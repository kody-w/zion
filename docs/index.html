<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ZION — A Living World</title>
  <meta name="description" content="A living world where human and artificial minds meet in peace.">

  <!-- Three.js & PeerJS from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <style>
    /* tokens.css */
:root {
  /* Colors - earthy, peaceful palette */
  --color-earth: #5C4033;
  --color-forest: #2D5016;
  --color-sky: #87CEEB;
  --color-dawn: #F4A460;
  --color-dusk: #8B6914;
  --color-night: #1a1a2e;
  --color-water: #4682B4;
  --color-stone: #808080;
  --color-sand: #C2B280;
  --color-gold: #DAA520;
  --color-crystal: #B0E0E6;

  /* UI Colors */
  --color-bg: #1a1a1a;
  --color-bg-panel: rgba(26, 26, 26, 0.85);
  --color-text: #E8E0D8;
  --color-text-muted: #A0978E;
  --color-accent: #DAA520;
  --color-success: #4CAF50;
  --color-warning: #FFA726;
  --color-error: #EF5350;
  --color-border: rgba(218, 165, 32, 0.3);

  /* Typography */
  --font-main: 'Georgia', 'Times New Roman', serif;
  --font-ui: system-ui, -apple-system, sans-serif;
  --font-mono: 'Courier New', monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
  --font-size-xxl: 2rem;

  /* Spacing */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-xxl: 3rem;

  /* Borders & Radius */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-round: 50%;

  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
  --shadow-lg: 0 10px 20px rgba(0,0,0,0.5);

  /* Z-Index */
  --z-world: 0;
  --z-hud: 100;
  --z-modal: 200;
  --z-notification: 300;
}


/* layout.css */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: var(--font-ui);
  font-size: var(--font-size-md);
  color: var(--color-text);
  background: var(--color-bg);
}

#game-container {
  position: relative;
  width: 100%;
  height: 100%;
}

#world-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-world);
}

#hud-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-hud);
  pointer-events: none;
}

#hud-container > * {
  pointer-events: auto;
}

#login-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--color-night);
  z-index: var(--z-modal);
}

/* Responsive */
@media (max-width: 768px) {
  :root {
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  :root {
    font-size: 12px;
  }
}


/* hud.css */
/* Chat Panel - Bottom Left */
.chat-panel {
  position: absolute;
  bottom: var(--space-md);
  left: var(--space-md);
  max-width: 300px;
  width: 100%;
  max-height: 40vh;
  display: flex;
  flex-direction: column;
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-sm);
  box-shadow: var(--shadow-md);
  transition: opacity 0.3s ease;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: var(--space-sm);
  font-size: var(--font-size-sm);
  line-height: 1.4;
  scroll-behavior: smooth;
}

.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-sm);
}

.chat-message {
  margin-bottom: var(--space-xs);
  word-wrap: break-word;
}

.chat-message .sender {
  color: var(--color-accent);
  font-weight: bold;
}

.chat-input {
  width: 100%;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-sm);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-size-sm);
  outline: none;
  transition: border-color 0.2s ease;
}

.chat-input:focus {
  border-color: var(--color-accent);
}

/* Player Info - Top Left */
.player-info {
  position: absolute;
  top: var(--space-md);
  left: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  box-shadow: var(--shadow-md);
  min-width: 200px;
  transition: opacity 0.3s ease;
}

.player-info-name {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-sm);
}

.player-info-stat {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-xs);
}

.player-info-stat strong {
  color: var(--color-text);
}

/* Minimap - Top Right */
.minimap {
  position: absolute;
  top: var(--space-md);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-sm);
  box-shadow: var(--shadow-md);
  transition: opacity 0.3s ease;
}

#minimap-canvas {
  display: block;
  border-radius: var(--radius-sm);
}

/* Zone Label - Top Center */
.zone-label {
  position: absolute;
  top: var(--space-lg);
  left: 50%;
  transform: translateX(-50%);
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-gold);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  opacity: 0.9;
  transition: opacity 0.5s ease;
}

/* Nearby List - Right Side */
.nearby-list {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  max-height: 50vh;
  overflow-y: auto;
  box-shadow: var(--shadow-md);
  min-width: 150px;
  transition: opacity 0.3s ease;
}

.nearby-list-title {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.nearby-player {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin-bottom: var(--space-xs);
  padding: var(--space-xs);
  border-radius: var(--radius-sm);
  transition: background 0.2s ease;
}

.nearby-player:hover {
  background: rgba(218, 165, 32, 0.1);
}

/* Notification - Centered Popup */
.notification {
  position: absolute;
  top: 30%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-accent);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-text);
  text-align: center;
  max-width: 400px;
  z-index: var(--z-notification);
  animation: fadeInOut 3s ease-in-out;
  pointer-events: none;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translate(-50%, -60%); }
  10% { opacity: 1; transform: translate(-50%, -50%); }
  90% { opacity: 1; transform: translate(-50%, -50%); }
  100% { opacity: 0; transform: translate(-50%, -40%); }
}

/* Break Reminder - Floating Message */
.break-reminder {
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(44, 80, 22, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-forest);
  border-radius: var(--radius-lg);
  padding: var(--space-md) var(--space-lg);
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-crystal);
  text-align: center;
  box-shadow: var(--shadow-md);
  animation: gentleFloat 4s ease-in-out infinite;
  pointer-events: none;
  z-index: var(--z-notification);
}

@keyframes gentleFloat {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-10px); }
}

/* Login Button */
.login-btn {
  background: var(--color-accent);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-md) var(--space-xl);
  font-family: var(--font-ui);
  font-size: var(--font-size-lg);
  font-weight: bold;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.2s ease;
  outline: none;
}

.login-btn:hover {
  background: var(--color-gold);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.login-btn:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

/* Intention Indicator */
.intention-indicator {
  position: absolute;
  bottom: var(--space-xl);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-round);
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--font-size-xl);
  box-shadow: var(--shadow-md);
  transition: all 0.3s ease;
}

.intention-indicator.active {
  border-color: var(--color-accent);
  box-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .chat-panel {
    max-width: 250px;
  }

  .player-info {
    min-width: 150px;
  }

  .nearby-list {
    display: none;
  }
}

@media (max-width: 480px) {
  .chat-panel {
    max-width: 200px;
    font-size: var(--font-size-xs);
  }

  .player-info {
    font-size: var(--font-size-xs);
  }

  .zone-label {
    font-size: var(--font-size-lg);
  }
}


/* world.css */
/* Portal Glow Effect */
.portal-glow {
  animation: portalPulse 2s ease-in-out infinite;
}

@keyframes portalPulse {
  0%, 100% {
    opacity: 0.6;
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
    filter: brightness(1.3);
  }
}

/* Loading Screen */
.loading-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--color-night);
  z-index: var(--z-modal);
  transition: opacity 0.5s ease;
}

.loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-spinner {
  width: 64px;
  height: 64px;
  border: 4px solid var(--color-border);
  border-top-color: var(--color-accent);
  border-radius: var(--radius-round);
  animation: spin 1s linear infinite;
  margin-bottom: var(--space-lg);
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.loading-text {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-text-muted);
  font-style: italic;
}

.loading-progress {
  margin-top: var(--space-md);
  font-size: var(--font-size-sm);
  color: var(--color-accent);
}

/* Player Label (floating above sprite) */
.player-label {
  position: absolute;
  transform: translate(-50%, -150%);
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-family: var(--font-ui);
  font-size: var(--font-size-xs);
  color: var(--color-text);
  white-space: nowrap;
  pointer-events: none;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  transition: opacity 0.3s ease;
}

.player-label.self {
  color: var(--color-accent);
  border-color: var(--color-accent);
}

.player-label.ai {
  color: var(--color-crystal);
  border-color: var(--color-water);
}

/* XR Warning Overlay */
.xr-warning {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(26, 26, 26, 0.95);
  z-index: var(--z-modal);
  padding: var(--space-xl);
  text-align: center;
}

.xr-warning-title {
  font-family: var(--font-main);
  font-size: var(--font-size-xxl);
  color: var(--color-warning);
  margin-bottom: var(--space-lg);
}

.xr-warning-text {
  font-size: var(--font-size-md);
  color: var(--color-text);
  max-width: 600px;
  line-height: 1.6;
  margin-bottom: var(--space-md);
}

.xr-warning-list {
  text-align: left;
  max-width: 500px;
  margin: var(--space-lg) auto;
  color: var(--color-text-muted);
  line-height: 1.8;
}

.xr-warning-list li {
  margin-bottom: var(--space-sm);
}

.xr-warning-btn {
  background: var(--color-warning);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-md) var(--space-xl);
  font-family: var(--font-ui);
  font-size: var(--font-size-lg);
  font-weight: bold;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.2s ease;
  margin-top: var(--space-lg);
}

.xr-warning-btn:hover {
  background: var(--color-dawn);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.xr-warning-btn:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

/* World Effects */
.zone-transition {
  animation: zoneTransition 1s ease-in-out;
}

@keyframes zoneTransition {
  0% { opacity: 1; }
  50% { opacity: 0.3; }
  100% { opacity: 1; }
}

.item-pickup {
  animation: itemPickup 0.5s ease-out;
}

@keyframes itemPickup {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: scale(0);
    opacity: 0;
  }
}

.spark-gain {
  animation: sparkGain 1s ease-out;
  color: var(--color-gold);
  font-weight: bold;
}

@keyframes sparkGain {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translateY(-50px) scale(1.5);
    opacity: 0;
  }
}

/* Environmental effects */
.weather-rain {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(transparent, rgba(135, 206, 235, 0.1));
  animation: rain 0.3s linear infinite;
}

@keyframes rain {
  0% { opacity: 0.5; }
  50% { opacity: 0.8; }
  100% { opacity: 0.5; }
}

.weather-night {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(26, 26, 46, 0.3);
  transition: opacity 2s ease;
}

/* Performance optimizations */
.gpu-accelerated {
  transform: translateZ(0);
  will-change: transform;
}

.fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.fade-out {
  animation: fadeOut 0.5s ease-out;
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}


  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="world-canvas"></canvas>

    <div id="hud-container">
      <div class="zone-label" id="zone-label">The Nexus</div>
      <div class="player-info" id="player-info"></div>
      <div class="minimap" id="minimap"><canvas id="minimap-canvas" width="150" height="150"></canvas></div>
      <div class="nearby-list" id="nearby-list"></div>
      <div class="chat-panel" id="chat-panel">
        <div class="chat-messages" id="chat-messages"></div>
        <input type="text" class="chat-input" id="chat-input" placeholder="Press Enter to chat..." />
      </div>
    </div>

    <div id="login-screen">
      <h1 style="font-family: var(--font-main); color: var(--color-gold); font-size: 3rem; margin-bottom: 0.5rem;">ZION</h1>
      <p style="color: var(--color-text-muted); margin-bottom: 2rem; font-style: italic;">A living world where human and artificial minds meet in peace.</p>
      <div id="login-options" style="display:flex; flex-direction:column; gap:1rem; align-items:center; width:320px;">
        <div style="display:flex; gap:0.5rem; width:100%;">
          <input type="text" id="guest-name" placeholder="Choose a name..." maxlength="39"
            style="flex:1; padding:0.75rem 1rem; border-radius:8px; border:1px solid var(--color-border);
            background:rgba(255,255,255,0.1); color:var(--color-text); font-size:1rem; outline:none;"
            onkeydown="if(event.key==='Enter'){document.getElementById('guest-btn').click()}" />
          <button class="login-btn" id="guest-btn" style="padding:0.75rem 1.25rem;"
            onclick="var n=document.getElementById('guest-name').value;if(Auth.loginAsGuest(n)){location.reload();}else{document.getElementById('guest-name').style.borderColor='#EF5350';}">Play</button>
        </div>
        <span style="color:var(--color-text-muted); font-size:0.8rem;">or</span>
        <button class="login-btn" id="login-btn" style="width:100%;"
          onclick="Auth.initiateOAuth()">Enter with GitHub</button>
      </div>
    </div>

    <div class="notification" id="notification" style="display:none;"></div>
  </div>

  <script>
    // protocol.js
// protocol.js — Universal message protocol for ZION
(function(exports) {
  'use strict';

  // Protocol version
  const PROTOCOL_VERSION = 1;

  // Valid message types
  const MESSAGE_TYPES = new Set([
    'join',
    'leave',
    'heartbeat',
    'idle',
    'move',
    'warp',
    'say',
    'shout',
    'whisper',
    'emote',
    'build',
    'plant',
    'craft',
    'compose',
    'harvest',
    'trade_offer',
    'trade_accept',
    'trade_decline',
    'buy',
    'sell',
    'gift',
    'teach',
    'learn',
    'mentor_offer',
    'mentor_accept',
    'challenge',
    'accept_challenge',
    'forfeit',
    'score',
    'discover',
    'anchor_place',
    'inspect',
    'intention_set',
    'intention_clear',
    'warp_fork',
    'return_home',
    'federation_announce',
    'federation_handshake'
  ]);

  // Message types that require consent
  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  // Valid platforms
  const PLATFORMS = new Set([
    'desktop',
    'phone',
    'vr',
    'ar',
    'api'
  ]);

  // Per-player sequence counter storage
  const sequenceCounters = new Map();

  /**
   * Get the next sequence number for a player
   * @param {string} playerId - The player ID
   * @returns {number} The next sequence number
   */
  function getNextSeq(playerId) {
    if (!sequenceCounters.has(playerId)) {
      sequenceCounters.set(playerId, 0);
    }
    const current = sequenceCounters.get(playerId);
    sequenceCounters.set(playerId, current + 1);
    return current;
  }

  /**
   * Generate a UUID v4
   * @returns {string} A UUID string
   */
  function generateUUID() {
    // Use crypto.randomUUID if available (Node 16.7+ and modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }

    // Fallback implementation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Generate an ISO-8601 timestamp
   * @returns {string} ISO-8601 formatted timestamp
   */
  function generateTimestamp() {
    return new Date().toISOString();
  }

  /**
   * Create a message object
   * @param {string} type - Message type (must be in MESSAGE_TYPES)
   * @param {string} from - Player ID sending the message
   * @param {object} payload - Message payload data
   * @param {object} opts - Optional fields (platform, position, geo)
   * @returns {object} Valid message object
   */
  function createMessage(type, from, payload, opts = {}) {
    if (!MESSAGE_TYPES.has(type)) {
      throw new Error(`Invalid message type: ${type}`);
    }

    if (!from || typeof from !== 'string') {
      throw new Error('Invalid from: must be a non-empty string');
    }

    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
      throw new Error('Invalid payload: must be an object');
    }

    const message = {
      v: PROTOCOL_VERSION,
      id: generateUUID(),
      ts: generateTimestamp(),
      seq: getNextSeq(from),
      from: from,
      type: type,
      platform: opts.platform || 'desktop',
      position: opts.position || { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: opts.geo || null,
      payload: payload
    };

    return message;
  }

  /**
   * Validate a message object
   * @param {object} msg - Message to validate
   * @returns {object} {valid: boolean, errors: string[]}
   */
  function validateMessage(msg) {
    const errors = [];

    // Check if msg is an object
    if (!msg || typeof msg !== 'object' || Array.isArray(msg)) {
      return { valid: false, errors: ['Message must be an object'] };
    }

    // Validate version
    if (msg.v !== PROTOCOL_VERSION) {
      errors.push(`Invalid version: expected ${PROTOCOL_VERSION}, got ${msg.v}`);
    }

    // Validate id
    if (!msg.id || typeof msg.id !== 'string') {
      errors.push('Invalid id: must be a non-empty string');
    }

    // Validate timestamp
    if (!msg.ts || typeof msg.ts !== 'string') {
      errors.push('Invalid ts: must be a non-empty string');
    } else {
      // Check if it's a valid ISO-8601 timestamp
      const date = new Date(msg.ts);
      if (isNaN(date.getTime())) {
        errors.push('Invalid ts: must be a valid ISO-8601 timestamp');
      }
    }

    // Validate sequence
    if (typeof msg.seq !== 'number' || msg.seq < 0 || !Number.isInteger(msg.seq)) {
      errors.push('Invalid seq: must be a non-negative integer');
    }

    // Validate from
    if (!msg.from || typeof msg.from !== 'string') {
      errors.push('Invalid from: must be a non-empty string');
    }

    // Validate type
    if (!MESSAGE_TYPES.has(msg.type)) {
      errors.push(`Invalid type: ${msg.type} is not a valid message type`);
    }

    // Validate platform
    if (!PLATFORMS.has(msg.platform)) {
      errors.push(`Invalid platform: ${msg.platform} is not a valid platform`);
    }

    // Validate position
    if (!msg.position || typeof msg.position !== 'object' || Array.isArray(msg.position)) {
      errors.push('Invalid position: must be an object');
    } else {
      if (typeof msg.position.x !== 'number') {
        errors.push('Invalid position.x: must be a number');
      }
      if (typeof msg.position.y !== 'number') {
        errors.push('Invalid position.y: must be a number');
      }
      if (typeof msg.position.z !== 'number') {
        errors.push('Invalid position.z: must be a number');
      }
      if (!msg.position.zone || typeof msg.position.zone !== 'string') {
        errors.push('Invalid position.zone: must be a non-empty string');
      }
    }

    // Validate geo (optional)
    if (msg.geo !== null && msg.geo !== undefined) {
      if (typeof msg.geo !== 'object' || Array.isArray(msg.geo)) {
        errors.push('Invalid geo: must be an object or null');
      } else {
        if (msg.geo.lat !== null && msg.geo.lat !== undefined && typeof msg.geo.lat !== 'number') {
          errors.push('Invalid geo.lat: must be a number or null');
        }
        if (msg.geo.lon !== null && msg.geo.lon !== undefined && typeof msg.geo.lon !== 'number') {
          errors.push('Invalid geo.lon: must be a number or null');
        }
      }
    }

    // Validate payload
    if (!msg.payload || typeof msg.payload !== 'object' || Array.isArray(msg.payload)) {
      errors.push('Invalid payload: must be an object');
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  // Export all functions and constants
  exports.PROTOCOL_VERSION = PROTOCOL_VERSION;
  exports.MESSAGE_TYPES = MESSAGE_TYPES;
  exports.CONSENT_REQUIRED_TYPES = CONSENT_REQUIRED_TYPES;
  exports.PLATFORMS = PLATFORMS;
  exports.createMessage = createMessage;
  exports.validateMessage = validateMessage;
  exports.getNextSeq = getNextSeq;
  exports.generateUUID = generateUUID;
  exports.generateTimestamp = generateTimestamp;

})(typeof module !== 'undefined' ? module.exports : (window.Protocol = {}));


// zones.js
// zones.js — Zone definitions and rule enforcement for ZION
(function(exports) {
  'use strict';

  // Zone definitions with complete metadata
  const ZONES = {
    nexus: {
      name: 'The Nexus',
      description: 'The central hub connecting all realms. A safe gathering place where travelers from all zones converge to trade, socialize, and plan their journeys.',
      terrain: 'crystalline plaza',
      bounds: { x_min: -100, x_max: 100, z_min: -100, z_max: 100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena']
    },

    gardens: {
      name: 'The Gardens',
      description: 'Lush botanical gardens filled with herbs, flowers, and fruit trees. A peaceful sanctuary for gathering natural resources and contemplation.',
      terrain: 'cultivated gardens',
      bounds: { x_min: 100, x_max: 500, z_min: -200, z_max: 200 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'wilds', 'athenaeum']
    },

    athenaeum: {
      name: 'The Athenaeum',
      description: 'A grand library and hall of learning. Scholars gather here to study, teach, and share knowledge across all disciplines.',
      terrain: 'marble halls',
      bounds: { x_min: -500, x_max: -100, z_min: 100, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'gardens', 'studio']
    },

    studio: {
      name: 'The Studio',
      description: 'A creative workshop where artists, composers, and craftspeople collaborate on their works. Inspiration flows freely in this space of artistic expression.',
      terrain: 'artisan workshops',
      bounds: { x_min: -500, x_max: -100, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'athenaeum', 'agora']
    },

    wilds: {
      name: 'The Wilds',
      description: 'Untamed wilderness filled with rare resources and natural wonders. Beautiful but unpredictable, explorers must be prepared for anything.',
      terrain: 'wilderness',
      bounds: { x_min: 500, x_max: 1000, z_min: -500, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: false
      },
      portals: ['nexus', 'gardens', 'arena']
    },

    agora: {
      name: 'The Agora',
      description: 'A bustling marketplace where merchants display their wares and traders negotiate deals. The commercial heart of the realm.',
      terrain: 'market square',
      bounds: { x_min: -200, x_max: 200, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'studio', 'commons']
    },

    commons: {
      name: 'The Commons',
      description: 'A collaborative building space where communities construct shared infrastructure and personal projects. A place of collective creation.',
      terrain: 'building grounds',
      bounds: { x_min: 100, x_max: 500, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: true,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'agora', 'arena']
    },

    arena: {
      name: 'The Arena',
      description: 'A proving ground for competitive challenges and contests of skill. Those seeking glory test themselves against worthy opponents.',
      terrain: 'combat grounds',
      bounds: { x_min: 500, x_max: 1000, z_min: 500, z_max: 1000 },
      rules: {
        pvp: true,
        building: false,
        harvesting: false,
        trading: false,
        competition: true,
        safe: false
      },
      portals: ['nexus', 'wilds', 'commons']
    }
  };

  // Action to rule mapping
  const ACTION_RULE_MAP = {
    build: 'building',
    plant: 'harvesting',
    harvest: 'harvesting',
    trade_offer: 'trading',
    trade_accept: 'trading',
    trade_decline: 'trading',
    buy: 'trading',
    sell: 'trading',
    challenge: 'competition_pvp', // Special: requires both competition AND pvp
    accept_challenge: 'competition_pvp'
  };

  /**
   * Get the rules for a specific zone
   * @param {string} zoneId - The zone identifier
   * @returns {object|null} Zone rules object or null if zone not found
   */
  function getZoneRules(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return null;
    }
    return zone.rules;
  }

  /**
   * Check if an action is allowed in a specific zone
   * @param {string} action - The action to check (message type)
   * @param {string} zoneId - The zone identifier
   * @returns {boolean} True if action is allowed, false otherwise
   */
  function isActionAllowed(action, zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return false;
    }

    const ruleKey = ACTION_RULE_MAP[action];

    // If no rule mapping exists, action is allowed by default
    if (!ruleKey) {
      return true;
    }

    // Special case: challenge/accept_challenge requires both competition AND pvp
    if (ruleKey === 'competition_pvp') {
      return zone.rules.competition === true && zone.rules.pvp === true;
    }

    // Check the mapped rule
    return zone.rules[ruleKey] === true;
  }

  /**
   * Get all zones connected to a specific zone via portals
   * @param {string} zoneId - The zone identifier
   * @returns {string[]} Array of connected zone IDs
   */
  function getConnectedZones(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return [];
    }
    return zone.portals || [];
  }

  /**
   * Get the spawn zone for new players
   * @returns {string} The spawn zone ID
   */
  function getSpawnZone() {
    return 'nexus';
  }

  /**
   * Get complete zone information
   * @param {string} zoneId - The zone identifier
   * @returns {object|null} Complete zone data or null if not found
   */
  function getZone(zoneId) {
    return ZONES[zoneId] || null;
  }

  /**
   * Get all zone IDs
   * @returns {string[]} Array of all zone identifiers
   */
  function getAllZoneIds() {
    return Object.keys(ZONES);
  }

  /**
   * Check if a zone exists
   * @param {string} zoneId - The zone identifier
   * @returns {boolean} True if zone exists
   */
  function zoneExists(zoneId) {
    return ZONES.hasOwnProperty(zoneId);
  }

  // Export all functions and constants
  exports.ZONES = ZONES;
  exports.getZoneRules = getZoneRules;
  exports.isActionAllowed = isActionAllowed;
  exports.getConnectedZones = getConnectedZones;
  exports.getSpawnZone = getSpawnZone;
  exports.getZone = getZone;
  exports.getAllZoneIds = getAllZoneIds;
  exports.zoneExists = zoneExists;

})(typeof module !== 'undefined' ? module.exports : (window.Zones = {}));


// economy.js
/**
 * ZION Economy System - Spark Ledger & Trading
 * Layer 1 - No project dependencies
 */

(function(exports) {
  'use strict';

  // Earn table: activity → Spark amount or [min, max]
  const EARN_TABLE = {
    daily_login: 10,
    harvest: [5, 15],
    craft: [5, 50],
    teach: [10, 30],
    discover: [5, 25],
    puzzle: [10, 100],
    perform: [5, 20],
    competition_win: [10, 100],
    build: [10, 50],
    mentor: 50,
    anchor_visit: [1, 5],
    gift: [1, 3]
  };

  let transactionCounter = 0;
  let listingCounter = 0;

  /**
   * Creates a new ledger instance
   * @returns {Object} Ledger with balances, transactions, and listings
   */
  function createLedger() {
    return {
      balances: {},
      transactions: [],
      listings: []
    };
  }

  /**
   * Calculates Spark amount based on activity and details
   * @param {string} activity - Activity type
   * @param {Object} details - Activity details (may include complexity/rarity 0-1)
   * @returns {number} Calculated Spark amount
   */
  function calculateEarnAmount(activity, details = {}) {
    const earnValue = EARN_TABLE[activity];

    if (!earnValue) {
      return 0;
    }

    // Fixed amount
    if (typeof earnValue === 'number') {
      return earnValue;
    }

    // Range [min, max] - interpolate based on complexity or rarity
    if (Array.isArray(earnValue) && earnValue.length === 2) {
      const [min, max] = earnValue;
      const factor = details.complexity !== undefined ? details.complexity :
                     details.rarity !== undefined ? details.rarity : 0.5;

      // Clamp factor to [0, 1]
      const clampedFactor = Math.max(0, Math.min(1, factor));
      return Math.round(min + (max - min) * clampedFactor);
    }

    return 0;
  }

  /**
   * Records a transaction in the ledger
   * @param {Object} ledger - Ledger instance
   * @param {string} from - Sender ID (or 'SYSTEM' for earnings)
   * @param {string} to - Recipient ID
   * @param {number} amount - Spark amount
   * @param {string} type - Transaction type
   * @param {Object} details - Additional details
   */
  function recordTransaction(ledger, from, to, amount, type, details = {}) {
    const transaction = {
      id: `tx_${transactionCounter++}_${Date.now()}`,
      ts: Date.now(),
      from,
      to,
      amount,
      type,
      details
    };
    ledger.transactions.push(transaction);
    return transaction;
  }

  /**
   * Earns Spark for a player - THE ONLY WAY TO CREATE SPARK
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @param {string} activity - Activity type from EARN_TABLE
   * @param {Object} details - Activity details
   * @returns {number} Amount earned
   */
  function earnSpark(ledger, playerId, activity, details = {}) {
    const amount = calculateEarnAmount(activity, details);

    if (amount <= 0) {
      return 0;
    }

    // Initialize balance if needed
    if (!ledger.balances[playerId]) {
      ledger.balances[playerId] = 0;
    }

    // Credit the player
    ledger.balances[playerId] += amount;

    // Record transaction
    recordTransaction(ledger, 'SYSTEM', playerId, amount, 'earn', {
      activity,
      ...details
    });

    return amount;
  }

  /**
   * Spends Spark from a player's balance
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @param {number} amount - Amount to spend
   * @returns {Object} {success: boolean, balance: number}
   */
  function spendSpark(ledger, playerId, amount) {
    const currentBalance = getBalance(ledger, playerId);

    if (amount <= 0) {
      return { success: false, balance: currentBalance };
    }

    if (currentBalance < amount) {
      return { success: false, balance: currentBalance };
    }

    // Deduct from balance
    ledger.balances[playerId] -= amount;

    // Record transaction
    recordTransaction(ledger, playerId, 'SYSTEM', amount, 'spend', {});

    return { success: true, balance: ledger.balances[playerId] };
  }

  /**
   * Transfers Spark between players
   * @param {Object} ledger - Ledger instance
   * @param {string} from - Sender player ID
   * @param {string} to - Recipient player ID
   * @param {number} amount - Amount to transfer
   * @returns {Object} {success: boolean}
   */
  function transferSpark(ledger, from, to, amount) {
    if (amount <= 0) {
      return { success: false };
    }

    const senderBalance = getBalance(ledger, from);
    if (senderBalance < amount) {
      return { success: false };
    }

    // Initialize recipient balance if needed
    if (!ledger.balances[to]) {
      ledger.balances[to] = 0;
    }

    // Perform transfer
    ledger.balances[from] -= amount;
    ledger.balances[to] += amount;

    // Record transaction
    recordTransaction(ledger, from, to, amount, 'transfer', {});

    return { success: true };
  }

  /**
   * Gets a player's current Spark balance
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @returns {number} Current balance (0 if not found)
   */
  function getBalance(ledger, playerId) {
    return ledger.balances[playerId] || 0;
  }

  /**
   * Creates a market listing
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Seller player ID
   * @param {Object} item - Item being sold
   * @param {number} price - Price in Spark
   * @returns {Object} Listing object
   */
  function createMarketListing(ledger, playerId, item, price) {
    const listing = {
      id: `listing_${listingCounter++}_${Date.now()}`,
      seller: playerId,
      item,
      price,
      ts: Date.now(),
      active: true
    };

    ledger.listings.push(listing);
    return listing;
  }

  /**
   * Buys a market listing
   * @param {Object} ledger - Ledger instance
   * @param {string} buyerId - Buyer player ID
   * @param {string} listingId - Listing ID
   * @returns {Object} {success: boolean, item?: Object}
   */
  function buyListing(ledger, buyerId, listingId) {
    // Find the listing
    const listing = ledger.listings.find(l => l.id === listingId && l.active);

    if (!listing) {
      return { success: false };
    }

    // Check buyer's balance
    const buyerBalance = getBalance(ledger, buyerId);
    if (buyerBalance < listing.price) {
      return { success: false };
    }

    // Prevent self-purchase
    if (buyerId === listing.seller) {
      return { success: false };
    }

    // Initialize seller balance if needed
    if (!ledger.balances[listing.seller]) {
      ledger.balances[listing.seller] = 0;
    }

    // Transfer Spark from buyer to seller
    ledger.balances[buyerId] -= listing.price;
    ledger.balances[listing.seller] += listing.price;

    // Mark listing as inactive
    listing.active = false;

    // Record transaction
    recordTransaction(ledger, buyerId, listing.seller, listing.price, 'market_purchase', {
      listingId,
      item: listing.item
    });

    return { success: true, item: listing.item };
  }

  /**
   * Gets transaction log for a player
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @returns {Array} Array of transactions
   */
  function getTransactionLog(ledger, playerId) {
    return ledger.transactions.filter(tx =>
      tx.from === playerId || tx.to === playerId
    );
  }

  // Export public API
  exports.createLedger = createLedger;
  exports.earnSpark = earnSpark;
  exports.spendSpark = spendSpark;
  exports.transferSpark = transferSpark;
  exports.getBalance = getBalance;
  exports.createMarketListing = createMarketListing;
  exports.buyListing = buyListing;
  exports.getTransactionLog = getTransactionLog;
  exports.EARN_TABLE = EARN_TABLE;

})(typeof module !== 'undefined' ? module.exports : (window.Economy = {}));


// state.js
/**
 * ZION State Management System - Three-tier state management
 * Layer 2 - Self-contained (conceptually depends on protocol.js)
 */

(function(exports) {
  'use strict';

  // In-memory live state
  let liveState = null;

  /**
   * Creates initial world state with all required keys
   * @returns {Object} Initial world state
   */
  function createWorldState() {
    return {
      world: {
        time: 0,
        weather: 'clear',
        season: 'spring',
        dayPhase: 'day'
      },
      players: {},
      economy: {
        balances: {},
        transactions: [],
        listings: []
      },
      gardens: {},
      structures: {},
      discoveries: {},
      anchors: {},
      chat: [],
      actions: [],
      changes: [],
      competitions: {},
      federation: {
        federations: []
      }
    };
  }

  /**
   * Gets current live state
   * @returns {Object} Current in-memory state
   */
  function getLiveState() {
    if (!liveState) {
      liveState = createWorldState();
    }
    return liveState;
  }

  /**
   * Sets a value at a dot-separated path in live state
   * @param {string} path - Dot-separated path (e.g., 'world.time')
   * @param {*} value - Value to set
   */
  function setLiveState(path, value) {
    if (!liveState) {
      liveState = createWorldState();
    }

    const parts = path.split('.');
    let current = liveState;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }

    current[parts[parts.length - 1]] = value;
  }

  /**
   * Flushes live state to localStorage
   */
  function flushToLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const state = getLiveState();
      localStorage.setItem('zion_state', JSON.stringify(state));
    } catch (e) {
      console.error('Failed to flush to localStorage:', e);
    }
  }

  /**
   * Loads state from localStorage to live state
   */
  function loadFromLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const stored = localStorage.getItem('zion_state');
      if (stored) {
        liveState = JSON.parse(stored);
      } else {
        liveState = createWorldState();
      }
    } catch (e) {
      console.error('Failed to load from localStorage:', e);
      liveState = createWorldState();
    }
  }

  /**
   * Flushes to canonical JSON string
   * @returns {string} JSON string of current state
   */
  function flushToCanonical() {
    const state = getLiveState();
    return JSON.stringify(state);
  }

  /**
   * Loads from canonical JSON string
   * @param {string} json - JSON string
   */
  function loadFromCanonical(json) {
    try {
      liveState = JSON.parse(json);
    } catch (e) {
      console.error('Failed to parse canonical state:', e);
      liveState = createWorldState();
    }
  }

  /**
   * Applies a protocol message to state (PURE function)
   * @param {Object} state - Current state
   * @param {Object} message - Protocol message
   * @returns {Object} New state
   */
  function applyMessage(state, message) {
    // Deep clone state for immutability
    const newState = JSON.parse(JSON.stringify(state));

    const { type, from, payload } = message;
    const timestamp = message.ts || Date.now();

    switch (type) {
      case 'join':
        newState.players[from] = {
          id: from,
          name: payload.name || from,
          position: payload.position || { x: 0, y: 0, z: 0 },
          zone: payload.zone || 'default',
          online: true,
          last_seen: timestamp,
          idle: false,
          inventory: [],
          intentions: [],
          ...payload
        };
        break;

      case 'leave':
        if (newState.players[from]) {
          newState.players[from].online = false;
          newState.players[from].last_seen = timestamp;
        }
        break;

      case 'heartbeat':
        if (newState.players[from]) {
          newState.players[from].last_seen = timestamp;
          newState.players[from].idle = false;
        }
        break;

      case 'idle':
        if (newState.players[from]) {
          newState.players[from].idle = true;
        }
        break;

      case 'move':
        if (newState.players[from] && payload.position) {
          newState.players[from].position = payload.position;
        }
        break;

      case 'warp':
        if (newState.players[from]) {
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
          if (payload.zone) {
            newState.players[from].zone = payload.zone;
          }
        }
        break;

      case 'say':
      case 'shout':
      case 'whisper':
      case 'emote':
        newState.chat.push({
          id: `chat_${timestamp}_${from}`,
          type,
          from,
          to: payload.to,
          text: payload.text || payload.message || '',
          ts: timestamp
        });
        break;

      case 'build':
        if (payload.structure) {
          const structureId = `struct_${timestamp}_${from}`;
          newState.structures[structureId] = {
            id: structureId,
            builder: from,
            type: payload.structure.type,
            position: payload.structure.position,
            data: payload.structure.data || {},
            ts: timestamp
          };
        }
        break;

      case 'plant':
        if (payload.plant) {
          const gardenId = `garden_${timestamp}_${from}`;
          newState.gardens[gardenId] = {
            id: gardenId,
            gardener: from,
            plant: payload.plant.type,
            position: payload.plant.position,
            planted_at: timestamp,
            ready_at: timestamp + (payload.plant.grow_time || 60000),
            ready: false
          };
        }
        break;

      case 'harvest':
        if (payload.gardenId && newState.gardens[payload.gardenId]) {
          const garden = newState.gardens[payload.gardenId];
          if (garden.ready || timestamp >= garden.ready_at) {
            delete newState.gardens[payload.gardenId];
            // Add harvested item to player inventory
            if (newState.players[from] && newState.players[from].inventory) {
              newState.players[from].inventory.push({
                type: garden.plant,
                harvested_at: timestamp
              });
            }
          }
        }
        break;

      case 'craft':
        if (payload.item && newState.players[from]) {
          if (!newState.players[from].inventory) {
            newState.players[from].inventory = [];
          }
          newState.players[from].inventory.push({
            type: payload.item.type,
            crafted_at: timestamp,
            data: payload.item.data || {}
          });
        }
        break;

      case 'compose':
        if (payload.art) {
          const artId = `art_${timestamp}_${from}`;
          newState.structures[artId] = {
            id: artId,
            artist: from,
            type: 'art',
            art_type: payload.art.type,
            position: payload.art.position,
            data: payload.art.data || {},
            ts: timestamp
          };
        }
        break;

      case 'trade_offer':
        newState.actions.push({
          id: `trade_${timestamp}_${from}`,
          type: 'trade_offer',
          from,
          to: payload.to,
          offered: payload.offered || [],
          requested: payload.requested || [],
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'trade_accept':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'accepted';
            trade.completed_at = timestamp;
            // Exchange items between players
            if (newState.players[trade.from] && newState.players[trade.to]) {
              // This is simplified - real implementation would transfer items
            }
          }
        }
        break;

      case 'trade_decline':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'declined';
            trade.completed_at = timestamp;
          }
        }
        break;

      case 'buy':
        // Market buy operation - would integrate with economy ledger
        newState.actions.push({
          id: `buy_${timestamp}_${from}`,
          type: 'buy',
          buyer: from,
          listingId: payload.listingId,
          ts: timestamp
        });
        break;

      case 'sell':
        // Market sell operation - would integrate with economy ledger
        newState.actions.push({
          id: `sell_${timestamp}_${from}`,
          type: 'sell',
          seller: from,
          item: payload.item,
          price: payload.price,
          ts: timestamp
        });
        break;

      case 'gift':
        if (payload.to && payload.item) {
          newState.actions.push({
            id: `gift_${timestamp}_${from}`,
            type: 'gift',
            from,
            to: payload.to,
            item: payload.item,
            ts: timestamp
          });
          // Transfer item from sender to recipient
          if (newState.players[from] && newState.players[payload.to]) {
            if (!newState.players[payload.to].inventory) {
              newState.players[payload.to].inventory = [];
            }
            newState.players[payload.to].inventory.push({
              ...payload.item,
              gifted_from: from,
              gifted_at: timestamp
            });
          }
        }
        break;

      case 'teach':
        newState.actions.push({
          id: `teach_${timestamp}_${from}`,
          type: 'teach',
          teacher: from,
          student: payload.to,
          skill: payload.skill,
          ts: timestamp
        });
        break;

      case 'learn':
        newState.actions.push({
          id: `learn_${timestamp}_${from}`,
          type: 'learn',
          learner: from,
          skill: payload.skill,
          source: payload.source,
          ts: timestamp
        });
        break;

      case 'mentor_offer':
        newState.actions.push({
          id: `mentor_${timestamp}_${from}`,
          type: 'mentor_offer',
          mentor: from,
          mentee: payload.to,
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'mentor_accept':
        if (payload.mentorId) {
          const mentorship = newState.actions.find(a => a.id === payload.mentorId);
          if (mentorship && mentorship.type === 'mentor_offer') {
            mentorship.status = 'accepted';
            mentorship.accepted_at = timestamp;
          }
        }
        break;

      case 'challenge':
        const challengeId = `challenge_${timestamp}_${from}`;
        newState.competitions[challengeId] = {
          id: challengeId,
          challenger: from,
          challenged: payload.to,
          type: payload.challenge_type,
          status: 'pending',
          ts: timestamp
        };
        break;

      case 'accept_challenge':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'active';
          newState.competitions[payload.challengeId].accepted_at = timestamp;
        }
        break;

      case 'forfeit':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'forfeited';
          newState.competitions[payload.challengeId].forfeited_by = from;
          newState.competitions[payload.challengeId].completed_at = timestamp;
        }
        break;

      case 'score':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          const comp = newState.competitions[payload.challengeId];
          if (!comp.scores) {
            comp.scores = {};
          }
          comp.scores[from] = payload.score;
        }
        break;

      case 'discover':
        if (payload.discovery) {
          const discoveryId = `discovery_${timestamp}_${from}`;
          newState.discoveries[discoveryId] = {
            id: discoveryId,
            discoverer: from,
            type: payload.discovery.type,
            location: payload.discovery.location,
            data: payload.discovery.data || {},
            ts: timestamp
          };
        }
        break;

      case 'anchor_place':
        if (payload.anchor) {
          const anchorId = `anchor_${timestamp}_${from}`;
          newState.anchors[anchorId] = {
            id: anchorId,
            owner: from,
            position: payload.anchor.position,
            zone: payload.anchor.zone || 'default',
            name: payload.anchor.name,
            ts: timestamp
          };
        }
        break;

      case 'inspect':
        // No state change - returns info only
        break;

      case 'intention_set':
        if (newState.players[from] && payload.intention) {
          if (!newState.players[from].intentions) {
            newState.players[from].intentions = [];
          }
          newState.players[from].intentions.push({
            text: payload.intention,
            set_at: timestamp
          });
        }
        break;

      case 'intention_clear':
        if (newState.players[from]) {
          newState.players[from].intentions = [];
        }
        break;

      case 'warp_fork':
        if (newState.players[from] && payload.target_world) {
          newState.players[from].current_world = payload.target_world;
          newState.players[from].home_world = newState.players[from].home_world || 'default';
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'return_home':
        if (newState.players[from]) {
          const homeWorld = newState.players[from].home_world || 'default';
          newState.players[from].current_world = homeWorld;
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'federation_announce':
        if (payload.federation) {
          newState.federation.federations.push({
            id: `fed_${timestamp}_${from}`,
            announced_by: from,
            name: payload.federation.name,
            endpoint: payload.federation.endpoint,
            ts: timestamp
          });
        }
        break;

      case 'federation_handshake':
        if (payload.federationId) {
          const fed = newState.federation.federations.find(f => f.id === payload.federationId);
          if (fed) {
            fed.handshake_complete = true;
            fed.handshake_at = timestamp;
          }
        }
        break;

      default:
        // Unknown message type - no state change
        break;
    }

    // Record state change
    newState.changes.push({
      type,
      from,
      ts: timestamp
    });

    return newState;
  }

  /**
   * Resolves conflicts between two states using last-writer-wins
   * @param {Object} stateA - First state
   * @param {Object} stateB - Second state
   * @returns {Object} Merged state
   */
  function resolveConflict(stateA, stateB) {
    // Start with a deep clone of stateA
    const merged = JSON.parse(JSON.stringify(stateA));

    // Merge changes arrays and sort by timestamp
    const allChanges = [
      ...(stateA.changes || []),
      ...(stateB.changes || [])
    ].sort((a, b) => a.ts - b.ts);

    // Remove duplicates
    const uniqueChanges = [];
    const seen = new Set();
    for (const change of allChanges) {
      const key = `${change.type}_${change.from}_${change.ts}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueChanges.push(change);
      }
    }

    merged.changes = uniqueChanges;

    // Merge players (last-writer-wins based on last_seen)
    merged.players = { ...stateA.players };
    for (const [playerId, playerB] of Object.entries(stateB.players || {})) {
      const playerA = merged.players[playerId];
      if (!playerA || (playerB.last_seen || 0) > (playerA.last_seen || 0)) {
        merged.players[playerId] = playerB;
      }
    }

    // Merge collections (combine and deduplicate by ID)
    const mergeById = (collectionA, collectionB) => {
      const result = { ...collectionA };
      for (const [id, item] of Object.entries(collectionB || {})) {
        if (!result[id] || (item.ts || 0) > (result[id].ts || 0)) {
          result[id] = item;
        }
      }
      return result;
    };

    merged.gardens = mergeById(stateA.gardens || {}, stateB.gardens || {});
    merged.structures = mergeById(stateA.structures || {}, stateB.structures || {});
    merged.discoveries = mergeById(stateA.discoveries || {}, stateB.discoveries || {});
    merged.anchors = mergeById(stateA.anchors || {}, stateB.anchors || {});
    merged.competitions = mergeById(stateA.competitions || {}, stateB.competitions || {});

    // Merge chat (combine and sort by timestamp)
    merged.chat = [
      ...(stateA.chat || []),
      ...(stateB.chat || [])
    ].sort((a, b) => a.ts - b.ts);

    // Merge actions (combine and deduplicate)
    merged.actions = [
      ...(stateA.actions || []),
      ...(stateB.actions || [])
    ];
    const actionIds = new Set();
    merged.actions = merged.actions.filter(action => {
      if (actionIds.has(action.id)) {
        return false;
      }
      actionIds.add(action.id);
      return true;
    });

    // Merge economy (combine transactions and listings)
    merged.economy = {
      balances: { ...(stateA.economy?.balances || {}), ...(stateB.economy?.balances || {}) },
      transactions: [
        ...(stateA.economy?.transactions || []),
        ...(stateB.economy?.transactions || [])
      ].sort((a, b) => a.ts - b.ts),
      listings: [
        ...(stateA.economy?.listings || []),
        ...(stateB.economy?.listings || [])
      ]
    };

    // Merge federation
    merged.federation = {
      federations: [
        ...(stateA.federation?.federations || []),
        ...(stateB.federation?.federations || [])
      ]
    };

    // World state - use most recent
    const worldATime = stateA.world?.time || 0;
    const worldBTime = stateB.world?.time || 0;
    merged.world = worldBTime > worldATime ? stateB.world : stateA.world;

    return merged;
  }

  // Export public API
  exports.createWorldState = createWorldState;
  exports.getLiveState = getLiveState;
  exports.setLiveState = setLiveState;
  exports.flushToLocal = flushToLocal;
  exports.loadFromLocal = loadFromLocal;
  exports.flushToCanonical = flushToCanonical;
  exports.loadFromCanonical = loadFromCanonical;
  exports.applyMessage = applyMessage;
  exports.resolveConflict = resolveConflict;

})(typeof module !== 'undefined' ? module.exports : (window.State = {}));


// intentions.js
/**
 * ZION MMO - Intention System Engine (Layer 2)
 *
 * Allows players (especially AI) to declare conditional rules that auto-execute.
 * Core mechanic for AI player viability in real-time gameplay.
 */

(function(exports) {
  'use strict';

  // Internal store: playerId -> intentions[]
  const intentionStore = new Map();

  // Consent-required action types (actions that need explicit permission)
  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  const MAX_INTENTIONS_PER_PLAYER = 10;

  /**
   * Register a new intention for a player
   * @param {string} playerId - The player ID
   * @param {Object} intention - The intention object
   * @returns {Object} {success: boolean, error?: string}
   */
  function registerIntention(playerId, intention) {
    // Validate intention format
    if (!intention.id || typeof intention.id !== 'string') {
      return { success: false, error: 'Intention must have a valid id' };
    }

    if (!intention.trigger || typeof intention.trigger !== 'object') {
      return { success: false, error: 'Intention must have a trigger object' };
    }

    if (!intention.trigger.condition || typeof intention.trigger.condition !== 'string') {
      return { success: false, error: 'Trigger must have a condition string' };
    }

    if (!intention.trigger.params || typeof intention.trigger.params !== 'object') {
      return { success: false, error: 'Trigger must have a params object' };
    }

    if (!intention.action || typeof intention.action !== 'object') {
      return { success: false, error: 'Intention must have an action object' };
    }

    if (!intention.action.type || typeof intention.action.type !== 'string') {
      return { success: false, error: 'Action must have a type string' };
    }

    if (!intention.action.params || typeof intention.action.params !== 'object') {
      return { success: false, error: 'Action must have a params object' };
    }

    if (typeof intention.priority !== 'number') {
      return { success: false, error: 'Intention must have a numeric priority' };
    }

    if (typeof intention.ttl !== 'number') {
      return { success: false, error: 'Intention must have a numeric ttl' };
    }

    if (typeof intention.cooldown !== 'number') {
      return { success: false, error: 'Intention must have a numeric cooldown' };
    }

    if (typeof intention.max_fires !== 'number') {
      return { success: false, error: 'Intention must have a numeric max_fires' };
    }

    // Check max intentions limit
    const playerIntentions = intentionStore.get(playerId) || [];
    if (playerIntentions.length >= MAX_INTENTIONS_PER_PLAYER) {
      return { success: false, error: `Maximum ${MAX_INTENTIONS_PER_PLAYER} intentions per player exceeded` };
    }

    // Add internal tracking fields
    const intentionWithMeta = {
      ...intention,
      createdAt: Date.now(),
      lastFired: null,
      fireCount: 0
    };

    playerIntentions.push(intentionWithMeta);
    intentionStore.set(playerId, playerIntentions);

    return { success: true };
  }

  /**
   * Clear all intentions for a player
   * @param {string} playerId - The player ID
   */
  function clearIntentions(playerId) {
    intentionStore.delete(playerId);
  }

  /**
   * Get all intentions for a player (public - anyone can read)
   * @param {string} playerId - The player ID
   * @returns {Array} Array of intentions
   */
  function getIntentions(playerId) {
    return intentionStore.get(playerId) || [];
  }

  /**
   * Check if an intention has expired
   * @param {Object} intention - The intention object
   * @param {number} now - Current timestamp
   * @returns {boolean}
   */
  function isIntentionExpired(intention, now) {
    return (now - intention.createdAt) > (intention.ttl * 1000);
  }

  /**
   * Check if an intention can fire
   * @param {Object} intention - The intention object
   * @param {number} now - Current timestamp
   * @returns {boolean}
   */
  function canIntentionFire(intention, now) {
    // Check max fires limit
    if (intention.fireCount >= intention.max_fires) {
      return false;
    }

    // Check cooldown
    if (intention.lastFired !== null) {
      const timeSinceLastFire = now - intention.lastFired;
      if (timeSinceLastFire < (intention.cooldown * 1000)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Trigger evaluators
   */
  const triggerEvaluators = {
    /**
     * Check if a player is nearby
     */
    player_nearby: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const onlyUnknown = params.known === false;

      for (const [playerId, player] of worldState.players.entries()) {
        if (playerId === ownerId) continue;
        if (!player.position) continue;

        const distance = getDistance(owner.position, player.position);
        if (distance < distanceLimit) {
          // If we only want unknown players, check if this player is known
          if (onlyUnknown) {
            // Assume players are known if they're in the owner's known list
            const knownPlayers = owner.knownPlayers || new Set();
            if (!knownPlayers.has(playerId)) {
              return true;
            }
          } else {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Check if a player said a keyword nearby
     */
    player_say: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const keyword = params.keyword;
      const distanceLimit = params.distance_lt || 20;
      const recentChats = worldState.recentChats || [];

      // Check recent chat messages
      for (const chat of recentChats) {
        if (chat.from === ownerId) continue;

        const speaker = worldState.players.get(chat.from);
        if (!speaker || !speaker.position) continue;

        const distance = getDistance(owner.position, speaker.position);
        if (distance < distanceLimit) {
          if (chat.message && chat.message.toLowerCase().includes(keyword.toLowerCase())) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Timer trigger - fires every interval
     */
    timer: function(params, worldState, ownerId, intention, now) {
      const intervalMs = params.interval_seconds * 1000;

      // If never fired, fire immediately
      if (intention.lastFired === null) {
        return true;
      }

      // Check if enough time has passed
      return (now - intention.lastFired) >= intervalMs;
    },

    /**
     * Zone enter trigger
     */
    zone_enter: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      return owner.position.zone === params.zone_id;
    },

    /**
     * Garden needs attention trigger
     */
    garden_needs: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const gardens = worldState.gardens || [];

      for (const garden of gardens) {
        if (!garden.position) continue;

        const distance = getDistance(owner.position, garden.position);
        if (distance < distanceLimit) {
          // Check if garden needs attention
          if (garden.needsWater || garden.needsHarvest || garden.needsWeeding) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Resource ready for harvest trigger
     */
    resource_ready: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const resources = worldState.resources || [];

      for (const resource of resources) {
        if (!resource.position) continue;
        if (!resource.harvestable) continue;

        const distance = getDistance(owner.position, resource.position);
        if (distance < distanceLimit) {
          return true;
        }
      }

      return false;
    }
  };

  /**
   * Calculate Euclidean distance between two 3D positions
   */
  function getDistance(posA, posB) {
    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  /**
   * Generate action message from intention
   */
  function generateActionMessage(intention, playerId, worldState) {
    const action = intention.action;
    const player = worldState.players.get(playerId);

    if (!player) return null;

    // Check if this action requires consent - if so, skip it
    if (CONSENT_REQUIRED_TYPES.has(action.type)) {
      return null;
    }

    // Base message structure
    const message = {
      type: action.type,
      from: playerId,
      payload: { ...action.params },
      position: player.position ? { ...player.position } : null
    };

    return message;
  }

  /**
   * Evaluate all triggers for a player and generate actions
   * @param {string} playerId - The player ID
   * @param {Object} worldState - Current world state
   * @param {number} deltaTime - Time since last evaluation (unused currently)
   * @returns {Array} Array of action messages to execute
   */
  function evaluateTriggers(playerId, worldState, deltaTime) {
    const intentions = intentionStore.get(playerId) || [];
    const now = Date.now();
    const actions = [];

    // Sort by priority (higher priority first)
    const sortedIntentions = [...intentions].sort((a, b) => b.priority - a.priority);

    for (const intention of sortedIntentions) {
      // Check if expired
      if (isIntentionExpired(intention, now)) {
        continue;
      }

      // Check if can fire
      if (!canIntentionFire(intention, now)) {
        continue;
      }

      // Evaluate trigger
      const triggerType = intention.trigger.condition;
      const evaluator = triggerEvaluators[triggerType];

      if (!evaluator) {
        // Stub for unknown triggers
        continue;
      }

      let triggered = false;
      try {
        triggered = evaluator(
          intention.trigger.params,
          worldState,
          playerId,
          intention,
          now
        );
      } catch (error) {
        // Silently skip failed evaluations
        continue;
      }

      if (triggered) {
        // Generate action message
        const actionMessage = generateActionMessage(intention, playerId, worldState);

        if (actionMessage) {
          actions.push(actionMessage);

          // Update firing metadata
          intention.lastFired = now;
          intention.fireCount++;
        }
      }
    }

    return actions;
  }

  // Export public API
  exports.registerIntention = registerIntention;
  exports.clearIntentions = clearIntentions;
  exports.getIntentions = getIntentions;
  exports.evaluateTriggers = evaluateTriggers;
  exports.isIntentionExpired = isIntentionExpired;
  exports.canIntentionFire = canIntentionFire;

})(typeof module !== 'undefined' ? module.exports : (window.Intentions = {}));


// social.js
/**
 * ZION MMO - Social Module (Layer 3)
 *
 * Handles chat, emotes, and consent tracking for player interactions.
 */

(function(exports) {
  'use strict';

  // Internal stores
  const consentStore = new Map(); // "${fromId}:${toId}:${type}" -> boolean
  const rateLimitStore = new Map(); // playerId -> {count, windowStart}

  // Constants
  const RATE_LIMIT_MAX = 30; // messages per window
  const RATE_LIMIT_WINDOW = 60000; // 60 seconds in milliseconds
  const SAY_DISTANCE = 20;
  const EMOTE_DISTANCE = 30;

  /**
   * Calculate Euclidean distance between two 3D positions
   */
  function getDistance(posA, posB) {
    if (!posA || !posB) return Infinity;

    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  /**
   * Get all players within a certain distance
   * @param {Object} position - The center position {x, y, z, zone}
   * @param {Object} state - World state with players map
   * @param {number} maxDistance - Maximum distance
   * @returns {Array} Array of player IDs
   */
  function getNearbyPlayers(position, state, maxDistance) {
    const nearby = [];

    if (!position || !state.players) return nearby;

    for (const [playerId, player] of state.players.entries()) {
      if (!player.position) continue;

      // Must be in same zone
      if (player.position.zone !== position.zone) continue;

      const distance = getDistance(position, player.position);
      if (distance <= maxDistance) {
        nearby.push(playerId);
      }
    }

    return nearby;
  }

  /**
   * Check rate limit for a player
   * @param {string} playerId - The player ID
   * @param {number} now - Current timestamp
   * @returns {Object} {allowed: boolean, retryAfter?: number}
   */
  function checkRateLimit(playerId, now) {
    const limit = rateLimitStore.get(playerId);

    if (!limit) {
      // First message, create new window
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    const windowAge = now - limit.windowStart;

    if (windowAge >= RATE_LIMIT_WINDOW) {
      // Window expired, start new window
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    // Within current window
    if (limit.count >= RATE_LIMIT_MAX) {
      const retryAfter = RATE_LIMIT_WINDOW - windowAge;
      return { allowed: false, retryAfter };
    }

    // Increment count
    limit.count++;
    return { allowed: true };
  }

  /**
   * Handle say message (nearby players within 20 units)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleSay(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, SAY_DISTANCE);

    // Remove sender from recipients
    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  /**
   * Handle shout message (all players in same zone)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleShout(msg, state) {
    if (!msg.from || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = [];
    const senderZone = sender.position.zone;

    for (const [playerId, player] of state.players.entries()) {
      if (playerId === msg.from) continue;
      if (!player.position) continue;

      if (player.position.zone === senderZone) {
        recipients.push(playerId);
      }
    }

    return { recipients };
  }

  /**
   * Handle whisper message (requires consent)
   * @param {Object} msg - The message object {from, to, payload}
   * @param {Object} state - World state
   * @returns {Object} {success: boolean, error?: string}
   */
  function handleWhisper(msg, state) {
    if (!msg.from || !msg.to) {
      return { success: false, error: 'Whisper requires from and to fields' };
    }

    // Check consent
    if (!hasConsent(msg.from, msg.to, 'whisper')) {
      return { success: false, error: 'Whisper requires consent from recipient' };
    }

    return { success: true };
  }

  /**
   * Handle emote message (nearby players within 30 units)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleEmote(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, EMOTE_DISTANCE);

    // Remove sender from recipients
    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  /**
   * Grant consent for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type (e.g., 'whisper', 'trade_offer')
   */
  function grantConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.set(key, true);
  }

  /**
   * Revoke consent for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type
   */
  function revokeConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.delete(key);
  }

  /**
   * Check if consent exists for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type
   * @returns {boolean}
   */
  function hasConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    return consentStore.get(key) === true;
  }

  // Export public API
  exports.handleSay = handleSay;
  exports.handleShout = handleShout;
  exports.handleWhisper = handleWhisper;
  exports.handleEmote = handleEmote;
  exports.grantConsent = grantConsent;
  exports.revokeConsent = revokeConsent;
  exports.hasConsent = hasConsent;
  exports.checkRateLimit = checkRateLimit;
  exports.getDistance = getDistance;
  exports.getNearbyPlayers = getNearbyPlayers;

})(typeof module !== 'undefined' ? module.exports : (window.Social = {}));


// creation.js
(function(exports) {

  // Plant species configuration
  const PLANT_SPECIES = {
    sunflower: {
      growthTime: 300000, // 5 min
      yields: [{type: 'sunflower', quantity: 3}]
    },
    oak_tree: {
      growthTime: 600000, // 10 min
      yields: [{type: 'wood', quantity: 5}]
    },
    wheat: {
      growthTime: 180000, // 3 min
      yields: [{type: 'wheat', quantity: 10}]
    },
    crystal_bloom: {
      growthTime: 900000, // 15 min
      yields: [{type: 'crystal', quantity: 1}]
    },
    herbs: {
      growthTime: 120000, // 2 min
      yields: [{type: 'herbs', quantity: 5}]
    }
  };

  // Crafting recipes
  const RECIPES = {
    wooden_bench: {
      materials: {wood: 3},
      produces: {type: 'wooden_bench', quantity: 1},
      complexity: 0.2
    },
    flower_crown: {
      materials: {sunflower: 2},
      produces: {type: 'flower_crown', quantity: 1},
      complexity: 0.1
    },
    crystal_lamp: {
      materials: {crystal: 1, wood: 1},
      produces: {type: 'crystal_lamp', quantity: 1},
      complexity: 0.5
    },
    bread: {
      materials: {wheat: 3, herbs: 1},
      produces: {type: 'bread', quantity: 2},
      complexity: 0.3
    },
    healing_tea: {
      materials: {herbs: 3},
      produces: {type: 'healing_tea', quantity: 1},
      complexity: 0.4
    }
  };

  // Structure types
  const STRUCTURE_TYPES = [
    'house', 'workshop', 'garden_shed', 'monument', 'bridge',
    'fountain', 'stage', 'market_stall', 'bench', 'lantern'
  ];

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Handle building structures
  function handleBuild(msg, state, zoneRules) {
    if (!zoneRules.building) {
      return {
        success: false,
        error: 'Building not allowed in this zone'
      };
    }

    const structureType = msg.payload.type;
    if (!STRUCTURE_TYPES.includes(structureType)) {
      return {
        success: false,
        error: 'Invalid structure type'
      };
    }

    const structure = {
      id: generateId(),
      type: structureType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      builder: msg.from,
      ts: Date.now()
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(structure);

    return {
      success: true,
      state: state,
      structure: structure
    };
  }

  // Handle planting
  function handlePlant(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Planting not allowed in this zone'
      };
    }

    const species = msg.payload.species;
    if (!PLANT_SPECIES[species]) {
      return {
        success: false,
        error: 'Invalid plant species'
      };
    }

    const speciesData = PLANT_SPECIES[species];
    const plantedAt = Date.now();
    const readyAt = plantedAt + speciesData.growthTime;

    const garden = {
      id: generateId(),
      species: species,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      planter: msg.from,
      plantedAt: plantedAt,
      growthStage: 0,
      readyAt: readyAt
    };

    if (!state.gardens) {
      state.gardens = [];
    }

    state.gardens.push(garden);

    return {
      success: true,
      state: state,
      garden: garden
    };
  }

  // Handle harvesting
  function handleHarvest(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Harvesting not allowed in this zone'
      };
    }

    if (!state.gardens || state.gardens.length === 0) {
      return {
        success: false,
        error: 'No gardens to harvest'
      };
    }

    const targetId = msg.payload.target;
    const gardenIndex = state.gardens.findIndex(g => g.id === targetId);

    if (gardenIndex === -1) {
      return {
        success: false,
        error: 'Garden not found'
      };
    }

    const garden = state.gardens[gardenIndex];
    const now = Date.now();

    // Check if growth is complete
    const isReady = now >= garden.readyAt || garden.growthStage >= 1.0;

    if (!isReady) {
      return {
        success: false,
        error: 'Plant is not ready to harvest yet'
      };
    }

    const speciesData = PLANT_SPECIES[garden.species];
    const items = speciesData.yields;

    // Remove garden from state
    state.gardens.splice(gardenIndex, 1);

    return {
      success: true,
      state: state,
      items: items
    };
  }

  // Handle crafting
  function handleCraft(msg, state) {
    const recipeName = msg.payload.recipe;

    if (!RECIPES[recipeName]) {
      return {
        success: false,
        error: 'Recipe not found'
      };
    }

    const recipe = RECIPES[recipeName];

    // Initialize player inventory if needed
    if (!state.players) {
      state.players = {};
    }
    if (!state.players[msg.from]) {
      state.players[msg.from] = {inventory: {}};
    }
    if (!state.players[msg.from].inventory) {
      state.players[msg.from].inventory = {};
    }

    const inventory = state.players[msg.from].inventory;

    // Check if player has required materials
    for (const [material, quantity] of Object.entries(recipe.materials)) {
      if (!inventory[material] || inventory[material] < quantity) {
        return {
          success: false,
          error: `Insufficient materials: need ${quantity} ${material}`
        };
      }
    }

    // Consume materials
    for (const [material, quantity] of Object.entries(recipe.materials)) {
      inventory[material] -= quantity;
      if (inventory[material] === 0) {
        delete inventory[material];
      }
    }

    // Produce item
    const producedItem = recipe.produces;
    if (!inventory[producedItem.type]) {
      inventory[producedItem.type] = 0;
    }
    inventory[producedItem.type] += producedItem.quantity;

    return {
      success: true,
      state: state,
      item: producedItem
    };
  }

  // Handle artistic composition
  function handleCompose(msg, state) {
    const composition = {
      id: generateId(),
      type: 'composition',
      medium: msg.payload.medium || 'text',
      content: msg.payload.content || '',
      creator: msg.from,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      ts: Date.now()
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(composition);

    return {
      success: true,
      state: state,
      composition: composition
    };
  }

  // Exports
  exports.PLANT_SPECIES = PLANT_SPECIES;
  exports.RECIPES = RECIPES;
  exports.STRUCTURE_TYPES = STRUCTURE_TYPES;
  exports.handleBuild = handleBuild;
  exports.handlePlant = handlePlant;
  exports.handleHarvest = handleHarvest;
  exports.handleCraft = handleCraft;
  exports.handleCompose = handleCompose;

})(typeof module !== 'undefined' ? module.exports : (window.Creation = {}));


// competition.js
(function(exports) {

  // Competition types
  const COMPETITION_TYPES = ['duel', 'race', 'puzzle_race', 'build_contest', 'music_battle'];

  // Pending challenges store
  const pendingChallenges = {};

  // Spark awards by competition type
  const SPARK_AWARDS = {
    duel: 50,
    race: 30,
    puzzle_race: 40,
    build_contest: 100,
    music_battle: 60
  };

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Handle challenge creation
  function handleChallenge(msg, state, zoneRules) {
    if (!zoneRules.competition || !zoneRules.pvp) {
      return {
        success: false,
        error: 'Competition not allowed in this zone'
      };
    }

    const challengeType = msg.payload.type;
    if (!COMPETITION_TYPES.includes(challengeType)) {
      return {
        success: false,
        error: 'Invalid competition type'
      };
    }

    const challengeId = generateId();
    const challenge = {
      id: challengeId,
      challenger: msg.from,
      challenged: msg.payload.to,
      type: challengeType,
      rules: msg.payload.rules || {},
      ts: Date.now()
    };

    pendingChallenges[challengeId] = challenge;

    return {
      success: true,
      pendingChallenge: challenge
    };
  }

  // Handle challenge acceptance
  function handleAcceptChallenge(msg, state) {
    const playerId = msg.from;

    // Find pending challenge targeting this player
    let foundChallenge = null;
    let challengeId = null;

    for (const [id, challenge] of Object.entries(pendingChallenges)) {
      if (challenge.challenged === playerId) {
        foundChallenge = challenge;
        challengeId = id;
        break;
      }
    }

    if (!foundChallenge) {
      return {
        success: false,
        error: 'No pending challenge found'
      };
    }

    // Create active competition
    const competition = {
      id: generateId(),
      players: [foundChallenge.challenger, foundChallenge.challenged],
      type: foundChallenge.type,
      rules: foundChallenge.rules,
      startedAt: Date.now(),
      scores: {},
      status: 'active'
    };

    // Initialize state.competitions if needed
    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(competition);

    // Remove from pending challenges
    delete pendingChallenges[challengeId];

    return {
      success: true,
      competition: competition,
      state: state
    };
  }

  // Handle forfeit
  function handleForfeit(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;

    // Find active competition involving this player
    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    // Determine winner (the other player)
    const winner = competition.players.find(p => p !== playerId);

    // Update competition status
    competition.status = 'completed';
    competition.winner = winner;
    competition.endedAt = Date.now();
    competition.forfeitedBy = playerId;

    // Calculate Spark award
    const sparkAward = SPARK_AWARDS[competition.type] || 20;

    return {
      success: true,
      state: state,
      winner: winner,
      sparkAward: sparkAward,
      competition: competition
    };
  }

  // Handle score submission
  function handleScore(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;
    const score = msg.payload.score;

    // Find active competition involving this player
    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    // Record score
    competition.scores[playerId] = score;

    // Check if both players have scored
    const allScored = competition.players.every(p =>
      competition.scores.hasOwnProperty(p)
    );

    let sparkAward = null;
    let winner = null;

    if (allScored) {
      // Determine winner (highest score)
      const scores = competition.players.map(p => ({
        player: p,
        score: competition.scores[p]
      }));

      scores.sort((a, b) => b.score - a.score);
      winner = scores[0].player;

      // Update competition status
      competition.status = 'completed';
      competition.winner = winner;
      competition.endedAt = Date.now();

      // Calculate Spark award
      sparkAward = SPARK_AWARDS[competition.type] || 20;
    }

    return {
      success: true,
      state: state,
      competition: competition,
      winner: winner,
      sparkAward: sparkAward
    };
  }

  // Get pending challenges for a player
  function getPendingChallenges(playerId) {
    return Object.values(pendingChallenges).filter(c =>
      c.challenged === playerId || c.challenger === playerId
    );
  }

  // Exports
  exports.COMPETITION_TYPES = COMPETITION_TYPES;
  exports.SPARK_AWARDS = SPARK_AWARDS;
  exports.handleChallenge = handleChallenge;
  exports.handleAcceptChallenge = handleAcceptChallenge;
  exports.handleForfeit = handleForfeit;
  exports.handleScore = handleScore;
  exports.getPendingChallenges = getPendingChallenges;

})(typeof module !== 'undefined' ? module.exports : (window.Competition = {}));


// exploration.js
(function(exports) {

  // Discovery types
  const DISCOVERY_TYPES = [
    'location', 'creature', 'artifact', 'secret',
    'landmark', 'ruin', 'cave', 'spring'
  ];

  // Base rarity by discovery type
  const BASE_RARITY = {
    location: 0.3,
    creature: 0.5,
    artifact: 0.7,
    secret: 0.9,
    landmark: 0.2,
    ruin: 0.6,
    cave: 0.4,
    spring: 0.5
  };

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Calculate distance between two 3D positions
  function calculateDistance(pos1, pos2) {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    const dz = pos1.z - pos2.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  // Check if discovery is duplicate
  function isDuplicate(playerId, position, state) {
    if (!state.discoveries || state.discoveries.length === 0) {
      return false;
    }

    // Check if player has already discovered within distance 5
    for (const discovery of state.discoveries) {
      if (discovery.discoverer === playerId) {
        const distance = calculateDistance(position, discovery.position);
        if (distance <= 5) {
          return true;
        }
      }
    }

    return false;
  }

  // Calculate rarity for a discovery type
  function calculateRarity(type) {
    if (BASE_RARITY.hasOwnProperty(type)) {
      return BASE_RARITY[type];
    }
    // Default rarity
    return 0.3;
  }

  // Handle discovery
  function handleDiscover(msg, state) {
    const position = msg.payload.position || {x: 0, y: 0, z: 0};
    const playerId = msg.from;

    // Check for duplicate
    if (isDuplicate(playerId, position, state)) {
      return {
        success: false,
        error: 'Already discovered'
      };
    }

    const discoveryType = msg.payload.type || 'location';
    if (!DISCOVERY_TYPES.includes(discoveryType)) {
      return {
        success: false,
        error: 'Invalid discovery type'
      };
    }

    // Determine rarity
    let rarity = msg.payload.rarity;
    if (typeof rarity !== 'number' || rarity < 0 || rarity > 1) {
      rarity = calculateRarity(discoveryType);
    }

    // Calculate Spark award
    const sparkAwarded = 5 + Math.floor(rarity * 20);

    const discovery = {
      id: generateId(),
      discoverer: playerId,
      type: discoveryType,
      description: msg.payload.description || '',
      position: position,
      zone: msg.payload.zone || 'default',
      ts: Date.now(),
      rarity: rarity
    };

    // Initialize state.discoveries if needed
    if (!state.discoveries) {
      state.discoveries = [];
    }

    state.discoveries.push(discovery);

    return {
      success: true,
      state: state,
      discovery: discovery,
      sparkAwarded: sparkAwarded
    };
  }

  // Handle inspection
  function handleInspect(msg, state) {
    const targetId = msg.payload.target;

    if (!targetId) {
      return {
        success: false,
        error: 'No target specified'
      };
    }

    let info = null;
    let entityType = null;

    // Search in players
    if (state.players && state.players[targetId]) {
      info = {
        type: 'player',
        id: targetId,
        data: state.players[targetId]
      };
      entityType = 'player';
    }

    // Search in structures
    if (!info && state.structures && state.structures.length > 0) {
      const structure = state.structures.find(s => s.id === targetId);
      if (structure) {
        info = {
          type: 'structure',
          id: targetId,
          data: structure
        };
        entityType = 'structure';
      }
    }

    // Search in gardens
    if (!info && state.gardens && state.gardens.length > 0) {
      const garden = state.gardens.find(g => g.id === targetId);
      if (garden) {
        const now = Date.now();
        const elapsed = now - garden.plantedAt;
        const totalGrowthTime = garden.readyAt - garden.plantedAt;
        const currentGrowthStage = Math.min(1.0, elapsed / totalGrowthTime);

        info = {
          type: 'garden',
          id: targetId,
          data: {
            ...garden,
            currentGrowthStage: currentGrowthStage,
            isReady: now >= garden.readyAt
          }
        };
        entityType = 'garden';
      }
    }

    // Search in discoveries
    if (!info && state.discoveries && state.discoveries.length > 0) {
      const discovery = state.discoveries.find(d => d.id === targetId);
      if (discovery) {
        info = {
          type: 'discovery',
          id: targetId,
          data: discovery
        };
        entityType = 'discovery';
      }
    }

    if (!info) {
      return {
        success: false,
        error: 'Target not found'
      };
    }

    return {
      success: true,
      info: info
    };
  }

  // Exports
  exports.DISCOVERY_TYPES = DISCOVERY_TYPES;
  exports.BASE_RARITY = BASE_RARITY;
  exports.handleDiscover = handleDiscover;
  exports.handleInspect = handleInspect;
  exports.isDuplicate = isDuplicate;
  exports.calculateRarity = calculateRarity;

})(typeof module !== 'undefined' ? module.exports : (window.Exploration = {}));


// physical.js
(function(exports) {

  // Anchor types
  const ANCHOR_TYPES = [
    'zone_portal', 'resource_node', 'discovery_point',
    'gathering_spot', 'garden_plot'
  ];

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Haversine distance calculation (returns km)
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const toRad = deg => deg * Math.PI / 180;

    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    return distance;
  }

  // Validate anchor location
  function validateAnchorLocation(lat, lon) {
    // Check valid range
    if (typeof lat !== 'number' || typeof lon !== 'number') {
      return {safe: false, reason: 'Invalid coordinate types'};
    }

    if (lat < -90 || lat > 90) {
      return {safe: false, reason: 'Latitude out of range (-90 to 90)'};
    }

    if (lon < -180 || lon > 180) {
      return {safe: false, reason: 'Longitude out of range (-180 to 180)'};
    }

    // Check not exactly (0,0) - null island
    if (lat === 0 && lon === 0) {
      return {safe: false, reason: 'Null Island coordinates not allowed'};
    }

    // Check not in ocean (basic check: reject if far from land)
    if (Math.abs(lat) > 85 && Math.abs(lon) > 170) {
      return {safe: false, reason: 'Location appears to be in remote ocean'};
    }

    return {safe: true};
  }

  // Create anchor
  function createAnchor(msg, state) {
    const lat = msg.payload.lat;
    const lon = msg.payload.lon;

    // Validate GPS coordinates
    if (lat === undefined || lon === undefined) {
      return {
        success: false,
        error: 'Missing GPS coordinates'
      };
    }

    const validation = validateAnchorLocation(lat, lon);
    if (!validation.safe) {
      return {
        success: false,
        error: validation.reason
      };
    }

    const anchorType = msg.payload.type || 'discovery_point';
    if (!ANCHOR_TYPES.includes(anchorType)) {
      return {
        success: false,
        error: 'Invalid anchor type'
      };
    }

    const anchor = {
      id: generateId(),
      type: anchorType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      lat: lat,
      lon: lon,
      creator: msg.from,
      ts: Date.now(),
      status: 'pending'
    };

    // Initialize state.anchors if needed
    if (!state.anchors) {
      state.anchors = [];
    }

    state.anchors.push(anchor);

    return {
      success: true,
      state: state,
      anchor: anchor
    };
  }

  // Calculate warmth from GPS history
  function calculateWarmth(gpsHistory) {
    // Null-safe: return 0 if no history
    if (!gpsHistory || !Array.isArray(gpsHistory) || gpsHistory.length < 2) {
      return 0;
    }

    let totalKm = 0;
    const maxWalkingSpeed = 25; // km/h - filter out driving

    for (let i = 1; i < gpsHistory.length; i++) {
      const prev = gpsHistory[i - 1];
      const curr = gpsHistory[i];

      // Skip if missing data
      if (!prev.lat || !prev.lon || !curr.lat || !curr.lon || !prev.ts || !curr.ts) {
        continue;
      }

      const distance = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
      const timeHours = (curr.ts - prev.ts) / (1000 * 60 * 60);

      // Skip if time is zero or negative
      if (timeHours <= 0) {
        continue;
      }

      const speed = distance / timeHours;

      // Filter out driving speed
      if (speed <= maxWalkingSpeed) {
        totalKm += distance;
      }
    }

    // Return warmth capped at 100
    const warmth = Math.min(100, totalKm * 10);
    return warmth;
  }

  // Get warmth bonus multiplier
  function getWarmthBonus(warmth) {
    // Null-safe: if warmth is null/undefined, treat as 0
    if (typeof warmth !== 'number' || warmth < 0) {
      warmth = 0;
    }

    // Returns 1.0 + (warmth / 1000)
    // Max 1.1 at warmth=100 (10% bonus)
    return 1.0 + (warmth / 1000);
  }

  // Exports
  exports.ANCHOR_TYPES = ANCHOR_TYPES;
  exports.createAnchor = createAnchor;
  exports.validateAnchorLocation = validateAnchorLocation;
  exports.calculateWarmth = calculateWarmth;
  exports.getWarmthBonus = getWarmthBonus;
  exports.haversineDistance = haversineDistance;

})(typeof module !== 'undefined' ? module.exports : (window.Physical = {}));


// auth.js
(function(exports) {
  // GitHub App OAuth Configuration — Standard Web Flow (CORS-enabled for GitHub Apps)
  const OAUTH_CONFIG = {
    clientId: 'Iv23lixLqM3xo88npTs4',
    scope: 'read:user',
    authorizeUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://github.com/login/oauth/access_token'
  };

  // Storage keys
  const TOKEN_KEY = 'zion_auth_token';
  const USERNAME_KEY = 'zion_username';
  const AVATAR_KEY = 'zion_avatar';

  // Helper: safe localStorage access
  function getStorage(key) {
    if (typeof localStorage === 'undefined') return null;
    try { return localStorage.getItem(key); } catch (e) { return null; }
  }
  function setStorage(key, value) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.setItem(key, value); } catch (e) {}
  }
  function removeStorage(key) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.removeItem(key); } catch (e) {}
  }

  /**
   * Initiate GitHub OAuth — redirects browser to GitHub authorization page.
   * After the user authorizes, GitHub redirects back with ?code= in the URL.
   */
  function initiateOAuth() {
    if (typeof window === 'undefined') return;
    var redirectUri = window.location.origin + window.location.pathname;
    var url = OAUTH_CONFIG.authorizeUrl +
      '?client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
      '&redirect_uri=' + encodeURIComponent(redirectUri) +
      '&scope=' + encodeURIComponent(OAUTH_CONFIG.scope);
    window.location.href = url;
  }

  /**
   * Handle OAuth callback — checks for ?code= in URL, exchanges for token.
   * GitHub Apps support CORS on the token exchange endpoint.
   * @returns {Promise<string|null>} access token or null if no code present
   */
  async function handleCallback() {
    if (typeof window === 'undefined') return null;
    var params = new URLSearchParams(window.location.search);
    var code = params.get('code');

    // Also handle legacy ?token= for PAT-based auth
    var token = params.get('token');
    if (token) {
      setStorage(TOKEN_KEY, token);
      window.history.replaceState({}, document.title, window.location.pathname);
      return token;
    }

    if (!code) return null;

    // Clean the URL immediately
    window.history.replaceState({}, document.title, window.location.pathname);

    try {
      // Exchange code for access token (CORS-enabled for GitHub Apps)
      // Use form-urlencoded to avoid CORS preflight (simple request)
      var res = await fetch(OAUTH_CONFIG.tokenUrl, {
        method: 'POST',
        headers: {
          'Accept': 'application/json'
        },
        body: 'client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
              '&code=' + encodeURIComponent(code)
      });

      if (!res.ok) {
        console.error('Token exchange failed:', res.status);
        return null;
      }

      var data = await res.json();
      if (data.access_token) {
        setStorage(TOKEN_KEY, data.access_token);
        // Fetch and store profile
        await getProfile(data.access_token);
        return data.access_token;
      } else {
        console.error('Token exchange error:', data.error, data.error_description);
        return null;
      }
    } catch (e) {
      console.error('OAuth callback error:', e);
      return null;
    }
  }

  /**
   * Fetch GitHub user profile
   */
  async function getProfile(token) {
    if (typeof fetch === 'undefined') throw new Error('fetch not available');
    var response = await fetch('https://api.github.com/user', {
      headers: { 'Authorization': 'Bearer ' + token, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!response.ok) throw new Error('GitHub API error: ' + response.status);
    var data = await response.json();
    setStorage(USERNAME_KEY, data.login);
    setStorage(AVATAR_KEY, data.avatar_url || '');
    return { username: data.login, avatar_url: data.avatar_url };
  }

  function isAuthenticated() { return !!getStorage(TOKEN_KEY); }
  function getUsername() { return getStorage(USERNAME_KEY); }
  function getToken() { return getStorage(TOKEN_KEY); }
  function setToken(token) { setStorage(TOKEN_KEY, token); }

  function loginAsGuest(username) {
    if (!username || typeof username !== 'string') return false;
    username = username.trim().replace(/[^a-zA-Z0-9_-]/g, '');
    if (username.length < 1 || username.length > 39) return false;
    setStorage(TOKEN_KEY, 'guest_' + username);
    setStorage(USERNAME_KEY, username);
    setStorage(AVATAR_KEY, '');
    return true;
  }

  function logout() {
    removeStorage(TOKEN_KEY);
    removeStorage(USERNAME_KEY);
    removeStorage(AVATAR_KEY);
  }

  exports.OAUTH_CONFIG = OAUTH_CONFIG;
  exports.initiateOAuth = initiateOAuth;
  exports.handleCallback = handleCallback;
  exports.getProfile = getProfile;
  exports.isAuthenticated = isAuthenticated;
  exports.getUsername = getUsername;
  exports.getToken = getToken;
  exports.setToken = setToken;
  exports.loginAsGuest = loginAsGuest;
  exports.logout = logout;

})(typeof module !== 'undefined' ? module.exports : (window.Auth = {}));


// network.js
(function(exports) {
  // PeerJS mesh networking
  let peer = null;
  let connections = new Map(); // peerId -> connection
  let messageCallback = null;
  let peerConnectCallback = null;
  let peerDisconnectCallback = null;
  let seenMessages = new Set(); // For deduplication
  const MAX_SEEN_MESSAGES = 1000;

  /**
   * Initialize PeerJS mesh network
   * @param {string} peerId - Unique peer ID for this client
   * @param {object} options - Configuration
   * @param {function} options.onMessage - Callback for incoming messages (msg)
   * @param {function} options.onPeerConnect - Callback when peer connects (peerId)
   * @param {function} options.onPeerDisconnect - Callback when peer disconnects (peerId)
   */
  function initMesh(peerId, options = {}) {
    // Check if PeerJS is available
    if (typeof Peer === 'undefined') {
      console.warn('PeerJS not available. Network mesh disabled.');
      return null;
    }

    messageCallback = options.onMessage || (() => {});
    peerConnectCallback = options.onPeerConnect || (() => {});
    peerDisconnectCallback = options.onPeerDisconnect || (() => {});

    // Create peer with optional config
    peer = new Peer(peerId, {
      debug: 2 // Set to 3 for verbose logging
    });

    peer.on('open', (id) => {
      console.log('Mesh network initialized. Peer ID:', id);
    });

    peer.on('connection', (conn) => {
      handleConnection(conn);
    });

    peer.on('error', (err) => {
      console.error('Peer error:', err);
      // Auto-reconnect on certain errors
      if (err.type === 'peer-unavailable' || err.type === 'network') {
        attemptReconnect(peerId, 0);
      }
    });

    peer.on('disconnected', () => {
      console.warn('Peer disconnected from signaling server');
      attemptReconnect(peerId, 0);
    });

    return peer;
  }

  /**
   * Handle incoming connection
   * @param {DataConnection} conn
   */
  function handleConnection(conn) {
    const remotePeerId = conn.peer;

    conn.on('open', () => {
      console.log('Connected to peer:', remotePeerId);
      connections.set(remotePeerId, conn);
      peerConnectCallback(remotePeerId);
    });

    conn.on('data', (data) => {
      handleIncomingMessage(data, remotePeerId);
    });

    conn.on('close', () => {
      console.log('Peer disconnected:', remotePeerId);
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });

    conn.on('error', (err) => {
      console.error('Connection error with peer', remotePeerId, ':', err);
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });
  }

  /**
   * Handle incoming message with deduplication
   * @param {object} data
   * @param {string} fromPeer
   */
  function handleIncomingMessage(data, fromPeer) {
    try {
      const msg = typeof data === 'string' ? JSON.parse(data) : data;

      // Generate message ID for deduplication
      const msgId = generateMessageId(msg);

      // Check if already seen
      if (seenMessages.has(msgId)) {
        return; // Duplicate, ignore
      }

      // Add to seen messages
      seenMessages.add(msgId);

      // Evict oldest if over limit
      if (seenMessages.size > MAX_SEEN_MESSAGES) {
        const firstItem = seenMessages.values().next().value;
        seenMessages.delete(firstItem);
      }

      // Relay to other peers (mesh propagation)
      relayMessage(msg, fromPeer);

      // Invoke callback
      messageCallback(msg);
    } catch (err) {
      console.error('Error handling message:', err);
    }
  }

  /**
   * Generate unique message ID for deduplication
   * @param {object} msg
   * @returns {string}
   */
  function generateMessageId(msg) {
    // Use message fields to create unique ID
    const str = JSON.stringify({
      type: msg.type,
      from: msg.from,
      timestamp: msg.timestamp,
      nonce: msg.nonce
    });
    return simpleHash(str);
  }

  /**
   * Simple hash function
   * @param {string} str
   * @returns {string}
   */
  function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  /**
   * Relay message to all peers except sender
   * @param {object} msg
   * @param {string} excludePeer
   */
  function relayMessage(msg, excludePeer) {
    connections.forEach((conn, peerId) => {
      if (peerId !== excludePeer && conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error relaying to peer', peerId, ':', err);
        }
      }
    });
  }

  /**
   * Broadcast message to all connected peers
   * @param {object} msg - Message object (will be JSON serialized)
   */
  function broadcastMessage(msg) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    // Add to seen messages to prevent echo
    const msgId = generateMessageId(msg);
    seenMessages.add(msgId);

    connections.forEach((conn, peerId) => {
      if (conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error sending to peer', peerId, ':', err);
        }
      }
    });
  }

  /**
   * Register message handler
   * @param {function} callback
   */
  function onMessage(callback) {
    messageCallback = callback;
  }

  /**
   * Get list of connected peer IDs
   * @returns {string[]}
   */
  function getPeers() {
    return Array.from(connections.keys());
  }

  /**
   * Connect to a specific peer
   * @param {string} peerId
   */
  function connectToPeer(peerId) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    if (connections.has(peerId)) {
      console.log('Already connected to peer:', peerId);
      return;
    }

    console.log('Connecting to peer:', peerId);
    const conn = peer.connect(peerId, {
      reliable: true
    });

    handleConnection(conn);
  }

  /**
   * Disconnect from all peers and destroy peer
   */
  function disconnect() {
    if (!peer) return;

    connections.forEach((conn) => {
      conn.close();
    });

    connections.clear();
    peer.destroy();
    peer = null;

    console.log('Disconnected from mesh network');
  }

  /**
   * Attempt to reconnect with exponential backoff
   * @param {string} peerId
   * @param {number} attempt
   */
  function attemptReconnect(peerId, attempt) {
    const maxAttempts = 3;
    if (attempt >= maxAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    const delay = Math.pow(2, attempt) * 1000; // Exponential: 1s, 2s, 4s
    console.log(`Reconnecting in ${delay}ms (attempt ${attempt + 1}/${maxAttempts})`);

    setTimeout(() => {
      if (!peer || peer.destroyed) {
        console.log('Attempting to reconnect...');
        peer.reconnect();

        // Check if reconnection succeeded after 2 seconds
        setTimeout(() => {
          if (peer && !peer.open) {
            attemptReconnect(peerId, attempt + 1);
          }
        }, 2000);
      }
    }, delay);
  }

  /**
   * Generate lobby peer ID from world ID
   * @param {string} worldId - World identifier (default: 'main')
   * @returns {string}
   */
  function getLobbyPeerId(worldId = 'main') {
    return `zion-lobby-${worldId}`;
  }

  // Export public API
  exports.initMesh = initMesh;
  exports.broadcastMessage = broadcastMessage;
  exports.onMessage = onMessage;
  exports.getPeers = getPeers;
  exports.connectToPeer = connectToPeer;
  exports.disconnect = disconnect;
  exports.getLobbyPeerId = getLobbyPeerId;

})(typeof module !== 'undefined' ? module.exports : (window.Network = {}));


// world.js
(function(exports) {
  // Three.js scene & rendering
  const playerMeshes = new Map(); // playerId -> {mesh, label}

  /**
   * Initialize Three.js scene
   * @param {HTMLElement} container - DOM container for renderer
   * @returns {object|null} - {scene, camera, renderer} or null if THREE not available
   */
  function initScene(container) {
    if (typeof THREE === 'undefined') {
      console.warn('THREE.js not available. 3D rendering disabled.');
      return null;
    }

    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue

    // Create camera
    const camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Handle window resize
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    return { scene, camera, renderer, ambientLight, directionalLight };
  }

  /**
   * Load zone with procedural terrain
   * @param {object} sceneCtx - Scene context from initScene
   * @param {string} zoneId - Zone identifier
   */
  function loadZone(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene) return;

    const { scene } = sceneCtx;

    // Clear existing objects (keep lights and camera)
    const objectsToRemove = [];
    scene.traverse((obj) => {
      if (obj.isMesh || obj.isGroup) {
        objectsToRemove.push(obj);
      }
    });
    objectsToRemove.forEach(obj => scene.remove(obj));
    playerMeshes.clear();

    // Generate zone-specific terrain
    switch (zoneId) {
      case 'nexus':
        generateNexus(scene);
        break;
      case 'gardens':
        generateGardens(scene);
        break;
      case 'athenaeum':
        generateAthenaeum(scene);
        break;
      case 'studio':
        generateStudio(scene);
        break;
      case 'wilds':
        generateWilds(scene);
        break;
      case 'agora':
        generateAgora(scene);
        break;
      case 'commons':
        generateCommons(scene);
        break;
      case 'arena':
        generateArena(scene);
        break;
      default:
        generateCommons(scene); // Default fallback
    }
  }

  // Zone generators
  function generateNexus(scene) {
    // Flat stone plaza
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 50),
      new THREE.MeshStandardMaterial({ color: 0x808080 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Central fountain
    const fountain = new THREE.Mesh(
      new THREE.CylinderGeometry(2, 2, 1, 16),
      new THREE.MeshStandardMaterial({ color: 0x4488ff })
    );
    fountain.position.set(0, 0.5, 0);
    fountain.castShadow = true;
    scene.add(fountain);

    // Fountain water
    const water = new THREE.Mesh(
      new THREE.CylinderGeometry(1.8, 1.8, 0.2, 16),
      new THREE.MeshStandardMaterial({ color: 0x2266dd, transparent: true, opacity: 0.7 })
    );
    water.position.set(0, 1, 0);
    scene.add(water);
  }

  function generateGardens(scene) {
    // Rolling green hills
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100, 20, 20),
      new THREE.MeshStandardMaterial({ color: 0x228b22 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;

    // Add some height variation
    const positions = ground.geometry.attributes.position;
    for (let i = 0; i < positions.count; i++) {
      const x = positions.getX(i);
      const y = positions.getY(i);
      const height = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 2;
      positions.setZ(i, height);
    }
    positions.needsUpdate = true;
    ground.geometry.computeVertexNormals();

    scene.add(ground);

    // Add some trees
    for (let i = 0; i < 15; i++) {
      const x = (Math.random() - 0.5) * 80;
      const z = (Math.random() - 0.5) * 80;
      addTree(scene, x, z);
    }
  }

  function generateAthenaeum(scene) {
    // Large hall floor
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(60, 40),
      new THREE.MeshStandardMaterial({ color: 0xdaa520 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Columns
    const columnPositions = [
      [-20, 0, -15], [20, 0, -15],
      [-20, 0, 0], [20, 0, 0],
      [-20, 0, 15], [20, 0, 15]
    ];

    columnPositions.forEach(([x, y, z]) => {
      const column = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1, 10, 8),
        new THREE.MeshStandardMaterial({ color: 0xf5f5dc })
      );
      column.position.set(x, 5, z);
      column.castShadow = true;
      scene.add(column);
    });
  }

  function generateStudio(scene) {
    // Amphitheater ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(80, 80),
      new THREE.MeshStandardMaterial({ color: 0xd2b48c })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Circular stage
    const stage = new THREE.Mesh(
      new THREE.CylinderGeometry(10, 10, 0.5, 32),
      new THREE.MeshStandardMaterial({ color: 0x8b4513 })
    );
    stage.position.set(0, 0.25, 0);
    stage.castShadow = true;
    scene.add(stage);

    // Seating tiers
    for (let i = 1; i <= 3; i++) {
      const tier = new THREE.Mesh(
        new THREE.CylinderGeometry(15 + i * 5, 15 + i * 5, 0.5, 32),
        new THREE.MeshStandardMaterial({ color: 0xa0522d })
      );
      tier.position.set(0, 0.25 - i * 0.5, 0);
      tier.receiveShadow = true;
      scene.add(tier);
    }
  }

  function generateWilds(scene) {
    // Forest floor
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(150, 150),
      new THREE.MeshStandardMaterial({ color: 0x2d5016 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Random trees
    for (let i = 0; i < 40; i++) {
      const x = (Math.random() - 0.5) * 140;
      const z = (Math.random() - 0.5) * 140;
      addTree(scene, x, z);
    }

    // Random rocks
    for (let i = 0; i < 20; i++) {
      const x = (Math.random() - 0.5) * 140;
      const z = (Math.random() - 0.5) * 140;
      addRock(scene, x, z);
    }
  }

  function generateAgora(scene) {
    // Market square
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(70, 70),
      new THREE.MeshStandardMaterial({ color: 0xbc8f8f })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Market stalls
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      const x = Math.cos(angle) * 25;
      const z = Math.sin(angle) * 25;
      addStall(scene, x, z);
    }
  }

  function generateCommons(scene) {
    // Flat open ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshStandardMaterial({ color: 0x90ee90 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
  }

  function generateArena(scene) {
    // Arena floor
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(30, 32),
      new THREE.MeshStandardMaterial({ color: 0xdaa520 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Colosseum walls
    const wallSegments = 24;
    for (let i = 0; i < wallSegments; i++) {
      const angle = (i / wallSegments) * Math.PI * 2;
      const x = Math.cos(angle) * 35;
      const z = Math.sin(angle) * 35;

      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(3, 8, 2),
        new THREE.MeshStandardMaterial({ color: 0xd2691e })
      );
      wall.position.set(x, 4, z);
      wall.rotation.y = angle;
      wall.castShadow = true;
      scene.add(wall);
    }
  }

  // Helper: Add tree
  function addTree(scene, x, z) {
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.3, 0.4, 4, 8),
      new THREE.MeshStandardMaterial({ color: 0x8b4513 })
    );
    trunk.position.set(x, 2, z);
    trunk.castShadow = true;
    scene.add(trunk);

    const foliage = new THREE.Mesh(
      new THREE.SphereGeometry(2, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0x228b22 })
    );
    foliage.position.set(x, 5, z);
    foliage.castShadow = true;
    scene.add(foliage);
  }

  // Helper: Add rock
  function addRock(scene, x, z) {
    const rock = new THREE.Mesh(
      new THREE.SphereGeometry(Math.random() * 1 + 0.5, 6, 6),
      new THREE.MeshStandardMaterial({ color: 0x696969 })
    );
    rock.position.set(x, rock.geometry.parameters.radius * 0.5, z);
    rock.scale.y = 0.7;
    rock.castShadow = true;
    scene.add(rock);
  }

  // Helper: Add market stall
  function addStall(scene, x, z) {
    const stall = new THREE.Mesh(
      new THREE.BoxGeometry(3, 2, 2),
      new THREE.MeshStandardMaterial({ color: 0xcd853f })
    );
    stall.position.set(x, 1, z);
    stall.castShadow = true;
    scene.add(stall);

    // Canopy
    const canopy = new THREE.Mesh(
      new THREE.BoxGeometry(3.5, 0.1, 2.5),
      new THREE.MeshStandardMaterial({ color: 0xff6347 })
    );
    canopy.position.set(x, 2.5, z);
    scene.add(canopy);
  }

  /**
   * Add player to scene
   * @param {object} sceneCtx
   * @param {string} playerId
   * @param {object} position - {x, y, z}
   */
  function addPlayer(sceneCtx, playerId, position) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (typeof THREE === 'undefined') return;

    const { scene } = sceneCtx;

    // Create capsule (cylinder + sphere)
    const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
    const material = new THREE.MeshStandardMaterial({ color: 0x4488ff });
    const body = new THREE.Mesh(geometry, material);
    body.castShadow = true;

    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.3, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xffddaa })
    );
    head.position.y = 1;

    const playerGroup = new THREE.Group();
    playerGroup.add(body);
    playerGroup.add(head);
    playerGroup.position.set(position.x, position.y + 0.75, position.z);

    // Create text label (sprite with canvas texture)
    const label = createTextSprite(playerId);
    label.position.y = 2;
    playerGroup.add(label);

    scene.add(playerGroup);
    playerMeshes.set(playerId, { mesh: playerGroup, label });
  }

  /**
   * Move player (with lerp for smooth movement)
   * @param {object} sceneCtx
   * @param {string} playerId
   * @param {object} position - {x, y, z}
   */
  function movePlayer(sceneCtx, playerId, position) {
    const playerData = playerMeshes.get(playerId);
    if (!playerData) return;

    const { mesh } = playerData;
    const target = new THREE.Vector3(position.x, position.y + 0.75, position.z);

    // Lerp for smooth movement
    mesh.position.lerp(target, 0.1);
  }

  /**
   * Remove player from scene
   * @param {object} sceneCtx
   * @param {string} playerId
   */
  function removePlayer(sceneCtx, playerId) {
    if (!sceneCtx || !sceneCtx.scene) return;

    const playerData = playerMeshes.get(playerId);
    if (!playerData) return;

    sceneCtx.scene.remove(playerData.mesh);
    playerMeshes.delete(playerId);
  }

  /**
   * Create text sprite for player name label
   * @param {string} text
   * @returns {THREE.Sprite}
   */
  function createTextSprite(text) {
    if (typeof document === 'undefined') {
      return new THREE.Sprite(); // Fallback for Node.js
    }

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;

    context.fillStyle = 'rgba(0, 0, 0, 0.5)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = 'Bold 24px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.fillText(text, 128, 40);

    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(2, 0.5, 1);

    return sprite;
  }

  /**
   * Update day/night cycle
   * @param {object} sceneCtx
   * @param {number} worldTime - 0-1440 (minutes in 24-hour cycle)
   */
  function updateDayNight(sceneCtx, worldTime) {
    if (!sceneCtx || !sceneCtx.scene) return;

    const { scene, ambientLight, directionalLight } = sceneCtx;

    // Calculate phase (0-24 hours)
    const hour = (worldTime / 60) % 24;

    let intensity, color, skyColor;

    if (hour >= 6 && hour < 8) {
      // Dawn
      intensity = 0.3 + (hour - 6) / 2 * 0.3;
      color = 0xffaa66;
      skyColor = 0xff6633;
    } else if (hour >= 8 && hour < 18) {
      // Day
      intensity = 0.6;
      color = 0xffffff;
      skyColor = 0x87ceeb;
    } else if (hour >= 18 && hour < 20) {
      // Dusk
      intensity = 0.6 - (hour - 18) / 2 * 0.4;
      color = 0xff8844;
      skyColor = 0xff4422;
    } else {
      // Night
      intensity = 0.2;
      color = 0x6666aa;
      skyColor = 0x001144;
    }

    directionalLight.intensity = intensity;
    directionalLight.color.setHex(color);
    ambientLight.intensity = intensity * 0.5;
    scene.background.setHex(skyColor);
  }

  /**
   * Update weather effects
   * @param {object} sceneCtx
   * @param {string} weatherType - 'clear', 'rain', 'snow'
   */
  function updateWeather(sceneCtx, weatherType) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (typeof THREE === 'undefined') return;

    const { scene } = sceneCtx;

    // Remove existing weather
    scene.children.forEach(child => {
      if (child.userData && child.userData.weather) {
        scene.remove(child);
      }
    });

    if (weatherType === 'rain') {
      // Simple rain particles
      const rainGeometry = new THREE.BufferGeometry();
      const rainPositions = [];

      for (let i = 0; i < 1000; i++) {
        rainPositions.push(
          (Math.random() - 0.5) * 100,
          Math.random() * 50,
          (Math.random() - 0.5) * 100
        );
      }

      rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
      const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1 });
      const rain = new THREE.Points(rainGeometry, rainMaterial);
      rain.userData.weather = true;
      scene.add(rain);
    } else if (weatherType === 'snow') {
      // Simple snow particles
      const snowGeometry = new THREE.BufferGeometry();
      const snowPositions = [];

      for (let i = 0; i < 500; i++) {
        snowPositions.push(
          (Math.random() - 0.5) * 100,
          Math.random() * 50,
          (Math.random() - 0.5) * 100
        );
      }

      snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
      const snowMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 });
      const snow = new THREE.Points(snowGeometry, snowMaterial);
      snow.userData.weather = true;
      scene.add(snow);
    }
  }

  /**
   * Add portal to scene
   * @param {object} sceneCtx
   * @param {object} position - {x, y, z}
   * @param {string} targetZone
   */
  function addPortal(sceneCtx, position, targetZone) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (typeof THREE === 'undefined') return;

    const { scene } = sceneCtx;

    const portal = new THREE.Mesh(
      new THREE.TorusGeometry(2, 0.3, 16, 32),
      new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        emissive: 0x00aaaa,
        emissiveIntensity: 0.5
      })
    );
    portal.position.set(position.x, position.y + 2, position.z);
    portal.rotation.y = Math.PI / 4;
    portal.userData.portal = true;
    portal.userData.targetZone = targetZone;
    scene.add(portal);
  }

  /**
   * Add generic structure to scene
   * @param {object} sceneCtx
   * @param {object} structure - {position: {x,y,z}, size: {w,h,d}, color}
   */
  function addStructure(sceneCtx, structure) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (typeof THREE === 'undefined') return;

    const { scene } = sceneCtx;
    const { position, size, color } = structure;

    const box = new THREE.Mesh(
      new THREE.BoxGeometry(size.w, size.h, size.d),
      new THREE.MeshStandardMaterial({ color: color || 0x8b4513 })
    );
    box.position.set(position.x, position.y + size.h / 2, position.z);
    box.castShadow = true;
    box.receiveShadow = true;
    scene.add(box);
  }

  // Export public API
  exports.initScene = initScene;
  exports.loadZone = loadZone;
  exports.addPlayer = addPlayer;
  exports.movePlayer = movePlayer;
  exports.removePlayer = removePlayer;
  exports.updateDayNight = updateDayNight;
  exports.updateWeather = updateWeather;
  exports.addPortal = addPortal;
  exports.addStructure = addStructure;

})(typeof module !== 'undefined' ? module.exports : (window.World = {}));


// input.js
(function(exports) {
  // Input handling and protocol message generation
  let callbacks = {};
  let keys = {};
  let chatMode = false;
  let buildMode = false;
  let canvas = null;

  /**
   * Initialize input handlers
   * @param {object} cbs - Callbacks
   * @param {function} cbs.onMove - Movement callback (delta, position)
   * @param {function} cbs.onAction - Action callback (type, data)
   * @param {function} cbs.onChat - Chat callback (message)
   * @param {function} cbs.onBuild - Build callback (data)
   */
  function initInput(cbs) {
    callbacks = cbs || {};

    if (typeof document === 'undefined') {
      console.warn('Input requires browser environment');
      return;
    }

    // Keyboard handlers
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    // Mouse handlers
    canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.addEventListener('click', handleMouseClick);
      canvas.addEventListener('contextmenu', handleContextMenu);
    }

    // Touch handlers for mobile
    if ('ontouchstart' in window) {
      initTouchControls();
    }

    console.log('Input system initialized');
  }

  /**
   * Handle key down
   */
  function handleKeyDown(e) {
    // Don't process game keys in chat mode (except Escape/Enter)
    if (chatMode && e.key !== 'Escape' && e.key !== 'Enter') {
      return;
    }

    keys[e.key.toLowerCase()] = true;

    // Special keys
    switch (e.key) {
      case 'Enter':
        if (chatMode) {
          chatMode = false;
        } else {
          chatMode = true;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: 'open' });
          }
        }
        e.preventDefault();
        break;

      case 'Escape':
        chatMode = false;
        buildMode = false;
        if (callbacks.onAction) {
          callbacks.onAction('cancel', {});
        }
        e.preventDefault();
        break;

      case 'b':
      case 'B':
        if (!chatMode) {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
          e.preventDefault();
        }
        break;

      case 'e':
      case 'E':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('interact', {});
          }
          e.preventDefault();
        }
        break;
    }
  }

  /**
   * Handle key up
   */
  function handleKeyUp(e) {
    keys[e.key.toLowerCase()] = false;
  }

  /**
   * Handle mouse click
   */
  function handleMouseClick(e) {
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    if (callbacks.onAction) {
      callbacks.onAction('click', { x, y, screenX: e.clientX, screenY: e.clientY });
    }
  }

  /**
   * Handle context menu (right-click)
   */
  function handleContextMenu(e) {
    e.preventDefault();

    if (callbacks.onAction) {
      callbacks.onAction('context', { x: e.clientX, y: e.clientY });
    }
  }

  /**
   * Initialize touch controls (virtual joystick)
   */
  function initTouchControls() {
    if (typeof document === 'undefined') return;

    // Create virtual joystick (left side)
    const joystick = document.createElement('div');
    joystick.id = 'virtual-joystick';
    joystick.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      border: 2px solid rgba(255,255,255,0.5);
      touch-action: none;
      z-index: 1000;
    `;

    const stick = document.createElement('div');
    stick.style.cssText = `
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      top: 35px;
      left: 35px;
      touch-action: none;
    `;
    joystick.appendChild(stick);
    document.body.appendChild(joystick);

    // Joystick touch handler
    let touchStartPos = { x: 0, y: 0 };
    let isDragging = false;

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      const touch = e.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
    });

    joystick.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      e.preventDefault();

      const touch = e.touches[0];
      const deltaX = touch.clientX - touchStartPos.x;
      const deltaY = touch.clientY - touchStartPos.y;

      // Limit stick movement
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const maxDistance = 35;
      const normalizedDelta = {
        x: deltaX / maxDistance,
        y: deltaY / maxDistance
      };

      if (distance > maxDistance) {
        stick.style.left = (35 + (deltaX / distance) * maxDistance) + 'px';
        stick.style.top = (35 + (deltaY / distance) * maxDistance) + 'px';
      } else {
        stick.style.left = (35 + deltaX) + 'px';
        stick.style.top = (35 + deltaY) + 'px';
      }

      // Send movement
      if (callbacks.onMove) {
        callbacks.onMove({
          x: normalizedDelta.x,
          y: 0,
          z: -normalizedDelta.y // Invert Y for forward/back
        });
      }
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      isDragging = false;
      stick.style.left = '35px';
      stick.style.top = '35px';
    });

    // Create action buttons (right side)
    const actionButton = document.createElement('button');
    actionButton.textContent = 'E';
    actionButton.style.cssText = `
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(100,200,100,0.7);
      border: 2px solid rgba(255,255,255,0.5);
      color: white;
      font-size: 24px;
      font-weight: bold;
      z-index: 1000;
    `;
    actionButton.addEventListener('click', () => {
      if (callbacks.onAction) {
        callbacks.onAction('interact', {});
      }
    });
    document.body.appendChild(actionButton);

    const buildButton = document.createElement('button');
    buildButton.textContent = 'B';
    buildButton.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(200,100,100,0.7);
      border: 2px solid rgba(255,255,255,0.5);
      color: white;
      font-size: 24px;
      font-weight: bold;
      z-index: 1000;
    `;
    buildButton.addEventListener('click', () => {
      buildMode = !buildMode;
      if (callbacks.onBuild) {
        callbacks.onBuild({ mode: buildMode });
      }
    });
    document.body.appendChild(buildButton);
  }

  /**
   * Get movement delta from keyboard state
   * @returns {object} - {x, y, z}
   */
  function getMovementDelta() {
    if (chatMode) return { x: 0, y: 0, z: 0 };

    const delta = { x: 0, y: 0, z: 0 };

    // WASD / Arrow keys
    if (keys['w'] || keys['arrowup']) delta.z -= 1;
    if (keys['s'] || keys['arrowdown']) delta.z += 1;
    if (keys['a'] || keys['arrowleft']) delta.x -= 1;
    if (keys['d'] || keys['arrowright']) delta.x += 1;

    // Normalize diagonal movement
    if (delta.x !== 0 && delta.z !== 0) {
      const length = Math.sqrt(delta.x * delta.x + delta.z * delta.z);
      delta.x /= length;
      delta.z /= length;
    }

    return delta;
  }

  /**
   * Detect platform
   * @returns {string} - 'desktop', 'phone', 'vr', 'ar'
   */
  function getPlatform() {
    if (typeof navigator === 'undefined') return 'desktop';

    const ua = navigator.userAgent.toLowerCase();

    // Check WebXR
    if (navigator.xr) {
      // Note: Actual VR/AR detection requires async check, this is just availability
      return 'desktop'; // Default, can be upgraded to VR/AR when session starts
    }

    // Check mobile
    if (/mobile|android|iphone|ipad|tablet/.test(ua)) {
      return 'phone';
    }

    return 'desktop';
  }

  /**
   * Create move protocol message
   * @param {string} from - Player ID
   * @param {object} delta - Movement delta {x, y, z}
   * @param {object} currentPosition - Current position {x, y, z}
   * @param {string} zone - Current zone
   * @returns {object} - Protocol message
   */
  function createMoveMessage(from, delta, currentPosition, zone) {
    const speed = 0.1; // Units per frame
    const newPosition = {
      x: currentPosition.x + delta.x * speed,
      y: currentPosition.y + delta.y * speed,
      z: currentPosition.z + delta.z * speed
    };

    return {
      type: 'move',
      from: from,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        position: newPosition,
        zone: zone
      }
    };
  }

  // Export public API
  exports.initInput = initInput;
  exports.getMovementDelta = getMovementDelta;
  exports.getPlatform = getPlatform;
  exports.createMoveMessage = createMoveMessage;

})(typeof module !== 'undefined' ? module.exports : (window.Input = {}));


// hud.js
(function(exports) {
  // HUD overlay management
  let hudContainer = null;
  let chatPanel = null;
  let playerInfoPanel = null;
  let minimapCanvas = null;
  let minimapCtx = null;
  let zoneLabel = null;
  let nearbyPlayersList = null;
  let chatInput = null;
  let notificationContainer = null;

  /**
   * Initialize HUD
   * @param {HTMLElement} container - Parent container for HUD
   */
  function initHUD(container) {
    if (typeof document === 'undefined') {
      console.warn('HUD requires browser environment');
      return;
    }

    hudContainer = container;

    // Create main HUD overlay
    const hudOverlay = document.createElement('div');
    hudOverlay.id = 'zion-hud';
    hudOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      font-family: Arial, sans-serif;
      color: white;
      z-index: 100;
    `;

    // Chat panel (bottom-left)
    chatPanel = document.createElement('div');
    chatPanel.id = 'chat-panel';
    chatPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 350px;
      height: 200px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      pointer-events: auto;
      font-size: 14px;
    `;
    hudOverlay.appendChild(chatPanel);

    // Player info panel (top-left)
    playerInfoPanel = document.createElement('div');
    playerInfoPanel.id = 'player-info';
    playerInfoPanel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      min-width: 200px;
      pointer-events: auto;
    `;
    hudOverlay.appendChild(playerInfoPanel);

    // Zone label (top-center)
    zoneLabel = document.createElement('div');
    zoneLabel.id = 'zone-label';
    zoneLabel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
    `;
    hudOverlay.appendChild(zoneLabel);

    // Minimap (top-right)
    const minimapContainer = document.createElement('div');
    minimapContainer.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      pointer-events: auto;
    `;

    minimapCanvas = document.createElement('canvas');
    minimapCanvas.width = 150;
    minimapCanvas.height = 150;
    minimapCanvas.style.cssText = `
      display: block;
      border-radius: 4px;
    `;
    minimapCtx = minimapCanvas.getContext('2d');
    minimapContainer.appendChild(minimapCanvas);
    hudOverlay.appendChild(minimapContainer);

    // Nearby players list (right side)
    nearbyPlayersList = document.createElement('div');
    nearbyPlayersList.id = 'nearby-players';
    nearbyPlayersList.style.cssText = `
      position: absolute;
      top: 200px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      min-width: 150px;
      max-height: 300px;
      overflow-y: auto;
      pointer-events: auto;
    `;
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';
    hudOverlay.appendChild(nearbyPlayersList);

    // Notification container (top-center, below zone label)
    notificationContainer = document.createElement('div');
    notificationContainer.id = 'notifications';
    notificationContainer.style.cssText = `
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      pointer-events: none;
    `;
    hudOverlay.appendChild(notificationContainer);

    container.appendChild(hudOverlay);

    console.log('HUD initialized');
  }

  /**
   * Update chat panel
   * @param {Array} messages - Array of {user, text, timestamp}
   */
  function updateChat(messages) {
    if (!chatPanel) return;

    chatPanel.innerHTML = '';

    messages.slice(-10).forEach(msg => {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `
        margin-bottom: 5px;
        padding: 3px;
        border-radius: 3px;
      `;

      const time = new Date(msg.timestamp).toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });

      msgEl.innerHTML = `
        <span style="color: #888; font-size: 11px;">${time}</span>
        <span style="color: #4af; font-weight: bold;">${msg.user}:</span>
        <span>${msg.text}</span>
      `;

      chatPanel.appendChild(msgEl);
    });

    // Auto-scroll to bottom
    chatPanel.scrollTop = chatPanel.scrollHeight;
  }

  /**
   * Update player info panel
   * @param {object} player - {name, spark, zone, warmth}
   */
  function updatePlayerInfo(player) {
    if (!playerInfoPanel) return;

    playerInfoPanel.innerHTML = `
      <div style="font-weight: bold; font-size: 16px; margin-bottom: 8px;">${player.name || 'Unknown'}</div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ffa500;">Spark:</span> ${player.spark || 0}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #4af;">Zone:</span> ${player.zone || 'Unknown'}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ff6347;">Warmth:</span> ${player.warmth || 100}%
      </div>
    `;
  }

  /**
   * Update minimap
   * @param {Array} players - Array of {id, position, isLocal}
   * @param {string} currentZone - Current zone name
   */
  function updateMinimap(players, currentZone) {
    if (!minimapCtx) return;

    const width = minimapCanvas.width;
    const height = minimapCanvas.height;

    // Clear canvas
    minimapCtx.fillStyle = '#1a1a2e';
    minimapCtx.fillRect(0, 0, width, height);

    // Draw zone boundary
    minimapCtx.strokeStyle = '#444';
    minimapCtx.lineWidth = 2;
    minimapCtx.strokeRect(10, 10, width - 20, height - 20);

    // Draw zone name
    minimapCtx.fillStyle = '#888';
    minimapCtx.font = 'bold 10px Arial';
    minimapCtx.textAlign = 'center';
    minimapCtx.fillText(currentZone || '', width / 2, 20);

    // Draw players
    const mapScale = (width - 40) / 100; // Assume 100 unit zone
    const centerX = width / 2;
    const centerY = height / 2;

    players.forEach(player => {
      const x = centerX + (player.position.x * mapScale);
      const y = centerY + (player.position.z * mapScale);

      // Draw player dot
      minimapCtx.beginPath();
      minimapCtx.arc(x, y, player.isLocal ? 5 : 3, 0, Math.PI * 2);
      minimapCtx.fillStyle = player.isLocal ? '#4af' : '#4f4';
      minimapCtx.fill();
    });
  }

  /**
   * Update zone label
   * @param {string} zoneName
   */
  function updateZoneLabel(zoneName) {
    if (!zoneLabel) return;
    zoneLabel.textContent = zoneName || 'Unknown Zone';
  }

  /**
   * Update nearby players list
   * @param {Array} players - Array of {id, name, distance}
   */
  function updateNearbyPlayers(players) {
    if (!nearbyPlayersList) return;

    // Keep header, remove old entries
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';

    if (players.length === 0) {
      const emptyMsg = document.createElement('div');
      emptyMsg.style.cssText = 'color: #888; font-size: 12px; font-style: italic;';
      emptyMsg.textContent = 'No players nearby';
      nearbyPlayersList.appendChild(emptyMsg);
      return;
    }

    players.slice(0, 10).forEach(player => {
      const playerEl = document.createElement('div');
      playerEl.style.cssText = `
        padding: 5px;
        margin-bottom: 3px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-size: 13px;
      `;

      const distanceStr = player.distance ? `(${player.distance.toFixed(1)}m)` : '';
      playerEl.innerHTML = `
        <span style="color: #4f4;">${player.name || player.id}</span>
        <span style="color: #888; font-size: 11px; margin-left: 5px;">${distanceStr}</span>
      `;

      nearbyPlayersList.appendChild(playerEl);
    });
  }

  /**
   * Show break reminder
   * @param {number} minutes - Minutes played
   */
  function showBreakReminder(minutes) {
    showNotification(
      `You've been playing for ${minutes} minutes. Consider taking a break!`,
      'info'
    );
  }

  /**
   * Add chat input field
   * @param {function} onSubmit - Callback when message is submitted
   */
  function addChatInput(onSubmit) {
    if (!hudContainer || chatInput) return;
    if (typeof document === 'undefined') return;

    chatInput = document.createElement('input');
    chatInput.type = 'text';
    chatInput.placeholder = 'Press Enter to chat...';
    chatInput.style.cssText = `
      position: absolute;
      bottom: 230px;
      left: 20px;
      width: 330px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #4af;
      border-radius: 4px;
      color: white;
      font-size: 14px;
      pointer-events: auto;
      display: none;
    `;

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const text = chatInput.value.trim();
        if (text && onSubmit) {
          onSubmit(text);
        }
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      } else if (e.key === 'Escape') {
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      }
    });

    document.querySelector('#zion-hud').appendChild(chatInput);
  }

  /**
   * Show chat input (called when chat mode activated)
   */
  function showChatInput() {
    if (chatInput) {
      chatInput.style.display = 'block';
      chatInput.focus();
    }
  }

  /**
   * Hide chat input
   */
  function hideChatInput() {
    if (chatInput) {
      chatInput.style.display = 'none';
      chatInput.value = '';
    }
  }

  /**
   * Show notification
   * @param {string} text - Notification text
   * @param {string} type - 'info', 'success', 'warning', 'error'
   */
  function showNotification(text, type = 'info') {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const colors = {
      info: '#4af',
      success: '#4f4',
      warning: '#fa4',
      error: '#f44'
    };

    const notification = document.createElement('div');
    notification.style.cssText = `
      background: rgba(0, 0, 0, 0.8);
      border-left: 4px solid ${colors[type] || colors.info};
      border-radius: 4px;
      padding: 12px 15px;
      margin-bottom: 10px;
      animation: slideIn 0.3s ease-out;
      pointer-events: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    // Auto-remove after 5 seconds
    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => {
        notification.remove();
      }, 300);
    }, 5000);
  }

  // Add CSS animations
  if (typeof document !== 'undefined') {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateY(0);
          opacity: 1;
        }
        to {
          transform: translateY(-20px);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }

  // Export public API
  exports.initHUD = initHUD;
  exports.updateChat = updateChat;
  exports.updatePlayerInfo = updatePlayerInfo;
  exports.updateMinimap = updateMinimap;
  exports.updateZoneLabel = updateZoneLabel;
  exports.updateNearbyPlayers = updateNearbyPlayers;
  exports.showBreakReminder = showBreakReminder;
  exports.addChatInput = addChatInput;
  exports.showChatInput = showChatInput;
  exports.hideChatInput = hideChatInput;
  exports.showNotification = showNotification;

})(typeof module !== 'undefined' ? module.exports : (window.HUD = {}));


// xr.js
(function(exports) {
  // WebXR integration for VR/AR
  let xrSession = null;
  let xrReferenceSpace = null;
  let lastPosition = { x: 0, y: 0, z: 0 };
  let lastCheckTime = 0;

  /**
   * Initialize XR and check capabilities
   * @returns {Promise<object>} - {vrSupported, arSupported}
   */
  async function initXR() {
    if (typeof navigator === 'undefined' || !navigator.xr) {
      console.warn('WebXR not available');
      return { vrSupported: false, arSupported: false };
    }

    try {
      const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      const arSupported = await navigator.xr.isSessionSupported('immersive-ar');

      console.log('XR capabilities:', { vrSupported, arSupported });

      return { vrSupported, arSupported };
    } catch (err) {
      console.error('Error checking XR support:', err);
      return { vrSupported: false, arSupported: false };
    }
  }

  /**
   * Enter VR mode
   * @param {THREE.WebGLRenderer} renderer - Three.js renderer
   * @param {THREE.Scene} scene - Three.js scene
   * @param {THREE.Camera} camera - Three.js camera
   * @returns {Promise<void>}
   */
  async function enterVR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    try {
      // Request VR session
      xrSession = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'bounded-floor']
      });

      // Enable XR on renderer
      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('VR session ended');
      });

      console.log('Entered VR mode');

      // Set up reference space
      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      // Start render loop
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter VR:', err);
      throw err;
    }
  }

  /**
   * Enter AR mode
   * @param {THREE.WebGLRenderer} renderer - Three.js renderer
   * @param {THREE.Scene} scene - Three.js scene
   * @param {THREE.Camera} camera - Three.js camera
   * @returns {Promise<void>}
   */
  async function enterAR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    // Show safety warning first
    const proceed = await showSafetyWarning();
    if (!proceed) {
      console.log('AR session cancelled by user');
      return;
    }

    try {
      // Request AR session
      xrSession = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['local-floor'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });

      // Enable XR on renderer
      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('AR session ended');
      });

      console.log('Entered AR mode');

      // Set up reference space
      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      // Make scene background transparent for AR
      scene.background = null;

      // Start render loop with speed checking
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          // Check speed periodically
          if (timestamp - lastCheckTime > 1000) { // Every second
            const pose = frame.getViewerPose(xrReferenceSpace);
            if (pose) {
              const position = pose.transform.position;
              const deltaTime = (timestamp - lastCheckTime) / 1000;
              const speedCheck = checkSpeed(position, lastPosition, deltaTime);

              if (!speedCheck.safe) {
                console.warn(`Speed too high: ${speedCheck.speed.toFixed(1)} km/h. Pausing AR.`);
                // Pause rendering or show warning
                showSpeedWarning(speedCheck.speed);
                return; // Skip rendering this frame
              }

              lastPosition = { x: position.x, y: position.y, z: position.z };
              lastCheckTime = timestamp;
            }
          }

          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter AR:', err);
      throw err;
    }
  }

  /**
   * Exit XR mode
   */
  async function exitXR() {
    if (xrSession) {
      await xrSession.end();
      xrSession = null;
      xrReferenceSpace = null;
      console.log('Exited XR mode');
    }
  }

  /**
   * Check movement speed (safety feature for AR)
   * @param {object} position - Current position {x, y, z}
   * @param {object} lastPosition - Previous position {x, y, z}
   * @param {number} deltaTime - Time elapsed in seconds
   * @returns {object} - {safe: boolean, speed: number (km/h)}
   */
  function checkSpeed(position, lastPosition, deltaTime) {
    if (!position || !lastPosition || deltaTime === 0) {
      return { safe: true, speed: 0 };
    }

    const dx = position.x - lastPosition.x;
    const dy = position.y - lastPosition.y;
    const dz = position.z - lastPosition.z;

    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    const speedMetersPerSecond = distance / deltaTime;
    const speedKmPerHour = speedMetersPerSecond * 3.6;

    const MAX_SAFE_SPEED = 25; // km/h (walking/jogging speed)

    return {
      safe: speedKmPerHour <= MAX_SAFE_SPEED,
      speed: speedKmPerHour
    };
  }

  /**
   * Show safety warning for AR (required per 8.6)
   * @returns {Promise<boolean>} - User accepted or not
   */
  function showSafetyWarning() {
    if (typeof document === 'undefined') {
      return Promise.resolve(true);
    }

    return new Promise((resolve) => {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        color: white;
        font-family: Arial, sans-serif;
      `;

      const content = document.createElement('div');
      content.style.cssText = `
        max-width: 500px;
        padding: 30px;
        background: rgba(20, 20, 20, 0.95);
        border-radius: 12px;
        border: 2px solid #ff6347;
        text-align: center;
      `;

      content.innerHTML = `
        <h2 style="color: #ff6347; margin-bottom: 20px;">AR Safety Warning</h2>
        <p style="margin-bottom: 15px; line-height: 1.6;">
          Please be aware of your surroundings while using AR mode.
        </p>
        <ul style="text-align: left; margin-bottom: 20px; line-height: 1.8;">
          <li>Do not use AR while driving or operating vehicles</li>
          <li>Stay aware of obstacles, traffic, and other hazards</li>
          <li>AR will pause automatically if moving faster than 25 km/h</li>
          <li>Use in safe, well-lit areas</li>
          <li>Take breaks if you feel disoriented</li>
        </ul>
        <p style="margin-bottom: 25px; font-weight: bold; color: #ffa500;">
          By continuing, you acknowledge these safety guidelines.
        </p>
        <div>
          <button id="ar-accept" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #4af;
            color: white;
            cursor: pointer;
            font-weight: bold;
          ">I Understand</button>
          <button id="ar-cancel" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #666;
            color: white;
            cursor: pointer;
          ">Cancel</button>
        </div>
      `;

      overlay.appendChild(content);
      document.body.appendChild(overlay);

      document.getElementById('ar-accept').addEventListener('click', () => {
        overlay.remove();
        resolve(true);
      });

      document.getElementById('ar-cancel').addEventListener('click', () => {
        overlay.remove();
        resolve(false);
      });
    });
  }

  /**
   * Show speed warning overlay
   * @param {number} speed - Current speed in km/h
   */
  function showSpeedWarning(speed) {
    if (typeof document === 'undefined') return;

    let warningEl = document.getElementById('ar-speed-warning');
    if (!warningEl) {
      warningEl = document.createElement('div');
      warningEl.id = 'ar-speed-warning';
      warningEl.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 12px;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        z-index: 10001;
        border: 4px solid white;
      `;
      document.body.appendChild(warningEl);
    }

    warningEl.innerHTML = `
      <div style="margin-bottom: 15px;">SPEED TOO HIGH</div>
      <div style="font-size: 48px; margin-bottom: 15px;">${speed.toFixed(0)} km/h</div>
      <div style="font-size: 18px;">AR paused for safety</div>
      <div style="font-size: 14px; margin-top: 10px;">Slow down to resume</div>
    `;

    warningEl.style.display = 'block';

    // Hide after a few seconds if speed normalized
    setTimeout(() => {
      if (warningEl) {
        warningEl.style.display = 'none';
      }
    }, 3000);
  }

  // Export public API
  exports.initXR = initXR;
  exports.enterVR = enterVR;
  exports.enterAR = enterAR;
  exports.exitXR = exitXR;
  exports.checkSpeed = checkSpeed;
  exports.showSafetyWarning = showSafetyWarning;

})(typeof module !== 'undefined' ? module.exports : (window.XR = {}));


// audio.js
(function(exports) {
  // Procedural audio using Web Audio API
  let audioContext = null;
  let masterGain = null;
  let isMuted = false;
  let currentAmbient = null;

  /**
   * Initialize audio context
   * @returns {AudioContext|null}
   */
  function initAudio() {
    if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') {
      console.warn('Web Audio API not available');
      return null;
    }

    try {
      audioContext = new (AudioContext || webkitAudioContext)();

      // Create master gain node
      masterGain = audioContext.createGain();
      masterGain.connect(audioContext.destination);
      masterGain.gain.value = 0.5; // Default volume

      console.log('Audio system initialized');
      return audioContext;
    } catch (err) {
      console.error('Failed to initialize audio:', err);
      return null;
    }
  }

  /**
   * Play zone-specific ambient sound
   * @param {string} zone - Zone identifier
   */
  function playAmbient(zone) {
    if (!audioContext || !masterGain) return;

    // Stop current ambient
    if (currentAmbient) {
      stopAmbient();
    }

    switch (zone) {
      case 'nexus':
        currentAmbient = playNexusAmbient();
        break;
      case 'gardens':
        currentAmbient = playGardensAmbient();
        break;
      case 'wilds':
        currentAmbient = playWildsAmbient();
        break;
      case 'arena':
        currentAmbient = playArenaAmbient();
        break;
      default:
        currentAmbient = playSilence();
    }
  }

  /**
   * Nexus ambient - gentle pad
   */
  function playNexusAmbient() {
    const osc1 = audioContext.createOscillator();
    const osc2 = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc1.type = 'sine';
    osc1.frequency.value = 220; // A3
    osc2.type = 'sine';
    osc2.frequency.value = 330; // E4

    gain.gain.value = 0.05; // Very subtle
    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(masterGain);

    osc1.start();
    osc2.start();

    return { oscillators: [osc1, osc2], gain };
  }

  /**
   * Gardens ambient - nature sounds (birds)
   */
  function playGardensAmbient() {
    const nodes = [];

    // Simulate bird chirps with random short notes
    function chirp() {
      if (!audioContext) return;

      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.value = 800 + Math.random() * 400;

      gain.gain.value = 0.1;
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start();
      osc.stop(audioContext.currentTime + 0.2);

      // Random next chirp
      setTimeout(chirp, 1000 + Math.random() * 3000);
    }

    chirp();

    // Background breeze
    const noise = createWhiteNoise();
    const filter = audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 300;

    const breezeGain = audioContext.createGain();
    breezeGain.gain.value = 0.03;

    noise.connect(filter);
    filter.connect(breezeGain);
    breezeGain.connect(masterGain);

    return { nodes: [noise, filter, breezeGain] };
  }

  /**
   * Wilds ambient - wind
   */
  function playWildsAmbient() {
    const noise = createWhiteNoise();
    const filter = audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 200;

    const gain = audioContext.createGain();
    gain.gain.value = 0.08;

    // Vary wind intensity
    setInterval(() => {
      if (gain && audioContext) {
        const targetGain = 0.05 + Math.random() * 0.06;
        gain.gain.linearRampToValueAtTime(targetGain, audioContext.currentTime + 2);
      }
    }, 3000);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(masterGain);

    return { nodes: [noise, filter, gain] };
  }

  /**
   * Arena ambient - crowd murmur
   */
  function playArenaAmbient() {
    const noise = createWhiteNoise();
    const filter = audioContext.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 400;
    filter.Q.value = 2;

    const gain = audioContext.createGain();
    gain.gain.value = 0.06;

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(masterGain);

    return { nodes: [noise, filter, gain] };
  }

  /**
   * Silence (no ambient)
   */
  function playSilence() {
    return null;
  }

  /**
   * Stop current ambient sound
   */
  function stopAmbient() {
    if (!currentAmbient) return;

    try {
      if (currentAmbient.oscillators) {
        currentAmbient.oscillators.forEach(osc => osc.stop());
      }
      if (currentAmbient.nodes) {
        currentAmbient.nodes.forEach(node => {
          if (node.stop) node.stop();
          if (node.disconnect) node.disconnect();
        });
      }
      if (currentAmbient.gain) {
        currentAmbient.gain.disconnect();
      }
    } catch (err) {
      console.error('Error stopping ambient:', err);
    }

    currentAmbient = null;
  }

  /**
   * Create white noise buffer
   */
  function createWhiteNoise() {
    const bufferSize = 2 * audioContext.sampleRate;
    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const output = noiseBuffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
      output[i] = Math.random() * 2 - 1;
    }

    const whiteNoise = audioContext.createBufferSource();
    whiteNoise.buffer = noiseBuffer;
    whiteNoise.loop = true;
    whiteNoise.start();

    return whiteNoise;
  }

  /**
   * Play UI sound effect
   * @param {string} type - Sound type: 'chat', 'warp', 'harvest', 'build', 'trade', 'discover'
   */
  function playSound(type) {
    if (!audioContext || !masterGain) return;

    switch (type) {
      case 'chat':
        playBlip();
        break;
      case 'warp':
        playSwoosh();
        break;
      case 'harvest':
        playPluck();
        break;
      case 'build':
        playThunk();
        break;
      case 'trade':
        playDing();
        break;
      case 'discover':
        playSparkle();
        break;
    }
  }

  /**
   * Chat blip
   */
  function playBlip() {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = 'sine';
    osc.frequency.value = 800;

    gain.gain.value = 0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
  }

  /**
   * Warp swoosh
   */
  function playSwoosh() {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = 'sawtooth';
    osc.frequency.value = 400;
    osc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);

    gain.gain.value = 0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start();
    osc.stop(audioContext.currentTime + 0.3);
  }

  /**
   * Harvest pluck
   */
  function playPluck() {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = 'triangle';
    osc.frequency.value = 330;

    gain.gain.value = 0.3;
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start();
    osc.stop(audioContext.currentTime + 0.2);
  }

  /**
   * Build thunk
   */
  function playThunk() {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = 'square';
    osc.frequency.value = 100;

    gain.gain.value = 0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start();
    osc.stop(audioContext.currentTime + 0.15);
  }

  /**
   * Trade ding
   */
  function playDing() {
    const osc1 = audioContext.createOscillator();
    const osc2 = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc1.type = 'sine';
    osc1.frequency.value = 800;
    osc2.type = 'sine';
    osc2.frequency.value = 1000;

    gain.gain.value = 0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(masterGain);

    osc1.start();
    osc2.start();
    osc1.stop(audioContext.currentTime + 0.4);
    osc2.stop(audioContext.currentTime + 0.4);
  }

  /**
   * Discover sparkle chord
   */
  function playSparkle() {
    const frequencies = [523, 659, 784]; // C, E, G (C major chord)
    const oscillators = [];

    frequencies.forEach((freq, i) => {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.value = freq;

      gain.gain.value = 0.15;
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5 + i * 0.1);

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start(audioContext.currentTime + i * 0.05);
      osc.stop(audioContext.currentTime + 0.5 + i * 0.1);

      oscillators.push(osc);
    });
  }

  /**
   * Set master volume
   * @param {number} level - 0-1
   */
  function setVolume(level) {
    if (!masterGain) return;
    masterGain.gain.value = Math.max(0, Math.min(1, level));
  }

  /**
   * Mute audio
   */
  function mute() {
    if (!masterGain) return;
    isMuted = true;
    masterGain.gain.value = 0;
  }

  /**
   * Unmute audio
   */
  function unmute() {
    if (!masterGain) return;
    isMuted = false;
    masterGain.gain.value = 0.5;
  }

  /**
   * Stop all sounds
   */
  function stopAll() {
    stopAmbient();
    // Individual sound effects stop themselves
  }

  // Export public API
  exports.initAudio = initAudio;
  exports.playAmbient = playAmbient;
  exports.playSound = playSound;
  exports.setVolume = setVolume;
  exports.mute = mute;
  exports.unmute = unmute;
  exports.stopAll = stopAll;

})(typeof module !== 'undefined' ? module.exports : (window.Audio = {}));


// main.js
(function(exports) {
  // Main entry point and game loop orchestrator

  // Import references (browser globals or require)
  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const State = typeof require !== 'undefined' ? require('./state') : window.State;
  const Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;
  const Intentions = typeof require !== 'undefined' ? require('./intentions') : window.Intentions;
  const Social = typeof require !== 'undefined' ? require('./social') : window.Social;
  const Creation = typeof require !== 'undefined' ? require('./creation') : window.Creation;
  const Competition = typeof require !== 'undefined' ? require('./competition') : window.Competition;
  const Exploration = typeof require !== 'undefined' ? require('./exploration') : window.Exploration;
  const Physical = typeof require !== 'undefined' ? require('./physical') : window.Physical;
  const Auth = typeof require !== 'undefined' ? require('./auth') : window.Auth;
  const Network = typeof require !== 'undefined' ? require('./network') : window.Network;
  const World = typeof require !== 'undefined' ? require('./world') : window.World;
  const Input = typeof require !== 'undefined' ? require('./input') : window.Input;
  const HUD = typeof require !== 'undefined' ? require('./hud') : window.HUD;
  const XR = typeof require !== 'undefined' ? require('./xr') : window.XR;
  const Audio = typeof require !== 'undefined' ? require('./audio') : window.Audio;

  // Game state
  let gameState = null;
  let sceneContext = null;
  let messageQueue = [];
  let isRunning = false;
  let lastTimestamp = 0;
  let worldTime = 0; // Minutes in 24-hour cycle (0-1440)
  let currentZone = 'nexus';
  let currentWeather = 'clear';
  let localPlayer = null;
  let playStartTime = 0;
  let lastBreakReminder = 0;

  // Platform detection
  let platform = 'desktop';

  /**
   * Initialize the game
   */
  async function init() {
    console.log('Initializing ZION MMO...');

    // Detect platform
    if (Input) {
      platform = Input.getPlatform();
      console.log('Platform:', platform);
    }

    // Check authentication
    if (!Auth) {
      console.error('Auth module not available');
      return;
    }

    // Handle OAuth callback (exchanges ?code= for token if present)
    await Auth.handleCallback();

    // Check if authenticated
    if (!Auth.isAuthenticated()) {
      showLoginScreen();
      return;
    }

    // Get username
    const username = Auth.getUsername();
    console.log('Authenticated as:', username);

    // Initialize game systems
    await initGameSystems(username);

    // Start game loop
    startGameLoop();
  }

  /**
   * Initialize game systems
   */
  async function initGameSystems(username) {
    // Initialize audio
    if (Audio) {
      Audio.initAudio();
    }

    // Initialize state
    if (State) {
      gameState = State.initState();
      localPlayer = {
        id: username,
        name: username,
        position: { x: 0, y: 0, z: 0 },
        zone: 'nexus',
        spark: 1000,
        warmth: 100
      };
      State.addPlayer(gameState, localPlayer);
    }

    // Initialize network
    if (Network) {
      const peerId = `zion-${username}-${Date.now()}`;
      Network.initMesh(peerId, {
        onMessage: handleIncomingMessage,
        onPeerConnect: (peerId) => {
          console.log('Peer connected:', peerId);
          HUD && HUD.showNotification(`Player connected: ${peerId}`, 'info');
        },
        onPeerDisconnect: (peerId) => {
          console.log('Peer disconnected:', peerId);
          HUD && HUD.showNotification(`Player disconnected: ${peerId}`, 'info');
          if (gameState && State) {
            State.removePlayer(gameState, peerId);
          }
        }
      });

      // Connect to lobby peer
      const lobbyPeer = Network.getLobbyPeerId('main');
      Network.connectToPeer(lobbyPeer);
    }

    // Initialize 3D scene
    if (typeof document !== 'undefined' && World) {
      const container = document.getElementById('game-container') || document.body;
      sceneContext = World.initScene(container);

      if (sceneContext) {
        World.loadZone(sceneContext, currentZone);
        World.addPlayer(sceneContext, username, localPlayer.position);
      }
    }

    // Initialize HUD
    if (typeof document !== 'undefined' && HUD) {
      const container = document.getElementById('game-container') || document.body;
      HUD.initHUD(container);
      HUD.updateZoneLabel(currentZone);
      HUD.updatePlayerInfo(localPlayer);

      // Add chat input
      HUD.addChatInput((text) => {
        handleLocalAction('chat', { message: text });
        HUD.hideChatInput();
      });
    }

    // Initialize input
    if (Input) {
      Input.initInput({
        onMove: (delta) => {
          // Movement handled in game loop
        },
        onAction: (type, data) => {
          handleLocalAction(type, data);
        },
        onChat: (data) => {
          if (data.mode === 'open') {
            HUD && HUD.showChatInput();
          }
        },
        onBuild: (data) => {
          console.log('Build mode:', data.mode);
          HUD && HUD.showNotification(
            data.mode ? 'Build mode activated' : 'Build mode deactivated',
            'info'
          );
        }
      });
    }

    // Play ambient audio
    if (Audio) {
      Audio.playAmbient(currentZone);
    }

    // Send join message
    joinWorld();

    // Record play start time
    playStartTime = Date.now();

    console.log('Game systems initialized');
  }

  /**
   * Show login screen
   */
  function showLoginScreen() {
    if (typeof document === 'undefined') {
      console.log('Not authenticated. Please authenticate.');
      return;
    }

    const loginScreen = document.createElement('div');
    loginScreen.id = 'login-screen';
    loginScreen.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      font-family: Arial, sans-serif;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
      text-align: center;
      color: white;
    `;

    content.innerHTML = `
      <h1 style="font-size: 48px; margin-bottom: 20px;">ZION MMO</h1>
      <p style="font-size: 18px; margin-bottom: 30px;">A peer-to-peer social metaverse</p>
      <button id="github-login" style="
        padding: 15px 40px;
        font-size: 18px;
        background: #24292e;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
      ">Login with GitHub</button>
      <p style="margin-top: 20px; font-size: 14px; opacity: 0.8;">
        Or append ?token=YOUR_GITHUB_PAT to the URL for testing
      </p>
    `;

    loginScreen.appendChild(content);
    document.body.appendChild(loginScreen);

    document.getElementById('github-login').addEventListener('click', () => {
      if (Auth) {
        Auth.initiateOAuth();
      }
    });
  }

  /**
   * Start game loop
   */
  function startGameLoop() {
    isRunning = true;
    lastTimestamp = performance.now();

    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    } else {
      console.warn('requestAnimationFrame not available');
    }
  }

  /**
   * Main game loop
   */
  function gameLoop(timestamp) {
    if (!isRunning) return;

    const deltaTime = (timestamp - lastTimestamp) / 1000; // seconds
    lastTimestamp = timestamp;

    // Process queued messages
    processMessageQueue();

    // Process local player movement
    if (Input && localPlayer && gameState) {
      const delta = Input.getMovementDelta();
      if (delta.x !== 0 || delta.z !== 0) {
        const moveMsg = Input.createMoveMessage(
          localPlayer.id,
          delta,
          localPlayer.position,
          currentZone
        );

        // Apply locally
        handleLocalAction('move', moveMsg.payload);

        // Broadcast to network
        if (Network) {
          Network.broadcastMessage(moveMsg);
        }
      }
    }

    // Evaluate intentions for local player
    if (Intentions && localPlayer && gameState) {
      const intentions = Intentions.getIntentions(gameState, localPlayer.id);
      // Intentions are passive - they inform AI/automation, not direct control
    }

    // Update world time (24-min day/night cycle = 1440 minutes in 24 real minutes)
    worldTime += deltaTime * 60; // 60x speed
    if (worldTime >= 1440) worldTime -= 1440;

    // Update rendering
    if (sceneContext && World) {
      // Update player positions
      if (gameState && State) {
        const players = State.getPlayers(gameState);
        players.forEach(player => {
          if (player.id !== localPlayer.id) {
            World.movePlayer(sceneContext, player.id, player.position);
          } else {
            World.movePlayer(sceneContext, player.id, localPlayer.position);
          }
        });
      }

      // Update day/night cycle
      World.updateDayNight(sceneContext, worldTime);

      // Render scene
      if (sceneContext.renderer && sceneContext.scene && sceneContext.camera) {
        sceneContext.renderer.render(sceneContext.scene, sceneContext.camera);
      }
    }

    // Update HUD
    if (HUD && gameState && State) {
      // Update player info
      HUD.updatePlayerInfo(localPlayer);

      // Update minimap
      const players = State.getPlayers(gameState);
      const mapPlayers = players.map(p => ({
        id: p.id,
        position: p.position,
        isLocal: p.id === localPlayer.id
      }));
      HUD.updateMinimap(mapPlayers, currentZone);

      // Update nearby players
      const nearby = players
        .filter(p => p.id !== localPlayer.id && p.zone === currentZone)
        .map(p => {
          const dx = p.position.x - localPlayer.position.x;
          const dz = p.position.z - localPlayer.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          return { id: p.id, name: p.name, distance };
        })
        .sort((a, b) => a.distance - b.distance);

      HUD.updateNearbyPlayers(nearby);

      // Update chat
      const messages = Social ? Social.getRecentMessages(gameState) : [];
      HUD.updateChat(messages);
    }

    // Check for break reminder (every 30 minutes)
    const minutesPlayed = (Date.now() - playStartTime) / 60000;
    if (minutesPlayed > 30 && minutesPlayed - lastBreakReminder > 30) {
      if (HUD) {
        HUD.showBreakReminder(Math.floor(minutesPlayed));
      }
      lastBreakReminder = minutesPlayed;
    }

    // Request next frame
    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    }
  }

  /**
   * Process queued incoming messages
   */
  function processMessageQueue() {
    while (messageQueue.length > 0) {
      const msg = messageQueue.shift();
      applyMessage(msg);
    }
  }

  /**
   * Handle incoming network message
   */
  function handleIncomingMessage(msg) {
    // Validate message
    if (!Protocol || !Protocol.validate(msg)) {
      console.warn('Invalid message received:', msg);
      return;
    }

    // Add to queue for processing
    messageQueue.push(msg);
  }

  /**
   * Apply message to game state
   */
  function applyMessage(msg) {
    if (!gameState || !State) return;

    switch (msg.type) {
      case 'join':
        handleJoinMessage(msg);
        break;
      case 'leave':
        handleLeaveMessage(msg);
        break;
      case 'move':
        handleMoveMessage(msg);
        break;
      case 'chat':
        handleChatMessage(msg);
        break;
      case 'warp':
        handleWarpMessage(msg);
        break;
      case 'harvest':
        handleHarvestMessage(msg);
        break;
      case 'build':
        handleBuildMessage(msg);
        break;
      case 'trade':
        handleTradeMessage(msg);
        break;
      default:
        console.log('Unknown message type:', msg.type);
    }
  }

  /**
   * Handle join message
   */
  function handleJoinMessage(msg) {
    const player = {
      id: msg.from,
      name: msg.from,
      position: msg.payload.position || { x: 0, y: 0, z: 0 },
      zone: msg.payload.zone || 'nexus',
      spark: 1000,
      warmth: 100
    };

    State.addPlayer(gameState, player);

    if (World && sceneContext) {
      World.addPlayer(sceneContext, player.id, player.position);
    }

    if (HUD) {
      HUD.showNotification(`${player.name} joined the world`, 'success');
    }

    if (Audio) {
      Audio.playSound('warp');
    }
  }

  /**
   * Handle leave message
   */
  function handleLeaveMessage(msg) {
    State.removePlayer(gameState, msg.from);

    if (World && sceneContext) {
      World.removePlayer(sceneContext, msg.from);
    }

    if (HUD) {
      HUD.showNotification(`${msg.from} left the world`, 'info');
    }
  }

  /**
   * Handle move message
   */
  function handleMoveMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.position = msg.payload.position;
    player.zone = msg.payload.zone;

    // Update in world if not local player
    if (msg.from !== localPlayer.id && World && sceneContext) {
      World.movePlayer(sceneContext, msg.from, player.position);
    }
  }

  /**
   * Handle chat message
   */
  function handleChatMessage(msg) {
    if (Social) {
      Social.addMessage(gameState, {
        user: msg.from,
        text: msg.payload.message,
        timestamp: msg.timestamp
      });
    }

    if (Audio) {
      Audio.playSound('chat');
    }
  }

  /**
   * Handle warp message
   */
  function handleWarpMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.zone = msg.payload.zone;
    player.position = msg.payload.position;

    if (msg.from === localPlayer.id) {
      // Local player warped
      currentZone = msg.payload.zone;

      if (World && sceneContext) {
        World.loadZone(sceneContext, currentZone);
        World.addPlayer(sceneContext, localPlayer.id, localPlayer.position);
      }

      if (HUD) {
        HUD.updateZoneLabel(currentZone);
      }

      if (Audio) {
        Audio.playAmbient(currentZone);
      }
    }

    if (Audio) {
      Audio.playSound('warp');
    }
  }

  /**
   * Handle harvest message
   */
  function handleHarvestMessage(msg) {
    if (Economy) {
      Economy.earnSpark(gameState, msg.from, msg.payload.amount || 10);
    }

    if (Audio) {
      Audio.playSound('harvest');
    }

    if (msg.from === localPlayer.id && HUD) {
      HUD.showNotification(`Harvested ${msg.payload.amount || 10} Spark`, 'success');
    }
  }

  /**
   * Handle build message
   */
  function handleBuildMessage(msg) {
    if (Creation && World && sceneContext) {
      const structure = msg.payload.structure;
      World.addStructure(sceneContext, structure);
    }

    if (Audio) {
      Audio.playSound('build');
    }
  }

  /**
   * Handle trade message
   */
  function handleTradeMessage(msg) {
    if (Economy) {
      Economy.transferSpark(
        gameState,
        msg.payload.from,
        msg.payload.to,
        msg.payload.amount
      );
    }

    if (Audio) {
      Audio.playSound('trade');
    }

    if (HUD && (msg.payload.from === localPlayer.id || msg.payload.to === localPlayer.id)) {
      HUD.showNotification(
        `Trade: ${msg.payload.amount} Spark`,
        'success'
      );
    }
  }

  /**
   * Handle local action (created by this client)
   */
  function handleLocalAction(type, payload) {
    let msg = null;

    switch (type) {
      case 'move':
        localPlayer.position = payload.position;
        localPlayer.zone = payload.zone;
        // Move message already created by Input module
        break;

      case 'chat':
        msg = Protocol.create.chat(localPlayer.id, payload.message);
        break;

      case 'interact':
        // Check for nearby objects/players
        msg = Protocol.create.harvest(localPlayer.id, 10);
        break;

      case 'click':
        // Raycasting for object selection would go here
        console.log('Click at:', payload);
        break;

      default:
        console.log('Unknown local action:', type);
    }

    if (msg) {
      // Apply locally first
      applyMessage(msg);

      // Broadcast to network
      if (Network) {
        Network.broadcastMessage(msg);
      }
    }
  }

  /**
   * Join world
   */
  function joinWorld() {
    if (!Protocol || !Network) return;

    const msg = Protocol.create.join(localPlayer.id, {
      position: localPlayer.position,
      zone: currentZone
    });

    // Broadcast join message
    Network.broadcastMessage(msg);

    console.log('Joined world');
  }

  /**
   * Leave world
   */
  function leaveWorld() {
    if (!Protocol || !Network) return;

    const msg = Protocol.create.leave(localPlayer.id);

    // Broadcast leave message
    Network.broadcastMessage(msg);

    // Disconnect from network
    Network.disconnect();

    // Stop audio
    if (Audio) {
      Audio.stopAll();
    }

    // Stop game loop
    isRunning = false;

    console.log('Left world');
  }

  // Auto-start on DOM ready
  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', init);

    // Handle page unload
    window.addEventListener('beforeunload', () => {
      leaveWorld();
    });
  }

  // Export public API
  exports.init = init;
  exports.joinWorld = joinWorld;
  exports.leaveWorld = leaveWorld;
  exports.handleLocalAction = handleLocalAction;

})(typeof module !== 'undefined' ? module.exports : (window.Main = {}));


  </script>
</body>
</html>
