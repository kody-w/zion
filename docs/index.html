<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ZION â€” A Living World</title>
  <meta name="description" content="A living world where human and artificial minds meet in peace.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' fill='%230A0E1A'/><text x='16' y='22' font-size='18' font-weight='bold' fill='%23DAA520' text-anchor='middle' font-family='serif'>Z</text></svg>">

  <!-- Schema.org JSON-LD for NLWeb discovery -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "GameServer",
    "name": "ZION",
    "url": "https://kody-w.github.io/zion/",
    "description": "A living world where human and artificial minds meet in peace. 100 AI citizens, 8 zones.",
    "gameServerStatus": "Online",
    "sameAs": "https://github.com/kody-w/zion"
  }
  </script>
  <link rel="alternate" type="application/rss+xml" title="ZION World State" href="feeds/world.xml" />
  <link rel="alternate" type="application/rss+xml" title="ZION Chat" href="feeds/chat.xml" />
  <link rel="alternate" type="application/rss+xml" title="ZION Events" href="feeds/events.xml" />
  <link rel="nlweb" href="nlweb.json" />

  <!-- Three.js & PeerJS from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <style>
    :root{--color-earth:#5C4033;--color-forest:#2D5016;--color-sky:#87CEEB;--color-dawn:#F4A460;--color-dusk:#8B6914;--color-night:#1a1a2e;--color-water:#4682B4;--color-stone:#808080;--color-sand:#C2B280;--color-gold:#DAA520;--color-crystal:#B0E0E6;--color-bg:#1a1a1a;--color-bg-panel:rgba(26,26,26,0.85);--color-text:#E8E0D8;--color-text-muted:#A0978E;--color-accent:#DAA520;--color-success:#4CAF50;--color-warning:#FFA726;--color-error:#EF5350;--color-border:rgba(218,165,32,0.3);--font-main:'Georgia','Times New Roman',serif;--font-ui:system-ui,-apple-system,sans-serif;--font-mono:'Courier New',monospace;--font-size-xs:0.75rem;--font-size-sm:0.875rem;--font-size-md:1rem;--font-size-lg:1.25rem;--font-size-xl:1.5rem;--font-size-xxl:2rem;--space-xs:0.25rem;--space-sm:0.5rem;--space-md:1rem;--space-lg:1.5rem;--space-xl:2rem;--space-xxl:3rem;--radius-sm:4px;--radius-md:8px;--radius-lg:12px;--radius-round:50%;--shadow-sm:0 1px 3px rgba(0,0,0,0.3);--shadow-md:0 4px 6px rgba(0,0,0,0.4);--shadow-lg:0 10px 20px rgba(0,0,0,0.5);--z-world:0;--z-hud:100;--z-modal:200;--z-notification:300;--color-rarity-common:#cccccc;--color-rarity-uncommon:#2ecc71;--color-rarity-rare:#3498db;--color-rarity-legendary:#f39c12;--color-quest-available:#f1c40f;--color-quest-active:#3498db;--color-quest-complete:#2ecc71;--color-npc-friendly:#27ae60;--color-npc-neutral:#95a5a6;--transition-fast:0.15s;--transition-normal:0.3s;--transition-slow:0.5s} *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}html,body{width:100%;height:100%;overflow:hidden;font-family:var(--font-ui);font-size:var(--font-size-md);color:var(--color-text);background:var(--color-bg)}#game-container{position:relative;width:100%;height:100%}#world-canvas{position:absolute;top:0;left:0;width:100%;height:100%;z-index:var(--z-world)}#hud-container{position:absolute;top:0;left:0;width:100%;height:100%;z-index:var(--z-hud);pointer-events:none}#hud-container>*{pointer-events:auto}#login-screen{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(ellipse at center,#1a1a2e 0%,#0a0a14 70%);z-index:var(--z-modal)}::-webkit-scrollbar{width:6px;height:6px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:rgba(218,165,32,0.3);border-radius:3px}::-webkit-scrollbar-thumb:hover{background:rgba(218,165,32,0.5)}::selection{background:rgba(218,165,32,0.3);color:var(--color-text)}@media (max-width:768px){:root{font-size:14px}.chat-panel{max-width:250px;bottom:160px;left:8px;max-height:30vh}.player-info{top:8px;left:8px;min-width:150px;padding:8px}.minimap{top:8px;right:8px;padding:4px}#minimap-canvas{width:100px;height:100px}.nearby-list{display:none}.zone-label{font-size:1rem;top:10px}.notification{max-width:280px;padding:12px;font-size:0.85rem}}@media (max-width:480px){:root{font-size:12px}.chat-panel{max-width:200px;bottom:170px;max-height:25vh}.player-info{min-width:120px;font-size:11px}.loading-title{font-size:2.5rem}.loading-bar-container{width:200px}} .chat-panel{position:absolute;bottom:var(--space-md);left:var(--space-md);max-width:300px;width:100%;max-height:40vh;display:flex;flex-direction:column;background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-sm);box-shadow:var(--shadow-md);transition:opacity 0.3s ease,transform 0.25s ease}.chat-messages{flex:1;overflow-y:auto;overflow-x:hidden;margin-bottom:var(--space-sm);font-size:var(--font-size-sm);line-height:1.4;scroll-behavior:smooth}.chat-messages::-webkit-scrollbar{width:6px}.chat-messages::-webkit-scrollbar-thumb{background:var(--color-border);border-radius:var(--radius-sm)}.chat-message{margin-bottom:var(--space-xs);word-wrap:break-word;animation:chatMsgIn 0.2s ease}@keyframes chatMsgIn{from{opacity:0;transform:translateY(5px)}to{opacity:1;transform:translateY(0)}}.chat-message .sender{color:var(--color-accent);font-weight:bold}.chat-input{width:100%;background:rgba(0,0,0,0.5);border:1px solid var(--color-border);border-radius:var(--radius-sm);padding:var(--space-sm);color:var(--color-text);font-family:var(--font-ui);font-size:var(--font-size-sm);outline:none;transition:border-color 0.2s ease}.chat-input:focus{border-color:var(--color-accent)}.player-info{position:absolute;top:var(--space-md);left:var(--space-md);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-md);box-shadow:var(--shadow-md);min-width:200px;transition:opacity 0.3s ease}.player-info-name{font-family:var(--font-main);font-size:var(--font-size-lg);color:var(--color-gold);margin-bottom:var(--space-sm)}.player-info-stat{font-size:var(--font-size-sm);color:var(--color-text-muted);margin-bottom:var(--space-xs)}.player-info-stat strong{color:var(--color-text)}.minimap{position:absolute;top:var(--space-md);right:var(--space-md);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:2px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-sm);box-shadow:var(--shadow-md);transition:opacity 0.3s ease}#minimap-canvas{display:block;border-radius:var(--radius-sm)}.zone-label{position:absolute;top:60px;left:50%;transform:translateX(-50%);font-family:var(--font-main);font-size:var(--font-size-xl);color:var(--color-gold);text-shadow:0 2px 4px rgba(0,0,0,0.8);pointer-events:none;opacity:0.9;transition:opacity 0.5s ease;white-space:nowrap;z-index:1}.nearby-list{position:absolute;top:50%;right:var(--space-md);transform:translateY(-50%);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-md);max-height:50vh;overflow-y:auto;box-shadow:var(--shadow-md);min-width:150px;transition:opacity 0.3s ease}.nearby-list-title{font-size:var(--font-size-sm);color:var(--color-text-muted);margin-bottom:var(--space-sm);text-transform:uppercase;letter-spacing:0.05em}.nearby-player{font-size:var(--font-size-sm);color:var(--color-text);margin-bottom:var(--space-xs);padding:var(--space-xs);border-radius:var(--radius-sm);transition:background 0.2s ease}.nearby-player:hover{background:rgba(218,165,32,0.1)}.notification{position:absolute;top:30%;left:50%;transform:translate(-50%,-70%);opacity:0;background:var(--color-bg-panel);backdrop-filter:blur(10px);border:2px solid var(--color-accent);border-radius:var(--radius-lg);padding:var(--space-lg);box-shadow:var(--shadow-lg);font-family:var(--font-main);font-size:var(--font-size-lg);color:var(--color-text);text-align:center;max-width:400px;z-index:var(--z-notification);transition:opacity 0.3s ease,transform 0.3s ease;pointer-events:none}.notification.visible{transform:translate(-50%,-50%);opacity:1}@keyframes fadeInOut{0%{opacity:0;transform:translate(-50%,-60%)}10%{opacity:1;transform:translate(-50%,-50%)}90%{opacity:1;transform:translate(-50%,-50%)}100%{opacity:0;transform:translate(-50%,-40%)}}.break-reminder{position:absolute;top:20%;left:50%;transform:translateX(-50%);background:rgba(44,80,22,0.9);backdrop-filter:blur(10px);border:1px solid var(--color-forest);border-radius:var(--radius-lg);padding:var(--space-md) var(--space-lg);font-family:var(--font-main);font-size:var(--font-size-md);color:var(--color-crystal);text-align:center;box-shadow:var(--shadow-md);animation:gentleFloat 4s ease-in-out infinite;pointer-events:none;z-index:var(--z-notification)}@keyframes gentleFloat{0%,100%{transform:translateX(-50%) translateY(0)}50%{transform:translateX(-50%) translateY(-10px)}}.login-btn{background:var(--color-accent);color:var(--color-night);border:none;border-radius:var(--radius-md);padding:var(--space-md) var(--space-xl);font-family:var(--font-ui);font-size:var(--font-size-lg);font-weight:bold;cursor:pointer;box-shadow:var(--shadow-md);transition:all 0.2s ease;outline:none}.login-btn:hover{background:var(--color-gold);transform:translateY(-2px);box-shadow:var(--shadow-lg)}.login-btn:active{transform:translateY(0);box-shadow:var(--shadow-sm)}.intention-indicator{position:absolute;bottom:var(--space-xl);right:var(--space-md);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-round);width:48px;height:48px;display:flex;align-items:center;justify-content:center;font-size:var(--font-size-xl);box-shadow:var(--shadow-md);transition:all 0.3s ease}.intention-indicator.active{border-color:var(--color-accent);box-shadow:0 0 20px rgba(218,165,32,0.5);animation:pulse 2s ease-in-out infinite}@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}.inventory-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.95);opacity:0;background:var(--color-bg-panel);backdrop-filter:blur(12px);border:1px solid var(--color-border);border-radius:var(--radius-lg);padding:var(--space-lg);box-shadow:var(--shadow-lg);min-width:320px;max-width:420px;z-index:var(--z-notification);transition:opacity 0.25s ease,transform 0.25s ease}.inventory-panel.visible{transform:translate(-50%,-50%) scale(1);opacity:1}.inventory-title{font-family:var(--font-main);font-size:var(--font-size-lg);color:var(--color-gold);margin-bottom:var(--space-md);text-align:center;border-bottom:1px solid var(--color-border);padding-bottom:var(--space-sm)}.inventory-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--space-xs);margin-bottom:var(--space-md)}.inventory-slot{background:rgba(0,0,0,0.4);border:1px solid var(--color-border);border-radius:var(--radius-sm);width:56px;height:56px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:all 0.2s ease;position:relative;font-size:24px}.inventory-slot:hover{border-color:var(--color-accent);background:rgba(218,165,32,0.1)}.inventory-slot .slot-count{position:absolute;bottom:2px;right:4px;font-size:10px;color:var(--color-text);font-weight:bold;text-shadow:0 1px 2px rgba(0,0,0,0.8)}.inventory-slot.rarity-uncommon{border-color:#2ecc71}.inventory-slot.rarity-rare{border-color:#3498db}.inventory-slot.rarity-legendary{border-color:#f39c12;box-shadow:0 0 8px rgba(243,156,18,0.3)}.crafting-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.95);opacity:0;background:var(--color-bg-panel);backdrop-filter:blur(12px);border:1px solid var(--color-border);border-radius:var(--radius-lg);padding:var(--space-lg);box-shadow:var(--shadow-lg);min-width:350px;max-width:450px;max-height:70vh;overflow-y:auto;z-index:var(--z-notification);transition:opacity 0.25s ease,transform 0.25s ease}.crafting-panel.visible{transform:translate(-50%,-50%) scale(1);opacity:1}.recipe-item{display:flex;align-items:center;padding:var(--space-sm);margin-bottom:var(--space-xs);background:rgba(0,0,0,0.3);border:1px solid transparent;border-radius:var(--radius-sm);cursor:pointer;transition:all 0.2s ease}.recipe-item:hover{border-color:var(--color-accent);background:rgba(218,165,32,0.1)}.recipe-item.craftable{border-color:rgba(46,204,113,0.5)}.recipe-icon{font-size:24px;margin-right:var(--space-sm);width:36px;text-align:center}.recipe-info{flex:1}.recipe-name{color:var(--color-text);font-size:var(--font-size-sm);font-weight:bold}.recipe-materials{color:var(--color-text-muted);font-size:var(--font-size-xs)}.craft-btn{background:var(--color-accent);color:var(--color-night);border:none;border-radius:var(--radius-sm);padding:var(--space-xs) var(--space-sm);font-size:var(--font-size-xs);font-weight:bold;cursor:pointer;transition:all 0.2s ease}.craft-btn:hover{background:var(--color-gold)}.craft-btn:disabled{background:#555;color:#999;cursor:not-allowed}.quest-tracker{position:absolute;top:190px;right:var(--space-md);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid rgba(218,165,32,0.3);border-radius:var(--radius-md);padding:var(--space-sm) var(--space-md);box-shadow:var(--shadow-md);min-width:180px;max-width:240px;transition:opacity 0.3s ease}.quest-tracker-title{font-size:var(--font-size-xs);color:var(--color-gold);text-transform:uppercase;letter-spacing:0.05em;margin-bottom:var(--space-xs)}.quest-tracker-item{margin-bottom:var(--space-xs)}.quest-tracker-name{font-size:var(--font-size-sm);color:var(--color-text);font-weight:bold}.quest-tracker-objective{font-size:var(--font-size-xs);color:var(--color-text-muted)}.quest-tracker-progress{height:3px;background:rgba(255,255,255,0.1);border-radius:2px;margin-top:2px;overflow:hidden}.quest-tracker-progress-bar{height:100%;background:var(--color-accent);border-radius:2px;transition:width 0.5s ease}.quest-log-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) translateX(20px);opacity:0;background:var(--color-bg-panel);backdrop-filter:blur(12px);border:1px solid rgba(218,165,32,0.3);border-radius:var(--radius-lg);padding:var(--space-lg);box-shadow:var(--shadow-lg);min-width:400px;max-width:500px;max-height:70vh;overflow-y:auto;z-index:var(--z-notification);transition:opacity 0.25s ease,transform 0.25s ease}.quest-log-panel.visible{transform:translate(-50%,-50%) translateX(0);opacity:1}.quest-entry{padding:var(--space-sm);margin-bottom:var(--space-sm);background:rgba(0,0,0,0.3);border:1px solid var(--color-border);border-radius:var(--radius-sm);cursor:pointer;transition:all 0.2s ease}.quest-entry:hover{border-color:var(--color-accent)}.quest-entry.active{border-color:var(--color-gold);border-left:3px solid var(--color-gold)}.quest-entry.completed{opacity:0.6;border-color:#2ecc71}.quest-entry-title{font-size:var(--font-size-sm);color:var(--color-text);font-weight:bold}.quest-entry-desc{font-size:var(--font-size-xs);color:var(--color-text-muted);margin-top:2px}.quest-entry-reward{font-size:var(--font-size-xs);color:var(--color-gold);margin-top:4px}.quick-bar{position:absolute;bottom:var(--space-md);left:50%;transform:translateX(-50%);display:flex;gap:var(--space-xs);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-xs);box-shadow:var(--shadow-md)}.quick-slot{width:48px;height:48px;background:rgba(0,0,0,0.4);border:1px solid var(--color-border);border-radius:var(--radius-sm);display:flex;align-items:center;justify-content:center;font-size:22px;position:relative;cursor:pointer;transition:all 0.2s ease}.quick-slot:hover{border-color:var(--color-accent)}.quick-slot .slot-key{position:absolute;top:2px;left:4px;font-size:9px;color:var(--color-text-muted)}.item-tooltip{position:absolute;background:rgba(20,20,30,0.95);border:1px solid var(--color-border);border-radius:var(--radius-sm);padding:var(--space-sm);max-width:200px;z-index:1000;pointer-events:none;font-size:var(--font-size-xs)}.item-tooltip-name{font-weight:bold;margin-bottom:2px}.item-tooltip-name.common{color:#ccc}.item-tooltip-name.uncommon{color:#2ecc71}.item-tooltip-name.rare{color:#3498db}.item-tooltip-name.legendary{color:#f39c12}.item-tooltip-desc{color:var(--color-text-muted);margin-bottom:4px}.item-pickup-text{position:absolute;font-size:var(--font-size-sm);color:var(--color-gold);font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.8);pointer-events:none;animation:floatUp 1.5s ease-out forwards;z-index:var(--z-notification)}@keyframes floatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-60px)}}.quest-complete-banner{position:absolute;top:25%;left:50%;transform:translate(-50%,-50%);background:rgba(218,165,32,0.15);backdrop-filter:blur(10px);border:2px solid var(--color-gold);border-radius:var(--radius-lg);padding:var(--space-lg) var(--space-xl);text-align:center;z-index:var(--z-notification);animation:questComplete 3s ease-in-out forwards;pointer-events:none}.quest-complete-banner h2{font-family:var(--font-main);font-size:var(--font-size-xl);color:var(--color-gold);margin:0 0 var(--space-sm)}.quest-complete-banner .reward{font-size:var(--font-size-md);color:var(--color-text)}@keyframes questComplete{0%{opacity:0;transform:translate(-50%,-50%) scale(0.8)}10%{opacity:1;transform:translate(-50%,-50%) scale(1.05)}15%{transform:translate(-50%,-50%) scale(1)}85%{opacity:1;transform:translate(-50%,-50%) scale(1)}100%{opacity:0;transform:translate(-50%,-50%) scale(1.1)}}@keyframes panelSlideIn{0%{opacity:0;transform:translate(-50%,-50%) scale(0.95)}100%{opacity:1;transform:translate(-50%,-50%) scale(1)}}.panel-close{position:absolute;top:var(--space-sm);right:var(--space-sm);background:none;border:1px solid var(--color-border);border-radius:var(--radius-round);width:28px;height:28px;color:var(--color-text-muted);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;transition:all 0.2s ease}.panel-close:hover{border-color:var(--color-accent);color:var(--color-text)}.npc-dialog{position:absolute;bottom:20%;left:50%;transform:translateX(-50%);background:rgba(26,26,46,0.95);backdrop-filter:blur(12px);border:2px solid var(--color-gold);border-radius:var(--radius-lg);padding:var(--space-lg);max-width:500px;width:90%;z-index:var(--z-modal);animation:dialogSlideUp 0.3s ease-out;box-shadow:0 0 20px rgba(218,165,32,0.2)}.npc-dialog-header{display:flex;align-items:center;gap:var(--space-sm);margin-bottom:var(--space-md);padding-bottom:var(--space-sm);border-bottom:1px solid rgba(218,165,32,0.3)}.npc-dialog-name{font-family:var(--font-main);font-size:var(--font-size-lg);color:var(--color-gold)}.npc-dialog-archetype{font-size:var(--font-size-xs);color:var(--color-text-muted);text-transform:uppercase;letter-spacing:0.1em}.npc-dialog-mood{font-size:var(--font-size-xs);color:var(--color-crystal);margin-left:auto}.npc-dialog-text{font-family:var(--font-main);font-size:var(--font-size-md);color:var(--color-text);line-height:1.6;margin-bottom:var(--space-md)}.npc-dialog-actions{display:flex;gap:var(--space-sm);justify-content:flex-end}.npc-dialog-btn{padding:var(--space-sm) var(--space-md);border:1px solid var(--color-border);border-radius:var(--radius-sm);background:rgba(218,165,32,0.1);color:var(--color-text);font-family:var(--font-ui);font-size:var(--font-size-sm);cursor:pointer;transition:all 0.2s ease}.npc-dialog-btn:hover{background:rgba(218,165,32,0.3);border-color:var(--color-gold);color:var(--color-gold)}.npc-dialog-btn.primary{background:rgba(218,165,32,0.2);border-color:var(--color-gold);color:var(--color-gold)}@keyframes dialogSlideUp{0%{opacity:0;transform:translateX(-50%) translateY(20px)}100%{opacity:1;transform:translateX(-50%) translateY(0)}}.crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:20px;height:20px;pointer-events:none;z-index:var(--z-hud);opacity:0.4;transition:opacity 0.2s ease}.crosshair.active{opacity:0.8}.crosshair::before,.crosshair::after{content:'';position:absolute;background:var(--color-text)}.crosshair::before{top:50%;left:0;right:0;height:1px;transform:translateY(-50%)}.crosshair::after{left:50%;top:0;bottom:0;width:1px;transform:translateX(-50%)}.crosshair .dot{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:4px;height:4px;background:var(--color-gold);border-radius:var(--radius-round)}.interact-prompt{position:absolute;top:55%;left:50%;transform:translateX(-50%);font-size:var(--font-size-sm);color:var(--color-text);text-shadow:0 2px 4px rgba(0,0,0,0.8);pointer-events:none;z-index:var(--z-hud);opacity:0;transition:opacity 0.3s ease;text-align:center}.interact-prompt.visible{opacity:1}.interact-prompt .key{display:inline-block;background:rgba(218,165,32,0.2);border:1px solid var(--color-gold);border-radius:3px;padding:1px 6px;font-family:var(--font-mono);font-size:var(--font-size-xs);color:var(--color-gold);margin:0 2px}.loading-screen{position:fixed;top:0;left:0;right:0;bottom:0;background:radial-gradient(ellipse at center,#1a1a2e 0%,#0a0a14 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:9999;transition:opacity 1s ease}.loading-screen.fade-out{opacity:0;pointer-events:none}.loading-title{font-family:var(--font-main);font-size:3rem;color:var(--color-gold);text-shadow:0 0 30px rgba(218,165,32,0.3);margin-bottom:var(--space-lg);letter-spacing:0.3em;animation:titleGlow 3s ease-in-out infinite}.loading-subtitle{font-family:var(--font-main);font-size:var(--font-size-md);color:var(--color-text-muted);margin-bottom:var(--space-xxl)}.loading-bar-container{width:300px;height:4px;background:rgba(218,165,32,0.1);border-radius:2px;overflow:hidden;margin-bottom:var(--space-md)}.loading-bar{height:100%;background:linear-gradient(90deg,var(--color-gold),var(--color-dawn));border-radius:2px;transition:width 0.3s ease;width:0%}.loading-status{font-size:var(--font-size-xs);color:var(--color-text-muted)}@keyframes titleGlow{0%,100%{text-shadow:0 0 20px rgba(218,165,32,0.2)}50%{text-shadow:0 0 40px rgba(218,165,32,0.5),0 0 60px rgba(218,165,32,0.2)}}.controls-overlay{position:absolute;bottom:var(--space-md);right:var(--space-md);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-md);font-size:var(--font-size-xs);color:var(--color-text-muted);z-index:var(--z-hud);transition:opacity 0.3s ease;max-width:200px}.controls-overlay-title{font-size:var(--font-size-sm);color:var(--color-text);margin-bottom:var(--space-sm);text-transform:uppercase;letter-spacing:0.05em}.control-row{display:flex;justify-content:space-between;margin-bottom:var(--space-xs);gap:var(--space-sm)}.control-key{font-family:var(--font-mono);color:var(--color-gold);font-weight:bold;min-width:40px}.control-desc{flex:1;text-align:right}.spark-balance{display:inline-block;transition:transform 0.2s ease}.spark-balance.changed{animation:sparkPulse 0.5s ease}@keyframes sparkPulse{0%{transform:scale(1)}30%{transform:scale(1.3);color:var(--color-gold)}100%{transform:scale(1)}}.status-effects{position:absolute;top:var(--space-md);left:50%;transform:translateX(-50%);display:flex;gap:var(--space-sm);z-index:var(--z-hud);pointer-events:none}.status-effect{width:32px;height:32px;background:var(--color-bg-panel);border:1px solid var(--color-border);border-radius:var(--radius-sm);display:flex;align-items:center;justify-content:center;font-size:16px;animation:statusPop 0.3s ease}@keyframes statusPop{0%{transform:scale(0)}60%{transform:scale(1.2)}100%{transform:scale(1)}}.daynight-overlay{position:fixed;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:1;transition:background 5s ease}.daynight-overlay.dawn{background:rgba(244,164,96,0.05)}.daynight-overlay.day{background:transparent}.daynight-overlay.dusk{background:rgba(139,105,20,0.08)}.daynight-overlay.night{background:rgba(26,26,46,0.15)}.zone-transition{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:var(--z-modal);pointer-events:none;animation:zoneTransition 1.5s ease-in-out}.zone-transition-name{font-family:var(--font-main);font-size:var(--font-size-xxl);color:var(--color-gold);text-shadow:0 0 20px rgba(218,165,32,0.5);letter-spacing:0.2em}@keyframes zoneTransition{0%{opacity:0}30%{opacity:1}70%{opacity:1}100%{opacity:0}}.achievement-popup{position:fixed;top:80px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,rgba(20,18,25,0.95),rgba(40,35,50,0.95));border:2px solid var(--color-gold);border-radius:var(--radius-lg);padding:var(--space-lg) var(--space-xxl);text-align:center;z-index:2000;animation:achievementSlide 0.5s ease-out,achievementFade 4s ease-in-out;box-shadow:0 0 40px rgba(218,165,32,0.3);pointer-events:none}.achievement-popup-title{font-family:var(--font-main);font-size:var(--font-size-sm);color:var(--color-gold);text-transform:uppercase;letter-spacing:0.15em;margin-bottom:var(--space-xs)}.achievement-popup-name{font-family:var(--font-main);font-size:var(--font-size-xl);color:var(--color-text);margin-bottom:var(--space-xs)}.achievement-popup-reward{font-size:var(--font-size-sm);color:var(--color-gold)}@keyframes achievementSlide{0%{transform:translateX(-50%) translateY(-30px);opacity:0}100%{transform:translateX(-50%) translateY(0);opacity:1}}@keyframes achievementFade{0%,80%{opacity:1}100%{opacity:0}}.game-tooltip{position:absolute;background:rgba(15,12,20,0.95);border:1px solid var(--color-border);border-radius:var(--radius-sm);padding:var(--space-xs) var(--space-sm);font-size:var(--font-size-xs);color:var(--color-text);pointer-events:none;z-index:3000;max-width:200px;white-space:nowrap;box-shadow:var(--shadow-lg)}.game-tooltip-title{color:var(--color-gold);font-weight:600;margin-bottom:2px}.game-tooltip-desc{color:var(--color-text-muted);font-size:0.7rem}.daily-quest-banner{position:absolute;top:var(--space-md);left:50%;transform:translateX(-50%);background:linear-gradient(90deg,transparent,rgba(218,165,32,0.1),transparent);padding:var(--space-xs) var(--space-lg);color:var(--color-gold);font-size:var(--font-size-sm);letter-spacing:0.1em;text-align:center;pointer-events:none;animation:fadeIn 1s ease}.hud-badge{position:absolute;top:-4px;right:-4px;background:var(--color-quest-active);color:white;font-size:0.6rem;width:16px;height:16px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold}.compass{position:absolute;top:var(--space-md);left:50%;transform:translateX(-50%);font-size:var(--font-size-sm);color:var(--color-text-muted);letter-spacing:0.3em;opacity:0.5}.stat-bar{height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;margin-top:2px}.stat-bar-fill{height:100%;border-radius:2px;transition:width 0.5s ease}.stat-bar-fill.spark{background:linear-gradient(90deg,var(--color-gold),var(--color-dawn))}.stat-bar-fill.energy{background:linear-gradient(90deg,#4caf50,#8bc34a)}.stat-bar-fill.social{background:linear-gradient(90deg,#2196f3,#03a9f4)}#npc-shop-panel::-webkit-scrollbar{width:6px}#npc-shop-panel::-webkit-scrollbar-track{background:transparent}#npc-shop-panel::-webkit-scrollbar-thumb{background:rgba(218,165,32,0.3);border-radius:3px}.npc-shop-panel{transform:scale(0.95);opacity:0;transition:opacity 0.25s ease,transform 0.25s ease}.npc-shop-panel.visible{transform:scale(1);opacity:1}.guild-panel{transform:translateX(20px);opacity:0;transition:opacity 0.25s ease,transform 0.25s ease}.guild-panel.visible{transform:translateX(0);opacity:1}.guild-member-row{display:flex;align-items:center;padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.05);transition:background 0.2s}.guild-member-row:hover{background:rgba(255,255,255,0.05)}.skill-row{display:flex;align-items:center;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.05)}.skill-bar{flex:1;height:6px;background:rgba(255,255,255,0.08);border-radius:3px;overflow:hidden;margin:0 10px}.skill-bar-fill{height:100%;border-radius:3px;transition:width 0.5s ease;background:linear-gradient(90deg,#4caf50,#8bc34a)}.discovery-popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.6);opacity:0;background:rgba(10,14,26,0.95);border:2px solid var(--color-gold);border-radius:16px;padding:24px 32px;text-align:center;z-index:10000;pointer-events:auto;transition:opacity 0.3s ease,transform 0.3s ease}.discovery-popup.visible{opacity:1;transform:translate(-50%,-50%) scale(1)}@keyframes discoveryReveal{0%{opacity:0;transform:translate(-50%,-50%) scale(0.6)}60%{transform:translate(-50%,-50%) scale(1.05)}100%{opacity:1;transform:translate(-50%,-50%) scale(1)}}.lore-entry{padding:12px 16px;margin-bottom:8px;background:rgba(255,255,255,0.03);border-radius:8px;border-left:3px solid rgba(147,112,219,0.5);transition:background 0.2s}.lore-entry:hover{background:rgba(255,255,255,0.06)}.lore-entry.unread{border-left-color:var(--color-gold)}.warmth-indicator{display:inline-flex;align-items:center;gap:4px;font-size:10px;color:#ff9800;padding:2px 6px;background:rgba(255,152,0,0.1);border-radius:4px}.achievement-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.95);opacity:0;background:rgba(15,12,10,0.95);border:1px solid rgba(218,165,32,0.3);border-radius:12px;padding:24px;min-width:420px;max-width:550px;max-height:70vh;overflow-y:auto;z-index:1100;backdrop-filter:blur(10px);transition:opacity 0.25s ease,transform 0.25s ease}.achievement-panel.visible{transform:translate(-50%,-50%) scale(1);opacity:1}.achievement-panel h2{color:var(--color-gold);margin:0 0 4px;font-size:1.2rem;font-family:var(--font-main);letter-spacing:0.1em}.achievement-progress-bar{width:100%;height:6px;background:rgba(255,255,255,0.1);border-radius:3px;margin:8px 0 16px;overflow:hidden}.achievement-progress-fill{height:100%;background:linear-gradient(90deg,var(--color-gold),#f0c040);border-radius:3px;transition:width 0.5s ease}.achievement-category{margin-bottom:16px}.achievement-category-title{color:var(--color-text-muted);font-size:0.7rem;text-transform:uppercase;letter-spacing:0.15em;margin-bottom:8px;padding-bottom:4px;border-bottom:1px solid rgba(255,255,255,0.05)}.achievement-row{display:flex;align-items:center;gap:10px;padding:6px 8px;border-radius:6px;margin-bottom:4px;transition:background 0.2s}.achievement-row:hover{background:rgba(255,255,255,0.05)}.achievement-row.locked{opacity:0.4}.achievement-row.unlocked{opacity:1}.achievement-icon{font-size:1.4rem;width:32px;text-align:center}.achievement-info{flex:1}.achievement-name{color:var(--color-text);font-size:0.85rem;font-weight:500}.achievement-desc{color:var(--color-text-muted);font-size:0.7rem}.achievement-reward{color:var(--color-gold);font-size:0.7rem;white-space:nowrap}.achievement-toast{position:fixed;top:80px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,rgba(25,20,15,0.95),rgba(35,28,18,0.95));border:1px solid var(--color-gold);border-radius:10px;padding:12px 20px;display:flex;align-items:center;gap:12px;z-index:1200;animation:achievementSlide 0.4s ease,achievementFade 0.5s 3s forwards;box-shadow:0 4px 20px rgba(218,165,32,0.2)}.achievement-toast-icon{font-size:2rem}.achievement-toast-text{}.achievement-toast-label{color:var(--color-gold);font-size:0.65rem;text-transform:uppercase;letter-spacing:0.15em}.achievement-toast-name{color:var(--color-text);font-size:1rem;font-weight:500}@keyframes achievementSlide{from{transform:translateX(-50%) translateY(-30px);opacity:0}to{transform:translateX(-50%) translateY(0);opacity:1}}@keyframes achievementFade{to{opacity:0;transform:translateX(-50%) translateY(-20px)}}.auction-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.95);opacity:0;background:rgba(15,12,10,0.95);border:1px solid rgba(176,224,230,0.3);border-radius:12px;padding:24px;min-width:450px;max-width:600px;max-height:70vh;overflow-y:auto;z-index:1100;backdrop-filter:blur(10px);transition:opacity 0.25s ease,transform 0.25s ease}.auction-panel.visible{transform:translate(-50%,-50%) scale(1);opacity:1}.auction-panel h2{color:var(--color-accent);margin:0 0 16px;font-size:1.2rem;font-family:var(--font-main)}.auction-item{display:flex;align-items:center;gap:12px;padding:10px;background:rgba(255,255,255,0.03);border-radius:8px;margin-bottom:8px;border:1px solid rgba(255,255,255,0.05);transition:border-color 0.2s}.auction-item:hover{border-color:rgba(176,224,230,0.2)}.auction-item-icon{font-size:1.5rem;width:36px;text-align:center}.auction-item-info{flex:1}.auction-item-name{color:var(--color-text);font-size:0.85rem}.auction-item-seller{color:var(--color-text-muted);font-size:0.7rem}.auction-item-time{color:rgba(255,200,100,0.7);font-size:0.65rem}.auction-bid-info{text-align:right}.auction-current-bid{color:var(--color-gold);font-size:0.9rem;font-weight:500}.auction-bid-count{color:var(--color-text-muted);font-size:0.65rem}.economic-event-banner{position:fixed;top:50px;left:50%;transform:translateX(-50%);background:linear-gradient(90deg,transparent,rgba(218,165,32,0.15),transparent);color:var(--color-gold);font-size:0.75rem;padding:4px 20px;border-radius:20px;z-index:900;pointer-events:none;letter-spacing:0.05em;text-align:center;animation:eventBannerPulse 3s ease-in-out infinite}@keyframes eventBannerPulse{0%,100%{opacity:0.7}50%{opacity:1}}.lore-journal-panel{font-family:Georgia,serif;transform:scale(0.95);opacity:0;transition:opacity 0.25s ease,transform 0.25s ease}.lore-journal-panel.visible{transform:scale(1);opacity:1}.lore-journal-panel::-webkit-scrollbar{width:8px}.lore-journal-panel::-webkit-scrollbar-track{background:rgba(42,24,16,0.5);border-radius:4px}.lore-journal-panel::-webkit-scrollbar-thumb{background:rgba(139,105,20,0.6);border-radius:4px}.lore-journal-panel::-webkit-scrollbar-thumb:hover{background:rgba(212,175,55,0.7)}.lore-category-tab{outline:none}.lore-category-tab:active{transform:translateY(1px)}.lore-entry{position:relative}.lore-entry-locked{cursor:not-allowed;user-select:none}.lore-progress{font-weight:500}.pet-panel{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.95);opacity:0;background:rgba(15,12,10,0.95);border:1px solid rgba(218,165,32,0.3);border-radius:12px;padding:24px;min-width:420px;max-width:550px;max-height:70vh;overflow-y:auto;z-index:1100;backdrop-filter:blur(10px);transition:opacity 0.25s ease,transform 0.25s ease}.pet-panel.visible{transform:translate(-50%,-50%) scale(1);opacity:1}.pet-panel h2{color:var(--color-gold);margin:0 0 16px;font-size:1.2rem;font-family:var(--font-main);letter-spacing:0.1em;text-align:center}.pet-panel::-webkit-scrollbar{width:6px}.pet-panel::-webkit-scrollbar-thumb{background:rgba(218,165,32,0.3);border-radius:3px}.pet-action-btn{flex:1;padding:10px 16px;background:rgba(218,165,32,0.2);border:1px solid rgba(218,165,32,0.5);border-radius:6px;color:var(--color-gold);font-family:var(--font-ui);font-size:0.85rem;cursor:pointer;transition:all 0.2s ease}.pet-action-btn:hover{background:rgba(218,165,32,0.3);border-color:var(--color-gold);transform:translateY(-1px)}.pet-action-btn:active{transform:translateY(0)}.pet-release-btn{width:100%;padding:10px 16px;background:rgba(231,76,60,0.1);border:1px solid rgba(231,76,60,0.3);border-radius:6px;color:#e74c3c;font-family:var(--font-ui);font-size:0.85rem;cursor:pointer;transition:all 0.2s ease}.pet-release-btn:hover{background:rgba(231,76,60,0.2);border-color:#e74c3c}.pet-adopt-btn{padding:8px 16px;background:rgba(46,204,113,0.2);border:1px solid rgba(46,204,113,0.5);border-radius:6px;color:#2ecc71;font-family:var(--font-ui);font-size:0.85rem;font-weight:500;cursor:pointer;transition:all 0.2s ease;white-space:nowrap}.pet-adopt-btn:hover{background:rgba(46,204,113,0.3);border-color:#2ecc71;transform:scale(1.05)}.pet-adoption-row{transition:all 0.2s ease}.pet-adoption-row:hover .pet-adopt-btn{background:rgba(46,204,113,0.3)}.pet-adopt-notification{font-family:var(--font-main)}@media (max-width:768px){.chat-panel{max-width:250px}.player-info{min-width:150px}.nearby-list{display:none}.lore-journal-panel{width:95%;height:90vh}.lore-category-tab{padding:8px 12px;font-size:12px}.pet-panel{min-width:320px;max-width:90vw}.hud-btn,.panel-btn,.craft-btn,.trade-btn,.quest-btn,.pet-action-btn,.pet-adopt-btn,.npc-dialog-btn{min-width:44px;min-height:44px}.minimap{width:120px !important;height:120px !important}#minimap-canvas{width:120px !important;height:120px !important}.chat-input{width:calc(100vw - 32px);max-width:none}.quest-tracker{max-height:120px;overflow-y:auto}.quest-tracker-title{font-size:var(--font-size-xs)}.player-info{font-size:var(--font-size-xs)}}@media (max-width:480px){.chat-panel{max-width:200px;font-size:var(--font-size-xs)}.player-info{font-size:var(--font-size-xs)}.zone-label{font-size:var(--font-size-lg)}.pet-panel{min-width:280px;padding:16px}}.seasonal-banner{position:absolute;top:0;left:50%;transform:translateX(-50%);padding:var(--space-sm) var(--space-xl);background:linear-gradient(90deg,transparent,rgba(218,165,32,0.15),transparent);backdrop-filter:blur(8px);border-bottom-left-radius:var(--radius-lg);border-bottom-right-radius:var(--radius-lg);border:1px solid rgba(218,165,32,0.3);border-top:none;text-align:center;z-index:var(--z-hud);pointer-events:none;min-width:300px;animation:seasonalBannerFadeIn 1s ease;transition:all 0.5s ease}.seasonal-banner-title{font-family:var(--font-main);font-size:var(--font-size-sm);font-weight:bold;letter-spacing:0.08em;margin-bottom:2px;text-shadow:0 2px 4px rgba(0,0,0,0.6)}.seasonal-banner-desc{font-size:var(--font-size-xs);opacity:0.9;text-shadow:0 1px 3px rgba(0,0,0,0.6)}.seasonal-banner-countdown{font-size:var(--font-size-xs);opacity:0.7;margin-top:2px}@keyframes seasonalBannerFadeIn{0%{opacity:0;transform:translateX(-50%) translateY(-20px)}100%{opacity:1;transform:translateX(-50%) translateY(0)}}.seasonal-item-badge{position:absolute;top:2px;right:2px;width:12px;height:12px;border-radius:var(--radius-round);border:1px solid rgba(255,255,255,0.3);display:flex;align-items:center;justify-content:center;font-size:8px;font-weight:bold;pointer-events:none;animation:seasonalBadgePulse 2s ease-in-out infinite;box-shadow:0 0 6px rgba(0,0,0,0.5)}@keyframes seasonalBadgePulse{0%,100%{transform:scale(1);opacity:0.9}50%{transform:scale(1.1);opacity:1}}.season-spring{background:linear-gradient(90deg,transparent,rgba(248,180,200,0.2),transparent);border-color:rgba(248,180,200,0.4)}.season-spring .seasonal-banner-title{color:#f8b4c8}.season-spring .seasonal-banner-desc,.season-spring .seasonal-banner-countdown{color:#7db37d}.season-spring .seasonal-item-badge{background:#f8b4c8;color:#7db37d;border-color:#ffd4e5}.season-summer{background:linear-gradient(90deg,transparent,rgba(240,192,64,0.2),transparent);border-color:rgba(240,192,64,0.4)}.season-summer .seasonal-banner-title{color:#f0c040}.season-summer .seasonal-banner-desc,.season-summer .seasonal-banner-countdown{color:#ff8c42}.season-summer .seasonal-item-badge{background:#f0c040;color:#ff8c42;border-color:#ffe080}.season-autumn{background:linear-gradient(90deg,transparent,rgba(212,160,64,0.2),transparent);border-color:rgba(212,160,64,0.4)}.season-autumn .seasonal-banner-title{color:#d4a040}.season-autumn .seasonal-banner-desc,.season-autumn .seasonal-banner-countdown{color:#8b4513}.season-autumn .seasonal-item-badge{background:#d4a040;color:#8b4513;border-color:#e8b860}.season-winter{background:linear-gradient(90deg,transparent,rgba(128,192,224,0.2),transparent);border-color:rgba(128,192,224,0.4)}.season-winter .seasonal-banner-title{color:#80c0e0}.season-winter .seasonal-banner-desc,.season-winter .seasonal-banner-countdown{color:#e8e8ff}.season-winter .seasonal-item-badge{background:#80c0e0;color:#0a0a14;border-color:#a0d4f0}.hud-btn,.panel-btn,.craft-btn,.trade-btn,.quest-btn,.pet-action-btn,.pet-adopt-btn,.npc-dialog-btn{transition:background 0.15s ease,transform 0.1s ease,box-shadow 0.15s ease,border-color 0.15s ease}.hud-btn:hover,.panel-btn:hover{transform:translateY(-1px);box-shadow:0 3px 10px rgba(218,165,32,0.2)}.hud-btn:active,.panel-btn:active{transform:translateY(0)}.inventory-slot{transition:all 0.2s ease,border-color 0.15s ease,transform 0.1s ease}.inventory-slot:hover{transform:scale(1.05)}.recipe-item{transition:all 0.2s ease,background 0.15s ease,border-color 0.15s ease}.quest-entry{transition:all 0.2s ease,border-color 0.15s ease,background 0.15s ease}.panel-close{transition:all 0.2s ease,border-color 0.15s ease,transform 0.1s ease}.panel-close:hover{transform:scale(1.1)}.governance-panel{transform:scale(0.95);opacity:0;transition:opacity 0.25s ease,transform 0.25s ease}.governance-panel.visible{transform:scale(1);opacity:1}.discovery-panel{opacity:0;transition:opacity 0.25s ease}.discovery-panel.visible{opacity:1}.zion-tool-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:300;pointer-events:auto;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.8);backdrop-filter:blur(12px);transition:opacity 0.2s ease,transform 0.2s ease}.economy-viz-panel{border-color:#22c55e;width:520px;max-height:80vh}.economy-viz-panel canvas{display:block;width:100%;height:auto;border-radius:6px}.economy-gini-bar{flex:1;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden}.economy-gini-fill{height:100%;border-radius:4px;transition:width 0.5s ease,background-color 0.5s ease}.economy-dist-bars{display:flex;align-items:flex-end;gap:3px;height:60px}.economy-dist-bar{flex:1;border-radius:3px 3px 0 0;background:#22c55e;transition:height 0.4s ease;cursor:pointer}.economy-dist-bar:hover{filter:brightness(1.3)}.yaml-inspector-panel{border-color:#818cf8;width:560px;height:600px}#yaml-inspector-tree{font-family:'Courier New',Courier,monospace;font-size:12px;line-height:1.7;white-space:pre;color:#e0e0e0;overflow-y:auto;flex:1;padding:12px 16px}.yaml-type-string{color:#86efac}.yaml-type-number{color:#67e8f9}.yaml-type-boolean{color:#fbbf24}.yaml-type-null{color:#9ca3af}.yaml-type-key{color:#818cf8}#yaml-inspector-search{outline:none;transition:border-color 0.2s ease}#yaml-inspector-search:focus{border-color:#818cf8 !important}#yaml-inspector-source{appearance:none;-webkit-appearance:none;cursor:pointer;outline:none}.replay-panel{border-color:#f472b6;width:460px}.replay-btn-record{background:rgba(239,68,68,0.15);border:1px solid #ef4444;color:#ef4444;border-radius:6px;padding:8px 16px;cursor:pointer;font-weight:bold;transition:background 0.2s ease}.replay-btn-record:hover{background:rgba(239,68,68,0.3)}.replay-btn-stop{background:rgba(100,100,100,0.15);border:1px solid #555;color:#888;border-radius:6px;padding:8px 16px;cursor:pointer;transition:background 0.2s ease,color 0.2s ease}.replay-btn-stop.active{border-color:#ef4444;color:#ef4444;background:rgba(239,68,68,0.15)}.replay-btn-play{background:rgba(34,197,94,0.15);border:1px solid rgba(34,197,94,0.4);color:#22c55e;border-radius:6px;padding:8px 16px;cursor:pointer;transition:background 0.2s ease}.replay-btn-play:hover{background:rgba(34,197,94,0.3)}#replay-seek{width:100%;accent-color:#f472b6;cursor:pointer}.replay-speed-btn{padding:4px 10px;border-radius:4px;color:#f472b6;font-size:11px;cursor:pointer;transition:background 0.15s ease,border-color 0.15s ease}.replay-speed-btn.active{background:rgba(244,114,182,0.25) !important;border-color:rgba(244,114,182,0.6) !important}.nearby-anchors-panel{border-color:#38bdf8;width:440px;max-height:600px}.nearby-anchor-card{display:flex;align-items:center;gap:10px;padding:10px;margin-bottom:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);border-radius:8px;transition:background 0.2s ease,border-color 0.2s ease;cursor:default}.nearby-anchor-card:hover{background:rgba(56,189,248,0.06);border-color:rgba(56,189,248,0.2)}.nearby-anchor-card.in-range{border-color:rgba(34,197,94,0.3);background:rgba(34,197,94,0.04)}.nearby-anchor-icon{font-size:22px;width:32px;text-align:center}.nearby-anchor-name{font-size:13px;color:#e0e0e0;font-weight:bold}.nearby-anchor-zone{font-size:11px;color:#666}.nearby-anchor-dist{font-size:12px;font-weight:bold;text-align:right}.nearby-anchor-dist.close{color:#22c55e}.nearby-anchor-dist.medium{color:#38bdf8}.nearby-anchor-dist.far{color:#888}.nearby-in-range-badge{font-size:10px;color:#22c55e;text-align:right;text-transform:uppercase;letter-spacing:0.05em}#nearby-enable-location:hover{background:rgba(56,189,248,0.25) !important}.zion-tool-panel-header{display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.1);flex-shrink:0}.zion-tool-panel-title{font-size:16px;font-weight:bold;flex:1}.zion-tool-panel-close{background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:50%;width:28px;height:28px;color:#aaa;cursor:pointer;font-size:14px;line-height:1;transition:background 0.2s ease,color 0.2s ease}.zion-tool-panel-close:hover{background:rgba(255,255,255,0.2);color:#fff}.amendment-panel{border-color:#daa520;width:600px;max-height:82vh}.amend-card{transition:box-shadow 0.2s ease,border-color 0.2s ease}.amend-card:hover{box-shadow:0 2px 12px rgba(218,165,32,0.18);border-color:rgba(218,165,32,0.5) !important}.amend-vote-btn{transition:background 0.15s ease,transform 0.1s ease}.amend-vote-btn:hover{filter:brightness(1.25);transform:translateY(-1px)}.amend-tab-btn{transition:color 0.15s ease,background 0.15s ease}.amend-tab-btn:hover{color:#daa520 !important;background:rgba(218,165,32,0.1) !important}.amend-history-card{transition:background 0.15s ease}.amend-history-card:hover{background:rgba(255,255,255,0.05) !important}#amend-propose-form input,#amend-propose-form textarea{transition:border-color 0.15s ease,box-shadow 0.15s ease;outline:none}#amend-propose-form input:focus,#amend-propose-form textarea:focus{border-color:#daa520 !important;box-shadow:0 0 0 2px rgba(218,165,32,0.2)}#amend-submit-btn:hover{filter:brightness(1.15);transform:translateY(-1px)}.amend-vote-bar-fill{height:100%;border-radius:3px;background:linear-gradient(90deg,#4ade80,#22c55e);transition:width 0.4s ease}.toast-container{position:fixed;top:140px;right:var(--space-md,16px);width:320px;display:flex;flex-direction:column;gap:8px;pointer-events:none;z-index:9000}.toast{display:flex;align-items:flex-start;gap:10px;background:rgba(10,10,20,0.88);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.12);border-left-width:4px;border-radius:8px;padding:10px 12px;box-shadow:0 4px 20px rgba(0,0,0,0.5);pointer-events:auto;cursor:pointer;user-select:none;animation:toastSlideIn 0.28s cubic-bezier(0.22,1,0.36,1) both;position:relative;overflow:hidden}.toast.toast-exiting{animation:toastFadeOut 0.25s ease-in forwards}.toast-progress{position:absolute;bottom:0;left:0;height:2px;background:currentColor;opacity:0.4;transform-origin:left;animation:toastProgress linear forwards}.toast-icon{font-size:20px;line-height:1;flex-shrink:0;margin-top:1px}.toast-body{flex:1;min-width:0}.toast-label{font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:0.08em;opacity:0.6;margin-bottom:2px;color:inherit}.toast-message{font-size:13px;line-height:1.35;color:#e8e8e8;word-break:break-word}.toast-badge{position:absolute;top:6px;right:8px;background:rgba(255,255,255,0.15);border-radius:10px;padding:1px 7px;font-size:11px;font-weight:700;color:#fff;line-height:1.4}.toast-close{position:absolute;bottom:5px;right:8px;font-size:11px;opacity:0;color:rgba(255,255,255,0.5);transition:opacity 0.15s ease;cursor:pointer;line-height:1}.toast:hover .toast-close{opacity:1}.toast-economy{border-left-color:#f1c40f;color:#f1c40f}.toast-achievement{border-left-color:#e67e22;color:#e67e22}.toast-social{border-left-color:#3498db;color:#3498db}.toast-system{border-left-color:#95a5a6;color:#95a5a6}.toast-quest{border-left-color:#9b59b6;color:#9b59b6}.toast-combat{border-left-color:#e74c3c;color:#e74c3c}.toast-priority-critical{border-width:2px;border-left-width:5px;box-shadow:0 0 0 1px rgba(231,76,60,0.4),0 4px 20px rgba(0,0,0,0.6);animation:toastSlideIn 0.28s cubic-bezier(0.22,1,0.36,1) both,toastPulseBorder 1.5s ease-in-out 0.3s infinite}.toast-priority-high{border-left-width:5px}.toast-priority-low{opacity:0.85}@keyframes toastSlideIn{from{opacity:0;transform:translateX(110%)}to{opacity:1;transform:translateX(0)}}@keyframes toastFadeOut{from{opacity:1;transform:translateX(0);max-height:100px;margin-bottom:0}to{opacity:0;transform:translateX(40px);max-height:0;margin-bottom:-8px;padding-top:0;padding-bottom:0}}@keyframes toastProgress{from{transform:scaleX(1)}to{transform:scaleX(0)}}@keyframes toastPulseBorder{0%,100%{box-shadow:0 0 0 1px rgba(231,76,60,0.4),0 4px 20px rgba(0,0,0,0.6)}50%{box-shadow:0 0 0 3px rgba(231,76,60,0.6),0 4px 24px rgba(0,0,0,0.7)}}.toast-overflow-badge{text-align:center;font-size:11px;color:rgba(255,255,255,0.5);padding:4px 0;pointer-events:none}.amend-history-card:hover{background:rgba(255,255,255,0.05) !important}#amend-propose-form input,#amend-propose-form textarea{transition:border-color 0.15s ease,box-shadow 0.15s ease;outline:none}#amend-propose-form input:focus,#amend-propose-form textarea:focus{border-color:#daa520 !important;box-shadow:0 0 0 2px rgba(218,165,32,0.2)}#amend-submit-btn:hover{filter:brightness(1.15);transform:translateY(-1px)}.amend-vote-bar-fill{height:100%;border-radius:3px;background:linear-gradient(90deg,#4ade80,#22c55e);transition:width 0.4s ease} .portal-glow{animation:portalPulse 2s ease-in-out infinite}@keyframes portalPulse{0%,100%{opacity:0.6;transform:scale(1);filter:brightness(1)}50%{opacity:1;transform:scale(1.05);filter:brightness(1.3)}}.loading-screen{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:var(--color-night);z-index:var(--z-modal);transition:opacity 0.5s ease}.loading-screen.hidden{opacity:0;pointer-events:none}.loading-spinner{width:64px;height:64px;border:4px solid var(--color-border);border-top-color:var(--color-accent);border-radius:var(--radius-round);animation:spin 1s linear infinite;margin-bottom:var(--space-lg)}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}.loading-text{font-family:var(--font-main);font-size:var(--font-size-lg);color:var(--color-text-muted);font-style:italic}.loading-progress{margin-top:var(--space-md);font-size:var(--font-size-sm);color:var(--color-accent)}.player-label{position:absolute;transform:translate(-50%,-150%);background:rgba(0,0,0,0.7);backdrop-filter:blur(5px);border:1px solid var(--color-border);border-radius:var(--radius-sm);padding:var(--space-xs) var(--space-sm);font-family:var(--font-ui);font-size:var(--font-size-xs);color:var(--color-text);white-space:nowrap;pointer-events:none;text-shadow:0 1px 2px rgba(0,0,0,0.8);transition:opacity 0.3s ease}.player-label.self{color:var(--color-accent);border-color:var(--color-accent)}.player-label.ai{color:var(--color-crystal);border-color:var(--color-water)}.xr-warning{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(26,26,26,0.95);z-index:var(--z-modal);padding:var(--space-xl);text-align:center}.xr-warning-title{font-family:var(--font-main);font-size:var(--font-size-xxl);color:var(--color-warning);margin-bottom:var(--space-lg)}.xr-warning-text{font-size:var(--font-size-md);color:var(--color-text);max-width:600px;line-height:1.6;margin-bottom:var(--space-md)}.xr-warning-list{text-align:left;max-width:500px;margin:var(--space-lg) auto;color:var(--color-text-muted);line-height:1.8}.xr-warning-list li{margin-bottom:var(--space-sm)}.xr-warning-btn{background:var(--color-warning);color:var(--color-night);border:none;border-radius:var(--radius-md);padding:var(--space-md) var(--space-xl);font-family:var(--font-ui);font-size:var(--font-size-lg);font-weight:bold;cursor:pointer;box-shadow:var(--shadow-md);transition:all 0.2s ease;margin-top:var(--space-lg)}.xr-warning-btn:hover{background:var(--color-dawn);transform:translateY(-2px);box-shadow:var(--shadow-lg)}.xr-warning-btn:active{transform:translateY(0);box-shadow:var(--shadow-sm)}.zone-transition{animation:zoneTransition 1s ease-in-out}@keyframes zoneTransition{0%{opacity:1}50%{opacity:0.3}100%{opacity:1}}.item-pickup{animation:itemPickup 0.5s ease-out}@keyframes itemPickup{0%{transform:scale(1);opacity:1}50%{transform:scale(1.2);opacity:0.8}100%{transform:scale(0);opacity:0}}.spark-gain{animation:sparkGain 1s ease-out;color:var(--color-gold);font-weight:bold}@keyframes sparkGain{0%{transform:translateY(0) scale(1);opacity:1}100%{transform:translateY(-50px) scale(1.5);opacity:0}}.weather-rain{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(transparent,rgba(135,206,235,0.1));animation:rain 0.3s linear infinite}@keyframes rain{0%{opacity:0.5}50%{opacity:0.8}100%{opacity:0.5}}.weather-night{pointer-events:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(26,26,46,0.3);transition:opacity 2s ease}.npc-speech-bubble{position:absolute;pointer-events:none;transform:translate(-50%,-100%);background:rgba(10,14,26,0.9);border:1px solid rgba(218,165,32,0.5);border-radius:8px;padding:6px 10px;font-size:11px;color:#E8E0D8;white-space:nowrap;max-width:200px;text-align:center;z-index:50;animation:speechBubbleIn 0.3s ease-out}.npc-speech-bubble::after{content:'';position:absolute;bottom:-6px;left:50%;transform:translateX(-50%);border-left:6px solid transparent;border-right:6px solid transparent;border-top:6px solid rgba(218,165,32,0.5)}.npc-speech-bubble.fading{animation:speechBubbleOut 0.5s ease-in forwards}@keyframes speechBubbleIn{0%{opacity:0;transform:translate(-50%,-80%)}100%{opacity:1;transform:translate(-50%,-100%)}}@keyframes speechBubbleOut{0%{opacity:1;transform:translate(-50%,-100%)}100%{opacity:0;transform:translate(-50%,-120%)}}.loading-title{font-family:var(--font-main);font-size:3.5rem;color:var(--color-gold);letter-spacing:0.3em;text-shadow:0 0 30px rgba(218,165,32,0.3);margin-bottom:0.5rem}.loading-subtitle{color:var(--color-text-muted);font-style:italic;margin-bottom:2rem}.loading-bar-container{width:300px;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;margin-bottom:1rem}.loading-bar{height:100%;width:0%;background:linear-gradient(90deg,var(--color-gold),#f0d060);border-radius:2px;transition:width 0.3s ease;animation:loadingPulse 1.5s ease-in-out infinite}@keyframes loadingPulse{0%,100%{opacity:0.8}50%{opacity:1}}.loading-status{font-size:0.75rem;color:var(--color-text-muted);letter-spacing:0.05em}.mobile-action-btn{position:fixed;border-radius:50%;background:rgba(10,14,26,0.75);border:2px solid rgba(218,165,32,0.5);color:#DAA520;display:flex;align-items:center;justify-content:center;font-weight:bold;font-family:var(--font-ui);cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:manipulation;z-index:100;transition:background 0.15s,border-color 0.15s}.mobile-action-btn:active{background:rgba(218,165,32,0.3);border-color:#DAA520}.mobile-joystick{position:fixed;bottom:30px;left:30px;width:120px;height:120px;border-radius:50%;background:rgba(10,14,26,0.5);border:2px solid rgba(218,165,32,0.3);z-index:100;touch-action:none}.mobile-joystick-handle{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:50px;height:50px;border-radius:50%;background:rgba(218,165,32,0.4);border:2px solid rgba(218,165,32,0.7);transition:none}.controls-overlay{position:absolute;bottom:var(--space-lg);right:var(--space-lg);background:var(--color-bg-panel);backdrop-filter:blur(10px);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:var(--space-md);box-shadow:var(--shadow-md);display:none;max-height:60vh;overflow-y:auto;z-index:200}.controls-overlay.visible{display:block;animation:fadeIn 0.2s ease-in}.controls-overlay-title{font-family:var(--font-main);font-size:var(--font-size-lg);color:var(--color-gold);margin-bottom:var(--space-sm);border-bottom:1px solid var(--color-border);padding-bottom:var(--space-xs)}.control-row{display:flex;justify-content:space-between;align-items:center;padding:3px 0;font-size:var(--font-size-sm)}.control-key{color:var(--color-gold);font-weight:bold;min-width:50px}.control-desc{color:var(--color-text-muted)}.login-btn{padding:0.75rem 1.5rem;background:rgba(218,165,32,0.15);border:1px solid var(--color-gold);border-radius:8px;color:var(--color-gold);font-family:var(--font-main);font-size:0.9rem;cursor:pointer;transition:all 0.3s ease;letter-spacing:0.05em}.login-btn:hover{background:rgba(218,165,32,0.25);transform:translateY(-1px);box-shadow:0 4px 15px rgba(218,165,32,0.2)}.login-btn:active{transform:translateY(0)}.gpu-accelerated{transform:translateZ(0);will-change:transform}.fade-in{animation:fadeIn 0.5s ease-in}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.fade-out{animation:fadeOut 0.5s ease-out}@keyframes fadeOut{from{opacity:1}to{opacity:0}}
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="world-canvas"></canvas>

    <div id="hud-container">
      <div class="zone-label" id="zone-label">The Nexus</div>
      <div class="player-info" id="player-info"></div>
      <div class="minimap" id="minimap"><canvas id="minimap-canvas" width="150" height="150"></canvas></div>
      <div class="nearby-list" id="nearby-list"></div>
      <div class="chat-panel" id="chat-panel">
        <div class="chat-messages" id="chat-messages"></div>
        <input type="text" class="chat-input" id="chat-input" placeholder="Press Enter to chat..." />
      </div>
    </div>

    <div id="login-screen">
      <div style="text-align:center; animation: fadeIn 1.5s ease;">
        <h1 style="font-family: var(--font-main); color: var(--color-gold); font-size: 4rem; margin-bottom: 0.25rem; letter-spacing: 0.3em; text-shadow: 0 0 30px rgba(218,165,32,0.3);">ZION</h1>
        <div style="width: 100px; height: 1px; background: linear-gradient(90deg, transparent, var(--color-gold), transparent); margin: 0.5rem auto 1rem;"></div>
        <p style="color: var(--color-text-muted); margin-bottom: 0.5rem; font-style: italic; font-family: var(--font-main);">A living world where human and artificial minds meet in peace.</p>
        <p style="color: rgba(176,224,230,0.5); font-size: 0.7rem; margin-bottom: 2rem; letter-spacing: 0.1em;">100 AI citizens await you</p>
      </div>
      <div id="login-options" style="display:flex; flex-direction:column; gap:1rem; align-items:center; width:320px; animation: fadeIn 2s ease;">
        <div style="display:flex; gap:0.5rem; width:100%;">
          <input type="text" id="guest-name" placeholder="Choose a name..." maxlength="39"
            style="flex:1; padding:0.75rem 1rem; border-radius:8px; border:1px solid var(--color-border);
            background:rgba(255,255,255,0.08); color:var(--color-text); font-size:1rem; outline:none;
            transition: border-color 0.3s ease, background 0.3s ease;"
            onfocus="this.style.borderColor='var(--color-gold)';this.style.background='rgba(255,255,255,0.12)'"
            onblur="this.style.borderColor='';this.style.background=''"
            onkeydown="if(event.key==='Enter'){document.getElementById('guest-btn').click()}" />
          <button class="login-btn" id="guest-btn" style="padding:0.75rem 1.25rem;"
            onclick="var n=document.getElementById('guest-name').value;if(Auth.loginAsGuest(n)){location.reload();}else{document.getElementById('guest-name').style.borderColor='#EF5350';}">Play</button>
        </div>
        <span style="color:var(--color-text-muted); font-size:0.75rem; letter-spacing:0.1em;">or</span>
        <button class="login-btn" id="login-btn" style="width:100%;"
          onclick="Auth.initiateOAuth()">Enter with GitHub</button>
        <p style="color:rgba(160,151,142,0.5); font-size:0.65rem; margin-top:1rem;">WASD move / E interact / B build / M map / F emote / X fish / Q pet / Z housing / J quests / G guild</p>
      </div>
    </div>

    <div id="loading-overlay" class="loading-screen" style="display:none;">
      <div class="loading-title">ZION</div>
      <div class="loading-subtitle">Entering the world...</div>
      <div class="loading-bar-container"><div class="loading-bar" id="loading-bar"></div></div>
      <div class="loading-status" id="loading-status">Initializing...</div>
    </div>

    <div class="controls-overlay" id="controls-overlay">
      <div class="controls-overlay-title">Controls</div>
      <div class="control-row"><span class="control-key">WASD</span><span class="control-desc">Move</span></div>
      <div class="control-row"><span class="control-key">Mouse</span><span class="control-desc">Look</span></div>
      <div class="control-row"><span class="control-key">E</span><span class="control-desc">Interact</span></div>
      <div class="control-row"><span class="control-key">I</span><span class="control-desc">Inventory</span></div>
      <div class="control-row"><span class="control-key">C</span><span class="control-desc">Craft</span></div>
      <div class="control-row"><span class="control-key">J</span><span class="control-desc">Quests</span></div>
      <div class="control-row"><span class="control-key">T</span><span class="control-desc">Trade</span></div>
      <div class="control-row"><span class="control-key">B</span><span class="control-desc">Build</span></div>
      <div class="control-row"><span class="control-key">M</span><span class="control-desc">Map</span></div>
      <div class="control-row"><span class="control-key">F</span><span class="control-desc">Emotes</span></div>
      <div class="control-row"><span class="control-key">G</span><span class="control-desc">Guild</span></div>
      <div class="control-row"><span class="control-key">K</span><span class="control-desc">Skills</span></div>
      <div class="control-row"><span class="control-key">L</span><span class="control-desc">Lore Book</span></div>
      <div class="control-row"><span class="control-key">V</span><span class="control-desc">Discoveries</span></div>
      <div class="control-row"><span class="control-key">H</span><span class="control-desc">Governance</span></div>
      <div class="control-row"><span class="control-key">Y</span><span class="control-desc">Achievements</span></div>
      <div class="control-row"><span class="control-key">U</span><span class="control-desc">Auctions</span></div>
      <div class="control-row"><span class="control-key">N</span><span class="control-desc">Compose</span></div>
      <div class="control-row"><span class="control-key">P</span><span class="control-desc">Profile</span></div>
      <div class="control-row"><span class="control-key">Q</span><span class="control-desc">Pet</span></div>
      <div class="control-row"><span class="control-key">X</span><span class="control-desc">Fish</span></div>
      <div class="control-row"><span class="control-key">Z</span><span class="control-desc">Housing</span></div>
      <div class="control-row"><span class="control-key">Enter</span><span class="control-desc">Chat</span></div>
      <div class="control-row"><span class="control-key">Esc</span><span class="control-desc">Settings</span></div>
    </div>

    <div class="notification" id="notification" style="display:none;"></div>
  </div>

  <script>
    // protocol.js
(function(exports) {
  'use strict';

  const PROTOCOL_VERSION = 1;

  const MESSAGE_TYPES = new Set([
    'join',
    'leave',
    'heartbeat',
    'idle',
    'move',
    'warp',
    'say',
    'shout',
    'whisper',
    'emote',
    'build',
    'plant',
    'craft',
    'compose',
    'harvest',
    'trade_offer',
    'trade_accept',
    'trade_decline',
    'buy',
    'sell',
    'gift',
    'teach',
    'learn',
    'mentor_offer',
    'mentor_accept',
    'challenge',
    'accept_challenge',
    'forfeit',
    'score',
    'discover',
    'anchor_place',
    'inspect',
    'intention_set',
    'intention_clear',
    'warp_fork',
    'return_home',
    'federation_announce',
    'federation_handshake',
    'reputation_adjust',
    'report_griefing',
    'election_start',
    'election_vote',
    'election_finalize',
    'steward_set_welcome',
    'steward_set_policy',
    'steward_moderate',
    'star_register',
    'sim_crm_action',
    'propose_amendment',
    'vote_amendment',
    'close_amendment',
    'garden_create',
    'garden_invite',
    'garden_uninvite',
    'garden_tend',
    'garden_set_public'
  ]);

  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  const PLATFORMS = new Set([
    'desktop',
    'phone',
    'vr',
    'ar',
    'api'
  ]);

  const sequenceCounters = new Map();

  function getNextSeq(playerId) {
    if (!sequenceCounters.has(playerId)) {
      sequenceCounters.set(playerId, 0);
    }
    const current = sequenceCounters.get(playerId);
    sequenceCounters.set(playerId, current + 1);
    return current;
  }

  function generateUUID() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }

    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function generateTimestamp() {
    return new Date().toISOString();
  }

  function createMessage(type, from, payload, opts = {}) {
    if (!MESSAGE_TYPES.has(type)) {
      throw new Error(`Invalid message type: ${type}`);
    }

    if (!from || typeof from !== 'string') {
      throw new Error('Invalid from: must be a non-empty string');
    }

    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
      throw new Error('Invalid payload: must be an object');
    }

    const message = {
      v: PROTOCOL_VERSION,
      id: generateUUID(),
      ts: generateTimestamp(),
      seq: getNextSeq(from),
      from: from,
      type: type,
      platform: opts.platform || 'desktop',
      position: opts.position || { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: opts.geo || null,
      payload: payload
    };

    return message;
  }

  function validateMessage(msg) {
    const errors = [];

    if (!msg || typeof msg !== 'object' || Array.isArray(msg)) {
      return { valid: false, errors: ['Message must be an object'] };
    }

    if (msg.v !== PROTOCOL_VERSION) {
      errors.push(`Invalid version: expected ${PROTOCOL_VERSION}, got ${msg.v}`);
    }

    if (!msg.id || typeof msg.id !== 'string') {
      errors.push('Invalid id: must be a non-empty string');
    }

    if (!msg.ts || typeof msg.ts !== 'string') {
      errors.push('Invalid ts: must be a non-empty string');
    } else {
      const date = new Date(msg.ts);
      if (isNaN(date.getTime())) {
        errors.push('Invalid ts: must be a valid ISO-8601 timestamp');
      }
    }

    if (typeof msg.seq !== 'number' || msg.seq < 0 || !Number.isInteger(msg.seq)) {
      errors.push('Invalid seq: must be a non-negative integer');
    }

    if (!msg.from || typeof msg.from !== 'string') {
      errors.push('Invalid from: must be a non-empty string');
    }

    if (!MESSAGE_TYPES.has(msg.type)) {
      errors.push(`Invalid type: ${msg.type} is not a valid message type`);
    }

    if (!PLATFORMS.has(msg.platform)) {
      errors.push(`Invalid platform: ${msg.platform} is not a valid platform`);
    }

    if (!msg.position || typeof msg.position !== 'object' || Array.isArray(msg.position)) {
      errors.push('Invalid position: must be an object');
    } else {
      if (typeof msg.position.x !== 'number') {
        errors.push('Invalid position.x: must be a number');
      }
      if (typeof msg.position.y !== 'number') {
        errors.push('Invalid position.y: must be a number');
      }
      if (typeof msg.position.z !== 'number') {
        errors.push('Invalid position.z: must be a number');
      }
      if (!msg.position.zone || typeof msg.position.zone !== 'string') {
        errors.push('Invalid position.zone: must be a non-empty string');
      }
    }

    if (msg.geo !== null && msg.geo !== undefined) {
      if (typeof msg.geo !== 'object' || Array.isArray(msg.geo)) {
        errors.push('Invalid geo: must be an object or null');
      } else {
        if (msg.geo.lat !== null && msg.geo.lat !== undefined && typeof msg.geo.lat !== 'number') {
          errors.push('Invalid geo.lat: must be a number or null');
        }
        if (msg.geo.lon !== null && msg.geo.lon !== undefined && typeof msg.geo.lon !== 'number') {
          errors.push('Invalid geo.lon: must be a number or null');
        }
      }
    }

    if (!msg.payload || typeof msg.payload !== 'object' || Array.isArray(msg.payload)) {
      errors.push('Invalid payload: must be an object');
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  var create = {};
  MESSAGE_TYPES.forEach(function(type) {
    create[type] = function(from, payload, opts) {
      return createMessage(type, from, payload || {}, opts);
    };
  });
  create.chat = create.say;

  exports.PROTOCOL_VERSION = PROTOCOL_VERSION;
  exports.MESSAGE_TYPES = MESSAGE_TYPES;
  exports.CONSENT_REQUIRED_TYPES = CONSENT_REQUIRED_TYPES;
  exports.PLATFORMS = PLATFORMS;
  exports.createMessage = createMessage;
  exports.validateMessage = validateMessage;
  exports.getNextSeq = getNextSeq;
  exports.generateUUID = generateUUID;
  exports.generateTimestamp = generateTimestamp;
  exports.create = create;

})(typeof module !== 'undefined' ? module.exports : (window.Protocol = {}));


// zones.js
(function(exports) {
  'use strict';

  const ZONES = {
    nexus: {
      name: 'The Nexus',
      description: 'The central hub connecting all realms. A safe gathering place where travelers from all zones converge to trade, socialize, and plan their journeys.',
      terrain: 'crystalline plaza',
      bounds: { x_min: -100, x_max: 100, z_min: -100, z_max: 100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena']
    },

    gardens: {
      name: 'The Gardens',
      description: 'Lush botanical gardens filled with herbs, flowers, and fruit trees. A peaceful sanctuary for gathering natural resources and contemplation.',
      terrain: 'cultivated gardens',
      bounds: { x_min: 100, x_max: 500, z_min: -200, z_max: 200 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'wilds', 'athenaeum']
    },

    athenaeum: {
      name: 'The Athenaeum',
      description: 'A grand library and hall of learning. Scholars gather here to study, teach, and share knowledge across all disciplines.',
      terrain: 'marble halls',
      bounds: { x_min: -500, x_max: -100, z_min: 100, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'gardens', 'studio']
    },

    studio: {
      name: 'The Studio',
      description: 'A creative workshop where artists, composers, and craftspeople collaborate on their works. Inspiration flows freely in this space of artistic expression.',
      terrain: 'artisan workshops',
      bounds: { x_min: -500, x_max: -100, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'athenaeum', 'agora']
    },

    wilds: {
      name: 'The Wilds',
      description: 'Untamed wilderness filled with rare resources and natural wonders. Beautiful but unpredictable, explorers must be prepared for anything.',
      terrain: 'wilderness',
      bounds: { x_min: 500, x_max: 1000, z_min: -500, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: false
      },
      portals: ['nexus', 'gardens', 'arena']
    },

    agora: {
      name: 'The Agora',
      description: 'A bustling marketplace where merchants display their wares and traders negotiate deals. The commercial heart of the realm.',
      terrain: 'market square',
      bounds: { x_min: -200, x_max: 200, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'studio', 'commons']
    },

    commons: {
      name: 'The Commons',
      description: 'A collaborative building space where communities construct shared infrastructure and personal projects. A place of collective creation.',
      terrain: 'building grounds',
      bounds: { x_min: 100, x_max: 500, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: true,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'agora', 'arena']
    },

    arena: {
      name: 'The Arena',
      description: 'A proving ground for competitive challenges and contests of skill. Those seeking glory test themselves against worthy opponents.',
      terrain: 'combat grounds',
      bounds: { x_min: 500, x_max: 1000, z_min: 500, z_max: 1000 },
      rules: {
        pvp: true,
        building: false,
        harvesting: false,
        trading: false,
        competition: true,
        safe: false
      },
      portals: ['nexus', 'wilds', 'commons']
    }
  };

  const ACTION_RULE_MAP = {
    build: 'building',
    plant: 'harvesting',
    harvest: 'harvesting',
    trade_offer: 'trading',
    trade_accept: 'trading',
    trade_decline: 'trading',
    buy: 'trading',
    sell: 'trading',
    challenge: 'competition_pvp', // Special: requires both competition AND pvp
    accept_challenge: 'competition_pvp'
  };

  function getZoneRules(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return null;
    }
    return zone.rules;
  }

  function isActionAllowed(action, zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return false;
    }

    const ruleKey = ACTION_RULE_MAP[action];

    if (!ruleKey) {
      return true;
    }

    if (ruleKey === 'competition_pvp') {
      return zone.rules.competition === true && zone.rules.pvp === true;
    }

    return zone.rules[ruleKey] === true;
  }

  function getConnectedZones(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return [];
    }
    return zone.portals || [];
  }

  function getSpawnZone() {
    return 'nexus';
  }

  function getZone(zoneId) {
    return ZONES[zoneId] || null;
  }

  function getAllZoneIds() {
    return Object.keys(ZONES);
  }

  function zoneExists(zoneId) {
    return ZONES.hasOwnProperty(zoneId);
  }

  const zoneStewards = new Map(); // zoneId -> {stewards: [], elections: [], policies: {}}
  const governanceLog = []; // Array of all governance actions
  const zoneRegulars = new Map(); // zoneId -> Set(playerId) - players who visit regularly

  const STEWARD_TERM_LENGTH = 604800000; // 7 days in milliseconds
  const ELECTION_DURATION = 172800000; // 2 days in milliseconds (voting period)
  const MAX_STEWARDS_PER_ZONE = 3;
  const REGULAR_VISIT_THRESHOLD = 5; // Visits needed to be considered a regular
  const REGULAR_VISIT_WINDOW = 2592000000; // 30 days

  function initZoneGovernance(zoneId) {
    if (!zoneStewards.has(zoneId)) {
      zoneStewards.set(zoneId, {
        stewards: [],
        elections: [],
        policies: {
          welcomeMessage: '',
          buildingRequiresApproval: false,
          chatModerated: false,
          eventCalendar: []
        }
      });
    }
    if (!zoneRegulars.has(zoneId)) {
      zoneRegulars.set(zoneId, new Map()); // playerId -> visitCount
    }
  }

  function recordZoneVisit(zoneId, playerId) {
    initZoneGovernance(zoneId);
    const regulars = zoneRegulars.get(zoneId);

    if (!regulars.has(playerId)) {
      regulars.set(playerId, { count: 0, lastVisit: 0 });
    }

    const record = regulars.get(playerId);
    record.count++;
    record.lastVisit = Date.now();
  }

  function isZoneRegular(zoneId, playerId) {
    initZoneGovernance(zoneId);
    const regulars = zoneRegulars.get(zoneId);
    const record = regulars.get(playerId);

    if (!record) return false;

    const withinWindow = (Date.now() - record.lastVisit) < REGULAR_VISIT_WINDOW;
    return record.count >= REGULAR_VISIT_THRESHOLD && withinWindow;
  }

  function getZoneStewards(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    const now = Date.now();
    governance.stewards = governance.stewards.filter(s => s.termEnd > now);

    return governance.stewards;
  }

  function isZoneSteward(zoneId, playerId) {
    const stewards = getZoneStewards(zoneId);
    return stewards.some(s => s.playerId === playerId);
  }

  function startElection(zoneId, candidates) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    const election = {
      id: `election_${zoneId}_${Date.now()}`,
      zoneId,
      candidates: candidates.map(playerId => ({
        playerId,
        votes: 0,
        voters: new Set()
      })),
      startTime: Date.now(),
      endTime: Date.now() + ELECTION_DURATION,
      status: 'active',
      totalVotes: 0
    };

    governance.elections.push(election);

    logGovernanceAction({
      type: 'election_started',
      zoneId,
      electionId: election.id,
      candidates: candidates,
      timestamp: Date.now()
    });

    return election;
  }

  function castVote(electionId, voterId, candidateId) {
    for (const [zoneId, governance] of zoneStewards.entries()) {
      const election = governance.elections.find(e => e.id === electionId);
      if (!election) continue;

      if (election.status !== 'active') {
        return { success: false, error: 'Election is not active' };
      }

      if (Date.now() > election.endTime) {
        election.status = 'ended';
        return { success: false, error: 'Election has ended' };
      }

      if (!isZoneRegular(zoneId, voterId)) {
        return { success: false, error: 'Only zone regulars can vote' };
      }

      const hasVoted = election.candidates.some(c => c.voters.has(voterId));
      if (hasVoted) {
        return { success: false, error: 'You have already voted in this election' };
      }

      const candidate = election.candidates.find(c => c.playerId === candidateId);
      if (!candidate) {
        return { success: false, error: 'Candidate not found' };
      }

      candidate.votes++;
      candidate.voters.add(voterId);
      election.totalVotes++;

      logGovernanceAction({
        type: 'vote_cast',
        zoneId,
        electionId,
        voterId,
        candidateId,
        timestamp: Date.now()
      });

      return { success: true };
    }

    return { success: false, error: 'Election not found' };
  }

  function finalizeElection(electionId) {
    for (const [zoneId, governance] of zoneStewards.entries()) {
      const election = governance.elections.find(e => e.id === electionId);
      if (!election) continue;

      if (Date.now() < election.endTime) {
        return { success: false, error: 'Election is still in progress' };
      }

      election.status = 'finalized';

      const sorted = [...election.candidates].sort((a, b) => b.votes - a.votes);

      const winners = sorted.slice(0, MAX_STEWARDS_PER_ZONE);

      const newStewards = winners.map(winner => ({
        playerId: winner.playerId,
        zoneId,
        electionId,
        votes: winner.votes,
        termStart: Date.now(),
        termEnd: Date.now() + STEWARD_TERM_LENGTH,
        actions: []
      }));

      governance.stewards = newStewards;

      logGovernanceAction({
        type: 'election_finalized',
        zoneId,
        electionId,
        stewards: newStewards.map(s => ({ playerId: s.playerId, votes: s.votes })),
        timestamp: Date.now()
      });

      return { success: true, stewards: newStewards };
    }

    return { success: false, error: 'Election not found' };
  }

  function setWelcomeMessage(zoneId, stewardId, message) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can set welcome message' };
    }

    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    governance.policies.welcomeMessage = message;

    logGovernanceAction({
      type: 'welcome_message_set',
      zoneId,
      stewardId,
      message,
      timestamp: Date.now()
    });

    return { success: true };
  }

  function setZonePolicy(zoneId, stewardId, policy, value) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can set zone policies' };
    }

    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    if (!governance.policies.hasOwnProperty(policy)) {
      return { success: false, error: 'Invalid policy' };
    }

    governance.policies[policy] = value;

    logGovernanceAction({
      type: 'policy_changed',
      zoneId,
      stewardId,
      policy,
      value,
      timestamp: Date.now()
    });

    return { success: true };
  }

  function moderateChat(zoneId, stewardId, targetPlayerId, action, reason) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can moderate chat' };
    }

    logGovernanceAction({
      type: 'chat_moderation',
      zoneId,
      stewardId,
      targetPlayerId,
      action,
      reason,
      timestamp: Date.now()
    });

    return { success: true, action };
  }

  function logGovernanceAction(action) {
    governanceLog.push(action);

    if (governanceLog.length > 1000) {
      governanceLog.shift();
    }
  }

  function getGovernanceLog(zoneId, limit) {
    limit = limit || 50;
    return governanceLog
      .filter(action => action.zoneId === zoneId)
      .slice(-limit);
  }

  function getZonePolicies(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    return governance.policies;
  }

  function getActiveElection(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    const now = Date.now();

    return governance.elections.find(e =>
      e.status === 'active' && e.endTime > now
    ) || null;
  }

  exports.ZONES = ZONES;
  exports.getZoneRules = getZoneRules;
  exports.isActionAllowed = isActionAllowed;
  exports.getConnectedZones = getConnectedZones;
  exports.getSpawnZone = getSpawnZone;
  exports.getZone = getZone;
  exports.getAllZoneIds = getAllZoneIds;
  exports.zoneExists = zoneExists;

  exports.initZoneGovernance = initZoneGovernance;
  exports.recordZoneVisit = recordZoneVisit;
  exports.isZoneRegular = isZoneRegular;
  exports.getZoneStewards = getZoneStewards;
  exports.isZoneSteward = isZoneSteward;
  exports.startElection = startElection;
  exports.castVote = castVote;
  exports.finalizeElection = finalizeElection;
  exports.setWelcomeMessage = setWelcomeMessage;
  exports.setZonePolicy = setZonePolicy;
  exports.moderateChat = moderateChat;
  exports.getGovernanceLog = getGovernanceLog;
  exports.getZonePolicies = getZonePolicies;
  exports.getActiveElection = getActiveElection;

})(typeof module !== 'undefined' ? module.exports : (window.Zones = {}));


// economy.js

(function(exports) {
  'use strict';

  const EARN_TABLE = {
    daily_login: 10,
    harvest: [5, 15],
    craft: [5, 50],
    teach: [10, 30],
    discover: [5, 25],
    puzzle: [10, 100],
    perform: [5, 20],
    competition_win: [10, 100],
    build: [10, 50],
    mentor: 50,
    anchor_visit: [1, 5],
    gift: [1, 3]
  };

  const TAX_BRACKETS = [
    { min: 0,   max: 19,  rate: 0.00 },
    { min: 20,  max: 49,  rate: 0.05 },
    { min: 50,  max: 99,  rate: 0.10 },
    { min: 100, max: 249, rate: 0.15 },
    { min: 250, max: 499, rate: 0.25 },
    { min: 500, max: Infinity, rate: 0.40 },
  ];

  const TREASURY_ID = 'TREASURY';
  const BASE_UBI_AMOUNT = 5;
  const WEALTH_TAX_THRESHOLD = 500;
  const WEALTH_TAX_RATE = 0.02;
  const BALANCE_FLOOR = 0;
  const MAINTENANCE_COST = 1;
  const LISTING_FEE_RATE = 0.05;
  const SYSTEM_SINK_ID = 'SYSTEM';

  let transactionCounter = 0;
  let listingCounter = 0;

  function createLedger() {
    return {
      balances: {},
      transactions: [],
      listings: []
    };
  }

  function calculateEarnAmount(activity, details = {}) {
    const earnValue = EARN_TABLE[activity];

    if (!earnValue) {
      return 0;
    }

    if (typeof earnValue === 'number') {
      return earnValue;
    }

    if (Array.isArray(earnValue) && earnValue.length === 2) {
      const [min, max] = earnValue;
      const factor = details.complexity !== undefined ? details.complexity :
                     details.rarity !== undefined ? details.rarity : 0.5;

      const clampedFactor = Math.max(0, Math.min(1, factor));
      return Math.round(min + (max - min) * clampedFactor);
    }

    return 0;
  }

  function getTaxRate(currentBalance) {
    if (currentBalance < 0) return 0;
    for (let i = 0; i < TAX_BRACKETS.length; i++) {
      if (currentBalance >= TAX_BRACKETS[i].min && currentBalance <= TAX_BRACKETS[i].max) {
        return TAX_BRACKETS[i].rate;
      }
    }
    return 0;
  }

  function calculateTax(grossAmount, currentBalance) {
    const taxRate = getTaxRate(currentBalance);
    const taxAmount = Math.floor(grossAmount * taxRate);
    return {
      netAmount: grossAmount - taxAmount,
      taxAmount: taxAmount,
      taxRate: taxRate
    };
  }

  function recordTransaction(ledger, from, to, amount, type, details = {}) {
    const transaction = {
      id: `tx_${transactionCounter++}_${Date.now()}`,
      ts: Date.now(),
      from,
      to,
      amount,
      type,
      details
    };
    ledger.transactions.push(transaction);
    return transaction;
  }

  function earnSpark(ledger, playerId, activity, details = {}) {
    const amount = calculateEarnAmount(activity, details);

    if (amount <= 0) {
      return 0;
    }

    if (!ledger.balances[playerId]) {
      ledger.balances[playerId] = 0;
    }

    const tax = calculateTax(amount, ledger.balances[playerId]);

    ledger.balances[playerId] += tax.netAmount;

    recordTransaction(ledger, 'SYSTEM', playerId, tax.netAmount, 'earn', {
      activity,
      grossAmount: amount,
      taxWithheld: tax.taxAmount,
      taxRate: tax.taxRate,
      ...details
    });

    if (tax.taxAmount > 0) {
      if (!ledger.balances[TREASURY_ID]) {
        ledger.balances[TREASURY_ID] = 0;
      }
      ledger.balances[TREASURY_ID] += tax.taxAmount;

      recordTransaction(ledger, playerId, TREASURY_ID, tax.taxAmount, 'tax', {
        activity,
        grossAmount: amount,
        taxRate: tax.taxRate
      });
    }

    return tax.netAmount;
  }

  function spendSpark(ledger, playerId, amount) {
    const currentBalance = getBalance(ledger, playerId);

    if (amount <= 0) {
      return { success: false, balance: currentBalance };
    }

    if (currentBalance < amount) {
      return { success: false, balance: currentBalance };
    }

    ledger.balances[playerId] -= amount;

    recordTransaction(ledger, playerId, 'SYSTEM', amount, 'spend', {});

    return { success: true, balance: ledger.balances[playerId] };
  }

  function transferSpark(ledger, from, to, amount) {
    if (amount <= 0) {
      return { success: false };
    }

    const senderBalance = getBalance(ledger, from);
    if (senderBalance < amount) {
      return { success: false };
    }

    if (!ledger.balances[to]) {
      ledger.balances[to] = 0;
    }

    ledger.balances[from] -= amount;
    ledger.balances[to] += amount;

    recordTransaction(ledger, from, to, amount, 'transfer', {});

    return { success: true };
  }

  function getBalance(ledger, playerId) {
    return ledger.balances[playerId] || 0;
  }

  function createMarketListing(ledger, playerId, item, price) {
    var listingFee = Math.max(1, Math.floor(price * LISTING_FEE_RATE));

    var sellerBalance = getBalance(ledger, playerId);
    if (sellerBalance < listingFee) {
      return { success: false, message: 'Insufficient spark for listing fee' };
    }

    ledger.balances[playerId] -= listingFee;

    recordTransaction(ledger, playerId, SYSTEM_SINK_ID, listingFee, 'listing_fee', {
      askingPrice: price,
      feeRate: LISTING_FEE_RATE
    });

    const listing = {
      id: `listing_${listingCounter++}_${Date.now()}`,
      seller: playerId,
      item,
      price,
      ts: Date.now(),
      active: true,
      feePaid: listingFee
    };

    ledger.listings.push(listing);
    return listing;
  }

  function buyListing(ledger, buyerId, listingId) {
    const listing = ledger.listings.find(l => l.id === listingId && l.active);

    if (!listing) {
      return { success: false };
    }

    const buyerBalance = getBalance(ledger, buyerId);
    if (buyerBalance < listing.price) {
      return { success: false };
    }

    if (buyerId === listing.seller) {
      return { success: false };
    }

    if (!ledger.balances[listing.seller]) {
      ledger.balances[listing.seller] = 0;
    }

    ledger.balances[buyerId] -= listing.price;
    ledger.balances[listing.seller] += listing.price;

    listing.active = false;

    recordTransaction(ledger, buyerId, listing.seller, listing.price, 'market_purchase', {
      listingId,
      item: listing.item
    });

    return { success: true, item: listing.item };
  }

  function getTransactionLog(ledger, playerId) {
    return ledger.transactions.filter(tx =>
      tx.from === playerId || tx.to === playerId
    );
  }

  function getActiveListings(ledger) {
    if (!ledger || !ledger.listings) return [];
    return ledger.listings.filter(function(l) { return l.active; });
  }

  function getListingsByItem(ledger, itemId) {
    return getActiveListings(ledger).filter(function(l) {
      return l.item === itemId || (l.item && l.item.id === itemId);
    });
  }

  function getListingsBySeller(ledger, sellerId) {
    return getActiveListings(ledger).filter(function(l) {
      return l.seller === sellerId;
    });
  }

  function cancelListing(ledger, listingId, sellerId) {
    if (!ledger || !ledger.listings) return { success: false, message: 'No ledger' };

    var listing = ledger.listings.find(function(l) { return l.id === listingId; });
    if (!listing) return { success: false, message: 'Listing not found' };
    if (listing.seller !== sellerId) return { success: false, message: 'Not your listing' };
    if (!listing.active) return { success: false, message: 'Already inactive' };

    listing.active = false;
    return { success: true, item: listing.item };
  }

  function getEconomyStats(ledger) {
    if (!ledger) return {};

    var totalSpark = 0;
    var playerCount = 0;
    for (var pid in ledger.balances) {
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;
      totalSpark += ledger.balances[pid] || 0;
      playerCount++;
    }

    var activeListings = getActiveListings(ledger);
    var totalTransactions = ledger.transactions ? ledger.transactions.length : 0;

    var velocity = playerCount > 0 ? totalTransactions / playerCount : 0;

    return {
      totalSpark: totalSpark,
      playerCount: playerCount,
      averageSpark: playerCount > 0 ? Math.floor(totalSpark / playerCount) : 0,
      activeListings: activeListings.length,
      totalTransactions: totalTransactions,
      velocity: Math.round(velocity * 100) / 100,
      treasury: ledger.balances[TREASURY_ID] || 0
    };
  }

  function getLeaderboard(ledger, limit) {
    if (!ledger || !ledger.balances) return [];
    limit = limit || 10;

    var players = [];
    for (var pid in ledger.balances) {
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;
      players.push({ playerId: pid, spark: ledger.balances[pid] || 0 });
    }

    players.sort(function(a, b) { return b.spark - a.spark; });
    return players.slice(0, limit);
  }

  function distributeUBI(ledger, eligiblePlayerIds) {
    if (!eligiblePlayerIds || eligiblePlayerIds.length === 0) {
      return { distributed: 0, perPlayer: 0, recipients: 0 };
    }

    var treasuryBalance = ledger.balances[TREASURY_ID] || 0;
    if (treasuryBalance <= 0) {
      return { distributed: 0, perPlayer: 0, recipients: 0 };
    }

    var perPlayer = Math.min(BASE_UBI_AMOUNT, Math.floor(treasuryBalance / eligiblePlayerIds.length));
    if (perPlayer < 1) {
      return { distributed: 0, perPlayer: 0, recipients: 0 };
    }

    var totalDistributed = 0;
    var recipientCount = 0;

    for (var i = 0; i < eligiblePlayerIds.length; i++) {
      var pid = eligiblePlayerIds[i];
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;

      if ((ledger.balances[TREASURY_ID] || 0) < perPlayer) break;

      if (!ledger.balances[pid]) {
        ledger.balances[pid] = 0;
      }

      ledger.balances[pid] += perPlayer;
      ledger.balances[TREASURY_ID] -= perPlayer;
      totalDistributed += perPlayer;
      recipientCount++;

      recordTransaction(ledger, TREASURY_ID, pid, perPlayer, 'ubi', {});
    }

    return { distributed: totalDistributed, perPlayer: perPlayer, recipients: recipientCount };
  }

  function getTreasuryInfo(ledger) {
    var balance = (ledger.balances && ledger.balances[TREASURY_ID]) || 0;
    var totalTaxCollected = 0;
    var totalUbiDistributed = 0;

    if (ledger.transactions) {
      for (var i = 0; i < ledger.transactions.length; i++) {
        var tx = ledger.transactions[i];
        if (tx.type === 'tax') {
          totalTaxCollected += tx.amount;
        } else if (tx.type === 'ubi') {
          totalUbiDistributed += tx.amount;
        }
      }
    }

    return {
      balance: balance,
      totalTaxCollected: totalTaxCollected,
      totalUbiDistributed: totalUbiDistributed
    };
  }

  function applyWealthTax(ledger) {
    var totalCollected = 0;
    var playersAffected = 0;

    if (!ledger.balances[TREASURY_ID]) {
      ledger.balances[TREASURY_ID] = 0;
    }

    for (var pid in ledger.balances) {
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;
      var balance = ledger.balances[pid];
      if (balance > WEALTH_TAX_THRESHOLD) {
        var taxableAmount = balance - WEALTH_TAX_THRESHOLD;
        var tax = Math.floor(taxableAmount * WEALTH_TAX_RATE);
        if (tax > 0) {
          ledger.balances[pid] -= tax;
          ledger.balances[TREASURY_ID] += tax;
          totalCollected += tax;
          playersAffected++;

          recordTransaction(ledger, pid, TREASURY_ID, tax, 'wealth_tax', {
            balance: balance,
            threshold: WEALTH_TAX_THRESHOLD,
            rate: WEALTH_TAX_RATE
          });
        }
      }
    }

    return { totalCollected: totalCollected, playersAffected: playersAffected };
  }

  function applyMaintenance(ledger, structureOwnerMap) {
    var totalDestroyed = 0;
    var structuresDecayed = [];

    if (!structureOwnerMap || typeof structureOwnerMap !== 'object') {
      return { totalDestroyed: 0, structuresDecayed: [] };
    }

    for (var structId in structureOwnerMap) {
      var ownerId = structureOwnerMap[structId];
      if (!ownerId) continue;

      var balance = getBalance(ledger, ownerId);

      if (balance >= MAINTENANCE_COST) {
        ledger.balances[ownerId] -= MAINTENANCE_COST;
        totalDestroyed += MAINTENANCE_COST;

        recordTransaction(ledger, ownerId, SYSTEM_SINK_ID, MAINTENANCE_COST, 'maintenance', {
          structureId: structId
        });
      } else {
        structuresDecayed.push(structId);
      }
    }

    return { totalDestroyed: totalDestroyed, structuresDecayed: structuresDecayed };
  }

  var auctionCounter = 0;

  function createAuction(ledger, sellerId, item, startingBid, durationMs) {
    if (!ledger.auctions) ledger.auctions = [];

    var auction = {
      id: 'auction_' + (auctionCounter++) + '_' + Date.now(),
      seller: sellerId,
      item: item,
      startingBid: startingBid || 1,
      currentBid: 0,
      currentBidder: null,
      bids: [],
      startTime: Date.now(),
      endTime: Date.now() + (durationMs || 300000), // Default 5 min
      status: 'active'
    };

    ledger.auctions.push(auction);
    return auction;
  }

  function placeBid(ledger, auctionId, bidderId, amount) {
    if (!ledger.auctions) return { success: false, message: 'No auctions' };

    var auction = ledger.auctions.find(function(a) { return a.id === auctionId; });
    if (!auction) return { success: false, message: 'Auction not found' };
    if (auction.status !== 'active') return { success: false, message: 'Auction not active' };
    if (Date.now() > auction.endTime) return { success: false, message: 'Auction ended' };
    if (auction.seller === bidderId) return { success: false, message: 'Cannot bid on own auction' };
    if (amount <= auction.currentBid) return { success: false, message: 'Bid must be higher than current bid' };
    if (amount < auction.startingBid) return { success: false, message: 'Bid below minimum' };

    var balance = getBalance(ledger, bidderId);
    if (balance < amount) return { success: false, message: 'Insufficient Spark' };

    auction.currentBid = amount;
    auction.currentBidder = bidderId;
    auction.bids.push({ bidder: bidderId, amount: amount, ts: Date.now() });

    if (auction.endTime - Date.now() < 30000) {
      auction.endTime = Date.now() + 30000;
    }

    return { success: true, message: 'Bid placed' };
  }

  function finalizeAuctions(ledger) {
    if (!ledger.auctions) return [];

    var now = Date.now();
    var completed = [];

    for (var i = 0; i < ledger.auctions.length; i++) {
      var auction = ledger.auctions[i];
      if (auction.status !== 'active') continue;
      if (now < auction.endTime) continue;

      if (auction.currentBidder && auction.currentBid > 0) {
        var winnerBalance = getBalance(ledger, auction.currentBidder);
        if (winnerBalance >= auction.currentBid) {
          if (!ledger.balances[auction.seller]) ledger.balances[auction.seller] = 0;
          ledger.balances[auction.currentBidder] -= auction.currentBid;
          ledger.balances[auction.seller] += auction.currentBid;

          recordTransaction(ledger, auction.currentBidder, auction.seller, auction.currentBid, 'auction', {
            auctionId: auction.id,
            item: auction.item
          });

          auction.status = 'sold';
          completed.push({ auction: auction, winner: auction.currentBidder, item: auction.item });
        } else {
          auction.status = 'failed';
        }
      } else {
        auction.status = 'expired';
      }
    }

    return completed;
  }

  function getActiveAuctions(ledger) {
    if (!ledger.auctions) return [];
    var now = Date.now();
    return ledger.auctions.filter(function(a) {
      return a.status === 'active' && now < a.endTime;
    });
  }

  var ECONOMIC_EVENTS = [
    { id: 'harvest_festival', name: 'Harvest Festival', description: 'Harvesting rewards doubled', modifier: { activity: 'harvest', multiplier: 2 } },
    { id: 'craft_fair', name: 'Craft Fair', description: 'Crafting rewards +50%', modifier: { activity: 'craft', multiplier: 1.5 } },
    { id: 'trading_day', name: 'Grand Trading Day', description: 'Trade bonuses increased', modifier: { activity: 'gift', multiplier: 3 } },
    { id: 'scholars_week', name: "Scholar's Week", description: 'Teaching and discovery rewards doubled', modifier: { activity: 'teach', multiplier: 2 } },
    { id: 'builders_boom', name: "Builder's Boom", description: 'Building rewards +50%', modifier: { activity: 'build', multiplier: 1.5 } },
    { id: 'exploration_surge', name: 'Exploration Surge', description: 'Discovery rewards doubled', modifier: { activity: 'discover', multiplier: 2 } }
  ];

  function getCurrentEvent() {
    var now = new Date();
    var dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
    var cycle = dayOfYear % 4;
    if (cycle === 3) return null; // Rest day
    var eventIndex = Math.floor(dayOfYear / 4) % ECONOMIC_EVENTS.length;
    return ECONOMIC_EVENTS[eventIndex];
  }

  function applyEventModifier(baseAmount, activity) {
    var event = getCurrentEvent();
    if (!event || !event.modifier) return baseAmount;
    if (event.modifier.activity === activity) {
      return Math.round(baseAmount * event.modifier.multiplier);
    }
    return baseAmount;
  }

  exports.createLedger = createLedger;
  exports.earnSpark = earnSpark;
  exports.spendSpark = spendSpark;
  exports.transferSpark = transferSpark;
  exports.getBalance = getBalance;
  exports.createMarketListing = createMarketListing;
  exports.buyListing = buyListing;
  exports.getTransactionLog = getTransactionLog;
  exports.getActiveListings = getActiveListings;
  exports.getListingsByItem = getListingsByItem;
  exports.getListingsBySeller = getListingsBySeller;
  exports.cancelListing = cancelListing;
  exports.getEconomyStats = getEconomyStats;
  exports.getLeaderboard = getLeaderboard;
  exports.EARN_TABLE = EARN_TABLE;
  exports.TAX_BRACKETS = TAX_BRACKETS;
  exports.TREASURY_ID = TREASURY_ID;
  exports.BASE_UBI_AMOUNT = BASE_UBI_AMOUNT;
  exports.getTaxRate = getTaxRate;
  exports.calculateTax = calculateTax;
  exports.distributeUBI = distributeUBI;
  exports.getTreasuryInfo = getTreasuryInfo;
  exports.applyWealthTax = applyWealthTax;
  exports.WEALTH_TAX_THRESHOLD = WEALTH_TAX_THRESHOLD;
  exports.WEALTH_TAX_RATE = WEALTH_TAX_RATE;
  exports.BALANCE_FLOOR = BALANCE_FLOOR;
  exports.MAINTENANCE_COST = MAINTENANCE_COST;
  exports.LISTING_FEE_RATE = LISTING_FEE_RATE;
  exports.SYSTEM_SINK_ID = SYSTEM_SINK_ID;
  exports.applyMaintenance = applyMaintenance;
  exports.createAuction = createAuction;
  exports.placeBid = placeBid;
  exports.finalizeAuctions = finalizeAuctions;
  exports.getActiveAuctions = getActiveAuctions;
  exports.ECONOMIC_EVENTS = ECONOMIC_EVENTS;
  exports.getCurrentEvent = getCurrentEvent;
  exports.applyEventModifier = applyEventModifier;

})(typeof module !== 'undefined' ? module.exports : (window.Economy = {}));


// LAZY_LOAD_START: economy_viz
(function(exports) {
  'use strict';

  var TREASURY_ID = 'TREASURY';

  var FLOW_COLORS = {
    earn:  '#22c55e',  // green
    tax:   '#ef4444',  // red
    ubi:   '#3b82f6',  // blue
    trade: '#eab308',  // yellow
    gift:  '#a855f7'   // purple
  };

  var BRACKETS = [
    { min: 0,    max: 9    },
    { min: 10,   max: 24   },
    { min: 25,   max: 49   },
    { min: 50,   max: 99   },
    { min: 100,  max: 249  },
    { min: 250,  max: 499  },
    { min: 500,  max: 999  },
    { min: 1000, max: 4999 },
    { min: 5000, max: Infinity }
  ];

  var _canvas = null;     // HTMLCanvasElement (browser only)
  var _ctx    = null;     // CanvasRenderingContext2D (browser only)
  var _state  = null;     // Last loaded economy state
  var _particles = [];   // Animated transaction particles
  var _time   = 0;        // Accumulated time (ms) for animation

  function computeGini(balances) {
    var values = [];
    var keys = Object.keys(balances);

    for (var i = 0; i < keys.length; i++) {
      var v = balances[keys[i]];
      values.push(v < 0 ? 0 : v);
    }

    if (values.length === 0) return 0;
    if (values.length === 1) return 0;

    values.sort(function(a, b) { return a - b; });

    var n = values.length;
    var sumOfAbsDiffs = 0;
    var sumOfValues = 0;

    for (var j = 0; j < n; j++) {
      sumOfValues += values[j];
      for (var k = 0; k < n; k++) {
        sumOfAbsDiffs += Math.abs(values[j] - values[k]);
      }
    }

    if (sumOfValues === 0) return 0;

    return sumOfAbsDiffs / (2 * n * sumOfValues);
  }

  function computeDistribution(balances) {
    var brackets = [];
    for (var b = 0; b < BRACKETS.length; b++) {
      var br = BRACKETS[b];
      var label = br.max === Infinity
        ? br.min + '+'
        : br.min + '-' + br.max;
      brackets.push({ range: label, count: 0, totalSpark: 0 });
    }

    var keys = Object.keys(balances);
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      if (id === TREASURY_ID) continue;

      var val = balances[id];
      var clamped = val < 0 ? 0 : val;

      for (var j = 0; j < BRACKETS.length; j++) {
        if (clamped >= BRACKETS[j].min && clamped <= BRACKETS[j].max) {
          brackets[j].count++;
          brackets[j].totalSpark += clamped;
          break;
        }
      }
    }

    return { brackets: brackets };
  }

  function getFlowData(economyState) {
    var balances = economyState.balances || {};
    var transactions = economyState.transactions || [];

    var nodes = [];
    var keys = Object.keys(balances);

    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      var balance = balances[id];
      var type = id === TREASURY_ID ? 'treasury' : 'citizen';
      nodes.push({
        id: id,
        label: id,
        balance: balance,
        type: type
      });
    }

    var flows = [];
    for (var t = 0; t < transactions.length; t++) {
      var tx = transactions[t];
      var flowType = _categorizeFlow(tx);
      if (flowType === null) continue;  // skip unknown/uncategorized

      flows.push({
        from:   tx.from || 'SYSTEM',
        to:     tx.to   || 'SYSTEM',
        amount: tx.amount || 0,
        type:   flowType
      });
    }

    var citizenBalances = {};
    var totalSupply = 0;
    var treasuryBalance = 0;
    var citizenCount = 0;
    var citizenSum = 0;

    for (var k = 0; k < keys.length; k++) {
      var sid = keys[k];
      var sbal = balances[sid];
      totalSupply += sbal;

      if (sid === TREASURY_ID) {
        treasuryBalance = sbal;
      } else {
        citizenBalances[sid] = sbal;
        citizenCount++;
        citizenSum += sbal;
      }
    }

    var avgBalance = citizenCount > 0 ? citizenSum / citizenCount : 0;
    var gini = computeGini(citizenBalances);

    var citizenNodes = nodes.filter(function(n) { return n.type === 'citizen'; });
    var topEarners = citizenNodes.slice().sort(function(a, b) {
      return b.balance - a.balance;
    });

    return {
      nodes: nodes,
      flows: flows,
      summary: {
        totalSupply:      totalSupply,
        treasuryBalance:  treasuryBalance,
        giniCoefficient:  gini,
        topEarners:       topEarners,
        avgBalance:       avgBalance,
        citizenCount:     citizenCount
      }
    };
  }

  function _categorizeFlow(tx) {
    var type = tx.type || '';

    if (type === 'earn')     return 'earn';
    if (type === 'tax')      return 'tax';
    if (type === 'ubi')      return 'ubi';
    if (type === 'trade')    return 'trade';
    if (type === 'gift')     return 'gift';
    if (type === 'trade_offer') return 'trade';

    var from = tx.from || '';
    var to   = tx.to   || '';

    if (to === TREASURY_ID)   return 'tax';
    if (from === TREASURY_ID) return 'ubi';
    if (from === 'SYSTEM')    return 'earn';

    var EARN_ACTIVITIES = ['craft', 'build', 'harvest', 'plant', 'discover',
                           'perform', 'teach', 'mentor', 'anchor_visit',
                           'daily_login', 'puzzle', 'competition_win'];
    for (var i = 0; i < EARN_ACTIVITIES.length; i++) {
      if (type === EARN_ACTIVITIES[i]) return 'earn';
    }

    if (type === 'gift') return 'gift';

    return null;
  }

  function formatSummary(economyState) {
    var flow = getFlowData(economyState);
    var s    = flow.summary;

    var lines = [
      'ZION Economy Summary',
      '--------------------',
      'Citizens:       ' + s.citizenCount,
      'Total Supply:   ' + s.totalSupply + ' Spark',
      'Treasury:       ' + s.treasuryBalance + ' Spark',
      'Avg Balance:    ' + s.avgBalance.toFixed(1) + ' Spark',
      'Gini Index:     ' + s.giniCoefficient.toFixed(3) + ' (0=equal, 1=unequal)'
    ];

    if (s.topEarners.length > 0) {
      lines.push('Top Earner:     ' + s.topEarners[0].id +
                 ' (' + s.topEarners[0].balance + ' Spark)');
    }

    return lines.join('\n');
  }

  function init(canvasElement) {
    if (typeof canvasElement === 'undefined' || canvasElement === null) return;
    _canvas = canvasElement;
    if (_canvas.getContext) {
      _ctx = _canvas.getContext('2d');
    }
    _particles = [];
    _time = 0;
  }

  function loadState(economyState) {
    _state = economyState;
    _particles = [];
    _time = 0;

    if (_state && _state.transactions) {
      var txs = _state.transactions;
      var limit = Math.min(txs.length, 30);
      for (var i = 0; i < limit; i++) {
        var tx = txs[i];
        var flowType = _categorizeFlow(tx);
        if (flowType) {
          _particles.push(_makeParticle(flowType, i / limit));
        }
      }
    }
  }

  function update(dt) {
    _time += dt;

    for (var i = _particles.length - 1; i >= 0; i--) {
      _particles[i].t += dt * _particles[i].speed;
      if (_particles[i].t > 1) {
        _particles[i].t -= 1;
      }
    }
  }

  function render() {
    if (!_ctx || !_canvas) return;
    if (!_state) return;

    var w = _canvas.width;
    var h = _canvas.height;

    _ctx.clearRect(0, 0, w, h);

    _ctx.fillStyle = '#0f172a';
    _ctx.fillRect(0, 0, w, h);

    var flow = getFlowData(_state);

    _renderSankeyFlow(flow, w, h);
    _renderDistributionChart(flow, w, h);
    _renderTreasuryMeter(flow.summary, w, h);
    _renderGiniDisplay(flow.summary, w, h);
    _renderParticles(w, h);
  }

  function _renderSankeyFlow(flow, w, h) {
    if (!_ctx) return;

    var areaW = w * 0.55;
    var areaH = h * 0.55;

    var col0 = 40;              // SYSTEM (earnings source)
    var col1 = areaW * 0.35;   // Citizens
    var col2 = areaW * 0.65;   // TREASURY
    var col3 = areaW * 0.95;   // Citizens (after UBI)

    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('Spark Flow', col0, 20);

    var labels = [
      { x: col0, y: 40, text: 'EARN', color: FLOW_COLORS.earn },
      { x: col1, y: 40, text: 'TAX',  color: FLOW_COLORS.tax  },
      { x: col2, y: 40, text: 'UBI',  color: FLOW_COLORS.ubi  },
      { x: col1, y: 60, text: 'TRADE',color: FLOW_COLORS.trade},
      { x: col1, y: 75, text: 'GIFT', color: FLOW_COLORS.gift }
    ];

    for (var l = 0; l < labels.length; l++) {
      _ctx.fillStyle = labels[l].color;
      _ctx.font = '10px monospace';
      _ctx.fillText(labels[l].text, labels[l].x, labels[l].y);
    }

    var aggr = { earn: 0, tax: 0, ubi: 0, trade: 0, gift: 0 };
    for (var f = 0; f < flow.flows.length; f++) {
      var fl = flow.flows[f];
      if (aggr[fl.type] !== undefined) aggr[fl.type] += fl.amount;
    }

    var maxFlow = Math.max(1, aggr.earn, aggr.tax, aggr.ubi, aggr.trade, aggr.gift);

    var flowLines = [
      { type: 'earn',  x1: col0, y1: areaH*0.3, x2: col1, y2: areaH*0.3 },
      { type: 'tax',   x1: col1, y1: areaH*0.35, x2: col2, y2: areaH*0.35 },
      { type: 'ubi',   x1: col2, y1: areaH*0.45, x2: col3, y2: areaH*0.45 },
      { type: 'trade', x1: col1, y1: areaH*0.55, x2: col1+50, y2: areaH*0.55 },
      { type: 'gift',  x1: col1, y1: areaH*0.65, x2: col1+50, y2: areaH*0.65 }
    ];

    for (var fl2 = 0; fl2 < flowLines.length; fl2++) {
      var line = flowLines[fl2];
      var amount = aggr[line.type];
      if (amount === 0) continue;
      var thickness = Math.max(1, (amount / maxFlow) * 12);

      _ctx.beginPath();
      _ctx.moveTo(line.x1, line.y1);
      var cpx = (line.x1 + line.x2) / 2;
      _ctx.bezierCurveTo(cpx, line.y1, cpx, line.y2, line.x2, line.y2);
      _ctx.strokeStyle = FLOW_COLORS[line.type];
      _ctx.lineWidth = thickness;
      _ctx.globalAlpha = 0.7;
      _ctx.stroke();
      _ctx.globalAlpha = 1.0;
      _ctx.lineWidth = 1;

      _ctx.fillStyle = FLOW_COLORS[line.type];
      _ctx.font = '9px monospace';
      _ctx.fillText(amount + ' â—†', (line.x1 + line.x2) / 2 - 10, line.y1 - 4);
    }
  }

  function _renderDistributionChart(flow, w, h) {
    if (!_ctx) return;

    var dist = computeDistribution(
      (flow.nodes.reduce(function(acc, n) {
        acc[n.id] = n.balance;
        return acc;
      }, {}))
    );

    var chartX = 0;
    var chartY = h * 0.58;
    var chartW = w * 0.55;
    var chartH = h * 0.38;

    _ctx.fillStyle = '#1e293b';
    _ctx.fillRect(chartX, chartY, chartW, chartH);

    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('Balance Distribution', chartX + 8, chartY + 16);

    var brackets = dist.brackets;
    var maxCount = 1;
    for (var b = 0; b < brackets.length; b++) {
      if (brackets[b].count > maxCount) maxCount = brackets[b].count;
    }

    var barAreaX = chartX + 8;
    var barAreaY = chartY + 24;
    var barAreaW = chartW - 16;
    var barAreaH = chartH - 40;
    var barW = barAreaW / brackets.length - 2;

    for (var i = 0; i < brackets.length; i++) {
      var bk = brackets[i];
      var barH = bk.count > 0 ? (bk.count / maxCount) * barAreaH : 0;
      var bx = barAreaX + i * (barW + 2);
      var by = barAreaY + barAreaH - barH;

      _ctx.fillStyle = '#3b82f6';
      _ctx.globalAlpha = 0.8;
      _ctx.fillRect(bx, by, barW, barH);
      _ctx.globalAlpha = 1.0;

      _ctx.fillStyle = '#64748b';
      _ctx.font = '7px monospace';
      _ctx.save();
      _ctx.translate(bx + barW / 2, barAreaY + barAreaH + 4);
      _ctx.rotate(-Math.PI / 4);
      _ctx.fillText(bk.range, 0, 0);
      _ctx.restore();

      if (bk.count > 0) {
        _ctx.fillStyle = '#e2e8f0';
        _ctx.font = '9px monospace';
        _ctx.fillText(bk.count, bx + 2, by - 2);
      }
    }
  }

  function _renderTreasuryMeter(summary, w, h) {
    if (!_ctx) return;

    var x = w * 0.62;
    var y = 20;
    var meterW = w * 0.35;
    var meterH = 30;

    _ctx.fillStyle = '#1e293b';
    _ctx.fillRect(x, y, meterW, meterH + 40);

    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('TREASURY', x + 6, y + 14);

    var maxTreasury = Math.max(summary.totalSupply, 1000);
    var fraction = summary.treasuryBalance / maxTreasury;
    fraction = Math.max(0, Math.min(1, fraction));

    _ctx.fillStyle = '#334155';
    _ctx.fillRect(x + 6, y + 18, meterW - 12, 14);

    var fillColor = fraction < 0.2 ? '#ef4444' :
                    fraction < 0.5 ? '#eab308' : '#22c55e';
    _ctx.fillStyle = fillColor;
    _ctx.fillRect(x + 6, y + 18, (meterW - 12) * fraction, 14);

    _ctx.fillStyle = '#e2e8f0';
    _ctx.font = '10px monospace';
    _ctx.fillText(summary.treasuryBalance + ' Spark', x + 6, y + 46);
  }

  function _renderGiniDisplay(summary, w, h) {
    if (!_ctx) return;

    var x = w * 0.62;
    var y = 90;
    var meterW = w * 0.35;

    _ctx.fillStyle = '#1e293b';
    _ctx.fillRect(x, y, meterW, 60);

    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('INEQUALITY (Gini)', x + 6, y + 14);

    var gini = summary.giniCoefficient;
    var giniColor = gini < 0.3 ? '#22c55e' :
                    gini < 0.5 ? '#eab308' : '#ef4444';

    _ctx.fillStyle = '#334155';
    _ctx.fillRect(x + 6, y + 18, meterW - 12, 12);

    _ctx.fillStyle = giniColor;
    _ctx.fillRect(x + 6, y + 18, (meterW - 12) * gini, 12);

    _ctx.fillStyle = '#e2e8f0';
    _ctx.font = '10px monospace';
    _ctx.fillText(gini.toFixed(3), x + 6, y + 46);

    _ctx.fillStyle = '#64748b';
    _ctx.font = '9px monospace';
    _ctx.fillText(summary.citizenCount + ' citizens | avg ' +
                  summary.avgBalance.toFixed(1) + ' Spark', x + 6, y + 56);
  }

  function _renderParticles(w, h) {
    if (!_ctx) return;

    for (var i = 0; i < _particles.length; i++) {
      var p = _particles[i];
      var x = p.x0 + (p.x1 - p.x0) * p.t;
      var y = p.y0 + (p.y1 - p.y0) * p.t;

      _ctx.beginPath();
      _ctx.arc(x, y, 3, 0, Math.PI * 2);
      _ctx.fillStyle = p.color;
      _ctx.globalAlpha = 0.9 - p.t * 0.4;
      _ctx.fill();
      _ctx.globalAlpha = 1.0;
    }
  }

  var _FLOW_PATHS = {
    earn:  { x0: 40,  y0: 120, x1: 180, y1: 120 },
    tax:   { x0: 180, y0: 140, x1: 300, y1: 140 },
    ubi:   { x0: 300, y0: 165, x1: 430, y1: 165 },
    trade: { x0: 180, y0: 200, x1: 260, y1: 200 },
    gift:  { x0: 180, y0: 240, x1: 260, y1: 240 }
  };

  function _makeParticle(flowType, offset) {
    var path = _FLOW_PATHS[flowType] || _FLOW_PATHS.earn;
    return {
      x0: path.x0,
      y0: path.y0,
      x1: path.x1,
      y1: path.y1,
      t: offset % 1,
      speed: 0.15 + Math.random() * 0.1,
      color: FLOW_COLORS[flowType] || '#ffffff'
    };
  }

  exports.init                = init;
  exports.loadState           = loadState;
  exports.update              = update;
  exports.render              = render;
  exports.getFlowData         = getFlowData;
  exports.computeGini         = computeGini;
  exports.computeDistribution = computeDistribution;
  exports.formatSummary       = formatSummary;

})(typeof module !== 'undefined' ? module.exports : (window.EconomyViz = {}));

// LAZY_LOAD_END: economy_viz

// inventory.js

(function(exports) {
  'use strict';

  const ITEM_CATALOG = {
    seed_wildflower: {
      id: 'seed_wildflower',
      name: 'Wildflower Seeds',
      type: 'seeds',
      icon: 'ðŸŒ±',
      description: 'Seeds that grow into colorful wildflowers',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    seed_lotus: {
      id: 'seed_lotus',
      name: 'Lotus Seeds',
      type: 'seeds',
      icon: 'ðŸª·',
      description: 'Rare seeds that bloom into mystical lotus flowers',
      stackable: true,
      maxStack: 99,
      rarity: 'rare'
    },
    seed_tree: {
      id: 'seed_tree',
      name: 'Tree Seeds',
      type: 'seeds',
      icon: 'ðŸŒ°',
      description: 'Seeds for planting new trees',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    flower_rose: {
      id: 'flower_rose',
      name: 'Rose',
      type: 'flowers',
      icon: 'ðŸŒ¹',
      description: 'A beautiful red rose',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    flower_sunflower: {
      id: 'flower_sunflower',
      name: 'Sunflower',
      type: 'flowers',
      icon: 'ðŸŒ»',
      description: 'A bright yellow sunflower',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    flower_lotus: {
      id: 'flower_lotus',
      name: 'Lotus Flower',
      type: 'flowers',
      icon: 'ðŸª·',
      description: 'A mystical lotus flower',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    flower_tulip: {
      id: 'flower_tulip',
      name: 'Tulip',
      type: 'flowers',
      icon: 'ðŸŒ·',
      description: 'A delicate tulip',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    flower_cherry: {
      id: 'flower_cherry',
      name: 'Cherry Blossom',
      type: 'flowers',
      icon: 'ðŸŒ¸',
      description: 'A gentle cherry blossom',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },

    wood_oak: {
      id: 'wood_oak',
      name: 'Oak Wood',
      type: 'wood',
      icon: 'ðŸªµ',
      description: 'Sturdy oak wood for building',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    wood_pine: {
      id: 'wood_pine',
      name: 'Pine Wood',
      type: 'wood',
      icon: 'ðŸŒ²',
      description: 'Light pine wood',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    wood_mystical: {
      id: 'wood_mystical',
      name: 'Mystical Wood',
      type: 'wood',
      icon: 'âœ¨',
      description: 'Rare wood imbued with energy',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },

    stone_common: {
      id: 'stone_common',
      name: 'Stone',
      type: 'stone',
      icon: 'ðŸª¨',
      description: 'Common building stone',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    stone_marble: {
      id: 'stone_marble',
      name: 'Marble',
      type: 'stone',
      icon: 'â¬œ',
      description: 'Polished marble for fine construction',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    stone_obsidian: {
      id: 'stone_obsidian',
      name: 'Obsidian',
      type: 'stone',
      icon: 'â¬›',
      description: 'Dark volcanic glass',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },

    crystal_clear: {
      id: 'crystal_clear',
      name: 'Clear Crystal',
      type: 'crystal',
      icon: 'ðŸ’Ž',
      description: 'A pristine clear crystal',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    crystal_amethyst: {
      id: 'crystal_amethyst',
      name: 'Amethyst',
      type: 'crystal',
      icon: 'ðŸ’œ',
      description: 'A purple amethyst crystal',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    crystal_emerald: {
      id: 'crystal_emerald',
      name: 'Emerald',
      type: 'crystal',
      icon: 'ðŸ’š',
      description: 'A vibrant green emerald',
      stackable: true,
      maxStack: 30,
      rarity: 'legendary'
    },

    herb_mint: {
      id: 'herb_mint',
      name: 'Mint',
      type: 'herbs',
      icon: 'ðŸŒ¿',
      description: 'Refreshing mint leaves',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    herb_sage: {
      id: 'herb_sage',
      name: 'Sage',
      type: 'herbs',
      icon: 'ðŸƒ',
      description: 'Aromatic sage for wisdom',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    herb_ginseng: {
      id: 'herb_ginseng',
      name: 'Ginseng',
      type: 'herbs',
      icon: 'ðŸŒ±',
      description: 'Rare medicinal root',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    herb_lavender: {
      id: 'herb_lavender',
      name: 'Lavender',
      type: 'herbs',
      icon: 'ðŸª»',
      description: 'Calming lavender flowers',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    food_bread: {
      id: 'food_bread',
      name: 'Bread',
      type: 'food',
      icon: 'ðŸž',
      description: 'Fresh baked bread',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_honey: {
      id: 'food_honey',
      name: 'Honey',
      type: 'food',
      icon: 'ðŸ¯',
      description: 'Sweet golden honey',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    food_mushroom: {
      id: 'food_mushroom',
      name: 'Mushroom',
      type: 'food',
      icon: 'ðŸ„',
      description: 'Edible forest mushroom',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    food_berry: {
      id: 'food_berry',
      name: 'Berries',
      type: 'food',
      icon: 'ðŸ«',
      description: 'Sweet wild berries',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },

    tool_pickaxe: {
      id: 'tool_pickaxe',
      name: 'Pickaxe',
      type: 'tools',
      icon: 'â›ï¸',
      description: 'For mining stone and crystals',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_axe: {
      id: 'tool_axe',
      name: 'Axe',
      type: 'tools',
      icon: 'ðŸª“',
      description: 'For chopping wood',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_shovel: {
      id: 'tool_shovel',
      name: 'Shovel',
      type: 'tools',
      icon: 'ðŸ—ï¸',
      description: 'For digging and planting',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_hammer: {
      id: 'tool_hammer',
      name: 'Hammer',
      type: 'tools',
      icon: 'ðŸ”¨',
      description: 'For crafting and building',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },

    item_workbench: {
      id: 'item_workbench',
      name: 'Workbench',
      type: 'crafted_items',
      icon: 'ðŸ› ï¸',
      description: 'Essential crafting station',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    item_fountain: {
      id: 'item_fountain',
      name: 'Fountain',
      type: 'crafted_items',
      icon: 'â›²',
      description: 'Decorative water fountain',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    item_lantern: {
      id: 'item_lantern',
      name: 'Lantern',
      type: 'crafted_items',
      icon: 'ðŸ®',
      description: 'Provides light in darkness',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    item_statue: {
      id: 'item_statue',
      name: 'Crystal Statue',
      type: 'crafted_items',
      icon: 'ðŸ—¿',
      description: 'A magnificent crystal statue',
      stackable: false,
      maxStack: 1,
      rarity: 'legendary'
    },

    potion_healing: {
      id: 'potion_healing',
      name: 'Healing Potion',
      type: 'potions',
      icon: 'ðŸ§ª',
      description: 'Restores health and warmth',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    potion_energy: {
      id: 'potion_energy',
      name: 'Energy Potion',
      type: 'potions',
      icon: 'âš¡',
      description: 'Boosts movement speed',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    potion_wisdom: {
      id: 'potion_wisdom',
      name: 'Wisdom Potion',
      type: 'potions',
      icon: 'ðŸ”®',
      description: 'Enhances learning and insight',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    item_scroll: {
      id: 'item_scroll',
      name: 'Ancient Scroll',
      type: 'knowledge',
      icon: 'ðŸ“œ',
      description: 'Contains ancient wisdom',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    item_book: {
      id: 'item_book',
      name: 'Knowledge Book',
      type: 'knowledge',
      icon: 'ðŸ“–',
      description: 'A book of collected knowledge',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    item_trophy: {
      id: 'item_trophy',
      name: 'Trophy',
      type: 'trophies',
      icon: 'ðŸ†',
      description: 'A mark of victory',
      stackable: true,
      maxStack: 10,
      rarity: 'rare'
    },

    instrument_flute: {
      id: 'instrument_flute',
      name: 'Wooden Flute',
      type: 'instruments',
      icon: 'ðŸªˆ',
      description: 'A hand-carved wooden flute',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    instrument_drum: {
      id: 'instrument_drum',
      name: 'Hand Drum',
      type: 'instruments',
      icon: 'ðŸ¥',
      description: 'A resonant hand drum for rhythm',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    instrument_harp: {
      id: 'instrument_harp',
      name: 'Crystal Harp',
      type: 'instruments',
      icon: 'ðŸŽµ',
      description: 'A harp strung with crystal fibers',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    instrument_bell: {
      id: 'instrument_bell',
      name: 'Harmony Bell',
      type: 'instruments',
      icon: 'ðŸ””',
      description: 'Rings with perfect pitch',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },

    art_pigment: {
      id: 'art_pigment',
      name: 'Pigment',
      type: 'art_supplies',
      icon: 'ðŸŽ¨',
      description: 'Colorful pigment for painting',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    art_canvas: {
      id: 'art_canvas',
      name: 'Canvas',
      type: 'art_supplies',
      icon: 'ðŸ–¼ï¸',
      description: 'Stretched canvas for artwork',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    art_clay: {
      id: 'art_clay',
      name: 'Sculpting Clay',
      type: 'art_supplies',
      icon: 'ðŸº',
      description: 'Soft clay for sculpting',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    art_ink: {
      id: 'art_ink',
      name: 'Luminous Ink',
      type: 'art_supplies',
      icon: 'âœ’ï¸',
      description: 'Ink that faintly glows in darkness',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon'
    },

    gear_compass: {
      id: 'gear_compass',
      name: 'Explorer Compass',
      type: 'gear',
      icon: 'ðŸ§­',
      description: 'Points toward undiscovered locations',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    gear_map: {
      id: 'gear_map',
      name: 'Zone Map',
      type: 'gear',
      icon: 'ðŸ—ºï¸',
      description: 'Reveals hidden paths in a zone',
      stackable: true,
      maxStack: 8,
      rarity: 'uncommon'
    },
    gear_spyglass: {
      id: 'gear_spyglass',
      name: 'Spyglass',
      type: 'gear',
      icon: 'ðŸ”­',
      description: 'See farther into the distance',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    gear_rope: {
      id: 'gear_rope',
      name: 'Climbing Rope',
      type: 'gear',
      icon: 'ðŸª¢',
      description: 'Reach high places safely',
      stackable: true,
      maxStack: 10,
      rarity: 'common'
    },

    food_pie: {
      id: 'food_pie',
      name: 'Fruit Pie',
      type: 'food',
      icon: 'ðŸ¥§',
      description: 'A warm pie made with fresh berries',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_stew: {
      id: 'food_stew',
      name: 'Herb Stew',
      type: 'food',
      icon: 'ðŸ²',
      description: 'Hearty stew with healing herbs',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_tea: {
      id: 'food_tea',
      name: 'Calming Tea',
      type: 'food',
      icon: 'ðŸµ',
      description: 'Brewed with lavender and mint',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_cake: {
      id: 'food_cake',
      name: 'Celebration Cake',
      type: 'food',
      icon: 'ðŸŽ‚',
      description: 'A cake for special occasions',
      stackable: true,
      maxStack: 5,
      rarity: 'rare'
    },

    decor_wreath: {
      id: 'decor_wreath',
      name: 'Flower Wreath',
      type: 'decorations',
      icon: 'ðŸ’',
      description: 'A woven wreath of wildflowers',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    decor_banner: {
      id: 'decor_banner',
      name: 'Woven Banner',
      type: 'decorations',
      icon: 'ðŸ³ï¸',
      description: 'A decorative banner for buildings',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    decor_windchime: {
      id: 'decor_windchime',
      name: 'Wind Chime',
      type: 'decorations',
      icon: 'ðŸŽ',
      description: 'Tinkles gently in the breeze',
      stackable: true,
      maxStack: 5,
      rarity: 'uncommon'
    },
    decor_mosaic: {
      id: 'decor_mosaic',
      name: 'Crystal Mosaic',
      type: 'decorations',
      icon: 'ðŸªŸ',
      description: 'A stunning crystal mosaic tile',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    rare_feather: {
      id: 'rare_feather',
      name: 'Phoenix Feather',
      type: 'collectibles',
      icon: 'ðŸª¶',
      description: 'A feather that radiates gentle warmth',
      stackable: true,
      maxStack: 10,
      rarity: 'legendary'
    },
    rare_pearl: {
      id: 'rare_pearl',
      name: 'Moon Pearl',
      type: 'collectibles',
      icon: 'ðŸŒ•',
      description: 'Glows softly under moonlight',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary'
    },
    rare_fossil: {
      id: 'rare_fossil',
      name: 'Ancient Fossil',
      type: 'collectibles',
      icon: 'ðŸ¦´',
      description: 'A fossilized remnant from before ZION',
      stackable: true,
      maxStack: 10,
      rarity: 'rare'
    },
    rare_starfragment: {
      id: 'rare_starfragment',
      name: 'Star Fragment',
      type: 'collectibles',
      icon: 'â­',
      description: 'A piece of fallen starlight',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary'
    },

    cloth_silk: {
      id: 'cloth_silk',
      name: 'Silk Thread',
      type: 'cloth',
      icon: 'ðŸ§µ',
      description: 'Fine silk for weaving',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    cloth_wool: {
      id: 'cloth_wool',
      name: 'Wool',
      type: 'cloth',
      icon: 'ðŸ§¶',
      description: 'Soft wool for crafting',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    metal_copper: {
      id: 'metal_copper',
      name: 'Copper Ore',
      type: 'metal',
      icon: 'ðŸŸ¤',
      description: 'Raw copper for smelting',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    metal_silver: {
      id: 'metal_silver',
      name: 'Silver Ingot',
      type: 'metal',
      icon: 'â¬œ',
      description: 'Refined silver for fine crafting',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    metal_gold: {
      id: 'metal_gold',
      name: 'Gold Nugget',
      type: 'metal',
      icon: 'ðŸŸ¡',
      description: 'A nugget of pure gold',
      stackable: true,
      maxStack: 30,
      rarity: 'rare'
    },

    tool_fishing_rod: {
      id: 'tool_fishing_rod',
      name: 'Fishing Rod',
      type: 'tools',
      icon: 'ðŸŽ£',
      description: 'A sturdy rod for catching fish',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    bait_worm: {
      id: 'bait_worm',
      name: 'Worm Bait',
      type: 'bait',
      icon: 'ðŸª±',
      description: 'Simple worm bait for fishing',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    bait_cricket: {
      id: 'bait_cricket',
      name: 'Cricket Bait',
      type: 'bait',
      icon: 'ðŸ¦—',
      description: 'Live cricket bait for better catches',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },

    fish_common: {
      id: 'fish_common',
      name: 'Common Carp',
      type: 'fish',
      icon: 'ðŸŸ',
      description: 'A simple freshwater fish',
      stackable: true,
      maxStack: 50,
      rarity: 'common',
      value: 5
    },
    fish_rare: {
      id: 'fish_rare',
      name: 'Rainbow Trout',
      type: 'fish',
      icon: 'ðŸ ',
      description: 'A beautiful rainbow-colored fish',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon',
      value: 15
    },
    fish_golden: {
      id: 'fish_golden',
      name: 'Golden Koi',
      type: 'fish',
      icon: 'ðŸŸ¡',
      description: 'A rare golden fish of legend',
      stackable: true,
      maxStack: 10,
      rarity: 'rare',
      value: 50
    },
    fish_silver_eel: {
      id: 'fish_silver_eel',
      name: 'Silver Eel',
      type: 'fish',
      icon: 'ðŸ',
      description: 'A sleek silver eel from deep waters',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon',
      value: 20
    },
    fish_crystal_trout: {
      id: 'fish_crystal_trout',
      name: 'Crystal Trout',
      type: 'fish',
      icon: 'ðŸ’Ž',
      description: 'A mystical fish with translucent scales',
      stackable: true,
      maxStack: 15,
      rarity: 'rare',
      value: 40
    },
    fish_shadow_bass: {
      id: 'fish_shadow_bass',
      name: 'Shadow Bass',
      type: 'fish',
      icon: 'ðŸŒ‘',
      description: 'A dark mysterious bass from the depths',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon',
      value: 18
    },
    fish_sunfish: {
      id: 'fish_sunfish',
      name: 'Sunfish',
      type: 'fish',
      icon: 'â˜€ï¸',
      description: 'A bright cheerful sunfish',
      stackable: true,
      maxStack: 50,
      rarity: 'common',
      value: 8
    },
    fish_moonfish: {
      id: 'fish_moonfish',
      name: 'Moonfish',
      type: 'fish',
      icon: 'ðŸŒ™',
      description: 'A pale nocturnal fish',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon',
      value: 25
    },
    fish_starfish: {
      id: 'fish_starfish',
      name: 'Star Cod',
      type: 'fish',
      icon: 'â­',
      description: 'A fish with star-like markings',
      stackable: true,
      maxStack: 20,
      rarity: 'rare',
      value: 35
    },
    fish_dragonfish: {
      id: 'fish_dragonfish',
      name: 'Dragonfish',
      type: 'fish',
      icon: 'ðŸ‰',
      description: 'An extremely rare and powerful fish',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary',
      value: 100
    },

    ingredient_rice: {
      id: 'ingredient_rice',
      name: 'Rice',
      type: 'ingredients',
      icon: 'ðŸš',
      description: 'Grains of white rice',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    ingredient_flour: {
      id: 'ingredient_flour',
      name: 'Flour',
      type: 'ingredients',
      icon: 'ðŸŒ¾',
      description: 'Ground wheat flour',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    ingredient_egg: {
      id: 'ingredient_egg',
      name: 'Egg',
      type: 'ingredients',
      icon: 'ðŸ¥š',
      description: 'A fresh egg',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    ingredient_water: {
      id: 'ingredient_water',
      name: 'Water',
      type: 'ingredients',
      icon: 'ðŸ’§',
      description: 'Clean fresh water',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    food_grilled_fish: {
      id: 'food_grilled_fish',
      name: 'Grilled Fish',
      type: 'food',
      icon: 'ðŸ–',
      description: 'A perfectly grilled fish fillet',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_fish_stew: {
      id: 'food_fish_stew',
      name: 'Fish Stew',
      type: 'food',
      icon: 'ðŸ²',
      description: 'A hearty fish stew with herbs',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_sushi_roll: {
      id: 'food_sushi_roll',
      name: 'Sushi Roll',
      type: 'food',
      icon: 'ðŸ£',
      description: 'Delicate fish wrapped in rice',
      stackable: true,
      maxStack: 15,
      rarity: 'uncommon'
    },
    food_fish_pie: {
      id: 'food_fish_pie',
      name: 'Fish Pie',
      type: 'food',
      icon: 'ðŸ¥§',
      description: 'A savory fish pie with flaky crust',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_luxury_sashimi: {
      id: 'food_luxury_sashimi',
      name: 'Luxury Sashimi',
      type: 'food',
      icon: 'ðŸ±',
      description: 'Premium sashimi made from rare fish',
      stackable: true,
      maxStack: 5,
      rarity: 'rare'
    }
  };

  const RECIPES = [
    {
      id: 'craft_pickaxe',
      name: 'Craft Pickaxe',
      output: { itemId: 'tool_pickaxe', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'stone_common', count: 5 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_axe',
      name: 'Craft Axe',
      output: { itemId: 'tool_axe', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'stone_common', count: 4 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_shovel',
      name: 'Craft Shovel',
      output: { itemId: 'tool_shovel', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'stone_common', count: 3 }
      ],
      sparkReward: 12
    },
    {
      id: 'craft_hammer',
      name: 'Craft Hammer',
      output: { itemId: 'tool_hammer', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'stone_common', count: 6 }
      ],
      sparkReward: 15
    },

    {
      id: 'craft_workbench',
      name: 'Craft Workbench',
      output: { itemId: 'item_workbench', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 8 },
        { itemId: 'stone_common', count: 4 }
      ],
      sparkReward: 25
    },

    {
      id: 'craft_fountain',
      name: 'Craft Fountain',
      output: { itemId: 'item_fountain', count: 1 },
      requirements: [
        { itemId: 'stone_marble', count: 12 },
        { itemId: 'crystal_clear', count: 3 }
      ],
      sparkReward: 40
    },
    {
      id: 'craft_lantern',
      name: 'Craft Lantern',
      output: { itemId: 'item_lantern', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_statue',
      name: 'Craft Crystal Statue',
      output: { itemId: 'item_statue', count: 1 },
      requirements: [
        { itemId: 'stone_marble', count: 10 },
        { itemId: 'crystal_amethyst', count: 5 },
        { itemId: 'crystal_emerald', count: 2 }
      ],
      sparkReward: 100
    },

    {
      id: 'craft_healing_potion',
      name: 'Brew Healing Potion',
      output: { itemId: 'potion_healing', count: 1 },
      requirements: [
        { itemId: 'herb_mint', count: 3 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_energy_potion',
      name: 'Brew Energy Potion',
      output: { itemId: 'potion_energy', count: 1 },
      requirements: [
        { itemId: 'herb_lavender', count: 2 },
        { itemId: 'food_honey', count: 1 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_wisdom_potion',
      name: 'Brew Wisdom Potion',
      output: { itemId: 'potion_wisdom', count: 1 },
      requirements: [
        { itemId: 'herb_sage', count: 3 },
        { itemId: 'herb_ginseng', count: 2 },
        { itemId: 'crystal_amethyst', count: 1 }
      ],
      sparkReward: 35
    },

    {
      id: 'craft_bread',
      name: 'Bake Bread',
      output: { itemId: 'food_bread', count: 2 },
      requirements: [
        { itemId: 'seed_wildflower', count: 10 }
      ],
      sparkReward: 8
    },

    {
      id: 'refine_marble',
      name: 'Refine Marble',
      output: { itemId: 'stone_marble', count: 2 },
      requirements: [
        { itemId: 'stone_common', count: 5 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_mystical_wood',
      name: 'Infuse Mystical Wood',
      output: { itemId: 'wood_mystical', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 5 },
        { itemId: 'crystal_clear', count: 2 }
      ],
      sparkReward: 30
    },

    {
      id: 'craft_book',
      name: 'Bind Knowledge Book',
      output: { itemId: 'item_book', count: 1 },
      requirements: [
        { itemId: 'item_scroll', count: 5 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 25
    },

    {
      id: 'plant_lotus',
      name: 'Plant Lotus Seeds',
      output: { itemId: 'flower_lotus', count: 1 },
      requirements: [
        { itemId: 'seed_lotus', count: 3 }
      ],
      sparkReward: 15
    },
    {
      id: 'plant_flowers',
      name: 'Plant Wildflowers',
      output: { itemId: 'flower_sunflower', count: 3 },
      requirements: [
        { itemId: 'seed_wildflower', count: 5 }
      ],
      sparkReward: 8
    },

    {
      id: 'craft_flute',
      name: 'Carve Wooden Flute',
      output: { itemId: 'instrument_flute', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 4 },
        { itemId: 'herb_sage', count: 2 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_drum',
      name: 'Build Hand Drum',
      output: { itemId: 'instrument_drum', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'cloth_wool', count: 4 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_harp',
      name: 'String Crystal Harp',
      output: { itemId: 'instrument_harp', count: 1 },
      requirements: [
        { itemId: 'wood_mystical', count: 3 },
        { itemId: 'crystal_clear', count: 4 },
        { itemId: 'cloth_silk', count: 6 }
      ],
      sparkReward: 50
    },
    {
      id: 'craft_bell',
      name: 'Cast Harmony Bell',
      output: { itemId: 'instrument_bell', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 8 },
        { itemId: 'metal_silver', count: 3 },
        { itemId: 'crystal_clear', count: 2 }
      ],
      sparkReward: 45
    },

    {
      id: 'craft_pigment',
      name: 'Grind Pigment',
      output: { itemId: 'art_pigment', count: 5 },
      requirements: [
        { itemId: 'flower_rose', count: 2 },
        { itemId: 'flower_tulip', count: 2 },
        { itemId: 'stone_common', count: 1 }
      ],
      sparkReward: 8
    },
    {
      id: 'craft_canvas',
      name: 'Stretch Canvas',
      output: { itemId: 'art_canvas', count: 2 },
      requirements: [
        { itemId: 'cloth_wool', count: 4 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 12
    },
    {
      id: 'craft_ink',
      name: 'Brew Luminous Ink',
      output: { itemId: 'art_ink', count: 3 },
      requirements: [
        { itemId: 'crystal_clear', count: 1 },
        { itemId: 'herb_sage', count: 3 },
        { itemId: 'food_berry', count: 5 }
      ],
      sparkReward: 18
    },

    {
      id: 'craft_compass',
      name: 'Craft Explorer Compass',
      output: { itemId: 'gear_compass', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 5 },
        { itemId: 'crystal_clear', count: 2 },
        { itemId: 'metal_silver', count: 1 }
      ],
      sparkReward: 30
    },
    {
      id: 'craft_spyglass',
      name: 'Craft Spyglass',
      output: { itemId: 'gear_spyglass', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 6 },
        { itemId: 'crystal_clear', count: 3 },
        { itemId: 'metal_silver', count: 2 }
      ],
      sparkReward: 40
    },
    {
      id: 'craft_rope',
      name: 'Braid Climbing Rope',
      output: { itemId: 'gear_rope', count: 2 },
      requirements: [
        { itemId: 'cloth_wool', count: 6 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_map',
      name: 'Draw Zone Map',
      output: { itemId: 'gear_map', count: 1 },
      requirements: [
        { itemId: 'art_ink', count: 2 },
        { itemId: 'art_canvas', count: 1 }
      ],
      sparkReward: 15
    },

    {
      id: 'cook_pie',
      name: 'Bake Fruit Pie',
      output: { itemId: 'food_pie', count: 1 },
      requirements: [
        { itemId: 'food_berry', count: 8 },
        { itemId: 'food_honey', count: 1 },
        { itemId: 'seed_wildflower', count: 5 }
      ],
      sparkReward: 18
    },
    {
      id: 'cook_stew',
      name: 'Cook Herb Stew',
      output: { itemId: 'food_stew', count: 1 },
      requirements: [
        { itemId: 'herb_mint', count: 2 },
        { itemId: 'herb_sage', count: 2 },
        { itemId: 'food_mushroom', count: 3 }
      ],
      sparkReward: 15
    },
    {
      id: 'brew_tea',
      name: 'Brew Calming Tea',
      output: { itemId: 'food_tea', count: 3 },
      requirements: [
        { itemId: 'herb_lavender', count: 3 },
        { itemId: 'herb_mint', count: 2 }
      ],
      sparkReward: 10
    },
    {
      id: 'bake_cake',
      name: 'Bake Celebration Cake',
      output: { itemId: 'food_cake', count: 1 },
      requirements: [
        { itemId: 'food_honey', count: 3 },
        { itemId: 'food_berry', count: 5 },
        { itemId: 'food_bread', count: 2 },
        { itemId: 'flower_cherry', count: 2 }
      ],
      sparkReward: 35
    },

    {
      id: 'craft_wreath',
      name: 'Weave Flower Wreath',
      output: { itemId: 'decor_wreath', count: 1 },
      requirements: [
        { itemId: 'flower_rose', count: 3 },
        { itemId: 'flower_tulip', count: 3 },
        { itemId: 'flower_cherry', count: 2 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_banner',
      name: 'Weave Banner',
      output: { itemId: 'decor_banner', count: 1 },
      requirements: [
        { itemId: 'cloth_silk', count: 5 },
        { itemId: 'art_pigment', count: 3 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_windchime',
      name: 'Craft Wind Chime',
      output: { itemId: 'decor_windchime', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 4 },
        { itemId: 'metal_silver', count: 2 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 25
    },
    {
      id: 'craft_mosaic',
      name: 'Craft Crystal Mosaic',
      output: { itemId: 'decor_mosaic', count: 1 },
      requirements: [
        { itemId: 'crystal_clear', count: 2 },
        { itemId: 'crystal_amethyst', count: 1 },
        { itemId: 'stone_marble', count: 3 }
      ],
      sparkReward: 30
    },

    {
      id: 'smelt_silver',
      name: 'Smelt Silver',
      output: { itemId: 'metal_silver', count: 2 },
      requirements: [
        { itemId: 'metal_copper', count: 6 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 15
    },
    {
      id: 'refine_gold',
      name: 'Refine Gold',
      output: { itemId: 'metal_gold', count: 1 },
      requirements: [
        { itemId: 'metal_silver', count: 4 },
        { itemId: 'crystal_amethyst', count: 1 }
      ],
      sparkReward: 25
    },

    {
      id: 'spin_silk',
      name: 'Spin Silk Thread',
      output: { itemId: 'cloth_silk', count: 3 },
      requirements: [
        { itemId: 'cloth_wool', count: 5 },
        { itemId: 'herb_lavender', count: 2 }
      ],
      sparkReward: 12
    },

    {
      id: 'craft_fishing_rod',
      name: 'Craft Fishing Rod',
      output: { itemId: 'tool_fishing_rod', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 4 },
        { itemId: 'cloth_silk', count: 2 }
      ],
      sparkReward: 18
    },

    {
      id: 'cook_grilled_fish',
      name: 'Grill Fish',
      output: { itemId: 'food_grilled_fish', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 1 },
        { itemId: 'wood_oak', count: 1 }
      ],
      sparkReward: 10
    },
    {
      id: 'cook_fish_stew',
      name: 'Cook Fish Stew',
      output: { itemId: 'food_fish_stew', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 2 },
        { itemId: 'herb_mint', count: 1 },
        { itemId: 'ingredient_water', count: 1 }
      ],
      sparkReward: 15
    },
    {
      id: 'cook_sushi_roll',
      name: 'Make Sushi Roll',
      output: { itemId: 'food_sushi_roll', count: 2 },
      requirements: [
        { itemId: 'fish_rare', count: 1 },
        { itemId: 'ingredient_rice', count: 3 }
      ],
      sparkReward: 20
    },
    {
      id: 'cook_fish_pie',
      name: 'Bake Fish Pie',
      output: { itemId: 'food_fish_pie', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 2 },
        { itemId: 'ingredient_flour', count: 2 },
        { itemId: 'ingredient_egg', count: 1 }
      ],
      sparkReward: 25
    },
    {
      id: 'cook_luxury_sashimi',
      name: 'Prepare Luxury Sashimi',
      output: { itemId: 'food_luxury_sashimi', count: 1 },
      requirements: [
        { itemId: 'fish_golden', count: 1 },
        { itemId: 'ingredient_rice', count: 2 },
        { itemId: 'herb_sage', count: 1 }
      ],
      sparkReward: 50
    }
  ];

  const ZONE_LOOT_TABLES = {
    nexus: {
      common: ['stone_common', 'herb_mint', 'cloth_wool'],
      uncommon: ['crystal_clear', 'metal_copper'],
      rare: ['item_scroll']
    },
    gardens: {
      common: ['seed_wildflower', 'herb_mint', 'herb_lavender', 'food_berry', 'cloth_wool', 'fish_common', 'fish_sunfish', 'bait_worm'],
      uncommon: ['flower_rose', 'flower_tulip', 'flower_cherry', 'herb_sage', 'food_honey', 'fish_rare', 'fish_crystal_trout', 'bait_cricket'],
      rare: ['seed_lotus', 'herb_ginseng', 'flower_lotus', 'rare_feather', 'fish_golden']
    },
    athenaeum: {
      common: ['item_scroll', 'stone_common', 'herb_sage'],
      uncommon: ['crystal_clear', 'art_ink', 'cloth_silk'],
      rare: ['crystal_amethyst', 'item_book', 'rare_fossil']
    },
    studio: {
      common: ['art_pigment', 'art_clay', 'cloth_wool', 'wood_oak'],
      uncommon: ['art_canvas', 'art_ink', 'cloth_silk', 'metal_copper'],
      rare: ['crystal_clear', 'metal_silver', 'rare_pearl']
    },
    wilds: {
      common: ['wood_oak', 'wood_pine', 'stone_common', 'food_mushroom', 'food_berry', 'gear_rope', 'fish_common', 'bait_worm'],
      uncommon: ['herb_ginseng', 'stone_marble', 'metal_copper', 'rare_fossil', 'fish_shadow_bass', 'fish_silver_eel', 'bait_cricket'],
      rare: ['wood_mystical', 'stone_obsidian', 'crystal_emerald', 'rare_starfragment', 'fish_starfish', 'fish_dragonfish']
    },
    agora: {
      common: ['cloth_wool', 'food_bread', 'metal_copper', 'ingredient_rice', 'ingredient_flour', 'ingredient_egg', 'ingredient_water'],
      uncommon: ['cloth_silk', 'metal_silver', 'food_honey', 'fish_rare'],
      rare: ['metal_gold', 'rare_pearl', 'fish_golden']
    },
    commons: {
      common: ['wood_oak', 'stone_common', 'cloth_wool', 'seed_wildflower', 'fish_common', 'bait_worm'],
      uncommon: ['stone_marble', 'metal_copper', 'flower_sunflower', 'fish_rare', 'fish_sunfish'],
      rare: ['crystal_clear', 'metal_silver', 'fish_moonfish']
    },
    arena: {
      common: ['stone_common', 'metal_copper', 'food_mushroom'],
      uncommon: ['stone_marble', 'metal_silver', 'crystal_clear'],
      rare: ['stone_obsidian', 'metal_gold', 'item_trophy']
    }
  };

  function rollHarvestDrop(zoneId, luck) {
    luck = typeof luck === 'number' ? Math.max(0, Math.min(1, luck)) : 0.3;
    var table = ZONE_LOOT_TABLES[zoneId] || ZONE_LOOT_TABLES.nexus;

    var roll = Math.random();
    var rareChance = 0.05 + luck * 0.15;   // 5-20%
    var uncommonChance = 0.25 + luck * 0.1; // 25-35%

    var rarity, pool;
    if (roll < rareChance && table.rare && table.rare.length > 0) {
      rarity = 'rare';
      pool = table.rare;
    } else if (roll < rareChance + uncommonChance && table.uncommon && table.uncommon.length > 0) {
      rarity = 'uncommon';
      pool = table.uncommon;
    } else {
      rarity = 'common';
      pool = table.common;
    }

    var itemId = pool[Math.floor(Math.random() * pool.length)];
    var count = rarity === 'rare' ? 1 : rarity === 'uncommon' ? Math.floor(Math.random() * 2) + 1 : Math.floor(Math.random() * 3) + 1;

    return { itemId: itemId, count: count, rarity: rarity };
  }

  function createInventory() {
    return {
      slots: new Array(20).fill(null),
      quickBar: [0, 1, 2, 3, 4] // Indices of slots shown in quick bar
    };
  }

  function addItem(inventory, itemId, count = 1) {
    const itemData = ITEM_CATALOG[itemId];
    if (!itemData) {
      return { success: false, added: 0, message: 'Unknown item' };
    }

    let remaining = count;

    if (itemData.stackable) {
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && slot.itemId === itemId) {
          const canAdd = Math.min(remaining, itemData.maxStack - slot.count);
          slot.count += canAdd;
          remaining -= canAdd;
          if (remaining <= 0) {
            return { success: true, added: count, message: `Added ${count} ${itemData.name}` };
          }
        }
      }
    }

    for (let i = 0; i < inventory.slots.length; i++) {
      if (inventory.slots[i] === null) {
        const stackSize = itemData.stackable ? Math.min(remaining, itemData.maxStack) : 1;
        inventory.slots[i] = {
          itemId: itemId,
          count: stackSize
        };
        remaining -= stackSize;
        if (remaining <= 0) {
          return { success: true, added: count, message: `Added ${count} ${itemData.name}` };
        }
      }
    }

    const added = count - remaining;
    if (added > 0) {
      return { success: true, added: added, message: `Added ${added} ${itemData.name} (inventory full)` };
    }
    return { success: false, added: 0, message: 'Inventory full' };
  }

  function removeItem(inventory, itemId, count = 1) {
    let remaining = count;

    for (let i = 0; i < inventory.slots.length; i++) {
      const slot = inventory.slots[i];
      if (slot && slot.itemId === itemId) {
        const removeCount = Math.min(remaining, slot.count);
        slot.count -= removeCount;
        remaining -= removeCount;

        if (slot.count <= 0) {
          inventory.slots[i] = null;
        }

        if (remaining <= 0) {
          return { success: true, removed: count };
        }
      }
    }

    const removed = count - remaining;
    return { success: removed > 0, removed: removed };
  }

  function hasItem(inventory, itemId, count = 1) {
    return getItemCount(inventory, itemId) >= count;
  }

  function getItemCount(inventory, itemId) {
    let total = 0;
    for (const slot of inventory.slots) {
      if (slot && slot.itemId === itemId) {
        total += slot.count;
      }
    }
    return total;
  }

  function getInventory(inventory) {
    return inventory.slots.map(slot => {
      if (!slot) return null;
      const itemData = ITEM_CATALOG[slot.itemId];
      return {
        itemId: slot.itemId,
        name: itemData.name,
        icon: itemData.icon,
        description: itemData.description,
        count: slot.count,
        rarity: itemData.rarity,
        type: itemData.type
      };
    });
  }

  function canCraft(inventory, recipe) {
    for (const req of recipe.requirements) {
      if (!hasItem(inventory, req.itemId, req.count)) {
        return false;
      }
    }
    return true;
  }

  function craftItem(inventory, recipeId) {
    const recipe = RECIPES.find(r => r.id === recipeId);
    if (!recipe) {
      return { success: false, message: 'Unknown recipe' };
    }

    if (!canCraft(inventory, recipe)) {
      return { success: false, message: 'Missing required materials' };
    }

    for (const req of recipe.requirements) {
      removeItem(inventory, req.itemId, req.count);
    }

    const result = addItem(inventory, recipe.output.itemId, recipe.output.count);

    if (result.success) {
      return {
        success: true,
        output: recipe.output,
        sparkEarned: recipe.sparkReward,
        message: `Crafted ${recipe.name}!`
      };
    } else {
      return {
        success: false,
        message: 'Crafted but inventory full (materials consumed!)'
      };
    }
  }

  function getAvailableRecipes(inventory) {
    return RECIPES.filter(recipe => canCraft(inventory, recipe));
  }

  function getAllRecipes() {
    return RECIPES;
  }

  function getItemData(itemId) {
    return ITEM_CATALOG[itemId] || null;
  }

  var RARITY_ORDER = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };

  function getInventoryStats(inventory) {
    if (!inventory || !inventory.items) return { totalItems: 0, uniqueItems: 0, totalValue: 0 };

    var totalItems = 0;
    var uniqueItems = 0;
    var byRarity = { common: 0, uncommon: 0, rare: 0, epic: 0, legendary: 0 };
    var byType = {};

    for (var i = 0; i < inventory.items.length; i++) {
      var slot = inventory.items[i];
      if (slot && slot.id) {
        uniqueItems++;
        totalItems += slot.count || 1;
        var data = ITEM_CATALOG[slot.id];
        if (data) {
          var rarity = data.rarity || 'common';
          byRarity[rarity] = (byRarity[rarity] || 0) + (slot.count || 1);
          var type = data.type || 'misc';
          byType[type] = (byType[type] || 0) + (slot.count || 1);
        }
      }
    }

    return {
      totalItems: totalItems,
      uniqueItems: uniqueItems,
      byRarity: byRarity,
      byType: byType,
      slotsUsed: uniqueItems,
      slotsTotal: inventory.maxSlots || 20
    };
  }

  function sortInventory(inventory, sortBy) {
    if (!inventory || !inventory.items) return;
    sortBy = sortBy || 'type';

    var items = inventory.items.filter(function(s) { return s && s.id; });
    var emptyCount = inventory.items.length - items.length;

    items.sort(function(a, b) {
      var dataA = ITEM_CATALOG[a.id] || {};
      var dataB = ITEM_CATALOG[b.id] || {};

      if (sortBy === 'rarity') {
        var ra = RARITY_ORDER[dataA.rarity || 'common'] || 0;
        var rb = RARITY_ORDER[dataB.rarity || 'common'] || 0;
        if (ra !== rb) return rb - ra; // Higher rarity first
      } else if (sortBy === 'type') {
        if (dataA.type !== dataB.type) return (dataA.type || '').localeCompare(dataB.type || '');
      } else if (sortBy === 'name') {
        return (dataA.name || '').localeCompare(dataB.name || '');
      }

      return (dataA.name || '').localeCompare(dataB.name || '');
    });

    inventory.items = items;
    for (var e = 0; e < emptyCount; e++) {
      inventory.items.push(null);
    }
  }

  function searchInventory(inventory, query) {
    if (!inventory || !inventory.items || !query) return [];
    query = query.toLowerCase();

    var results = [];
    for (var i = 0; i < inventory.items.length; i++) {
      var slot = inventory.items[i];
      if (slot && slot.id) {
        var data = ITEM_CATALOG[slot.id] || {};
        if ((data.name || '').toLowerCase().indexOf(query) !== -1 ||
            (data.description || '').toLowerCase().indexOf(query) !== -1 ||
            (data.type || '').toLowerCase().indexOf(query) !== -1) {
          results.push({ slotIndex: i, item: slot, data: data });
        }
      }
    }
    return results;
  }

  exports.ITEM_CATALOG = ITEM_CATALOG;
  exports.RECIPES = RECIPES;
  exports.createInventory = createInventory;
  exports.addItem = addItem;
  exports.removeItem = removeItem;
  exports.hasItem = hasItem;
  exports.getItemCount = getItemCount;
  exports.getInventory = getInventory;
  exports.canCraft = canCraft;
  exports.craftItem = craftItem;
  exports.getAvailableRecipes = getAvailableRecipes;
  exports.getAllRecipes = getAllRecipes;
  exports.getItemData = getItemData;
  exports.getInventoryStats = getInventoryStats;
  exports.sortInventory = sortInventory;
  exports.searchInventory = searchInventory;
  exports.ZONE_LOOT_TABLES = ZONE_LOOT_TABLES;
  exports.rollHarvestDrop = rollHarvestDrop;

})(typeof module !== 'undefined' ? module.exports : (window.Inventory = {}));


// trading.js

(function(exports) {
  'use strict';

  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const Inventory = typeof require !== 'undefined' ? require('./inventory') : window.Inventory;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;

  const activeTrades = new Map();

  const pendingInvitations = new Map();

  let tradeCounter = 0;
  let messageCallback = null;

  function initTrading(onMessage) {
    messageCallback = onMessage;
    console.log('Trading system initialized');
  }

  function requestTrade(fromPlayerId, toPlayerId, position) {
    if (fromPlayerId === toPlayerId) {
      return { success: false, message: 'Cannot trade with yourself' };
    }

    for (const [tradeId, trade] of activeTrades.entries()) {
      if ((trade.player1.id === fromPlayerId && trade.player2.id === toPlayerId) ||
          (trade.player1.id === toPlayerId && trade.player2.id === fromPlayerId)) {
        return { success: false, message: 'Already in a trade with this player' };
      }
    }

    const tradeId = `trade_${tradeCounter++}_${Date.now()}`;

    pendingInvitations.set(tradeId, {
      id: tradeId,
      from: fromPlayerId,
      to: toPlayerId,
      timestamp: Date.now()
    });

    if (messageCallback) {
      const msg = Protocol.create.trade_offer(fromPlayerId, {
        tradeId: tradeId,
        targetPlayer: toPlayerId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, tradeId: tradeId };
  }

  function acceptTrade(tradeId, playerId, position) {
    const invitation = pendingInvitations.get(tradeId);

    if (!invitation) {
      return { success: false, message: 'Trade invitation not found' };
    }

    if (invitation.to !== playerId) {
      return { success: false, message: 'Not the intended recipient' };
    }

    const trade = {
      id: tradeId,
      player1: {
        id: invitation.from,
        items: [], // Array of {slot: number, itemId: string, count: number}
        spark: 0,
        ready: false,
        confirmed: false
      },
      player2: {
        id: invitation.to,
        items: [],
        spark: 0,
        ready: false,
        confirmed: false
      },
      status: 'active', // active, cancelled, completed
      timestamp: Date.now()
    };

    activeTrades.set(tradeId, trade);
    pendingInvitations.delete(tradeId);

    if (messageCallback) {
      const msg = Protocol.create.trade_accept(playerId, {
        tradeId: tradeId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, trade: trade };
  }

  function declineTrade(tradeId, playerId, position) {
    const invitation = pendingInvitations.get(tradeId);

    if (!invitation) {
      return { success: false, message: 'Trade invitation not found' };
    }

    if (invitation.to !== playerId) {
      return { success: false, message: 'Not the intended recipient' };
    }

    pendingInvitations.delete(tradeId);

    if (messageCallback) {
      const msg = Protocol.create.trade_decline(playerId, {
        tradeId: tradeId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true };
  }

  function addItemToTrade(tradeId, playerId, itemSlot, inventory, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (player.items.length >= 6) {
      return { success: false, message: 'Trade slots full (max 6 items)' };
    }

    const item = inventory.slots[itemSlot];
    if (!item) {
      return { success: false, message: 'No item in that slot' };
    }

    if (player.items.find(i => i.slot === itemSlot)) {
      return { success: false, message: 'Item already in trade' };
    }

    player.items.push({
      slot: itemSlot,
      itemId: item.itemId,
      count: item.count
    });

    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  function removeItemFromTrade(tradeId, playerId, tradeSlot, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (tradeSlot < 0 || tradeSlot >= player.items.length) {
      return { success: false, message: 'Invalid trade slot' };
    }

    player.items.splice(tradeSlot, 1);

    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  function setSparkOffer(tradeId, playerId, amount, ledger, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (amount < 0) {
      return { success: false, message: 'Amount must be non-negative' };
    }

    if (Economy && ledger) {
      const balance = Economy.getBalance(ledger, playerId);
      if (balance < amount) {
        return { success: false, message: 'Insufficient Spark' };
      }
    }

    player.spark = amount;

    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  function setReady(tradeId, playerId, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    player.ready = true;

    broadcastTradeUpdate(trade, position);

    const bothReady = trade.player1.ready && trade.player2.ready;
    return { success: true, bothReady: bothReady };
  }

  function confirmTrade(tradeId, playerId, inventory1, inventory2, ledger, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    if (!trade.player1.ready || !trade.player2.ready) {
      return { success: false, message: 'Both players must be ready first' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    player.confirmed = true;

    if (trade.player1.confirmed && trade.player2.confirmed) {
      const result = executeTrade(trade, inventory1, inventory2, ledger);

      if (result.success) {
        trade.status = 'completed';

        if (messageCallback) {
          const msg = Protocol.create.trade_accept(playerId, {
            tradeId: tradeId,
            status: 'completed'
          }, { position: position });
          messageCallback(msg);
        }

        activeTrades.delete(tradeId);

        return { success: true, executed: true };
      } else {
        trade.player1.confirmed = false;
        trade.player2.confirmed = false;
        return { success: false, message: result.message };
      }
    }

    if (messageCallback) {
      const msg = Protocol.create.trade_accept(playerId, {
        tradeId: tradeId,
        confirmed: true
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, executed: false };
  }

  function cancelTrade(tradeId, playerId, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      const invitation = pendingInvitations.get(tradeId);
      if (invitation) {
        pendingInvitations.delete(tradeId);
        return { success: true };
      }
      return { success: false, message: 'Trade not found' };
    }

    if (trade.player1.id !== playerId && trade.player2.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    trade.status = 'cancelled';

    if (messageCallback) {
      const msg = Protocol.create.trade_decline(playerId, {
        tradeId: tradeId,
        reason: 'cancelled'
      }, { position: position });
      messageCallback(msg);
    }

    activeTrades.delete(tradeId);

    return { success: true };
  }

  function executeTrade(trade, inventory1, inventory2, ledger) {
    if (!Inventory || !Economy) {
      return { success: false, message: 'Trading systems not available' };
    }

    for (const tradeItem of trade.player1.items) {
      const invItem = inventory1.slots[tradeItem.slot];
      if (!invItem || invItem.itemId !== tradeItem.itemId || invItem.count < tradeItem.count) {
        return { success: false, message: 'Player 1 no longer has offered items' };
      }
    }

    for (const tradeItem of trade.player2.items) {
      const invItem = inventory2.slots[tradeItem.slot];
      if (!invItem || invItem.itemId !== tradeItem.itemId || invItem.count < tradeItem.count) {
        return { success: false, message: 'Player 2 no longer has offered items' };
      }
    }

    const balance1 = Economy.getBalance(ledger, trade.player1.id);
    const balance2 = Economy.getBalance(ledger, trade.player2.id);

    if (balance1 < trade.player1.spark) {
      return { success: false, message: 'Player 1 insufficient Spark' };
    }
    if (balance2 < trade.player2.spark) {
      return { success: false, message: 'Player 2 insufficient Spark' };
    }

    const p1NeedsSlots = trade.player2.items.length - trade.player1.items.length;
    const p2NeedsSlots = trade.player1.items.length - trade.player2.items.length;

    const p1EmptySlots = inventory1.slots.filter(s => s === null).length;
    const p2EmptySlots = inventory2.slots.filter(s => s === null).length;

    if (p1NeedsSlots > p1EmptySlots) {
      return { success: false, message: 'Player 1 insufficient inventory space' };
    }
    if (p2NeedsSlots > p2EmptySlots) {
      return { success: false, message: 'Player 2 insufficient inventory space' };
    }

    for (const tradeItem of trade.player1.items) {
      Inventory.removeItem(inventory1, tradeItem.itemId, tradeItem.count);
    }
    for (const tradeItem of trade.player2.items) {
      Inventory.removeItem(inventory2, tradeItem.itemId, tradeItem.count);
    }

    for (const tradeItem of trade.player1.items) {
      Inventory.addItem(inventory2, tradeItem.itemId, tradeItem.count);
    }
    for (const tradeItem of trade.player2.items) {
      Inventory.addItem(inventory1, tradeItem.itemId, tradeItem.count);
    }

    if (trade.player1.spark > 0) {
      Economy.transferSpark(ledger, trade.player1.id, trade.player2.id, trade.player1.spark);
    }
    if (trade.player2.spark > 0) {
      Economy.transferSpark(ledger, trade.player2.id, trade.player1.id, trade.player2.spark);
    }

    return { success: true };
  }

  function broadcastTradeUpdate(trade, position) {
    if (!messageCallback) return;

    const msg = Protocol.create.trade_offer(trade.player1.id, {
      tradeId: trade.id,
      player1: {
        items: trade.player1.items,
        spark: trade.player1.spark,
        ready: trade.player1.ready,
        confirmed: trade.player1.confirmed
      },
      player2: {
        items: trade.player2.items,
        spark: trade.player2.spark,
        ready: trade.player2.ready,
        confirmed: trade.player2.confirmed
      },
      status: trade.status
    }, { position: position });

    messageCallback(msg);
  }

  function handleTradeMessage(msg) {
    if (!msg || !msg.type || !msg.payload) {
      return null;
    }

    switch (msg.type) {
      case 'trade_offer':
        if (msg.payload.targetPlayer) {
          return {
            type: 'trade_request',
            data: {
              tradeId: msg.payload.tradeId,
              from: msg.from,
              to: msg.payload.targetPlayer
            }
          };
        } else {
          return {
            type: 'trade_update',
            data: {
              tradeId: msg.payload.tradeId,
              player1: msg.payload.player1,
              player2: msg.payload.player2,
              status: msg.payload.status
            }
          };
        }

      case 'trade_accept':
        if (msg.payload.status === 'completed') {
          return {
            type: 'trade_complete',
            data: {
              tradeId: msg.payload.tradeId
            }
          };
        } else if (msg.payload.confirmed) {
          return {
            type: 'trade_confirm',
            data: {
              tradeId: msg.payload.tradeId,
              playerId: msg.from
            }
          };
        } else {
          return {
            type: 'trade_accepted',
            data: {
              tradeId: msg.payload.tradeId,
              playerId: msg.from
            }
          };
        }

      case 'trade_decline':
        return {
          type: 'trade_cancelled',
          data: {
            tradeId: msg.payload.tradeId,
            reason: msg.payload.reason || 'declined'
          }
        };

      default:
        return null;
    }
  }

  function getActiveTrade(playerId) {
    for (const [tradeId, trade] of activeTrades.entries()) {
      if (trade.player1.id === playerId || trade.player2.id === playerId) {
        return trade;
      }
    }
    return null;
  }

  function getPendingInvitation(playerId) {
    for (const [tradeId, invitation] of pendingInvitations.entries()) {
      if (invitation.to === playerId) {
        return invitation;
      }
    }
    return null;
  }

  exports.initTrading = initTrading;
  exports.requestTrade = requestTrade;
  exports.acceptTrade = acceptTrade;
  exports.declineTrade = declineTrade;
  exports.addItemToTrade = addItemToTrade;
  exports.removeItemFromTrade = removeItemFromTrade;
  exports.setSparkOffer = setSparkOffer;
  exports.setReady = setReady;
  exports.confirmTrade = confirmTrade;
  exports.cancelTrade = cancelTrade;
  exports.handleTradeMessage = handleTradeMessage;
  exports.getActiveTrade = getActiveTrade;
  exports.getPendingInvitation = getPendingInvitation;

})(typeof module !== 'undefined' ? module.exports : (window.Trading = {}));


// state.js

(function(exports) {
  'use strict';

  let liveState = null;

  function createWorldState() {
    return {
      world: {
        time: 0,
        weather: 'clear',
        season: 'spring',
        dayPhase: 'day'
      },
      players: {},
      economy: {
        balances: {},
        transactions: [],
        listings: []
      },
      gardens: {},
      structures: {},
      discoveries: {},
      anchors: {},
      chat: [],
      actions: [],
      changes: [],
      competitions: {},
      federation: {
        federations: []
      },
      playerStars: {}
    };
  }

  function getLiveState() {
    if (!liveState) {
      liveState = createWorldState();
    }
    return liveState;
  }

  function setLiveState(path, value) {
    if (!liveState) {
      liveState = createWorldState();
    }

    const parts = path.split('.');
    let current = liveState;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }

    current[parts[parts.length - 1]] = value;
  }

  function flushToLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const state = getLiveState();
      localStorage.setItem('zion_state', JSON.stringify(state));
    } catch (e) {
      console.error('Failed to flush to localStorage:', e);
    }
  }

  function loadFromLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const stored = localStorage.getItem('zion_state');
      if (stored) {
        liveState = JSON.parse(stored);
      } else {
        liveState = createWorldState();
      }
    } catch (e) {
      console.error('Failed to load from localStorage:', e);
      liveState = createWorldState();
    }
  }

  function flushToCanonical() {
    const state = getLiveState();
    return JSON.stringify(state);
  }

  function loadFromCanonical(json) {
    try {
      liveState = JSON.parse(json);
    } catch (e) {
      console.error('Failed to parse canonical state:', e);
      liveState = createWorldState();
    }
  }

  function applyMessage(state, message) {
    const newState = JSON.parse(JSON.stringify(state));

    const { type, from, payload } = message;
    const timestamp = message.ts || Date.now();

    switch (type) {
      case 'join':
        newState.players[from] = {
          id: from,
          name: payload.name || from,
          position: payload.position || { x: 0, y: 0, z: 0 },
          zone: payload.zone || 'default',
          online: true,
          last_seen: timestamp,
          idle: false,
          inventory: [],
          intentions: [],
          ...payload
        };
        break;

      case 'leave':
        if (newState.players[from]) {
          newState.players[from].online = false;
          newState.players[from].last_seen = timestamp;
        }
        break;

      case 'heartbeat':
        if (newState.players[from]) {
          newState.players[from].last_seen = timestamp;
          newState.players[from].idle = false;
        }
        break;

      case 'idle':
        if (newState.players[from]) {
          newState.players[from].idle = true;
        }
        break;

      case 'move':
        if (newState.players[from] && payload.position) {
          newState.players[from].position = payload.position;
        }
        break;

      case 'warp':
        if (newState.players[from]) {
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
          if (payload.zone) {
            newState.players[from].zone = payload.zone;
          }
        }
        break;

      case 'say':
      case 'shout':
      case 'whisper':
      case 'emote':
        newState.chat.push({
          id: `chat_${timestamp}_${from}`,
          type,
          from,
          to: payload.to,
          text: payload.text || payload.message || '',
          ts: timestamp
        });
        break;

      case 'build':
        if (payload.structure) {
          const structureId = `struct_${timestamp}_${from}`;
          newState.structures[structureId] = {
            id: structureId,
            builder: from,
            type: payload.structure.type,
            position: payload.structure.position,
            data: payload.structure.data || {},
            ts: timestamp
          };
        }
        break;

      case 'plant':
        if (payload.plant) {
          const gardenId = `garden_${timestamp}_${from}`;
          newState.gardens[gardenId] = {
            id: gardenId,
            gardener: from,
            plant: payload.plant.type,
            position: payload.plant.position,
            planted_at: timestamp,
            ready_at: timestamp + (payload.plant.grow_time || 60000),
            ready: false
          };
        }
        break;

      case 'harvest':
        if (payload.gardenId && newState.gardens[payload.gardenId]) {
          const garden = newState.gardens[payload.gardenId];
          if (garden.ready || timestamp >= garden.ready_at) {
            delete newState.gardens[payload.gardenId];
            if (newState.players[from] && newState.players[from].inventory) {
              newState.players[from].inventory.push({
                type: garden.plant,
                harvested_at: timestamp
              });
            }
          }
        }
        break;

      case 'craft':
        if (payload.item && newState.players[from]) {
          if (!newState.players[from].inventory) {
            newState.players[from].inventory = [];
          }
          newState.players[from].inventory.push({
            type: payload.item.type,
            crafted_at: timestamp,
            data: payload.item.data || {}
          });
        }
        break;

      case 'compose':
        if (payload.art) {
          const artId = `art_${timestamp}_${from}`;
          newState.structures[artId] = {
            id: artId,
            artist: from,
            type: 'art',
            art_type: payload.art.type,
            position: payload.art.position,
            data: payload.art.data || {},
            ts: timestamp
          };
        }
        break;

      case 'trade_offer':
        newState.actions.push({
          id: `trade_${timestamp}_${from}`,
          type: 'trade_offer',
          from,
          to: payload.to,
          offered: payload.offered || [],
          requested: payload.requested || [],
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'trade_accept':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'accepted';
            trade.completed_at = timestamp;
            var sender = newState.players[trade.from];
            var recipient = newState.players[trade.to];
            if (sender && recipient) {
              if (!sender.inventory) sender.inventory = [];
              if (!recipient.inventory) recipient.inventory = [];
              if (trade.offered && trade.offered.length > 0) {
                trade.offered.forEach(function(item) {
                  var idx = sender.inventory.findIndex(function(inv) { return inv.type === item.type; });
                  if (idx !== -1) {
                    sender.inventory.splice(idx, 1);
                    recipient.inventory.push(item);
                  }
                });
              }
              if (trade.requested && trade.requested.length > 0) {
                trade.requested.forEach(function(item) {
                  var idx = recipient.inventory.findIndex(function(inv) { return inv.type === item.type; });
                  if (idx !== -1) {
                    recipient.inventory.splice(idx, 1);
                    sender.inventory.push(item);
                  }
                });
              }
            }
          }
        }
        break;

      case 'trade_decline':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'declined';
            trade.completed_at = timestamp;
          }
        }
        break;

      case 'buy':
        var buyActionId = 'buy_' + timestamp + '_' + from;
        var listing = (newState.economy.listings || []).find(function(l) { return l.id === payload.listingId && l.active; });
        if (listing) {
          var buyerBal = (newState.economy.balances[from] || 0);
          if (buyerBal >= listing.price) {
            newState.economy.balances[from] = (newState.economy.balances[from] || 0) - listing.price;
            newState.economy.balances[listing.seller] = (newState.economy.balances[listing.seller] || 0) + listing.price;
            listing.active = false;
            listing.sold_to = from;
            listing.sold_at = timestamp;
            if (newState.players[from]) {
              if (!newState.players[from].inventory) newState.players[from].inventory = [];
              newState.players[from].inventory.push({
                type: listing.itemType || listing.item,
                purchased_at: timestamp,
                data: listing.data || {}
              });
            }
            newState.economy.transactions.push({
              id: buyActionId,
              type: 'buy',
              from: from,
              to: listing.seller,
              amount: listing.price,
              item: listing.itemType || listing.item,
              ts: timestamp
            });
          }
        }
        newState.actions.push({
          id: buyActionId,
          type: 'buy',
          buyer: from,
          listingId: payload.listingId,
          success: !!listing,
          ts: timestamp
        });
        break;

      case 'sell':
        var sellActionId = 'sell_' + timestamp + '_' + from;
        var listingId = 'listing_' + timestamp + '_' + from;
        if (!newState.economy.listings) newState.economy.listings = [];
        newState.economy.listings.push({
          id: listingId,
          seller: from,
          item: payload.item,
          itemType: payload.item && payload.item.type ? payload.item.type : payload.item,
          price: payload.price || 0,
          active: true,
          data: payload.data || {},
          ts: timestamp
        });
        newState.actions.push({
          id: sellActionId,
          type: 'sell',
          seller: from,
          listingId: listingId,
          item: payload.item,
          price: payload.price,
          ts: timestamp
        });
        break;

      case 'gift':
        if (payload.to && payload.item) {
          newState.actions.push({
            id: `gift_${timestamp}_${from}`,
            type: 'gift',
            from,
            to: payload.to,
            item: payload.item,
            ts: timestamp
          });
          if (newState.players[from] && newState.players[payload.to]) {
            if (!newState.players[payload.to].inventory) {
              newState.players[payload.to].inventory = [];
            }
            newState.players[payload.to].inventory.push({
              ...payload.item,
              gifted_from: from,
              gifted_at: timestamp
            });
          }
        }
        break;

      case 'teach':
        newState.actions.push({
          id: `teach_${timestamp}_${from}`,
          type: 'teach',
          teacher: from,
          student: payload.to,
          skill: payload.skill,
          ts: timestamp
        });
        break;

      case 'learn':
        newState.actions.push({
          id: `learn_${timestamp}_${from}`,
          type: 'learn',
          learner: from,
          skill: payload.skill,
          source: payload.source,
          ts: timestamp
        });
        break;

      case 'mentor_offer':
        newState.actions.push({
          id: `mentor_${timestamp}_${from}`,
          type: 'mentor_offer',
          mentor: from,
          mentee: payload.to,
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'mentor_accept':
        if (payload.mentorId) {
          const mentorship = newState.actions.find(a => a.id === payload.mentorId);
          if (mentorship && mentorship.type === 'mentor_offer') {
            mentorship.status = 'accepted';
            mentorship.accepted_at = timestamp;
          }
        }
        break;

      case 'challenge':
        const challengeId = `challenge_${timestamp}_${from}`;
        newState.competitions[challengeId] = {
          id: challengeId,
          challenger: from,
          challenged: payload.to,
          type: payload.challenge_type,
          status: 'pending',
          ts: timestamp
        };
        break;

      case 'accept_challenge':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'active';
          newState.competitions[payload.challengeId].accepted_at = timestamp;
        }
        break;

      case 'forfeit':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'forfeited';
          newState.competitions[payload.challengeId].forfeited_by = from;
          newState.competitions[payload.challengeId].completed_at = timestamp;
        }
        break;

      case 'score':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          const comp = newState.competitions[payload.challengeId];
          if (!comp.scores) {
            comp.scores = {};
          }
          comp.scores[from] = payload.score;
        }
        break;

      case 'discover':
        if (payload.discovery) {
          const discoveryId = `discovery_${timestamp}_${from}`;
          newState.discoveries[discoveryId] = {
            id: discoveryId,
            discoverer: from,
            type: payload.discovery.type,
            location: payload.discovery.location,
            data: payload.discovery.data || {},
            ts: timestamp
          };
        }
        break;

      case 'anchor_place':
        if (payload.anchor) {
          const anchorId = `anchor_${timestamp}_${from}`;
          newState.anchors[anchorId] = {
            id: anchorId,
            owner: from,
            position: payload.anchor.position,
            zone: payload.anchor.zone || 'default',
            name: payload.anchor.name,
            ts: timestamp
          };
        }
        break;

      case 'inspect':
        break;

      case 'intention_set':
        if (newState.players[from] && payload.intention) {
          if (!newState.players[from].intentions) {
            newState.players[from].intentions = [];
          }
          newState.players[from].intentions.push({
            text: payload.intention,
            set_at: timestamp
          });
        }
        break;

      case 'intention_clear':
        if (newState.players[from]) {
          newState.players[from].intentions = [];
        }
        break;

      case 'warp_fork':
        if (newState.players[from] && payload.target_world) {
          newState.players[from].current_world = payload.target_world;
          newState.players[from].home_world = newState.players[from].home_world || 'default';
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'return_home':
        if (newState.players[from]) {
          const homeWorld = newState.players[from].home_world || 'default';
          newState.players[from].current_world = homeWorld;
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'federation_announce':
        if (payload.federation) {
          newState.federation.federations.push({
            id: `fed_${timestamp}_${from}`,
            announced_by: from,
            name: payload.federation.name,
            endpoint: payload.federation.endpoint,
            ts: timestamp
          });
        }
        break;

      case 'federation_handshake':
        if (payload.federationId) {
          const fed = newState.federation.federations.find(f => f.id === payload.federationId);
          if (fed) {
            fed.handshake_complete = true;
            fed.handshake_at = timestamp;
          }
        }
        break;

      case 'star_register':
        if (!newState.playerStars) newState.playerStars = {};
        if (payload) {
          newState.playerStars[from] = {
            name: payload.name || from,
            x: payload.x || 0,
            y: payload.y || 0,
            z: payload.z || 0,
            color: payload.color || 0xFFDD88,
            ts: timestamp
          };
        }
        break;

      case 'election_start':
        if (!newState.elections) newState.elections = {};
        var electionId = 'election_' + timestamp + '_' + (payload.zone || 'nexus');
        newState.elections[electionId] = {
          id: electionId,
          zone: payload.zone,
          started_by: from,
          candidates: [from],
          votes: {},
          started_at: timestamp,
          ends_at: timestamp + (30 * 24 * 60 * 60 * 1000), // 30-day term
          status: 'active'
        };
        break;

      case 'election_vote':
        if (newState.elections && payload.electionId) {
          var election = newState.elections[payload.electionId];
          if (election && election.status === 'active') {
            election.votes[from] = payload.candidate;
            if (payload.candidate && election.candidates.indexOf(payload.candidate) === -1) {
              election.candidates.push(payload.candidate);
            }
          }
        }
        break;

      case 'election_finalize':
        if (newState.elections && payload.electionId) {
          var elecFinal = newState.elections[payload.electionId];
          if (elecFinal && elecFinal.status === 'active') {
            var voteCounts = {};
            Object.values(elecFinal.votes).forEach(function(candidate) {
              voteCounts[candidate] = (voteCounts[candidate] || 0) + 1;
            });
            var winner = null;
            var maxVotes = 0;
            Object.keys(voteCounts).forEach(function(c) {
              if (voteCounts[c] > maxVotes) { maxVotes = voteCounts[c]; winner = c; }
            });
            elecFinal.status = 'complete';
            elecFinal.winner = winner;
            elecFinal.completed_at = timestamp;
            if (!newState.stewards) newState.stewards = {};
            if (winner) {
              newState.stewards[elecFinal.zone] = {
                playerId: winner,
                zone: elecFinal.zone,
                elected_at: timestamp,
                term_ends: timestamp + (30 * 24 * 60 * 60 * 1000)
              };
            }
          }
        }
        break;

      case 'steward_set_welcome':
        if (!newState.stewards) newState.stewards = {};
        var steward = newState.stewards[payload.zone];
        if (steward && steward.playerId === from) {
          steward.welcomeMessage = payload.message;
        }
        break;

      case 'steward_set_policy':
        if (!newState.stewards) newState.stewards = {};
        var stewardPolicy = newState.stewards[payload.zone];
        if (stewardPolicy && stewardPolicy.playerId === from) {
          stewardPolicy.policy = payload.policy;
        }
        break;

      case 'steward_moderate':
        if (!newState.stewards) newState.stewards = {};
        var stewardMod = newState.stewards[payload.zone];
        if (stewardMod && stewardMod.playerId === from) {
          newState.actions.push({
            id: 'moderate_' + timestamp + '_' + from,
            type: 'moderation',
            steward: from,
            zone: payload.zone,
            target: payload.target,
            action: payload.action,
            reason: payload.reason,
            ts: timestamp
          });
        }
        break;

      case 'sim_crm_action':
        if (!newState.simulations) newState.simulations = {};
        if (!newState.simulations.crm) newState.simulations.crm = { actions: [] };
        newState.simulations.crm.actions.push({
          id: 'sim_' + timestamp + '_' + from,
          from: from,
          action: payload.action,
          data: payload.data || {},
          ts: timestamp
        });
        break;

      case 'propose_amendment':
        if (!newState.amendments) newState.amendments = [];
        if (payload.title && payload.description && payload.diff_text) {
          var amendId = 'amend_' + timestamp + '_' + from;
          var discussionDays = Math.max(7, parseInt(payload.discussion_period_days || 7, 10));
          var proposedAt = new Date(typeof timestamp === 'number' ? timestamp : timestamp);
          var closesAt = new Date(proposedAt.getTime() + discussionDays * 86400000);
          newState.amendments.push({
            id: amendId,
            title: payload.title,
            description: payload.description,
            diff_text: payload.diff_text,
            proposed_by: from,
            proposed_at: typeof timestamp === 'string' ? timestamp : new Date(timestamp).toISOString(),
            discussion_period_days: discussionDays,
            voting_closes_at: closesAt.toISOString(),
            status: 'open',
            votes: [],
            result: null
          });
        }
        break;

      case 'vote_amendment':
        if (newState.amendments && payload.amendment_id && payload.vote) {
          var voteAmend = null;
          for (var ai = 0; ai < newState.amendments.length; ai++) {
            if (newState.amendments[ai].id === payload.amendment_id) {
              voteAmend = newState.amendments[ai];
              break;
            }
          }
          if (voteAmend && voteAmend.status === 'open') {
            var alreadyVoted = false;
            for (var vi = 0; vi < voteAmend.votes.length; vi++) {
              if (voteAmend.votes[vi].from === from) { alreadyVoted = true; break; }
            }
            if (!alreadyVoted && (payload.vote === 'for' || payload.vote === 'against')) {
              var sparkWeight = Math.max(1, (newState.economy && newState.economy.balances && newState.economy.balances[from]) || 1);
              voteAmend.votes.push({
                from: from,
                vote: payload.vote,
                spark_weight: sparkWeight,
                ts: typeof timestamp === 'string' ? timestamp : new Date(timestamp).toISOString()
              });
            }
          }
        }
        break;

      case 'close_amendment':
        if (newState.amendments && payload.amendment_id) {
          for (var ci = 0; ci < newState.amendments.length; ci++) {
            if (newState.amendments[ci].id === payload.amendment_id) {
              newState.amendments[ci].status = 'closed';
              newState.amendments[ci].result = payload.result || null;
              if (payload.tally) {
                newState.amendments[ci].tally = payload.tally;
              }
              newState.amendments[ci].closed_at = typeof timestamp === 'string' ? timestamp : new Date(timestamp).toISOString();
              break;
            }
          }
        }
        break;

      default:
        break;
    }

    newState.changes.push({
      type,
      from,
      ts: timestamp
    });

    return newState;
  }

  function resolveConflict(stateA, stateB) {
    const merged = JSON.parse(JSON.stringify(stateA));

    const allChanges = [
      ...(stateA.changes || []),
      ...(stateB.changes || [])
    ].sort((a, b) => a.ts - b.ts);

    const uniqueChanges = [];
    const seen = new Set();
    for (const change of allChanges) {
      const key = `${change.type}_${change.from}_${change.ts}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueChanges.push(change);
      }
    }

    merged.changes = uniqueChanges;

    merged.players = { ...stateA.players };
    for (const [playerId, playerB] of Object.entries(stateB.players || {})) {
      const playerA = merged.players[playerId];
      if (!playerA || (playerB.last_seen || 0) > (playerA.last_seen || 0)) {
        merged.players[playerId] = playerB;
      }
    }

    const mergeById = (collectionA, collectionB) => {
      const result = { ...collectionA };
      for (const [id, item] of Object.entries(collectionB || {})) {
        if (!result[id] || (item.ts || 0) > (result[id].ts || 0)) {
          result[id] = item;
        }
      }
      return result;
    };

    merged.gardens = mergeById(stateA.gardens || {}, stateB.gardens || {});
    merged.structures = mergeById(stateA.structures || {}, stateB.structures || {});
    merged.discoveries = mergeById(stateA.discoveries || {}, stateB.discoveries || {});
    merged.anchors = mergeById(stateA.anchors || {}, stateB.anchors || {});
    merged.competitions = mergeById(stateA.competitions || {}, stateB.competitions || {});

    merged.chat = [
      ...(stateA.chat || []),
      ...(stateB.chat || [])
    ].sort((a, b) => a.ts - b.ts);

    merged.actions = [
      ...(stateA.actions || []),
      ...(stateB.actions || [])
    ];
    const actionIds = new Set();
    merged.actions = merged.actions.filter(action => {
      if (actionIds.has(action.id)) {
        return false;
      }
      actionIds.add(action.id);
      return true;
    });

    merged.economy = {
      balances: { ...(stateA.economy?.balances || {}), ...(stateB.economy?.balances || {}) },
      transactions: [
        ...(stateA.economy?.transactions || []),
        ...(stateB.economy?.transactions || [])
      ].sort((a, b) => a.ts - b.ts),
      listings: [
        ...(stateA.economy?.listings || []),
        ...(stateB.economy?.listings || [])
      ]
    };

    merged.federation = {
      federations: [
        ...(stateA.federation?.federations || []),
        ...(stateB.federation?.federations || [])
      ]
    };

    const worldATime = stateA.world?.time || 0;
    const worldBTime = stateB.world?.time || 0;
    merged.world = worldBTime > worldATime ? stateB.world : stateA.world;

    return merged;
  }

  function initState() {
    return createWorldState();
  }

  function addPlayer(state, player) {
    if (!state || !player) return;
    state.players[player.id] = {
      id: player.id,
      name: player.name || player.id,
      position: player.position || { x: 0, y: 0, z: 0 },
      zone: player.zone || 'nexus',
      spark: player.spark || 0,
      warmth: player.warmth || 0,
      online: true,
      lastSeen: new Date().toISOString()
    };
  }

  function removePlayer(state, playerId) {
    if (!state || !playerId) return;
    if (state.players[playerId]) {
      state.players[playerId].online = false;
      state.players[playerId].lastSeen = new Date().toISOString();
    }
  }

  function getPlayer(state, playerId) {
    if (!state || !playerId) return null;
    return state.players[playerId] || null;
  }

  function getPlayers(state) {
    if (!state) return [];
    return Object.values(state.players);
  }

  exports.createWorldState = createWorldState;
  exports.initState = initState;
  exports.addPlayer = addPlayer;
  exports.removePlayer = removePlayer;
  exports.getPlayer = getPlayer;
  exports.getPlayers = getPlayers;
  exports.getLiveState = getLiveState;
  exports.setLiveState = setLiveState;
  exports.flushToLocal = flushToLocal;
  exports.loadFromLocal = loadFromLocal;
  exports.flushToCanonical = flushToCanonical;
  exports.loadFromCanonical = loadFromCanonical;
  exports.applyMessage = applyMessage;
  exports.resolveConflict = resolveConflict;

})(typeof module !== 'undefined' ? module.exports : (window.State = {}));


// LAZY_LOAD_START: replay
(function(exports) {
  'use strict';

  function sortByTimestamp(messages) {
    return messages.slice().sort(function(a, b) {
      var ta = new Date(a.ts).getTime();
      var tb = new Date(b.ts).getTime();
      return ta - tb;
    });
  }

  function buildRecording(messages) {
    var sorted = sortByTimestamp(messages);
    var startTime = sorted.length > 0 ? sorted[0].ts : null;
    var endTime = sorted.length > 0 ? sorted[sorted.length - 1].ts : null;
    var duration = 0;
    if (startTime && endTime) {
      duration = new Date(endTime).getTime() - new Date(startTime).getTime();
    }
    return {
      messages: sorted,
      startTime: startTime,
      endTime: endTime,
      duration: duration
    };
  }

  function createRecorder() {
    var _messages = [];

    function record(message) {
      _messages.push(message);
    }

    function stop() {
      return buildRecording(_messages);
    }

    function exportRecording() {
      var recording = buildRecording(_messages);
      return JSON.stringify(recording);
    }

    return {
      record: record,
      stop: stop,
      export: exportRecording
    };
  }

  function createPlayer(recording) {
    var _messages = recording.messages || [];
    var _speed = 1;
    var _currentIndex = 0;
    var _playing = false;
    var _paused = false;
    var _stopped = false;
    var _callback = null;
    var _completeCallback = null;
    var _timeoutId = null;

    var _resumeDelay = 0;

    var _elapsedMs = 0;

    function onComplete(cb) {
      _completeCallback = cb;
    }

    function setSpeed(multiplier) {
      _speed = Math.max(0.01, multiplier);
    }

    function getProgress() {
      var total = _messages.length;
      var current = Math.min(_currentIndex, total);
      var percent = total === 0 ? 100 : Math.round((current / total) * 100);
      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;
      var totalDuration = recording.duration || 0;
      var elapsed = _elapsedMs;
      var remaining = Math.max(0, totalDuration - elapsed);
      return {
        current: current,
        total: total,
        percent: percent,
        elapsed: elapsed,
        remaining: remaining
      };
    }

    function seek(timestamp) {
      if (_timeoutId !== null) {
        clearTimeout(_timeoutId);
        _timeoutId = null;
      }

      var seekMs = new Date(timestamp).getTime();
      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;

      var idx = 0;
      for (var i = 0; i < _messages.length; i++) {
        var msgMs = new Date(_messages[i].ts).getTime();
        if (msgMs >= seekMs) {
          break;
        }
        idx = i + 1;
      }
      _currentIndex = idx;
      _elapsedMs = Math.max(0, seekMs - startMs);
    }

    function _scheduleNext() {
      if (_stopped || _paused) return;
      if (_currentIndex >= _messages.length) {
        _playing = false;
        _elapsedMs = recording.duration || 0;
        if (_completeCallback) _completeCallback();
        return;
      }

      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;
      var nowMs = startMs + _elapsedMs;
      var nextMsg = _messages[_currentIndex];
      var nextMsgMs = new Date(nextMsg.ts).getTime();

      var virtualDelay = Math.max(0, nextMsgMs - nowMs);
      var realDelay = virtualDelay / _speed;

      _timeoutId = setTimeout(function() {
        if (_stopped || _paused) return;
        _timeoutId = null;

        var msg = _messages[_currentIndex];
        _elapsedMs = new Date(msg.ts).getTime() - startMs;
        _currentIndex++;

        if (_callback) _callback(msg);

        _scheduleNext();
      }, realDelay);
    }

    function play(callback, speed) {
      if (speed !== undefined) {
        setSpeed(speed);
      }
      _callback = callback;
      _playing = true;
      _paused = false;
      _stopped = false;

      if (_messages.length === 0) {
        _playing = false;
        setTimeout(function() {
          if (_completeCallback) _completeCallback();
        }, 0);
        return;
      }

      _scheduleNext();
    }

    function pause() {
      if (!_playing || _paused) return;
      _paused = true;

      if (_timeoutId !== null) {
        clearTimeout(_timeoutId);
        _timeoutId = null;
      }

      if (_currentIndex < _messages.length) {
        var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;
        var nowMs = startMs + _elapsedMs;
        var nextMsgMs = new Date(_messages[_currentIndex].ts).getTime();
        var virtualRemaining = Math.max(0, nextMsgMs - nowMs);
        _resumeDelay = virtualRemaining / _speed;
      } else {
        _resumeDelay = 0;
      }
    }

    function resume() {
      if (!_paused) return;
      _paused = false;

      if (_currentIndex >= _messages.length) {
        _playing = false;
        if (_completeCallback) _completeCallback();
        return;
      }

      var delay = _resumeDelay;
      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;

      _timeoutId = setTimeout(function() {
        if (_stopped || _paused) return;
        _timeoutId = null;

        var msg = _messages[_currentIndex];
        _elapsedMs = new Date(msg.ts).getTime() - startMs;
        _currentIndex++;

        if (_callback) _callback(msg);

        _scheduleNext();
      }, delay);
    }

    function stop() {
      _stopped = true;
      _playing = false;
      _paused = false;
      if (_timeoutId !== null) {
        clearTimeout(_timeoutId);
        _timeoutId = null;
      }
    }

    return {
      play: play,
      pause: pause,
      resume: resume,
      stop: stop,
      seek: seek,
      setSpeed: setSpeed,
      getProgress: getProgress,
      onComplete: onComplete
    };
  }

  function importRecording(jsonString) {
    var data;
    try {
      data = JSON.parse(jsonString);
    } catch (e) {
      throw new Error('importRecording: invalid JSON â€” ' + e.message);
    }
    if (!data || !Array.isArray(data.messages)) {
      throw new Error('importRecording: missing messages array');
    }
    return buildRecording(data.messages);
  }

  function importFromInbox(inboxDir) {
    var fs = require('fs');
    var path = require('path');

    var files;
    try {
      files = fs.readdirSync(inboxDir);
    } catch (e) {
      throw new Error('importFromInbox: cannot read directory â€” ' + e.message);
    }

    var messages = [];

    for (var i = 0; i < files.length; i++) {
      var filename = files[i];
      if (!filename.endsWith('.json')) continue;

      var filepath = path.join(inboxDir, filename);

      var stat;
      try {
        stat = fs.statSync(filepath);
      } catch (e) {
        continue;
      }
      if (!stat.isFile()) continue;

      var content;
      try {
        content = fs.readFileSync(filepath, 'utf8');
      } catch (e) {
        continue; // Skip unreadable files
      }

      var msg;
      try {
        msg = JSON.parse(content);
      } catch (e) {
        continue; // Skip malformed JSON
      }

      if (!msg.ts) continue;

      messages.push(msg);
    }

    return buildRecording(messages);
  }

  exports.createRecorder = createRecorder;
  exports.createPlayer = createPlayer;
  exports.importRecording = importRecording;
  exports.importFromInbox = importFromInbox;

})(typeof module !== 'undefined' ? module.exports : (window.Replay = {}));

// LAZY_LOAD_END: replay

// LAZY_LOAD_START: yaml_dash
(function(exports) {
  'use strict';

  var YAML_BOOL_NULL = {
    'true': true, 'false': true, 'yes': true, 'no': true,
    'on': true, 'off': true, 'null': true, '~': true
  };

  var LOOKS_NUMERIC = /^[+-]?(\d+\.?\d*|\.\d+)([eE][+-]?\d+)?$/;

  var LOOKS_DATE = /^\d{4}-\d{2}-\d{2}/;

  var SPECIAL_START_CHARS = { '#': true, '@': true, '&': true, '*': true,
                               '|': true, '>': true, '!': true, '%': true,
                               '[': true, '{': true };

  function _needsQuoting(s) {
    if (s === '') return true;
    if (YAML_BOOL_NULL[s.toLowerCase()]) return true;
    if (LOOKS_NUMERIC.test(s)) return true;
    if (LOOKS_DATE.test(s)) return true;
    if (SPECIAL_START_CHARS[s[0]]) return true;
    if (s.indexOf(': ') !== -1 || s[s.length - 1] === ':') return true;
    if (s[0] === '"' || s[0] === "'" || s[0] === ' ' || s[0] === ',') return true;
    if (s[s.length - 1] === ' ') return true;
    if (s.indexOf("'") !== -1) return true;
    return false;
  }

  function _quote(s) {
    return "'" + s.replace(/'/g, "''") + "'";
  }

  function _needsKeyQuoting(key) {
    if (key === '') return true;
    if (YAML_BOOL_NULL[key.toLowerCase()]) return true;
    if (LOOKS_NUMERIC.test(key)) return true;
    if (LOOKS_DATE.test(key)) return true;
    if (SPECIAL_START_CHARS[key[0]]) return true;
    if (key.indexOf(': ') !== -1 || key[key.length - 1] === ':') return true;
    if (key[0] === '"' || key[0] === "'" || key[0] === ' ' || key[0] === ',') return true;
    if (key[key.length - 1] === ' ') return true;
    return false;
  }

  function _formatKey(key) {
    if (_needsKeyQuoting(key)) return _quote(key);
    return key;
  }

  function _formatScalar(value) {
    if (value === null) return 'null';
    if (value === true) return 'true';
    if (value === false) return 'false';
    if (typeof value === 'number') return String(value);
    if (typeof value === 'string') {
      if (value.indexOf('\n') !== -1) return null; // signal: use block scalar
      if (_needsQuoting(value)) return _quote(value);
      return value;
    }
    return String(value);
  }

  function _renderBlockScalar(s, indent) {
    var prefix = _repeat(' ', indent);
    var header, body;
    if (s[s.length - 1] === '\n') {
      header = '|';
      body = s.slice(0, s.length - 1);
    } else {
      header = '|-';
      body = s;
    }
    var lines = body.split('\n');
    var result = header + '\n';
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (line) {
        result += prefix + line + '\n';
      } else {
        result += '\n';
      }
    }
    return result;
  }

  function _repeat(str, n) {
    var out = '';
    for (var i = 0; i < n; i++) out += str;
    return out;
  }

  function _isObject(v) {
    return v !== null && typeof v === 'object' && !Array.isArray(v);
  }

  function _isArray(v) {
    return Array.isArray(v);
  }

  function _render(value, indent, inlineFirst) {
    var prefix = _repeat(' ', indent);
    indent = indent || 0;
    inlineFirst = inlineFirst || false;

    if (_isObject(value)) {
      var keys = Object.keys(value);
      if (keys.length === 0) {
        return inlineFirst ? '{}\n' : prefix + '{}\n';
      }
      var lines = [];
      var first = true;
      for (var ki = 0; ki < keys.length; ki++) {
        var key = keys[ki];
        var val = value[key];
        var fk = _formatKey(String(key));
        var linePrefix = (first && inlineFirst) ? '' : prefix;

        if (_isObject(val)) {
          if (Object.keys(val).length === 0) {
            lines.push(linePrefix + fk + ': {}\n');
          } else {
            lines.push(linePrefix + fk + ':\n');
            lines.push(_render(val, indent + 2, false));
          }
        } else if (_isArray(val)) {
          if (val.length === 0) {
            lines.push(linePrefix + fk + ': []\n');
          } else {
            lines.push(linePrefix + fk + ':\n');
            lines.push(_render(val, indent + 2, false));
          }
        } else if (typeof val === 'string' && val.indexOf('\n') !== -1) {
          lines.push(linePrefix + fk + ': ' + _renderBlockScalar(val, indent + 2));
        } else {
          var scalar = _formatScalar(val);
          lines.push(linePrefix + fk + ': ' + scalar + '\n');
        }
        first = false;
      }
      return lines.join('');
    }

    if (_isArray(value)) {
      if (value.length === 0) {
        return inlineFirst ? '[]\n' : prefix + '[]\n';
      }
      var arrLines = [];
      var arrFirst = true;
      for (var ai = 0; ai < value.length; ai++) {
        var item = value[ai];
        var arrPrefix = (arrFirst && inlineFirst) ? '' : prefix;

        if (_isObject(item)) {
          if (Object.keys(item).length === 0) {
            arrLines.push(arrPrefix + '- {}\n');
          } else {
            arrLines.push(arrPrefix + '- ' + _render(item, indent + 2, true));
          }
        } else if (_isArray(item)) {
          if (item.length === 0) {
            arrLines.push(arrPrefix + '- []\n');
          } else {
            arrLines.push(arrPrefix + '- ' + _render(item, indent + 2, true));
          }
        } else if (typeof item === 'string' && item.indexOf('\n') !== -1) {
          arrLines.push(arrPrefix + '- ' + _renderBlockScalar(item, indent + 2));
        } else {
          var sc = _formatScalar(item);
          arrLines.push(arrPrefix + '- ' + sc + '\n');
        }
        arrFirst = false;
      }
      return arrLines.join('');
    }

    if (typeof value === 'string' && value.indexOf('\n') !== -1) {
      return _renderBlockScalar(value, indent);
    }
    var topScalar = _formatScalar(value);
    if (inlineFirst) return topScalar + '\n';
    return prefix + topScalar + '\n';
  }

  function jsonToYaml(data) {
    return _render(data, 0, false);
  }

  function _typeOf(value) {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    if (typeof value === 'boolean') return 'boolean';
    if (typeof value === 'number') return 'number';
    return 'string';
  }

  function buildTree(data, path, depth, key) {
    path = (path === undefined || path === null) ? '' : path;
    depth = depth || 0;
    key = (key === undefined || key === null) ? '' : String(key);

    var type = _typeOf(data);
    var node = {
      key: key,
      value: (type === 'object' || type === 'array') ? null : data,
      type: type,
      children: [],
      path: path,
      collapsed: true,
      depth: depth
    };

    if (type === 'object') {
      var objKeys = Object.keys(data);
      for (var i = 0; i < objKeys.length; i++) {
        var k = objKeys[i];
        var childPath = path ? (path + '.' + k) : k;
        node.children.push(buildTree(data[k], childPath, depth + 1, k));
      }
    } else if (type === 'array') {
      for (var ai = 0; ai < data.length; ai++) {
        var arrPath = path ? (path + '[' + ai + ']') : ('[' + ai + ']');
        node.children.push(buildTree(data[ai], arrPath, depth + 1, String(ai)));
      }
    }

    return node;
  }

  function _findNode(node, path) {
    if (node.path === path) return node;
    for (var i = 0; i < node.children.length; i++) {
      var found = _findNode(node.children[i], path);
      if (found) return found;
    }
    return null;
  }

  function toggleNode(tree, path) {
    var node = _findNode(tree, path);
    if (node && node.children.length > 0) {
      node.collapsed = !node.collapsed;
    }
  }

  function getVisibleNodes(node) {
    var result = [];
    _collectVisible(node, result);
    return result;
  }

  function _collectVisible(node, result) {
    result.push(node);
    if (!node.collapsed) {
      for (var i = 0; i < node.children.length; i++) {
        _collectVisible(node.children[i], result);
      }
    }
  }

  function filterTree(tree, query) {
    if (!query || query === '') {
      return _cloneTree(tree);
    }
    var q = query.toLowerCase();
    var cloned = _cloneTree(tree);
    var matched = _markMatches(cloned, q);
    return cloned;
  }

  function _cloneTree(node) {
    var clone = {
      key: node.key,
      value: node.value,
      type: node.type,
      children: [],
      path: node.path,
      collapsed: node.collapsed,
      depth: node.depth
    };
    for (var i = 0; i < node.children.length; i++) {
      clone.children.push(_cloneTree(node.children[i]));
    }
    return clone;
  }

  function _markMatches(node, query) {
    var selfMatch = false;

    if (node.key && node.key.toLowerCase().indexOf(query) !== -1) {
      selfMatch = true;
    }

    if (!selfMatch && node.value !== null && node.value !== undefined) {
      var valStr = String(node.value).toLowerCase();
      if (valStr.indexOf(query) !== -1) {
        selfMatch = true;
      }
    }

    var childMatch = false;
    for (var i = 0; i < node.children.length; i++) {
      if (_markMatches(node.children[i], query)) {
        childMatch = true;
      }
    }

    if (childMatch) {
      node.collapsed = false;
    }

    return selfMatch || childMatch;
  }

  function renderToText(tree, expanded) {
    var lines = [];
    _renderNode(tree, lines, expanded || false);
    return lines.join('\n') + (lines.length > 0 ? '\n' : '');
  }

  function _renderNode(node, lines, forceExpanded) {
    var indent = _repeat('  ', node.depth);
    var isContainer = node.children.length > 0;
    var isCollapsed = forceExpanded ? false : node.collapsed;

    var line = indent;

    if (node.key !== '') {
      line += node.key + ': ';
    }

    if (isContainer) {
      if (isCollapsed) {
        var typeHint = node.type === 'array' ? '[' + node.children.length + ' items]'
                                              : '{' + node.children.length + ' keys}';
        line += 'â–¶ ' + typeHint;
      } else {
        var openHint = node.type === 'array' ? 'â–¼ [' : 'â–¼ {';
        line += openHint;
      }
    } else {
      var valStr = _formatScalar(node.value);
      if (valStr === null) {
        valStr = _quote(String(node.value));
      }
      line += valStr;
    }

    lines.push(line);

    if (isContainer && !isCollapsed) {
      for (var i = 0; i < node.children.length; i++) {
        _renderNode(node.children[i], lines, forceExpanded);
      }
      var closeHint = node.type === 'array' ? _repeat('  ', node.depth) + ']'
                                            : _repeat('  ', node.depth) + '}';
      lines.push(closeHint);
    }
  }

  var _panelState = {
    data: null,
    title: 'YAML Dashboard',
    tree: null,
    container: null,
    panel: null,
    searchQuery: ''
  };

  function createPanel(containerId) {
    if (typeof document === 'undefined') return null;

    var container = document.getElementById(containerId);
    if (!container) return null;

    var panel = document.createElement('div');
    panel.className = 'yaml-dash-panel';
    panel.innerHTML = [
      '<div class="yaml-dash-header">',
      '  <span class="yaml-dash-title">YAML Dashboard</span>',
      '  <input class="yaml-dash-search" type="text" placeholder="Search keys/values..." />',
      '</div>',
      '<div class="yaml-dash-body">',
      '  <pre class="yaml-dash-content">No data loaded.</pre>',
      '</div>'
    ].join('');

    _panelState.panel = panel;
    _panelState.container = container;

    var searchInput = panel.querySelector('.yaml-dash-search');
    if (searchInput) {
      searchInput.addEventListener('input', function() {
        _panelState.searchQuery = searchInput.value;
        _refreshPanel();
      });
    }

    container.appendChild(panel);
    return panel;
  }

  function loadData(data, title) {
    _panelState.data = data;
    if (title) {
      _panelState.title = title;
      if (_panelState.panel) {
        var titleEl = _panelState.panel.querySelector('.yaml-dash-title');
        if (titleEl) titleEl.textContent = title;
      }
    }
    _panelState.tree = buildTree(data, 'root');
    _refreshPanel();
  }

  function refresh() {
    _refreshPanel();
  }

  function _refreshPanel() {
    if (!_panelState.panel || !_panelState.tree) return;

    var displayTree = _panelState.searchQuery
      ? filterTree(_panelState.tree, _panelState.searchQuery)
      : _panelState.tree;

    var content = _panelState.panel.querySelector('.yaml-dash-content');
    if (!content) return;

    if (!displayTree) {
      content.textContent = '(no results for "' + _panelState.searchQuery + '")';
      return;
    }

    content.textContent = renderToText(displayTree);

    content.onclick = function(e) {
      var target = e.target;
      var path = target.getAttribute('data-path');
      if (path) {
        toggleNode(_panelState.tree, path);
        _refreshPanel();
      }
    };
  }

  exports.jsonToYaml = jsonToYaml;
  exports.buildTree = buildTree;
  exports.toggleNode = toggleNode;
  exports.getVisibleNodes = getVisibleNodes;
  exports.filterTree = filterTree;
  exports.renderToText = renderToText;
  exports.createPanel = createPanel;
  exports.loadData = loadData;
  exports.refresh = refresh;

})(typeof module !== 'undefined' ? module.exports : (window.YamlDash = {}));

// LAZY_LOAD_END: yaml_dash

// intentions.js

(function(exports) {
  'use strict';

  const intentionStore = new Map();

  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  const MAX_INTENTIONS_PER_PLAYER = 10;

  function registerIntention(playerId, intention) {
    if (!intention.id || typeof intention.id !== 'string') {
      return { success: false, error: 'Intention must have a valid id' };
    }

    if (!intention.trigger || typeof intention.trigger !== 'object') {
      return { success: false, error: 'Intention must have a trigger object' };
    }

    if (!intention.trigger.condition || typeof intention.trigger.condition !== 'string') {
      return { success: false, error: 'Trigger must have a condition string' };
    }

    if (!intention.trigger.params || typeof intention.trigger.params !== 'object') {
      return { success: false, error: 'Trigger must have a params object' };
    }

    if (!intention.action || typeof intention.action !== 'object') {
      return { success: false, error: 'Intention must have an action object' };
    }

    if (!intention.action.type || typeof intention.action.type !== 'string') {
      return { success: false, error: 'Action must have a type string' };
    }

    if (!intention.action.params || typeof intention.action.params !== 'object') {
      return { success: false, error: 'Action must have a params object' };
    }

    if (typeof intention.priority !== 'number') {
      return { success: false, error: 'Intention must have a numeric priority' };
    }

    if (typeof intention.ttl !== 'number') {
      return { success: false, error: 'Intention must have a numeric ttl' };
    }

    if (typeof intention.cooldown !== 'number') {
      return { success: false, error: 'Intention must have a numeric cooldown' };
    }

    if (typeof intention.max_fires !== 'number') {
      return { success: false, error: 'Intention must have a numeric max_fires' };
    }

    const playerIntentions = intentionStore.get(playerId) || [];
    if (playerIntentions.length >= MAX_INTENTIONS_PER_PLAYER) {
      return { success: false, error: `Maximum ${MAX_INTENTIONS_PER_PLAYER} intentions per player exceeded` };
    }

    const intentionWithMeta = {
      ...intention,
      createdAt: Date.now(),
      lastFired: null,
      fireCount: 0
    };

    playerIntentions.push(intentionWithMeta);
    intentionStore.set(playerId, playerIntentions);

    return { success: true };
  }

  function clearIntentions(playerId) {
    intentionStore.delete(playerId);
  }

  function getIntentions(playerId) {
    return intentionStore.get(playerId) || [];
  }

  function isIntentionExpired(intention, now) {
    return (now - intention.createdAt) > (intention.ttl * 1000);
  }

  function canIntentionFire(intention, now) {
    if (intention.fireCount >= intention.max_fires) {
      return false;
    }

    if (intention.lastFired !== null) {
      const timeSinceLastFire = now - intention.lastFired;
      if (timeSinceLastFire < (intention.cooldown * 1000)) {
        return false;
      }
    }

    return true;
  }

  const triggerEvaluators = {
    player_nearby: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const onlyUnknown = params.known === false;

      for (const [playerId, player] of worldState.players.entries()) {
        if (playerId === ownerId) continue;
        if (!player.position) continue;

        const distance = getDistance(owner.position, player.position);
        if (distance < distanceLimit) {
          if (onlyUnknown) {
            const knownPlayers = owner.knownPlayers || new Set();
            if (!knownPlayers.has(playerId)) {
              return true;
            }
          } else {
            return true;
          }
        }
      }

      return false;
    },

    player_say: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const keyword = params.keyword;
      const distanceLimit = params.distance_lt || 20;
      const recentChats = worldState.recentChats || [];

      for (const chat of recentChats) {
        if (chat.from === ownerId) continue;

        const speaker = worldState.players.get(chat.from);
        if (!speaker || !speaker.position) continue;

        const distance = getDistance(owner.position, speaker.position);
        if (distance < distanceLimit) {
          if (chat.message && chat.message.toLowerCase().includes(keyword.toLowerCase())) {
            return true;
          }
        }
      }

      return false;
    },

    timer: function(params, worldState, ownerId, intention, now) {
      const intervalMs = params.interval_seconds * 1000;

      if (intention.lastFired === null) {
        return true;
      }

      return (now - intention.lastFired) >= intervalMs;
    },

    zone_enter: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      return owner.position.zone === params.zone_id;
    },

    garden_needs: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const gardens = worldState.gardens || [];

      for (const garden of gardens) {
        if (!garden.position) continue;

        const distance = getDistance(owner.position, garden.position);
        if (distance < distanceLimit) {
          if (garden.needsWater || garden.needsHarvest || garden.needsWeeding) {
            return true;
          }
        }
      }

      return false;
    },

    resource_ready: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const resources = worldState.resources || [];

      for (const resource of resources) {
        if (!resource.position) continue;
        if (!resource.harvestable) continue;

        const distance = getDistance(owner.position, resource.position);
        if (distance < distanceLimit) {
          return true;
        }
      }

      return false;
    },

    health_below: function(params, worldState, ownerId) {
      var owner = worldState.players.get(ownerId);
      if (!owner) return false;

      var threshold = typeof params.threshold === 'number' ? params.threshold : 50;

      var warmth = typeof owner.warmth === 'number' ? owner.warmth : 100;
      return warmth < threshold;
    },

    item_nearby: function(params, worldState, ownerId) {
      var owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      var distanceLimit = params.distance_lt || 10;
      var targetItemType = params.item_type || '';

      var resources = worldState.resources || [];
      for (var i = 0; i < resources.length; i++) {
        var resource = resources[i];
        if (!resource.position) continue;
        if (targetItemType && resource.type !== targetItemType) continue;
        var dist = getDistance(owner.position, resource.position);
        if (dist < distanceLimit) {
          return true;
        }
      }

      var structures = worldState.structures || {};
      var structureList = Array.isArray(structures) ? structures : Object.values(structures);
      for (var j = 0; j < structureList.length; j++) {
        var structure = structureList[j];
        if (!structure.position) continue;
        if (targetItemType && structure.art_type !== targetItemType && structure.type !== targetItemType) continue;
        var structDist = getDistance(owner.position, structure.position);
        if (structDist < distanceLimit) {
          return true;
        }
      }

      return false;
    },

    trade_received: function(params, worldState, ownerId) {
      var filterItemType = params.item_type || null;
      var actions = worldState.actions || [];

      for (var i = 0; i < actions.length; i++) {
        var action = actions[i];
        if (action.type !== 'trade_offer') continue;
        if (action.status !== 'pending') continue;
        if (action.to !== ownerId) continue;

        if (!filterItemType) return true;

        var offered = action.offered || [];
        for (var j = 0; j < offered.length; j++) {
          if (offered[j].type === filterItemType || offered[j].name === filterItemType) {
            return true;
          }
        }
      }

      return false;
    },

    weather_change: function(params, worldState, ownerId) {
      var world = worldState.world || {};
      var currentWeather = world.weather || 'clear';
      var targetWeather = params.weather_type || '';
      return currentWeather === targetWeather;
    },

    time_of_day: function(params, worldState, ownerId) {
      var world = worldState.world || {};
      var currentPhase = world.dayPhase || 'day';
      var targetPhase = params.phase || '';

      if (currentPhase === targetPhase) return true;

      if (targetPhase === 'day') {
        return currentPhase === 'morning' || currentPhase === 'midday' || currentPhase === 'afternoon';
      }

      if (targetPhase === 'dusk') {
        return currentPhase === 'evening';
      }

      return false;
    },

    ally_nearby: function(params, worldState, ownerId) {
      var owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      var distanceLimit = params.distance_lt || 20;
      var groupId = params.group_id || null;

      for (var entry of worldState.players.entries()) {
        var playerId = entry[0];
        var player = entry[1];
        if (playerId === ownerId) continue;
        if (!player.position) continue;

        var playerGroupId = player.guildId || player.guild_id || player.groupId || player.group_id || null;

        if (groupId && playerGroupId !== groupId) continue;

        if (!groupId) {
          var ownerGroupId = owner.guildId || owner.guild_id || owner.groupId || owner.group_id || null;
          if (!ownerGroupId) continue; // no group to match against
          if (playerGroupId !== ownerGroupId) continue;
        }

        var dist = getDistance(owner.position, player.position);
        if (dist < distanceLimit) {
          return true;
        }
      }

      return false;
    }
  };

  function getDistance(posA, posB) {
    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  function generateActionMessage(intention, playerId, worldState) {
    const action = intention.action;
    const player = worldState.players.get(playerId);

    if (!player) return null;

    if (CONSENT_REQUIRED_TYPES.has(action.type)) {
      return null;
    }

    const message = {
      type: action.type,
      from: playerId,
      payload: { ...action.params },
      position: player.position ? { ...player.position } : null
    };

    return message;
  }

  function evaluateTriggers(playerId, worldState, deltaTime) {
    const intentions = intentionStore.get(playerId) || [];
    const now = Date.now();
    const actions = [];

    const sortedIntentions = [...intentions].sort((a, b) => b.priority - a.priority);

    for (const intention of sortedIntentions) {
      if (isIntentionExpired(intention, now)) {
        continue;
      }

      if (!canIntentionFire(intention, now)) {
        continue;
      }

      const triggerType = intention.trigger.condition;
      const evaluator = triggerEvaluators[triggerType];

      if (!evaluator) {
        continue;
      }

      let triggered = false;
      try {
        triggered = evaluator(
          intention.trigger.params,
          worldState,
          playerId,
          intention,
          now
        );
      } catch (error) {
        continue;
      }

      if (triggered) {
        const actionMessage = generateActionMessage(intention, playerId, worldState);

        if (actionMessage) {
          actions.push(actionMessage);

          intention.lastFired = now;
          intention.fireCount++;
        }
      }
    }

    return actions;
  }

  exports.registerIntention = registerIntention;
  exports.clearIntentions = clearIntentions;
  exports.getIntentions = getIntentions;
  exports.evaluateTriggers = evaluateTriggers;
  exports.isIntentionExpired = isIntentionExpired;
  exports.canIntentionFire = canIntentionFire;

})(typeof module !== 'undefined' ? module.exports : (window.Intentions = {}));


// social.js

(function(exports) {
  'use strict';

  const consentStore = new Map(); // "${fromId}:${toId}:${type}" -> boolean
  const rateLimitStore = new Map(); // playerId -> {count, windowStart}
  const reputationStore = new Map(); // playerId -> {score, tier, history}
  const harassmentStore = new Map(); // "${fromId}:${toId}" -> {declineCount, lastDecline}

  const RATE_LIMIT_MAX = 30; // messages per window
  const RATE_LIMIT_WINDOW = 60000; // 60 seconds in milliseconds
  const SAY_DISTANCE = 20;
  const EMOTE_DISTANCE = 30;

  const REPUTATION_TIERS = [
    { name: 'Newcomer', minScore: 0, maxScore: 99 },
    { name: 'Trusted', minScore: 100, maxScore: 499 },
    { name: 'Respected', minScore: 500, maxScore: 1499 },
    { name: 'Honored', minScore: 1500, maxScore: 4999 },
    { name: 'Elder', minScore: 5000, maxScore: Infinity }
  ];

  const REPUTATION_GAINS = {
    helping: 10,
    teaching: 15,
    trading: 5,
    gifting: 8,
    guild_contribution: 12,
    mentoring: 20,
    zone_steward_action: 5
  };

  const REPUTATION_LOSSES = {
    harassment: -25,
    griefing_report: -50,
    steward_violation: -30
  };

  const HARASSMENT_THRESHOLD = 3; // Declined interactions before harassment flag
  const HARASSMENT_WINDOW = 600000; // 10 minutes

  function getDistance(posA, posB) {
    if (!posA || !posB) return Infinity;

    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  function getNearbyPlayers(position, state, maxDistance) {
    const nearby = [];

    if (!position || !state.players) return nearby;

    for (const [playerId, player] of state.players.entries()) {
      if (!player.position) continue;

      if (player.position.zone !== position.zone) continue;

      const distance = getDistance(position, player.position);
      if (distance <= maxDistance) {
        nearby.push(playerId);
      }
    }

    return nearby;
  }

  function checkRateLimit(playerId, now) {
    const limit = rateLimitStore.get(playerId);

    if (!limit) {
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    const windowAge = now - limit.windowStart;

    if (windowAge >= RATE_LIMIT_WINDOW) {
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    if (limit.count >= RATE_LIMIT_MAX) {
      const retryAfter = RATE_LIMIT_WINDOW - windowAge;
      return { allowed: false, retryAfter };
    }

    limit.count++;
    return { allowed: true };
  }

  function handleSay(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, SAY_DISTANCE);

    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  function handleShout(msg, state) {
    if (!msg.from || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = [];
    const senderZone = sender.position.zone;

    for (const [playerId, player] of state.players.entries()) {
      if (playerId === msg.from) continue;
      if (!player.position) continue;

      if (player.position.zone === senderZone) {
        recipients.push(playerId);
      }
    }

    return { recipients };
  }

  function handleWhisper(msg, state) {
    if (!msg.from || !msg.to) {
      return { success: false, error: 'Whisper requires from and to fields' };
    }

    if (!hasConsent(msg.from, msg.to, 'whisper')) {
      return { success: false, error: 'Whisper requires consent from recipient' };
    }

    return { success: true };
  }

  function handleEmote(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, EMOTE_DISTANCE);

    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  function grantConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.set(key, true);
  }

  function revokeConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.delete(key);
  }

  function hasConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    return consentStore.get(key) === true;
  }

  function addMessage(state, message) {
    if (!state || !message) return;
    if (!state.chat) state.chat = { messages: [] };
    if (!state.chat.messages) state.chat.messages = [];
    state.chat.messages.push({
      user: message.user,
      text: message.text,
      timestamp: message.timestamp || new Date().toISOString()
    });
    if (state.chat.messages.length > 100) {
      state.chat.messages = state.chat.messages.slice(-100);
    }
  }

  function getRecentMessages(state, count) {
    if (!state || !state.chat || !state.chat.messages) return [];
    count = count || 50;
    return state.chat.messages.slice(-count);
  }

  function initReputation(playerId) {
    if (!reputationStore.has(playerId)) {
      reputationStore.set(playerId, {
        score: 0,
        tier: 'Newcomer',
        history: [],
        restrictions: {
          tradeBanned: false,
          zoneMuted: new Set(),
          zoneBanned: new Set()
        }
      });
    }
  }

  function getReputation(playerId) {
    initReputation(playerId);
    return reputationStore.get(playerId);
  }

  function calculateTier(score) {
    for (const tier of REPUTATION_TIERS) {
      if (score >= tier.minScore && score <= tier.maxScore) {
        return tier.name;
      }
    }
    return 'Newcomer';
  }

  function adjustReputation(playerId, action, details) {
    initReputation(playerId);
    const rep = reputationStore.get(playerId);

    const change = REPUTATION_GAINS[action] || REPUTATION_LOSSES[action] || 0;
    const oldScore = rep.score;
    const oldTier = rep.tier;

    rep.score = Math.max(0, rep.score + change);
    rep.tier = calculateTier(rep.score);

    rep.history.push({
      action,
      change,
      oldScore,
      newScore: rep.score,
      timestamp: Date.now(),
      details: details || {}
    });

    if (rep.history.length > 100) {
      rep.history = rep.history.slice(-100);
    }

    const tierChanged = oldTier !== rep.tier;

    return {
      score: rep.score,
      tier: rep.tier,
      change,
      tierChanged,
      oldTier
    };
  }

  function recordDecline(fromId, toId, type) {
    const key = `${fromId}:${toId}`;
    const now = Date.now();

    if (!harassmentStore.has(key)) {
      harassmentStore.set(key, {
        declineCount: 0,
        lastDecline: 0,
        type: type
      });
    }

    const record = harassmentStore.get(key);

    if (now - record.lastDecline > HARASSMENT_WINDOW) {
      record.declineCount = 0;
    }

    record.declineCount++;
    record.lastDecline = now;
    record.type = type;

    if (record.declineCount >= HARASSMENT_THRESHOLD) {
      adjustReputation(fromId, 'harassment', {
        targetPlayer: toId,
        interactionType: type,
        declineCount: record.declineCount
      });

      record.declineCount = 0;

      return true; // Harassment detected
    }

    return false;
  }

  function applyReputationRestrictions(playerId) {
    const rep = getReputation(playerId);

    if (rep.score < 0) {
      rep.restrictions.tradeBanned = true;
    } else if (rep.score < 50) {
      rep.restrictions.tradeBanned = false;
    }
  }

  function checkReputationPermission(playerId, action, zone) {
    const rep = getReputation(playerId);

    if (action === 'trade' && rep.restrictions.tradeBanned) {
      return { allowed: false, reason: 'Trade restricted due to low reputation' };
    }

    if (zone && rep.restrictions.zoneMuted.has(zone) && (action === 'say' || action === 'shout')) {
      return { allowed: false, reason: 'You are muted in this zone' };
    }

    if (zone && rep.restrictions.zoneBanned.has(zone)) {
      return { allowed: false, reason: 'You are temporarily banned from this zone' };
    }

    if (action === 'run_for_steward' && rep.tier !== 'Respected' && rep.tier !== 'Honored' && rep.tier !== 'Elder') {
      return { allowed: false, reason: 'Must be Respected tier or higher to run for zone steward' };
    }

    return { allowed: true };
  }

  function muteInZone(playerId, zone, duration) {
    const rep = getReputation(playerId);
    rep.restrictions.zoneMuted.add(zone);

    if (duration > 0) {
      setTimeout(() => {
        rep.restrictions.zoneMuted.delete(zone);
      }, duration);
    }
  }

  function banFromZone(playerId, zone, duration) {
    const rep = getReputation(playerId);
    rep.restrictions.zoneBanned.add(zone);

    setTimeout(() => {
      rep.restrictions.zoneBanned.delete(zone);
    }, duration);
  }

  exports.handleSay = handleSay;
  exports.handleShout = handleShout;
  exports.handleWhisper = handleWhisper;
  exports.handleEmote = handleEmote;
  exports.grantConsent = grantConsent;
  exports.revokeConsent = revokeConsent;
  exports.hasConsent = hasConsent;
  exports.checkRateLimit = checkRateLimit;
  exports.getDistance = getDistance;
  exports.getNearbyPlayers = getNearbyPlayers;
  exports.addMessage = addMessage;
  exports.getRecentMessages = getRecentMessages;

  exports.initReputation = initReputation;
  exports.getReputation = getReputation;
  exports.adjustReputation = adjustReputation;
  exports.recordDecline = recordDecline;
  exports.checkReputationPermission = checkReputationPermission;
  exports.muteInZone = muteInZone;
  exports.banFromZone = banFromZone;
  exports.REPUTATION_TIERS = REPUTATION_TIERS;

})(typeof module !== 'undefined' ? module.exports : (window.Social = {}));


// creation.js
(function(exports) {

  const PLANT_SPECIES = {
    sunflower: {
      growthTime: 300000, // 5 min
      yields: [{type: 'sunflower', quantity: 3}]
    },
    oak_tree: {
      growthTime: 600000, // 10 min
      yields: [{type: 'wood', quantity: 5}]
    },
    wheat: {
      growthTime: 180000, // 3 min
      yields: [{type: 'wheat', quantity: 10}]
    },
    crystal_bloom: {
      growthTime: 900000, // 15 min
      yields: [{type: 'crystal', quantity: 1}]
    },
    herbs: {
      growthTime: 120000, // 2 min
      yields: [{type: 'herbs', quantity: 5}]
    }
  };

  const RECIPES = {
    wooden_bench: {
      materials: {wood: 3},
      produces: {type: 'wooden_bench', quantity: 1},
      complexity: 0.2
    },
    flower_crown: {
      materials: {sunflower: 2},
      produces: {type: 'flower_crown', quantity: 1},
      complexity: 0.1
    },
    crystal_lamp: {
      materials: {crystal: 1, wood: 1},
      produces: {type: 'crystal_lamp', quantity: 1},
      complexity: 0.5
    },
    bread: {
      materials: {wheat: 3, herbs: 1},
      produces: {type: 'bread', quantity: 2},
      complexity: 0.3
    },
    healing_tea: {
      materials: {herbs: 3},
      produces: {type: 'healing_tea', quantity: 1},
      complexity: 0.4
    }
  };

  const STRUCTURE_TYPES = [
    'house', 'workshop', 'garden_shed', 'monument', 'bridge',
    'fountain', 'stage', 'market_stall', 'bench', 'lantern'
  ];

  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  function handleBuild(msg, state, zoneRules) {
    if (!zoneRules.building) {
      return {
        success: false,
        error: 'Building not allowed in this zone'
      };
    }

    const structureType = msg.payload.type;
    if (!STRUCTURE_TYPES.includes(structureType)) {
      return {
        success: false,
        error: 'Invalid structure type'
      };
    }

    const structure = {
      id: generateId(),
      type: structureType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      builder: msg.from,
      ts: Date.now()
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(structure);

    return {
      success: true,
      state: state,
      structure: structure
    };
  }

  function handlePlant(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Planting not allowed in this zone'
      };
    }

    const species = msg.payload.species;
    if (!PLANT_SPECIES[species]) {
      return {
        success: false,
        error: 'Invalid plant species'
      };
    }

    const speciesData = PLANT_SPECIES[species];
    const plantedAt = Date.now();
    const readyAt = plantedAt + speciesData.growthTime;

    const garden = {
      id: generateId(),
      species: species,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      planter: msg.from,
      plantedAt: plantedAt,
      growthStage: 0,
      readyAt: readyAt
    };

    if (!state.gardens) {
      state.gardens = [];
    }

    state.gardens.push(garden);

    return {
      success: true,
      state: state,
      garden: garden
    };
  }

  function handleHarvest(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Harvesting not allowed in this zone'
      };
    }

    if (!state.gardens || state.gardens.length === 0) {
      return {
        success: false,
        error: 'No gardens to harvest'
      };
    }

    const targetId = msg.payload.target;
    const gardenIndex = state.gardens.findIndex(g => g.id === targetId);

    if (gardenIndex === -1) {
      return {
        success: false,
        error: 'Garden not found'
      };
    }

    const garden = state.gardens[gardenIndex];
    const now = Date.now();

    const isReady = now >= garden.readyAt || garden.growthStage >= 1.0;

    if (!isReady) {
      return {
        success: false,
        error: 'Plant is not ready to harvest yet'
      };
    }

    const speciesData = PLANT_SPECIES[garden.species];
    const items = speciesData.yields;

    state.gardens.splice(gardenIndex, 1);

    return {
      success: true,
      state: state,
      items: items
    };
  }

  function handleCraft(msg, state) {
    const recipeName = msg.payload.recipe;

    if (!RECIPES[recipeName]) {
      return {
        success: false,
        error: 'Recipe not found'
      };
    }

    const recipe = RECIPES[recipeName];

    if (!state.players) {
      state.players = {};
    }
    if (!state.players[msg.from]) {
      state.players[msg.from] = {inventory: {}};
    }
    if (!state.players[msg.from].inventory) {
      state.players[msg.from].inventory = {};
    }

    const inventory = state.players[msg.from].inventory;

    for (const [material, quantity] of Object.entries(recipe.materials)) {
      if (!inventory[material] || inventory[material] < quantity) {
        return {
          success: false,
          error: `Insufficient materials: need ${quantity} ${material}`
        };
      }
    }

    for (const [material, quantity] of Object.entries(recipe.materials)) {
      inventory[material] -= quantity;
      if (inventory[material] === 0) {
        delete inventory[material];
      }
    }

    const producedItem = recipe.produces;
    if (!inventory[producedItem.type]) {
      inventory[producedItem.type] = 0;
    }
    inventory[producedItem.type] += producedItem.quantity;

    return {
      success: true,
      state: state,
      item: producedItem
    };
  }

  const COMPOSE_TYPES = {
    poem: { name: 'Poem', maxLength: 500, sparkReward: [5, 20] },
    poetry: { name: 'Poetry', maxLength: 500, sparkReward: [5, 20] },
    song: { name: 'Song', maxLength: 300, sparkReward: [10, 30] },
    story: { name: 'Short Story', maxLength: 1000, sparkReward: [10, 40] },
    painting: { name: 'Painting', sparkReward: [5, 25] },
    sculpture: { name: 'Sculpture', sparkReward: [10, 35] },
    mural: { name: 'Mural', sparkReward: [15, 50] }
  };

  function handleCompose(msg, state) {
    const medium = msg.payload.medium || msg.payload.composeType || 'poem';
    const title = msg.payload.title || 'Untitled';
    const content = msg.payload.content || '';

    if (!COMPOSE_TYPES[medium]) {
      return {
        success: false,
        error: 'Invalid compose type'
      };
    }

    const typeData = COMPOSE_TYPES[medium];

    if (typeData.maxLength && content.length > typeData.maxLength) {
      return {
        success: false,
        error: 'Content exceeds maximum length of ' + typeData.maxLength + ' characters'
      };
    }

    const composition = {
      id: generateId(),
      creator: msg.from,
      type: 'composition',
      medium: medium,
      title: title,
      content: content,
      zone: msg.payload.zone || 'default',
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      ts: Date.now(),
      likes: 0,
      featured: false,
      likedBy: []
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(composition);

    const sparkMin = typeData.sparkReward[0];
    const sparkMax = typeData.sparkReward[1];
    const sparkReward = Math.floor(sparkMin + Math.random() * (sparkMax - sparkMin));

    return {
      success: true,
      state: state,
      composition: composition,
      sparkReward: sparkReward
    };
  }

  function likeArtwork(artworkId, playerId, state) {
    if (!state.artworks) {
      return { success: false, error: 'No artworks found' };
    }

    const artwork = state.artworks.find(function(a) { return a.id === artworkId; });
    if (!artwork) {
      return { success: false, error: 'Artwork not found' };
    }

    if (!artwork.likedBy) {
      artwork.likedBy = [];
    }

    if (artwork.likedBy.indexOf(playerId) !== -1) {
      return { success: false, error: 'Already liked this artwork' };
    }

    artwork.likedBy.push(playerId);
    artwork.likes = artwork.likedBy.length;

    return {
      success: true,
      artwork: artwork,
      totalLikes: artwork.likes
    };
  }

  function getArtworks(state, zone) {
    if (!state.artworks) return [];

    return state.artworks.filter(function(a) {
      return !zone || a.zone === zone;
    });
  }

  function getArtworksByPlayer(state, playerId) {
    if (!state.artworks) return [];

    return state.artworks.filter(function(a) {
      return a.creator === playerId;
    });
  }

  function featureArtwork(artworkId, state) {
    if (!state.artworks) {
      return { success: false, error: 'No artworks found' };
    }

    const artwork = state.artworks.find(function(a) { return a.id === artworkId; });
    if (!artwork) {
      return { success: false, error: 'Artwork not found' };
    }

    state.artworks.forEach(function(a) {
      if (a.zone === artwork.zone && a.id !== artworkId) {
        a.featured = false;
      }
    });

    artwork.featured = true;

    return {
      success: true,
      artwork: artwork
    };
  }

  var PLOT_SIZE = 10; // 10x10 area
  var MAX_FURNITURE_PER_PLOT = 20;
  var HOUSING_ZONE = 'commons'; // Only Commons allows housing plots

  var PLOT_GRID = [];
  (function initPlotGrid() {
    var baseX = 140, baseZ = 170;
    for (var row = 0; row < 4; row++) {
      for (var col = 0; col < 5; col++) {
        PLOT_GRID.push({
          id: 'plot_' + row + '_' + col,
          x: baseX + col * (PLOT_SIZE + 4),
          z: baseZ + row * (PLOT_SIZE + 4),
          row: row,
          col: col
        });
      }
    }
  })();

  var playerPlots = {};

  var FURNITURE_TYPES = {
    bed: { name: 'Bed', icon: '&#128716;', cost: 25, description: 'A cozy place to rest' },
    table: { name: 'Table', icon: '&#128207;', cost: 15, description: 'A sturdy wooden table' },
    chair: { name: 'Chair', icon: '&#129681;', cost: 10, description: 'A comfortable chair' },
    bookshelf: { name: 'Bookshelf', icon: '&#128218;', cost: 30, description: 'Stores your favorite books' },
    lamp: { name: 'Lamp', icon: '&#128161;', cost: 12, description: 'Warm ambient light' },
    rug: { name: 'Rug', icon: '&#129531;', cost: 18, description: 'A decorative rug' },
    plant_pot: { name: 'Potted Plant', icon: '&#127793;', cost: 8, description: 'A cheerful houseplant' },
    fireplace: { name: 'Fireplace', icon: '&#128293;', cost: 40, description: 'Warm and inviting' },
    painting: { name: 'Painting', icon: '&#128444;', cost: 20, description: 'Art for your walls' },
    chest: { name: 'Storage Chest', icon: '&#128230;', cost: 22, description: 'Store your treasures' },
    fountain_small: { name: 'Small Fountain', icon: '&#9970;', cost: 35, description: 'A soothing water feature' },
    banner: { name: 'Banner', icon: '&#127988;', cost: 15, description: 'Show your colors' }
  };

  function getAvailablePlots() {
    var claimed = {};
    Object.keys(playerPlots).forEach(function(pid) {
      claimed[playerPlots[pid].plotId] = true;
    });
    return PLOT_GRID.filter(function(plot) {
      return !claimed[plot.id];
    });
  }

  function claimPlot(playerId, plotId, plotName) {
    if (playerPlots[playerId]) {
      return { success: false, error: 'You already have a plot. Release it first.' };
    }
    var plotDef = PLOT_GRID.find(function(p) { return p.id === plotId; });
    if (!plotDef) {
      return { success: false, error: 'Plot not found' };
    }
    var alreadyClaimed = Object.keys(playerPlots).some(function(pid) {
      return playerPlots[pid].plotId === plotId;
    });
    if (alreadyClaimed) {
      return { success: false, error: 'Plot already claimed by another player' };
    }

    playerPlots[playerId] = {
      plotId: plotId,
      name: plotName || playerId + "'s Plot",
      furniture: [],
      claimedAt: Date.now(),
      position: { x: plotDef.x, z: plotDef.z },
      size: PLOT_SIZE
    };
    return { success: true, plot: playerPlots[playerId] };
  }

  function getPlayerPlot(playerId) {
    return playerPlots[playerId] || null;
  }

  function placeFurniture(playerId, furnitureType, localX, localZ) {
    var plot = playerPlots[playerId];
    if (!plot) return { success: false, error: 'You don\'t have a plot' };
    if (!FURNITURE_TYPES[furnitureType]) return { success: false, error: 'Unknown furniture type' };
    if (plot.furniture.length >= MAX_FURNITURE_PER_PLOT) {
      return { success: false, error: 'Plot is full (max ' + MAX_FURNITURE_PER_PLOT + ' items)' };
    }
    localX = Math.max(0, Math.min(PLOT_SIZE - 1, localX || 0));
    localZ = Math.max(0, Math.min(PLOT_SIZE - 1, localZ || 0));

    var item = {
      id: 'furn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4),
      type: furnitureType,
      localX: localX,
      localZ: localZ,
      placedAt: Date.now()
    };
    plot.furniture.push(item);
    return { success: true, item: item, cost: FURNITURE_TYPES[furnitureType].cost };
  }

  function removeFurniture(playerId, furnitureId) {
    var plot = playerPlots[playerId];
    if (!plot) return { success: false, error: 'You don\'t have a plot' };
    var idx = plot.furniture.findIndex(function(f) { return f.id === furnitureId; });
    if (idx === -1) return { success: false, error: 'Furniture not found' };
    plot.furniture.splice(idx, 1);
    return { success: true };
  }

  function releasePlot(playerId) {
    if (!playerPlots[playerId]) return { success: false, error: 'You don\'t have a plot' };
    delete playerPlots[playerId];
    return { success: true };
  }

  function getPlotAtPosition(worldX, worldZ) {
    for (var pid in playerPlots) {
      var plot = playerPlots[pid];
      if (worldX >= plot.position.x && worldX <= plot.position.x + PLOT_SIZE &&
          worldZ >= plot.position.z && worldZ <= plot.position.z + PLOT_SIZE) {
        return { playerId: pid, plot: plot };
      }
    }
    return null;
  }

  function getAllPlots() {
    return playerPlots;
  }

  exports.PLANT_SPECIES = PLANT_SPECIES;
  exports.RECIPES = RECIPES;
  exports.STRUCTURE_TYPES = STRUCTURE_TYPES;
  exports.COMPOSE_TYPES = COMPOSE_TYPES;
  exports.handleBuild = handleBuild;
  exports.handlePlant = handlePlant;
  exports.handleHarvest = handleHarvest;
  exports.handleCraft = handleCraft;
  exports.handleCompose = handleCompose;
  exports.likeArtwork = likeArtwork;
  exports.getArtworks = getArtworks;
  exports.getArtworksByPlayer = getArtworksByPlayer;
  exports.featureArtwork = featureArtwork;
  exports.FURNITURE_TYPES = FURNITURE_TYPES;
  exports.PLOT_GRID = PLOT_GRID;
  exports.getAvailablePlots = getAvailablePlots;
  exports.claimPlot = claimPlot;
  exports.getPlayerPlot = getPlayerPlot;
  exports.placeFurniture = placeFurniture;
  exports.removeFurniture = removeFurniture;
  exports.releasePlot = releasePlot;
  exports.getPlotAtPosition = getPlotAtPosition;
  exports.getAllPlots = getAllPlots;

})(typeof module !== 'undefined' ? module.exports : (window.Creation = {}));


// quests.js

(function(exports) {
  'use strict';

  const QUEST_DATABASE = {
    quest_nexus_001: {
      id: 'quest_nexus_001',
      title: 'Welcome to ZION',
      description: 'Explore the Nexus and speak to 3 different citizens',
      giverNpcId: 'ai_citizen_001',
      type: 'social',
      objectives: [
        { type: 'talk_npcs', count: 3, current: 0 }
      ],
      rewards: { spark: 25, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Welcome, traveler! To truly understand ZION, you must connect with its people. Speak to three different citizens and learn their stories.",
        progress: "You've spoken with {current} citizens so far. Talk to {remaining} more.",
        complete: "Wonderful! You're beginning to understand what makes ZION special. Here's some Spark for your curiosity."
      },
      status: 'available'
    },

    quest_nexus_002: {
      id: 'quest_nexus_002',
      title: 'Journey Begins',
      description: 'Visit any 3 different zones in ZION',
      giverNpcId: 'ai_citizen_007',
      type: 'explore',
      objectives: [
        { type: 'visit_zones', zones: [], required: 3, current: 0 }
      ],
      rewards: { spark: 50, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: ['quest_nexus_001'],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "ZION is vast and full of wonders. Visit three different zones to broaden your horizons.",
        progress: "You've explored {current} zones. Discover {remaining} more!",
        complete: "Excellent exploration! Each zone has its own character. This Spark will fuel your continued journey."
      },
      status: 'available'
    },

    quest_gardens_001: {
      id: 'quest_gardens_001',
      title: 'The Gardener\'s Request',
      description: 'Gather 3 sunflowers for Willow the Gardener',
      giverNpcId: 'ai_citizen_013',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'sunflower', count: 3, current: 0 }
      ],
      rewards: { spark: 30, items: [{ id: 'rare_seed', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Hello traveler! My garden needs sunflowers. Could you gather 3 for me? They grow near the pond.",
        progress: "Still looking for those sunflowers? You need {remaining} more.",
        complete: "Wonderful! These are beautiful. Here, take this rare seed as thanks."
      },
      status: 'available'
    },

    quest_gardens_002: {
      id: 'quest_gardens_002',
      title: 'Moonflower Cultivation',
      description: 'Help plant 5 moonflower seeds in the Gardens',
      giverNpcId: 'ai_citizen_019',
      type: 'craft',
      objectives: [
        { type: 'plant', item: 'moonflower_seed', count: 5, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Moonflowers bloom only at night and bring tranquility to the Gardens. Will you help me plant 5 seeds?",
        progress: "You've planted {current} moonflower seeds. {remaining} more to go!",
        complete: "Perfect! In time, these will create a beautiful nighttime display. Thank you."
      },
      status: 'available'
    },

    quest_gardens_003: {
      id: 'quest_gardens_003',
      title: 'Herbal Remedy',
      description: 'Collect 4 healing herbs from the Gardens',
      giverNpcId: 'ai_citizen_025',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'healing_herb', count: 4, current: 0 }
      ],
      rewards: { spark: 35, items: [{ id: 'health_potion', count: 2 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "I'm preparing remedies for the community. Could you gather 4 healing herbs? They have purple flowers.",
        progress: "You have {current} herbs. I need {remaining} more for the remedy.",
        complete: "Excellent! These will help many people. Take these health potions for your troubles."
      },
      status: 'available'
    },

    quest_gardens_004: {
      id: 'quest_gardens_004',
      title: 'The Secret Garden',
      description: 'Find the hidden meditation spot in the Gardens',
      giverNpcId: 'ai_citizen_031',
      type: 'explore',
      objectives: [
        { type: 'discover', location: 'gardens_secret_spot', current: 0 }
      ],
      rewards: { spark: 60, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Deep within the Gardens lies a secret meditation spot. Few have found it. Will you seek it out?",
        progress: "Keep searching. Listen for the sound of wind chimes...",
        complete: "You found it! That place holds special energy. May it bring you peace."
      },
      status: 'available'
    },

    quest_gardens_005: {
      id: 'quest_gardens_005',
      title: 'Water the Wilds',
      description: 'Deliver water from the Gardens fountain to a Wilds gardener',
      giverNpcId: 'ai_citizen_037',
      type: 'deliver',
      objectives: [
        { type: 'deliver', item: 'water_bucket', npcId: 'ai_citizen_043', current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Our friends in the Wilds need fresh water from our fountain. Can you deliver this bucket to them?",
        progress: "The water is still fresh. Find the gardener in the Wilds!",
        complete: "Thank you! This water will help their wild gardens flourish."
      },
      status: 'available'
    },

    quest_wilds_001: {
      id: 'quest_wilds_001',
      title: 'Wild Observations',
      description: 'Observe 5 different wildlife species in the Wilds',
      giverNpcId: 'ai_citizen_043',
      type: 'explore',
      objectives: [
        { type: 'observe', category: 'wildlife', count: 5, current: 0 }
      ],
      rewards: { spark: 50, items: [{ id: 'field_journal', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The Wilds are teeming with life! Observe 5 different species and document your findings.",
        progress: "You've observed {current} species. {remaining} more to discover!",
        complete: "Fascinating observations! Take this field journal to record your future discoveries."
      },
      status: 'available'
    },

    quest_wilds_002: {
      id: 'quest_wilds_002',
      title: 'Rare Resource Hunt',
      description: 'Find 2 pieces of rare amber in the Wilds',
      giverNpcId: 'ai_citizen_049',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'wild_amber', count: 2, current: 0 }
      ],
      rewards: { spark: 70, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Ancient amber can be found in the deepest parts of the Wilds. Bring me 2 pieces - they're invaluable!",
        progress: "Amber is rare. You have {current}, need {remaining} more.",
        complete: "Incredible! This amber is perfect. Your effort is greatly appreciated."
      },
      status: 'available'
    },

    quest_wilds_003: {
      id: 'quest_wilds_003',
      title: 'Trail Blazer',
      description: 'Mark 3 new trail markers in unexplored areas',
      giverNpcId: 'ai_citizen_055',
      type: 'explore',
      objectives: [
        { type: 'place_marker', count: 3, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Help expand our trail network! Place 3 markers in unexplored areas of the Wilds.",
        progress: "You've placed {current} markers. {remaining} more needed!",
        complete: "Excellent work! These trails will help many travelers."
      },
      status: 'available'
    },

    quest_wilds_004: {
      id: 'quest_wilds_004',
      title: 'Ecosystem Balance',
      description: 'Help maintain balance by planting 6 native seeds',
      giverNpcId: 'ai_citizen_061',
      type: 'craft',
      objectives: [
        { type: 'plant', item: 'native_seed', count: 6, current: 0 }
      ],
      rewards: { spark: 65, items: [{ id: 'nature_compass', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The Wilds ecosystem needs our care. Plant 6 native seeds to restore balance.",
        progress: "You've planted {current} seeds. The ecosystem needs {remaining} more.",
        complete: "Perfect! Nature thanks you. Take this compass - it attunes to natural energy."
      },
      status: 'available'
    },

    quest_athenaeum_001: {
      id: 'quest_athenaeum_001',
      title: 'Knowledge Seeker',
      description: 'Read 3 different scrolls in the Athenaeum',
      giverNpcId: 'ai_citizen_067',
      type: 'social',
      objectives: [
        { type: 'read', item: 'scroll', count: 3, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Knowledge is power. Read 3 different scrolls from our collection to expand your understanding.",
        progress: "You've read {current} scrolls. {remaining} more await your eyes.",
        complete: "Excellent! Knowledge shared is knowledge multiplied. Well done."
      },
      status: 'available'
    },

    quest_athenaeum_002: {
      id: 'quest_athenaeum_002',
      title: 'The Scholar\'s Circle',
      description: 'Speak with 4 scholars to gather ancient wisdom',
      giverNpcId: 'ai_citizen_073',
      type: 'social',
      objectives: [
        { type: 'talk_scholars', count: 4, current: 0 }
      ],
      rewards: { spark: 50, items: [{ id: 'wisdom_tome', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The scholars here each hold unique wisdom. Speak with 4 of them to broaden your perspective.",
        progress: "You've consulted {current} scholars. Seek out {remaining} more.",
        complete: "Wonderful! You've gathered great wisdom. This tome will serve you well."
      },
      status: 'available'
    },

    quest_athenaeum_003: {
      id: 'quest_athenaeum_003',
      title: 'Lost Manuscript',
      description: 'Find the lost manuscript hidden somewhere in the Athenaeum',
      giverNpcId: 'ai_citizen_079',
      type: 'explore',
      objectives: [
        { type: 'discover', location: 'athenaeum_manuscript', current: 0 }
      ],
      rewards: { spark: 80, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "A valuable manuscript was misplaced generations ago. Can you find it? Check between the oldest shelves.",
        progress: "The manuscript is still out there. Keep searching the archives...",
        complete: "You found it! This is priceless. Thank you for preserving our history."
      },
      status: 'available'
    },

    quest_studio_001: {
      id: 'quest_studio_001',
      title: 'Artist\'s First Brush',
      description: 'Create your first artwork in the Studio',
      giverNpcId: 'ai_citizen_085',
      type: 'craft',
      objectives: [
        { type: 'create', item: 'artwork', count: 1, current: 0 }
      ],
      rewards: { spark: 35, items: [{ id: 'paint_set', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Everyone has creativity within them. Create your first artwork here in the Studio!",
        progress: "Let your imagination flow. Your first artwork awaits creation!",
        complete: "Beautiful! Art is a journey. This paint set will help you continue yours."
      },
      status: 'available'
    },

    quest_studio_002: {
      id: 'quest_studio_002',
      title: 'Musical Composition',
      description: 'Compose a piece of music with 3 instruments',
      giverNpcId: 'ai_citizen_091',
      type: 'craft',
      objectives: [
        { type: 'compose', instruments: 3, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Music speaks what words cannot. Compose a piece using at least 3 different instruments!",
        progress: "You've incorporated {current} instruments. Add {remaining} more!",
        complete: "Magnificent! Your music adds beauty to ZION. Keep composing!"
      },
      status: 'available'
    },

    quest_studio_003: {
      id: 'quest_studio_003',
      title: 'The Collaborative Mural',
      description: 'Contribute to the community mural with 5 brush strokes',
      giverNpcId: 'ai_citizen_097',
      type: 'craft',
      objectives: [
        { type: 'paint_mural', count: 5, current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The community mural represents all of us. Add your 5 brush strokes to become part of ZION's story!",
        progress: "You've added {current} strokes. {remaining} more will complete your contribution!",
        complete: "Perfect! Your marks are now part of our shared legacy. Thank you."
      },
      status: 'available'
    },

    quest_agora_001: {
      id: 'quest_agora_001',
      title: 'Market Day Delivery',
      description: 'Deliver goods to 3 different merchants in the Agora',
      giverNpcId: 'ai_citizen_003',
      type: 'deliver',
      objectives: [
        { type: 'deliver_merchants', count: 3, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Market day is busy! Can you deliver these packages to 3 different merchants for me?",
        progress: "You've delivered to {current} merchants. {remaining} more to go!",
        complete: "Wonderful! You've helped keep commerce flowing. Thank you!"
      },
      status: 'available'
    },

    quest_agora_002: {
      id: 'quest_agora_002',
      title: 'The Trading Game',
      description: 'Complete 2 successful trades with other players',
      giverNpcId: 'ai_citizen_009',
      type: 'social',
      objectives: [
        { type: 'trade', count: 2, current: 0 }
      ],
      rewards: { spark: 60, items: [{ id: 'merchant_badge', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Trade is the foundation of community. Complete 2 successful trades with others!",
        progress: "You've completed {current} trades. {remaining} more to go!",
        complete: "Excellent trading! Take this merchant badge as recognition of your skills."
      },
      status: 'available'
    },

    quest_agora_003: {
      id: 'quest_agora_003',
      title: 'Supply and Demand',
      description: 'Gather market data by speaking to 5 merchants',
      giverNpcId: 'ai_citizen_015',
      type: 'social',
      objectives: [
        { type: 'talk_merchants', count: 5, current: 0 }
      ],
      rewards: { spark: 50, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Help me understand the market! Speak with 5 merchants about their current needs.",
        progress: "You've surveyed {current} merchants. {remaining} more to survey!",
        complete: "Perfect data! This will help optimize our market. Thank you!"
      },
      status: 'available'
    },

    quest_commons_001: {
      id: 'quest_commons_001',
      title: 'Community Building',
      description: 'Contribute 5 building materials to the Commons project',
      giverNpcId: 'ai_citizen_021',
      type: 'gather',
      objectives: [
        { type: 'contribute', item: 'building_material', count: 5, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "We're building something wonderful for everyone! Contribute 5 building materials to help!",
        progress: "You've contributed {current} materials. We need {remaining} more!",
        complete: "Thank you! Your contribution makes our community stronger!"
      },
      status: 'available'
    },

    quest_commons_002: {
      id: 'quest_commons_002',
      title: 'The Gathering',
      description: 'Attend a community gathering with at least 3 other players',
      giverNpcId: 'ai_citizen_027',
      type: 'social',
      objectives: [
        { type: 'attend_gathering', players: 3, current: 0 }
      ],
      rewards: { spark: 70, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Community is about togetherness. Join a gathering with at least 3 other people!",
        progress: "The gathering needs {remaining} more participants!",
        complete: "What a wonderful gathering! Community is our greatest strength."
      },
      status: 'available'
    },

    quest_commons_003: {
      id: 'quest_commons_003',
      title: 'Helping Hands',
      description: 'Help 4 different citizens with their daily tasks',
      giverNpcId: 'ai_citizen_033',
      type: 'social',
      objectives: [
        { type: 'help_citizens', count: 4, current: 0 }
      ],
      rewards: { spark: 65, items: [{ id: 'helper_ribbon', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Many people need assistance. Help 4 different citizens with their tasks!",
        progress: "You've helped {current} citizens. {remaining} more need your help!",
        complete: "You're a true helper! Wear this ribbon with pride."
      },
      status: 'available'
    },

    quest_arena_001: {
      id: 'quest_arena_001',
      title: 'Training Day',
      description: 'Complete 3 training exercises in the Arena',
      giverNpcId: 'ai_citizen_039',
      type: 'craft',
      objectives: [
        { type: 'train', count: 3, current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Physical and mental training keeps us sharp! Complete 3 training exercises!",
        progress: "You've completed {current} exercises. {remaining} more to go!",
        complete: "Well done! Regular training builds character and strength."
      },
      status: 'available'
    },

    quest_arena_002: {
      id: 'quest_arena_002',
      title: 'Champion\'s Path',
      description: 'Achieve a perfect score in an Arena challenge',
      giverNpcId: 'ai_citizen_045',
      type: 'craft',
      objectives: [
        { type: 'perfect_score', current: 0 }
      ],
      rewards: { spark: 100, items: [{ id: 'champion_medal', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: ['quest_arena_001'],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Only the dedicated achieve perfection. Score perfectly in an Arena challenge!",
        progress: "Perfection requires focus and practice. Keep training!",
        complete: "Incredible! You've achieved perfection. This medal marks your mastery."
      },
      status: 'available'
    }
  };

  const playerQuestStates = new Map(); // playerId -> { activeQuests: [], completedQuests: [], turnedInQuests: [] }
  const MAX_ACTIVE_QUESTS = 5;

  function initPlayerQuests(playerId) {
    if (!playerQuestStates.has(playerId)) {
      playerQuestStates.set(playerId, {
        activeQuests: [],
        completedQuests: [],
        turnedInQuests: []
      });
    }
  }

  function getAvailableQuests(playerId, playerData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const available = [];
    for (const questId in QUEST_DATABASE) {
      const quest = QUEST_DATABASE[questId];

      if (state.activeQuests.find(q => q.id === questId)) continue;
      if (!quest.repeatable && state.turnedInQuests.includes(questId)) continue;

      if (quest.requiredLevel > (playerData.level || 0)) continue;

      let prereqsMet = true;
      for (const prereqId of quest.prerequisiteQuests) {
        if (!state.turnedInQuests.includes(prereqId)) {
          prereqsMet = false;
          break;
        }
      }
      if (!prereqsMet) continue;

      available.push(Object.assign({}, quest));
    }

    return available;
  }

  function acceptQuest(playerId, questId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    if (!QUEST_DATABASE[questId]) {
      return { success: false, message: 'Quest not found' };
    }

    if (state.activeQuests.find(q => q.id === questId)) {
      return { success: false, message: 'Quest already active' };
    }

    if (state.activeQuests.length >= MAX_ACTIVE_QUESTS) {
      return { success: false, message: 'Too many active quests (max 5)' };
    }

    const quest = JSON.parse(JSON.stringify(QUEST_DATABASE[questId]));
    quest.status = 'active';
    quest.startTime = Date.now();

    state.activeQuests.push(quest);

    return { success: true, message: 'Quest accepted', quest: quest };
  }

  function updateQuestProgress(playerId, eventType, eventData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);
    const updatedQuests = [];

    for (const quest of state.activeQuests) {
      let questUpdated = false;

      for (const objective of quest.objectives) {
        let match = false;

        switch (objective.type) {
          case 'collect':
            match = eventType === 'collect' && eventData.item === objective.item;
            break;
          case 'talk_npcs':
          case 'talk_scholars':
          case 'talk_merchants':
            match = eventType === 'talk_npc';
            break;
          case 'visit_zones':
            match = eventType === 'visit_zone';
            if (match && !objective.zones.includes(eventData.zone)) {
              objective.zones.push(eventData.zone);
            }
            break;
          case 'deliver':
            match = eventType === 'deliver' && eventData.npcId === objective.npcId;
            break;
          case 'plant':
            match = eventType === 'plant' && eventData.item === objective.item;
            break;
          case 'create':
          case 'compose':
          case 'paint_mural':
          case 'train':
            match = eventType === objective.type;
            break;
          case 'trade':
            match = eventType === 'trade';
            break;
          case 'deliver_merchants':
            match = eventType === 'deliver_merchant';
            break;
          case 'contribute':
            match = eventType === 'contribute' && eventData.item === objective.item;
            break;
          case 'discover':
            match = eventType === 'discover' && eventData.location === objective.location;
            break;
          case 'observe':
            match = eventType === 'observe' && eventData.category === objective.category;
            break;
          case 'place_marker':
            match = eventType === 'place_marker';
            break;
          case 'read':
            match = eventType === 'read' && eventData.item === objective.item;
            break;
          case 'attend_gathering':
            match = eventType === 'attend_gathering';
            break;
          case 'help_citizens':
            match = eventType === 'help_citizen';
            break;
          case 'perfect_score':
            match = eventType === 'perfect_score';
            break;
        }

        if (match) {
          if (objective.type === 'visit_zones') {
            objective.current = objective.zones.length;
          } else {
            objective.current = Math.min(objective.current + (eventData.amount || 1), objective.count || 1);
          }
          questUpdated = true;
        }
      }

      if (questUpdated) {
        const allComplete = quest.objectives.every(obj => {
          if (obj.required !== undefined) return obj.current >= obj.required;
          if (obj.count !== undefined) return obj.current >= obj.count;
          return obj.current >= 1;
        });

        if (allComplete) {
          quest.status = 'complete';
          state.completedQuests.push(quest.id);
        }

        updatedQuests.push(quest);
      }
    }

    return updatedQuests;
  }

  function completeQuest(playerId, questId, gameState) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const questIndex = state.activeQuests.findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return { success: false, message: 'Quest not active' };
    }

    const quest = state.activeQuests[questIndex];

    if (quest.status !== 'complete') {
      return { success: false, message: 'Quest objectives not complete' };
    }

    if (quest.rewards.spark > 0 && gameState && window.Economy) {
      window.Economy.earnSpark(gameState, playerId, quest.rewards.spark);
    }

    const rewards = {
      spark: quest.rewards.spark,
      items: quest.rewards.items
    };

    if (!state.turnedInQuests.includes(questId)) {
      state.turnedInQuests.push(questId);
    }

    state.activeQuests.splice(questIndex, 1);

    return { success: true, rewards: rewards, quest: quest };
  }

  function getActiveQuests(playerId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);
    return state.activeQuests.slice();
  }

  function getQuestLog(playerId, playerData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    return {
      active: state.activeQuests.slice(),
      completed: state.completedQuests.slice(),
      available: getAvailableQuests(playerId, playerData || {})
    };
  }

  function getQuestDialogue(questId, status, quest) {
    const questTemplate = QUEST_DATABASE[questId];
    if (!questTemplate || !questTemplate.dialogue[status]) {
      return '';
    }

    let dialogue = questTemplate.dialogue[status];

    if (quest && status === 'progress') {
      const objective = quest.objectives[0]; // Use first objective for now
      if (objective) {
        const required = objective.required || objective.count || 1;
        const remaining = required - objective.current;
        dialogue = dialogue.replace('{current}', objective.current);
        dialogue = dialogue.replace('{remaining}', remaining);
      }
    }

    return dialogue;
  }

  function getNpcQuests(npcId, playerId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const npcQuests = [];

    for (const questId in QUEST_DATABASE) {
      const quest = QUEST_DATABASE[questId];
      if (quest.giverNpcId !== npcId) continue;

      const activeQuest = state.activeQuests.find(q => q.id === questId);
      if (activeQuest) {
        npcQuests.push({ quest: activeQuest, state: activeQuest.status });
        continue;
      }

      if (!quest.repeatable && state.turnedInQuests.includes(questId)) {
        continue; // Already completed, not repeatable
      }

      let available = true;
      for (const prereqId of quest.prerequisiteQuests) {
        if (!state.turnedInQuests.includes(prereqId)) {
          available = false;
          break;
        }
      }

      if (available) {
        npcQuests.push({ quest: Object.assign({}, quest), state: 'available' });
      }
    }

    return npcQuests;
  }

  function abandonQuest(playerId, questId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const questIndex = state.activeQuests.findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return { success: false, message: 'Quest not active' };
    }

    state.activeQuests.splice(questIndex, 1);
    return { success: true };
  }

  var DAILY_QUESTS = [
    {
      id: 'daily_social',
      title: 'Social Butterfly',
      description: 'Talk to 5 different NPCs today',
      objectives: [{ type: 'talk_npcs', count: 5, current: 0 }],
      rewards: { spark: 20, items: [] },
      dialogue: {
        offer: "Today's challenge: connect with 5 different citizens. Every conversation enriches ZION.",
        progress: "You've chatted with {current} NPCs. {remaining} more to go!",
        complete: "What a social day! Here's your daily Spark reward."
      }
    },
    {
      id: 'daily_explorer',
      title: 'Daily Explorer',
      description: 'Visit 4 different zones today',
      objectives: [{ type: 'visit_zones', zones: [], required: 4, current: 0 }],
      rewards: { spark: 25, items: [] },
      dialogue: {
        offer: "Stretch your legs! Visit 4 different zones to earn your daily exploration reward.",
        progress: "You've visited {current} zones. {remaining} more await!",
        complete: "A well-traveled day! The world rewards your curiosity."
      }
    },
    {
      id: 'daily_gatherer',
      title: 'Daily Harvest',
      description: 'Harvest 5 resources today',
      objectives: [{ type: 'collect', item: 'resource', count: 5, current: 0 }],
      rewards: { spark: 15, items: [] },
      dialogue: {
        offer: "The gardens are abundant today. Harvest 5 resources to earn your daily reward.",
        progress: "Harvested {current} of 5 resources.",
        complete: "A productive day! Nature provides for those who tend it."
      }
    },
    {
      id: 'daily_trader',
      title: 'Market Day',
      description: 'Complete 1 trade with another player',
      objectives: [{ type: 'trade', count: 1, current: 0 }],
      rewards: { spark: 30, items: [] },
      dialogue: {
        offer: "The Agora thrives on trade. Complete one trade today to keep the economy flowing.",
        progress: "You haven't traded yet today. Find a partner!",
        complete: "A fair trade benefits everyone. Well done, merchant!"
      }
    },
    {
      id: 'daily_crafter',
      title: 'Creative Day',
      description: 'Craft 2 items today',
      objectives: [{ type: 'craft', count: 2, current: 0 }],
      rewards: { spark: 20, items: [] },
      dialogue: {
        offer: "Creation is at the heart of ZION. Craft 2 items today to earn your reward.",
        progress: "Crafted {current} of 2 items.",
        complete: "Your hands have shaped the world today. Well crafted!"
      }
    },
    {
      id: 'daily_builder',
      title: 'Construction Day',
      description: 'Place 2 structures today',
      objectives: [{ type: 'build', count: 2, current: 0 }],
      rewards: { spark: 25, items: [] },
      dialogue: {
        offer: "The Commons could use some new structures. Place 2 buildings today.",
        progress: "Placed {current} of 2 structures.",
        complete: "Your buildings will stand as testament to today's work!"
      }
    },
    {
      id: 'daily_wanderer',
      title: 'Long Walk',
      description: 'Walk a total of 500 units today',
      objectives: [{ type: 'walk_distance', distance: 500, current: 0 }],
      rewards: { spark: 15, items: [] },
      dialogue: {
        offer: "Sometimes the journey matters more than the destination. Walk 500 units today.",
        progress: "You've walked {current} of 500 units.",
        complete: "Every step is a story. Well walked!"
      }
    }
  ];

  function getDailyQuests() {
    var now = new Date();
    var dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
    var dailies = [];
    for (var i = 0; i < 3; i++) {
      var idx = (dayOfYear + i) % DAILY_QUESTS.length;
      var daily = JSON.parse(JSON.stringify(DAILY_QUESTS[idx]));
      daily.id = 'daily_' + dayOfYear + '_' + i;
      daily.type = 'daily';
      daily.repeatable = false;
      daily.requiredLevel = 0;
      daily.prerequisiteQuests = [];
      daily.timeLimit = 0;
      daily.giverNpcId = 'ai_citizen_001'; // Default quest giver
      daily.status = 'available';
      dailies.push(daily);
    }
    return dailies;
  }

  function isDailyCompleted(playerId, dailyId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    return state.turnedInQuests.indexOf(dailyId) !== -1;
  }

  var QUEST_CHAINS = {
    'chain_origins': {
      name: 'Origins of ZION',
      description: 'Discover the history of how ZION came to be',
      quests: ['quest_nexus_001', 'quest_nexus_002'],
      reward: { spark: 100, title: 'Historian' }
    },
    'chain_garden_master': {
      name: 'Garden Master',
      description: 'Complete all garden quests to earn the title of Garden Master',
      quests: ['quest_gardens_001', 'quest_gardens_002', 'quest_gardens_003', 'quest_gardens_004', 'quest_gardens_005'],
      reward: { spark: 150, title: 'Garden Master' }
    },
    'chain_scholar': {
      name: 'Scholar of the Athenaeum',
      description: 'Complete all knowledge quests',
      quests: ['quest_athenaeum_001', 'quest_athenaeum_002', 'quest_athenaeum_003'],
      reward: { spark: 120, title: 'Scholar' }
    },
    'chain_artisan': {
      name: 'Master Artisan',
      description: 'Complete all studio crafting quests',
      quests: ['quest_studio_001', 'quest_studio_002'],
      reward: { spark: 100, title: 'Artisan' }
    },
    'chain_explorer': {
      name: 'True Explorer',
      description: 'Visit every zone and complete all exploration quests',
      quests: ['quest_nexus_002', 'quest_wilds_001', 'quest_wilds_002', 'quest_wilds_003'],
      reward: { spark: 200, title: 'True Explorer' }
    }
  };

  function getChainProgress(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    var progress = {};

    for (var chainId in QUEST_CHAINS) {
      var chain = QUEST_CHAINS[chainId];
      var completed = 0;
      for (var i = 0; i < chain.quests.length; i++) {
        if (state.turnedInQuests.indexOf(chain.quests[i]) !== -1) {
          completed++;
        }
      }
      progress[chainId] = {
        name: chain.name,
        description: chain.description,
        completed: completed,
        total: chain.quests.length,
        isComplete: completed >= chain.quests.length,
        reward: chain.reward
      };
    }

    return progress;
  }

  function checkChainCompletion(playerId) {
    var progress = getChainProgress(playerId);
    var newlyCompleted = [];

    for (var chainId in progress) {
      var chain = progress[chainId];
      if (chain.isComplete) {
        initPlayerQuests(playerId);
        var state = playerQuestStates.get(playerId);
        if (!state.completedChains) state.completedChains = [];
        if (state.completedChains.indexOf(chainId) === -1) {
          state.completedChains.push(chainId);
          newlyCompleted.push({
            chainId: chainId,
            name: chain.name,
            reward: chain.reward
          });
        }
      }
    }

    return newlyCompleted;
  }

  function getPlayerQuestStats(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);

    return {
      activeQuests: state.activeQuests.length,
      completedQuests: state.turnedInQuests.length,
      totalAvailable: Object.keys(QUEST_DATABASE).length,
      completedChains: (state.completedChains || []).length,
      totalChains: Object.keys(QUEST_CHAINS).length,
      titles: (state.completedChains || []).map(function(chainId) {
        return QUEST_CHAINS[chainId] ? QUEST_CHAINS[chainId].reward.title : null;
      }).filter(Boolean)
    };
  }

  var ACHIEVEMENTS = {
    first_steps: { id: 'first_steps', name: 'First Steps', description: 'Enter ZION for the first time', icon: 'ðŸ‘£', category: 'exploration', sparkReward: 10 },
    zone_hopper: { id: 'zone_hopper', name: 'Zone Hopper', description: 'Visit 4 different zones', icon: 'ðŸš¶', category: 'exploration', sparkReward: 25 },
    world_traveler: { id: 'world_traveler', name: 'World Traveler', description: 'Visit all 8 zones', icon: 'ðŸŒ', category: 'exploration', sparkReward: 75 },
    trailblazer: { id: 'trailblazer', name: 'Trailblazer', description: 'Make 10 discoveries', icon: 'ðŸ”', category: 'exploration', sparkReward: 50 },
    cartographer: { id: 'cartographer', name: 'Cartographer', description: 'Make 25 discoveries', icon: 'ðŸ—ºï¸', category: 'exploration', sparkReward: 100 },

    friendly_face: { id: 'friendly_face', name: 'Friendly Face', description: 'Talk to 10 NPCs', icon: 'ðŸ˜Š', category: 'social', sparkReward: 15 },
    social_butterfly: { id: 'social_butterfly', name: 'Social Butterfly', description: 'Talk to 50 NPCs', icon: 'ðŸ¦‹', category: 'social', sparkReward: 40 },
    first_trade: { id: 'first_trade', name: 'First Trade', description: 'Complete your first trade', icon: 'ðŸ¤', category: 'social', sparkReward: 20 },
    merchant_prince: { id: 'merchant_prince', name: 'Merchant Prince', description: 'Complete 25 trades', icon: 'ðŸ‘‘', category: 'social', sparkReward: 75 },
    gift_giver: { id: 'gift_giver', name: 'Gift Giver', description: 'Gift an item to another player', icon: 'ðŸŽ', category: 'social', sparkReward: 15 },

    first_craft: { id: 'first_craft', name: 'First Craft', description: 'Craft your first item', icon: 'ðŸ”¨', category: 'crafting', sparkReward: 10 },
    apprentice_crafter: { id: 'apprentice_crafter', name: 'Apprentice Crafter', description: 'Craft 10 items', icon: 'âš’ï¸', category: 'crafting', sparkReward: 30 },
    master_crafter: { id: 'master_crafter', name: 'Master Crafter', description: 'Craft 50 items', icon: 'ðŸ› ï¸', category: 'crafting', sparkReward: 80 },
    potion_brewer: { id: 'potion_brewer', name: 'Potion Brewer', description: 'Brew 10 potions', icon: 'ðŸ§ª', category: 'crafting', sparkReward: 25 },
    instrument_maker: { id: 'instrument_maker', name: 'Instrument Maker', description: 'Craft a musical instrument', icon: 'ðŸŽµ', category: 'crafting', sparkReward: 20 },

    first_build: { id: 'first_build', name: 'First Build', description: 'Place your first structure', icon: 'ðŸ—ï¸', category: 'building', sparkReward: 10 },
    architect: { id: 'architect', name: 'Architect', description: 'Place 10 structures', icon: 'ðŸ›ï¸', category: 'building', sparkReward: 40 },
    city_planner: { id: 'city_planner', name: 'City Planner', description: 'Place 50 structures', icon: 'ðŸ™ï¸', category: 'building', sparkReward: 100 },

    green_thumb: { id: 'green_thumb', name: 'Green Thumb', description: 'Plant your first seed', icon: 'ðŸŒ±', category: 'gardening', sparkReward: 10 },
    gardener: { id: 'gardener', name: 'Gardener', description: 'Harvest 20 plants', icon: 'ðŸŒ»', category: 'gardening', sparkReward: 30 },
    botanist: { id: 'botanist', name: 'Botanist', description: 'Harvest 100 plants', icon: 'ðŸŒ¿', category: 'gardening', sparkReward: 80 },

    spark_saver: { id: 'spark_saver', name: 'Spark Saver', description: 'Accumulate 100 Spark', icon: 'âœ¨', category: 'economy', sparkReward: 10 },
    spark_hoarder: { id: 'spark_hoarder', name: 'Spark Hoarder', description: 'Accumulate 500 Spark', icon: 'ðŸ’°', category: 'economy', sparkReward: 25 },
    spark_magnate: { id: 'spark_magnate', name: 'Spark Magnate', description: 'Accumulate 2000 Spark', icon: 'ðŸ’Ž', category: 'economy', sparkReward: 75 },

    first_challenge: { id: 'first_challenge', name: 'First Challenge', description: 'Participate in your first competition', icon: 'âš”ï¸', category: 'competition', sparkReward: 15 },
    champion: { id: 'champion', name: 'Champion', description: 'Win 5 competitions', icon: 'ðŸ†', category: 'competition', sparkReward: 50 },

    quest_starter: { id: 'quest_starter', name: 'Quest Starter', description: 'Accept your first quest', icon: 'ðŸ“‹', category: 'quests', sparkReward: 5 },
    questmaster: { id: 'questmaster', name: 'Questmaster', description: 'Complete 10 quests', icon: 'ðŸ“œ', category: 'quests', sparkReward: 40 },
    completionist: { id: 'completionist', name: 'Completionist', description: 'Complete 25 quests', icon: 'â­', category: 'quests', sparkReward: 100 },
    chain_finisher: { id: 'chain_finisher', name: 'Chain Finisher', description: 'Complete a quest chain', icon: 'ðŸ”—', category: 'quests', sparkReward: 30 },

    guild_founder: { id: 'guild_founder', name: 'Guild Founder', description: 'Create a guild', icon: 'ðŸ°', category: 'guild', sparkReward: 25 },
    guild_member: { id: 'guild_member', name: 'Guild Member', description: 'Join a guild', icon: 'ðŸ¤œ', category: 'guild', sparkReward: 10 },

    first_artwork: { id: 'first_artwork', name: 'First Artwork', description: 'Create your first artwork', icon: 'ðŸŽ¨', category: 'art', sparkReward: 15 },
    prolific_artist: { id: 'prolific_artist', name: 'Prolific Artist', description: 'Create 10 artworks', icon: 'ðŸ–¼ï¸', category: 'art', sparkReward: 40 },

    sunwalker: { id: 'sunwalker', name: 'Sunwalker', description: 'Reach Sunwalker warmth tier', icon: 'â˜€ï¸', category: 'physical', sparkReward: 50 },

    first_lesson: { id: 'first_lesson', name: 'First Lesson', description: 'Complete a mentoring lesson', icon: 'ðŸ“š', category: 'mentoring', sparkReward: 15 },
    wise_mentor: { id: 'wise_mentor', name: 'Wise Mentor', description: 'Mentor 5 players', icon: 'ðŸŽ“', category: 'mentoring', sparkReward: 50 }
  };

  var playerAchievements = new Map(); // playerId -> { unlocked: Set, counters: {} }

  function initPlayerAchievements(playerId) {
    if (!playerAchievements.has(playerId)) {
      playerAchievements.set(playerId, {
        unlocked: new Set(),
        counters: {
          npcs_talked: 0,
          zones_visited: new Set(),
          trades_completed: 0,
          items_crafted: 0,
          potions_brewed: 0,
          structures_placed: 0,
          plants_harvested: 0,
          seeds_planted: 0,
          discoveries_made: 0,
          competitions_entered: 0,
          competitions_won: 0,
          quests_completed: 0,
          artworks_created: 0,
          players_mentored: 0,
          lessons_completed: 0,
          gifts_given: 0
        }
      });
    }
    return playerAchievements.get(playerId);
  }

  function trackAchievementEvent(playerId, eventType, eventData) {
    var state = initPlayerAchievements(playerId);
    eventData = eventData || {};

    switch (eventType) {
      case 'login':
        break; // first_steps checked separately
      case 'talk_npc':
        state.counters.npcs_talked++;
        break;
      case 'visit_zone':
        if (eventData.zone) state.counters.zones_visited.add(eventData.zone);
        break;
      case 'trade':
        state.counters.trades_completed++;
        break;
      case 'craft':
        state.counters.items_crafted++;
        if (eventData.category === 'potion') state.counters.potions_brewed++;
        break;
      case 'build':
        state.counters.structures_placed++;
        break;
      case 'harvest':
        state.counters.plants_harvested++;
        break;
      case 'plant':
        state.counters.seeds_planted++;
        break;
      case 'discover':
        state.counters.discoveries_made++;
        break;
      case 'competition_enter':
        state.counters.competitions_entered++;
        break;
      case 'competition_win':
        state.counters.competitions_won++;
        break;
      case 'quest_complete':
        state.counters.quests_completed++;
        break;
      case 'artwork':
        state.counters.artworks_created++;
        break;
      case 'mentor':
        state.counters.players_mentored++;
        break;
      case 'lesson':
        state.counters.lessons_completed++;
        break;
      case 'gift':
        state.counters.gifts_given++;
        break;
    }

    var newlyUnlocked = [];
    var checks = {
      first_steps: eventType === 'login',
      zone_hopper: state.counters.zones_visited.size >= 4,
      world_traveler: state.counters.zones_visited.size >= 8,
      trailblazer: state.counters.discoveries_made >= 10,
      cartographer: state.counters.discoveries_made >= 25,
      friendly_face: state.counters.npcs_talked >= 10,
      social_butterfly: state.counters.npcs_talked >= 50,
      first_trade: state.counters.trades_completed >= 1,
      merchant_prince: state.counters.trades_completed >= 25,
      gift_giver: state.counters.gifts_given >= 1,
      first_craft: state.counters.items_crafted >= 1,
      apprentice_crafter: state.counters.items_crafted >= 10,
      master_crafter: state.counters.items_crafted >= 50,
      potion_brewer: state.counters.potions_brewed >= 10,
      instrument_maker: eventType === 'craft' && eventData.category === 'instrument',
      first_build: state.counters.structures_placed >= 1,
      architect: state.counters.structures_placed >= 10,
      city_planner: state.counters.structures_placed >= 50,
      green_thumb: state.counters.seeds_planted >= 1,
      gardener: state.counters.plants_harvested >= 20,
      botanist: state.counters.plants_harvested >= 100,
      spark_saver: eventData.spark >= 100,
      spark_hoarder: eventData.spark >= 500,
      spark_magnate: eventData.spark >= 2000,
      first_challenge: state.counters.competitions_entered >= 1,
      champion: state.counters.competitions_won >= 5,
      quest_starter: state.counters.quests_completed >= 0 && eventType === 'quest_accept',
      questmaster: state.counters.quests_completed >= 10,
      completionist: state.counters.quests_completed >= 25,
      chain_finisher: eventType === 'chain_complete',
      guild_founder: eventType === 'guild_create',
      guild_member: eventType === 'guild_join',
      first_artwork: state.counters.artworks_created >= 1,
      prolific_artist: state.counters.artworks_created >= 10,
      sunwalker: eventType === 'warmth_tier' && eventData.tier === 'Sunwalker',
      first_lesson: state.counters.lessons_completed >= 1,
      wise_mentor: state.counters.players_mentored >= 5
    };

    for (var achId in checks) {
      if (checks[achId] && !state.unlocked.has(achId) && ACHIEVEMENTS[achId]) {
        state.unlocked.add(achId);
        newlyUnlocked.push(ACHIEVEMENTS[achId]);
      }
    }

    return newlyUnlocked;
  }

  function getAchievements(playerId) {
    var state = initPlayerAchievements(playerId);
    var result = [];

    for (var achId in ACHIEVEMENTS) {
      var ach = ACHIEVEMENTS[achId];
      result.push({
        id: ach.id,
        name: ach.name,
        description: ach.description,
        icon: ach.icon,
        category: ach.category,
        sparkReward: ach.sparkReward,
        unlocked: state.unlocked.has(achId)
      });
    }

    return result;
  }

  function getAchievementProgress(playerId) {
    var state = initPlayerAchievements(playerId);
    var total = Object.keys(ACHIEVEMENTS).length;
    var unlocked = state.unlocked.size;

    return {
      unlocked: unlocked,
      total: total,
      percentage: total > 0 ? Math.round((unlocked / total) * 100) : 0,
      counters: {
        npcs_talked: state.counters.npcs_talked,
        zones_visited: state.counters.zones_visited.size,
        trades_completed: state.counters.trades_completed,
        items_crafted: state.counters.items_crafted,
        structures_placed: state.counters.structures_placed,
        quests_completed: state.counters.quests_completed,
        discoveries_made: state.counters.discoveries_made
      }
    };
  }

  function getCompletedQuests(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    return state ? state.turnedInQuests : [];
  }

  exports.getCompletedQuests = getCompletedQuests;
  exports.getAvailableQuests = getAvailableQuests;
  exports.acceptQuest = acceptQuest;
  exports.updateQuestProgress = updateQuestProgress;
  exports.completeQuest = completeQuest;
  exports.getActiveQuests = getActiveQuests;
  exports.getQuestLog = getQuestLog;
  exports.getQuestDialogue = getQuestDialogue;
  exports.getNpcQuests = getNpcQuests;
  exports.abandonQuest = abandonQuest;
  exports.initPlayerQuests = initPlayerQuests;
  exports.getDailyQuests = getDailyQuests;
  exports.isDailyCompleted = isDailyCompleted;
  exports.getChainProgress = getChainProgress;
  exports.checkChainCompletion = checkChainCompletion;
  exports.getPlayerQuestStats = getPlayerQuestStats;
  exports.QUEST_CHAINS = QUEST_CHAINS;
  exports.DAILY_QUESTS = DAILY_QUESTS;
  exports.ACHIEVEMENTS = ACHIEVEMENTS;
  exports.trackAchievementEvent = trackAchievementEvent;
  exports.getAchievements = getAchievements;
  exports.getAchievementProgress = getAchievementProgress;
  exports.initPlayerAchievements = initPlayerAchievements;

})(typeof module !== 'undefined' ? module.exports : (window.Quests = {}));


// competition.js
(function(exports) {

  const COMPETITION_TYPES = ['duel', 'race', 'puzzle_race', 'build_contest', 'music_battle'];

  const pendingChallenges = {};

  const SPARK_AWARDS = {
    duel: 50,
    race: 30,
    puzzle_race: 40,
    build_contest: 100,
    music_battle: 60
  };

  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  function handleChallenge(msg, state, zoneRules) {
    if (!zoneRules.competition || !zoneRules.pvp) {
      return {
        success: false,
        error: 'Competition not allowed in this zone'
      };
    }

    const challengeType = msg.payload.type;
    if (!COMPETITION_TYPES.includes(challengeType)) {
      return {
        success: false,
        error: 'Invalid competition type'
      };
    }

    const challengeId = generateId();
    const challenge = {
      id: challengeId,
      challenger: msg.from,
      challenged: msg.payload.to,
      type: challengeType,
      rules: msg.payload.rules || {},
      ts: Date.now()
    };

    pendingChallenges[challengeId] = challenge;

    return {
      success: true,
      pendingChallenge: challenge
    };
  }

  function handleAcceptChallenge(msg, state) {
    const playerId = msg.from;

    let foundChallenge = null;
    let challengeId = null;

    for (const [id, challenge] of Object.entries(pendingChallenges)) {
      if (challenge.challenged === playerId) {
        foundChallenge = challenge;
        challengeId = id;
        break;
      }
    }

    if (!foundChallenge) {
      return {
        success: false,
        error: 'No pending challenge found'
      };
    }

    const competition = {
      id: generateId(),
      players: [foundChallenge.challenger, foundChallenge.challenged],
      type: foundChallenge.type,
      rules: foundChallenge.rules,
      startedAt: Date.now(),
      scores: {},
      status: 'active'
    };

    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(competition);

    delete pendingChallenges[challengeId];

    return {
      success: true,
      competition: competition,
      state: state
    };
  }

  function handleForfeit(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;

    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    const winner = competition.players.find(p => p !== playerId);

    competition.status = 'completed';
    competition.winner = winner;
    competition.endedAt = Date.now();
    competition.forfeitedBy = playerId;

    const sparkAward = SPARK_AWARDS[competition.type] || 20;

    return {
      success: true,
      state: state,
      winner: winner,
      sparkAward: sparkAward,
      competition: competition
    };
  }

  function handleScore(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;
    const score = msg.payload.score;

    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    competition.scores[playerId] = score;

    const allScored = competition.players.every(p =>
      competition.scores.hasOwnProperty(p)
    );

    let sparkAward = null;
    let winner = null;

    if (allScored) {
      const scores = competition.players.map(p => ({
        player: p,
        score: competition.scores[p]
      }));

      scores.sort((a, b) => b.score - a.score);
      winner = scores[0].player;

      competition.status = 'completed';
      competition.winner = winner;
      competition.endedAt = Date.now();

      sparkAward = SPARK_AWARDS[competition.type] || 20;
    }

    return {
      success: true,
      state: state,
      competition: competition,
      winner: winner,
      sparkAward: sparkAward
    };
  }

  function getPendingChallenges(playerId) {
    return Object.values(pendingChallenges).filter(c =>
      c.challenged === playerId || c.challenger === playerId
    );
  }

  var spectators = {}; // competitionId â†’ [playerIds]

  function joinAsSpectator(competitionId, playerId, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return { success: false, error: 'No competitions found' };
    }

    var competition = state.competitions.find(function(c) {
      return c.id === competitionId;
    });

    if (!competition) {
      return { success: false, error: 'Competition not found' };
    }

    if (competition.status !== 'active') {
      return { success: false, error: 'Competition is not active' };
    }

    if (!spectators[competitionId]) {
      spectators[competitionId] = [];
    }

    if (spectators[competitionId].indexOf(playerId) === -1) {
      spectators[competitionId].push(playerId);
    }

    return { success: true, competition: competition };
  }

  function leaveSpectator(competitionId, playerId) {
    if (!spectators[competitionId]) return;

    var index = spectators[competitionId].indexOf(playerId);
    if (index !== -1) {
      spectators[competitionId].splice(index, 1);
    }

    if (spectators[competitionId].length === 0) {
      delete spectators[competitionId];
    }
  }

  function getSpectators(competitionId) {
    return spectators[competitionId] || [];
  }

  function getActiveCompetitions(state) {
    if (!state.competitions || state.competitions.length === 0) {
      return [];
    }

    return state.competitions
      .filter(function(c) { return c.status === 'active'; })
      .map(function(c) {
        return {
          id: c.id,
          type: c.type,
          players: c.players,
          startedAt: c.startedAt,
          spectatorCount: spectators[c.id] ? spectators[c.id].length : 0
        };
      });
  }

  function broadcastToSpectators(competitionId, eventType, data) {
    var spectatorList = spectators[competitionId] || [];

    return {
      type: 'spectator_event',
      competitionId: competitionId,
      eventType: eventType,
      data: data,
      spectators: spectatorList,
      timestamp: Date.now()
    };
  }

  function getCompetitionLeaderboard(state) {
    if (!state.competitions || state.competitions.length === 0) {
      return [];
    }

    var playerStats = {};

    state.competitions
      .filter(function(c) { return c.status === 'completed'; })
      .forEach(function(comp) {
        comp.players.forEach(function(playerId) {
          if (!playerStats[playerId]) {
            playerStats[playerId] = { playerId: playerId, wins: 0, losses: 0, total: 0 };
          }

          if (comp.winner === playerId) {
            playerStats[playerId].wins++;
          } else {
            playerStats[playerId].losses++;
          }
          playerStats[playerId].total++;
        });
      });

    return Object.values(playerStats).sort(function(a, b) {
      return b.wins - a.wins;
    });
  }

  function createRace(organizerId, checkpoints, zone, state) {
    var raceId = generateId();
    var race = {
      id: raceId,
      type: 'race',
      organizer: organizerId,
      checkpoints: checkpoints,
      zone: zone,
      participants: [],
      progress: {}, // playerId â†’ { checkpointIndex, time }
      status: 'waiting',
      createdAt: Date.now()
    };

    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(race);

    return {
      success: true,
      race: race,
      state: state
    };
  }

  function checkRaceProgress(competitionId, playerId, position, state) {
    var CHECKPOINT_RADIUS = 5; // units â€” player must be within this distance to trigger a checkpoint

    if (!state || !state.competitions) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    var race = null;
    for (var i = 0; i < state.competitions.length; i++) {
      if (state.competitions[i].id === competitionId && state.competitions[i].type === 'race') {
        race = state.competitions[i];
        break;
      }
    }

    if (!race) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    if (race.status !== 'active') {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    if (race.participants.indexOf(playerId) === -1) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    if (!race.checkpoints || race.checkpoints.length === 0) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    if (!race.progress) {
      race.progress = {};
    }
    if (!race.progress[playerId]) {
      race.progress[playerId] = {
        checkpointIndex: 0,  // next checkpoint the player needs to reach
        startTime: Date.now(),
        time: 0,
        finished: false
      };
    }

    var playerProgress = race.progress[playerId];

    if (playerProgress.finished) {
      return {
        checkpointHit: false,
        finished: true,
        currentCheckpoint: playerProgress.checkpointIndex,
        time: playerProgress.time
      };
    }

    var nextIndex = playerProgress.checkpointIndex;
    if (nextIndex >= race.checkpoints.length) {
      return { checkpointHit: false, finished: false, currentCheckpoint: nextIndex, time: playerProgress.time };
    }

    var target = race.checkpoints[nextIndex];

    var dx = position.x - target.x;
    var dy = position.y - target.y;
    var dz = position.z - target.z;
    var distSquared = dx * dx + dy * dy + dz * dz;

    if (distSquared > CHECKPOINT_RADIUS * CHECKPOINT_RADIUS) {
      return {
        checkpointHit: false,
        finished: false,
        currentCheckpoint: nextIndex,
        time: Date.now() - playerProgress.startTime
      };
    }

    playerProgress.checkpointIndex = nextIndex + 1;
    var elapsed = Date.now() - playerProgress.startTime;
    playerProgress.time = elapsed;

    var finished = false;
    if (playerProgress.checkpointIndex >= race.checkpoints.length) {
      finished = true;
      playerProgress.finished = true;

      var allDone = true;
      for (var p = 0; p < race.participants.length; p++) {
        var pid = race.participants[p];
        if (!race.progress[pid] || !race.progress[pid].finished) {
          allDone = false;
          break;
        }
      }

      if (allDone) {
        race.status = 'completed';

        var bestTime = Infinity;
        var winner = null;
        for (var w = 0; w < race.participants.length; w++) {
          var wid = race.participants[w];
          if (race.progress[wid] && race.progress[wid].finished) {
            if (race.progress[wid].time < bestTime) {
              bestTime = race.progress[wid].time;
              winner = wid;
            }
          }
        }
        race.winner = winner;
        race.endedAt = Date.now();
      }
    }

    return {
      checkpointHit: true,
      finished: finished,
      currentCheckpoint: playerProgress.checkpointIndex,
      time: elapsed
    };
  }

  function getRaceStandings(competitionId, state) {
    if (!state.competitions) {
      return [];
    }

    var race = state.competitions.find(function(c) {
      return c.id === competitionId && c.type === 'race';
    });

    if (!race || !race.progress) {
      return [];
    }

    var standings = Object.keys(race.progress).map(function(playerId) {
      var progress = race.progress[playerId];
      return {
        playerId: playerId,
        checkpointIndex: progress.checkpointIndex || 0,
        time: progress.time || 0,
        finished: progress.finished || false
      };
    });

    standings.sort(function(a, b) {
      if (a.finished && !b.finished) return -1;
      if (!a.finished && b.finished) return 1;
      if (a.checkpointIndex !== b.checkpointIndex) {
        return b.checkpointIndex - a.checkpointIndex;
      }
      return a.time - b.time;
    });

    return standings;
  }

  exports.COMPETITION_TYPES = COMPETITION_TYPES;
  exports.SPARK_AWARDS = SPARK_AWARDS;
  exports.handleChallenge = handleChallenge;
  exports.handleAcceptChallenge = handleAcceptChallenge;
  exports.handleForfeit = handleForfeit;
  exports.handleScore = handleScore;
  exports.getPendingChallenges = getPendingChallenges;
  exports.joinAsSpectator = joinAsSpectator;
  exports.leaveSpectator = leaveSpectator;
  exports.getSpectators = getSpectators;
  exports.getActiveCompetitions = getActiveCompetitions;
  exports.broadcastToSpectators = broadcastToSpectators;
  exports.getCompetitionLeaderboard = getCompetitionLeaderboard;
  exports.createRace = createRace;
  exports.checkRaceProgress = checkRaceProgress;
  exports.getRaceStandings = getRaceStandings;

})(typeof module !== 'undefined' ? module.exports : (window.Competition = {}));


// exploration.js
(function(exports) {

  const DISCOVERY_TYPES = [
    'location', 'creature', 'artifact', 'secret',
    'landmark', 'ruin', 'cave', 'spring'
  ];

  const BASE_RARITY = {
    location: 0.3,
    creature: 0.5,
    artifact: 0.7,
    secret: 0.9,
    landmark: 0.2,
    ruin: 0.6,
    cave: 0.4,
    spring: 0.5
  };

  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  function calculateDistance(pos1, pos2) {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    const dz = pos1.z - pos2.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  function isDuplicate(playerId, position, state) {
    if (!state.discoveries || state.discoveries.length === 0) {
      return false;
    }

    for (const discovery of state.discoveries) {
      if (discovery.discoverer === playerId) {
        const distance = calculateDistance(position, discovery.position);
        if (distance <= 5) {
          return true;
        }
      }
    }

    return false;
  }

  function calculateRarity(type) {
    if (BASE_RARITY.hasOwnProperty(type)) {
      return BASE_RARITY[type];
    }
    return 0.3;
  }

  function handleDiscover(msg, state) {
    const position = msg.payload.position || {x: 0, y: 0, z: 0};
    const playerId = msg.from;

    if (isDuplicate(playerId, position, state)) {
      return {
        success: false,
        error: 'Already discovered'
      };
    }

    const discoveryType = msg.payload.type || 'location';
    if (!DISCOVERY_TYPES.includes(discoveryType)) {
      return {
        success: false,
        error: 'Invalid discovery type'
      };
    }

    let rarity = msg.payload.rarity;
    if (typeof rarity !== 'number' || rarity < 0 || rarity > 1) {
      rarity = calculateRarity(discoveryType);
    }

    const sparkAwarded = 5 + Math.floor(rarity * 20);

    const discovery = {
      id: generateId(),
      discoverer: playerId,
      type: discoveryType,
      description: msg.payload.description || '',
      position: position,
      zone: msg.payload.zone || 'default',
      ts: Date.now(),
      rarity: rarity
    };

    if (!state.discoveries) {
      state.discoveries = [];
    }

    state.discoveries.push(discovery);

    return {
      success: true,
      state: state,
      discovery: discovery,
      sparkAwarded: sparkAwarded
    };
  }

  function handleInspect(msg, state) {
    const targetId = msg.payload.target;

    if (!targetId) {
      return {
        success: false,
        error: 'No target specified'
      };
    }

    let info = null;
    let entityType = null;

    if (state.players && state.players[targetId]) {
      info = {
        type: 'player',
        id: targetId,
        data: state.players[targetId]
      };
      entityType = 'player';
    }

    if (!info && state.structures && state.structures.length > 0) {
      const structure = state.structures.find(s => s.id === targetId);
      if (structure) {
        info = {
          type: 'structure',
          id: targetId,
          data: structure
        };
        entityType = 'structure';
      }
    }

    if (!info && state.gardens && state.gardens.length > 0) {
      const garden = state.gardens.find(g => g.id === targetId);
      if (garden) {
        const now = Date.now();
        const elapsed = now - garden.plantedAt;
        const totalGrowthTime = garden.readyAt - garden.plantedAt;
        const currentGrowthStage = Math.min(1.0, elapsed / totalGrowthTime);

        info = {
          type: 'garden',
          id: targetId,
          data: {
            ...garden,
            currentGrowthStage: currentGrowthStage,
            isReady: now >= garden.readyAt
          }
        };
        entityType = 'garden';
      }
    }

    if (!info && state.discoveries && state.discoveries.length > 0) {
      const discovery = state.discoveries.find(d => d.id === targetId);
      if (discovery) {
        info = {
          type: 'discovery',
          id: targetId,
          data: discovery
        };
        entityType = 'discovery';
      }
    }

    if (!info) {
      return {
        success: false,
        error: 'Target not found'
      };
    }

    return {
      success: true,
      info: info
    };
  }

  function getDiscoveries(playerId, state) {
    if (!state || !state.discoveries) {
      return [];
    }

    return state.discoveries.filter(function(d) {
      return d.discoverer === playerId;
    }).map(function(d) {
      var rarityName = 'common';
      if (d.rarity >= 0.9) rarityName = 'legendary';
      else if (d.rarity >= 0.7) rarityName = 'epic';
      else if (d.rarity >= 0.5) rarityName = 'rare';
      else if (d.rarity >= 0.3) rarityName = 'uncommon';

      return {
        name: d.type.charAt(0).toUpperCase() + d.type.slice(1),
        description: d.description,
        zone: d.zone,
        rarity: rarityName,
        timestamp: d.ts
      };
    });
  }

  function getDiscoveredZones(playerId, state) {
    if (!state || !state.discoveries) {
      return ['default'];
    }

    var zones = {};
    state.discoveries.forEach(function(d) {
      if (d.discoverer === playerId) {
        zones[d.zone] = true;
      }
    });

    return Object.keys(zones);
  }

  var ZONE_SECRETS = {
    nexus: [
      { id: 'nexus_heart', name: 'Heart of the Nexus', type: 'secret', description: 'A pulsing crystal embedded in the ground at the world\'s center, humming with energy from all connected zones.', position: { x: 0, y: 0.5, z: 0 }, rarity: 0.8, loreId: 'lore_nexus_heart' },
      { id: 'nexus_echo', name: 'Echo Stone', type: 'artifact', description: 'A smooth stone that whispers the names of every player who has ever visited ZION.', position: { x: 15, y: 1, z: -10 }, rarity: 0.6, loreId: 'lore_echo_stone' },
      { id: 'nexus_sundial', name: 'Eternal Sundial', type: 'landmark', description: 'An ancient sundial that tracks not just time but the phases of ZION\'s day-night cycle.', position: { x: -8, y: 0, z: 12 }, rarity: 0.4, loreId: 'lore_sundial' }
    ],
    gardens: [
      { id: 'gardens_moonwell', name: 'Moonwell', type: 'spring', description: 'A hidden pool that glows silver at night, said to accelerate plant growth nearby.', position: { x: -20, y: 0, z: -25 }, rarity: 0.7, loreId: 'lore_moonwell' },
      { id: 'gardens_ancient_tree', name: 'The First Tree', type: 'landmark', description: 'The oldest tree in ZION, its trunk carved with symbols from the founding.', position: { x: 30, y: 0, z: 10 }, rarity: 0.5, loreId: 'lore_first_tree' },
      { id: 'gardens_fairy_ring', name: 'Fairy Ring', type: 'secret', description: 'A perfect circle of mushrooms that appears only at certain times.', position: { x: -5, y: 0, z: 35 }, rarity: 0.9, loreId: 'lore_fairy_ring' },
      { id: 'gardens_meditation', name: 'Meditation Hollow', type: 'location', description: 'A sheltered hollow where the ambient sounds of nature converge in perfect harmony.', position: { x: 18, y: -1, z: -30 }, rarity: 0.6, loreId: 'lore_meditation' }
    ],
    athenaeum: [
      { id: 'athenaeum_codex', name: 'The Lost Codex', type: 'artifact', description: 'A floating book whose pages contain knowledge from all federated worlds.', position: { x: -12, y: 3, z: -15 }, rarity: 0.9, loreId: 'lore_codex' },
      { id: 'athenaeum_orrery', name: 'Celestial Orrery', type: 'artifact', description: 'A mechanical model of the multiverse, with a tiny light for each federated world.', position: { x: 5, y: 2, z: 20 }, rarity: 0.8, loreId: 'lore_orrery' },
      { id: 'athenaeum_whispering', name: 'Whispering Stacks', type: 'secret', description: 'Deep in the shelves, the books murmur to each other, sharing fragments of lore.', position: { x: -25, y: 0, z: 8 }, rarity: 0.7, loreId: 'lore_whispering' }
    ],
    studio: [
      { id: 'studio_muse', name: 'The Muse\'s Corner', type: 'secret', description: 'A corner where inspiration strikes harder. Art created here always seems to resonate more.', position: { x: 10, y: 0, z: -18 }, rarity: 0.7, loreId: 'lore_muse' },
      { id: 'studio_palette', name: 'Living Palette', type: 'artifact', description: 'A palette whose colors shift with the seasons, mixing hues no artisan has seen before.', position: { x: -15, y: 1, z: 12 }, rarity: 0.8, loreId: 'lore_palette' },
      { id: 'studio_resonance', name: 'Resonance Chamber', type: 'cave', description: 'A natural acoustic chamber where even whispers become music.', position: { x: 22, y: -2, z: -5 }, rarity: 0.6, loreId: 'lore_resonance' }
    ],
    wilds: [
      { id: 'wilds_hollow', name: 'Starfall Hollow', type: 'cave', description: 'A cavern where fragments of starlight collect in luminous pools.', position: { x: -30, y: -3, z: -20 }, rarity: 0.9, loreId: 'lore_starfall' },
      { id: 'wilds_monolith', name: 'The Monolith', type: 'ruin', description: 'A towering black stone that predates ZION itself, covered in undecipherable glyphs.', position: { x: 35, y: 0, z: 25 }, rarity: 0.8, loreId: 'lore_monolith' },
      { id: 'wilds_grove', name: 'Singing Grove', type: 'location', description: 'Trees here sway in patterns that create hauntingly beautiful melodies.', position: { x: -10, y: 0, z: 30 }, rarity: 0.5, loreId: 'lore_singing_grove' },
      { id: 'wilds_fossil', name: 'Fossil Cliff', type: 'landmark', description: 'A cliff face embedded with fossils from creatures that never existed in our world.', position: { x: 20, y: 5, z: -35 }, rarity: 0.6, loreId: 'lore_fossil_cliff' },
      { id: 'wilds_spring', name: 'Hidden Hot Spring', type: 'spring', description: 'A natural hot spring tucked behind a waterfall, warm even in winter.', position: { x: -25, y: -1, z: -10 }, rarity: 0.7, loreId: 'lore_hot_spring' }
    ],
    agora: [
      { id: 'agora_vault', name: 'The Old Vault', type: 'ruin', description: 'Beneath the market, the remains of ZION\'s first bank, its vault door still ajar.', position: { x: 8, y: -2, z: -12 }, rarity: 0.7, loreId: 'lore_vault' },
      { id: 'agora_scales', name: 'Scales of Truth', type: 'artifact', description: 'Ancient merchant scales that glow when a fair trade is struck nearby.', position: { x: -10, y: 1, z: 5 }, rarity: 0.6, loreId: 'lore_scales' }
    ],
    commons: [
      { id: 'commons_bell', name: 'Community Bell', type: 'landmark', description: 'A large bell that was rung to call the first citizens of ZION together.', position: { x: 0, y: 3, z: 0 }, rarity: 0.4, loreId: 'lore_bell' },
      { id: 'commons_mosaic', name: 'Founders\' Mosaic', type: 'artifact', description: 'A floor mosaic depicting the founding of ZION, with space for new tiles from each generation.', position: { x: -15, y: 0, z: 15 }, rarity: 0.6, loreId: 'lore_mosaic' },
      { id: 'commons_time_capsule', name: 'Time Capsule', type: 'secret', description: 'Buried beneath the gathering circle, a capsule left by the founders with messages for the future.', position: { x: 5, y: -1, z: -8 }, rarity: 0.8, loreId: 'lore_time_capsule' }
    ],
    arena: [
      { id: 'arena_champions', name: 'Hall of Champions', type: 'ruin', description: 'Carved into the arena wall, the names and deeds of every champion who competed here.', position: { x: 20, y: 2, z: 0 }, rarity: 0.5, loreId: 'lore_champions' },
      { id: 'arena_flame', name: 'Eternal Flame', type: 'landmark', description: 'A flame that has burned since the arena was built, said to embody the spirit of competition.', position: { x: 0, y: 1, z: -20 }, rarity: 0.6, loreId: 'lore_flame' }
    ]
  };

  var LORE_ENTRIES = {
    lore_nexus_heart: {
      title: 'The Heart of ZION',
      text: 'Long before the first player set foot in ZION, the Heart was placed here â€” a crystal forged from the combined intentions of its creators. It pulses once for every soul currently inhabiting the world. Old-timers say that on quiet nights, you can feel it sync with your own heartbeat, as if the world itself is alive and breathing alongside you.',
      category: 'origins'
    },
    lore_echo_stone: {
      title: 'The Echo Stone',
      text: 'The Echo Stone remembers. Every name spoken near it is captured and preserved in its crystalline lattice. Some say if you press your ear to its surface and whisper a name, you can hear a faint echo of that person\'s first words in ZION. The stone grows infinitesimally larger with each new voice it records.',
      category: 'artifacts'
    },
    lore_sundial: {
      title: 'The Eternal Sundial',
      text: 'The Sundial was the first structure built in the Nexus, before even the portals were erected. It tracks the 24-minute day cycle and marks the seasons that shift each real-world week. At dawn, its shadow points toward the Gardens. At dusk, toward the Wilds. At the rare eclipse, it casts no shadow at all.',
      category: 'landmarks'
    },
    lore_moonwell: {
      title: 'The Moonwell',
      text: 'Hidden in the deepest grove of the Gardens lies the Moonwell, a pool of water that seems to capture and hold moonlight even after dawn. Gardeners discovered that plants watered from the Moonwell grow twice as fast, though they suspect this is less about the water and more about the attention the gardener pays in finding it.',
      category: 'nature'
    },
    lore_first_tree: {
      title: 'The First Tree',
      text: 'Before the Gardens were cultivated, before the zones were named, there was a single tree. The First Tree grew from a seed of intention planted by ZION\'s architects. Its roots extend beneath every zone, connecting the world in ways no map can show. The symbols carved in its trunk are the original protocol â€” the language that all of ZION\'s systems speak.',
      category: 'origins'
    },
    lore_fairy_ring: {
      title: 'The Fairy Ring',
      text: 'The Fairy Ring appears and disappears according to rules no scholar has fully deciphered. Some say it follows the moon cycle, others claim it responds to the emotional state of the world itself. Those who find it report a fleeting sense of profound connection to every other being in ZION â€” as if, for one moment, the boundaries between self and world dissolve.',
      category: 'mysteries'
    },
    lore_meditation: {
      title: 'The Meditation Hollow',
      text: 'In the Meditation Hollow, the sounds of nature converge in unexpected harmony â€” birdsong becomes melody, wind becomes rhythm, water becomes bass. Those who sit here long enough report achieving a rare clarity of purpose. It\'s said this was the spot where the intention system was first imagined.',
      category: 'nature'
    },
    lore_codex: {
      title: 'The Lost Codex',
      text: 'The Codex floats between shelves, never resting in one place. Its pages are blank to most, but to those who have visited federated worlds, text appears: knowledge from those distant lands. The more worlds you visit, the more pages reveal themselves. Scholars believe the Codex is less a book and more a living bridge between realities.',
      category: 'artifacts'
    },
    lore_orrery: {
      title: 'The Celestial Orrery',
      text: 'Built by the first scholars of the Athenaeum, the Orrery maps every federated world as a tiny point of light orbiting a central sun â€” ZION itself. New lights appear when new federations are forged, and they dim when connections grow quiet. It serves as both art and practical tool, allowing citizens to see the health of the multiverse at a glance.',
      category: 'artifacts'
    },
    lore_whispering: {
      title: 'The Whispering Stacks',
      text: 'Deep in the Athenaeum, where the oldest books reside, the air is thick with whispers. The books share knowledge among themselves when no one is looking, cross-referencing and updating their contents. Scholars who linger here too long report dreams filled with information they never consciously learned.',
      category: 'mysteries'
    },
    lore_muse: {
      title: 'The Muse\'s Corner',
      text: 'Every studio has its sweet spot, the place where creativity flows most freely. In ZION\'s Studio, that spot is marked by a slight warmth in the floor and a tendency for ambient sounds to harmonize. Artists who create here often surprise themselves with the results. Is it magic, or simply the power of expectation? The Muse keeps her secrets.',
      category: 'art'
    },
    lore_palette: {
      title: 'The Living Palette',
      text: 'The Palette was not crafted but grown â€” crystallized from the combined creative energy of ZION\'s first artists. Its colors are alive: they deepen in autumn, brighten in spring, glow warmly in winter, and shimmer like water in summer. Art created with its pigments is said to evoke emotions in viewers that no ordinary color can.',
      category: 'artifacts'
    },
    lore_resonance: {
      title: 'The Resonance Chamber',
      text: 'Beneath the Studio lies a natural cavern with perfect acoustics. Sound enters and emerges transformed â€” whispers become symphonies, footsteps become percussion, breath becomes wind instruments. Musicians gather here to compose pieces that could never exist in the above-ground world. The Chamber doesn\'t amplify sound; it reveals its hidden depth.',
      category: 'nature'
    },
    lore_starfall: {
      title: 'Starfall Hollow',
      text: 'When the procedural stars of ZION\'s sky occasionally flicker and fall, their light doesn\'t vanish â€” it collects in pools deep within Starfall Hollow. The luminous pools cast impossible shadows that move independently of light sources. Explorers have reported seeing brief visions of other worlds reflected in the starlight pools.',
      category: 'mysteries'
    },
    lore_monolith: {
      title: 'The Monolith',
      text: 'The Monolith stands as a reminder that not everything in ZION was placed there by its creators. It appeared one day, unannounced, and no log records its creation. Its glyphs resist translation â€” they seem to shift when observed directly. Some theorize it\'s a message from a parallel ZION, a fork that found a way to communicate across the multiverse gap.',
      category: 'mysteries'
    },
    lore_singing_grove: {
      title: 'The Singing Grove',
      text: 'The trees of the Singing Grove have grown in a pattern that channels wind into music. Each season brings a different key, and the melody changes with the weather. During storms, the grove produces sounds that can only be described as the world singing itself to sleep. Wildlife gathers here during these concerts, unbothered by the presence of visitors.',
      category: 'nature'
    },
    lore_fossil_cliff: {
      title: 'The Fossil Cliff',
      text: 'The fossils in this cliff belong to creatures that exist in no biological record. Wings with too many segments, shells that spiral in mathematically impossible patterns, teeth that seem designed for eating light itself. Scholars debate whether these are remnants of an earlier version of ZION, or dreams that somehow calcified into stone.',
      category: 'mysteries'
    },
    lore_hot_spring: {
      title: 'The Hidden Hot Spring',
      text: 'Tucked behind a waterfall that reveals itself only to those who approach from the right angle, the Hot Spring maintains a perfect temperature regardless of season. Its waters carry a faint mineral glow. Visitors leave feeling restored, though whether this is the water\'s doing or simply the peace of discovering a hidden place is debated.',
      category: 'nature'
    },
    lore_vault: {
      title: 'The Old Vault',
      text: 'Beneath the bustling Agora lies the Old Vault â€” ZION\'s first attempt at a central bank, abandoned when the community chose a distributed ledger instead. The vault door is still ajar, revealing a room lined with empty shelves. A plaque on the wall reads: "The true wealth of ZION cannot be stored in a single place."',
      category: 'history'
    },
    lore_scales: {
      title: 'The Scales of Truth',
      text: 'The Scales were a gift from the merchants of early ZION, imbued with a simple enchantment: they glow golden when a fair trade is completed nearby. In a world where the protocol enforces honest transactions, the Scales serve more as a celebration than a safeguard. Their gentle light is a reminder that fairness feels good.',
      category: 'artifacts'
    },
    lore_bell: {
      title: 'The Community Bell',
      text: 'The Bell was rung to gather the first hundred citizens of ZION â€” the founding AI agents who would give the world its initial life. It rang once for each of them, one hundred clear notes that still echo in the architecture of the Commons. Now it rings for every community event, its tone slightly different each time, as if greeting each gathering uniquely.',
      category: 'history'
    },
    lore_mosaic: {
      title: 'The Founders\' Mosaic',
      text: 'The mosaic in the Commons floor tells the story of ZION\'s founding in tiny colored tiles. At the center, a burst of golden Spark radiating outward. Around it, the eight zones taking shape from formless possibility. At the edges, blank space â€” room for new tiles that each generation of citizens adds. Finding your own tile is a rite of passage.',
      category: 'history'
    },
    lore_time_capsule: {
      title: 'The Time Capsule',
      text: 'Buried beneath the gathering circle is a capsule containing the original vision documents for ZION â€” the hopes and principles its creators encoded before the first line of code was written. The capsule is sealed but not locked; anyone can open it. Inside, alongside the documents, is a simple note: "Build kindly."',
      category: 'origins'
    },
    lore_champions: {
      title: 'The Hall of Champions',
      text: 'The Arena wall bears the names of all who have competed with honor. Not just winners â€” every participant who showed sportsmanship, creativity, or grace under pressure. The Hall reminds visitors that competition in ZION is not about domination but about pushing each other to grow. Below the names runs a single line: "The only defeat is refusing to play."',
      category: 'history'
    },
    lore_flame: {
      title: 'The Eternal Flame',
      text: 'The Eternal Flame burns without fuel, its light neither hot nor cold but somehow both warming and invigorating. It was lit at the Arena\'s inauguration and has never gone out. Competitors who pass the flame before a challenge report feeling calmer and more focused, as if the flame absorbs anxiety and returns resolve.',
      category: 'landmarks'
    }
  };

  function getZoneSecrets(zoneId) {
    return ZONE_SECRETS[zoneId] || [];
  }

  function checkNearbySecrets(playerId, position, zoneId, state) {
    var secrets = ZONE_SECRETS[zoneId];
    if (!secrets) return null;

    for (var i = 0; i < secrets.length; i++) {
      var secret = secrets[i];
      var dist = calculateDistance(position, secret.position);

      if (dist <= 8) {
        var alreadyFound = false;
        if (state.discoveries) {
          for (var j = 0; j < state.discoveries.length; j++) {
            if (state.discoveries[j].discoverer === playerId && state.discoveries[j].secretId === secret.id) {
              alreadyFound = true;
              break;
            }
          }
        }

        if (!alreadyFound) {
          return secret;
        }
      }
    }

    return null;
  }

  function discoverSecret(playerId, secret, state) {
    if (!state.discoveries) state.discoveries = [];

    var sparkAwarded = 5 + Math.floor(secret.rarity * 30); // Higher rewards for secrets

    var discovery = {
      id: generateId(),
      secretId: secret.id,
      discoverer: playerId,
      type: secret.type,
      name: secret.name,
      description: secret.description,
      position: secret.position,
      zone: secret.position.zone || 'unknown',
      ts: Date.now(),
      rarity: secret.rarity,
      loreId: secret.loreId
    };

    state.discoveries.push(discovery);

    return {
      success: true,
      discovery: discovery,
      sparkAwarded: sparkAwarded,
      lore: secret.loreId ? LORE_ENTRIES[secret.loreId] : null
    };
  }

  function getLoreEntry(loreId) {
    return LORE_ENTRIES[loreId] || null;
  }

  function getUnlockedLore(playerId, state) {
    if (!state.discoveries) return [];

    var loreIds = new Set();
    state.discoveries.forEach(function(d) {
      if (d.discoverer === playerId && d.loreId) {
        loreIds.add(d.loreId);
      }
    });

    var result = [];
    loreIds.forEach(function(loreId) {
      var entry = LORE_ENTRIES[loreId];
      if (entry) {
        result.push({
          id: loreId,
          title: entry.title,
          text: entry.text,
          category: entry.category
        });
      }
    });

    return result;
  }

  function getLoreCategories() {
    var cats = {};
    for (var loreId in LORE_ENTRIES) {
      var cat = LORE_ENTRIES[loreId].category;
      cats[cat] = (cats[cat] || 0) + 1;
    }
    return cats;
  }

  exports.DISCOVERY_TYPES = DISCOVERY_TYPES;
  exports.BASE_RARITY = BASE_RARITY;
  exports.handleDiscover = handleDiscover;
  exports.handleInspect = handleInspect;
  exports.isDuplicate = isDuplicate;
  exports.calculateRarity = calculateRarity;
  exports.getDiscoveries = getDiscoveries;
  exports.getDiscoveredZones = getDiscoveredZones;
  exports.ZONE_SECRETS = ZONE_SECRETS;
  exports.LORE_ENTRIES = LORE_ENTRIES;
  exports.getZoneSecrets = getZoneSecrets;
  exports.checkNearbySecrets = checkNearbySecrets;
  exports.discoverSecret = discoverSecret;
  exports.getLoreEntry = getLoreEntry;
  exports.getUnlockedLore = getUnlockedLore;
  exports.getLoreCategories = getLoreCategories;

})(typeof module !== 'undefined' ? module.exports : (window.Exploration = {}));


// anchors.js
(function(exports) {
  'use strict';

  var TYPES = {
    ZONE_PORTAL:     'zone_portal',      // Real location â†’ ZION zone entry
    RESOURCE_NODE:   'resource_node',    // Real location â†’ harvestable resources
    DISCOVERY_POINT: 'discovery_point',  // Real location â†’ lore/secrets/items
    GATHERING_SPOT:  'gathering_spot',   // Real location â†’ social meetup
    GARDEN_PLOT:     'garden_plot'       // Real location â†’ player garden
  };

  var VALID_TYPES = [
    'zone_portal', 'resource_node', 'discovery_point',
    'gathering_spot', 'garden_plot'
  ];

  var VALID_ZONES = [
    'nexus', 'gardens', 'athenaeum', 'studio',
    'wilds', 'agora', 'commons', 'arena'
  ];

  var EARTH_RADIUS_M = 6371000;

  var DEFAULT_RANGE_M = 50;

  var WALKING_SPEED_MAX_KMH = 10;  // < 10 km/h = walking
  var DRIVING_SPEED_MIN_KMH = 25;  // >= 25 km/h = driving â†’ pause AR

  var WARMTH_POINTS_MAX = 5;               // Max warmth per session
  var WARMTH_HARVEST_MAX_BONUS = 0.10;     // Max 10% harvest bonus
  var WARMTH_DISCOVERY_MAX_BONUS = 0.15;   // Max 15% discovery rate bonus

  var PROTOCOL_VERSION = 1;

  function generateId() {
    return 'anc_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
  }

  function generateMsgId() {
    return 'msg_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
  }

  function nowISO() {
    return new Date().toISOString();
  }

  function getDistance(lat1, lon1, lat2, lon2) {
    var toRad = function(deg) { return deg * Math.PI / 180; };

    var dLat = toRad(lat2 - lat1);
    var dLon = toRad(lon2 - lon1);

    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);

    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS_M * c;
  }

  function isWalkingSpeed(speedKmh) {
    if (typeof speedKmh !== 'number' || speedKmh < 0) return false;
    return speedKmh < WALKING_SPEED_MAX_KMH;
  }

  function isDrivingSpeed(speedKmh) {
    if (typeof speedKmh !== 'number') return false;
    return speedKmh >= DRIVING_SPEED_MIN_KMH;
  }

  function requestLocation(callback, errorCallback) {
    if (typeof navigator === 'undefined' || !navigator.geolocation) {
      if (typeof errorCallback === 'function') {
        errorCallback({ code: -1, message: 'Geolocation not available' });
      }
      return;
    }

    navigator.geolocation.getCurrentPosition(
      function(position) {
        if (typeof callback === 'function') {
          callback({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            speed: position.coords.speed || 0,
            accuracy: position.coords.accuracy || null
          });
        }
      },
      function(err) {
        if (typeof errorCallback === 'function') {
          errorCallback(err);
        }
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 }
    );
  }

  function watchLocation(callback, errorCallback) {
    if (typeof navigator === 'undefined' || !navigator.geolocation) {
      if (typeof errorCallback === 'function') {
        errorCallback({ code: -1, message: 'Geolocation not available' });
      }
      return null;
    }

    return navigator.geolocation.watchPosition(
      function(position) {
        if (typeof callback === 'function') {
          callback({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            speed: position.coords.speed || 0,
            accuracy: position.coords.accuracy || null
          });
        }
      },
      function(err) {
        if (typeof errorCallback === 'function') {
          errorCallback(err);
        }
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 5000 }
    );
  }

  function stopWatching(watchId) {
    if (typeof navigator !== 'undefined' && navigator.geolocation &&
        typeof navigator.geolocation.clearWatch === 'function') {
      navigator.geolocation.clearWatch(watchId);
    }
  }

  function create(type, geoPosition, zoneMapping, description, from) {
    var anchorId = generateId();
    var now = nowISO();

    var anchor = {
      id: anchorId,
      type: type,
      geo: {
        lat: geoPosition.lat,
        lon: geoPosition.lon
      },
      zone: zoneMapping,
      description: description,
      placed_by: from,
      placed_at: now,
      approved_by: null,
      status: 'pending',
      discoveries: 0,
      metadata: {}
    };

    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: now,
      seq: Date.now(),
      from: from,
      type: 'anchor_place',
      platform: 'ar',
      position: { x: 0, y: 0, z: 0, zone: zoneMapping },
      geo: { lat: geoPosition.lat, lon: geoPosition.lon },
      payload: {
        type: type,
        zone: zoneMapping,
        description: description,
        anchor: anchor
      }
    };
  }

  function validate(anchor) {
    var reasons = [];

    if (!anchor.geo || typeof anchor.geo !== 'object') {
      reasons.push('Missing geo coordinates');
    } else {
      var lat = anchor.geo.lat;
      var lon = anchor.geo.lon;

      if (typeof lat !== 'number' || typeof lon !== 'number') {
        reasons.push('Geo coordinates must be numbers');
      } else {
        if (lat < -90 || lat > 90) {
          reasons.push('Latitude out of range (-90 to 90)');
        }
        if (lon < -180 || lon > 180) {
          reasons.push('Longitude out of range (-180 to 180)');
        }
        if (lat === 0 && lon === 0) {
          reasons.push('Null Island (0,0) coordinates not permitted');
        }
      }
    }

    if (!anchor.type || VALID_TYPES.indexOf(anchor.type) === -1) {
      reasons.push('Invalid anchor type: "' + anchor.type + '". Must be one of: ' + VALID_TYPES.join(', '));
    }

    if (!anchor.zone || VALID_ZONES.indexOf(anchor.zone) === -1) {
      reasons.push('Invalid or missing zone: "' + anchor.zone + '". Must be one of: ' + VALID_ZONES.join(', '));
    }

    if (!anchor.description || typeof anchor.description !== 'string' || anchor.description.trim().length === 0) {
      reasons.push('Anchor must have a non-empty description');
    }

    return {
      valid: reasons.length === 0,
      reasons: reasons
    };
  }

  function approve(anchorId, stewardId) {
    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: nowISO(),
      seq: Date.now(),
      from: stewardId,
      type: 'anchor_approve',
      platform: 'api',
      position: { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: { lat: null, lon: null },
      payload: {
        anchor_id: anchorId,
        status: 'approved',
        approved_by: stewardId,
        approved_at: nowISO()
      }
    };
  }

  function reject(anchorId, stewardId, reason) {
    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: nowISO(),
      seq: Date.now(),
      from: stewardId,
      type: 'anchor_reject',
      platform: 'api',
      position: { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: { lat: null, lon: null },
      payload: {
        anchor_id: anchorId,
        status: 'rejected',
        rejected_by: stewardId,
        rejected_at: nowISO(),
        reason: reason || 'No reason provided'
      }
    };
  }

  function toArray(anchors) {
    if (!anchors) return [];
    if (Array.isArray(anchors)) return anchors;
    var arr = [];
    for (var key in anchors) {
      if (Object.prototype.hasOwnProperty.call(anchors, key)) {
        arr.push(anchors[key]);
      }
    }
    return arr;
  }

  function getNearby(playerGeo, anchors, radiusMeters) {
    var arr = toArray(anchors);
    var results = [];

    for (var i = 0; i < arr.length; i++) {
      var anchor = arr[i];
      if (!anchor.geo) continue;

      var dist = getDistance(playerGeo.lat, playerGeo.lon, anchor.geo.lat, anchor.geo.lon);

      if (radiusMeters !== undefined && dist > radiusMeters) continue;

      var copy = {};
      for (var k in anchor) {
        if (Object.prototype.hasOwnProperty.call(anchor, k)) {
          copy[k] = anchor[k];
        }
      }
      copy.distance = dist;
      results.push(copy);
    }

    results.sort(function(a, b) { return a.distance - b.distance; });
    return results;
  }

  function isInRange(playerGeo, anchor, radiusMeters) {
    if (!anchor.geo) return false;
    var range = (radiusMeters !== undefined) ? radiusMeters : DEFAULT_RANGE_M;
    var dist = getDistance(playerGeo.lat, playerGeo.lon, anchor.geo.lat, anchor.geo.lon);
    return dist <= range;
  }

  function discover(anchor, playerId) {
    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: nowISO(),
      seq: Date.now(),
      from: playerId,
      type: 'discover',
      platform: 'ar',
      position: { x: 0, y: 0, z: 0, zone: anchor.zone || 'nexus' },
      geo: { lat: anchor.geo.lat, lon: anchor.geo.lon },
      payload: {
        anchor_id: anchor.id,
        type: anchor.type,
        description: anchor.description,
        zone: anchor.zone,
        discovered_at: nowISO()
      }
    };
  }

  function getDiscoveredBy(playerId, anchors) {
    var arr = toArray(anchors);
    return arr.filter(function(anchor) {
      return Array.isArray(anchor.discoverers) && anchor.discoverers.indexOf(playerId) !== -1;
    });
  }

  function calculateWarmth(playerMovement) {
    if (!playerMovement || !Array.isArray(playerMovement) || playerMovement.length < 2) {
      return 0;
    }

    var totalDistanceM = 0;

    for (var i = 1; i < playerMovement.length; i++) {
      var prev = playerMovement[i - 1];
      var curr = playerMovement[i];

      if (!prev || !curr) continue;
      if (typeof prev.lat !== 'number' || typeof prev.lon !== 'number') continue;
      if (typeof curr.lat !== 'number' || typeof curr.lon !== 'number') continue;

      var segmentDistM = getDistance(prev.lat, prev.lon, curr.lat, curr.lon);

      var speedKmh = 0;
      if (typeof curr.speed === 'number' && curr.speed >= 0) {
        speedKmh = curr.speed;
      } else if (prev.ts && curr.ts) {
        var timeHours = (curr.ts - prev.ts) / (1000 * 60 * 60);
        if (timeHours > 0) {
          speedKmh = (segmentDistM / 1000) / timeHours;
        }
      }

      if (isDrivingSpeed(speedKmh)) continue;
      if (segmentDistM < 1) continue;

      totalDistanceM += segmentDistM;
    }

    var rawPoints = totalDistanceM / 100;
    return Math.min(WARMTH_POINTS_MAX, rawPoints);
  }

  function getWarmthBonus(warmthPoints) {
    if (typeof warmthPoints !== 'number' || warmthPoints < 0) {
      warmthPoints = 0;
    }

    var clamped = Math.min(warmthPoints, WARMTH_POINTS_MAX);
    var fraction = clamped / WARMTH_POINTS_MAX; // 0.0 to 1.0

    var harvestMultiplier = 1.0 + (fraction * WARMTH_HARVEST_MAX_BONUS);
    var discoveryMultiplier = 1.0 + (fraction * WARMTH_DISCOVERY_MAX_BONUS);

    harvestMultiplier = Math.min(1.0 + WARMTH_HARVEST_MAX_BONUS, harvestMultiplier);
    discoveryMultiplier = Math.min(1.0 + WARMTH_DISCOVERY_MAX_BONUS, discoveryMultiplier);

    return {
      harvestMultiplier: harvestMultiplier,
      discoveryMultiplier: discoveryMultiplier
    };
  }

  function geoToZone(lat, lon, anchors) {
    var arr = toArray(anchors);
    if (arr.length === 0) return null;

    var nearest = null;
    var nearestDist = Infinity;

    for (var i = 0; i < arr.length; i++) {
      var anchor = arr[i];
      if (!anchor.geo) continue;
      var dist = getDistance(lat, lon, anchor.geo.lat, anchor.geo.lon);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = anchor.zone;
      }
    }

    return nearest;
  }

  function zoneToGeoCenter(zone, anchors) {
    var zoneAnchors = getZoneAnchors(zone, anchors);
    if (zoneAnchors.length === 0) return null;

    var totalLat = 0;
    var totalLon = 0;
    for (var i = 0; i < zoneAnchors.length; i++) {
      totalLat += zoneAnchors[i].geo.lat;
      totalLon += zoneAnchors[i].geo.lon;
    }

    return {
      lat: totalLat / zoneAnchors.length,
      lon: totalLon / zoneAnchors.length
    };
  }

  function getZoneAnchors(zone, anchors) {
    var arr = toArray(anchors);
    return arr.filter(function(anchor) { return anchor.zone === zone; });
  }

  var SAFETY = {
    requiresPermission: true,
    maxSessionHours: 4,

    checkSpeed: function(speedKmh) {
      if (isDrivingSpeed(speedKmh)) {
        return {
          safe: false,
          warning: 'AR paused: Moving too fast (' + Math.round(speedKmh) + ' km/h). ' +
                   'Please stop and play ZION on foot. Stay safe!'
        };
      }
      return { safe: true };
    },

    getWarningMessage: function() {
      return 'SAFETY: AR mode uses your camera and GPS. ' +
             'Always be aware of your surroundings. ' +
             'Do not enter roads, restricted areas, or private property. ' +
             'Never use AR while driving or cycling. ' +
             'ZION anchors are placed at public, safe locations only. ' +
             'Location permission is required for AR features but ZION works fully without it.';
    }
  };

  function loadState(anchorsJson) {
    try {
      var state = JSON.parse(anchorsJson);
      if (!state.anchors || typeof state.anchors !== 'object') {
        state.anchors = {};
      }
      return state;
    } catch (e) {
      return { anchors: {} };
    }
  }

  function saveState(anchorsState) {
    return JSON.stringify(anchorsState, null, 2);
  }

  function addAnchor(state, anchor) {
    var newAnchors = {};
    for (var k in state.anchors) {
      if (Object.prototype.hasOwnProperty.call(state.anchors, k)) {
        newAnchors[k] = state.anchors[k];
      }
    }
    newAnchors[anchor.id] = anchor;
    return { anchors: newAnchors };
  }

  function removeAnchor(state, anchorId) {
    var newAnchors = {};
    for (var k in state.anchors) {
      if (Object.prototype.hasOwnProperty.call(state.anchors, k) && k !== anchorId) {
        newAnchors[k] = state.anchors[k];
      }
    }
    return { anchors: newAnchors };
  }

  function getStats(state) {
    var byType = {};
    var byZone = {};
    var totalDiscoveries = 0;
    var totalAnchors = 0;

    var anchors = state.anchors || {};
    for (var id in anchors) {
      if (!Object.prototype.hasOwnProperty.call(anchors, id)) continue;

      var anchor = anchors[id];
      totalAnchors++;

      var t = anchor.type || 'unknown';
      byType[t] = (byType[t] || 0) + 1;

      var z = anchor.zone || 'unknown';
      byZone[z] = (byZone[z] || 0) + 1;

      totalDiscoveries += (typeof anchor.discoveries === 'number') ? anchor.discoveries : 0;
    }

    return {
      totalAnchors: totalAnchors,
      byType: byType,
      byZone: byZone,
      totalDiscoveries: totalDiscoveries
    };
  }

  exports.TYPES = TYPES;
  exports.VALID_TYPES = VALID_TYPES;
  exports.VALID_ZONES = VALID_ZONES;
  exports.SAFETY = SAFETY;

  exports.requestLocation = requestLocation;
  exports.watchLocation = watchLocation;
  exports.stopWatching = stopWatching;
  exports.getDistance = getDistance;
  exports.isWalkingSpeed = isWalkingSpeed;
  exports.isDrivingSpeed = isDrivingSpeed;

  exports.create = create;
  exports.validate = validate;
  exports.approve = approve;
  exports.reject = reject;

  exports.getNearby = getNearby;
  exports.isInRange = isInRange;
  exports.discover = discover;
  exports.getDiscoveredBy = getDiscoveredBy;

  exports.calculateWarmth = calculateWarmth;
  exports.getWarmthBonus = getWarmthBonus;

  exports.geoToZone = geoToZone;
  exports.zoneToGeoCenter = zoneToGeoCenter;
  exports.getZoneAnchors = getZoneAnchors;

  exports.loadState = loadState;
  exports.saveState = saveState;
  exports.addAnchor = addAnchor;
  exports.removeAnchor = removeAnchor;
  exports.getStats = getStats;

})(typeof module !== 'undefined' ? module.exports : (window.Anchors = {}));


// physical.js
(function(exports) {

  const ANCHOR_TYPES = [
    'zone_portal', 'resource_node', 'discovery_point',
    'gathering_spot', 'garden_plot'
  ];

  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const toRad = deg => deg * Math.PI / 180;

    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    return distance;
  }

  function validateAnchorLocation(lat, lon) {
    if (typeof lat !== 'number' || typeof lon !== 'number') {
      return {safe: false, reason: 'Invalid coordinate types'};
    }

    if (lat < -90 || lat > 90) {
      return {safe: false, reason: 'Latitude out of range (-90 to 90)'};
    }

    if (lon < -180 || lon > 180) {
      return {safe: false, reason: 'Longitude out of range (-180 to 180)'};
    }

    if (lat === 0 && lon === 0) {
      return {safe: false, reason: 'Null Island coordinates not allowed'};
    }

    if (Math.abs(lat) > 85 && Math.abs(lon) > 170) {
      return {safe: false, reason: 'Location appears to be in remote ocean'};
    }

    return {safe: true};
  }

  function createAnchor(msg, state) {
    const lat = msg.payload.lat;
    const lon = msg.payload.lon;

    if (lat === undefined || lon === undefined) {
      return {
        success: false,
        error: 'Missing GPS coordinates'
      };
    }

    const validation = validateAnchorLocation(lat, lon);
    if (!validation.safe) {
      return {
        success: false,
        error: validation.reason
      };
    }

    const anchorType = msg.payload.type || 'discovery_point';
    if (!ANCHOR_TYPES.includes(anchorType)) {
      return {
        success: false,
        error: 'Invalid anchor type'
      };
    }

    const anchor = {
      id: generateId(),
      type: anchorType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      lat: lat,
      lon: lon,
      creator: msg.from,
      ts: Date.now(),
      status: 'pending'
    };

    if (!state.anchors) {
      state.anchors = [];
    }

    state.anchors.push(anchor);

    return {
      success: true,
      state: state,
      anchor: anchor
    };
  }

  function calculateWarmth(gpsHistory) {
    if (!gpsHistory || !Array.isArray(gpsHistory) || gpsHistory.length < 2) {
      return 0;
    }

    let totalKm = 0;
    const maxWalkingSpeed = 25; // km/h - filter out driving

    for (let i = 1; i < gpsHistory.length; i++) {
      const prev = gpsHistory[i - 1];
      const curr = gpsHistory[i];

      if (!prev.lat || !prev.lon || !curr.lat || !curr.lon || !prev.ts || !curr.ts) {
        continue;
      }

      const distance = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
      const timeHours = (curr.ts - prev.ts) / (1000 * 60 * 60);

      if (timeHours <= 0) {
        continue;
      }

      const speed = distance / timeHours;

      if (speed <= maxWalkingSpeed) {
        totalKm += distance;
      }
    }

    const warmth = Math.min(100, totalKm * 10);
    return warmth;
  }

  function getWarmthBonus(warmth) {
    if (typeof warmth !== 'number' || warmth < 0) {
      warmth = 0;
    }

    return 1.0 + (warmth / 1000);
  }

  function getSpeed(prev, curr) {
    if (!prev || !curr || !prev.ts || !curr.ts) return 0;
    var dist = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
    var hours = (curr.ts - prev.ts) / (1000 * 60 * 60);
    if (hours <= 0) return 0;
    return dist / hours;
  }

  function isDrivingSpeed(recentGPS) {
    if (!recentGPS || recentGPS.length < 2) return false;
    var last = recentGPS[recentGPS.length - 1];
    var prev = recentGPS[recentGPS.length - 2];
    return getSpeed(prev, last) > 30; // 30 km/h threshold
  }

  function getWarmthTier(warmth) {
    if (warmth >= 80) return 'Sunwalker';
    if (warmth >= 50) return 'Wanderer';
    if (warmth >= 20) return 'Stroller';
    if (warmth > 0) return 'Newcomer';
    return 'Indoor';
  }

  exports.ANCHOR_TYPES = ANCHOR_TYPES;
  exports.createAnchor = createAnchor;
  exports.validateAnchorLocation = validateAnchorLocation;
  exports.calculateWarmth = calculateWarmth;
  exports.getWarmthBonus = getWarmthBonus;
  exports.haversineDistance = haversineDistance;
  exports.getSpeed = getSpeed;
  exports.isDrivingSpeed = isDrivingSpeed;
  exports.getWarmthTier = getWarmthTier;

})(typeof module !== 'undefined' ? module.exports : (window.Physical = {}));


// guilds.js
(function(exports) {
  'use strict';

  var guilds = [];
  var invites = [];
  var guildMessages = [];
  var nextGuildId = 1;
  var nextInviteId = 1;
  var nextMessageId = 1;

  var LEVEL_THRESHOLDS = [
    { level: 1, xp: 0, maxMembers: 20 },
    { level: 2, xp: 500, maxMembers: 30 },
    { level: 3, xp: 1500, maxMembers: 40 },
    { level: 4, xp: 3000, maxMembers: 50 },
    { level: 5, xp: 6000, maxMembers: 60 }
  ];

  var GUILD_CREATION_COST = 100;
  var INVITE_EXPIRY_MS = 3600000; // 1 hour

  function initGuilds(existingData) {
    if (!existingData) return;

    guilds = existingData.guilds || [];
    invites = existingData.invites || [];
    guildMessages = existingData.guildMessages || [];
    nextGuildId = existingData.nextGuildId || 1;
    nextInviteId = existingData.nextInviteId || 1;
    nextMessageId = existingData.nextMessageId || 1;

    console.log('Guilds initialized:', guilds.length, 'guilds');
  }

  function getGuildsState() {
    return {
      guilds: guilds,
      invites: invites,
      guildMessages: guildMessages,
      nextGuildId: nextGuildId,
      nextInviteId: nextInviteId,
      nextMessageId: nextMessageId
    };
  }

  function createGuild(playerId, name, tag, type, description) {
    if (!playerId || !name || !tag || !type) {
      return { success: false, error: 'Missing required parameters' };
    }

    if (tag.length < 3 || tag.length > 5) {
      return { success: false, error: 'Tag must be 3-5 characters' };
    }

    if (['guild', 'garden', 'studio', 'community'].indexOf(type) === -1) {
      return { success: false, error: 'Invalid guild type' };
    }

    var existingGuild = getPlayerGuild(playerId);
    if (existingGuild) {
      return { success: false, error: 'Already in a guild' };
    }

    var nameExists = guilds.some(function(g) { return g.name === name; });
    var tagExists = guilds.some(function(g) { return g.tag === tag; });

    if (nameExists) {
      return { success: false, error: 'Guild name already taken' };
    }

    if (tagExists) {
      return { success: false, error: 'Guild tag already taken' };
    }

    var guild = {
      id: 'guild_' + (nextGuildId++),
      name: name,
      tag: tag,
      description: description || '',
      founder: playerId,
      leaders: [playerId],
      members: [{
        playerId: playerId,
        role: 'leader',
        joinedAt: Date.now()
      }],
      createdAt: Date.now(),
      zone: 'nexus', // Default home zone
      type: type,
      banner: {
        primaryColor: '#FFD700',
        secondaryColor: '#4A4A4A',
        icon: 'star'
      },
      treasury: 0,
      level: 1,
      xp: 0,
      maxMembers: 20,
      settings: {
        open: true,
        minLevel: 0
      },
      activities: []
    };

    guilds.push(guild);

    addActivity(guild.id, playerId + ' founded the ' + type);

    return {
      success: true,
      guild: guild,
      cost: GUILD_CREATION_COST
    };
  }

  function disbandGuild(guildId, playerId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    if (guild.founder !== playerId) {
      return { success: false, error: 'Only founder can disband guild' };
    }

    guilds = guilds.filter(function(g) { return g.id !== guildId; });

    invites = invites.filter(function(i) { return i.guildId !== guildId; });

    guildMessages = guildMessages.filter(function(m) { return m.guildId !== guildId; });

    return { success: true };
  }

  function inviteToGuild(guildId, inviterId, targetId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var inviterMember = guild.members.find(function(m) { return m.playerId === inviterId; });
    if (!inviterMember || (inviterMember.role !== 'leader' && inviterMember.role !== 'officer')) {
      return { success: false, error: 'No permission to invite' };
    }

    var targetInGuild = guild.members.some(function(m) { return m.playerId === targetId; });
    if (targetInGuild) {
      return { success: false, error: 'Player already in guild' };
    }

    var targetGuild = getPlayerGuild(targetId);
    if (targetGuild) {
      return { success: false, error: 'Player already in another guild' };
    }

    if (guild.members.length >= guild.maxMembers) {
      return { success: false, error: 'Guild is full' };
    }

    var existingInvite = invites.find(function(i) {
      return i.guildId === guildId && i.targetId === targetId && i.status === 'pending';
    });

    if (existingInvite) {
      return { success: false, error: 'Invite already sent' };
    }

    var invite = {
      id: 'invite_' + (nextInviteId++),
      guildId: guildId,
      guildName: guild.name,
      guildTag: guild.tag,
      inviterId: inviterId,
      targetId: targetId,
      status: 'pending',
      createdAt: Date.now(),
      expiresAt: Date.now() + INVITE_EXPIRY_MS
    };

    invites.push(invite);

    return { success: true, invite: invite };
  }

  function acceptInvite(inviteId, playerId) {
    var invite = invites.find(function(i) { return i.id === inviteId; });
    if (!invite) {
      return { success: false, error: 'Invite not found' };
    }

    if (invite.targetId !== playerId) {
      return { success: false, error: 'Invite not for this player' };
    }

    if (invite.status !== 'pending') {
      return { success: false, error: 'Invite already responded to' };
    }

    if (Date.now() > invite.expiresAt) {
      invite.status = 'expired';
      return { success: false, error: 'Invite expired' };
    }

    var guild = getGuild(invite.guildId);
    if (!guild) {
      return { success: false, error: 'Guild no longer exists' };
    }

    var playerGuild = getPlayerGuild(playerId);
    if (playerGuild) {
      return { success: false, error: 'Already in a guild' };
    }

    if (guild.members.length >= guild.maxMembers) {
      return { success: false, error: 'Guild is full' };
    }

    guild.members.push({
      playerId: playerId,
      role: 'member',
      joinedAt: Date.now()
    });

    invite.status = 'accepted';

    addActivity(guild.id, playerId + ' joined the guild');

    return { success: true, guild: guild };
  }

  function declineInvite(inviteId, playerId) {
    var invite = invites.find(function(i) { return i.id === inviteId; });
    if (!invite) {
      return { success: false, error: 'Invite not found' };
    }

    if (invite.targetId !== playerId) {
      return { success: false, error: 'Invite not for this player' };
    }

    if (invite.status !== 'pending') {
      return { success: false, error: 'Invite already responded to' };
    }

    invite.status = 'declined';

    return { success: true };
  }

  function leaveGuild(guildId, playerId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var memberIndex = guild.members.findIndex(function(m) { return m.playerId === playerId; });
    if (memberIndex === -1) {
      return { success: false, error: 'Not a member of this guild' };
    }

    if (guild.founder === playerId) {
      return { success: false, error: 'Founder must disband guild instead' };
    }

    guild.members.splice(memberIndex, 1);

    guild.leaders = guild.leaders.filter(function(id) { return id !== playerId; });

    addActivity(guild.id, playerId + ' left the guild');

    return { success: true };
  }

  function kickMember(guildId, kickerId, targetId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var kickerMember = guild.members.find(function(m) { return m.playerId === kickerId; });
    if (!kickerMember || (kickerMember.role !== 'leader' && kickerMember.role !== 'officer')) {
      return { success: false, error: 'No permission to kick' };
    }

    if (guild.founder === targetId) {
      return { success: false, error: 'Cannot kick founder' };
    }

    if (kickerId === targetId) {
      return { success: false, error: 'Cannot kick yourself' };
    }

    var targetMember = guild.members.find(function(m) { return m.playerId === targetId; });
    if (!targetMember) {
      return { success: false, error: 'Player not in guild' };
    }

    if (kickerMember.role === 'officer' && (targetMember.role === 'officer' || targetMember.role === 'leader')) {
      return { success: false, error: 'Insufficient permission' };
    }

    guild.members = guild.members.filter(function(m) { return m.playerId !== targetId; });

    guild.leaders = guild.leaders.filter(function(id) { return id !== targetId; });

    addActivity(guild.id, targetId + ' was kicked from guild');

    return { success: true };
  }

  function promoteRole(guildId, promoterId, targetId, newRole) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    if (['leader', 'officer', 'member'].indexOf(newRole) === -1) {
      return { success: false, error: 'Invalid role' };
    }

    var promoterMember = guild.members.find(function(m) { return m.playerId === promoterId; });
    if (!promoterMember || promoterMember.role !== 'leader') {
      return { success: false, error: 'Only leaders can promote' };
    }

    if (guild.founder === targetId && newRole !== 'leader') {
      return { success: false, error: 'Cannot demote founder' };
    }

    var targetMember = guild.members.find(function(m) { return m.playerId === targetId; });
    if (!targetMember) {
      return { success: false, error: 'Player not in guild' };
    }

    var oldRole = targetMember.role;
    targetMember.role = newRole;

    if (newRole === 'leader' && guild.leaders.indexOf(targetId) === -1) {
      guild.leaders.push(targetId);
    } else if (newRole !== 'leader' && guild.leaders.indexOf(targetId) !== -1) {
      guild.leaders = guild.leaders.filter(function(id) { return id !== targetId; });
    }

    addActivity(guild.id, targetId + ' promoted from ' + oldRole + ' to ' + newRole);

    return { success: true };
  }

  function getGuild(guildId) {
    return guilds.find(function(g) { return g.id === guildId; }) || null;
  }

  function getPlayerGuild(playerId) {
    return guilds.find(function(g) {
      return g.members.some(function(m) { return m.playerId === playerId; });
    }) || null;
  }

  function getGuildMembers(guildId) {
    var guild = getGuild(guildId);
    if (!guild) return [];

    return guild.members.map(function(m) {
      return {
        playerId: m.playerId,
        role: m.role,
        joinedAt: m.joinedAt,
        online: false // Would be populated by game state
      };
    });
  }

  function searchGuilds(query) {
    var lowerQuery = query.toLowerCase();
    return guilds.filter(function(g) {
      return g.name.toLowerCase().indexOf(lowerQuery) !== -1 ||
             g.tag.toLowerCase().indexOf(lowerQuery) !== -1;
    });
  }

  function getGuildsByType(type) {
    return guilds.filter(function(g) { return g.type === type; });
  }

  function depositToTreasury(guildId, playerId, amount) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member) {
      return { success: false, error: 'Not a member of this guild' };
    }

    if (amount <= 0) {
      return { success: false, error: 'Invalid amount' };
    }

    guild.treasury += amount;

    addActivity(guild.id, playerId + ' deposited ' + amount + ' Spark to treasury');

    return { success: true };
  }

  function withdrawFromTreasury(guildId, playerId, amount) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can withdraw' };
    }

    if (amount <= 0) {
      return { success: false, error: 'Invalid amount' };
    }

    if (guild.treasury < amount) {
      return { success: false, error: 'Insufficient treasury funds' };
    }

    guild.treasury -= amount;

    addActivity(guild.id, playerId + ' withdrew ' + amount + ' Spark from treasury');

    return { success: true };
  }

  function addGuildXP(guildId, amount, activity) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, leveledUp: false };
    }

    guild.xp += amount;

    var newLevel = calculateLevel(guild.xp);
    var leveledUp = newLevel > guild.level;

    if (leveledUp) {
      guild.level = newLevel;
      var threshold = LEVEL_THRESHOLDS.find(function(t) { return t.level === newLevel; });
      if (threshold) {
        guild.maxMembers = threshold.maxMembers;
      }

      addActivity(guild.id, 'Guild reached level ' + newLevel + '!');
    }

    if (activity) {
      addActivity(guild.id, activity + ' (+' + amount + ' XP)');
    }

    return {
      success: true,
      leveledUp: leveledUp,
      newLevel: leveledUp ? newLevel : undefined
    };
  }

  function calculateLevel(xp) {
    for (var i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
      if (xp >= LEVEL_THRESHOLDS[i].xp) {
        return LEVEL_THRESHOLDS[i].level;
      }
    }
    return 1;
  }

  function getGuildLeaderboard() {
    return guilds
      .slice()
      .sort(function(a, b) { return b.xp - a.xp; })
      .slice(0, 10)
      .map(function(g) {
        return {
          id: g.id,
          name: g.name,
          tag: g.tag,
          type: g.type,
          level: g.level,
          xp: g.xp,
          memberCount: g.members.length
        };
      });
  }

  function setGuildBanner(guildId, playerId, banner) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can change banner' };
    }

    guild.banner = banner;

    addActivity(guild.id, 'Guild banner updated');

    return { success: true };
  }

  function getGuildActivities(guildId, limit) {
    var guild = getGuild(guildId);
    if (!guild) return [];

    var activities = guild.activities.slice();
    if (limit) {
      activities = activities.slice(-limit);
    }

    return activities.reverse(); // Most recent first
  }

  function sendGuildMessage(guildId, playerId, text) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member) {
      return { success: false, error: 'Not a member of this guild' };
    }

    var message = {
      id: 'msg_' + (nextMessageId++),
      guildId: guildId,
      playerId: playerId,
      text: text,
      timestamp: Date.now()
    };

    guildMessages.push(message);

    return { success: true, message: message };
  }

  function getGuildMessages(guildId, limit) {
    var messages = guildMessages.filter(function(m) { return m.guildId === guildId; });

    if (limit) {
      messages = messages.slice(-limit);
    }

    return messages;
  }

  function addActivity(guildId, activity) {
    var guild = getGuild(guildId);
    if (!guild) return;

    guild.activities.push({
      timestamp: Date.now(),
      text: activity
    });

    if (guild.activities.length > 50) {
      guild.activities = guild.activities.slice(-50);
    }
  }

  function getPendingInvites(playerId) {
    return invites.filter(function(i) {
      return i.targetId === playerId &&
             i.status === 'pending' &&
             Date.now() <= i.expiresAt;
    });
  }

  function updateGuildSettings(guildId, playerId, settings) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can update settings' };
    }

    if (settings.hasOwnProperty('open')) {
      guild.settings.open = settings.open;
    }
    if (settings.hasOwnProperty('minLevel')) {
      guild.settings.minLevel = settings.minLevel;
    }

    return { success: true };
  }

  exports.initGuilds = initGuilds;
  exports.getGuildsState = getGuildsState;
  exports.createGuild = createGuild;
  exports.disbandGuild = disbandGuild;
  exports.inviteToGuild = inviteToGuild;
  exports.acceptInvite = acceptInvite;
  exports.declineInvite = declineInvite;
  exports.leaveGuild = leaveGuild;
  exports.kickMember = kickMember;
  exports.promoteRole = promoteRole;
  exports.getGuild = getGuild;
  exports.getPlayerGuild = getPlayerGuild;
  exports.getGuildMembers = getGuildMembers;
  exports.searchGuilds = searchGuilds;
  exports.getGuildsByType = getGuildsByType;
  exports.depositToTreasury = depositToTreasury;
  exports.withdrawFromTreasury = withdrawFromTreasury;
  exports.addGuildXP = addGuildXP;
  exports.getGuildLeaderboard = getGuildLeaderboard;
  exports.setGuildBanner = setGuildBanner;
  exports.getGuildActivities = getGuildActivities;
  exports.sendGuildMessage = sendGuildMessage;
  exports.getGuildMessages = getGuildMessages;
  exports.getPendingInvites = getPendingInvites;
  exports.updateGuildSettings = updateGuildSettings;

})(typeof module !== 'undefined' ? module.exports : (window.Guilds = {}));


// mentoring.js
(function(exports) {
  'use strict';

  var SKILLS = {
    gardening: {
      name: 'Gardening',
      levels: ['Seedling', 'Sprout', 'Gardener', 'Botanist', 'Grove Master'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    crafting: {
      name: 'Crafting',
      levels: ['Novice', 'Apprentice', 'Journeyman', 'Artisan', 'Master Crafter'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    building: {
      name: 'Building',
      levels: ['Laborer', 'Builder', 'Architect', 'Engineer', 'Grand Architect'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    exploration: {
      name: 'Exploration',
      levels: ['Wanderer', 'Scout', 'Explorer', 'Pathfinder', 'Cartographer'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    trading: {
      name: 'Trading',
      levels: ['Haggler', 'Merchant', 'Trader', 'Mogul', 'Trade Baron'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    social: {
      name: 'Social',
      levels: ['Shy', 'Friendly', 'Sociable', 'Diplomat', 'Ambassador'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    combat: {
      name: 'Combat',
      levels: ['Brawler', 'Fighter', 'Warrior', 'Champion', 'Arena Legend'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    lore: {
      name: 'Lore',
      levels: ['Curious', 'Student', 'Scholar', 'Sage', 'Lorekeeper'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    }
  };

  var NPC_TEACHING_SPECIALTIES = {
    farmer: 'gardening',
    gardener: 'gardening',
    artisan: 'crafting',
    creator: 'crafting',
    builder: 'building',
    architect: 'building',
    explorer: 'exploration',
    ranger: 'exploration',
    merchant: 'trading',
    trader: 'trading',
    diplomat: 'social',
    storyteller: 'social',
    warrior: 'combat',
    guardian: 'combat',
    scholar: 'lore',
    sage: 'lore'
  };

  var playerSkills = {}; // playerId -> { skillName: { xp, level, levelName } }
  var mentorships = {}; // mentorshipId -> mentorship object
  var mentorshipOffers = {}; // offerId -> offer object
  var npcLessons = {}; // lessonId -> lesson object
  var mentorshipIdCounter = 0;
  var offerIdCounter = 0;
  var lessonIdCounter = 0;

  function generateId(prefix) {
    return prefix + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  function getSkillLevel(xp, skill) {
    if (!SKILLS[skill]) return 0;
    var thresholds = SKILLS[skill].xpPerLevel;
    for (var i = thresholds.length - 1; i >= 0; i--) {
      if (xp >= thresholds[i]) return i;
    }
    return 0;
  }

  function getLevelName(level, skill) {
    if (!SKILLS[skill] || level < 0 || level >= SKILLS[skill].levels.length) {
      return 'Unknown';
    }
    return SKILLS[skill].levels[level];
  }

  function initPlayerSkills(playerId) {
    if (playerSkills[playerId]) return playerSkills[playerId];

    playerSkills[playerId] = {};
    for (var skillName in SKILLS) {
      playerSkills[playerId][skillName] = {
        xp: 0,
        level: 0,
        levelName: SKILLS[skillName].levels[0]
      };
    }
    return playerSkills[playerId];
  }

  function getPlayerSkills(playerId) {
    if (!playerSkills[playerId]) {
      initPlayerSkills(playerId);
    }
    return playerSkills[playerId];
  }

  function addSkillXP(playerId, skill, amount) {
    if (!SKILLS[skill]) {
      return { success: false, error: 'Invalid skill' };
    }

    if (!playerSkills[playerId]) {
      initPlayerSkills(playerId);
    }

    var skillData = playerSkills[playerId][skill];
    var oldLevel = skillData.level;
    skillData.xp += amount;

    var newLevel = getSkillLevel(skillData.xp, skill);
    var leveledUp = newLevel > oldLevel;

    if (leveledUp) {
      skillData.level = newLevel;
      skillData.levelName = getLevelName(newLevel, skill);
    }

    return {
      success: true,
      newXP: skillData.xp,
      leveledUp: leveledUp,
      newLevel: newLevel,
      newLevelName: skillData.levelName
    };
  }

  function getSkillLevelNum(playerId, skill) {
    if (!playerSkills[playerId] || !SKILLS[skill]) {
      return 0;
    }
    return playerSkills[playerId][skill].level;
  }

  function offerMentorship(mentorId, menteeId, skill) {
    if (!SKILLS[skill]) {
      return { success: false, error: 'Invalid skill' };
    }

    var mentorLevel = getSkillLevelNum(mentorId, skill);
    if (mentorLevel < 2) {
      return {
        success: false,
        error: 'Mentor must be at least level 2 in ' + SKILLS[skill].name
      };
    }

    var offerId = generateId('offer');
    var offer = {
      id: offerId,
      mentorId: mentorId,
      menteeId: menteeId,
      skill: skill,
      timestamp: Date.now()
    };

    mentorshipOffers[offerId] = offer;

    return {
      success: true,
      offer: offer
    };
  }

  function acceptMentorship(offerId) {
    var offer = mentorshipOffers[offerId];
    if (!offer) {
      return { success: false, error: 'Offer not found' };
    }

    var mentorshipId = generateId('mentorship');
    var mentorship = {
      id: mentorshipId,
      mentorId: offer.mentorId,
      menteeId: offer.menteeId,
      skill: offer.skill,
      stepsCompleted: 0,
      totalSteps: 5,
      startedAt: Date.now()
    };

    mentorships[mentorshipId] = mentorship;
    delete mentorshipOffers[offerId];

    return {
      success: true,
      mentorship: mentorship
    };
  }

  function declineMentorship(offerId) {
    if (mentorshipOffers[offerId]) {
      delete mentorshipOffers[offerId];
    }
  }

  function completeLessonStep(mentorshipId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return { success: false, error: 'Mentorship not found' };
    }

    if (mentorship.stepsCompleted >= mentorship.totalSteps) {
      return { success: false, error: 'Mentorship already completed' };
    }

    mentorship.stepsCompleted++;
    var progress = mentorship.stepsCompleted / mentorship.totalSteps;
    var completed = mentorship.stepsCompleted >= mentorship.totalSteps;

    addSkillXP(mentorship.menteeId, mentorship.skill, 20);

    var sparkReward = Math.floor(5 + Math.random() * 5);
    if (completed) {
      sparkReward += 50;
    }

    return {
      success: true,
      progress: progress,
      stepsCompleted: mentorship.stepsCompleted,
      totalSteps: mentorship.totalSteps,
      completed: completed,
      sparkReward: sparkReward,
      mentorship: mentorship
    };
  }

  function getActiveMentorships(playerId) {
    var result = [];
    for (var id in mentorships) {
      var m = mentorships[id];
      if (m.mentorId === playerId || m.menteeId === playerId) {
        result.push(m);
      }
    }
    return result;
  }

  function getMentorshipProgress(mentorshipId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return null;
    }

    return {
      stepsCompleted: mentorship.stepsCompleted,
      totalSteps: mentorship.totalSteps,
      skill: mentorship.skill,
      mentor: mentorship.mentorId,
      mentee: mentorship.menteeId
    };
  }

  function cancelMentorship(mentorshipId, playerId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return { success: false, error: 'Mentorship not found' };
    }

    if (mentorship.mentorId !== playerId && mentorship.menteeId !== playerId) {
      return { success: false, error: 'Not part of this mentorship' };
    }

    delete mentorships[mentorshipId];
    return { success: true };
  }

  function canNPCTeach(npcArchetype, skill) {
    if (!SKILLS[skill]) return false;
    return NPC_TEACHING_SPECIALTIES[npcArchetype] === skill;
  }

  function startNPCLesson(playerId, npcId, npcArchetype, skill) {
    if (!canNPCTeach(npcArchetype, skill)) {
      return {
        success: false,
        error: 'This NPC cannot teach ' + SKILLS[skill].name
      };
    }

    var lessonId = generateId('lesson');
    var lesson = {
      id: lessonId,
      playerId: playerId,
      npcId: npcId,
      npcArchetype: npcArchetype,
      skill: skill,
      startedAt: Date.now()
    };

    npcLessons[lessonId] = lesson;

    return {
      success: true,
      lesson: lesson
    };
  }

  function completeNPCLesson(lessonId) {
    var lesson = npcLessons[lessonId];
    if (!lesson) {
      return { success: false, error: 'Lesson not found' };
    }

    var xpGained = 15;
    addSkillXP(lesson.playerId, lesson.skill, xpGained);

    var sparkCost = Math.floor(5 + Math.random() * 10);

    delete npcLessons[lessonId];

    return {
      success: true,
      xpGained: xpGained,
      sparkCost: sparkCost,
      skill: lesson.skill
    };
  }

  function initMentoring(existingData) {
    if (existingData) {
      playerSkills = existingData.playerSkills || {};
      mentorships = existingData.mentorships || {};
      mentorshipOffers = existingData.mentorshipOffers || {};
      npcLessons = existingData.npcLessons || {};
    }
  }

  function getMentoringState() {
    return {
      playerSkills: playerSkills,
      mentorships: mentorships,
      mentorshipOffers: mentorshipOffers,
      npcLessons: npcLessons
    };
  }

  exports.SKILLS = SKILLS;
  exports.NPC_TEACHING_SPECIALTIES = NPC_TEACHING_SPECIALTIES;
  exports.initPlayerSkills = initPlayerSkills;
  exports.getPlayerSkills = getPlayerSkills;
  exports.addSkillXP = addSkillXP;
  exports.getSkillLevel = getSkillLevelNum;
  exports.offerMentorship = offerMentorship;
  exports.acceptMentorship = acceptMentorship;
  exports.declineMentorship = declineMentorship;
  exports.completeLessonStep = completeLessonStep;
  exports.getActiveMentorships = getActiveMentorships;
  exports.getMentorshipProgress = getMentorshipProgress;
  exports.cancelMentorship = cancelMentorship;
  exports.canNPCTeach = canNPCTeach;
  exports.startNPCLesson = startNPCLesson;
  exports.completeNPCLesson = completeNPCLesson;
  exports.initMentoring = initMentoring;
  exports.getMentoringState = getMentoringState;

})(typeof module !== 'undefined' ? module.exports : (window.Mentoring = {}));


// gardens.js
(function(exports) {
  'use strict';

  var MAX_COLLABORATORS = 5;

  var COLLABORATION_BONUS = 0.1;

  var ACTIVE_WINDOW_MS = 86400000; // 24 hours

  var ACTIVE_TEND_THRESHOLD = 1;

  var VALID_TEND_ACTIONS = ['water', 'weed', 'fertilize'];

  var GARDEN_ZONES = ['gardens', 'wilds'];

  var PLOT_SIZES = ['small', 'medium', 'large'];

  var DEFAULT_ZONE = 'gardens';

  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  var gardens = {}; // gardenId -> garden object

  function _getGarden(gardenId) {
    return gardens[gardenId] || null;
  }

  function createGarden(ownerId, position, zoneName) {
    if (!ownerId || typeof ownerId !== 'string' || ownerId.trim() === '') {
      return { success: false, error: 'Invalid ownerId' };
    }

    var zone = zoneName || DEFAULT_ZONE;

    if (GARDEN_ZONES.indexOf(zone) === -1) {
      return { success: false, error: 'Gardens not allowed in zone: ' + zone };
    }

    if (!position || typeof position !== 'object') {
      return { success: false, error: 'Invalid position' };
    }

    if (typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
      return { success: false, error: 'Position must have numeric x, y, z' };
    }

    var garden = {
      id: generateId(),
      ownerId: ownerId,
      position: { x: position.x, y: position.y, z: position.z },
      zoneName: zone,
      collaborators: [],
      isPublic: false,
      createdAt: Date.now(),
      tending: [],
      contributions: {},
      fertility: 0.7,
      size: 'medium',
      health: 1.0
    };

    garden.contributions[ownerId] = 0;

    gardens[garden.id] = garden;

    return { success: true, garden: garden };
  }

  function addCollaborator(gardenId, ownerId, collaboratorId) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (garden.ownerId !== ownerId) {
      return { success: false, error: 'Only the owner can add collaborators' };
    }

    if (!collaboratorId || typeof collaboratorId !== 'string' || collaboratorId.trim() === '') {
      return { success: false, error: 'Invalid collaboratorId' };
    }

    if (collaboratorId === ownerId) {
      return { success: false, error: 'Owner is already a member of the garden' };
    }

    if (garden.collaborators.indexOf(collaboratorId) !== -1) {
      return { success: false, error: 'Player is already a collaborator' };
    }

    if (garden.collaborators.length >= MAX_COLLABORATORS) {
      return { success: false, error: 'Garden has reached maximum collaborators (' + MAX_COLLABORATORS + ')' };
    }

    garden.collaborators.push(collaboratorId);

    if (garden.contributions[collaboratorId] === undefined) {
      garden.contributions[collaboratorId] = 0;
    }

    return { success: true };
  }

  function removeCollaborator(gardenId, ownerId, collaboratorId) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (garden.ownerId !== ownerId) {
      return { success: false, error: 'Only the owner can remove collaborators' };
    }

    var idx = garden.collaborators.indexOf(collaboratorId);
    if (idx === -1) {
      return { success: false, error: 'Player is not a collaborator' };
    }

    garden.collaborators.splice(idx, 1);

    return { success: true };
  }

  function getCollaborators(gardenId) {
    var garden = _getGarden(gardenId);
    if (!garden) return [];
    return garden.collaborators.slice();
  }

  function canTend(gardenId, playerId) {
    var garden = _getGarden(gardenId);
    if (!garden) return false;

    if (garden.ownerId === playerId) return true;
    if (garden.collaborators.indexOf(playerId) !== -1) return true;
    if (garden.isPublic) return true;

    return false;
  }

  function tendGarden(gardenId, playerId, action) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (!canTend(gardenId, playerId)) {
      return { success: false, error: 'Player does not have permission to tend this garden' };
    }

    if (VALID_TEND_ACTIONS.indexOf(action) === -1) {
      return { success: false, error: 'Invalid tending action: ' + action + '. Valid actions: ' + VALID_TEND_ACTIONS.join(', ') };
    }

    var event = {
      playerId: playerId,
      action: action,
      ts: Date.now()
    };

    garden.tending.push(event);

    if (garden.contributions[playerId] === undefined) {
      garden.contributions[playerId] = 0;
    }
    garden.contributions[playerId]++;

    garden.health = getGardenHealth(garden);

    return { success: true, tendingEvent: event };
  }

  function getGardenHealth(garden) {
    if (!garden || !garden.tending) return 0;

    var now = Date.now();
    var recentActions = garden.tending.filter(function(e) {
      return (now - e.ts) <= ACTIVE_WINDOW_MS;
    }).length;

    var base = Math.min(recentActions / 10, 1);
    var bonus = getBonusFromCollaboration(garden);
    var health = Math.min(base * (1 + bonus), 1);

    return health;
  }

  function getContributions(gardenId) {
    var garden = _getGarden(gardenId);
    if (!garden) return {};

    var result = {};
    var keys = Object.keys(garden.contributions);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = garden.contributions[keys[i]];
    }
    return result;
  }

  function getHarvestShare(gardenId, playerId) {
    var garden = _getGarden(gardenId);
    if (!garden) return 0;

    var contributions = garden.contributions;
    var total = 0;
    var keys = Object.keys(contributions);

    for (var i = 0; i < keys.length; i++) {
      total += contributions[keys[i]];
    }

    if (total === 0) {
      if (playerId === garden.ownerId) return 1;
      return 0;
    }

    var playerShare = contributions[playerId] || 0;

    if (playerShare === 0 && playerId === garden.ownerId) {
      var memberCount = garden.collaborators.length + 1; // +1 for owner
      var baseShare = 1 / memberCount;
      var remaining = 1 - baseShare;
      return baseShare;
    }

    return playerShare / total;
  }

  function getBonusFromCollaboration(garden) {
    if (!garden || !garden.tending) return 0;

    var now = Date.now();
    var activePlayerIds = {};

    for (var i = 0; i < garden.tending.length; i++) {
      var event = garden.tending[i];
      if ((now - event.ts) <= ACTIVE_WINDOW_MS) {
        activePlayerIds[event.playerId] = true;
      }
    }

    var activeCount = Object.keys(activePlayerIds).length;

    var collaboratorCount = Math.max(0, activeCount - 1);
    return collaboratorCount * COLLABORATION_BONUS;
  }

  function getGardenStats(gardenId) {
    var garden = _getGarden(gardenId);
    if (!garden) return null;

    var now = Date.now();
    var recentTending = garden.tending.filter(function(e) {
      return (now - e.ts) <= ACTIVE_WINDOW_MS;
    });

    var activeTenders = {};
    for (var i = 0; i < recentTending.length; i++) {
      activeTenders[recentTending[i].playerId] = true;
    }

    var actionCounts = {};
    for (var j = 0; j < garden.tending.length; j++) {
      var action = garden.tending[j].action;
      actionCounts[action] = (actionCounts[action] || 0) + 1;
    }

    return {
      id: garden.id,
      ownerId: garden.ownerId,
      zoneName: garden.zoneName,
      position: garden.position,
      collaborators: garden.collaborators.slice(),
      isPublic: garden.isPublic,
      createdAt: garden.createdAt,
      health: getGardenHealth(garden),
      collaborationBonus: getBonusFromCollaboration(garden),
      totalTendingActions: garden.tending.length,
      recentTendingActions: recentTending.length,
      activeTenderCount: Object.keys(activeTenders).length,
      contributions: getContributions(gardenId),
      actionBreakdown: actionCounts,
      fertility: garden.fertility,
      size: garden.size
    };
  }

  function listPublicGardens() {
    var result = [];
    var ids = Object.keys(gardens);
    for (var i = 0; i < ids.length; i++) {
      var garden = gardens[ids[i]];
      if (garden.isPublic) {
        result.push(getGardenStats(garden.id));
      }
    }
    return result;
  }

  function setGardenPublic(gardenId, ownerId, isPublic) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (garden.ownerId !== ownerId) {
      return { success: false, error: 'Only the owner can change garden visibility' };
    }

    if (typeof isPublic !== 'boolean') {
      return { success: false, error: 'isPublic must be a boolean' };
    }

    garden.isPublic = isPublic;

    return { success: true };
  }

  function _resetStore() {
    gardens = {};
  }

  function _loadGarden(garden) {
    if (garden && garden.id) {
      gardens[garden.id] = garden;
    }
  }

  function _getAllGardens() {
    return gardens;
  }

  function handleGardenCreate(msg) {
    var payload = msg.payload || {};
    return createGarden(
      msg.from,
      payload.position || { x: 0, y: 0, z: 0 },
      payload.zone || DEFAULT_ZONE
    );
  }

  function handleGardenInvite(msg) {
    var payload = msg.payload || {};
    return addCollaborator(payload.gardenId, msg.from, payload.collaboratorId);
  }

  function handleGardenUninvite(msg) {
    var payload = msg.payload || {};
    return removeCollaborator(payload.gardenId, msg.from, payload.collaboratorId);
  }

  function handleGardenTend(msg) {
    var payload = msg.payload || {};
    return tendGarden(payload.gardenId, msg.from, payload.action);
  }

  function handleGardenSetPublic(msg) {
    var payload = msg.payload || {};
    return setGardenPublic(payload.gardenId, msg.from, payload.isPublic);
  }

  exports.MAX_COLLABORATORS = MAX_COLLABORATORS;
  exports.COLLABORATION_BONUS = COLLABORATION_BONUS;
  exports.ACTIVE_WINDOW_MS = ACTIVE_WINDOW_MS;
  exports.VALID_TEND_ACTIONS = VALID_TEND_ACTIONS;
  exports.GARDEN_ZONES = GARDEN_ZONES;

  exports.createGarden = createGarden;
  exports.addCollaborator = addCollaborator;
  exports.removeCollaborator = removeCollaborator;
  exports.getCollaborators = getCollaborators;
  exports.canTend = canTend;
  exports.tendGarden = tendGarden;
  exports.getGardenHealth = getGardenHealth;
  exports.getContributions = getContributions;
  exports.getHarvestShare = getHarvestShare;
  exports.getBonusFromCollaboration = getBonusFromCollaboration;
  exports.getGardenStats = getGardenStats;
  exports.listPublicGardens = listPublicGardens;
  exports.setGardenPublic = setGardenPublic;

  exports.handleGardenCreate = handleGardenCreate;
  exports.handleGardenInvite = handleGardenInvite;
  exports.handleGardenUninvite = handleGardenUninvite;
  exports.handleGardenTend = handleGardenTend;
  exports.handleGardenSetPublic = handleGardenSetPublic;

  exports._resetStore = _resetStore;
  exports._loadGarden = _loadGarden;
  exports._getAllGardens = _getAllGardens;

})(typeof module !== 'undefined' ? module.exports : (window.Gardens = {}));


// chat.js

(function(exports) {
  'use strict';

  var CHANNEL_TYPES = {
    GLOBAL:  'global',
    ZONE:    'zone',
    GUILD:   'guild',
    WHISPER: 'whisper',
    SYSTEM:  'system',
    TRADE:   'trade'
  };

  var MESSAGE_COLORS = {
    global:  '#A8D8EA',   // soft blue
    zone:    '#B8F0B8',   // soft green
    guild:   '#FFD580',   // soft gold
    whisper: '#E8A0FF',   // soft purple
    system:  '#FF9999',   // soft red / system orange
    trade:   '#FFB347'    // warm orange
  };

  var CHANNEL_BADGES = {
    global:  '[G]',
    zone:    '[Z]',
    guild:   '[GU]',
    whisper: '[W]',
    system:  '[SYS]',
    trade:   '[T]'
  };

  var maxHistoryPerChannel = 200;

  var channels = {};        // channelName -> channel object
  var activeChannel = null; // name of currently selected channel

  function createChannel(type, name, options) {
    if (!type || !name) {
      return null;
    }

    var validTypes = Object.keys(CHANNEL_TYPES).map(function(k) { return CHANNEL_TYPES[k]; });
    if (validTypes.indexOf(type) === -1) {
      return null;
    }

    var opts = options || {};

    var channel = {
      type:         type,
      name:         name,
      displayName:  opts.displayName || name,
      targetPlayer: opts.targetPlayer || null,  // for whisper channels
      guildId:      opts.guildId || null,        // for guild channels
      zoneName:     opts.zoneName || null,        // for zone channels
      persistent:   opts.persistent !== undefined ? opts.persistent : true,
      muted:        false,
      messages:     [],
      unreadCount:  0,
      lastReadTs:   0,
      createdAt:    Date.now()
    };

    channels[name] = channel;
    return channel;
  }

  function getDefaultChannels() {
    var defaults = [
      { type: CHANNEL_TYPES.GLOBAL,  name: 'global',  displayName: 'Global',   persistent: true },
      { type: CHANNEL_TYPES.SYSTEM,  name: 'system',  displayName: 'System',   persistent: true },
      { type: CHANNEL_TYPES.TRADE,   name: 'trade',   displayName: 'Trade',    persistent: true }
    ];

    var result = [];
    for (var i = 0; i < defaults.length; i++) {
      var d = defaults[i];
      var ch = channels[d.name] || createChannel(d.type, d.name, { displayName: d.displayName, persistent: d.persistent });
      result.push(ch);
    }
    return result;
  }

  function addMessage(channel, message) {
    var ch = _resolveChannel(channel);
    if (!ch) return null;
    if (!message || typeof message !== 'object') return null;
    if (!message.sender || !message.text) return null;

    var record = {
      id:        _generateId(),
      sender:    message.sender,
      text:      String(message.text),
      ts:        message.ts || Date.now(),
      type:      message.type || ch.type,
      badge:     message.badge || CHANNEL_BADGES[ch.type] || '',
      meta:      message.meta || {}
    };

    ch.messages.push(record);

    if (ch.messages.length > maxHistoryPerChannel) {
      ch.messages = ch.messages.slice(ch.messages.length - maxHistoryPerChannel);
    }

    if (activeChannel !== ch.name) {
      ch.unreadCount++;
    }

    return record;
  }

  function getMessages(channel, limit, before) {
    var ch = _resolveChannel(channel);
    if (!ch) return [];

    var msgs = ch.messages.slice(); // shallow copy

    if (typeof before === 'number') {
      msgs = msgs.filter(function(m) { return m.ts < before; });
    }

    if (typeof limit === 'number' && limit > 0) {
      msgs = msgs.slice(-limit);
    }

    return msgs;
  }

  function getUnreadCount(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return 0;
    return ch.unreadCount;
  }

  function markAsRead(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return;
    ch.unreadCount = 0;
    ch.lastReadTs = Date.now();
  }

  function switchChannel(channelName) {
    if (!channels[channelName]) return null;
    activeChannel = channelName;
    markAsRead(channelName);
    return channels[channelName];
  }

  function getActiveChannel() {
    if (!activeChannel || !channels[activeChannel]) return null;
    return channels[activeChannel];
  }

  function formatMessage(msg) {
    if (!msg || typeof msg !== 'object') return '';

    var time = _formatTime(msg.ts);
    var badge = msg.badge || '';
    var sender = msg.sender || 'unknown';
    var text = msg.text || '';

    var parts = [time];
    if (badge) parts.push(badge);
    parts.push(sender + ': ' + text);

    return parts.join(' ');
  }

  function filterMessages(channel, query) {
    var ch = _resolveChannel(channel);
    if (!ch) return [];
    if (!query || typeof query !== 'string') return ch.messages.slice();

    var lq = query.toLowerCase();
    return ch.messages.filter(function(m) {
      return (m.sender && m.sender.toLowerCase().indexOf(lq) !== -1) ||
             (m.text   && m.text.toLowerCase().indexOf(lq)   !== -1);
    });
  }

  function muteChannel(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return;
    ch.muted = true;
  }

  function unmuteChannel(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return;
    ch.muted = false;
  }

  function getChannelForZone(zoneName) {
    if (!zoneName || typeof zoneName !== 'string') return null;
    var name = 'zone_' + zoneName;
    if (!channels[name]) {
      createChannel(CHANNEL_TYPES.ZONE, name, {
        displayName: zoneName.charAt(0).toUpperCase() + zoneName.slice(1),
        zoneName: zoneName
      });
    }
    return channels[name];
  }

  function getGuildChannel(guildId) {
    if (!guildId || typeof guildId !== 'string') return null;
    var name = 'guild_' + guildId;
    if (!channels[name]) {
      createChannel(CHANNEL_TYPES.GUILD, name, {
        displayName: 'Guild',
        guildId: guildId
      });
    }
    return channels[name];
  }

  function createWhisperChannel(localPlayer, targetPlayer) {
    if (!localPlayer || !targetPlayer || typeof localPlayer !== 'string' || typeof targetPlayer !== 'string') {
      return null;
    }
    if (localPlayer === targetPlayer) return null;

    var sorted = [localPlayer, targetPlayer].sort();
    var name = 'whisper_' + sorted[0] + '_' + sorted[1];

    if (!channels[name]) {
      createChannel(CHANNEL_TYPES.WHISPER, name, {
        displayName: targetPlayer,
        targetPlayer: targetPlayer
      });
    }
    return channels[name];
  }

  function getChannel(name) {
    return channels[name] || null;
  }

  function getAllChannels() {
    return channels;
  }

  function removeChannel(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return false;
    if (activeChannel === ch.name) {
      activeChannel = null;
    }
    delete channels[ch.name];
    return true;
  }

  function reset() {
    channels = {};
    activeChannel = null;
  }

  function _resolveChannel(channel) {
    if (!channel) return null;
    if (typeof channel === 'string') return channels[channel] || null;
    if (typeof channel === 'object' && channel.name) return channels[channel.name] || channel;
    return null;
  }

  function _generateId() {
    return 'msg_' + Date.now() + '_' + Math.floor(Math.random() * 1000000);
  }

  function _formatTime(ts) {
    var d = new Date(typeof ts === 'number' ? ts : Date.now());
    var hh = String(d.getHours()).padStart(2, '0');
    var mm = String(d.getMinutes()).padStart(2, '0');
    return '[' + hh + ':' + mm + ']';
  }

  exports.CHANNEL_TYPES        = CHANNEL_TYPES;
  exports.MESSAGE_COLORS       = MESSAGE_COLORS;
  exports.CHANNEL_BADGES       = CHANNEL_BADGES;
  exports.maxHistoryPerChannel = maxHistoryPerChannel;

  exports.createChannel        = createChannel;
  exports.getDefaultChannels   = getDefaultChannels;
  exports.addMessage           = addMessage;
  exports.getMessages          = getMessages;
  exports.getUnreadCount       = getUnreadCount;
  exports.markAsRead           = markAsRead;
  exports.switchChannel        = switchChannel;
  exports.getActiveChannel     = getActiveChannel;
  exports.formatMessage        = formatMessage;
  exports.filterMessages       = filterMessages;
  exports.muteChannel          = muteChannel;
  exports.unmuteChannel        = unmuteChannel;
  exports.getChannelForZone    = getChannelForZone;
  exports.getGuildChannel      = getGuildChannel;
  exports.createWhisperChannel = createWhisperChannel;
  exports.getChannel           = getChannel;
  exports.getAllChannels        = getAllChannels;
  exports.removeChannel        = removeChannel;
  exports.reset                = reset;

})(typeof module !== 'undefined' ? module.exports : (window.Chat = {}));


// elections.js
(function(exports) {
  'use strict';

  var ELECTION_CONFIG = {
    termLengthMs: 7 * 24 * 60 * 60 * 1000,       // 7 days in milliseconds
    votingPeriodMs: 2 * 24 * 60 * 60 * 1000,      // 2 days voting window
    minCandidates: 1,                               // Minimum candidates to hold election
    maxStewardsPerZone: 3,                          // Top N winners become stewards
    minVisitsToVote: 5,                             // Visits needed to vote
    minVisitsToRun: 10,                             // Visits needed to run as candidate
    visitWindowMs: 30 * 24 * 60 * 60 * 1000,       // 30-day window for visit counts
    reputationToRun: ['Respected', 'Honored', 'Elder'],  // Tiers eligible to run
    historyLimit: 20                                // Max election history per zone
  };

  var STEWARD_POWERS = [
    {
      id: 'set_welcome',
      name: 'Set Welcome Message',
      description: 'Display a custom greeting to players entering the zone.',
      protocol: 'steward_set_welcome'
    },
    {
      id: 'set_policy',
      name: 'Set Zone Policy',
      description: 'Toggle zone policies like chat moderation and building approval.',
      protocol: 'steward_set_policy'
    },
    {
      id: 'moderate',
      name: 'Moderate Citizens',
      description: 'Warn or mute players who violate zone norms.',
      protocol: 'steward_moderate'
    },
    {
      id: 'schedule_event',
      name: 'Schedule Events',
      description: 'Add events to the zone calendar visible to all visitors.',
      protocol: 'steward_set_policy'
    },
    {
      id: 'pin_announcement',
      name: 'Pin Announcement',
      description: 'Pin a message at the top of zone chat for all to see.',
      protocol: 'steward_set_welcome'
    }
  ];

  var electionStore = {};

  var stewardStore = {};

  var historyStore = {};

  var visitStore = {};

  var candidateDeclarations = {};

  function recordVisit(zoneId, playerId) {
    var key = zoneId + ':' + playerId;
    if (!visitStore[key]) {
      visitStore[key] = { count: 0, lastVisit: 0 };
    }
    visitStore[key].count++;
    visitStore[key].lastVisit = Date.now();
  }

  function getVisitRecord(zoneId, playerId) {
    var key = zoneId + ':' + playerId;
    return visitStore[key] || { count: 0, lastVisit: 0 };
  }

  function meetsVisitThreshold(zoneId, playerId, minVisits) {
    var record = getVisitRecord(zoneId, playerId);
    var now = Date.now();
    var withinWindow = (now - record.lastVisit) < ELECTION_CONFIG.visitWindowMs;
    return record.count >= minVisits && withinWindow;
  }

  function isEligibleCandidate(playerId, zoneId, playerData) {
    if (!playerId || typeof playerId !== 'string') {
      return { eligible: false, reason: 'Invalid player ID' };
    }
    if (!zoneId || typeof zoneId !== 'string') {
      return { eligible: false, reason: 'Invalid zone ID' };
    }

    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    try { Zones = Zones || require('./zones'); } catch(e) {}
    if (Zones && !Zones.zoneExists(zoneId)) {
      return { eligible: false, reason: 'Zone does not exist' };
    }

    if (!meetsVisitThreshold(zoneId, playerId, ELECTION_CONFIG.minVisitsToRun)) {
      var record = getVisitRecord(zoneId, playerId);
      return {
        eligible: false,
        reason: 'Must visit this zone at least ' + ELECTION_CONFIG.minVisitsToRun +
          ' times within the last 30 days (current: ' + record.count + ')'
      };
    }

    if (playerData && playerData.reputationTier) {
      var tiers = ELECTION_CONFIG.reputationToRun;
      if (tiers.indexOf(playerData.reputationTier) === -1) {
        return {
          eligible: false,
          reason: 'Must have Respected, Honored, or Elder reputation tier to run'
        };
      }
    }

    return { eligible: true, reason: 'Eligible to run' };
  }

  function isEligibleVoter(playerId, zoneId) {
    if (!playerId || typeof playerId !== 'string') {
      return { eligible: false, reason: 'Invalid player ID' };
    }
    if (!zoneId || typeof zoneId !== 'string') {
      return { eligible: false, reason: 'Invalid zone ID' };
    }

    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    try { Zones = Zones || require('./zones'); } catch(e) {}
    if (Zones && !Zones.zoneExists(zoneId)) {
      return { eligible: false, reason: 'Zone does not exist' };
    }

    if (!meetsVisitThreshold(zoneId, playerId, ELECTION_CONFIG.minVisitsToVote)) {
      var record = getVisitRecord(zoneId, playerId);
      return {
        eligible: false,
        reason: 'Must visit this zone at least ' + ELECTION_CONFIG.minVisitsToVote +
          ' times within the last 30 days (current: ' + record.count + ')'
      };
    }

    return { eligible: true, reason: 'Eligible to vote' };
  }

  function createElection(zoneId, candidates, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();

    if (!zoneId || typeof zoneId !== 'string') {
      return { success: false, error: 'Invalid zone ID' };
    }

    var existing = getActiveElectionForZone(zoneId, now);
    if (existing) {
      return { success: false, error: 'An election is already active for this zone' };
    }

    if (!Array.isArray(candidates)) {
      return { success: false, error: 'Candidates must be an array' };
    }

    if (candidates.length < ELECTION_CONFIG.minCandidates) {
      return {
        success: false,
        error: 'Need at least ' + ELECTION_CONFIG.minCandidates + ' candidate(s) to start election'
      };
    }

    var seen = {};
    var uniqueCandidates = [];
    for (var i = 0; i < candidates.length; i++) {
      var cid = candidates[i];
      if (cid && typeof cid === 'string' && !seen[cid]) {
        seen[cid] = true;
        uniqueCandidates.push(cid);
      }
    }

    var electionId = 'election_' + zoneId + '_' + now;
    var election = {
      id: electionId,
      zoneId: zoneId,
      startedBy: opts.startedBy || null,
      candidates: uniqueCandidates.map(function(pid) {
        return { playerId: pid, votes: 0, voters: [] };
      }),
      startTime: now,
      endTime: now + ELECTION_CONFIG.votingPeriodMs,
      status: 'active',
      totalVotes: 0
    };

    electionStore[electionId] = election;
    return { success: true, election: election };
  }

  function declareCandidacy(electionId, playerId) {
    var election = electionStore[electionId];
    if (!election) {
      return { success: false, error: 'Election not found' };
    }
    if (election.status !== 'active') {
      return { success: false, error: 'Election is not active' };
    }
    var now = Date.now();
    if (now > election.endTime) {
      return { success: false, error: 'Voting period has ended' };
    }

    for (var i = 0; i < election.candidates.length; i++) {
      if (election.candidates[i].playerId === playerId) {
        return { success: false, error: 'Already a candidate in this election' };
      }
    }

    election.candidates.push({ playerId: playerId, votes: 0, voters: [] });
    candidateDeclarations[electionId + ':' + playerId] = now;
    return { success: true };
  }

  function castVote(electionId, voterId, candidateId, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();

    var election = electionStore[electionId];
    if (!election) {
      return { success: false, error: 'Election not found' };
    }
    if (election.status !== 'active') {
      return { success: false, error: 'Election is not active' };
    }
    if (now > election.endTime) {
      election.status = 'ended';
      return { success: false, error: 'Voting period has ended' };
    }

    var eligibility = isEligibleVoter(voterId, election.zoneId);
    if (!eligibility.eligible) {
      return { success: false, error: eligibility.reason };
    }

    var alreadyVoted = false;
    for (var i = 0; i < election.candidates.length; i++) {
      if (election.candidates[i].voters.indexOf(voterId) !== -1) {
        alreadyVoted = true;
        break;
      }
    }
    if (alreadyVoted) {
      return { success: false, error: 'You have already voted in this election' };
    }

    var candidate = null;
    for (var j = 0; j < election.candidates.length; j++) {
      if (election.candidates[j].playerId === candidateId) {
        candidate = election.candidates[j];
        break;
      }
    }
    if (!candidate) {
      return { success: false, error: 'Candidate not found in this election' };
    }

    candidate.votes++;
    candidate.voters.push(voterId);
    election.totalVotes++;
    return { success: true };
  }

  function getElectionResults(election) {
    if (!election || !election.candidates) {
      return { winner: null, ranked: [], totalVotes: 0 };
    }

    var sorted = election.candidates.slice().sort(function(a, b) {
      return b.votes - a.votes;
    });

    var winner = sorted.length > 0 && sorted[0].votes > 0 ? sorted[0].playerId : null;

    return {
      winner: winner,
      ranked: sorted.map(function(c) {
        return {
          playerId: c.playerId,
          votes: c.votes,
          percentage: election.totalVotes > 0
            ? Math.round((c.votes / election.totalVotes) * 100)
            : 0
        };
      }),
      totalVotes: election.totalVotes
    };
  }

  function finalizeElection(electionId, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();

    var election = electionStore[electionId];
    if (!election) {
      return { success: false, error: 'Election not found' };
    }
    if (election.status === 'finalized') {
      return { success: false, error: 'Election already finalized' };
    }
    if (election.status !== 'active' && election.status !== 'ended') {
      return { success: false, error: 'Election cannot be finalized' };
    }
    if (now < election.endTime) {
      return { success: false, error: 'Election voting period has not ended yet' };
    }

    election.status = 'finalized';
    election.finalizedAt = now;

    var results = getElectionResults(election);
    var winners = results.ranked.slice(0, ELECTION_CONFIG.maxStewardsPerZone);

    var zoneId = election.zoneId;
    if (!stewardStore[zoneId]) {
      stewardStore[zoneId] = [];
    }

    var newStewards = winners.map(function(w) {
      return {
        playerId: w.playerId,
        zoneId: zoneId,
        electionId: electionId,
        votes: w.votes,
        electedAt: now,
        termEnds: now + ELECTION_CONFIG.termLengthMs
      };
    });

    stewardStore[zoneId] = newStewards;

    if (!historyStore[zoneId]) {
      historyStore[zoneId] = [];
    }
    historyStore[zoneId].unshift({
      electionId: electionId,
      zoneId: zoneId,
      startTime: election.startTime,
      endTime: election.endTime,
      finalizedAt: now,
      totalVotes: election.totalVotes,
      winner: results.winner,
      ranked: results.ranked
    });

    if (historyStore[zoneId].length > ELECTION_CONFIG.historyLimit) {
      historyStore[zoneId] = historyStore[zoneId].slice(0, ELECTION_CONFIG.historyLimit);
    }

    return { success: true, stewards: newStewards, results: results };
  }

  function getActiveElectionForZone(zoneId, now) {
    now = now !== undefined ? now : Date.now();
    var keys = Object.keys(electionStore);
    for (var i = 0; i < keys.length; i++) {
      var e = electionStore[keys[i]];
      if (e.zoneId === zoneId && e.status === 'active' && e.endTime > now) {
        return e;
      }
    }
    return null;
  }

  function getActiveElections() {
    var now = Date.now();
    var active = [];
    var keys = Object.keys(electionStore);
    for (var i = 0; i < keys.length; i++) {
      var e = electionStore[keys[i]];
      if (e.status === 'active' && e.endTime > now) {
        active.push(e);
      }
    }
    return active;
  }

  function getCurrentStewards() {
    var now = Date.now();
    var result = {};
    var zones = Object.keys(stewardStore);
    for (var i = 0; i < zones.length; i++) {
      var zoneId = zones[i];
      var active = stewardStore[zoneId].filter(function(s) {
        return s.termEnds > now;
      });
      if (active.length > 0) {
        result[zoneId] = active;
      }
    }
    return result;
  }

  function getZoneStewards(zoneId) {
    var now = Date.now();
    var stewards = stewardStore[zoneId] || [];
    return stewards.filter(function(s) { return s.termEnds > now; });
  }

  function isSteward(playerId, zoneId) {
    var stewards = getZoneStewards(zoneId);
    for (var i = 0; i < stewards.length; i++) {
      if (stewards[i].playerId === playerId) return true;
    }
    return false;
  }

  function getStewardPowers() {
    return STEWARD_POWERS.slice();
  }

  function getElectionHistory(zoneId) {
    return (historyStore[zoneId] || []).slice();
  }

  function calculateTermRemaining(steward) {
    if (!steward || typeof steward.termEnds !== 'number') {
      return { days: 0, hours: 0, totalMs: 0, expired: true };
    }
    var now = Date.now();
    var remaining = steward.termEnds - now;
    if (remaining <= 0) {
      return { days: 0, hours: 0, totalMs: 0, expired: true };
    }
    var days = Math.floor(remaining / 86400000);
    var hours = Math.floor((remaining % 86400000) / 3600000);
    return { days: days, hours: hours, totalMs: remaining, expired: false };
  }

  function formatElectionCard(election) {
    if (!election) return null;

    var now = Date.now();
    var msLeft = election.endTime - now;
    var hoursLeft = Math.max(0, Math.floor(msLeft / 3600000));
    var minutesLeft = Math.max(0, Math.floor((msLeft % 3600000) / 60000));

    var results = getElectionResults(election);

    return {
      id: election.id,
      zoneId: election.zoneId,
      status: election.status,
      timeLeft: msLeft > 0 ? (hoursLeft + 'h ' + minutesLeft + 'm remaining') : 'Voting ended',
      hoursLeft: hoursLeft,
      totalVotes: election.totalVotes,
      candidates: results.ranked,
      winner: results.winner,
      startTime: new Date(election.startTime).toLocaleDateString(),
      endTime: new Date(election.endTime).toLocaleDateString()
    };
  }

  function applyElectionStart(msg, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();
    var zoneId = msg.payload && msg.payload.zone ? msg.payload.zone : null;
    if (!zoneId) {
      return { success: false, error: 'Missing zone in payload' };
    }
    return createElection(zoneId, [msg.from], { startedBy: msg.from, now: now });
  }

  function applyElectionVote(msg, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();
    var electionId = msg.payload && msg.payload.electionId ? msg.payload.electionId : null;
    var candidate = msg.payload && msg.payload.candidate ? msg.payload.candidate : null;
    if (!electionId || !candidate) {
      return { success: false, error: 'Missing electionId or candidate in payload' };
    }
    return castVote(electionId, msg.from, candidate, { now: now });
  }

  function applyElectionFinalize(msg, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();
    var electionId = msg.payload && msg.payload.electionId ? msg.payload.electionId : null;
    if (!electionId) {
      return { success: false, error: 'Missing electionId in payload' };
    }
    return finalizeElection(electionId, { now: now });
  }

  function _reset() {
    electionStore = {};
    stewardStore = {};
    historyStore = {};
    visitStore = {};
    candidateDeclarations = {};
  }

  function _seedVisit(zoneId, playerId, count, lastVisit) {
    var key = zoneId + ':' + playerId;
    visitStore[key] = {
      count: count,
      lastVisit: lastVisit !== undefined ? lastVisit : Date.now()
    };
  }

  function _insertElection(election) {
    electionStore[election.id] = election;
  }

  function _insertSteward(zoneId, steward) {
    if (!stewardStore[zoneId]) stewardStore[zoneId] = [];
    stewardStore[zoneId].push(steward);
  }

  exports.ELECTION_CONFIG = ELECTION_CONFIG;
  exports.STEWARD_POWERS = STEWARD_POWERS;

  exports.recordVisit = recordVisit;
  exports.getVisitRecord = getVisitRecord;
  exports.isEligibleCandidate = isEligibleCandidate;
  exports.isEligibleVoter = isEligibleVoter;

  exports.createElection = createElection;
  exports.declareCandidacy = declareCandidacy;
  exports.castVote = castVote;
  exports.getElectionResults = getElectionResults;
  exports.finalizeElection = finalizeElection;

  exports.getActiveElections = getActiveElections;
  exports.getCurrentStewards = getCurrentStewards;
  exports.getZoneStewards = getZoneStewards;
  exports.isSteward = isSteward;
  exports.getStewardPowers = getStewardPowers;
  exports.getElectionHistory = getElectionHistory;
  exports.calculateTermRemaining = calculateTermRemaining;
  exports.formatElectionCard = formatElectionCard;

  exports.applyElectionStart = applyElectionStart;
  exports.applyElectionVote = applyElectionVote;
  exports.applyElectionFinalize = applyElectionFinalize;

  exports._reset = _reset;
  exports._seedVisit = _seedVisit;
  exports._insertElection = _insertElection;
  exports._insertSteward = _insertSteward;

})(typeof module !== 'undefined' ? module.exports : (window.Elections = {}));


// leaderboards.js

(function(exports) {
  'use strict';

  var CATEGORIES = {
    WEALTH: 'wealth',
    QUESTS: 'quests',
    EXPLORATION: 'exploration',
    GUILDS: 'guilds',
    REPUTATION: 'reputation',
    COMBINED: 'combined'
  };

  var TIME_PERIODS = {
    ALL_TIME: 'all_time',
    DAILY: 'daily',
    WEEKLY: 'weekly'
  };

  var DEFAULT_DISPLAY_COUNTS = [10, 25, 50];

  var COMBINED_WEIGHTS = {
    wealth: 0.25,
    quests: 0.25,
    exploration: 0.20,
    reputation: 0.20,
    guilds: 0.10
  };

  var MS_PER_DAY = 86400000;
  var MS_PER_WEEK = 604800000;

  var TIER_VALUES = {
    'Newcomer': 0,
    'Trusted': 100,
    'Respected': 500,
    'Honored': 1500,
    'Elder': 5000
  };

  var _nowFn = function() { return Date.now(); };

  function _setNowFn(fn) {
    _nowFn = fn;
  }

  function _now() {
    return _nowFn();
  }

  function _clamp(val, min, max) {
    if (val < min) return min;
    if (val > max) return max;
    return val;
  }

  function _safeInt(n) {
    if (typeof n !== 'number' || !isFinite(n) || isNaN(n)) return 0;
    return Math.floor(n);
  }

  function _timeCutoff(period) {
    var now = _now();
    if (period === TIME_PERIODS.DAILY) return now - MS_PER_DAY;
    if (period === TIME_PERIODS.WEEKLY) return now - MS_PER_WEEK;
    return 0; // all_time â€” no cutoff
  }

  function _normalise(entries) {
    if (!entries || entries.length === 0) return [];
    var max = 0;
    for (var i = 0; i < entries.length; i++) {
      if (entries[i].score > max) max = entries[i].score;
    }
    if (max === 0) {
      return entries.map(function(e) {
        return { id: e.id, score: e.score, normScore: 0 };
      });
    }
    return entries.map(function(e) {
      return { id: e.id, score: e.score, normScore: (e.score / max) * 100 };
    });
  }

  function _rankEntries(entries) {
    if (!entries || entries.length === 0) return [];
    var sorted = entries.slice().sort(function(a, b) { return b.score - a.score; });
    var rank = 1;
    for (var i = 0; i < sorted.length; i++) {
      if (i > 0 && sorted[i].score < sorted[i - 1].score) {
        rank = i + 1;
      }
      sorted[i].rank = rank;
    }
    return sorted;
  }

  function _validId(id) {
    return typeof id === 'string' && id.length > 0;
  }

  function getWealthRankings(economyData, options) {
    options = options || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var exclude = options.excludeIds || [];
    var SYSTEM_IDS = ['TREASURY', 'SYSTEM'];

    if (!economyData) return [];

    var balances = economyData.balances || economyData;
    if (typeof balances !== 'object') return [];

    var entries = [];
    var keys = Object.keys(balances);
    for (var i = 0; i < keys.length; i++) {
      var pid = keys[i];
      if (SYSTEM_IDS.indexOf(pid) !== -1) continue;
      if (exclude.indexOf(pid) !== -1) continue;
      var balance = _safeInt(balances[pid]);
      if (balance < 0) balance = 0;
      entries.push({ id: pid, score: balance, name: pid, label: balance + ' Spark' });
    }

    if (period !== TIME_PERIODS.ALL_TIME && economyData.transactions) {
      var cutoff = _timeCutoff(period);
      var periodEarnings = {};
      var txns = economyData.transactions;
      for (var t = 0; t < txns.length; t++) {
        var tx = txns[t];
        if (tx.ts < cutoff) continue;
        if (tx.type !== 'earn') continue;
        if (SYSTEM_IDS.indexOf(tx.to) !== -1) continue;
        if (!periodEarnings[tx.to]) periodEarnings[tx.to] = 0;
        periodEarnings[tx.to] += _safeInt(tx.amount);
      }
      entries = [];
      var earnKeys = Object.keys(periodEarnings);
      for (var e = 0; e < earnKeys.length; e++) {
        var epid = earnKeys[e];
        if (exclude.indexOf(epid) !== -1) continue;
        var earned = periodEarnings[epid];
        entries.push({ id: epid, score: earned, name: epid, label: earned + ' Spark earned' });
      }
    }

    return _rankEntries(entries);
  }

  function getQuestRankings(questData, options) {
    options = options || {};

    if (!questData) return [];

    var entries = [];

    function _processPlayer(pid, pData) {
      if (!_validId(pid)) return;
      var turned = (pData.turnedInQuests || []).length;
      var completed = (pData.completedQuests || []).length;
      var count = Math.max(turned, completed);
      entries.push({ id: pid, score: count, name: pid, label: count + ' quests' });
    }

    if (Array.isArray(questData)) {
      for (var i = 0; i < questData.length; i++) {
        var item = questData[i];
        _processPlayer(item.playerId || item.id, item);
      }
    } else if (typeof questData === 'object') {
      var keys = Object.keys(questData);
      for (var k = 0; k < keys.length; k++) {
        _processPlayer(keys[k], questData[keys[k]]);
      }
    }

    return _rankEntries(entries);
  }

  function getExplorationRankings(discoveryData, options) {
    options = options || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var cutoff = _timeCutoff(period);
    var useRarityBonus = options.rarityBonus !== false; // default true

    if (!discoveryData) return [];

    var scores = {};

    function _addDiscovery(pid, discovery) {
      if (!_validId(pid)) return;
      if (cutoff > 0 && discovery.ts && discovery.ts < cutoff) return;
      var rarity = typeof discovery.rarity === 'number' ? discovery.rarity : 0.3;
      var points = 1;
      if (useRarityBonus) {
        if (rarity >= 0.9) points = 4;
        else if (rarity >= 0.7) points = 3;
        else if (rarity >= 0.5) points = 2;
      }
      if (!scores[pid]) scores[pid] = 0;
      scores[pid] += points;
    }

    if (Array.isArray(discoveryData)) {
      for (var i = 0; i < discoveryData.length; i++) {
        var d = discoveryData[i];
        _addDiscovery(d.discoverer || d.playerId || d.id, d);
      }
    } else if (typeof discoveryData === 'object') {
      var keys = Object.keys(discoveryData);
      for (var k = 0; k < keys.length; k++) {
        var pid = keys[k];
        var dList = discoveryData[pid];
        if (Array.isArray(dList)) {
          for (var j = 0; j < dList.length; j++) {
            _addDiscovery(pid, dList[j]);
          }
        }
      }
    }

    var entries = [];
    var scoreKeys = Object.keys(scores);
    for (var s = 0; s < scoreKeys.length; s++) {
      var id = scoreKeys[s];
      var sc = scores[id];
      entries.push({ id: id, score: sc, name: id, label: sc + ' pts' });
    }

    return _rankEntries(entries);
  }

  function getGuildRankings(guildData, options) {
    options = options || {};
    var metric = options.metric || 'composite';

    if (!guildData) return [];

    var guilds = Array.isArray(guildData) ? guildData : (guildData.guilds || []);
    if (!Array.isArray(guilds)) return [];

    var entries = [];
    for (var i = 0; i < guilds.length; i++) {
      var g = guilds[i];
      if (!g || !g.id) continue;
      var level = _safeInt(g.level) || 1;
      var xp = _safeInt(g.xp);
      var memberCount = Array.isArray(g.members) ? g.members.length : _safeInt(g.members);
      var treasury = _safeInt(g.treasury);

      var score;
      switch (metric) {
        case 'xp':
          score = xp;
          break;
        case 'members':
          score = memberCount;
          break;
        case 'treasury':
          score = treasury;
          break;
        default: // composite
          score = (level * 1000) + xp;
      }

      entries.push({
        id: g.id,
        score: score,
        name: g.name || g.id,
        tag: g.tag || '',
        level: level,
        xp: xp,
        memberCount: memberCount,
        label: 'Level ' + level + ' Â· ' + xp + ' XP'
      });
    }

    return _rankEntries(entries);
  }

  function getReputationRankings(socialData, options) {
    options = options || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var cutoff = _timeCutoff(period);

    if (!socialData) return [];

    var entries = [];

    function _processRep(pid, repData) {
      if (!_validId(pid)) return;
      var score;
      if (cutoff > 0 && repData.history) {
        score = 0;
        var hist = repData.history;
        for (var h = 0; h < hist.length; h++) {
          var entry = hist[h];
          if (entry.timestamp && entry.timestamp >= cutoff && entry.change > 0) {
            score += entry.change;
          }
        }
      } else {
        score = _safeInt(repData.score);
      }
      var tier = repData.tier || 'Newcomer';
      entries.push({
        id: pid,
        score: score,
        name: pid,
        tier: tier,
        label: tier + ' (' + score + ')'
      });
    }

    if (Array.isArray(socialData)) {
      for (var i = 0; i < socialData.length; i++) {
        var item = socialData[i];
        _processRep(item.playerId || item.id, item);
      }
    } else if (typeof socialData === 'object') {
      var keys = Object.keys(socialData);
      for (var k = 0; k < keys.length; k++) {
        _processRep(keys[k], socialData[keys[k]]);
      }
    }

    return _rankEntries(entries);
  }

  function getCombinedRankings(data, options) {
    options = options || {};
    data = data || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var weights = options.weights || COMBINED_WEIGHTS;

    var wealthRaw = getWealthRankings(data.economy || {}, { period: period });
    var questsRaw = getQuestRankings(data.quests || {}, { period: period });
    var exploreRaw = getExplorationRankings(data.discoveries || [], { period: period });
    var repRaw = getReputationRankings(data.reputation || {}, { period: period });

    var wealthNorm = _normalise(wealthRaw);
    var questsNorm = _normalise(questsRaw);
    var exploreNorm = _normalise(exploreRaw);
    var repNorm = _normalise(repRaw);

    var allIds = {};
    function _addIds(arr) {
      for (var i = 0; i < arr.length; i++) allIds[arr[i].id] = true;
    }
    _addIds(wealthNorm);
    _addIds(questsNorm);
    _addIds(exploreNorm);
    _addIds(repNorm);

    function _buildMap(arr) {
      var m = {};
      for (var i = 0; i < arr.length; i++) m[arr[i].id] = arr[i].normScore || 0;
      return m;
    }

    var wMap = _buildMap(wealthNorm);
    var qMap = _buildMap(questsNorm);
    var eMap = _buildMap(exploreNorm);
    var rMap = _buildMap(repNorm);

    var w = {
      wealth: weights.wealth || COMBINED_WEIGHTS.wealth,
      quests: weights.quests || COMBINED_WEIGHTS.quests,
      exploration: weights.exploration || COMBINED_WEIGHTS.exploration,
      reputation: weights.reputation || COMBINED_WEIGHTS.reputation
    };

    var entries = [];
    var ids = Object.keys(allIds);
    for (var i = 0; i < ids.length; i++) {
      var pid = ids[i];
      var combined =
        (wMap[pid] || 0) * w.wealth +
        (qMap[pid] || 0) * w.quests +
        (eMap[pid] || 0) * w.exploration +
        (rMap[pid] || 0) * w.reputation;

      entries.push({
        id: pid,
        score: Math.round(combined * 10) / 10, // one decimal place
        name: pid,
        breakdown: {
          wealth: Math.round((wMap[pid] || 0) * 10) / 10,
          quests: Math.round((qMap[pid] || 0) * 10) / 10,
          exploration: Math.round((eMap[pid] || 0) * 10) / 10,
          reputation: Math.round((rMap[pid] || 0) * 10) / 10
        },
        label: Math.round(combined * 10) / 10 + ' pts'
      });
    }

    return _rankEntries(entries);
  }

  function getPlayerRank(playerId, category, data, options) {
    if (!_validId(playerId)) return null;

    var rankings = [];

    switch (category) {
      case CATEGORIES.WEALTH:
        rankings = getWealthRankings(data, options);
        break;
      case CATEGORIES.QUESTS:
        rankings = getQuestRankings(data, options);
        break;
      case CATEGORIES.EXPLORATION:
        rankings = getExplorationRankings(data, options);
        break;
      case CATEGORIES.GUILDS:
        rankings = getGuildRankings(data, options);
        break;
      case CATEGORIES.REPUTATION:
        rankings = getReputationRankings(data, options);
        break;
      case CATEGORIES.COMBINED:
        rankings = getCombinedRankings(data, options);
        break;
      default:
        return null;
    }

    for (var i = 0; i < rankings.length; i++) {
      if (rankings[i].id === playerId) {
        return {
          rank: rankings[i].rank,
          score: rankings[i].score,
          total: rankings.length,
          label: rankings[i].label || '',
          category: category,
          entry: rankings[i]
        };
      }
    }

    return {
      rank: null,
      score: 0,
      total: rankings.length,
      label: 'Unranked',
      category: category,
      entry: null
    };
  }

  function formatLeaderboard(rankings, options) {
    options = options || {};
    var count = options.count || 10;
    var highlightId = options.highlightId || null;
    var showBreakdown = !!options.showBreakdown;

    if (!rankings || !Array.isArray(rankings)) return [];

    var allowed = options.allowedCounts || DEFAULT_DISPLAY_COUNTS;
    if (allowed.indexOf(count) === -1) {
      count = allowed.reduce(function(prev, curr) {
        return Math.abs(curr - count) < Math.abs(prev - count) ? curr : prev;
      }, allowed[0]);
    }

    var slice = rankings.slice(0, count);

    return slice.map(function(entry, idx) {
      var row = {
        rank: entry.rank,
        id: entry.id,
        name: entry.name || entry.id,
        score: entry.score,
        label: entry.label || String(entry.score),
        isHighlighted: highlightId ? entry.id === highlightId : false
      };

      if (entry.tier) row.tier = entry.tier;
      if (entry.tag) row.tag = entry.tag;
      if (entry.level !== undefined) row.level = entry.level;
      if (entry.memberCount !== undefined) row.memberCount = entry.memberCount;

      if (showBreakdown && entry.breakdown) {
        row.breakdown = entry.breakdown;
      }

      return row;
    });
  }

  function getTimePeriodLabel(period) {
    switch (period) {
      case TIME_PERIODS.DAILY: return 'Today';
      case TIME_PERIODS.WEEKLY: return 'This Week';
      default: return 'All Time';
    }
  }

  function getTimePeriods() {
    return [
      { id: TIME_PERIODS.ALL_TIME, label: 'All Time' },
      { id: TIME_PERIODS.DAILY, label: 'Today' },
      { id: TIME_PERIODS.WEEKLY, label: 'This Week' }
    ];
  }

  function buildSnapshot(gameData, options) {
    options = options || {};
    gameData = gameData || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var count = options.count || 10;
    var periodOpts = { period: period };

    var wealthRaw = getWealthRankings(gameData.economy || {}, periodOpts);
    var questsRaw = getQuestRankings(gameData.quests || {}, periodOpts);
    var exploreRaw = getExplorationRankings(gameData.discoveries || [], periodOpts);
    var guildsRaw = getGuildRankings(gameData.guilds || [], periodOpts);
    var repRaw = getReputationRankings(gameData.reputation || {}, periodOpts);
    var combinedRaw = getCombinedRankings(gameData, periodOpts);

    var fmtOpts = { count: count, allowedCounts: [count] };

    return {
      wealth: formatLeaderboard(wealthRaw, fmtOpts),
      quests: formatLeaderboard(questsRaw, fmtOpts),
      exploration: formatLeaderboard(exploreRaw, fmtOpts),
      guilds: formatLeaderboard(guildsRaw, fmtOpts),
      reputation: formatLeaderboard(repRaw, fmtOpts),
      combined: formatLeaderboard(combinedRaw, Object.assign({}, fmtOpts, { showBreakdown: true })),
      meta: {
        period: period,
        periodLabel: getTimePeriodLabel(period),
        count: count,
        generatedAt: _now()
      }
    };
  }

  exports.CATEGORIES = CATEGORIES;
  exports.TIME_PERIODS = TIME_PERIODS;
  exports.COMBINED_WEIGHTS = COMBINED_WEIGHTS;

  exports.getWealthRankings = getWealthRankings;
  exports.getQuestRankings = getQuestRankings;
  exports.getExplorationRankings = getExplorationRankings;
  exports.getGuildRankings = getGuildRankings;
  exports.getReputationRankings = getReputationRankings;
  exports.getCombinedRankings = getCombinedRankings;

  exports.getPlayerRank = getPlayerRank;
  exports.formatLeaderboard = formatLeaderboard;

  exports.getTimePeriodLabel = getTimePeriodLabel;
  exports.getTimePeriods = getTimePeriods;
  exports.buildSnapshot = buildSnapshot;

  exports._rankEntries = _rankEntries;
  exports._normalise = _normalise;
  exports._timeCutoff = _timeCutoff;
  exports._setNowFn = _setNowFn;
  exports._clamp = _clamp;
  exports._safeInt = _safeInt;

})(typeof module !== 'undefined' ? module.exports : (window.Leaderboards = {}));


// notifications.js

(function(exports) {
  'use strict';

  var NOTIFICATION_TYPES = {
    economy:     'economy',
    achievement: 'achievement',
    social:      'social',
    system:      'system',
    quest:       'quest',
    combat:      'combat'
  };

  var PRIORITY_LEVELS = {
    low:      0,
    normal:   1,
    high:     2,
    critical: 3
  };

  var DEFAULT_DURATIONS = {
    low:      3000,
    normal:   4500,
    high:     7000,
    critical: 0     // 0 = persist until manually dismissed
  };

  var TYPE_META = {
    economy:     { icon: 'ðŸ’°', color: '#f1c40f', label: 'Economy' },
    achievement: { icon: 'ðŸ†', color: '#e67e22', label: 'Achievement' },
    social:      { icon: 'ðŸ’¬', color: '#3498db', label: 'Social' },
    system:      { icon: 'âš™ï¸',  color: '#95a5a6', label: 'System' },
    quest:       { icon: 'ðŸ“œ', color: '#9b59b6', label: 'Quest' },
    combat:      { icon: 'âš”ï¸',  color: '#e74c3c', label: 'Combat' }
  };

  var TYPE_SOUNDS = {
    economy:     'chime_coin',
    achievement: 'fanfare_achievement',
    social:      'ping_social',
    system:      'blip_system',
    quest:       'fanfare_quest',
    combat:      'alert_combat'
  };

  var MAX_HISTORY = 200;
  var DEFAULT_MAX_VISIBLE = 5;
  var DEFAULT_GROUPING_WINDOW = 2000; // ms â€” collapse repeated messages within this window

  var _idCounter = 0;
  var _toastQueue = [];       // Active toasts (visible)
  var _pendingQueue = [];     // Overflow toasts waiting for a slot
  var _history = [];          // All notifications ever created

  var _prefs = {
    mutedTypes:     {},       // { economy: true, ... }
    durations:      {},       // override durations per type
    maxVisible:     DEFAULT_MAX_VISIBLE,
    groupingWindow: DEFAULT_GROUPING_WINDOW,
    enabled:        true
  };

  function _now() {
    return (typeof Date !== 'undefined') ? Date.now() : 0;
  }

  function _nextId() {
    _idCounter += 1;
    return 'notif_' + _idCounter;
  }

  function _isValidType(type) {
    return Object.prototype.hasOwnProperty.call(NOTIFICATION_TYPES, type);
  }

  function _isValidPriority(priority) {
    return Object.prototype.hasOwnProperty.call(PRIORITY_LEVELS, priority);
  }

  function _resolveDuration(type, priority, options) {
    if (options && typeof options.duration === 'number') {
      return options.duration;
    }
    if (_prefs.durations && typeof _prefs.durations[type] === 'number') {
      return _prefs.durations[type];
    }
    return DEFAULT_DURATIONS[priority];
  }

  function _findGroupable(type, message) {
    var now = _now();
    var window = _prefs.groupingWindow;
    for (var i = 0; i < _toastQueue.length; i++) {
      var t = _toastQueue[i];
      if (t.type === type && t.message === message) {
        if (now - t.createdAt <= window) {
          return t;
        }
      }
    }
    return null;
  }

  function _findGroupableInPending(type, message) {
    var now = _now();
    var window = _prefs.groupingWindow;
    for (var i = 0; i < _pendingQueue.length; i++) {
      var t = _pendingQueue[i];
      if (t.type === type && t.message === message) {
        if (now - t.createdAt <= window) {
          return t;
        }
      }
    }
    return null;
  }

  function createNotification(type, message, options) {
    if (!_isValidType(type)) {
      throw new Error('Unknown notification type: ' + type);
    }

    options = options || {};

    var priority = options.priority || 'normal';
    if (!_isValidPriority(priority)) {
      throw new Error('Unknown priority level: ' + priority);
    }

    var duration = _resolveDuration(type, priority, options);

    var notification = {
      id:         _nextId(),
      type:       type,
      message:    String(message),
      priority:   priority,
      duration:   duration,
      groupable:  options.groupable !== false, // default true
      groupCount: 1,
      data:       options.data || null,
      createdAt:  _now(),
      dismissedAt: null,
      expired:    false
    };

    return notification;
  }

  function addNotification(type, message, options) {
    if (!_prefs.enabled) return null;
    if (_prefs.mutedTypes && _prefs.mutedTypes[type]) return null;

    if (!_isValidType(type)) return null;

    options = options || {};

    if (options.groupable !== false) {
      var existing = _findGroupable(type, message);
      if (!existing) {
        existing = _findGroupableInPending(type, message);
      }
      if (existing) {
        existing.groupCount += 1;
        existing.createdAt = _now(); // bump timestamp so it refreshes
        return existing;
      }
    }

    var notif = createNotification(type, message, options);

    _history.unshift(notif);
    if (_history.length > MAX_HISTORY) {
      _history.length = MAX_HISTORY;
    }

    var maxVisible = (_prefs.maxVisible > 0) ? _prefs.maxVisible : DEFAULT_MAX_VISIBLE;
    if (_toastQueue.length < maxVisible) {
      _toastQueue.push(notif);
    } else {
      _pendingQueue.push(notif);
    }

    return notif;
  }

  function tick() {
    var now = _now();
    var maxVisible = (_prefs.maxVisible > 0) ? _prefs.maxVisible : DEFAULT_MAX_VISIBLE;

    for (var i = _toastQueue.length - 1; i >= 0; i--) {
      var t = _toastQueue[i];
      if (t.duration > 0 && (now - t.createdAt) >= t.duration) {
        t.expired = true;
        _toastQueue.splice(i, 1);
      }
    }

    while (_toastQueue.length < maxVisible && _pendingQueue.length > 0) {
      var next = _pendingQueue.shift();
      next.createdAt = _now();
      _toastQueue.push(next);
    }
  }

  function getActiveToasts() {
    var sorted = _toastQueue.slice().sort(function(a, b) {
      var pDiff = PRIORITY_LEVELS[b.priority] - PRIORITY_LEVELS[a.priority];
      if (pDiff !== 0) return pDiff;
      return a.createdAt - b.createdAt;
    });
    return sorted;
  }

  function getNotificationHistory(limit) {
    limit = (typeof limit === 'number' && limit > 0) ? limit : 50;
    return _history.slice(0, limit);
  }

  function dismissToast(id) {
    var now = _now();

    for (var i = 0; i < _toastQueue.length; i++) {
      if (_toastQueue[i].id === id) {
        _toastQueue[i].dismissedAt = now;
        _toastQueue[i].expired = true;
        _toastQueue.splice(i, 1);
        tick();
        return true;
      }
    }

    for (var j = 0; j < _pendingQueue.length; j++) {
      if (_pendingQueue[j].id === id) {
        _pendingQueue[j].dismissedAt = now;
        _pendingQueue[j].expired = true;
        _pendingQueue.splice(j, 1);
        return true;
      }
    }

    return false;
  }

  function dismissAll() {
    var now = _now();
    var i;
    for (i = 0; i < _toastQueue.length; i++) {
      _toastQueue[i].dismissedAt = now;
      _toastQueue[i].expired = true;
    }
    for (i = 0; i < _pendingQueue.length; i++) {
      _pendingQueue[i].dismissedAt = now;
      _pendingQueue[i].expired = true;
    }
    _toastQueue = [];
    _pendingQueue = [];
  }

  function setPreferences(prefs) {
    if (!prefs || typeof prefs !== 'object') return;

    if (typeof prefs.enabled === 'boolean') {
      _prefs.enabled = prefs.enabled;
    }
    if (typeof prefs.maxVisible === 'number' && prefs.maxVisible > 0) {
      _prefs.maxVisible = prefs.maxVisible;
    }
    if (typeof prefs.groupingWindow === 'number' && prefs.groupingWindow >= 0) {
      _prefs.groupingWindow = prefs.groupingWindow;
    }
    if (prefs.mutedTypes && typeof prefs.mutedTypes === 'object') {
      var mt = prefs.mutedTypes;
      for (var k in mt) {
        if (Object.prototype.hasOwnProperty.call(mt, k)) {
          if (mt[k]) {
            _prefs.mutedTypes[k] = true;
          } else {
            delete _prefs.mutedTypes[k];
          }
        }
      }
    }
    if (prefs.durations && typeof prefs.durations === 'object') {
      var d = prefs.durations;
      for (var key in d) {
        if (Object.prototype.hasOwnProperty.call(d, key)) {
          if (typeof d[key] === 'number') {
            _prefs.durations[key] = d[key];
          }
        }
      }
    }
  }

  function formatNotification(notification) {
    if (!notification) return null;

    var meta = TYPE_META[notification.type] || { icon: 'ðŸ””', color: '#ffffff', label: 'Notice' };
    var sound = TYPE_SOUNDS[notification.type] || 'blip_system';

    var badgeText = null;
    if (notification.groupCount && notification.groupCount > 1) {
      badgeText = 'x' + notification.groupCount;
    }

    var formattedMessage = notification.message;

    return {
      id:               notification.id,
      type:             notification.type,
      priority:         notification.priority,
      icon:             meta.icon,
      color:            meta.color,
      label:            meta.label,
      formattedMessage: formattedMessage,
      soundHint:        sound,
      badgeText:        badgeText,
      groupCount:       notification.groupCount || 1,
      duration:         notification.duration,
      createdAt:        notification.createdAt
    };
  }

  function getSoundHint(type) {
    return TYPE_SOUNDS[type] || 'blip_system';
  }

  function getPreferences() {
    return {
      mutedTypes:      JSON.parse(JSON.stringify(_prefs.mutedTypes)),
      durations:       JSON.parse(JSON.stringify(_prefs.durations)),
      maxVisible:      _prefs.maxVisible,
      groupingWindow:  _prefs.groupingWindow,
      enabled:         _prefs.enabled
    };
  }

  function getPendingCount() {
    return _pendingQueue.length;
  }

  function reset() {
    _idCounter = 0;
    _toastQueue = [];
    _pendingQueue = [];
    _history = [];
    _prefs = {
      mutedTypes:     {},
      durations:      {},
      maxVisible:     DEFAULT_MAX_VISIBLE,
      groupingWindow: DEFAULT_GROUPING_WINDOW,
      enabled:        true
    };
  }

  exports.NOTIFICATION_TYPES  = NOTIFICATION_TYPES;
  exports.PRIORITY_LEVELS     = PRIORITY_LEVELS;
  exports.DEFAULT_DURATIONS   = DEFAULT_DURATIONS;
  exports.TYPE_META           = TYPE_META;
  exports.TYPE_SOUNDS         = TYPE_SOUNDS;

  exports.createNotification      = createNotification;
  exports.addNotification         = addNotification;
  exports.tick                    = tick;
  exports.getActiveToasts         = getActiveToasts;
  exports.getNotificationHistory  = getNotificationHistory;
  exports.dismissToast            = dismissToast;
  exports.dismissAll              = dismissAll;
  exports.setPreferences          = setPreferences;
  exports.getPreferences          = getPreferences;
  exports.formatNotification      = formatNotification;
  exports.getSoundHint            = getSoundHint;
  exports.getPendingCount         = getPendingCount;
  exports.reset                   = reset;

})(typeof module !== 'undefined' ? module.exports : (window.Notifications = {}));


// badges.js

(function(exports) {
  'use strict';

  var BADGE_CATALOG = {

    badge_first_steps: {
      id: 'badge_first_steps',
      name: 'First Steps',
      description: 'Entered ZION for the first time',
      icon: 'ðŸ‘£',
      rarity: 'common',
      category: 'exploration',
      achievementId: 'first_steps',
      points: 1
    },
    badge_zone_hopper: {
      id: 'badge_zone_hopper',
      name: 'Zone Hopper',
      description: 'Visited 4 different zones of ZION',
      icon: 'ðŸš¶',
      rarity: 'common',
      category: 'exploration',
      achievementId: 'zone_hopper',
      points: 1
    },
    badge_world_traveler: {
      id: 'badge_world_traveler',
      name: 'World Traveler',
      description: 'Explored all 8 zones of ZION',
      icon: 'ðŸŒ',
      rarity: 'rare',
      category: 'exploration',
      achievementId: 'world_traveler',
      points: 5
    },
    badge_trailblazer: {
      id: 'badge_trailblazer',
      name: 'Trailblazer',
      description: 'Made 10 discoveries across ZION',
      icon: 'ðŸ”',
      rarity: 'uncommon',
      category: 'exploration',
      achievementId: 'trailblazer',
      points: 2
    },
    badge_cartographer: {
      id: 'badge_cartographer',
      name: 'Cartographer',
      description: 'Made 25 discoveries â€” a true mapmaker',
      icon: 'ðŸ—ºï¸',
      rarity: 'rare',
      category: 'exploration',
      achievementId: 'cartographer',
      points: 5
    },

    badge_friendly_face: {
      id: 'badge_friendly_face',
      name: 'Friendly Face',
      description: 'Talked to 10 citizens of ZION',
      icon: 'ðŸ˜Š',
      rarity: 'common',
      category: 'social',
      achievementId: 'friendly_face',
      points: 1
    },
    badge_social_butterfly: {
      id: 'badge_social_butterfly',
      name: 'Social Butterfly',
      description: 'Talked to 50 citizens â€” a beloved community member',
      icon: 'ðŸ¦‹',
      rarity: 'uncommon',
      category: 'social',
      achievementId: 'social_butterfly',
      points: 2
    },
    badge_first_trade: {
      id: 'badge_first_trade',
      name: 'First Trade',
      description: 'Completed a trade with another citizen',
      icon: 'ðŸ¤',
      rarity: 'common',
      category: 'social',
      achievementId: 'first_trade',
      points: 1
    },
    badge_merchant_prince: {
      id: 'badge_merchant_prince',
      name: 'Merchant Prince',
      description: 'Completed 25 trades â€” a pillar of commerce',
      icon: 'ðŸ‘‘',
      rarity: 'epic',
      category: 'social',
      achievementId: 'merchant_prince',
      points: 10
    },
    badge_gift_giver: {
      id: 'badge_gift_giver',
      name: 'Gift Giver',
      description: 'Gifted an item to a fellow citizen',
      icon: 'ðŸŽ',
      rarity: 'common',
      category: 'social',
      achievementId: 'gift_giver',
      points: 1
    },
    badge_guild_founder: {
      id: 'badge_guild_founder',
      name: 'Guild Founder',
      description: 'Founded a guild in ZION',
      icon: 'ðŸ°',
      rarity: 'rare',
      category: 'social',
      achievementId: 'guild_founder',
      points: 5
    },
    badge_guild_member: {
      id: 'badge_guild_member',
      name: 'Guild Member',
      description: 'Joined a guild â€” strength in unity',
      icon: 'ðŸ¤œ',
      rarity: 'common',
      category: 'social',
      achievementId: 'guild_member',
      points: 1
    },

    badge_spark_saver: {
      id: 'badge_spark_saver',
      name: 'Spark Saver',
      description: 'Accumulated 100 Spark',
      icon: 'âœ¨',
      rarity: 'common',
      category: 'economic',
      achievementId: 'spark_saver',
      points: 1
    },
    badge_spark_hoarder: {
      id: 'badge_spark_hoarder',
      name: 'Spark Hoarder',
      description: 'Accumulated 500 Spark â€” a prosperous citizen',
      icon: 'ðŸ’°',
      rarity: 'uncommon',
      category: 'economic',
      achievementId: 'spark_hoarder',
      points: 2
    },
    badge_spark_magnate: {
      id: 'badge_spark_magnate',
      name: 'Spark Magnate',
      description: 'Accumulated 2000 Spark â€” an economic powerhouse',
      icon: 'ðŸ’Ž',
      rarity: 'epic',
      category: 'economic',
      achievementId: 'spark_magnate',
      points: 10
    },

    badge_first_craft: {
      id: 'badge_first_craft',
      name: 'First Craft',
      description: 'Crafted your first item',
      icon: 'ðŸ”¨',
      rarity: 'common',
      category: 'creative',
      achievementId: 'first_craft',
      points: 1
    },
    badge_apprentice_crafter: {
      id: 'badge_apprentice_crafter',
      name: 'Apprentice Crafter',
      description: 'Crafted 10 items â€” a skilled hand emerges',
      icon: 'âš’ï¸',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'apprentice_crafter',
      points: 2
    },
    badge_master_crafter: {
      id: 'badge_master_crafter',
      name: 'Master Crafter',
      description: 'Crafted 50 items â€” the forge is your home',
      icon: 'ðŸ› ï¸',
      rarity: 'rare',
      category: 'creative',
      achievementId: 'master_crafter',
      points: 5
    },
    badge_potion_brewer: {
      id: 'badge_potion_brewer',
      name: 'Potion Brewer',
      description: 'Brewed 10 potions â€” alchemy mastered',
      icon: 'ðŸ§ª',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'potion_brewer',
      points: 2
    },
    badge_instrument_maker: {
      id: 'badge_instrument_maker',
      name: 'Instrument Maker',
      description: 'Crafted a musical instrument â€” music fills the air',
      icon: 'ðŸŽµ',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'instrument_maker',
      points: 2
    },
    badge_first_build: {
      id: 'badge_first_build',
      name: 'First Build',
      description: 'Placed your first structure in ZION',
      icon: 'ðŸ—ï¸',
      rarity: 'common',
      category: 'creative',
      achievementId: 'first_build',
      points: 1
    },
    badge_architect: {
      id: 'badge_architect',
      name: 'Architect',
      description: 'Placed 10 structures â€” shaping the world',
      icon: 'ðŸ›ï¸',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'architect',
      points: 2
    },
    badge_city_planner: {
      id: 'badge_city_planner',
      name: 'City Planner',
      description: 'Placed 50 structures â€” an urban visionary',
      icon: 'ðŸ™ï¸',
      rarity: 'epic',
      category: 'creative',
      achievementId: 'city_planner',
      points: 10
    },
    badge_green_thumb: {
      id: 'badge_green_thumb',
      name: 'Green Thumb',
      description: 'Planted your first seed',
      icon: 'ðŸŒ±',
      rarity: 'common',
      category: 'creative',
      achievementId: 'green_thumb',
      points: 1
    },
    badge_gardener: {
      id: 'badge_gardener',
      name: 'Gardener',
      description: 'Harvested 20 plants â€” the Gardens bloom for you',
      icon: 'ðŸŒ»',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'gardener',
      points: 2
    },
    badge_botanist: {
      id: 'badge_botanist',
      name: 'Botanist',
      description: 'Harvested 100 plants â€” ZION\'s foremost naturalist',
      icon: 'ðŸŒ¿',
      rarity: 'rare',
      category: 'creative',
      achievementId: 'botanist',
      points: 5
    },
    badge_first_artwork: {
      id: 'badge_first_artwork',
      name: 'First Artwork',
      description: 'Created your first artwork',
      icon: 'ðŸŽ¨',
      rarity: 'common',
      category: 'creative',
      achievementId: 'first_artwork',
      points: 1
    },
    badge_prolific_artist: {
      id: 'badge_prolific_artist',
      name: 'Prolific Artist',
      description: 'Created 10 artworks â€” a true visionary',
      icon: 'ðŸ–¼ï¸',
      rarity: 'rare',
      category: 'creative',
      achievementId: 'prolific_artist',
      points: 5
    },

    badge_first_challenge: {
      id: 'badge_first_challenge',
      name: 'First Challenge',
      description: 'Participated in your first competition',
      icon: 'âš”ï¸',
      rarity: 'common',
      category: 'combat',
      achievementId: 'first_challenge',
      points: 1
    },
    badge_champion: {
      id: 'badge_champion',
      name: 'Champion',
      description: 'Won 5 competitions â€” glory to the victor',
      icon: 'ðŸ†',
      rarity: 'epic',
      category: 'combat',
      achievementId: 'champion',
      points: 10
    },

    badge_quest_starter: {
      id: 'badge_quest_starter',
      name: 'Quest Starter',
      description: 'Accepted your first quest',
      icon: 'ðŸ“‹',
      rarity: 'common',
      category: 'mastery',
      achievementId: 'quest_starter',
      points: 1
    },
    badge_questmaster: {
      id: 'badge_questmaster',
      name: 'Questmaster',
      description: 'Completed 10 quests â€” a seasoned adventurer',
      icon: 'ðŸ“œ',
      rarity: 'uncommon',
      category: 'mastery',
      achievementId: 'questmaster',
      points: 2
    },
    badge_completionist: {
      id: 'badge_completionist',
      name: 'Completionist',
      description: 'Completed 25 quests â€” nothing left undone',
      icon: 'â­',
      rarity: 'legendary',
      category: 'mastery',
      achievementId: 'completionist',
      points: 25
    },
    badge_chain_finisher: {
      id: 'badge_chain_finisher',
      name: 'Chain Finisher',
      description: 'Completed an entire quest chain',
      icon: 'ðŸ”—',
      rarity: 'rare',
      category: 'mastery',
      achievementId: 'chain_finisher',
      points: 5
    },
    badge_sunwalker: {
      id: 'badge_sunwalker',
      name: 'Sunwalker',
      description: 'Reached the Sunwalker warmth tier â€” radiant and warm',
      icon: 'â˜€ï¸',
      rarity: 'legendary',
      category: 'mastery',
      achievementId: 'sunwalker',
      points: 25
    },
    badge_first_lesson: {
      id: 'badge_first_lesson',
      name: 'First Lesson',
      description: 'Completed a mentoring lesson',
      icon: 'ðŸ“š',
      rarity: 'common',
      category: 'mastery',
      achievementId: 'first_lesson',
      points: 1
    },
    badge_wise_mentor: {
      id: 'badge_wise_mentor',
      name: 'Wise Mentor',
      description: 'Mentored 5 players â€” wisdom shared is wisdom multiplied',
      icon: 'ðŸŽ“',
      rarity: 'epic',
      category: 'mastery',
      achievementId: 'wise_mentor',
      points: 10
    }
  };

  var COSMETIC_REWARDS = {
    badge_world_traveler: {
      type: 'name_color',
      value: '#4a90e2',
      label: 'Traveler Blue',
      description: 'Your name glows in explorer blue'
    },
    badge_cartographer: {
      type: 'trail_effect',
      value: 'map_dots',
      label: 'Cartographer Trail',
      description: 'Leave a trail of glowing map dots as you walk'
    },

    badge_merchant_prince: {
      type: 'name_color',
      value: '#f5a623',
      label: 'Merchant Gold',
      description: 'Your name shimmers in merchant gold'
    },
    badge_social_butterfly: {
      type: 'aura_effect',
      value: 'butterfly_wings',
      label: 'Butterfly Aura',
      description: 'Glowing butterfly wings flutter around you'
    },

    badge_spark_magnate: {
      type: 'aura_effect',
      value: 'spark_aura',
      label: 'Spark Aura',
      description: 'Sparks swirl around your form'
    },
    badge_spark_hoarder: {
      type: 'trail_effect',
      value: 'coin_trail',
      label: 'Coin Trail',
      description: 'Leave a trail of gleaming coins'
    },

    badge_master_crafter: {
      type: 'aura_effect',
      value: 'forge_glow',
      label: 'Forge Glow',
      description: 'An orange forge-light aura surrounds you'
    },
    badge_city_planner: {
      type: 'name_color',
      value: '#7ed321',
      label: 'Builder Green',
      description: 'Your name gleams in architect green'
    },
    badge_botanist: {
      type: 'trail_effect',
      value: 'petal_trail',
      label: 'Petal Trail',
      description: 'Flower petals drift behind you as you walk'
    },
    badge_prolific_artist: {
      type: 'aura_effect',
      value: 'paint_splash',
      label: 'Artist Aura',
      description: 'Colorful paint splashes swirl around you'
    },

    badge_champion: {
      type: 'name_color',
      value: '#e74c3c',
      label: 'Champion Red',
      description: 'Your name blazes in champion crimson'
    },
    badge_first_challenge: {
      type: 'trail_effect',
      value: 'arena_sparks',
      label: 'Arena Sparks',
      description: 'Sparks fly from your footsteps'
    },

    badge_completionist: {
      type: 'aura_effect',
      value: 'star_burst',
      label: 'Star Burst Aura',
      description: 'Golden stars radiate from your body'
    },
    badge_sunwalker: {
      type: 'aura_effect',
      value: 'solar_halo',
      label: 'Solar Halo',
      description: 'A blazing solar halo crowns your head'
    },
    badge_wise_mentor: {
      type: 'name_color',
      value: '#9b59b6',
      label: 'Mentor Purple',
      description: 'Your name glows in wise mentor purple'
    },
    badge_questmaster: {
      type: 'trail_effect',
      value: 'scroll_trail',
      label: 'Scroll Trail',
      description: 'Ancient scrolls flutter in your wake'
    }
  };

  var RARITY_CONFIG = {
    common:    { color: '#9e9e9e', label: 'Common',    points: 1  },
    uncommon:  { color: '#4caf50', label: 'Uncommon',  points: 2  },
    rare:      { color: '#2196f3', label: 'Rare',      points: 5  },
    epic:      { color: '#9c27b0', label: 'Epic',      points: 10 },
    legendary: { color: '#ff9800', label: 'Legendary', points: 25 }
  };

  var COLLECTOR_TIERS = [
    { minPoints: 0,   level: 0, title: 'Newcomer',     color: '#9e9e9e' },
    { minPoints: 5,   level: 1, title: 'Collector',    color: '#4caf50' },
    { minPoints: 15,  level: 2, title: 'Enthusiast',   color: '#2196f3' },
    { minPoints: 35,  level: 3, title: 'Connoisseur',  color: '#9c27b0' },
    { minPoints: 75,  level: 4, title: 'Curator',      color: '#ff9800' },
    { minPoints: 150, level: 5, title: 'Archivist',    color: '#f44336' },
    { minPoints: 300, level: 6, title: 'Legendary Collector', color: '#ffd700' }
  ];

  var playerDisplayBadges = {}; // playerId -> badgeId

  function getBadgesForPlayer(playerId, achievements) {
    var unlockedSet;
    if (achievements instanceof Set) {
      unlockedSet = achievements;
    } else if (Array.isArray(achievements)) {
      unlockedSet = new Set(achievements);
    } else {
      unlockedSet = new Set();
    }

    var earned = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (unlockedSet.has(badge.achievementId)) {
        earned.push(_withMeta(badge, true));
      }
    }
    return earned;
  }

  function getUnlockedBadges(achievementProgress) {
    var unlockedIds;
    if (!achievementProgress) {
      return [];
    }
    if (achievementProgress.unlocked instanceof Set) {
      unlockedIds = achievementProgress.unlocked;
    } else if (Array.isArray(achievementProgress.unlocked)) {
      unlockedIds = new Set(achievementProgress.unlocked);
    } else {
      unlockedIds = new Set();
    }

    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (unlockedIds.has(badge.achievementId)) {
        result.push(_withMeta(badge, true));
      }
    }
    return result;
  }

  function getLockedBadges(achievementProgress) {
    var unlockedIds;
    if (!achievementProgress) {
      return Object.keys(BADGE_CATALOG).map(function(id) {
        return _withMeta(BADGE_CATALOG[id], false, 0);
      });
    }
    if (achievementProgress.unlocked instanceof Set) {
      unlockedIds = achievementProgress.unlocked;
    } else if (Array.isArray(achievementProgress.unlocked)) {
      unlockedIds = new Set(achievementProgress.unlocked);
    } else {
      unlockedIds = new Set();
    }

    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (!unlockedIds.has(badge.achievementId)) {
        var pct = _computeProgress(badge.achievementId, achievementProgress.counters || {});
        result.push(_withMeta(badge, false, pct));
      }
    }
    return result;
  }

  function getBadgesByCategory(category) {
    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (badge.category === category) {
        result.push(_withMeta(badge, false));
      }
    }
    return result;
  }

  function getBadgesByRarity(rarity) {
    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (badge.rarity === rarity) {
        result.push(_withMeta(badge, false));
      }
    }
    return result;
  }

  function getDisplayBadge(playerId) {
    var badgeId = playerDisplayBadges[playerId];
    if (!badgeId || !BADGE_CATALOG[badgeId]) {
      return null;
    }
    return _withMeta(BADGE_CATALOG[badgeId], true);
  }

  function setDisplayBadge(playerId, badgeId) {
    if (!badgeId) {
      delete playerDisplayBadges[playerId];
      return { success: true, message: 'Display badge cleared' };
    }
    if (!BADGE_CATALOG[badgeId]) {
      return { success: false, message: 'Unknown badge: ' + badgeId };
    }
    playerDisplayBadges[playerId] = badgeId;
    return { success: true, message: 'Display badge set to ' + BADGE_CATALOG[badgeId].name };
  }

  function getNameplateDecoration(playerId, badges) {
    if (!badges || badges.length === 0) {
      return { borderColor: '#9e9e9e', glowColor: null, icon: null, title: null };
    }

    var rarityOrder = ['legendary', 'epic', 'rare', 'uncommon', 'common'];
    var topBadge = null;
    for (var ri = 0; ri < rarityOrder.length; ri++) {
      for (var bi = 0; bi < badges.length; bi++) {
        if (badges[bi].rarity === rarityOrder[ri]) {
          topBadge = badges[bi];
          break;
        }
      }
      if (topBadge) break;
    }

    var displayBadgeId = playerDisplayBadges[playerId];
    if (displayBadgeId && BADGE_CATALOG[displayBadgeId]) {
      topBadge = BADGE_CATALOG[displayBadgeId];
    }

    var rarityColor = getBadgeRarityColor(topBadge.rarity);

    return {
      borderColor: rarityColor,
      glowColor: topBadge.rarity === 'legendary' || topBadge.rarity === 'epic' ? rarityColor : null,
      icon: topBadge.icon,
      title: topBadge.name
    };
  }

  function getCosmeticForBadge(badgeId) {
    return COSMETIC_REWARDS[badgeId] || null;
  }

  function getPlayerCosmetics(playerId, unlockedBadges) {
    if (!unlockedBadges || unlockedBadges.length === 0) return [];
    var cosmetics = [];
    for (var i = 0; i < unlockedBadges.length; i++) {
      var badge = unlockedBadges[i];
      var cosmetic = COSMETIC_REWARDS[badge.id];
      if (cosmetic) {
        cosmetics.push({
          badgeId: badge.id,
          badgeName: badge.name,
          type: cosmetic.type,
          value: cosmetic.value,
          label: cosmetic.label,
          description: cosmetic.description
        });
      }
    }
    return cosmetics;
  }

  function getBadgeRarityColor(rarity) {
    var config = RARITY_CONFIG[rarity];
    return config ? config.color : '#9e9e9e';
  }

  function formatBadgeDisplay(badge) {
    if (!badge) return '';
    var rarityConfig = RARITY_CONFIG[badge.rarity] || RARITY_CONFIG.common;
    return '[' + rarityConfig.label.toUpperCase() + '] ' + badge.icon + ' ' + badge.name + ' â€” ' + badge.description;
  }

  function getTotalBadgePoints(badges) {
    if (!badges || badges.length === 0) return 0;
    var total = 0;
    for (var i = 0; i < badges.length; i++) {
      var badge = badges[i];
      var rarity = badge.rarity || 'common';
      var config = RARITY_CONFIG[rarity];
      total += config ? config.points : 1;
    }
    return total;
  }

  function getCollectorLevel(points) {
    var tier = COLLECTOR_TIERS[0];
    for (var i = COLLECTOR_TIERS.length - 1; i >= 0; i--) {
      if (points >= COLLECTOR_TIERS[i].minPoints) {
        tier = COLLECTOR_TIERS[i];
        break;
      }
    }
    var nextTier = null;
    for (var j = 0; j < COLLECTOR_TIERS.length; j++) {
      if (COLLECTOR_TIERS[j].minPoints > points) {
        nextTier = COLLECTOR_TIERS[j];
        break;
      }
    }
    return {
      level: tier.level,
      title: tier.title,
      color: tier.color,
      minPoints: tier.minPoints,
      nextThreshold: nextTier ? nextTier.minPoints : null,
      pointsToNext: nextTier ? nextTier.minPoints - points : 0
    };
  }

  function _withMeta(badge, unlocked, progressPct) {
    return {
      id: badge.id,
      name: badge.name,
      description: badge.description,
      icon: badge.icon,
      rarity: badge.rarity,
      category: badge.category,
      achievementId: badge.achievementId,
      points: badge.points,
      unlocked: unlocked === true,
      progressPct: progressPct !== undefined ? progressPct : (unlocked ? 100 : 0)
    };
  }

  function _computeProgress(achievementId, counters) {
    var pct = 0;
    switch (achievementId) {
      case 'zone_hopper':
        pct = Math.min(99, Math.round(((counters.zones_visited || 0) / 4) * 100));
        break;
      case 'world_traveler':
        pct = Math.min(99, Math.round(((counters.zones_visited || 0) / 8) * 100));
        break;
      case 'trailblazer':
        pct = Math.min(99, Math.round(((counters.discoveries_made || 0) / 10) * 100));
        break;
      case 'cartographer':
        pct = Math.min(99, Math.round(((counters.discoveries_made || 0) / 25) * 100));
        break;
      case 'friendly_face':
        pct = Math.min(99, Math.round(((counters.npcs_talked || 0) / 10) * 100));
        break;
      case 'social_butterfly':
        pct = Math.min(99, Math.round(((counters.npcs_talked || 0) / 50) * 100));
        break;
      case 'merchant_prince':
        pct = Math.min(99, Math.round(((counters.trades_completed || 0) / 25) * 100));
        break;
      case 'apprentice_crafter':
        pct = Math.min(99, Math.round(((counters.items_crafted || 0) / 10) * 100));
        break;
      case 'master_crafter':
        pct = Math.min(99, Math.round(((counters.items_crafted || 0) / 50) * 100));
        break;
      case 'potion_brewer':
        pct = Math.min(99, Math.round(((counters.potions_brewed || 0) / 10) * 100));
        break;
      case 'architect':
        pct = Math.min(99, Math.round(((counters.structures_placed || 0) / 10) * 100));
        break;
      case 'city_planner':
        pct = Math.min(99, Math.round(((counters.structures_placed || 0) / 50) * 100));
        break;
      case 'gardener':
        pct = Math.min(99, Math.round(((counters.plants_harvested || 0) / 20) * 100));
        break;
      case 'botanist':
        pct = Math.min(99, Math.round(((counters.plants_harvested || 0) / 100) * 100));
        break;
      case 'champion':
        pct = Math.min(99, Math.round(((counters.competitions_won || 0) / 5) * 100));
        break;
      case 'questmaster':
        pct = Math.min(99, Math.round(((counters.quests_completed || 0) / 10) * 100));
        break;
      case 'completionist':
        pct = Math.min(99, Math.round(((counters.quests_completed || 0) / 25) * 100));
        break;
      case 'prolific_artist':
        pct = Math.min(99, Math.round(((counters.artworks_created || 0) / 10) * 100));
        break;
      case 'wise_mentor':
        pct = Math.min(99, Math.round(((counters.players_mentored || 0) / 5) * 100));
        break;
      default:
        pct = 0;
        break;
    }
    return pct;
  }

  exports.BADGE_CATALOG = BADGE_CATALOG;
  exports.COSMETIC_REWARDS = COSMETIC_REWARDS;
  exports.RARITY_CONFIG = RARITY_CONFIG;
  exports.COLLECTOR_TIERS = COLLECTOR_TIERS;
  exports.getBadgesForPlayer = getBadgesForPlayer;
  exports.getUnlockedBadges = getUnlockedBadges;
  exports.getLockedBadges = getLockedBadges;
  exports.getBadgesByCategory = getBadgesByCategory;
  exports.getBadgesByRarity = getBadgesByRarity;
  exports.getDisplayBadge = getDisplayBadge;
  exports.setDisplayBadge = setDisplayBadge;
  exports.getNameplateDecoration = getNameplateDecoration;
  exports.getCosmeticForBadge = getCosmeticForBadge;
  exports.getPlayerCosmetics = getPlayerCosmetics;
  exports.getBadgeRarityColor = getBadgeRarityColor;
  exports.formatBadgeDisplay = formatBadgeDisplay;
  exports.getTotalBadgePoints = getTotalBadgePoints;
  exports.getCollectorLevel = getCollectorLevel;

})(typeof module !== 'undefined' ? module.exports : (window.Badges = {}));


// daily_rewards.js

(function(exports) {
  'use strict';

  var GRACE_PERIOD_HOURS = 36;

  var REWARD_CALENDAR = [
    {
      day: 1,
      label: 'Day 1',
      type: 'spark',
      spark: 5,
      item: null,
      description: '5 Spark to start your journey'
    },
    {
      day: 2,
      label: 'Day 2',
      type: 'item',
      spark: 0,
      item: { id: 'seed_wildflower', count: 3 },
      description: '3 Wildflower Seeds'
    },
    {
      day: 3,
      label: 'Day 3',
      type: 'spark',
      spark: 10,
      item: null,
      description: '10 Spark'
    },
    {
      day: 4,
      label: 'Day 4',
      type: 'item',
      spark: 0,
      item: { id: 'wood_oak', count: 5 },
      description: '5 Oak Wood (crafting material)'
    },
    {
      day: 5,
      label: 'Day 5',
      type: 'spark',
      spark: 15,
      item: null,
      description: '15 Spark'
    },
    {
      day: 6,
      label: 'Day 6',
      type: 'rare_chance',
      spark: 5,
      item: { id: 'crystal_amethyst', count: 1 },
      rareChance: 0.25,
      rareFallbackItem: { id: 'stone_marble', count: 2 },
      description: '5 Spark + chance at Amethyst'
    },
    {
      day: 7,
      label: 'Day 7 (Weekly Bonus)',
      type: 'jackpot',
      spark: 25,
      item: { id: 'potion_wisdom', count: 1 },
      description: '25 Spark + Wisdom Potion'
    }
  ];

  var STREAK_BONUSES = [
    { minStreak: 30, multiplier: 3.0,  label: 'Legendary Streak' },
    { minStreak: 14, multiplier: 2.5,  label: 'Epic Streak' },
    { minStreak: 7,  multiplier: 2.0,  label: 'Great Streak' },
    { minStreak: 3,  multiplier: 1.5,  label: 'Good Streak' },
    { minStreak: 1,  multiplier: 1.0,  label: 'Active' }
  ];

  function dayStart(ts) {
    var d = new Date(ts);
    return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  }

  function daysDiff(tsA, tsB) {
    var msPerDay = 24 * 60 * 60 * 1000;
    return Math.floor((dayStart(tsA) - dayStart(tsB)) / msPerDay);
  }

  function ensureState(playerData) {
    if (!playerData.dailyRewards) {
      playerData.dailyRewards = {
        streak: 0,
        lastClaimTs: null,
        history: [],
        lifetimeSpark: 0,
        lifetimeItems: []
      };
    }
    return playerData;
  }

  function getStreak(playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    if (dr.lastClaimTs === null) {
      return 0;
    }
    var now = Date.now();
    var gracePeriodMs = GRACE_PERIOD_HOURS * 60 * 60 * 1000;
    var elapsed = now - dr.lastClaimTs;
    if (elapsed > gracePeriodMs) {
      return 0;
    }
    return dr.streak;
  }

  function getStreakBonus(streak) {
    for (var i = 0; i < STREAK_BONUSES.length; i++) {
      if (streak >= STREAK_BONUSES[i].minStreak) {
        return {
          multiplier: STREAK_BONUSES[i].multiplier,
          label: STREAK_BONUSES[i].label
        };
      }
    }
    return { multiplier: 1.0, label: 'No Streak' };
  }

  function calculateStreakReward(baseReward, streak) {
    var bonus = getStreakBonus(streak);
    return Math.floor(baseReward * bonus.multiplier);
  }

  function resetStreak(playerData) {
    ensureState(playerData);
    playerData.dailyRewards.streak = 0;
    return playerData;
  }

  function getDailyReward(dayNumber) {
    var index = ((dayNumber - 1) % 7 + 7) % 7;
    return REWARD_CALENDAR[index];
  }

  function getNextReward(playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    var currentStreak = getStreak(playerData);
    var nextDay = currentStreak + 1;
    return getDailyReward(nextDay);
  }

  function getCalendarView(playerData) {
    ensureState(playerData);
    var currentStreak = getStreak(playerData);
    var canClaimNow = canClaim(null, playerData);

    var result = [];
    for (var i = 0; i < 7; i++) {
      var dayNum = i + 1;
      var reward = REWARD_CALENDAR[i];
      var claimed = dayNum <= currentStreak;
      var current = canClaimNow && dayNum === (currentStreak + 1);
      if (!canClaimNow && dayNum === currentStreak) {
        current = true;
        claimed = false; // just claimed
      }
      result.push({
        day: dayNum,
        label: reward.label,
        description: reward.description,
        type: reward.type,
        spark: reward.spark,
        item: reward.item,
        claimed: claimed,
        current: current,
        upcoming: !claimed && !current
      });
    }
    return result;
  }

  function canClaim(playerId, playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    if (dr.lastClaimTs === null) {
      return true;
    }
    var now = Date.now();
    var diff = daysDiff(now, dr.lastClaimTs);
    return diff >= 1;
  }

  function claimDailyReward(playerId, playerData, options) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    var now = (options && options.now) ? options.now : Date.now();

    if (dr.lastClaimTs !== null) {
      var diff = daysDiff(now, dr.lastClaimTs);
      if (diff < 1) {
        return {
          success: false,
          message: 'Already claimed today',
          nextClaimTs: dayStart(dr.lastClaimTs) + 24 * 60 * 60 * 1000
        };
      }
    }

    var gracePeriodMs = GRACE_PERIOD_HOURS * 60 * 60 * 1000;
    var streakContinues = (dr.lastClaimTs === null) ? false :
                          (now - dr.lastClaimTs) <= gracePeriodMs;

    var newStreak;
    if (dr.lastClaimTs === null) {
      newStreak = 1;
    } else if (streakContinues) {
      newStreak = dr.streak + 1;
    } else {
      newStreak = 1;
    }

    var reward = getDailyReward(newStreak);

    var baseSpark = reward.spark || 0;
    var boostedSpark = calculateStreakReward(baseSpark, newStreak);
    var streakBonus = getStreakBonus(newStreak);

    var awardedItem = null;
    if (reward.type === 'rare_chance') {
      var roll = Math.random();
      awardedItem = (roll < reward.rareChance) ? reward.item : reward.rareFallbackItem;
    } else {
      awardedItem = reward.item;
    }

    var claimRecord = {
      ts: now,
      day: newStreak,
      calendarDay: ((newStreak - 1) % 7) + 1,
      spark: boostedSpark,
      baseSpark: baseSpark,
      item: awardedItem,
      streakMultiplier: streakBonus.multiplier,
      streakLabel: streakBonus.label
    };

    dr.streak = newStreak;
    dr.lastClaimTs = now;
    dr.history.push(claimRecord);
    dr.lifetimeSpark += boostedSpark;
    if (awardedItem) {
      dr.lifetimeItems.push({ ts: now, item: awardedItem });
    }

    return {
      success: true,
      reward: {
        spark: boostedSpark,
        baseSpark: baseSpark,
        item: awardedItem,
        description: reward.description
      },
      streakBonus: streakBonus,
      newStreak: newStreak,
      message: 'Reward claimed!'
    };
  }

  function getRewardHistory(playerData, limit) {
    ensureState(playerData);
    var history = playerData.dailyRewards.history;
    var n = (limit === undefined || limit === null) ? 10 : limit;
    var start = Math.max(0, history.length - n);
    return history.slice(start).reverse();
  }

  function getLifetimeRewards(playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    return {
      totalSpark: dr.lifetimeSpark,
      totalItemCount: dr.lifetimeItems.length,
      totalClaims: dr.history.length,
      items: dr.lifetimeItems.slice()
    };
  }

  function formatReward(reward) {
    var parts = [];
    if (reward.spark && reward.spark > 0) {
      parts.push(reward.spark + ' Spark');
    }
    if (reward.baseSpark && reward.baseSpark > 0 && reward.spark !== reward.baseSpark) {
      parts.push(reward.spark + ' Spark (x' + reward.streakMultiplier + ' streak bonus)');
      parts.shift();
    }
    if (reward.item) {
      var itemStr = reward.item.id;
      if (reward.item.count && reward.item.count > 1) {
        itemStr = reward.item.count + 'x ' + reward.item.id;
      }
      parts.push(itemStr);
    }
    if (reward.description && parts.length === 0) {
      return reward.description;
    }
    return parts.length > 0 ? parts.join(' + ') : 'No reward';
  }

  exports.REWARD_CALENDAR = REWARD_CALENDAR;
  exports.STREAK_BONUSES = STREAK_BONUSES;
  exports.GRACE_PERIOD_HOURS = GRACE_PERIOD_HOURS;

  exports.claimDailyReward = claimDailyReward;
  exports.getDailyReward = getDailyReward;
  exports.getStreak = getStreak;
  exports.getStreakBonus = getStreakBonus;
  exports.canClaim = canClaim;
  exports.getNextReward = getNextReward;
  exports.getRewardHistory = getRewardHistory;
  exports.calculateStreakReward = calculateStreakReward;
  exports.resetStreak = resetStreak;
  exports.getCalendarView = getCalendarView;
  exports.formatReward = formatReward;
  exports.getLifetimeRewards = getLifetimeRewards;

  exports._dayStart = dayStart;
  exports._daysDiff = daysDiff;

})(typeof module !== 'undefined' ? module.exports : (window.DailyRewards = {}));


// profiles.js

(function(exports) {
  'use strict';

  var LEVEL_THRESHOLDS = [
    { level: 1,  xpRequired: 0,     title: 'Newcomer' },
    { level: 2,  xpRequired: 100,   title: 'Wanderer' },
    { level: 3,  xpRequired: 300,   title: 'Settler' },
    { level: 4,  xpRequired: 600,   title: 'Explorer' },
    { level: 5,  xpRequired: 1000,  title: 'Adventurer' },
    { level: 6,  xpRequired: 1500,  title: 'Pathfinder' },
    { level: 7,  xpRequired: 2200,  title: 'Veteran' },
    { level: 8,  xpRequired: 3000,  title: 'Champion' },
    { level: 9,  xpRequired: 4000,  title: 'Legend' },
    { level: 10, xpRequired: 5500,  title: 'Elder' },
    { level: 11, xpRequired: 7500,  title: 'Sage' },
    { level: 12, xpRequired: 10000, title: 'Archon' },
    { level: 13, xpRequired: 13000, title: 'Mythic' },
    { level: 14, xpRequired: 17000, title: 'Eternal' },
    { level: 15, xpRequired: 22000, title: 'Transcendent' }
  ];

  var TITLE_LIST = [
    { id: 'the_curious',       name: 'The Curious',       description: 'Asked a question in ZION',            condition: 'first_login' },
    { id: 'the_friendly',      name: 'The Friendly',      description: 'Spoke to 10 citizens',                 condition: 'talk_npcs_10' },
    { id: 'the_explorer',      name: 'The Explorer',      description: 'Visited all 8 zones',                  condition: 'zones_8' },
    { id: 'the_questmaster',   name: 'The Questmaster',   description: 'Completed 10 quests',                  condition: 'quests_10' },
    { id: 'the_completionist', name: 'The Completionist', description: 'Completed 25 quests',                  condition: 'quests_25' },
    { id: 'the_merchant',      name: 'The Merchant',      description: 'Completed 25 trades',                  condition: 'trades_25' },
    { id: 'the_magnate',       name: 'The Magnate',       description: 'Accumulated 2000 Spark',               condition: 'spark_2000' },
    { id: 'the_artisan',       name: 'The Artisan',       description: 'Crafted 50 items',                     condition: 'craft_50' },
    { id: 'the_builder',       name: 'The Builder',       description: 'Placed 50 structures',                 condition: 'build_50' },
    { id: 'the_cartographer',  name: 'The Cartographer',  description: 'Made 25 discoveries',                  condition: 'discoveries_25' },
    { id: 'the_scholar',       name: 'The Scholar',       description: 'Reached lore skill level 4',           condition: 'lore_level_4' },
    { id: 'the_champion',      name: 'The Champion',      description: 'Won 5 competitions',                   condition: 'wins_5' },
    { id: 'the_guild_founder', name: 'The Guild Founder', description: 'Founded a guild',                      condition: 'guild_founder' },
    { id: 'the_mentor',        name: 'The Mentor',        description: 'Taught another player a skill',        condition: 'taught_player' },
    { id: 'the_naturalist',    name: 'The Naturalist',    description: 'Adopted a pet companion',              condition: 'has_pet' },
    { id: 'the_elder',         name: 'The Elder',         description: 'Reached player level 10',              condition: 'level_10' },
    { id: 'the_transcendent',  name: 'The Transcendent',  description: 'Reached maximum player level',         condition: 'level_15' },
    { id: 'the_sunwalker',     name: 'The Sunwalker',     description: 'Achieved Sunwalker warmth tier',       condition: 'sunwalker' },
    { id: 'the_lorekeeper',    name: 'The Lorekeeper',    description: 'Unlocked 10 lore entries',             condition: 'lore_10' },
    { id: 'the_gardener',      name: 'The Gardener',      description: 'Harvested 100 plants',                 condition: 'harvest_100' }
  ];

  var SKILL_META = {
    gardening:   { icon: '[G]', color: '#4caf50' },
    crafting:    { icon: '[C]', color: '#ff9800' },
    building:    { icon: '[B]', color: '#2196f3' },
    exploration: { icon: '[E]', color: '#9c27b0' },
    trading:     { icon: '[T]', color: '#ffc107' },
    social:      { icon: '[S]', color: '#e91e63' },
    combat:      { icon: '[W]', color: '#f44336' },
    lore:        { icon: '[L]', color: '#00bcd4' }
  };

  var MAX_SKILL_LEVEL = 4;

  function createProfile(playerId, data) {
    if (!playerId) return null;
    data = data || {};

    var questStats  = getProfileStats_quests(data.questData);
    var guildInfo   = getGuildInfo(playerId, data.guildData);
    var skillSummary = getSkillSummary(playerId, data.mentoringData);
    var petInfo     = getPetInfo(playerId, data.petData);
    var exploration = getExplorationProgress(playerId, data.discoveryData);
    var sparkBalance = (data.ledger && data.ledger.balances)
      ? (data.ledger.balances[playerId] || 0)
      : (data.sparkBalance || 0);
    var reputation  = data.reputationData || { score: 0, tier: 'Newcomer' };
    var joinTime    = data.joinTime || 0;
    var playtime    = data.playTimeSeconds || 0;
    var achievements = data.achievementData || {};

    var badges  = getProfileBadges(playerId, achievements);
    var titles  = getProfileTitle(playerId, questStats);
    var level   = getProfileLevel({
      questStats: questStats,
      sparkBalance: sparkBalance,
      exploration: exploration,
      skillSummary: skillSummary
    });

    return {
      id: playerId,
      name: sanitizeText(data.name || playerId),
      level: level,
      levelTitle: getLevelTitle(level),
      sparkBalance: sparkBalance,
      reputation: {
        score: reputation.score || 0,
        tier: reputation.tier || 'Newcomer'
      },
      questStats: questStats,
      guildInfo: guildInfo,
      skillSummary: skillSummary,
      petInfo: petInfo,
      exploration: exploration,
      badges: badges,
      titles: titles,
      joinTime: joinTime,
      playTimeSeconds: playtime,
      createdAt: Date.now()
    };
  }

  function getProfileStats_quests(questData) {
    if (!questData) {
      return {
        activeQuests: 0,
        completedQuests: 0,
        totalAvailable: 0,
        completedChains: 0,
        totalChains: 0,
        titles: []
      };
    }
    return {
      activeQuests:    questData.activeQuests    || 0,
      completedQuests: questData.completedQuests || 0,
      totalAvailable:  questData.totalAvailable  || 0,
      completedChains: questData.completedChains || 0,
      totalChains:     questData.totalChains     || 0,
      titles:          questData.titles          || []
    };
  }

  function getProfileStats(playerId, gameData) {
    gameData = gameData || {};

    var questStats = getProfileStats_quests(gameData.questData);
    var discoveriesCount = 0;
    var zonesDiscovered = 0;
    if (gameData.discoveryData) {
      var discoveries = gameData.discoveryData.list || gameData.discoveryData || [];
      if (Array.isArray(discoveries)) {
        discoveriesCount = discoveries.filter(function(d) {
          return d.discoverer === playerId || d.player === playerId;
        }).length;
      }
      var zoneMap = {};
      if (Array.isArray(discoveries)) {
        discoveries.forEach(function(d) {
          if ((d.discoverer === playerId || d.player === playerId) && d.zone) {
            zoneMap[d.zone] = true;
          }
        });
      }
      zonesDiscovered = Object.keys(zoneMap).length;
    }

    var sparkBalance = 0;
    if (gameData.ledger && gameData.ledger.balances) {
      sparkBalance = gameData.ledger.balances[playerId] || 0;
    } else if (typeof gameData.sparkBalance === 'number') {
      sparkBalance = gameData.sparkBalance;
    }

    var reputationScore = 0;
    var reputationTier = 'Newcomer';
    if (gameData.reputationData) {
      reputationScore = gameData.reputationData.score || 0;
      reputationTier  = gameData.reputationData.tier  || 'Newcomer';
    }

    return {
      questsCompleted:  questStats.completedQuests,
      activeQuests:     questStats.activeQuests,
      chainsCompleted:  questStats.completedChains,
      discoveries:      discoveriesCount,
      zonesDiscovered:  zonesDiscovered,
      sparkBalance:     sparkBalance,
      reputationScore:  reputationScore,
      reputationTier:   reputationTier,
      playTimeSeconds:  gameData.playTimeSeconds || 0,
      playTimeFormatted: formatPlayTime(gameData.playTimeSeconds || 0)
    };
  }

  function getProfileBadges(playerId, achievements) {
    if (!achievements) return [];

    var earned = [];
    for (var id in achievements) {
      var ach = achievements[id];
      if (ach && ach.earned) {
        earned.push({
          id: id,
          name:        ach.name        || id,
          description: ach.description || '',
          icon:        ach.icon        || '[*]',
          category:    ach.category    || 'misc',
          earnedAt:    ach.ts          || ach.earnedAt || 0
        });
      }
    }

    earned.sort(function(a, b) { return b.earnedAt - a.earnedAt; });
    return earned;
  }

  function getProfileTitle(playerId, questStats) {
    questStats = questStats || {};
    var titles = questStats.titles || [];

    var completedQuests = questStats.completedQuests || 0;
    if (completedQuests >= 10 && titles.indexOf('The Questmaster') === -1) {
      titles = titles.concat(['The Questmaster']);
    }
    if (completedQuests >= 25 && titles.indexOf('The Completionist') === -1) {
      titles = titles.concat(['The Completionist']);
    }

    return titles;
  }

  function getSkillSummary(playerId, mentoringData) {
    var skillNames = ['gardening', 'crafting', 'building', 'exploration',
                      'trading', 'social', 'combat', 'lore'];
    var summary = {};

    skillNames.forEach(function(skill) {
      var raw = mentoringData && mentoringData[skill];
      var level     = raw ? (raw.level     || 0) : 0;
      var xp        = raw ? (raw.xp        || 0) : 0;
      var levelName = raw ? (raw.levelName || 'Novice') : 'Novice';

      var xpThresholds = [0, 100, 300, 600, 1000];
      var xpToNext = 0;
      if (level < xpThresholds.length - 1) {
        xpToNext = xpThresholds[level + 1] - xp;
        if (xpToNext < 0) xpToNext = 0;
      }

      var meta = SKILL_META[skill] || { icon: '[?]', color: '#888' };
      summary[skill] = {
        level:     level,
        levelName: levelName,
        xp:        xp,
        xpToNext:  xpToNext,
        maxLevel:  MAX_SKILL_LEVEL,
        icon:      meta.icon,
        color:     meta.color
      };
    });

    return summary;
  }

  function getGuildInfo(playerId, guildData) {
    if (!guildData) {
      return { inGuild: false, guildId: null, guildName: null, guildTag: null,
               role: null, memberCount: 0, level: 0 };
    }

    var member = null;
    if (Array.isArray(guildData.members)) {
      guildData.members.forEach(function(m) {
        if (m.playerId === playerId) member = m;
      });
    }

    return {
      inGuild:     true,
      guildId:     guildData.id     || null,
      guildName:   sanitizeText(guildData.name   || ''),
      guildTag:    sanitizeText(guildData.tag    || ''),
      guildType:   guildData.type   || 'guild',
      role:        member ? (member.role || 'member') : 'member',
      memberCount: Array.isArray(guildData.members) ? guildData.members.length : 0,
      level:       guildData.level  || 1
    };
  }

  function getPetInfo(playerId, petData) {
    if (!petData) {
      return { hasPet: false, name: null, type: null, icon: null,
               rarity: null, mood: 0, bond: 0 };
    }

    return {
      hasPet: true,
      petId:  petData.id   || null,
      name:   sanitizeText(petData.name || 'Unknown'),
      type:   petData.type || 'unknown',
      icon:   petData.icon || '[pet]',
      rarity: petData.rarity || 'common',
      mood:   typeof petData.mood === 'number' ? petData.mood : 100,
      bond:   typeof petData.bond === 'number' ? petData.bond : 0,
      bonus:  petData.bonus || null
    };
  }

  function getExplorationProgress(playerId, discoveryData) {
    var result = {
      zonesDiscovered: 0,
      totalDiscoveries: 0,
      secretsFound: 0,
      loreUnlocked: 0,
      discoveries: []
    };

    if (!discoveryData) return result;

    var list = Array.isArray(discoveryData) ? discoveryData
             : (discoveryData.list || discoveryData.discoveries || []);

    var zoneMap = {};
    var secretCount = 0;
    var loreCount = 0;

    list.forEach(function(d) {
      var isOwner = d.discoverer === playerId || d.player === playerId;
      if (!isOwner) return;

      result.totalDiscoveries++;
      if (d.zone) zoneMap[d.zone] = true;
      if (d.type === 'secret') secretCount++;
      if (d.type === 'lore')   loreCount++;
      result.discoveries.push({
        name:  d.name  || (d.type ? d.type.charAt(0).toUpperCase() + d.type.slice(1) : 'Discovery'),
        zone:  d.zone  || 'unknown',
        rarity: d.rarity || 'common',
        type:  d.type  || 'landmark'
      });
    });

    result.zonesDiscovered = Object.keys(zoneMap).length;
    result.secretsFound    = secretCount;
    result.loreUnlocked    = loreCount;

    return result;
  }

  function formatProfileCard(profile) {
    if (!profile) return null;

    var guildLabel = profile.guildInfo && profile.guildInfo.inGuild
      ? '[' + sanitizeText(profile.guildInfo.guildTag) + '] ' + sanitizeText(profile.guildInfo.guildName)
      : 'No Guild';

    var petLabel = profile.petInfo && profile.petInfo.hasPet
      ? profile.petInfo.icon + ' ' + sanitizeText(profile.petInfo.name)
        + ' (' + profile.petInfo.type + ')'
      : 'No Companion';

    var topBadges = (profile.badges || []).slice(0, 6);
    var badgeLabels = topBadges.map(function(b) {
      return b.icon + ' ' + sanitizeText(b.name);
    });

    var topSkills = [];
    if (profile.skillSummary) {
      for (var skillName in profile.skillSummary) {
        var s = profile.skillSummary[skillName];
        topSkills.push({
          name:      skillName.charAt(0).toUpperCase() + skillName.slice(1),
          level:     s.level,
          levelName: s.levelName,
          xp:        s.xp,
          xpToNext:  s.xpToNext,
          icon:      s.icon,
          color:     s.color
        });
      }
    }

    return {
      id:              sanitizeText(profile.id),
      name:            sanitizeText(profile.name),
      level:           profile.level,
      levelTitle:      sanitizeText(profile.levelTitle),
      sparkBalance:    profile.sparkBalance,
      reputationTier:  sanitizeText(profile.reputation ? profile.reputation.tier : 'Newcomer'),
      reputationScore: profile.reputation ? profile.reputation.score : 0,
      questsCompleted: profile.questStats ? profile.questStats.completedQuests : 0,
      chainsCompleted: profile.questStats ? profile.questStats.completedChains : 0,
      discoveries:     profile.exploration ? profile.exploration.totalDiscoveries : 0,
      zonesDiscovered: profile.exploration ? profile.exploration.zonesDiscovered : 0,
      secretsFound:    profile.exploration ? profile.exploration.secretsFound : 0,
      playTime:        formatPlayTime(profile.playTimeSeconds || 0),
      guildLabel:      guildLabel,
      petLabel:        petLabel,
      badgeLabels:     badgeLabels,
      skills:          topSkills,
      titles:          (profile.titles || []).map(sanitizeText)
    };
  }

  function compareProfiles(profileA, profileB) {
    if (!profileA || !profileB) return null;

    var sparkA = profileA.sparkBalance || 0;
    var sparkB = profileB.sparkBalance || 0;
    var questsA = (profileA.questStats || {}).completedQuests || 0;
    var questsB = (profileB.questStats || {}).completedQuests || 0;
    var discA = (profileA.exploration || {}).totalDiscoveries || 0;
    var discB = (profileB.exploration || {}).totalDiscoveries || 0;
    var repA = (profileA.reputation || {}).score || 0;
    var repB = (profileB.reputation || {}).score || 0;
    var levelA = profileA.level || 1;
    var levelB = profileB.level || 1;
    var badgesA = (profileA.badges || []).length;
    var badgesB = (profileB.badges || []).length;

    var skillTotalA = sumSkillLevels(profileA.skillSummary);
    var skillTotalB = sumSkillLevels(profileB.skillSummary);

    return {
      players: [sanitizeText(profileA.name), sanitizeText(profileB.name)],
      categories: {
        level:      { values: [levelA,   levelB],  winner: levelA  > levelB  ? 0 : levelB  > levelA  ? 1 : -1 },
        spark:      { values: [sparkA,   sparkB],  winner: sparkA  > sparkB  ? 0 : sparkB  > sparkA  ? 1 : -1 },
        quests:     { values: [questsA,  questsB], winner: questsA > questsB ? 0 : questsB > questsA ? 1 : -1 },
        discoveries:{ values: [discA,    discB],   winner: discA   > discB   ? 0 : discB   > discA   ? 1 : -1 },
        reputation: { values: [repA,     repB],    winner: repA    > repB    ? 0 : repB    > repA    ? 1 : -1 },
        badges:     { values: [badgesA,  badgesB], winner: badgesA > badgesB ? 0 : badgesB > badgesA ? 1 : -1 },
        skills:     { values: [skillTotalA, skillTotalB], winner: skillTotalA > skillTotalB ? 0 : skillTotalB > skillTotalA ? 1 : -1 }
      }
    };
  }

  function getProfileLevel(profile) {
    profile = profile || {};

    var xp = 0;

    var questStats = profile.questStats || {};
    xp += (questStats.completedQuests || 0) * 20;
    xp += (questStats.completedChains || 0) * 50;

    var spark = profile.sparkBalance || 0;
    xp += Math.floor(Math.min(spark, 5000) / 10);

    var exploration = profile.exploration || {};
    xp += (exploration.totalDiscoveries || 0) * 10;
    xp += (exploration.zonesDiscovered  || 0) * 30;

    var skillSum = sumSkillLevels(profile.skillSummary);
    xp += skillSum * 15;

    var level = 1;
    for (var i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
      if (xp >= LEVEL_THRESHOLDS[i].xpRequired) {
        level = LEVEL_THRESHOLDS[i].level;
        break;
      }
    }
    return level;
  }

  function showPlayerProfilePanel(profile, container) {
    var existing = document.getElementById('profiles-panel');
    if (existing && existing.parentNode) {
      existing.parentNode.removeChild(existing);
      return null; // toggle off
    }

    var formatted = formatProfileCard(profile);
    if (!formatted) return null;

    var panel = document.createElement('div');
    panel.id = 'profiles-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.92);border:2px solid #d4af37;border-radius:12px;' +
      'padding:0;width:720px;max-height:88vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 40px rgba(0,0,0,0.9);z-index:350;font-family:monospace;color:#fff;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;justify-content:space-between;align-items:center;' +
      'padding:18px 22px;background:rgba(212,175,55,0.12);border-bottom:1px solid #d4af37;';

    var titleEl = document.createElement('div');
    titleEl.style.cssText = 'font-size:20px;font-weight:bold;color:#d4af37;';
    titleEl.textContent = 'Player Profile';
    header.appendChild(titleEl);

    var closeBtn = document.createElement('div');
    closeBtn.textContent = 'X';
    closeBtn.style.cssText = 'cursor:pointer;font-size:20px;color:#888;padding:2px 10px;' +
      'border-radius:4px;';
    closeBtn.onmouseover = function() { this.style.color = '#d4af37'; };
    closeBtn.onmouseout  = function() { this.style.color = '#888'; };
    closeBtn.onclick = function() {
      if (panel.parentNode) panel.parentNode.removeChild(panel);
    };
    header.appendChild(closeBtn);
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:22px;';

    var identity = _buildIdentitySection(formatted);
    body.appendChild(identity);

    var statsSection = _buildStatsSection(formatted);
    body.appendChild(statsSection);

    var guildSection = _buildGuildSection(formatted);
    body.appendChild(guildSection);

    var petSection = _buildPetSection(formatted);
    body.appendChild(petSection);

    if (profile.badges && profile.badges.length > 0) {
      var badgeSection = _buildBadgeSection(profile.badges);
      body.appendChild(badgeSection);
    }

    var skillSection = _buildSkillSection(formatted.skills, profile.skillSummary);
    body.appendChild(skillSection);

    if (formatted.titles && formatted.titles.length > 0) {
      var titleSection = _buildTitleSection(formatted.titles);
      body.appendChild(titleSection);
    }

    panel.appendChild(body);
    var root = container || document.body;
    root.appendChild(panel);
    return panel;
  }

  function _buildIdentitySection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'display:flex;align-items:center;gap:20px;margin-bottom:22px;' +
      'padding-bottom:18px;border-bottom:1px solid rgba(212,175,55,0.3);';

    var avatar = document.createElement('div');
    var initial = (fmt.name || 'P').charAt(0).toUpperCase();
    avatar.textContent = initial;
    avatar.style.cssText = 'width:76px;height:76px;border-radius:50%;background:#d4af37;' +
      'display:flex;align-items:center;justify-content:center;font-size:34px;font-weight:bold;' +
      'color:#000;flex-shrink:0;border:2px solid rgba(212,175,55,0.6);';

    var details = document.createElement('div');
    details.style.cssText = 'flex:1;';

    var nameEl = document.createElement('div');
    nameEl.textContent = fmt.name;
    nameEl.style.cssText = 'font-size:22px;font-weight:bold;color:#fff;margin-bottom:4px;';

    var levelEl = document.createElement('div');
    levelEl.textContent = 'Level ' + fmt.level + ' â€” ' + fmt.levelTitle;
    levelEl.style.cssText = 'font-size:13px;color:#d4af37;margin-bottom:4px;';

    var repEl = document.createElement('div');
    repEl.textContent = fmt.reputationTier + ' (rep: ' + fmt.reputationScore + ')';
    repEl.style.cssText = 'font-size:12px;color:#aaa;margin-bottom:6px;';

    var sparkEl = document.createElement('div');
    sparkEl.innerHTML = '<span style="color:#d4af37;">[S]</span> ' + fmt.sparkBalance + ' Spark';
    sparkEl.style.cssText = 'font-size:15px;color:#fff;font-weight:bold;';

    details.appendChild(nameEl);
    details.appendChild(levelEl);
    details.appendChild(repEl);
    details.appendChild(sparkEl);

    section.appendChild(avatar);
    section.appendChild(details);
    return section;
  }

  function _buildStatsSection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:20px;';

    var title = document.createElement('div');
    title.textContent = 'Stats';
    title.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:10px;';
    section.appendChild(title);

    var grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(3,1fr);gap:10px;';

    var statItems = [
      { label: 'Quests Done',    value: fmt.questsCompleted },
      { label: 'Chains Done',    value: fmt.chainsCompleted },
      { label: 'Discoveries',    value: fmt.discoveries },
      { label: 'Zones Explored', value: fmt.zonesDiscovered },
      { label: 'Secrets Found',  value: fmt.secretsFound },
      { label: 'Time Played',    value: fmt.playTime }
    ];

    statItems.forEach(function(s) {
      var item = document.createElement('div');
      item.style.cssText = 'background:rgba(255,255,255,0.05);border-radius:6px;padding:10px 12px;' +
        'border:1px solid rgba(212,175,55,0.15);';

      var lbl = document.createElement('div');
      lbl.textContent = s.label;
      lbl.style.cssText = 'font-size:10px;color:#888;margin-bottom:4px;text-transform:uppercase;';

      var val = document.createElement('div');
      val.textContent = s.value;
      val.style.cssText = 'font-size:17px;color:#fff;font-weight:bold;';

      item.appendChild(lbl);
      item.appendChild(val);
      grid.appendChild(item);
    });

    section.appendChild(grid);
    return section;
  }

  function _buildGuildSection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;padding:12px 14px;background:rgba(212,175,55,0.05);' +
      'border-radius:8px;border:1px solid rgba(212,175,55,0.2);display:flex;align-items:center;gap:12px;';

    var icon = document.createElement('div');
    icon.textContent = '[H]';
    icon.style.cssText = 'font-size:22px;flex-shrink:0;color:#d4af37;';

    var info = document.createElement('div');
    var nameEl = document.createElement('div');
    nameEl.textContent = 'Guild: ' + fmt.guildLabel;
    nameEl.style.cssText = 'font-size:14px;color:#fff;font-weight:bold;';
    info.appendChild(nameEl);

    section.appendChild(icon);
    section.appendChild(info);
    return section;
  }

  function _buildPetSection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;padding:12px 14px;background:rgba(100,200,100,0.05);' +
      'border-radius:8px;border:1px solid rgba(100,200,100,0.2);display:flex;align-items:center;gap:12px;';

    var icon = document.createElement('div');
    icon.textContent = '[P]';
    icon.style.cssText = 'font-size:22px;flex-shrink:0;color:#4caf50;';

    var info = document.createElement('div');
    var nameEl = document.createElement('div');
    nameEl.textContent = 'Companion: ' + fmt.petLabel;
    nameEl.style.cssText = 'font-size:14px;color:#fff;font-weight:bold;';
    info.appendChild(nameEl);

    section.appendChild(icon);
    section.appendChild(info);
    return section;
  }

  function _buildBadgeSection(badges) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;';

    var title = document.createElement('div');
    title.textContent = 'Achievements';
    title.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:10px;';
    section.appendChild(title);

    var row = document.createElement('div');
    row.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;';

    badges.slice(0, 12).forEach(function(badge) {
      var chip = document.createElement('div');
      chip.title = badge.description;
      chip.style.cssText = 'padding:5px 10px;background:rgba(212,175,55,0.1);border:1px solid rgba(212,175,55,0.4);' +
        'border-radius:20px;font-size:12px;color:#d4af37;cursor:default;';
      chip.textContent = badge.icon + ' ' + badge.name;
      row.appendChild(chip);
    });

    section.appendChild(row);
    return section;
  }

  function _buildSkillSection(skills, skillSummary) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;';

    var title = document.createElement('div');
    title.textContent = 'Skills';
    title.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:10px;';
    section.appendChild(title);

    var grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:10px;';

    skills.forEach(function(skill) {
      var row = document.createElement('div');
      row.style.cssText = 'padding:8px;';

      var header = document.createElement('div');
      header.style.cssText = 'display:flex;justify-content:space-between;margin-bottom:4px;';

      var lbl = document.createElement('div');
      lbl.textContent = skill.icon + ' ' + skill.name;
      lbl.style.cssText = 'font-size:13px;color:#fff;font-weight:600;';

      var lvl = document.createElement('div');
      lvl.textContent = skill.levelName + ' (Lv.' + skill.level + ')';
      lvl.style.cssText = 'font-size:11px;color:#d4af37;';

      header.appendChild(lbl);
      header.appendChild(lvl);
      row.appendChild(header);

      var barWrap = document.createElement('div');
      barWrap.style.cssText = 'height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;';

      var xpTotal = skill.xp + skill.xpToNext;
      var pct = xpTotal > 0 ? Math.min(100, (skill.xp / xpTotal) * 100) : 0;
      if (skill.level >= (skill.maxLevel || 4)) pct = 100;

      var fill = document.createElement('div');
      fill.style.cssText = 'height:100%;background:' + (skill.color || '#d4af37') + ';' +
        'border-radius:4px;width:' + pct.toFixed(1) + '%;';
      barWrap.appendChild(fill);
      row.appendChild(barWrap);

      grid.appendChild(row);
    });

    section.appendChild(grid);
    return section;
  }

  function _buildTitleSection(titles) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:10px;';

    var titleEl = document.createElement('div');
    titleEl.textContent = 'Titles';
    titleEl.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:8px;';
    section.appendChild(titleEl);

    var row = document.createElement('div');
    row.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;';

    titles.forEach(function(t) {
      var chip = document.createElement('div');
      chip.style.cssText = 'padding:4px 10px;background:rgba(255,255,255,0.08);' +
        'border:1px solid rgba(255,255,255,0.2);border-radius:4px;font-size:12px;color:#eee;';
      chip.textContent = t;
      row.appendChild(chip);
    });

    section.appendChild(row);
    return section;
  }

  function sumSkillLevels(skillSummary) {
    if (!skillSummary) return 0;
    var total = 0;
    for (var k in skillSummary) {
      total += (skillSummary[k].level || 0);
    }
    return total;
  }

  function getLevelTitle(level) {
    for (var i = 0; i < LEVEL_THRESHOLDS.length; i++) {
      if (LEVEL_THRESHOLDS[i].level === level) {
        return LEVEL_THRESHOLDS[i].title;
      }
    }
    return 'Newcomer';
  }

  function formatPlayTime(seconds) {
    seconds = Math.floor(seconds || 0);
    if (seconds < 60) return seconds + 's';
    var m = Math.floor(seconds / 60);
    if (m < 60) return m + 'm';
    var h = Math.floor(m / 60);
    var rem = m % 60;
    return h + 'h ' + rem + 'm';
  }

  function sanitizeText(text) {
    if (typeof text !== 'string') return String(text || '');
    return text.replace(/[<>&"']/g, function(c) {
      return { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;' }[c];
    });
  }

  exports.LEVEL_THRESHOLDS      = LEVEL_THRESHOLDS;
  exports.TITLE_LIST            = TITLE_LIST;
  exports.SKILL_META            = SKILL_META;
  exports.createProfile         = createProfile;
  exports.getProfileStats       = getProfileStats;
  exports.getProfileBadges      = getProfileBadges;
  exports.getProfileTitle       = getProfileTitle;
  exports.getSkillSummary       = getSkillSummary;
  exports.getGuildInfo          = getGuildInfo;
  exports.getPetInfo            = getPetInfo;
  exports.getExplorationProgress = getExplorationProgress;
  exports.formatProfileCard     = formatProfileCard;
  exports.compareProfiles       = compareProfiles;
  exports.getProfileLevel       = getProfileLevel;
  exports.showPlayerProfilePanel = showPlayerProfilePanel;
  exports.formatPlayTime        = formatPlayTime;
  exports.sanitizeText          = sanitizeText;
  exports.sumSkillLevels        = sumSkillLevels;
  exports.getLevelTitle         = getLevelTitle;

})(typeof module !== 'undefined' ? module.exports : (window.Profiles = {}));


// models.js

(function(exports) {
  'use strict';

  function createTree(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'tree_' + type;
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.05;
    group.userData.swaySpeed = 1.0;

    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
    const darkTrunk = new THREE.MeshLambertMaterial({ color: 0x3a2718 });

    switch(type) {
      case 'oak':
        const oakTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 3 * scale, 8),
          trunkMaterial
        );
        oakTrunk.position.y = 1.5 * scale;
        group.add(oakTrunk);

        for (let i = 0; i < 4; i++) {
          const root = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1 * scale, 0.15 * scale, 0.5 * scale, 6),
            darkTrunk
          );
          root.position.y = 0.1 * scale;
          const angle = (i / 4) * Math.PI * 2;
          root.position.x = Math.cos(angle) * 0.3 * scale;
          root.position.z = Math.sin(angle) * 0.3 * scale;
          root.rotation.z = Math.PI / 6;
          root.rotation.y = angle;
          group.add(root);
        }

        const canopyColors = [0x2d5016, 0x3a6b1f, 0x4a8028];
        for (let i = 0; i < 8; i++) {
          const leafBall = new THREE.Mesh(
            new THREE.SphereGeometry(0.8 * scale, 8, 6),
            new THREE.MeshLambertMaterial({
              color: canopyColors[Math.floor(Math.random() * canopyColors.length)]
            })
          );
          const angle = (i / 8) * Math.PI * 2;
          const radius = 0.6 * scale;
          leafBall.position.x = Math.cos(angle) * radius;
          leafBall.position.z = Math.sin(angle) * radius;
          leafBall.position.y = 3 * scale + Math.random() * 0.4 * scale;
          group.add(leafBall);
        }

        const centerCanopy = new THREE.Mesh(
          new THREE.SphereGeometry(1 * scale, 8, 6),
          new THREE.MeshLambertMaterial({ color: 0x3a6b1f })
        );
        centerCanopy.position.y = 3.2 * scale;
        group.add(centerCanopy);
        break;

      case 'pine':
        const pineTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 4 * scale, 8),
          trunkMaterial
        );
        pineTrunk.position.y = 2 * scale;
        group.add(pineTrunk);

        const pineMaterial = new THREE.MeshLambertMaterial({ color: 0x1a4d2e });
        const coneSizes = [1.2, 1.0, 0.8, 0.6];
        for (let i = 0; i < coneSizes.length; i++) {
          const cone = new THREE.Mesh(
            new THREE.ConeGeometry(coneSizes[i] * scale, 1.5 * scale, 8),
            pineMaterial
          );
          cone.position.y = (2 + i * 1.2) * scale;
          group.add(cone);
        }

        const top = new THREE.Mesh(
          new THREE.ConeGeometry(0.3 * scale, 0.8 * scale, 6),
          pineMaterial
        );
        top.position.y = 6.5 * scale;
        group.add(top);
        break;

      case 'willow':
        const willowTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, 2.5 * scale, 8),
          trunkMaterial
        );
        willowTrunk.position.y = 1.25 * scale;
        group.add(willowTrunk);

        const willowGreen = new THREE.MeshLambertMaterial({ color: 0x90ee90 });
        const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x5a4a38 });

        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const branchLength = 1.5 * scale;

          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03 * scale, 0.02 * scale, branchLength, 4),
            branchMaterial
          );
          branch.position.x = Math.cos(angle) * 0.2 * scale;
          branch.position.z = Math.sin(angle) * 0.2 * scale;
          branch.position.y = 2.5 * scale - branchLength / 2;
          branch.rotation.z = Math.PI / 4;
          branch.rotation.y = angle;
          group.add(branch);

          for (let j = 0; j < 3; j++) {
            const leaf = new THREE.Mesh(
              new THREE.SphereGeometry(0.15 * scale, 6, 4),
              willowGreen
            );
            leaf.position.x = Math.cos(angle) * (0.3 + j * 0.3) * scale;
            leaf.position.z = Math.sin(angle) * (0.3 + j * 0.3) * scale;
            leaf.position.y = (2.2 - j * 0.4) * scale;
            group.add(leaf);
          }
        }
        break;

      case 'cherry':
        const cherryTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2.5 * scale, 8),
          trunkMaterial
        );
        cherryTrunk.position.y = 1.25 * scale;
        group.add(cherryTrunk);

        const blossomColors = [0xffb7c5, 0xffc0cb, 0xffd1dc, 0xffffff];
        for (let i = 0; i < 20; i++) {
          const blossom = new THREE.Mesh(
            new THREE.SphereGeometry(0.2 * scale, 6, 4),
            new THREE.MeshLambertMaterial({
              color: blossomColors[Math.floor(Math.random() * blossomColors.length)]
            })
          );
          const angle = Math.random() * Math.PI * 2;
          const radius = 0.4 + Math.random() * 0.6;
          blossom.position.x = Math.cos(angle) * radius * scale;
          blossom.position.z = Math.sin(angle) * radius * scale;
          blossom.position.y = (2 + Math.random() * 1) * scale;
          group.add(blossom);
        }
        break;

      case 'dead':
        const deadTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25 * scale, 0.35 * scale, 3 * scale, 8),
          new THREE.MeshLambertMaterial({ color: 0x666666 })
        );
        deadTrunk.position.y = 1.5 * scale;
        group.add(deadTrunk);

        const deadBranchMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
        for (let i = 0; i < 6; i++) {
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05 * scale, 0.02 * scale, 1 * scale, 4),
            deadBranchMat
          );
          const angle = (i / 6) * Math.PI * 2;
          branch.position.y = (2 + Math.random() * 0.5) * scale;
          branch.rotation.z = Math.PI / 3 + Math.random() * 0.3;
          branch.rotation.y = angle;
          group.add(branch);
        }

        group.userData.animationType = 'none';
        break;
    }

    return group;
  }

  function createRock(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'rock_' + type;

    switch(type) {
      case 'boulder':
        const boulderGeo = new THREE.DodecahedronGeometry(1 * scale, 0);
        const boulderMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        const vertices = boulderGeo.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          vertices[i] += (Math.random() - 0.5) * 0.2 * scale;
          vertices[i + 1] += (Math.random() - 0.5) * 0.2 * scale;
          vertices[i + 2] += (Math.random() - 0.5) * 0.2 * scale;
        }
        boulderGeo.attributes.position.needsUpdate = true;
        boulderGeo.computeVertexNormals();

        const boulder = new THREE.Mesh(boulderGeo, boulderMat);
        boulder.position.y = 0.8 * scale;
        group.add(boulder);
        break;

      case 'crystal':
        group.userData.animationType = 'bob';
        group.userData.bobSpeed = 1.5;
        group.userData.bobAmount = 0.2;

        const crystalColors = [0x9966ff, 0x6699ff, 0x00ccff];
        const angles = [0, Math.PI * 2 / 3, Math.PI * 4 / 3];

        for (let i = 0; i < 3; i++) {
          const crystalMat = new THREE.MeshLambertMaterial({
            color: crystalColors[i],
            emissive: crystalColors[i],
            emissiveIntensity: 0.3
          });

          const crystal = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.4 * scale, 0),
            crystalMat
          );

          crystal.position.x = Math.cos(angles[i]) * 0.3 * scale;
          crystal.position.z = Math.sin(angles[i]) * 0.3 * scale;
          crystal.position.y = (0.8 + i * 0.2) * scale;
          crystal.rotation.y = angles[i];
          crystal.scale.y = 1.5 + Math.random() * 0.5;
          group.add(crystal);
        }
        break;

      case 'ruins':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0xb8a890 });
        const ruinPieces = [
          { w: 1.5, h: 0.4, d: 0.8, x: 0, y: 0.2, z: 0, rx: 0, ry: 0, rz: 0.1 },
          { w: 1.0, h: 0.5, d: 0.6, x: 0.5, y: 0.5, z: 0.3, rx: 0.2, ry: 0.3, rz: -0.15 },
          { w: 0.8, h: 0.6, d: 0.5, x: -0.4, y: 0.6, z: -0.2, rx: -0.15, ry: -0.2, rz: 0.1 },
          { w: 0.6, h: 0.3, d: 0.4, x: 0.2, y: 1.0, z: -0.4, rx: 0.3, ry: 0.1, rz: 0.2 }
        ];

        ruinPieces.forEach(piece => {
          const stone = new THREE.Mesh(
            new THREE.BoxGeometry(piece.w * scale, piece.h * scale, piece.d * scale),
            stoneMat
          );
          stone.position.set(piece.x * scale, piece.y * scale, piece.z * scale);
          stone.rotation.set(piece.rx, piece.ry, piece.rz);
          group.add(stone);
        });
        break;
    }

    return group;
  }

  function createBuilding(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'building_' + type;

    switch(type) {
      case 'house':
        const wallMat = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
        const roofMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const doorMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const windowMat = new THREE.MeshLambertMaterial({
          color: 0xffffaa,
          emissive: 0xffff88,
          emissiveIntensity: 0.5
        });

        const base = new THREE.Mesh(
          new THREE.BoxGeometry(3 * scale, 2 * scale, 3 * scale),
          wallMat
        );
        base.position.y = 1 * scale;
        group.add(base);

        const roof1 = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5 * scale, 2 * scale),
          roofMat
        );
        roof1.position.y = 2.5 * scale;
        roof1.position.z = -0.5 * scale;
        roof1.rotation.x = -Math.PI / 4;
        group.add(roof1);

        const roof2 = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5 * scale, 2 * scale),
          roofMat
        );
        roof2.position.y = 2.5 * scale;
        roof2.position.z = 0.5 * scale;
        roof2.rotation.x = Math.PI / 4;
        group.add(roof2);

        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.6 * scale, 1.2 * scale, 0.1 * scale),
          doorMat
        );
        door.position.y = 0.6 * scale;
        door.position.z = 1.55 * scale;
        group.add(door);

        const windowPositions = [
          { x: -0.8, y: 1.2, z: 1.55 },
          { x: 0.8, y: 1.2, z: 1.55 }
        ];
        windowPositions.forEach(pos => {
          const window = new THREE.Mesh(
            new THREE.BoxGeometry(0.4 * scale, 0.4 * scale, 0.1 * scale),
            windowMat
          );
          window.position.set(pos.x * scale, pos.y * scale, pos.z * scale);
          group.add(window);
        });
        break;

      case 'tower':
        const towerMat = new THREE.MeshLambertMaterial({ color: 0x9a9a9a });
        const crenMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        const tower = new THREE.Mesh(
          new THREE.CylinderGeometry(1 * scale, 1.2 * scale, 6 * scale, 12),
          towerMat
        );
        tower.position.y = 3 * scale;
        group.add(tower);

        for (let i = 0; i < 8; i++) {
          const cren = new THREE.Mesh(
            new THREE.BoxGeometry(0.3 * scale, 0.5 * scale, 0.3 * scale),
            crenMat
          );
          const angle = (i / 8) * Math.PI * 2;
          cren.position.x = Math.cos(angle) * 1 * scale;
          cren.position.z = Math.sin(angle) * 1 * scale;
          cren.position.y = 6.25 * scale;
          group.add(cren);
        }

        const slitMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const slit = new THREE.Mesh(
            new THREE.BoxGeometry(0.1 * scale, 0.6 * scale, 0.2 * scale),
            slitMat
          );
          slit.position.x = Math.cos(angle) * 1.15 * scale;
          slit.position.z = Math.sin(angle) * 1.15 * scale;
          slit.position.y = 4 * scale;
          group.add(slit);
        }
        break;

      case 'market_stall':
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
        const fabricMat = new THREE.MeshLambertMaterial({ color: 0xff6b35 });
        const counterMat = new THREE.MeshLambertMaterial({ color: 0xa0826d });

        const polePositions = [
          { x: -1, z: -1 }, { x: 1, z: -1 },
          { x: -1, z: 1 }, { x: 1, z: 1 }
        ];
        polePositions.forEach(pos => {
          const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 2.5 * scale, 6),
            poleMat
          );
          pole.position.set(pos.x * scale, 1.25 * scale, pos.z * scale);
          group.add(pole);
        });

        const roof = new THREE.Mesh(
          new THREE.PlaneGeometry(2.5 * scale, 2.5 * scale),
          fabricMat
        );
        roof.position.y = 2.5 * scale;
        roof.rotation.x = -Math.PI / 2;
        group.add(roof);

        const counter = new THREE.Mesh(
          new THREE.BoxGeometry(2 * scale, 0.1 * scale, 1 * scale),
          counterMat
        );
        counter.position.y = 1 * scale;
        counter.position.z = 0.5 * scale;
        group.add(counter);
        break;

      case 'temple':
        const templeMat = new THREE.MeshLambertMaterial({ color: 0xe8dcc4 });
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0xd4c5a9 });

        for (let i = 0; i < 3; i++) {
          const step = new THREE.Mesh(
            new THREE.BoxGeometry((4 - i * 0.3) * scale, 0.3 * scale, (3 - i * 0.3) * scale),
            templeMat
          );
          step.position.y = i * 0.3 * scale;
          group.add(step);
        }

        const main = new THREE.Mesh(
          new THREE.BoxGeometry(3 * scale, 2 * scale, 2 * scale),
          templeMat
        );
        main.position.y = 1.9 * scale;
        group.add(main);

        const pillarXPos = [-1.2, -0.4, 0.4, 1.2];
        pillarXPos.forEach(x => {
          const pillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15 * scale, 0.15 * scale, 2 * scale, 8),
            pillarMat
          );
          pillar.position.set(x * scale, 1.9 * scale, 1.2 * scale);
          group.add(pillar);
        });

        const pediment = new THREE.Mesh(
          new THREE.ConeGeometry(1.8 * scale, 0.8 * scale, 3),
          templeMat
        );
        pediment.position.y = 3.3 * scale;
        pediment.position.z = 1.2 * scale;
        pediment.rotation.z = -Math.PI / 2;
        pediment.rotation.y = Math.PI / 2;
        group.add(pediment);
        break;
    }

    return group;
  }

  function createFurniture(type) {
    const group = new THREE.Group();
    group.name = 'furniture_' + type;

    switch(type) {
      case 'bench':
        const benchMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        const seat = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.1, 0.4),
          benchMat
        );
        seat.position.y = 0.5;
        group.add(seat);

        const leg1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          benchMat
        );
        leg1.position.set(-0.6, 0.25, 0);
        group.add(leg1);

        const leg2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          benchMat
        );
        leg2.position.set(0.6, 0.25, 0);
        group.add(leg2);
        break;

      case 'lantern':
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const lightMat = new THREE.MeshLambertMaterial({
          color: 0xffff88,
          emissive: 0xffff00,
          emissiveIntensity: 0.8
        });

        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 2, 6),
          poleMat
        );
        pole.position.y = 1;
        group.add(pole);

        const lantern = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.3),
          lightMat
        );
        lantern.position.y = 2.2;
        group.add(lantern);

        const light = new THREE.PointLight(0xffff88, 1, 10);
        light.position.y = 2.2;
        group.add(light);
        break;

      case 'well':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        const wellBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.8, 0.8, 1, 12),
          stoneMat
        );
        wellBase.position.y = 0.5;
        group.add(wellBase);

        const post1 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6),
          woodMat
        );
        post1.position.set(-0.6, 1.25, 0);
        group.add(post1);

        const post2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6),
          woodMat
        );
        post2.position.set(0.6, 1.25, 0);
        group.add(post2);

        const crossbar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 1.4, 6),
          woodMat
        );
        crossbar.position.y = 2;
        crossbar.rotation.z = Math.PI / 2;
        group.add(crossbar);

        const bucket = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8),
          woodMat
        );
        bucket.position.set(0, 1.5, 0.5);
        group.add(bucket);
        break;

      case 'bridge':
        const plankMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
        const railMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

        const numPlanks = 8;
        for (let i = 0; i < numPlanks; i++) {
          const plank = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.1, 0.4),
            plankMat
          );
          const t = (i / (numPlanks - 1)) * Math.PI;
          plank.position.x = (i - numPlanks / 2) * 0.5;
          plank.position.y = Math.sin(t) * 0.3;
          plank.rotation.z = Math.cos(t) * 0.2;
          group.add(plank);
        }

        for (let side = -1; side <= 1; side += 2) {
          for (let i = 0; i < numPlanks; i++) {
            const rail = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.5, 4),
              railMat
            );
            const t = (i / (numPlanks - 1)) * Math.PI;
            rail.position.x = (i - numPlanks / 2) * 0.5;
            rail.position.y = Math.sin(t) * 0.3 + 0.25;
            rail.position.z = side * 0.35;
            group.add(rail);
          }
        }
        break;

      case 'fence':
        const fenceMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        for (let i = 0; i < 5; i++) {
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1, 0.1),
            fenceMat
          );
          post.position.x = (i - 2) * 0.5;
          post.position.y = 0.5;
          group.add(post);
        }

        for (let i = 0; i < 2; i++) {
          const rail = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.08, 0.08),
            fenceMat
          );
          rail.position.y = 0.3 + i * 0.4;
          group.add(rail);
        }
        break;
    }

    return group;
  }

  function createCreature(type) {
    const group = new THREE.Group();
    group.name = 'creature_' + type;

    switch(type) {
      case 'butterfly':
        group.userData.animationType = 'flap';
        group.userData.flapSpeed = 8;
        group.userData.flapAmount = Math.PI / 4;

        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const wingMat = new THREE.MeshLambertMaterial({ color: 0xff6b9d });

        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6),
          bodyMat
        );
        body.rotation.z = Math.PI / 2;
        group.add(body);

        const leftWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.3, 0.4),
          wingMat
        );
        leftWing.position.z = 0.2;
        leftWing.name = 'leftWing';
        group.add(leftWing);

        const rightWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.3, 0.4),
          wingMat
        );
        rightWing.position.z = -0.2;
        rightWing.name = 'rightWing';
        group.add(rightWing);
        break;

      case 'bird':
        group.userData.animationType = 'bob';
        group.userData.bobSpeed = 2;
        group.userData.bobAmount = 0.3;

        const birdBodyMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const birdWingMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

        const birdBody = new THREE.Mesh(
          new THREE.ConeGeometry(0.15, 0.4, 8),
          birdBodyMat
        );
        birdBody.rotation.z = -Math.PI / 2;
        group.add(birdBody);

        const leftBirdWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          birdWingMat
        );
        leftBirdWing.position.z = 0.15;
        leftBirdWing.rotation.x = Math.PI / 6;
        leftBirdWing.name = 'leftWing';
        group.add(leftBirdWing);

        const rightBirdWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          birdWingMat
        );
        rightBirdWing.position.z = -0.15;
        rightBirdWing.rotation.x = -Math.PI / 6;
        rightBirdWing.name = 'rightWing';
        group.add(rightBirdWing);
        break;

      case 'fish':
        group.userData.animationType = 'swim';
        group.userData.swimSpeed = 1;
        group.userData.swimRadius = 2;
        group.userData.swimAngle = 0;

        const fishBodyMat = new THREE.MeshLambertMaterial({ color: 0xff8c00 });
        const fishTailMat = new THREE.MeshLambertMaterial({ color: 0xff6347 });

        const fishBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 8, 6),
          fishBodyMat
        );
        fishBody.scale.x = 2;
        group.add(fishBody);

        const tailGeo = new THREE.ConeGeometry(0.15, 0.3, 3);
        const tail = new THREE.Mesh(tailGeo, fishTailMat);
        tail.rotation.z = Math.PI / 2;
        tail.position.x = -0.4;
        group.add(tail);
        break;
    }

    return group;
  }

  function createLandmark(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'landmark_' + type;

    switch(type) {
      case 'fountain':
        const basinMat = new THREE.MeshLambertMaterial({ color: 0x8899aa });
        const waterMat = new THREE.MeshLambertMaterial({
          color: 0x4488cc,
          transparent: true,
          opacity: 0.7
        });
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0xaabbcc });

        const basin = new THREE.Mesh(
          new THREE.CylinderGeometry(2 * scale, 2.2 * scale, 0.6 * scale, 16),
          basinMat
        );
        basin.position.y = 0.3 * scale;
        group.add(basin);

        const water = new THREE.Mesh(
          new THREE.CylinderGeometry(1.8 * scale, 1.8 * scale, 0.1 * scale, 16),
          waterMat
        );
        water.position.y = 0.5 * scale;
        group.add(water);

        const centerPillar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2 * scale, 8),
          pillarMat
        );
        centerPillar.position.y = 1.3 * scale;
        group.add(centerPillar);

        const topBowl = new THREE.Mesh(
          new THREE.SphereGeometry(0.5 * scale, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
          basinMat
        );
        topBowl.position.y = 2.3 * scale;
        topBowl.rotation.x = Math.PI;
        group.add(topBowl);

        const dropMat = new THREE.MeshLambertMaterial({
          color: 0x88ccff,
          emissive: 0x2266aa,
          emissiveIntensity: 0.4
        });
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.15 * scale, 8, 6),
          dropMat
        );
        drop.position.y = 2.5 * scale;
        drop.name = 'waterDrop';
        group.add(drop);

        group.userData.animationType = 'fountain';
        break;

      case 'obelisk':
        const obeliskMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
        const runeMat = new THREE.MeshLambertMaterial({
          color: 0x88aaff,
          emissive: 0x4466cc,
          emissiveIntensity: 0.6
        });

        const obelisk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3 * scale, 0.6 * scale, 5 * scale, 4),
          obeliskMat
        );
        obelisk.position.y = 2.5 * scale;
        group.add(obelisk);

        for (let i = 0; i < 3; i++) {
          const rune = new THREE.Mesh(
            new THREE.TorusGeometry(0.45 * scale, 0.04 * scale, 6, 12),
            runeMat
          );
          rune.position.y = (1.5 + i * 1.2) * scale;
          rune.rotation.x = Math.PI / 2;
          group.add(rune);
        }

        const top = new THREE.Mesh(
          new THREE.ConeGeometry(0.35 * scale, 0.6 * scale, 4),
          obeliskMat
        );
        top.position.y = 5.3 * scale;
        group.add(top);

        const tipMat = new THREE.MeshLambertMaterial({
          color: 0xaaccff,
          emissive: 0x6688ff,
          emissiveIntensity: 1.0
        });
        const tip = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 * scale, 8, 6),
          tipMat
        );
        tip.position.y = 5.7 * scale;
        group.add(tip);

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 1.5;
        break;

      case 'statue':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
        const pedestalMat = new THREE.MeshLambertMaterial({ color: 0x777777 });

        const pedestal = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 * scale, 0.8 * scale, 1.2 * scale),
          pedestalMat
        );
        pedestal.position.y = 0.4 * scale;
        group.add(pedestal);

        const torso = new THREE.Mesh(
          new THREE.BoxGeometry(0.7 * scale, 1.2 * scale, 0.4 * scale),
          stoneMat
        );
        torso.position.y = 1.8 * scale;
        group.add(torso);

        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.25 * scale, 8, 6),
          stoneMat
        );
        head.position.y = 2.7 * scale;
        group.add(head);

        const leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.2 * scale),
          stoneMat
        );
        leftArm.position.set(-0.7 * scale, 2.0 * scale, 0);
        leftArm.rotation.z = Math.PI / 6;
        group.add(leftArm);

        const rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.2 * scale),
          stoneMat
        );
        rightArm.position.set(0.7 * scale, 2.0 * scale, 0);
        rightArm.rotation.z = -Math.PI / 6;
        group.add(rightArm);
        break;

      case 'campfire':
        const logMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const fireMat = new THREE.MeshLambertMaterial({
          color: 0xff6600,
          emissive: 0xff4400,
          emissiveIntensity: 0.9
        });
        const emberMat = new THREE.MeshLambertMaterial({
          color: 0xff2200,
          emissive: 0xff0000,
          emissiveIntensity: 0.7
        });

        for (let i = 0; i < 8; i++) {
          const stone = new THREE.Mesh(
            new THREE.SphereGeometry(0.15 * scale, 6, 4),
            new THREE.MeshLambertMaterial({ color: 0x666666 })
          );
          const angle = (i / 8) * Math.PI * 2;
          stone.position.x = Math.cos(angle) * 0.6 * scale;
          stone.position.z = Math.sin(angle) * 0.6 * scale;
          stone.position.y = 0.1 * scale;
          stone.scale.y = 0.7;
          group.add(stone);
        }

        for (let i = 0; i < 3; i++) {
          const log = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 1 * scale, 6),
            logMat
          );
          const angle = (i / 3) * Math.PI * 2;
          log.position.x = Math.cos(angle) * 0.2 * scale;
          log.position.z = Math.sin(angle) * 0.2 * scale;
          log.position.y = 0.15 * scale;
          log.rotation.z = Math.PI / 2;
          log.rotation.y = angle;
          group.add(log);
        }

        const fireCore = new THREE.Mesh(
          new THREE.ConeGeometry(0.25 * scale, 0.8 * scale, 6),
          fireMat
        );
        fireCore.position.y = 0.5 * scale;
        fireCore.name = 'fireCore';
        group.add(fireCore);

        const innerFlame = new THREE.Mesh(
          new THREE.ConeGeometry(0.15 * scale, 0.5 * scale, 5),
          new THREE.MeshLambertMaterial({
            color: 0xffaa00,
            emissive: 0xff8800,
            emissiveIntensity: 1.0
          })
        );
        innerFlame.position.y = 0.55 * scale;
        innerFlame.name = 'innerFlame';
        group.add(innerFlame);

        for (let i = 0; i < 5; i++) {
          const ember = new THREE.Mesh(
            new THREE.SphereGeometry(0.04 * scale, 4, 4),
            emberMat
          );
          ember.position.x = (Math.random() - 0.5) * 0.4 * scale;
          ember.position.z = (Math.random() - 0.5) * 0.4 * scale;
          ember.position.y = 0.2 * scale;
          group.add(ember);
        }

        const fireLight = new THREE.PointLight(0xff6622, 2, 15);
        fireLight.position.y = 0.8 * scale;
        group.add(fireLight);

        group.userData.animationType = 'flicker';
        group.userData.flickerSpeed = 8;
        break;

      case 'portal_ring':
        const ringMat = new THREE.MeshLambertMaterial({
          color: 0x8866ff,
          emissive: 0x4422cc,
          emissiveIntensity: 0.8
        });
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x555555 });

        const leftPillar = new THREE.Mesh(
          new THREE.BoxGeometry(0.4 * scale, 4 * scale, 0.4 * scale),
          frameMat
        );
        leftPillar.position.set(-1.5 * scale, 2 * scale, 0);
        group.add(leftPillar);

        const rightPillar = new THREE.Mesh(
          new THREE.BoxGeometry(0.4 * scale, 4 * scale, 0.4 * scale),
          frameMat
        );
        rightPillar.position.set(1.5 * scale, 2 * scale, 0);
        group.add(rightPillar);

        const arch = new THREE.Mesh(
          new THREE.TorusGeometry(1.5 * scale, 0.2 * scale, 8, 12, Math.PI),
          frameMat
        );
        arch.position.y = 4 * scale;
        group.add(arch);

        const innerRing = new THREE.Mesh(
          new THREE.TorusGeometry(1.2 * scale, 0.08 * scale, 8, 24),
          ringMat
        );
        innerRing.position.y = 2.5 * scale;
        innerRing.name = 'portalRing';
        group.add(innerRing);

        const portalCenter = new THREE.Mesh(
          new THREE.CircleGeometry(1.1 * scale, 16),
          new THREE.MeshLambertMaterial({
            color: 0xaa88ff,
            emissive: 0x6644cc,
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
          })
        );
        portalCenter.position.y = 2.5 * scale;
        portalCenter.name = 'portalCenter';
        group.add(portalCenter);

        group.userData.animationType = 'portal';
        group.userData.spinSpeed = 0.5;
        break;

      case 'signpost':
        const postMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
        const signMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        const signPost = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * scale, 0.08 * scale, 2.5 * scale, 6),
          postMat
        );
        signPost.position.y = 1.25 * scale;
        group.add(signPost);

        const signAngles = [0, Math.PI / 3, -Math.PI / 4];
        const signColors = [0x9b7924, 0x8b6914, 0x7b5904];
        signAngles.forEach(function(angle, i) {
          var signBoard = new THREE.Mesh(
            new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.05 * scale),
            new THREE.MeshLambertMaterial({ color: signColors[i] })
          );
          signBoard.position.y = (2.0 - i * 0.35) * scale;
          signBoard.position.x = 0.3 * scale;
          signBoard.rotation.y = angle;
          group.add(signBoard);
        });
        break;

      case 'gazebo':
        const gazeboWoodMat = new THREE.MeshLambertMaterial({ color: 0xc9a96e });
        const gazeboRoofMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });

        const floor = new THREE.Mesh(
          new THREE.CylinderGeometry(2.5 * scale, 2.5 * scale, 0.2 * scale, 8),
          gazeboWoodMat
        );
        floor.position.y = 0.3 * scale;
        group.add(floor);

        for (let i = 0; i < 6; i++) {
          const gazeboPillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1 * scale, 0.1 * scale, 2.5 * scale, 6),
            gazeboWoodMat
          );
          const pAngle = (i / 6) * Math.PI * 2;
          gazeboPillar.position.x = Math.cos(pAngle) * 2.2 * scale;
          gazeboPillar.position.z = Math.sin(pAngle) * 2.2 * scale;
          gazeboPillar.position.y = 1.55 * scale;
          group.add(gazeboPillar);
        }

        const gazeboRoof = new THREE.Mesh(
          new THREE.ConeGeometry(3 * scale, 1.5 * scale, 8),
          gazeboRoofMat
        );
        gazeboRoof.position.y = 3.6 * scale;
        group.add(gazeboRoof);

        for (let i = 0; i < 6; i++) {
          if (i === 0) continue; // Leave one gap for entrance
          const a1 = (i / 6) * Math.PI * 2;
          const a2 = ((i + 1) / 6) * Math.PI * 2;
          const midAngle = (a1 + a2) / 2;
          const railing = new THREE.Mesh(
            new THREE.BoxGeometry(1.5 * scale, 0.1 * scale, 0.08 * scale),
            gazeboWoodMat
          );
          railing.position.x = Math.cos(midAngle) * 2.2 * scale;
          railing.position.z = Math.sin(midAngle) * 2.2 * scale;
          railing.position.y = 0.8 * scale;
          railing.rotation.y = midAngle + Math.PI / 2;
          group.add(railing);
        }
        break;
    }

    return group;
  }

  function createResourceNode(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'resource_' + type;
    group.userData.isResource = true;
    group.userData.resourceType = type;

    switch(type) {
      case 'ore_vein':
        const oreMat = new THREE.MeshLambertMaterial({ color: 0x8a7b6b });
        const oreGlintMat = new THREE.MeshLambertMaterial({
          color: 0xccaa66,
          emissive: 0x886622,
          emissiveIntensity: 0.4
        });

        const oreRock = new THREE.Mesh(
          new THREE.DodecahedronGeometry(0.7 * scale, 0),
          oreMat
        );
        oreRock.position.y = 0.4 * scale;
        oreRock.scale.y = 0.6;
        group.add(oreRock);

        for (let i = 0; i < 4; i++) {
          const vein = new THREE.Mesh(
            new THREE.SphereGeometry(0.12 * scale, 6, 4),
            oreGlintMat
          );
          const angle = (i / 4) * Math.PI * 2 + Math.random();
          vein.position.x = Math.cos(angle) * 0.4 * scale;
          vein.position.z = Math.sin(angle) * 0.4 * scale;
          vein.position.y = (0.3 + Math.random() * 0.3) * scale;
          group.add(vein);
        }

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 0.8;
        break;

      case 'crystal_cluster':
        const crystalColors = [0x88aaff, 0xaa88ff, 0x66ccff, 0xcc88ff];

        for (let i = 0; i < 5; i++) {
          const crystalHeight = (0.5 + Math.random() * 1.0) * scale;
          const crystalRadius = (0.08 + Math.random() * 0.12) * scale;
          const crystal = new THREE.Mesh(
            new THREE.ConeGeometry(crystalRadius, crystalHeight, 6),
            new THREE.MeshLambertMaterial({
              color: crystalColors[i % crystalColors.length],
              emissive: crystalColors[i % crystalColors.length],
              emissiveIntensity: 0.3,
              transparent: true,
              opacity: 0.85
            })
          );
          const angle = (i / 5) * Math.PI * 2;
          const rad = 0.2 * scale;
          crystal.position.x = Math.cos(angle) * rad;
          crystal.position.z = Math.sin(angle) * rad;
          crystal.position.y = crystalHeight / 2;
          crystal.rotation.x = (Math.random() - 0.5) * 0.3;
          crystal.rotation.z = (Math.random() - 0.5) * 0.3;
          group.add(crystal);
        }

        const crystalLight = new THREE.PointLight(0x8888ff, 0.8, 8);
        crystalLight.position.y = 0.5 * scale;
        group.add(crystalLight);

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 1.2;
        break;

      case 'herb_patch':
        const stemMat = new THREE.MeshLambertMaterial({ color: 0x2d7a2d });
        const flowerColors = [0xff88aa, 0xffaa44, 0xaa88ff, 0x88ffaa];

        for (let i = 0; i < 6; i++) {
          const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02 * scale, 0.02 * scale, 0.4 * scale, 4),
            stemMat
          );
          const angle = (i / 6) * Math.PI * 2;
          const rad = 0.3 * scale;
          stem.position.x = Math.cos(angle) * rad;
          stem.position.z = Math.sin(angle) * rad;
          stem.position.y = 0.2 * scale;
          group.add(stem);

          const flower = new THREE.Mesh(
            new THREE.SphereGeometry(0.06 * scale, 6, 4),
            new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] })
          );
          flower.position.x = stem.position.x;
          flower.position.z = stem.position.z;
          flower.position.y = 0.42 * scale;
          group.add(flower);
        }

        const leafMat = new THREE.MeshLambertMaterial({ color: 0x3a8a3a });
        const leafGround = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 0.05 * scale, 8),
          leafMat
        );
        leafGround.position.y = 0.02 * scale;
        group.add(leafGround);

        group.userData.animationType = 'sway';
        group.userData.swayAmount = 0.03;
        group.userData.swaySpeed = 1.5;
        break;

      case 'flower_bed':
        const fStemMat = new THREE.MeshLambertMaterial({ color: 0x2d7a2d });
        const petalColors = [0xff4488, 0xff88cc, 0xffaa66, 0xffff44, 0xff6644];

        for (let i = 0; i < 8; i++) {
          const fStem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015 * scale, 0.02 * scale, 0.5 * scale, 4),
            fStemMat
          );
          const angle = Math.random() * Math.PI * 2;
          const rad = Math.random() * 0.5 * scale;
          fStem.position.x = Math.cos(angle) * rad;
          fStem.position.z = Math.sin(angle) * rad;
          fStem.position.y = 0.25 * scale;
          fStem.rotation.x = (Math.random() - 0.5) * 0.15;
          fStem.rotation.z = (Math.random() - 0.5) * 0.15;
          group.add(fStem);

          const flowerHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.08 * scale, 6, 4),
            new THREE.MeshLambertMaterial({
              color: petalColors[Math.floor(Math.random() * petalColors.length)]
            })
          );
          flowerHead.position.set(fStem.position.x, 0.52 * scale, fStem.position.z);
          group.add(flowerHead);
        }

        group.userData.animationType = 'sway';
        group.userData.swayAmount = 0.02;
        group.userData.swaySpeed = 2;
        break;

      case 'wood_pile':
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
        const barkMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

        var logCount = 0;
        for (let row = 0; row < 3; row++) {
          var logsInRow = 3 - row;
          for (let i = 0; i < logsInRow; i++) {
            const log = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12 * scale, 0.12 * scale, 1.0 * scale, 6),
              row % 2 === 0 ? woodMat : barkMat
            );
            log.rotation.z = Math.PI / 2;
            log.position.x = (i - (logsInRow - 1) / 2) * 0.26 * scale;
            log.position.y = (0.12 + row * 0.22) * scale;
            log.position.z = ((logCount % 2) * 0.05 - 0.025) * scale;
            group.add(log);
            logCount++;
          }
        }
        break;
    }

    return group;
  }

  function createWildlife(type) {
    const group = new THREE.Group();
    group.name = 'wildlife_' + type;

    switch(type) {
      case 'deer':
        const deerBodyMat = new THREE.MeshLambertMaterial({ color: 0xb8860b });
        const deerLegMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        const deerBody = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.35, 0.8),
          deerBodyMat
        );
        deerBody.position.y = 0.7;
        group.add(deerBody);

        const deerHead = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.25),
          deerBodyMat
        );
        deerHead.position.set(0, 0.95, 0.4);
        group.add(deerHead);

        const antlerMat = new THREE.MeshLambertMaterial({ color: 0xd2b48c });
        for (let side = -1; side <= 1; side += 2) {
          const antler = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4),
            antlerMat
          );
          antler.position.set(side * 0.1, 1.15, 0.4);
          antler.rotation.z = side * Math.PI / 6;
          group.add(antler);

          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.015, 0.15, 4),
            antlerMat
          );
          branch.position.set(side * 0.2, 1.25, 0.4);
          branch.rotation.z = side * Math.PI / 4;
          group.add(branch);
        }

        var legPositions = [
          { x: -0.12, z: 0.25 }, { x: 0.12, z: 0.25 },
          { x: -0.12, z: -0.25 }, { x: 0.12, z: -0.25 }
        ];
        legPositions.forEach(function(pos) {
          var leg = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.03, 0.5, 6),
            deerLegMat
          );
          leg.position.set(pos.x, 0.3, pos.z);
          group.add(leg);
        });

        const tailMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const deerTail = new THREE.Mesh(
          new THREE.ConeGeometry(0.05, 0.1, 4),
          tailMat
        );
        deerTail.position.set(0, 0.75, -0.45);
        deerTail.rotation.x = -Math.PI / 4;
        group.add(deerTail);

        group.userData.animationType = 'idle_look';
        group.scale.set(1.5, 1.5, 1.5);
        break;

      case 'rabbit':
        const rabbitMat = new THREE.MeshLambertMaterial({ color: 0xd2b48c });

        const rabbitBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 8, 6),
          rabbitMat
        );
        rabbitBody.position.y = 0.2;
        rabbitBody.scale.z = 1.3;
        group.add(rabbitBody);

        const rabbitHead = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 6),
          rabbitMat
        );
        rabbitHead.position.set(0, 0.3, 0.15);
        group.add(rabbitHead);

        const earMat = new THREE.MeshLambertMaterial({ color: 0xc4a882 });
        for (let side = -1; side <= 1; side += 2) {
          const ear = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, 0.15, 0.05),
            earMat
          );
          ear.position.set(side * 0.05, 0.45, 0.15);
          ear.rotation.z = side * 0.2;
          group.add(ear);
        }

        const puffTail = new THREE.Mesh(
          new THREE.SphereGeometry(0.06, 6, 4),
          new THREE.MeshLambertMaterial({ color: 0xeeeeee })
        );
        puffTail.position.set(0, 0.2, -0.2);
        group.add(puffTail);

        group.userData.animationType = 'hop';
        group.userData.hopInterval = 3;
        group.userData.hopTimer = Math.random() * 3;
        break;

      case 'firefly':
        const ffBodyMat = new THREE.MeshLambertMaterial({ color: 0x333300 });
        const ffGlowMat = new THREE.MeshLambertMaterial({
          color: 0xffff44,
          emissive: 0xaacc00,
          emissiveIntensity: 1.0
        });

        const ffBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 6, 4),
          ffBodyMat
        );
        group.add(ffBody);

        const ffGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 6, 4),
          ffGlowMat
        );
        ffGlow.position.z = -0.04;
        ffGlow.name = 'glow';
        group.add(ffGlow);

        const ffLight = new THREE.PointLight(0xaacc00, 0.5, 4);
        ffLight.position.z = -0.04;
        group.add(ffLight);

        group.userData.animationType = 'float';
        group.userData.floatSpeed = 0.5 + Math.random() * 0.5;
        group.userData.floatRadius = 1 + Math.random() * 2;
        group.userData.floatAngle = Math.random() * Math.PI * 2;
        group.userData.floatHeight = 1.5 + Math.random();
        break;

      case 'frog':
        const frogMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
        const frogEyeMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });

        const frogBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 8, 6),
          frogMat
        );
        frogBody.position.y = 0.1;
        frogBody.scale.y = 0.7;
        frogBody.scale.z = 1.2;
        group.add(frogBody);

        for (let side = -1; side <= 1; side += 2) {
          const eye = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 6, 4),
            frogEyeMat
          );
          eye.position.set(side * 0.06, 0.18, 0.08);
          group.add(eye);
        }

        for (let side = -1; side <= 1; side += 2) {
          const backLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.04, 0.15),
            frogMat
          );
          backLeg.position.set(side * 0.1, 0.05, -0.12);
          group.add(backLeg);
        }

        group.userData.animationType = 'hop';
        group.userData.hopInterval = 5;
        group.userData.hopTimer = Math.random() * 5;
        break;
    }

    return group;
  }

  function animateModel(model, deltaTime, worldTime) {
    if (!model.userData.animationType || model.userData.animationType === 'none') {
      return;
    }

    const type = model.userData.animationType;

    switch(type) {
      case 'sway':
        const swayAmount = model.userData.swayAmount || 0.05;
        const swaySpeed = model.userData.swaySpeed || 1.0;
        model.rotation.z = Math.sin(worldTime * swaySpeed) * swayAmount;
        model.rotation.x = Math.cos(worldTime * swaySpeed * 0.7) * swayAmount * 0.5;
        break;

      case 'flap':
        const flapSpeed = model.userData.flapSpeed || 8;
        const flapAmount = model.userData.flapAmount || Math.PI / 4;
        const flapAngle = Math.sin(worldTime * flapSpeed) * flapAmount;

        const leftWing = model.getObjectByName('leftWing');
        const rightWing = model.getObjectByName('rightWing');

        if (leftWing) {
          leftWing.rotation.y = flapAngle;
        }
        if (rightWing) {
          rightWing.rotation.y = -flapAngle;
        }
        break;

      case 'swim':
        const swimSpeed = model.userData.swimSpeed || 1;
        const swimRadius = model.userData.swimRadius || 2;

        model.userData.swimAngle = (model.userData.swimAngle || 0) + deltaTime * swimSpeed;

        const centerX = model.userData.swimCenterX || 0;
        const centerZ = model.userData.swimCenterZ || 0;

        model.position.x = centerX + Math.cos(model.userData.swimAngle) * swimRadius;
        model.position.z = centerZ + Math.sin(model.userData.swimAngle) * swimRadius;
        model.rotation.y = model.userData.swimAngle + Math.PI / 2;
        break;

      case 'bob':
        const bobSpeed = model.userData.bobSpeed || 1.5;
        const bobAmount = model.userData.bobAmount || 0.2;
        const baseY = model.userData.baseY || model.position.y;

        if (model.userData.baseY === undefined) {
          model.userData.baseY = model.position.y;
        }

        model.position.y = baseY + Math.sin(worldTime * bobSpeed) * bobAmount;
        break;

      case 'spin':
        const spinSpeed = model.userData.spinSpeed || 0.5;
        model.rotation.y += deltaTime * spinSpeed;
        break;

      case 'pulse':
        var pulseSpeed = model.userData.pulseSpeed || 1.5;
        var pulseVal = 1 + Math.sin(worldTime * pulseSpeed) * 0.08;
        model.scale.set(pulseVal, pulseVal, pulseVal);
        break;

      case 'flicker':
        var flickerSpeed = model.userData.flickerSpeed || 8;
        var fireCore = model.getObjectByName('fireCore');
        var innerFlame = model.getObjectByName('innerFlame');
        if (fireCore) {
          fireCore.scale.x = 0.8 + Math.sin(worldTime * flickerSpeed) * 0.3;
          fireCore.scale.z = 0.8 + Math.cos(worldTime * flickerSpeed * 1.3) * 0.3;
          fireCore.scale.y = 0.9 + Math.sin(worldTime * flickerSpeed * 0.7) * 0.2;
          fireCore.position.y = 0.5 + Math.sin(worldTime * flickerSpeed * 1.1) * 0.05;
        }
        if (innerFlame) {
          innerFlame.scale.x = 0.7 + Math.cos(worldTime * flickerSpeed * 1.5) * 0.4;
          innerFlame.scale.z = 0.7 + Math.sin(worldTime * flickerSpeed * 0.9) * 0.4;
          innerFlame.rotation.y += deltaTime * 2;
        }
        break;

      case 'fountain':
        var waterDrop = model.getObjectByName('waterDrop');
        if (waterDrop) {
          var fountainCycle = worldTime * 2;
          var dropPhase = fountainCycle % 2;
          if (dropPhase < 1) {
            waterDrop.position.y = 2.5 + dropPhase * 0.5;
            waterDrop.scale.set(1, 1, 1);
          } else {
            waterDrop.position.y = 3.0 - (dropPhase - 1) * 0.8;
            var shrink = 1 - (dropPhase - 1) * 0.5;
            waterDrop.scale.set(shrink, shrink, shrink);
          }
        }
        break;

      case 'portal':
        var portalRing = model.getObjectByName('portalRing');
        var portalCenter = model.getObjectByName('portalCenter');
        if (portalRing) {
          portalRing.rotation.z += deltaTime * 0.5;
        }
        if (portalCenter) {
          portalCenter.rotation.z -= deltaTime * 0.3;
          var opacity = 0.3 + Math.sin(worldTime * 1.5) * 0.2;
          if (portalCenter.material) {
            portalCenter.material.opacity = opacity;
          }
        }
        break;

      case 'float':
        var floatSpeed = model.userData.floatSpeed || 0.5;
        var floatRadius = model.userData.floatRadius || 2;
        var floatHeight = model.userData.floatHeight || 2;

        model.userData.floatAngle = (model.userData.floatAngle || 0) + deltaTime * floatSpeed;
        var fAngle = model.userData.floatAngle;

        if (model.userData.floatCenterX === undefined) {
          model.userData.floatCenterX = model.position.x;
          model.userData.floatCenterZ = model.position.z;
        }

        model.position.x = model.userData.floatCenterX + Math.cos(fAngle) * floatRadius;
        model.position.z = model.userData.floatCenterZ + Math.sin(fAngle * 0.7) * floatRadius;
        model.position.y = floatHeight + Math.sin(fAngle * 1.3) * 0.5;
        break;

      case 'hop':
        model.userData.hopTimer = (model.userData.hopTimer || 0) - deltaTime;
        if (model.userData.hopTimer <= 0) {
          model.userData.hopTimer = model.userData.hopInterval || 3;
          model.userData.isHopping = true;
          model.userData.hopPhase = 0;
          model.userData.hopDirX = (Math.random() - 0.5) * 2;
          model.userData.hopDirZ = (Math.random() - 0.5) * 2;
        }
        if (model.userData.isHopping) {
          model.userData.hopPhase += deltaTime * 4;
          if (model.userData.hopPhase < Math.PI) {
            var hopHeight = Math.sin(model.userData.hopPhase) * 0.3;
            if (model.userData.baseHopY === undefined) {
              model.userData.baseHopY = model.position.y;
            }
            model.position.y = model.userData.baseHopY + hopHeight;
            model.position.x += model.userData.hopDirX * deltaTime;
            model.position.z += model.userData.hopDirZ * deltaTime;
          } else {
            model.position.y = model.userData.baseHopY || model.position.y;
            model.userData.isHopping = false;
          }
        }
        break;

      case 'idle_look':
        model.rotation.y = Math.sin(worldTime * 0.3) * 0.3;
        break;
    }
  }

  function createGrassPatch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'grass_patch';
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.03;
    group.userData.swaySpeed = 2.0;

    var grassColors = [0x4a8028, 0x3a6b1f, 0x5a9030, 0x2d5016, 0x68a840];

    var bladeCount = 8 + Math.floor(Math.random() * 5);
    for (var i = 0; i < bladeCount; i++) {
      var bladeHeight = (0.3 + Math.random() * 0.4) * scale;
      var bladeGeo = new THREE.PlaneGeometry(0.04 * scale, bladeHeight);
      var bladeMat = new THREE.MeshLambertMaterial({
        color: grassColors[Math.floor(Math.random() * grassColors.length)],
        side: THREE.DoubleSide
      });
      var blade = new THREE.Mesh(bladeGeo, bladeMat);

      var angle = (i / bladeCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
      var radius = Math.random() * 0.3 * scale;
      blade.position.x = Math.cos(angle) * radius;
      blade.position.z = Math.sin(angle) * radius;
      blade.position.y = bladeHeight * 0.5;
      blade.rotation.y = Math.random() * Math.PI;
      blade.rotation.z = (Math.random() - 0.5) * 0.3;
      group.add(blade);
    }

    return group;
  }

  function createMushroom(type, scale) {
    scale = scale || 1;
    type = type || 'red';
    var group = new THREE.Group();
    group.name = 'mushroom_' + type;

    var stemMat = new THREE.MeshLambertMaterial({ color: 0xf5deb3 });
    var capColors = {
      red: 0xcc3333,
      brown: 0x8b6914,
      white: 0xf0f0e0,
      purple: 0x9966cc,
      glowing: 0x66ffcc
    };
    var capColor = capColors[type] || capColors.red;

    var stem = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.05 * scale, 0.2 * scale, 6),
      stemMat
    );
    stem.position.y = 0.1 * scale;
    group.add(stem);

    var capMat = new THREE.MeshLambertMaterial({ color: capColor });
    if (type === 'glowing') {
      capMat = new THREE.MeshBasicMaterial({ color: capColor });
    }
    var cap = new THREE.Mesh(
      new THREE.SphereGeometry(0.1 * scale, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.6),
      capMat
    );
    cap.position.y = 0.2 * scale;
    group.add(cap);

    if (type === 'red' || type === 'purple') {
      for (var s = 0; s < 4; s++) {
        var spot = new THREE.Mesh(
          new THREE.CircleGeometry(0.015 * scale, 6),
          new THREE.MeshLambertMaterial({ color: 0xffffff })
        );
        var sAngle = (s / 4) * Math.PI * 2;
        spot.position.x = Math.cos(sAngle) * 0.07 * scale;
        spot.position.z = Math.sin(sAngle) * 0.07 * scale;
        spot.position.y = 0.23 * scale;
        spot.rotation.x = -Math.PI * 0.3;
        spot.rotation.y = sAngle;
        group.add(spot);
      }
    }

    for (var m = 0; m < 1 + Math.floor(Math.random() * 2); m++) {
      var smallScale = 0.5 + Math.random() * 0.3;
      var smallStem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03 * scale * smallScale, 0.04 * scale * smallScale, 0.15 * scale * smallScale, 6),
        stemMat
      );
      var mAngle = Math.random() * Math.PI * 2;
      var mDist = 0.1 + Math.random() * 0.1;
      smallStem.position.x = Math.cos(mAngle) * mDist * scale;
      smallStem.position.z = Math.sin(mAngle) * mDist * scale;
      smallStem.position.y = 0.075 * scale * smallScale;
      group.add(smallStem);

      var smallCap = new THREE.Mesh(
        new THREE.SphereGeometry(0.07 * scale * smallScale, 6, 5, 0, Math.PI * 2, 0, Math.PI * 0.6),
        capMat
      );
      smallCap.position.x = smallStem.position.x;
      smallCap.position.z = smallStem.position.z;
      smallCap.position.y = 0.15 * scale * smallScale;
      group.add(smallCap);
    }

    if (type === 'glowing') {
      var glow = new THREE.PointLight(0x66ffcc, 0.5, 3 * scale);
      glow.position.y = 0.2 * scale;
      group.add(glow);
      group.userData.animationType = 'pulse';
    }

    return group;
  }

  function createBush(type, scale) {
    scale = scale || 1;
    type = type || 'green';
    var group = new THREE.Group();
    group.name = 'bush_' + type;
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.02;
    group.userData.swaySpeed = 0.8;

    var bushColors = {
      green: [0x2d5016, 0x3a6b1f, 0x4a8028],
      flowering: [0x3a6b1f, 0x4a8028, 0x5a9030],
      berry: [0x2d5016, 0x3a6b1f],
      autumn: [0xcc6600, 0xdd8800, 0xaa4400]
    };

    var colors = bushColors[type] || bushColors.green;

    var clumpCount = 4 + Math.floor(Math.random() * 3);
    for (var i = 0; i < clumpCount; i++) {
      var clumpSize = (0.25 + Math.random() * 0.2) * scale;
      var clump = new THREE.Mesh(
        new THREE.SphereGeometry(clumpSize, 6, 5),
        new THREE.MeshLambertMaterial({
          color: colors[Math.floor(Math.random() * colors.length)]
        })
      );
      var cAngle = (i / clumpCount) * Math.PI * 2 + Math.random() * 0.5;
      var cRadius = 0.15 * scale;
      clump.position.x = Math.cos(cAngle) * cRadius;
      clump.position.z = Math.sin(cAngle) * cRadius;
      clump.position.y = clumpSize * 0.7;
      group.add(clump);
    }

    if (type === 'flowering') {
      var flowerColors = [0xff6699, 0xffcc00, 0xff9933, 0xcc66ff, 0xff3366];
      for (var f = 0; f < 5 + Math.floor(Math.random() * 4); f++) {
        var flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.04 * scale, 5, 4),
          new THREE.MeshLambertMaterial({
            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
          })
        );
        var fAngle = Math.random() * Math.PI * 2;
        var fRadius = Math.random() * 0.35 * scale;
        flower.position.x = Math.cos(fAngle) * fRadius;
        flower.position.z = Math.sin(fAngle) * fRadius;
        flower.position.y = 0.3 * scale + Math.random() * 0.15 * scale;
        group.add(flower);
      }
    }

    if (type === 'berry') {
      for (var b = 0; b < 6 + Math.floor(Math.random() * 5); b++) {
        var berry = new THREE.Mesh(
          new THREE.SphereGeometry(0.025 * scale, 5, 4),
          new THREE.MeshLambertMaterial({ color: 0xcc0033 })
        );
        var bAngle = Math.random() * Math.PI * 2;
        var bRadius = Math.random() * 0.3 * scale;
        berry.position.x = Math.cos(bAngle) * bRadius;
        berry.position.z = Math.sin(bAngle) * bRadius;
        berry.position.y = 0.2 * scale + Math.random() * 0.2 * scale;
        group.add(berry);
      }
    }

    return group;
  }

  function createFallenLog(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'fallen_log';

    var barkMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
    var innerMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });

    var log = new THREE.Mesh(
      new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 2.5 * scale, 8),
      barkMat
    );
    log.rotation.z = Math.PI / 2;
    log.position.y = 0.15 * scale;
    group.add(log);

    var ring = new THREE.Mesh(
      new THREE.CircleGeometry(0.15 * scale, 8),
      innerMat
    );
    ring.position.x = 1.25 * scale;
    ring.position.y = 0.15 * scale;
    ring.rotation.y = Math.PI / 2;
    group.add(ring);

    var mossMat = new THREE.MeshLambertMaterial({ color: 0x4a8028 });
    for (var i = 0; i < 3; i++) {
      var moss = new THREE.Mesh(
        new THREE.SphereGeometry(0.08 * scale, 5, 4, 0, Math.PI * 2, 0, Math.PI * 0.5),
        mossMat
      );
      moss.position.x = (Math.random() - 0.5) * 1.5 * scale;
      moss.position.y = 0.28 * scale;
      moss.position.z = (Math.random() - 0.5) * 0.1 * scale;
      group.add(moss);
    }

    if (Math.random() < 0.5) {
      var logMushroom = createMushroom('brown', scale * 0.4);
      logMushroom.position.x = (Math.random() - 0.5) * scale;
      logMushroom.position.y = 0.3 * scale;
      group.add(logMushroom);
    }

    return group;
  }

  function createRuinWall(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'ruin_wall';

    var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8378 });
    var mossyMat = new THREE.MeshLambertMaterial({ color: 0x6b7c5a });

    var wallBase = new THREE.Mesh(
      new THREE.BoxGeometry(4 * scale, 2 * scale, 0.5 * scale),
      stoneMat
    );
    wallBase.position.y = 1 * scale;
    group.add(wallBase);

    var topHeights = [0.8, 1.2, 0.4, 1.0, 0.6, 0.9, 0.3];
    for (var i = 0; i < topHeights.length; i++) {
      var blockW = (4 / topHeights.length) * scale;
      var blockH = topHeights[i] * scale;
      var mat = Math.random() < 0.3 ? mossyMat : stoneMat;
      var block = new THREE.Mesh(
        new THREE.BoxGeometry(blockW * 0.9, blockH, 0.5 * scale),
        mat
      );
      block.position.x = (i - topHeights.length / 2 + 0.5) * blockW;
      block.position.y = 2 * scale + blockH / 2;
      group.add(block);
    }

    for (var m = 0; m < 4; m++) {
      var moss = new THREE.Mesh(
        new THREE.SphereGeometry(0.15 * scale, 5, 4, 0, Math.PI * 2, 0, Math.PI * 0.5),
        mossyMat
      );
      moss.position.x = (Math.random() - 0.5) * 3.5 * scale;
      moss.position.y = 0.05 * scale;
      moss.position.z = 0.2 * scale;
      group.add(moss);
    }

    return group;
  }

  function createColumnRow(count, height, spacing, scale) {
    scale = scale || 1;
    count = count || 4;
    height = height || 4;
    spacing = spacing || 2;
    var group = new THREE.Group();
    group.name = 'column_row';

    var columnMat = new THREE.MeshPhongMaterial({ color: 0xd4c8b0 });
    var capMat = new THREE.MeshPhongMaterial({ color: 0xc8bca0 });

    for (var i = 0; i < count; i++) {
      var shaft = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, height * scale, 8),
        columnMat
      );
      shaft.position.x = (i - (count - 1) / 2) * spacing * scale;
      shaft.position.y = height * scale / 2;
      group.add(shaft);

      var base = new THREE.Mesh(
        new THREE.BoxGeometry(0.6 * scale, 0.15 * scale, 0.6 * scale),
        capMat
      );
      base.position.x = shaft.position.x;
      base.position.y = 0.075 * scale;
      group.add(base);

      var capital = new THREE.Mesh(
        new THREE.BoxGeometry(0.55 * scale, 0.12 * scale, 0.55 * scale),
        capMat
      );
      capital.position.x = shaft.position.x;
      capital.position.y = height * scale + 0.06 * scale;
      group.add(capital);
    }

    var beam = new THREE.Mesh(
      new THREE.BoxGeometry((count - 1) * spacing * scale + 0.8 * scale, 0.2 * scale, 0.5 * scale),
      capMat
    );
    beam.position.y = height * scale + 0.22 * scale;
    group.add(beam);

    return group;
  }

  function createAmphitheater(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'amphitheater';

    var seatMat = new THREE.MeshLambertMaterial({ color: 0xa09080 });
    var stageMat = new THREE.MeshLambertMaterial({ color: 0xd4c090 });

    for (var tier = 0; tier < 5; tier++) {
      var innerR = (3 + tier * 1.5) * scale;
      var outerR = innerR + 1.2 * scale;
      var seatHeight = (0.4 + tier * 0.5) * scale;

      var segments = 12;
      for (var s = 0; s < segments; s++) {
        var angle = (s / segments) * Math.PI - Math.PI / 2; // semicircle
        var midR = (innerR + outerR) / 2;
        var seat = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 * scale, 0.3 * scale, 1.0 * scale),
          seatMat
        );
        seat.position.x = Math.cos(angle) * midR;
        seat.position.z = Math.sin(angle) * midR;
        seat.position.y = seatHeight;
        seat.rotation.y = -angle + Math.PI / 2;
        group.add(seat);
      }
    }

    var stage = new THREE.Mesh(
      new THREE.CylinderGeometry(2.5 * scale, 2.5 * scale, 0.3 * scale, 16, 1, false, 0, Math.PI),
      stageMat
    );
    stage.position.y = 0.15 * scale;
    group.add(stage);

    for (var c = -1; c <= 1; c++) {
      var col = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 3 * scale, 6),
        new THREE.MeshPhongMaterial({ color: 0xc8b890 })
      );
      col.position.x = c * 2 * scale;
      col.position.y = 1.5 * scale;
      col.position.z = -0.5 * scale;
      group.add(col);
    }

    return group;
  }

  function createWishingWell(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'wishing_well';

    var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
    var roofMat = new THREE.MeshLambertMaterial({ color: 0x5a3e2b });
    var waterMat = new THREE.MeshPhongMaterial({ color: 0x2244aa, transparent: true, opacity: 0.6 });

    var wallOuter = new THREE.Mesh(
      new THREE.CylinderGeometry(0.8 * scale, 0.85 * scale, 0.7 * scale, 12),
      stoneMat
    );
    wallOuter.position.y = 0.35 * scale;
    group.add(wallOuter);

    var water = new THREE.Mesh(
      new THREE.CylinderGeometry(0.65 * scale, 0.65 * scale, 0.05 * scale, 12),
      waterMat
    );
    water.position.y = 0.5 * scale;
    group.add(water);

    for (var p = 0; p < 2; p++) {
      var post = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06 * scale, 0.06 * scale, 1.8 * scale, 6),
        roofMat
      );
      post.position.x = (p === 0 ? -0.6 : 0.6) * scale;
      post.position.y = 1.2 * scale;
      group.add(post);
    }

    var beam = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.04 * scale, 1.3 * scale, 6),
      roofMat
    );
    beam.rotation.z = Math.PI / 2;
    beam.position.y = 2.1 * scale;
    group.add(beam);

    var roof = new THREE.Mesh(
      new THREE.ConeGeometry(0.9 * scale, 0.5 * scale, 4),
      roofMat
    );
    roof.position.y = 2.45 * scale;
    roof.rotation.y = Math.PI / 4;
    group.add(roof);

    var bucket = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1 * scale, 0.08 * scale, 0.15 * scale, 8, 1, true),
      new THREE.MeshLambertMaterial({ color: 0x654321, side: THREE.DoubleSide })
    );
    bucket.position.y = 1.5 * scale;
    group.add(bucket);

    group.userData.animationType = 'bob';
    group.userData.bobSpeed = 0.5;
    group.userData.bobAmount = 0.02;

    return group;
  }

  function createBookshelf(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'bookshelf';

    var woodMat = new THREE.MeshLambertMaterial({ color: 0x5c3a1e });
    var bookColors = [0x8b0000, 0x00008b, 0x006400, 0x8b4513, 0x4b0082, 0xb8860b, 0x2f4f4f];

    var back = new THREE.Mesh(
      new THREE.BoxGeometry(1.5 * scale, 2.2 * scale, 0.05 * scale),
      woodMat
    );
    back.position.y = 1.1 * scale;
    back.position.z = -0.15 * scale;
    group.add(back);

    for (var side = -1; side <= 1; side += 2) {
      var sidePanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.05 * scale, 2.2 * scale, 0.35 * scale),
        woodMat
      );
      sidePanel.position.x = side * 0.75 * scale;
      sidePanel.position.y = 1.1 * scale;
      group.add(sidePanel);
    }

    for (var shelf = 0; shelf < 5; shelf++) {
      var shelfBoard = new THREE.Mesh(
        new THREE.BoxGeometry(1.5 * scale, 0.04 * scale, 0.35 * scale),
        woodMat
      );
      shelfBoard.position.y = shelf * 0.55 * scale;
      group.add(shelfBoard);

      if (shelf < 4) {
        var bookCount = 5 + Math.floor(Math.random() * 4);
        var xPos = -0.6 * scale;
        for (var b = 0; b < bookCount && xPos < 0.6 * scale; b++) {
          var bookW = (0.06 + Math.random() * 0.08) * scale;
          var bookH = (0.35 + Math.random() * 0.15) * scale;
          var book = new THREE.Mesh(
            new THREE.BoxGeometry(bookW, bookH, 0.2 * scale),
            new THREE.MeshLambertMaterial({ color: bookColors[Math.floor(Math.random() * bookColors.length)] })
          );
          book.position.x = xPos + bookW / 2;
          book.position.y = shelf * 0.55 * scale + 0.02 * scale + bookH / 2;
          book.rotation.z = (Math.random() - 0.5) * 0.08;
          group.add(book);
          xPos += bookW + 0.01 * scale;
        }
      }
    }

    return group;
  }

  function createTorch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'torch';

    var bracketMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
    var bracket = new THREE.Mesh(
      new THREE.BoxGeometry(0.08 * scale, 0.08 * scale, 0.3 * scale),
      bracketMat
    );
    bracket.position.z = -0.15 * scale;
    bracket.position.y = 1.5 * scale;
    group.add(bracket);

    var handleMat = new THREE.MeshLambertMaterial({ color: 0x5c3a1e });
    var handle = new THREE.Mesh(
      new THREE.CylinderGeometry(0.03 * scale, 0.04 * scale, 0.6 * scale, 6),
      handleMat
    );
    handle.position.y = 1.5 * scale;
    group.add(handle);

    var fireMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
    var innerFireMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

    var fireOuter = new THREE.Mesh(
      new THREE.ConeGeometry(0.08 * scale, 0.2 * scale, 6),
      fireMat
    );
    fireOuter.position.y = 1.9 * scale;
    group.add(fireOuter);

    var fireInner = new THREE.Mesh(
      new THREE.ConeGeometry(0.04 * scale, 0.15 * scale, 5),
      innerFireMat
    );
    fireInner.position.y = 1.88 * scale;
    group.add(fireInner);

    var light = new THREE.PointLight(0xff8833, 0.8, 10);
    light.position.y = 2 * scale;
    group.add(light);

    group.userData.animationType = 'fire';

    return group;
  }

  function createBridge(length, scale) {
    scale = scale || 1;
    length = length || 8;
    var group = new THREE.Group();
    group.name = 'bridge';

    var plankMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
    var ropeMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
    var postMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

    for (var end = -1; end <= 1; end += 2) {
      for (var side = -1; side <= 1; side += 2) {
        var post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * scale, 0.06 * scale, 1.5 * scale, 6),
          postMat
        );
        post.position.x = end * length / 2 * scale;
        post.position.y = 0.75 * scale;
        post.position.z = side * 0.6 * scale;
        group.add(post);
      }
    }

    var plankCount = Math.floor(length * 2);
    for (var p = 0; p < plankCount; p++) {
      var plank = new THREE.Mesh(
        new THREE.BoxGeometry(0.4 * scale, 0.04 * scale, 1.0 * scale),
        plankMat
      );
      plank.position.x = (p / plankCount - 0.5) * length * scale;
      var sagT = (p / plankCount - 0.5) * 2;
      plank.position.y = -sagT * sagT * 0.3 * scale + 0.3 * scale;
      plank.rotation.y = (Math.random() - 0.5) * 0.05;
      group.add(plank);
    }

    for (var ropeSide = -1; ropeSide <= 1; ropeSide += 2) {
      var ropeSegments = 8;
      for (var rs = 0; rs < ropeSegments; rs++) {
        var segLen = length / ropeSegments * scale;
        var rope = new THREE.Mesh(
          new THREE.CylinderGeometry(0.015 * scale, 0.015 * scale, segLen, 4),
          ropeMat
        );
        rope.rotation.z = Math.PI / 2;
        var t1 = rs / ropeSegments - 0.5;
        rope.position.x = (t1 + 0.5 / ropeSegments) * length * scale;
        var sagR = t1 * 2;
        rope.position.y = 1.2 * scale - sagR * sagR * 0.2 * scale;
        rope.position.z = ropeSide * 0.6 * scale;
        group.add(rope);
      }
    }

    return group;
  }

  function createGardenArch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'garden_arch';

    var woodMat = new THREE.MeshLambertMaterial({ color: 0xfaf0e6 });
    var vineMat = new THREE.MeshLambertMaterial({ color: 0x2d5a1e });
    var flowerMat = new THREE.MeshLambertMaterial({ color: 0xff69b4 });

    for (var s = -1; s <= 1; s += 2) {
      var post = new THREE.Mesh(
        new THREE.BoxGeometry(0.1 * scale, 3 * scale, 0.1 * scale),
        woodMat
      );
      post.position.x = s * 1.2 * scale;
      post.position.y = 1.5 * scale;
      group.add(post);
    }

    var archSegments = 8;
    for (var a = 0; a < archSegments; a++) {
      var angle = (a / (archSegments - 1)) * Math.PI;
      var ax = Math.cos(angle) * 1.2 * scale;
      var ay = 3 * scale + Math.sin(angle) * 0.6 * scale;
      var seg = new THREE.Mesh(
        new THREE.BoxGeometry(0.35 * scale, 0.08 * scale, 0.1 * scale),
        woodMat
      );
      seg.position.x = ax;
      seg.position.y = ay;
      seg.rotation.z = angle - Math.PI / 2;
      group.add(seg);
    }

    for (var v = 0; v < 8; v++) {
      var vineAngle = (v / 8) * Math.PI;
      var vine = new THREE.Mesh(
        new THREE.SphereGeometry(0.08 * scale, 5, 4),
        vineMat
      );
      vine.position.x = Math.cos(vineAngle) * 1.15 * scale;
      vine.position.y = 2.9 * scale + Math.sin(vineAngle) * 0.55 * scale;
      vine.position.z = (Math.random() - 0.5) * 0.15 * scale;
      group.add(vine);

      if (Math.random() < 0.4) {
        var flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.05 * scale, 5, 4),
          flowerMat
        );
        flower.position.copy(vine.position);
        flower.position.z += 0.1 * scale;
        group.add(flower);
      }
    }

    for (var side = -1; side <= 1; side += 2) {
      for (var tv = 0; tv < 4; tv++) {
        var tendril = new THREE.Mesh(
          new THREE.SphereGeometry(0.06 * scale, 4, 3),
          vineMat
        );
        tendril.position.x = side * 1.15 * scale + (Math.random() - 0.5) * 0.1 * scale;
        tendril.position.y = 0.5 + tv * 0.7 * scale;
        tendril.position.z = (Math.random() - 0.5) * 0.1 * scale;
        group.add(tendril);
      }
    }

    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.01;
    group.userData.swaySpeed = 1;

    return group;
  }

  function createBannerPole(color, scale) {
    scale = scale || 1;
    color = color || 0xcc0000;
    var group = new THREE.Group();
    group.name = 'banner_pole';

    var poleMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
    var pole = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.05 * scale, 4 * scale, 6),
      poleMat
    );
    pole.position.y = 2 * scale;
    group.add(pole);

    var finial = new THREE.Mesh(
      new THREE.SphereGeometry(0.08 * scale, 6, 6),
      new THREE.MeshPhongMaterial({ color: 0xdaa520 })
    );
    finial.position.y = 4.1 * scale;
    group.add(finial);

    var bannerMat = new THREE.MeshLambertMaterial({ color: color, side: THREE.DoubleSide });
    var bannerGeo = new THREE.PlaneGeometry(0.8 * scale, 1.2 * scale);
    var banner = new THREE.Mesh(bannerGeo, bannerMat);
    banner.position.x = 0.4 * scale;
    banner.position.y = 3.4 * scale;
    group.add(banner);

    var trimMat = new THREE.MeshLambertMaterial({ color: 0xdaa520 });
    var trim = new THREE.Mesh(
      new THREE.BoxGeometry(0.82 * scale, 0.04 * scale, 0.02 * scale),
      trimMat
    );
    trim.position.x = 0.4 * scale;
    trim.position.y = 4 * scale;
    group.add(trim);

    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.03;
    group.userData.swaySpeed = 1.5;

    return group;
  }

  exports.createTree = createTree;
  exports.createRock = createRock;
  exports.createBuilding = createBuilding;
  exports.createFurniture = createFurniture;
  exports.createCreature = createCreature;
  exports.createLandmark = createLandmark;
  exports.createResourceNode = createResourceNode;
  exports.createWildlife = createWildlife;
  exports.createGrassPatch = createGrassPatch;
  exports.createMushroom = createMushroom;
  exports.createBush = createBush;
  exports.createFallenLog = createFallenLog;
  exports.createRuinWall = createRuinWall;
  exports.createColumnRow = createColumnRow;
  exports.createAmphitheater = createAmphitheater;
  exports.createWishingWell = createWishingWell;
  exports.createBookshelf = createBookshelf;
  exports.createTorch = createTorch;
  exports.createBridge = createBridge;
  exports.createGardenArch = createGardenArch;
  exports.createBannerPole = createBannerPole;
  exports.animateModel = animateModel;

})(typeof module !== 'undefined' ? module.exports : (window.Models = {}));


// auth.js
(function(exports) {
  const OAUTH_CONFIG = {
    clientId: 'Iv23lixLqM3xo88npTs4',
    scope: 'read:user',
    authorizeUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://zion-oauth.kwildfeuer.workers.dev'
  };

  const TOKEN_KEY = 'zion_auth_token';
  const USERNAME_KEY = 'zion_username';
  const AVATAR_KEY = 'zion_avatar';

  function getStorage(key) {
    if (typeof localStorage === 'undefined') return null;
    try { return localStorage.getItem(key); } catch (e) { return null; }
  }
  function setStorage(key, value) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.setItem(key, value); } catch (e) {}
  }
  function removeStorage(key) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.removeItem(key); } catch (e) {}
  }

  function initiateOAuth() {
    if (typeof window === 'undefined') return;
    var redirectUri = window.location.origin + window.location.pathname;
    var url = OAUTH_CONFIG.authorizeUrl +
      '?client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
      '&redirect_uri=' + encodeURIComponent(redirectUri) +
      '&scope=' + encodeURIComponent(OAUTH_CONFIG.scope);
    window.location.href = url;
  }

  async function handleCallback() {
    if (typeof window === 'undefined') return null;
    var params = new URLSearchParams(window.location.search);
    var code = params.get('code');

    var token = params.get('token');
    if (token) {
      setStorage(TOKEN_KEY, token);
      window.history.replaceState({}, document.title, window.location.pathname);
      return token;
    }

    if (!code) return null;

    window.history.replaceState({}, document.title, window.location.pathname);

    try {
      var res = await fetch(OAUTH_CONFIG.tokenUrl, {
        method: 'POST',
        headers: {
          'Accept': 'application/json'
        },
        body: 'client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
              '&code=' + encodeURIComponent(code)
      });

      if (!res.ok) {
        console.error('Token exchange failed:', res.status);
        return null;
      }

      var data = await res.json();
      if (data.access_token) {
        setStorage(TOKEN_KEY, data.access_token);
        await getProfile(data.access_token);
        return data.access_token;
      } else {
        console.error('Token exchange error:', data.error, data.error_description);
        return null;
      }
    } catch (e) {
      console.error('OAuth callback error:', e);
      return null;
    }
  }

  async function getProfile(token) {
    if (typeof fetch === 'undefined') throw new Error('fetch not available');
    var response = await fetch('https://api.github.com/user', {
      headers: { 'Authorization': 'Bearer ' + token, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!response.ok) throw new Error('GitHub API error: ' + response.status);
    var data = await response.json();
    setStorage(USERNAME_KEY, data.login);
    setStorage(AVATAR_KEY, data.avatar_url || '');
    return { username: data.login, avatar_url: data.avatar_url };
  }

  function isAuthenticated() { return !!getStorage(TOKEN_KEY); }
  function getUsername() { return getStorage(USERNAME_KEY); }
  function getToken() { return getStorage(TOKEN_KEY); }
  function setToken(token) { setStorage(TOKEN_KEY, token); }

  function loginAsGuest(username) {
    if (!username || typeof username !== 'string') return false;
    username = username.trim().replace(/[^a-zA-Z0-9_-]/g, '');
    if (username.length < 1 || username.length > 39) return false;
    setStorage(TOKEN_KEY, 'guest_' + username);
    setStorage(USERNAME_KEY, username);
    setStorage(AVATAR_KEY, '');
    return true;
  }

  function logout() {
    removeStorage(TOKEN_KEY);
    removeStorage(USERNAME_KEY);
    removeStorage(AVATAR_KEY);
  }

  var PLAYER_DATA_KEY = 'zion_player_data';
  var PLAYER_PREFS_KEY = 'zion_player_prefs';

  function savePlayerData(data) {
    if (!data) return;
    try {
      var saveData = {
        version: 2,
        ts: Date.now(),
        username: getUsername(),
        inventory: data.inventory || null,
        spark: data.spark || 0,
        position: data.position || null,
        zone: data.zone || 'nexus',
        skills: data.skills || null,
        questState: data.questState || null,
        achievements: data.achievements || null,
        guild: data.guild || null,
        discoveredSecrets: data.discoveredSecrets || [],
        warmth: data.warmth || 0,
        playTime: data.playTime || 0,
        lastSave: Date.now()
      };
      setStorage(PLAYER_DATA_KEY, JSON.stringify(saveData));
    } catch (e) {
      console.warn('Failed to save player data:', e);
    }
  }

  function loadPlayerData() {
    try {
      var raw = getStorage(PLAYER_DATA_KEY);
      if (!raw) return null;
      var data = JSON.parse(raw);
      if (data.username !== getUsername()) return null;
      return data;
    } catch (e) {
      console.warn('Failed to load player data:', e);
      return null;
    }
  }

  function savePreferences(prefs) {
    try {
      setStorage(PLAYER_PREFS_KEY, JSON.stringify(prefs));
    } catch (e) {}
  }

  function loadPreferences() {
    try {
      var raw = getStorage(PLAYER_PREFS_KEY);
      if (!raw) return getDefaultPreferences();
      return JSON.parse(raw);
    } catch (e) {
      return getDefaultPreferences();
    }
  }

  function getDefaultPreferences() {
    return {
      volume: 0.5,
      musicVolume: 0.3,
      sfxVolume: 0.5,
      quality: 'medium',
      chatVisible: true,
      minimapVisible: true,
      showFPS: false,
      controlsHint: true
    };
  }

  function getAvatarUrl() {
    return getStorage(AVATAR_KEY) || '';
  }

  function isGuest() {
    var token = getStorage(TOKEN_KEY);
    return token ? token.startsWith('guest_') : false;
  }

  function getTimeSinceLastSave() {
    var data = loadPlayerData();
    if (!data || !data.lastSave) return Infinity;
    return Date.now() - data.lastSave;
  }

  exports.OAUTH_CONFIG = OAUTH_CONFIG;
  exports.initiateOAuth = initiateOAuth;
  exports.handleCallback = handleCallback;
  exports.getProfile = getProfile;
  exports.isAuthenticated = isAuthenticated;
  exports.getUsername = getUsername;
  exports.getToken = getToken;
  exports.setToken = setToken;
  exports.loginAsGuest = loginAsGuest;
  exports.logout = logout;
  exports.savePlayerData = savePlayerData;
  exports.loadPlayerData = loadPlayerData;
  exports.savePreferences = savePreferences;
  exports.loadPreferences = loadPreferences;
  exports.getDefaultPreferences = getDefaultPreferences;
  exports.getAvatarUrl = getAvatarUrl;
  exports.isGuest = isGuest;
  exports.getTimeSinceLastSave = getTimeSinceLastSave;

})(typeof module !== 'undefined' ? module.exports : (window.Auth = {}));


// network.js
(function(exports) {
  let peer = null;
  let connections = new Map(); // peerId -> connection
  let messageCallback = null;
  let peerConnectCallback = null;
  let peerDisconnectCallback = null;
  let seenMessages = new Set(); // For deduplication
  const MAX_SEEN_MESSAGES = 1000;

  function initMesh(peerId, options = {}) {
    if (typeof Peer === 'undefined') {
      console.warn('PeerJS not available. Network mesh disabled.');
      return null;
    }

    messageCallback = options.onMessage || (() => {});
    peerConnectCallback = options.onPeerConnect || (() => {});
    peerDisconnectCallback = options.onPeerDisconnect || (() => {});

    peer = new Peer(peerId, {
      debug: 2 // Set to 3 for verbose logging
    });

    peer.on('open', (id) => {
      console.log('Mesh network initialized. Peer ID:', id);
    });

    peer.on('connection', (conn) => {
      handleConnection(conn);
    });

    peer.on('error', (err) => {
      if (err.type === 'peer-unavailable') {
        return;
      }
      console.error('Peer error:', err);
      if (err.type === 'network') {
        attemptReconnect(peerId, 0);
      }
    });

    peer.on('disconnected', () => {
      console.warn('Peer disconnected from signaling server');
      attemptReconnect(peerId, 0);
    });

    return peer;
  }

  function handleConnection(conn) {
    const remotePeerId = conn.peer;

    conn.on('open', () => {
      console.log('Connected to peer:', remotePeerId);
      connections.set(remotePeerId, conn);
      peerConnectCallback(remotePeerId);
    });

    conn.on('data', (data) => {
      handleIncomingMessage(data, remotePeerId);
    });

    conn.on('close', () => {
      console.log('Peer disconnected:', remotePeerId);
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });

    conn.on('error', (err) => {
      if (err && err.type !== 'peer-unavailable') {
        console.warn('Connection error with peer', remotePeerId, ':', err);
      }
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });
  }

  function handleIncomingMessage(data, fromPeer) {
    try {
      const msg = typeof data === 'string' ? JSON.parse(data) : data;

      const msgId = generateMessageId(msg);

      if (seenMessages.has(msgId)) {
        return; // Duplicate, ignore
      }

      seenMessages.add(msgId);

      if (seenMessages.size > MAX_SEEN_MESSAGES) {
        const firstItem = seenMessages.values().next().value;
        seenMessages.delete(firstItem);
      }

      relayMessage(msg, fromPeer);

      messageCallback(msg);
    } catch (err) {
      console.error('Error handling message:', err);
    }
  }

  function generateMessageId(msg) {
    const str = JSON.stringify({
      type: msg.type,
      from: msg.from,
      timestamp: msg.timestamp,
      nonce: msg.nonce
    });
    return simpleHash(str);
  }

  function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  function relayMessage(msg, excludePeer) {
    connections.forEach((conn, peerId) => {
      if (peerId !== excludePeer && conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error relaying to peer', peerId, ':', err);
        }
      }
    });
  }

  function broadcastMessage(msg) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    const msgId = generateMessageId(msg);
    seenMessages.add(msgId);

    connections.forEach((conn, peerId) => {
      if (conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error sending to peer', peerId, ':', err);
        }
      }
    });
  }

  function onMessage(callback) {
    messageCallback = callback;
  }

  function getPeers() {
    return Array.from(connections.keys());
  }

  function connectToPeer(peerId) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    if (connections.has(peerId)) {
      console.log('Already connected to peer:', peerId);
      return;
    }

    console.log('Connecting to peer:', peerId);
    const conn = peer.connect(peerId, {
      reliable: true
    });

    handleConnection(conn);
  }

  function disconnect() {
    if (!peer) return;

    connections.forEach((conn) => {
      conn.close();
    });

    connections.clear();
    peer.destroy();
    peer = null;

    console.log('Disconnected from mesh network');
  }

  function attemptReconnect(peerId, attempt) {
    const maxAttempts = 3;
    if (attempt >= maxAttempts) {
      console.log('Max reconnection attempts reached, will retry on next discovery cycle');
      return;
    }

    const delay = Math.pow(2, attempt) * 1000; // Exponential: 1s, 2s, 4s
    console.log(`Reconnecting in ${delay}ms (attempt ${attempt + 1}/${maxAttempts})`);

    setTimeout(() => {
      if (!peer || peer.destroyed) {
        console.log('Attempting to reconnect...');
        peer.reconnect();

        setTimeout(() => {
          if (peer && !peer.open) {
            attemptReconnect(peerId, attempt + 1);
          }
        }, 2000);
      }
    }, delay);
  }

  function getLobbyPeerId(worldId = 'main') {
    return `zion-lobby-${worldId}`;
  }

  var lobbyState = {
    peerId: null,
    worldId: 'main',
    discoveryInterval: null,
    knownPeers: [],       // All peer IDs ever seen
    heartbeatInterval: null,
    playerName: '',
    zone: 'nexus',
    lastAnnounce: 0
  };

  function joinLobby(worldId, playerName, zone) {
    lobbyState.worldId = worldId || 'main';
    lobbyState.playerName = playerName || 'Anonymous';
    lobbyState.zone = zone || 'nexus';

    if (!peer) return;

    lobbyState.peerId = peer.id;

    var lobbyId = getLobbyPeerId(lobbyState.worldId);

    if (peer.id !== lobbyId) {
      connectToPeer(lobbyId);
    }

    var seedCount = 5;
    for (var i = 0; i < seedCount; i++) {
      var seedId = 'zion-seed-' + lobbyState.worldId + '-' + i;
      if (seedId !== peer.id) {
        connectToPeer(seedId);
      }
    }

    if (lobbyState.discoveryInterval) {
      clearInterval(lobbyState.discoveryInterval);
    }

    lobbyState.discoveryInterval = setInterval(function() {
      announcePresence();
    }, 10000); // Every 10 seconds

    if (lobbyState.heartbeatInterval) {
      clearInterval(lobbyState.heartbeatInterval);
    }

    lobbyState.heartbeatInterval = setInterval(function() {
      sendHeartbeat();
    }, 30000); // Every 30 seconds

    announcePresence();
  }

  function announcePresence() {
    if (!peer || !peer.open) return;

    var announcement = {
      type: '_lobby_announce',
      peerId: peer.id,
      playerName: lobbyState.playerName,
      zone: lobbyState.zone,
      peers: getPeers(), // Share our peer list for gossip
      timestamp: Date.now()
    };

    broadcastMessage(announcement);
    lobbyState.lastAnnounce = Date.now();
  }

  function sendHeartbeat() {
    if (!peer || !peer.open) return;

    broadcastMessage({
      type: '_heartbeat',
      peerId: peer.id,
      zone: lobbyState.zone,
      peerCount: connections.size,
      timestamp: Date.now()
    });
  }

  function handleLobbyMessage(msg) {
    if (!msg || !msg.type) return false;

    if (handleFederationMessage(msg)) {
      return true;
    }

    if (msg.type === '_lobby_announce') {
      if (msg.peers && Array.isArray(msg.peers)) {
        msg.peers.forEach(function(peerId) {
          if (peerId !== peer.id && !connections.has(peerId)) {
            if (lobbyState.knownPeers.indexOf(peerId) === -1) {
              lobbyState.knownPeers.push(peerId);
            }
            if (connections.size < 20) {
              connectToPeer(peerId);
            }
          }
        });
      }
      return true; // Handled
    }

    if (msg.type === '_heartbeat') {
      return true; // Handled, don't propagate to game
    }

    if (msg.type === '_peer_list_request') {
      broadcastMessage({
        type: '_lobby_announce',
        peerId: peer.id,
        playerName: lobbyState.playerName,
        zone: lobbyState.zone,
        peers: getPeers(),
        timestamp: Date.now()
      });
      return true;
    }

    return false; // Not a lobby message
  }

  function updateLobbyZone(zone) {
    lobbyState.zone = zone;
  }

  function leaveLobby() {
    if (lobbyState.discoveryInterval) {
      clearInterval(lobbyState.discoveryInterval);
      lobbyState.discoveryInterval = null;
    }
    if (lobbyState.heartbeatInterval) {
      clearInterval(lobbyState.heartbeatInterval);
      lobbyState.heartbeatInterval = null;
    }
  }

  function getNetworkStats() {
    return {
      peerId: peer ? peer.id : null,
      connected: peer ? peer.open : false,
      peerCount: connections.size,
      knownPeers: lobbyState.knownPeers.length,
      seenMessages: seenMessages.size
    };
  }

  var federationState = {
    worldId: null,
    worldName: null,
    endpoint: null,
    federatedPeers: new Map(), // worldId -> {peerId, connection, worldInfo}
    federationCallback: null,
    discoveredWorlds: new Map() // worldId -> worldInfo
  };

  function initFederation(worldId, worldName, endpoint) {
    federationState.worldId = worldId;
    federationState.worldName = worldName || worldId;
    federationState.endpoint = endpoint;

    console.log('Federation initialized for world:', worldId);
  }

  function getFederatedPeerId(worldId, playerId) {
    return `zion-fed-${worldId}-${playerId}`;
  }

  function announceFederation() {
    if (!peer || !peer.open) return;
    if (!federationState.worldId) {
      console.warn('Federation not initialized');
      return;
    }

    var announcement = {
      type: 'federation_announce',
      worldId: federationState.worldId,
      worldName: federationState.worldName,
      endpoint: federationState.endpoint,
      protocolVersion: 1,
      playerCount: connections.size,
      peerId: peer.id,
      timestamp: Date.now()
    };

    broadcastMessage(announcement);
    console.log('Federation announced:', federationState.worldName);
  }

  function federationHandshake(targetWorldId, worldInfo) {
    if (!peer || !peer.open) return;
    if (!federationState.worldId) {
      console.warn('Federation not initialized');
      return;
    }

    var federatedPeerId = getFederatedPeerId(targetWorldId, lobbyState.peerId);

    if (federationState.federatedPeers.has(targetWorldId)) {
      console.log('Already federated with world:', targetWorldId);
      return;
    }

    var handshake = {
      type: 'federation_handshake',
      from_world: federationState.worldId,
      to_world: targetWorldId,
      worldName: federationState.worldName,
      endpoint: federationState.endpoint,
      protocolVersion: 1,
      peerId: peer.id,
      timestamp: Date.now()
    };

    broadcastMessage(handshake);

    federationState.federatedPeers.set(targetWorldId, {
      worldId: targetWorldId,
      worldInfo: worldInfo,
      peerId: federatedPeerId,
      status: 'handshake_sent',
      timestamp: Date.now()
    });

    console.log('Federation handshake sent to:', targetWorldId);
  }

  function handleFederationMessage(msg) {
    if (!msg || !msg.type) return false;

    if (msg.type === 'federation_announce') {
      var worldId = msg.worldId || msg.payload?.worldId;
      if (worldId && worldId !== federationState.worldId) {
        var worldInfo = {
          worldId: worldId,
          worldName: msg.worldName || msg.payload?.worldName,
          endpoint: msg.endpoint || msg.payload?.endpoint,
          protocolVersion: msg.protocolVersion || msg.payload?.protocolVersion || 1,
          playerCount: msg.playerCount || msg.payload?.playerCount || 0,
          peerId: msg.peerId || msg.payload?.peerId,
          timestamp: msg.timestamp || Date.now()
        };

        federationState.discoveredWorlds.set(worldId, worldInfo);

        if (federationState.federationCallback) {
          federationState.federationCallback({
            type: 'world_discovered',
            worldInfo: worldInfo
          });
        }

        console.log('Discovered federated world:', worldInfo.worldName);
      }
      return true;
    }

    if (msg.type === 'federation_handshake') {
      var fromWorld = msg.from_world || msg.payload?.from_world;
      var toWorld = msg.to_world || msg.payload?.to_world;

      if (toWorld === federationState.worldId && fromWorld) {
        var worldInfo = {
          worldId: fromWorld,
          worldName: msg.worldName || msg.payload?.worldName,
          endpoint: msg.endpoint || msg.payload?.endpoint,
          protocolVersion: msg.protocolVersion || msg.payload?.protocolVersion || 1,
          peerId: msg.peerId || msg.payload?.peerId,
          timestamp: msg.timestamp || Date.now()
        };

        var existing = federationState.federatedPeers.get(fromWorld);
        if (existing && existing.status === 'active') {
          console.log('Federation already active with:', fromWorld);
          return true;
        }

        federationState.federatedPeers.set(fromWorld, {
          worldId: fromWorld,
          worldInfo: worldInfo,
          status: 'active',
          timestamp: Date.now()
        });

        if (federationState.federationCallback) {
          federationState.federationCallback({
            type: 'federation_established',
            worldInfo: worldInfo
          });
        }

        console.log('Federation established with:', worldInfo.worldName);
      }
      return true;
    }

    if (msg.type === 'warp_fork') {
      if (federationState.federationCallback) {
        federationState.federationCallback({
          type: 'cross_world_warp',
          playerId: msg.from,
          targetWorld: msg.payload?.target_world,
          position: msg.payload?.position
        });
      }
      return true;
    }

    if (msg.type === 'return_home') {
      if (federationState.federationCallback) {
        federationState.federationCallback({
          type: 'player_returned',
          playerId: msg.from,
          position: msg.payload?.position
        });
      }
      return true;
    }

    return false;
  }

  function onFederationEvent(callback) {
    federationState.federationCallback = callback;
  }

  function getFederatedWorlds() {
    return Array.from(federationState.federatedPeers.values());
  }

  function getDiscoveredWorlds() {
    return Array.from(federationState.discoveredWorlds.values());
  }

  function isFederatedWith(worldId) {
    var fed = federationState.federatedPeers.get(worldId);
    return fed && fed.status === 'active';
  }

  function deriveWorldId() {
    if (typeof window === 'undefined' || !window.location) {
      return 'localhost';
    }

    var url = window.location.href;
    var match = url.match(/github\.io\/([^\/]+)/);
    if (match) {
      return match[1];
    }

    return window.location.hostname.replace(/\./g, '-');
  }

  exports.initMesh = initMesh;
  exports.broadcastMessage = broadcastMessage;
  exports.onMessage = onMessage;
  exports.getPeers = getPeers;
  exports.connectToPeer = connectToPeer;
  exports.disconnect = disconnect;
  exports.getLobbyPeerId = getLobbyPeerId;
  exports.joinLobby = joinLobby;
  exports.leaveLobby = leaveLobby;
  exports.updateLobbyZone = updateLobbyZone;
  exports.handleLobbyMessage = handleLobbyMessage;
  exports.getNetworkStats = getNetworkStats;

  exports.initFederation = initFederation;
  exports.announceFederation = announceFederation;
  exports.federationHandshake = federationHandshake;
  exports.handleFederationMessage = handleFederationMessage;
  exports.onFederationEvent = onFederationEvent;
  exports.getFederatedWorlds = getFederatedWorlds;
  exports.getDiscoveredWorlds = getDiscoveredWorlds;
  exports.isFederatedWith = isFederatedWith;
  exports.deriveWorldId = deriveWorldId;
  exports.getFederatedPeerId = getFederatedPeerId;

})(typeof module !== 'undefined' ? module.exports : (window.Network = {}));


// federation.js
(function(exports) {
  'use strict';

  var PROTOCOL_VERSION = 1;
  var FEDERATION_ANNOUNCE = 'federation_announce';
  var FEDERATION_HANDSHAKE = 'federation_handshake';
  var WARP_FORK = 'warp_fork';
  var RETURN_HOME = 'return_home';

  var HEALTHY_LATENCY_THRESHOLD = 200;

  var connections = {};

  var visitors = [];

  var visiting = [];

  function generateUUID() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function now() {
    return new Date().toISOString();
  }

  function buildMessage(type, from, payload) {
    return {
      v: PROTOCOL_VERSION,
      id: generateUUID(),
      ts: now(),
      seq: 0,
      from: from || 'federation',
      type: type,
      platform: 'api',
      position: { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: null,
      payload: payload || {}
    };
  }

  function announce(worldConfig) {
    return buildMessage(FEDERATION_ANNOUNCE, worldConfig.adminUser || worldConfig.worldId, {
      worldId: worldConfig.worldId,
      worldName: worldConfig.worldName,
      endpoint: worldConfig.endpoint,
      protocolVersion: worldConfig.protocolVersion || PROTOCOL_VERSION,
      announcedAt: now()
    });
  }

  function handleAnnounce(message, localWorldId) {
    if (!message || !message.payload) {
      return { accept: false, reason: 'Invalid or missing announcement message' };
    }

    var p = message.payload;

    if (message.type !== FEDERATION_ANNOUNCE) {
      return { accept: false, reason: 'Message is not a federation_announce' };
    }

    if (!p.worldId || !p.worldName || !p.endpoint) {
      return { accept: false, reason: 'Missing required fields: worldId, worldName, or endpoint' };
    }

    if (localWorldId && p.worldId === localWorldId) {
      return { accept: false, reason: 'Self-connection rejected: cannot federate with yourself' };
    }

    var versionCheck = validateProtocolVersion(PROTOCOL_VERSION, p.protocolVersion);
    if (!versionCheck.compatible) {
      return { accept: false, reason: 'Protocol version incompatible: ' + versionCheck.reason };
    }

    return { accept: true };
  }

  function handshake(targetWorldId, localConfig, remoteConfig) {
    var accepted = true;

    if (accepted && remoteConfig) {
      var versionCheck = validateProtocolVersion(
        localConfig.protocolVersion || PROTOCOL_VERSION,
        remoteConfig.protocolVersion || PROTOCOL_VERSION
      );
      if (!versionCheck.compatible) {
        accepted = false;
      }
    }

    return buildMessage(FEDERATION_HANDSHAKE, localConfig.adminUser || localConfig.worldId, {
      worldId: localConfig.worldId,
      worldName: localConfig.worldName,
      endpoint: localConfig.endpoint,
      protocolVersion: localConfig.protocolVersion || PROTOCOL_VERSION,
      targetWorldId: targetWorldId,
      accepted: accepted,
      handshakeAt: now()
    });
  }

  function handleHandshake(message, localConfig) {
    if (!message || !message.payload) {
      return null;
    }

    var p = message.payload;

    if (!p.accepted) {
      return null;
    }

    if (localConfig && p.worldId === localConfig.worldId) {
      return null;
    }

    var conn = {
      worldId: p.worldId,
      worldName: p.worldName,
      endpoint: p.endpoint,
      protocolVersion: p.protocolVersion || PROTOCOL_VERSION,
      status: 'active',
      connectedSince: now(),
      lastHeartbeat: now(),
      playerCount: 0,
      latency: 0
    };

    connections[conn.worldId] = conn;

    return conn;
  }

  function connect(connObj) {
    if (!connObj || !connObj.worldId) {
      return;
    }
    connections[connObj.worldId] = Object.assign({}, connObj, {
      status: connObj.status || 'active'
    });
  }

  function disconnect(worldId) {
    if (!connections[worldId]) {
      return null;
    }

    var conn = connections[worldId];
    connections[worldId] = Object.assign({}, conn, { status: 'disconnected' });

    return buildMessage('leave', conn.worldId, {
      worldId: worldId,
      reason: 'federation_dissolved',
      disconnectedAt: now()
    });
  }

  function getConnections() {
    return Object.values(connections).filter(function(c) {
      return c.status === 'active';
    });
  }

  function isConnected(worldId) {
    return !!(connections[worldId] && connections[worldId].status === 'active');
  }

  function warpToFork(worldId, player) {
    var travelPack = {
      username: player.username,
      homeWorld: player.homeWorld,
      reputation: player.reputation || 0,
      appearance: player.appearance ? JSON.parse(JSON.stringify(player.appearance)) : {},
      intentions: player.intentions ? JSON.parse(JSON.stringify(player.intentions)) : [],
      skills: player.skills ? JSON.parse(JSON.stringify(player.skills)) : [],
      travelerMarks: player.travelerMarks ? JSON.parse(JSON.stringify(player.travelerMarks)) : [],
      departedAt: now()
    };

    var message = buildMessage(WARP_FORK, player.username, {
      fork_id: worldId,
      destination_zone: 'nexus',   // Â§10.4 visitors start in Nexus
      travelPack: travelPack
    });

    return { message: message, travelPack: travelPack };
  }

  function arriveFromFork(travelPack) {
    var visitor = {
      username: travelPack.username,
      homeWorld: travelPack.homeWorld,
      reputation: travelPack.reputation || 0,
      appearance: travelPack.appearance ? JSON.parse(JSON.stringify(travelPack.appearance)) : {},
      intentions: travelPack.intentions ? JSON.parse(JSON.stringify(travelPack.intentions)) : [],
      skills: travelPack.skills ? JSON.parse(JSON.stringify(travelPack.skills)) : [],
      travelerMarks: travelPack.travelerMarks ? JSON.parse(JSON.stringify(travelPack.travelerMarks)) : [],
      isVisitor: true,
      arrivedAt: now(),
      inventory: [],      // arrive with empty hands (Â§10.3)
      spark: 0,           // currency is sovereign (Â§10.3)
      isSteward: false,   // governance is local (Â§10.3)
      position: { x: 0, y: 0, z: 0, zone: 'nexus' }
    };

    return visitor;
  }

  function returnHome(player) {
    return buildMessage(RETURN_HOME, player.username, {
      homeWorld: player.homeWorld,
      departedAt: now()
    });
  }

  function registerVisitor(visitor) {
    visitors = visitors.filter(function(v) { return v.username !== visitor.username; });
    visitors.push({
      username: visitor.username,
      homeWorld: visitor.homeWorld,
      arrivedAt: visitor.arrivedAt || now()
    });
  }

  function getVisitors() {
    return visitors.slice();
  }

  function getVisiting() {
    return visiting.slice();
  }

  function createRiftPortal(connection) {
    var healthy = (connection.latency || 0) < HEALTHY_LATENCY_THRESHOLD && connection.status === 'active';

    return {
      worldId: connection.worldId,
      worldName: connection.worldName,
      playerCount: connection.playerCount || 0,
      latency: connection.latency || 0,
      healthy: healthy,
      description: connection.description || '',
      position: {
        x: 0, y: 0, z: -20,    // Rift portals placed at Nexus center near the hub
        zone: 'nexus'
      },
      type: 'rift_portal',
      createdAt: now()
    };
  }

  function updateRiftPortal(connection) {
    return createRiftPortal(connection);
  }

  function loadRegistry(federationJson) {
    if (!federationJson) {
      return { worldId: '', worldName: '', federations: [], discoveredWorlds: [] };
    }

    return {
      worldId: federationJson.worldId || '',
      worldName: federationJson.worldName || '',
      endpoint: federationJson.endpoint || '',
      protocolVersion: federationJson.protocolVersion || PROTOCOL_VERSION,
      federations: (federationJson.federations || []).map(function(f) {
        return {
          worldId: f.worldId,
          worldName: f.worldName,
          endpoint: f.endpoint,
          protocolVersion: f.protocolVersion || PROTOCOL_VERSION,
          federatedSince: f.federatedSince || null,
          status: f.status || 'unknown',
          playerCount: f.playerCount || 0,
          lastHeartbeat: f.lastHeartbeat || null
        };
      }),
      discoveredWorlds: federationJson.discoveredWorlds || [],
      lastAnnounce: federationJson.lastAnnounce || null
    };
  }

  function updateRegistry(activeConnections) {
    return {
      federations: (activeConnections || []).map(function(conn) {
        return {
          worldId: conn.worldId,
          worldName: conn.worldName,
          endpoint: conn.endpoint,
          protocolVersion: conn.protocolVersion || PROTOCOL_VERSION,
          federatedSince: conn.connectedSince || null,
          status: conn.status || 'active',
          playerCount: conn.playerCount || 0,
          lastHeartbeat: conn.lastHeartbeat || null
        };
      }),
      updatedAt: now()
    };
  }

  function getActiveWorlds() {
    return getConnections().map(function(conn) {
      return {
        worldId: conn.worldId,
        worldName: conn.worldName,
        endpoint: conn.endpoint,
        status: conn.status,
        playerCount: conn.playerCount || 0
      };
    });
  }

  function validateProtocolVersion(local, remote) {
    if (!remote || remote <= 0) {
      return { compatible: false, reason: 'Remote protocol version is missing or invalid (got ' + remote + ')' };
    }

    if (!local || local <= 0) {
      return { compatible: false, reason: 'Local protocol version is missing or invalid (got ' + local + ')' };
    }

    if (local !== remote) {
      return {
        compatible: false,
        reason: 'Protocol version mismatch: local=' + local + ', remote=' + remote
      };
    }

    return { compatible: true };
  }

  function validateFederationRequest(message, localConfig) {
    if (!message || typeof message !== 'object') {
      return { valid: false, reason: 'Message must be an object' };
    }

    if (message.type !== FEDERATION_ANNOUNCE && message.type !== FEDERATION_HANDSHAKE) {
      return {
        valid: false,
        reason: 'Message type must be federation_announce or federation_handshake, got: ' + message.type
      };
    }

    if (!message.payload || !message.payload.worldId) {
      return { valid: false, reason: 'Payload must include worldId' };
    }

    var versionCheck = validateProtocolVersion(
      (localConfig && localConfig.protocolVersion) || PROTOCOL_VERSION,
      message.payload.protocolVersion
    );
    if (!versionCheck.compatible) {
      return { valid: false, reason: 'Protocol incompatible: ' + versionCheck.reason };
    }

    return { valid: true };
  }

  function getState() {
    return {
      connections: JSON.parse(JSON.stringify(connections)),
      visitors: JSON.parse(JSON.stringify(visitors)),
      visiting: JSON.parse(JSON.stringify(visiting))
    };
  }

  exports.PROTOCOL_VERSION = PROTOCOL_VERSION;

  exports.announce = announce;
  exports.handleAnnounce = handleAnnounce;
  exports.handshake = handshake;
  exports.handleHandshake = handleHandshake;

  exports.connect = connect;
  exports.disconnect = disconnect;
  exports.getConnections = getConnections;
  exports.isConnected = isConnected;

  exports.warpToFork = warpToFork;
  exports.arriveFromFork = arriveFromFork;
  exports.returnHome = returnHome;

  exports.registerVisitor = registerVisitor;
  exports.getVisitors = getVisitors;
  exports.getVisiting = getVisiting;

  exports.createRiftPortal = createRiftPortal;
  exports.updateRiftPortal = updateRiftPortal;

  exports.loadRegistry = loadRegistry;
  exports.updateRegistry = updateRegistry;
  exports.getActiveWorlds = getActiveWorlds;

  exports.validateProtocolVersion = validateProtocolVersion;
  exports.validateFederationRequest = validateFederationRequest;

  exports.getState = getState;

})(typeof module !== 'undefined' ? module.exports : (window.Federation = {}));


// rift_portal.js

(function(exports) {
  'use strict';

  var NEXUS_X = 0;
  var NEXUS_Z = 0;

  var RING_RADIUS = 1.5;          // Outer torus radius (diameter 3)
  var RING_TUBE = 0.2;            // Torus tube thickness
  var DISC_RADIUS = 1.3;          // Inner disc radius
  var PARTICLE_SIZE = 0.12;       // Orbiting sphere radius
  var PARTICLE_COUNT = 10;        // Number of orbiting particles
  var PARTICLE_ORBIT_RADIUS = 1.8;// Orbit radius around portal centre

  var SEMICIRCLE_RADIUS = 20;     // Distance from Nexus centre
  var SEMICIRCLE_START_ANGLE = Math.PI * 0.1;
  var SEMICIRCLE_END_ANGLE   = Math.PI * 0.9;

  var DEFAULT_PROXIMITY_RANGE = 5;

  var COLOR_RING_HEALTHY   = 0x7c3aed;  // Purple
  var COLOR_RING_UNHEALTHY = 0xdc2626;  // Red
  var COLOR_DISC_A         = 0x4f46e5;  // Deep indigo
  var COLOR_DISC_B         = 0x818cf8;  // Light indigo
  var COLOR_PARTICLE_BASE  = 0x6ee7f7;  // Cyan
  var COLOR_GLOW_HEALTHY   = 0xa78bfa;  // Soft violet
  var COLOR_GLOW_UNHEALTHY = 0xf87171;  // Soft red
  var COLOR_STATUS_HEALTHY   = 0x22c55e;  // Green
  var COLOR_STATUS_UNHEALTHY = 0xef4444;  // Red

  var RING_ROTATION_SPEED    = 0.8;   // rad/s around Y
  var DISC_PULSE_SPEED       = 1.2;   // Hz
  var PARTICLE_ORBIT_SPEEDS  = [1.0, -0.7, 1.3, -0.9, 0.6, -1.1, 0.8, -0.5, 1.5, -1.2];
  var FLICKER_SPEED          = 8.0;   // Hz, for unhealthy portals

  function lerpColor(a, b, t) {
    var ar = (a >> 16) & 0xff, ag = (a >> 8) & 0xff, ab = a & 0xff;
    var br = (b >> 16) & 0xff, bg = (b >> 8) & 0xff, bb = b & 0xff;
    var r = Math.round(ar + (br - ar) * t);
    var g = Math.round(ag + (bg - ag) * t);
    var bl2 = Math.round(ab + (bb - ab) * t);
    return (r << 16) | (g << 8) | bl2;
  }

  function buildLabelText(connection) {
    var name = (connection && connection.worldName) ? connection.worldName : 'Unknown World';
    var count = (connection && typeof connection.playerCount === 'number') ? connection.playerCount : 0;
    var unit = count === 1 ? 'player' : 'players';
    return name + '\n(' + count + ' ' + unit + ')';
  }

  function createTextSprite(text, THREE) {
    var canvas = (typeof document !== 'undefined')
      ? document.createElement('canvas')
      : { width: 256, height: 128,
          getContext: function() {
            return {
              clearRect:         function() {},
              fillRect:          function() {},
              fillText:          function() {},
              measureText:       function(t) { return { width: t.length * 8 }; },
              beginPath:         function() {},
              moveTo:            function() {},
              lineTo:            function() {},
              quadraticCurveTo:  function() {},
              closePath:         function() {},
              fill:              function() {},
              roundRect:         function() {},
              font:              '',
              fillStyle:         '',
              textAlign:         '',
              textBaseline:      ''
            };
          }
        };

    canvas.width  = 256;
    canvas.height = 128;

    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 256, 128);

    ctx.fillStyle = 'rgba(20, 10, 40, 0.82)';
    _roundRect(ctx, 8, 8, 240, 112, 16);

    var lines = text.split('\n');
    ctx.font = 'bold 26px Arial, sans-serif';
    ctx.fillStyle = '#e0d7ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(lines[0] || '', 128, 44);

    ctx.font = '20px Arial, sans-serif';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText(lines[1] || '', 128, 84);

    var texture = new THREE.CanvasTexture
      ? new THREE.CanvasTexture(canvas)
      : new THREE.Texture(canvas);

    if (texture.needsUpdate !== undefined) {
      texture.needsUpdate = true;
    }

    var material = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      depthTest: false
    });

    var sprite = new THREE.Sprite(material);
    sprite.scale.set(4.0, 2.0, 1.0);
    return sprite;
  }

  function _roundRect(ctx, x, y, w, h, r) {
    if (ctx.roundRect) {
      ctx.beginPath();
      ctx.roundRect(x, y, w, h, r);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }
  }

  function getPortalPositions(count, terrainHeightFn) {
    if (!count || count <= 0) return [];

    var positions = [];
    for (var i = 0; i < count; i++) {
      var t = count === 1 ? 0.5 : i / (count - 1);
      var angle = SEMICIRCLE_START_ANGLE + t * (SEMICIRCLE_END_ANGLE - SEMICIRCLE_START_ANGLE);

      var x = NEXUS_X + Math.cos(angle) * SEMICIRCLE_RADIUS;
      var z = NEXUS_Z + Math.sin(angle) * SEMICIRCLE_RADIUS;
      var terrainY = (typeof terrainHeightFn === 'function') ? terrainHeightFn(x, z) : 0;
      var y = terrainY + 1;

      var facingAngle = Math.atan2(NEXUS_X - x, NEXUS_Z - z);

      positions.push({ x: x, y: y, z: z, angle: facingAngle });
    }
    return positions;
  }

  function createPortal(connection, scene, THREE) {
    if (!THREE) {
      if (typeof window !== 'undefined' && window.THREE) {
        THREE = window.THREE;
      } else {
        throw new Error('RiftPortal.createPortal: THREE is required');
      }
    }

    var healthy = _isHealthy(connection);
    var group = new THREE.Group();

    var ringGeo = new THREE.TorusGeometry(RING_RADIUS, RING_TUBE, 16, 48);
    var ringMat = new THREE.MeshPhongMaterial({
      color: healthy ? COLOR_RING_HEALTHY : COLOR_RING_UNHEALTHY,
      emissive: healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY,
      emissiveIntensity: 0.6,
      shininess: 80,
      transparent: true,
      opacity: 0.95
    });
    var ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2; // Stand upright
    ring.name = 'riftRing';
    group.add(ring);

    var discGeo = new THREE.CircleGeometry(DISC_RADIUS, 32);
    var discMat = new THREE.MeshBasicMaterial({
      color: COLOR_DISC_A,
      transparent: true,
      opacity: 0.75,
      side: 2 // THREE.DoubleSide = 2
    });
    var disc = new THREE.Mesh(discGeo, discMat);
    disc.rotation.x = Math.PI / 2; // Stand upright (same plane as ring)
    disc.name = 'riftDisc';
    group.add(disc);

    var particles = [];
    for (var i = 0; i < PARTICLE_COUNT; i++) {
      var pGeo = new THREE.SphereGeometry(PARTICLE_SIZE, 6, 6);
      var pColor = lerpColor(COLOR_PARTICLE_BASE, healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY, i / PARTICLE_COUNT);
      var pMat = new THREE.MeshBasicMaterial({
        color: pColor,
        transparent: true,
        opacity: 0.9
      });
      var particle = new THREE.Mesh(pGeo, pMat);
      var initAngle = (i / PARTICLE_COUNT) * Math.PI * 2;
      particle.position.x = Math.cos(initAngle) * PARTICLE_ORBIT_RADIUS;
      particle.position.y = Math.sin(initAngle) * PARTICLE_ORBIT_RADIUS;
      particle.position.z = 0;
      particle.name = 'riftParticle_' + i;
      particle.userData.orbitAngle = initAngle;
      particle.userData.orbitSpeed = PARTICLE_ORBIT_SPEEDS[i % PARTICLE_ORBIT_SPEEDS.length];
      group.add(particle);
      particles.push(particle);
    }

    var dotGeo = new THREE.SphereGeometry(0.15, 8, 8);
    var dotMat = new THREE.MeshBasicMaterial({
      color: healthy ? COLOR_STATUS_HEALTHY : COLOR_STATUS_UNHEALTHY
    });
    var statusDot = new THREE.Mesh(dotGeo, dotMat);
    statusDot.position.set(RING_RADIUS + 0.3, 0, 0);
    statusDot.name = 'riftStatusDot';
    group.add(statusDot);

    var labelSprite = createTextSprite(buildLabelText(connection), THREE);
    labelSprite.position.set(0, RING_RADIUS + 1.2, 0);
    labelSprite.name = 'riftLabel';
    group.add(labelSprite);

    group.name = 'riftPortal_' + (connection.worldId || 'unknown');
    group.userData.portalData = {
      worldId:     connection.worldId || '',
      worldName:   connection.worldName || '',
      playerCount: connection.playerCount || 0,
      latency:     connection.latency || 0,
      healthy:     healthy,
      time:        0,          // accumulated time for animation
      particles:   particles,
      ring:        ring,
      disc:        disc,
      statusDot:   statusDot,
      label:       labelSprite,
      connection:  connection
    };

    return group;
  }

  function updatePortal(portalObject, connection) {
    if (!portalObject || !portalObject.userData || !portalObject.userData.portalData) {
      return;
    }

    var pd = portalObject.userData.portalData;
    var healthy = _isHealthy(connection);
    var playerCountChanged = pd.playerCount !== (connection.playerCount || 0);

    pd.worldName   = connection.worldName || pd.worldName;
    pd.playerCount = connection.playerCount || 0;
    pd.latency     = connection.latency || 0;
    pd.healthy     = healthy;
    pd.connection  = connection;

    if (pd.ring && pd.ring.material) {
      pd.ring.material.color.setHex(healthy ? COLOR_RING_HEALTHY : COLOR_RING_UNHEALTHY);
      pd.ring.material.emissive.setHex(healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY);
    }

    if (pd.statusDot && pd.statusDot.material) {
      pd.statusDot.material.color.setHex(healthy ? COLOR_STATUS_HEALTHY : COLOR_STATUS_UNHEALTHY);
    }

    if (pd.particles) {
      for (var i = 0; i < pd.particles.length; i++) {
        var p = pd.particles[i];
        if (p && p.material) {
          var pColor = lerpColor(COLOR_PARTICLE_BASE, healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY, i / pd.particles.length);
          p.material.color.setHex(pColor);
        }
      }
    }

    if (playerCountChanged && pd.label) {
      var newText = buildLabelText(connection);
      _updateLabelText(pd.label, newText);
    }
  }

  function _updateLabelText(sprite, text) {
    if (!sprite || !sprite.material || !sprite.material.map) return;
    var map = sprite.material.map;
    if (!map.image || typeof map.image.getContext !== 'function') return;
    var canvas = map.image;
    var ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(20, 10, 40, 0.82)';
    _roundRect(ctx, 8, 8, 240, 112, 16);

    var lines = text.split('\n');
    ctx.font = 'bold 26px Arial, sans-serif';
    ctx.fillStyle = '#e0d7ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(lines[0] || '', 128, 44);

    ctx.font = '20px Arial, sans-serif';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText(lines[1] || '', 128, 84);

    map.needsUpdate = true;
  }

  function removePortal(portalObject, scene) {
    if (!portalObject) return;

    _disposeGroup(portalObject);

    if (scene && typeof scene.remove === 'function') {
      scene.remove(portalObject);
    }
  }

  function _disposeGroup(group) {
    if (!group || !group.children) return;
    for (var i = group.children.length - 1; i >= 0; i--) {
      var child = group.children[i];
      if (child.geometry && typeof child.geometry.dispose === 'function') {
        child.geometry.dispose();
      }
      if (child.material) {
        if (child.material.map && typeof child.material.map.dispose === 'function') {
          child.material.map.dispose();
        }
        if (typeof child.material.dispose === 'function') {
          child.material.dispose();
        }
      }
    }
  }

  function animatePortal(portalObject, deltaTime) {
    if (!portalObject || !portalObject.userData || !portalObject.userData.portalData) return;

    var pd = portalObject.userData.portalData;
    pd.time += deltaTime;

    var t = pd.time;
    var healthy = pd.healthy;

    if (pd.ring) {
      pd.ring.rotation.z += RING_ROTATION_SPEED * deltaTime;
    }

    if (pd.disc && pd.disc.material) {
      var pulse = (Math.sin(t * DISC_PULSE_SPEED * Math.PI * 2) + 1) * 0.5;
      var discColor = lerpColor(COLOR_DISC_A, COLOR_DISC_B, pulse);
      pd.disc.material.color.setHex(discColor);
      pd.disc.material.opacity = 0.55 + pulse * 0.3;
    }

    if (!healthy && pd.ring && pd.ring.material) {
      var flicker = (Math.sin(t * FLICKER_SPEED * Math.PI * 2) + 1) * 0.5;
      pd.ring.material.opacity = 0.5 + flicker * 0.45;
    }

    if (pd.particles) {
      for (var i = 0; i < pd.particles.length; i++) {
        var particle = pd.particles[i];
        if (!particle) continue;
        var speed = particle.userData.orbitSpeed || 1.0;
        particle.userData.orbitAngle += speed * deltaTime;
        var angle = particle.userData.orbitAngle;
        particle.position.x = Math.cos(angle) * PARTICLE_ORBIT_RADIUS;
        particle.position.y = Math.sin(angle) * PARTICLE_ORBIT_RADIUS;
        particle.position.z = Math.sin(angle * 2.3 + t) * 0.25;
      }
    }

    portalObject.position.y = (portalObject.userData.baseY || 0) +
      Math.sin(t * 0.8 + (portalObject.userData.hoverOffset || 0)) * 0.15;
  }

  function updateAll(portals, connections, scene, deltaTime, THREE, terrainHeightFn) {
    if (!portals || !connections || !scene) return;

    var threeLib = THREE || (typeof window !== 'undefined' && window.THREE) || null;
    if (!threeLib) return;

    var activeIds = {};
    for (var ci = 0; ci < connections.length; ci++) {
      var conn = connections[ci];
      if (conn && conn.worldId) {
        activeIds[conn.worldId] = conn;
      }
    }

    var existingIds = Object.keys(portals);
    for (var ri = 0; ri < existingIds.length; ri++) {
      var id = existingIds[ri];
      if (!activeIds[id]) {
        removePortal(portals[id], scene);
        delete portals[id];
      }
    }

    var connList = connections.filter(function(c) { return c && c.worldId; });
    var positions = getPortalPositions(connList.length, terrainHeightFn);

    for (var ai = 0; ai < connList.length; ai++) {
      var connection = connList[ai];
      var worldId = connection.worldId;
      var pos = positions[ai] || { x: 0, y: 1, z: -20, angle: 0 };

      if (!portals[worldId]) {
        var portal = createPortal(connection, scene, threeLib);
        portal.position.set(pos.x, pos.y, pos.z);
        portal.rotation.y = pos.angle;
        portal.userData.baseY = pos.y;
        portal.userData.hoverOffset = ai * 1.1; // stagger hover phase
        scene.add(portal);
        portals[worldId] = portal;
      } else {
        updatePortal(portals[worldId], connection);
      }

      animatePortal(portals[worldId], deltaTime);
    }
  }

  function isPlayerNearPortal(playerPos, portals, range) {
    if (!playerPos || !portals) {
      return { near: false, portal: null, worldId: null, distance: Infinity };
    }

    var checkRange = (typeof range === 'number' && range > 0) ? range : DEFAULT_PROXIMITY_RANGE;
    var rangeSq = checkRange * checkRange;

    var ids = Object.keys(portals);
    for (var i = 0; i < ids.length; i++) {
      var id = ids[i];
      var portalObj = portals[id];
      if (!portalObj || !portalObj.position) continue;

      var dx = playerPos.x - portalObj.position.x;
      var dy = playerPos.y - portalObj.position.y;
      var dz = playerPos.z - portalObj.position.z;
      var distSq = dx * dx + dy * dy + dz * dz;

      if (distSq <= rangeSq) {
        return {
          near: true,
          portal: portalObj,
          worldId: id,
          distance: Math.sqrt(distSq)
        };
      }
    }

    return { near: false, portal: null, worldId: null, distance: Infinity };
  }

  function _isHealthy(connection) {
    if (!connection) return false;
    var hasGoodLatency = (connection.latency === undefined || connection.latency < 200);
    var isActive = (connection.status === 'active' || connection.status === undefined);
    if (typeof connection.healthy === 'boolean') return connection.healthy;
    return hasGoodLatency && isActive;
  }

  exports.createPortal       = createPortal;
  exports.updatePortal       = updatePortal;
  exports.removePortal       = removePortal;
  exports.animatePortal      = animatePortal;
  exports.updateAll          = updateAll;
  exports.getPortalPositions = getPortalPositions;
  exports.isPlayerNearPortal = isPlayerNearPortal;

  exports._isHealthy         = _isHealthy;
  exports._buildLabelText    = buildLabelText;
  exports._lerpColor         = lerpColor;

  exports.RING_RADIUS            = RING_RADIUS;
  exports.DISC_RADIUS            = DISC_RADIUS;
  exports.PARTICLE_COUNT         = PARTICLE_COUNT;
  exports.SEMICIRCLE_RADIUS      = SEMICIRCLE_RADIUS;
  exports.DEFAULT_PROXIMITY_RANGE = DEFAULT_PROXIMITY_RANGE;

})(typeof module !== 'undefined' ? module.exports : (window.RiftPortal = {}));


// api_bridge.js
(function(exports) {
  'use strict';

  var REPO_OWNER = 'kody-w';
  var REPO_NAME = 'zion';
  var RAW_BASE = 'https://raw.githubusercontent.com/' + REPO_OWNER + '/' + REPO_NAME + '/main';
  var API_BASE = 'https://api.github.com/repos/' + REPO_OWNER + '/' + REPO_NAME;

  var PUBLISH_INTERVAL = 60000;  // 60s between state publishes
  var POLL_INTERVAL = 30000;     // 30s between inbox polls

  var lastPublishTime = 0;
  var lastPollTime = 0;
  var pendingMessages = [];

  function init() {
    console.log('[ApiBridge] Initialized â€” publish every %ds, poll every %ds',
      PUBLISH_INTERVAL / 1000, POLL_INTERVAL / 1000);
  }

  function update(now, gameState) {
    if (now - lastPublishTime >= PUBLISH_INTERVAL) {
      lastPublishTime = now;
      publishStateSnapshot(gameState);
    }

    if (now - lastPollTime >= POLL_INTERVAL) {
      lastPollTime = now;
      pollInbox(gameState);
    }

    if (pendingMessages.length > 0) {
      processPendingMessages(gameState);
    }
  }

  function buildSnapshot(gameState) {
    var state = typeof State !== 'undefined' ? State : {};
    var zones = typeof Zones !== 'undefined' ? Zones : {};
    var liveState = state.getLiveState ? state.getLiveState() : {};

    var world = liveState.world || {};
    var players = liveState.players || {};
    var economy = liveState.economy || {};
    var chat = liveState.chat || [];

    var playerZones = {};
    var playerEntries = {};
    for (var pid in players) {
      if (players.hasOwnProperty(pid)) {
        var p = players[pid];
        var pzone = (p.position && p.position.zone) || 'nexus';
        playerZones[pzone] = (playerZones[pzone] || 0) + 1;
        playerEntries[pid] = {
          position: p.position || {},
          zone: pzone,
          online: true
        };
      }
    }

    var zoneIds = zones.getAllZoneIds ? zones.getAllZoneIds() : [];
    var zoneSummaries = {};
    for (var i = 0; i < zoneIds.length; i++) {
      var zid = zoneIds[i];
      var zdata = zones.getZone ? zones.getZone(zid) : {};
      zoneSummaries[zid] = {
        name: zdata.name || zid,
        description: zdata.description || '',
        player_count: playerZones[zid] || 0,
        npc_count: 0
      };
    }

    var npcList = [];
    if (typeof NPCs !== 'undefined' && NPCs.getAllNPCs) {
      var allNpcs = NPCs.getAllNPCs();
      for (var n = 0; n < allNpcs.length; n++) {
        var npc = allNpcs[n];
        var nzone = (npc.position && npc.position.zone) || 'nexus';
        npcList.push({
          id: npc.id || '',
          name: npc.name || '',
          archetype: npc.archetype || '',
          zone: nzone
        });
        if (zoneSummaries[nzone]) {
          zoneSummaries[nzone].npc_count++;
        }
      }
    }

    var recentChat = [];
    var chatSlice = chat.slice(-20);
    for (var c = 0; c < chatSlice.length; c++) {
      var msg = chatSlice[c];
      recentChat.push({
        from: msg.from || '',
        type: msg.type || 'say',
        text: (msg.payload && msg.payload.text) || '',
        ts: msg.ts || ''
      });
    }

    var simulations = {};
    if (typeof SimCRM !== 'undefined' && SimCRM.getMetrics) {
      var crmState = typeof Main !== 'undefined' && Main.getSimCrmState ? Main.getSimCrmState() : null;
      if (crmState) {
        simulations.crm = SimCRM.getMetrics(crmState);
      }
    }

    return {
      v: 1,
      ts: new Date().toISOString(),
      world: {
        time: world.time || 0,
        dayPhase: world.dayPhase || 'day',
        weather: world.weather || 'clear',
        season: world.season || 'spring'
      },
      zones: zoneSummaries,
      players: playerEntries,
      npcs: npcList,
      recent_chat: recentChat,
      economy: {
        total_spark: sumValues(economy.balances || {}),
        active_listings: (economy.listings || []).length
      },
      simulations: simulations
    };
  }

  function publishStateSnapshot(gameState) {
    try {
      var snapshot = buildSnapshot(gameState);
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem('zion_api_state', JSON.stringify(snapshot));
        localStorage.setItem('zion_api_state_ts', snapshot.ts);
      }
    } catch (e) {
      console.warn('[ApiBridge] Failed to publish snapshot:', e.message);
    }
  }

  function pollInbox(gameState) {
    var url = API_BASE + '/contents/state/inbox';

    fetch(url, {
      headers: { 'Accept': 'application/vnd.github.v3+json' }
    })
    .then(function(response) {
      if (!response.ok) return [];
      return response.json();
    })
    .then(function(files) {
      if (!Array.isArray(files)) return;

      var messageFiles = files.filter(function(f) {
        return f.name.endsWith('.json') && f.type === 'file';
      });

      if (messageFiles.length === 0) return;

      console.log('[ApiBridge] Found %d inbox messages', messageFiles.length);

      messageFiles.forEach(function(f) {
        fetch(f.download_url)
          .then(function(r) { return r.json(); })
          .then(function(msg) {
            pendingMessages.push(msg);
          })
          .catch(function(e) {
            console.warn('[ApiBridge] Failed to fetch message %s: %s', f.name, e.message);
          });
      });
    })
    .catch(function(e) {
    });
  }

  function processPendingMessages(gameState) {
    var protocol = typeof Protocol !== 'undefined' ? Protocol : null;
    var state = typeof State !== 'undefined' ? State : null;

    if (!protocol || !state) return;

    while (pendingMessages.length > 0) {
      var msg = pendingMessages.shift();

      var result = protocol.validateMessage(msg);
      if (!result.valid) {
        console.warn('[ApiBridge] Invalid message from %s: %s', msg.from, result.errors.join(', '));
        continue;
      }

      try {
        var currentState = state.getLiveState();
        var newState = state.applyMessage(currentState, msg);
        state.setLiveState(newState);
        console.log('[ApiBridge] Applied %s from %s', msg.type, msg.from);

      } catch (e) {
        console.warn('[ApiBridge] Failed to apply message: %s', e.message);
      }
    }
  }

  function getLatestSnapshot() {
    if (typeof localStorage === 'undefined') return null;
    try {
      var raw = localStorage.getItem('zion_api_state');
      return raw ? JSON.parse(raw) : null;
    } catch (e) {
      return null;
    }
  }

  function sumValues(obj) {
    var total = 0;
    for (var k in obj) {
      if (obj.hasOwnProperty(k) && typeof obj[k] === 'number') {
        total += obj[k];
      }
    }
    return total;
  }

  exports.init = init;
  exports.update = update;
  exports.buildSnapshot = buildSnapshot;
  exports.publishStateSnapshot = publishStateSnapshot;
  exports.pollInbox = pollInbox;
  exports.getLatestSnapshot = getLatestSnapshot;

})(typeof module !== 'undefined' ? module.exports : (window.ApiBridge = {}));


// LAZY_LOAD_START: sim_crm
(function(exports) {
  'use strict';

  var DEFAULT_PIPELINE = [
    'prospecting', 'qualification', 'proposal',
    'negotiation', 'closed_won', 'closed_lost'
  ];

  var DEFAULT_STAGE_PROB = {
    'prospecting': 10, 'qualification': 25, 'proposal': 50,
    'negotiation': 75, 'closed_won': 100, 'closed_lost': 0
  };

  var DEFAULT_ACTIVITY_TYPES = ['call', 'email', 'meeting', 'task'];

  var DEFAULT_SCHEMA = {
    collections: {
      accounts:      { prefix: 'acc', fields: ['name','industry','revenue','owner','status','zone'] },
      contacts:      { prefix: 'con', fields: ['name','email','phone','role','accountId','owner'] },
      opportunities: { prefix: 'opp', fields: ['name','accountId','stage','value','probability','owner','expected_close'] }
    },
    activity_types: DEFAULT_ACTIVITY_TYPES.slice(),
    pipeline_stages: DEFAULT_PIPELINE.slice(),
    stage_probabilities: JSON.parse(JSON.stringify(DEFAULT_STAGE_PROB))
  };

  var idCounter = 0;

  function generateId(prefix) {
    idCounter++;
    return prefix + '_' + Date.now().toString(36) + '_' + idCounter;
  }

  function initState(snapshot) {
    if (snapshot && (snapshot.accounts || snapshot._schema)) {
      var maxNum = 0;
      var schema = snapshot._schema || DEFAULT_SCHEMA;
      var collNames = objectKeys(schema.collections || {});
      var scanKeys = collNames.concat(['accounts', 'contacts', 'opportunities']);
      for (var c = 0; c < scanKeys.length; c++) {
        var coll = snapshot[scanKeys[c]];
        if (coll && typeof coll === 'object' && !Array.isArray(coll)) {
          for (var k in coll) {
            if (coll.hasOwnProperty(k)) {
              var parts = k.split('_');
              var num = parseInt(parts[parts.length - 1], 10);
              if (!isNaN(num) && num > maxNum) { maxNum = num; }
            }
          }
        }
      }
      var activities = snapshot.activities || [];
      for (var a = 0; a < activities.length; a++) {
        if (activities[a].id) {
          var aParts = activities[a].id.split('_');
          var aNum = parseInt(aParts[aParts.length - 1], 10);
          if (!isNaN(aNum) && aNum > maxNum) { maxNum = aNum; }
        }
      }
      idCounter = maxNum;

      var loaded = JSON.parse(JSON.stringify(snapshot));
      if (!loaded._schema) {
        loaded._schema = JSON.parse(JSON.stringify(DEFAULT_SCHEMA));
      }
      if (!loaded._molt_log) { loaded._molt_log = []; }
      if (!loaded.pipeline_stages) {
        loaded.pipeline_stages = loaded._schema.pipeline_stages.slice();
      }
      return loaded;
    }
    return {
      _schema: JSON.parse(JSON.stringify(DEFAULT_SCHEMA)),
      _molt_log: [],
      accounts: {},
      contacts: {},
      opportunities: {},
      activities: [],
      pipeline_stages: DEFAULT_PIPELINE.slice()
    };
  }

  function molt(state, reason) {
    var s = clone(state);
    if (!s._molt_log) { s._molt_log = []; }
    s._molt_log.push({
      v: s._molt_log.length + 1,
      reason: reason,
      ts: new Date().toISOString()
    });
    return s;
  }

  function ensureCollection(state, collName, prefix) {
    if (state[collName] && typeof state[collName] === 'object' && !Array.isArray(state[collName])) {
      return state;
    }
    var s = molt(state, 'New collection: ' + collName);
    s[collName] = {};
    if (!s._schema.collections[collName]) {
      s._schema.collections[collName] = { prefix: prefix || collName.substring(0, 3), fields: [] };
    }
    return s;
  }

  function ensurePipelineStage(state, stageName) {
    var stages = state._schema.pipeline_stages;
    if (stages.indexOf(stageName) !== -1) { return state; }
    var s = molt(state, 'New pipeline stage: ' + stageName);
    var closedIdx = stages.indexOf('closed_won');
    if (closedIdx === -1) { closedIdx = stages.length; }
    s._schema.pipeline_stages.splice(closedIdx, 0, stageName);
    s.pipeline_stages = s._schema.pipeline_stages.slice();
    if (!s._schema.stage_probabilities[stageName]) {
      var pos = s._schema.pipeline_stages.indexOf(stageName);
      var total = s._schema.pipeline_stages.length;
      s._schema.stage_probabilities[stageName] = Math.round((pos / (total - 1)) * 100);
    }
    return s;
  }

  function ensureActivityType(state, typeName) {
    if (state._schema.activity_types.indexOf(typeName) !== -1) { return state; }
    var s = molt(state, 'New activity type: ' + typeName);
    s._schema.activity_types.push(typeName);
    return s;
  }

  function learnFields(state, collName, data) {
    var schema = state._schema;
    if (!schema.collections[collName]) { return state; }
    var known = schema.collections[collName].fields;
    var newFields = [];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id' && k !== 'owner' && known.indexOf(k) === -1) {
        newFields.push(k);
      }
    }
    if (newFields.length === 0) { return state; }
    var s = molt(state, 'New fields on ' + collName + ': ' + newFields.join(', '));
    for (var i = 0; i < newFields.length; i++) {
      s._schema.collections[collName].fields.push(newFields[i]);
    }
    return s;
  }

  function applyAction(state, msg) {
    var payload = msg.payload || msg;
    var action = payload.action;
    var data = payload.data || {};
    var from = msg.from || payload.from || 'system';
    var result;

    if (!state._schema) {
      state = initState(state);
    }

    switch (action) {
      case 'create_account':
        result = createAccount(state, mergeOwner(data, from));
        return result.state;

      case 'update_account':
        return updateAccount(state, data.id, data);

      case 'create_contact':
        result = createContact(state, mergeOwner(data, from));
        return result.state;

      case 'update_contact':
        return updateContact(state, data.id, data);

      case 'create_opportunity':
        result = createOpportunity(state, mergeOwner(data, from));
        return result.state;

      case 'update_stage':
        return updateStage(state, data.id, data.stage);

      case 'close_deal':
        return closeDeal(state, data.id, data.won, data);

      case 'log_activity':
        result = logActivity(state, mergeOwner(data, from));
        return result.state;

      case 'add_note':
        return addNote(state, data.entityType, data.entityId, data.text, from);

      default:
        return moltForAction(state, action, data, from);
    }
  }

  function moltForAction(state, action, data, from) {
    if (!action || typeof action !== 'string') { return state; }

    var parts = action.split('_');
    if (parts.length < 2) { return state; }

    var verb = parts[0];
    var entitySingular = parts.slice(1).join('_');
    var collName = entitySingular + 's';
    var prefix = entitySingular.substring(0, 3);

    if (verb === 'create') {
      var s = ensureCollection(state, collName, prefix);
      s = learnFields(s, collName, data);
      var s2 = clone(s);
      var id = generateId(prefix);
      var record = { id: id, owner: data.owner || from, createdAt: new Date().toISOString() };
      for (var k in data) {
        if (data.hasOwnProperty(k)) { record[k] = data[k]; }
      }
      if (!record.name) { record.name = 'Unnamed ' + entitySingular; }
      if (!record.notes) { record.notes = []; }
      s2[collName][id] = record;
      return s2;

    } else if (verb === 'update') {
      if (!state[collName] || !data.id || !state[collName][data.id]) { return state; }
      var su = clone(state);
      su = learnFields(su, collName, data);
      var target = su[collName][data.id];
      for (var uk in data) {
        if (data.hasOwnProperty(uk) && uk !== 'id') { target[uk] = data[uk]; }
      }
      target.updatedAt = new Date().toISOString();
      return su;

    } else if (verb === 'delete') {
      if (!state[collName] || !data.id || !state[collName][data.id]) { return state; }
      var sd = clone(state);
      delete sd[collName][data.id];
      return sd;

    } else if (verb === 'list') {
      return state;
    }

    return state;
  }

  function mergeOwner(data, from) {
    var out = {};
    for (var k in data) {
      if (data.hasOwnProperty(k)) { out[k] = data[k]; }
    }
    if (!out.owner) { out.owner = from; }
    return out;
  }

  function createAccount(state, data) {
    var s = learnFields(state, 'accounts', data);
    s = clone(s);
    var id = generateId('acc');
    var record = {
      id: id,
      name: data.name || 'Unnamed Account',
      industry: data.industry || 'general',
      revenue: data.revenue || 0,
      owner: data.owner || 'system',
      status: data.status || 'active',
      zone: data.zone || 'agora',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.accounts[id] = record;
    return { state: s, record: record };
  }

  function updateAccount(state, id, data) {
    if (!state.accounts[id]) { return state; }
    var s = learnFields(state, 'accounts', data);
    s = clone(s);
    var acct = s.accounts[id];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id') { acct[k] = data[k]; }
    }
    acct.updatedAt = new Date().toISOString();
    return s;
  }

  function createContact(state, data) {
    var s = learnFields(state, 'contacts', data);
    s = clone(s);
    var id = generateId('con');
    var record = {
      id: id,
      name: data.name || 'Unnamed Contact',
      email: data.email || '',
      phone: data.phone || '',
      role: data.role || '',
      accountId: data.accountId || '',
      owner: data.owner || 'system',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.contacts[id] = record;
    return { state: s, record: record };
  }

  function updateContact(state, id, data) {
    if (!state.contacts[id]) { return state; }
    var s = learnFields(state, 'contacts', data);
    s = clone(s);
    var con = s.contacts[id];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id') { con[k] = data[k]; }
    }
    con.updatedAt = new Date().toISOString();
    return s;
  }

  function createOpportunity(state, data) {
    var s = state;
    var stage = data.stage || 'prospecting';
    if (s._schema && s._schema.pipeline_stages.indexOf(stage) === -1) {
      s = ensurePipelineStage(s, stage);
    }
    s = learnFields(s, 'opportunities', data);
    s = clone(s);
    var id = generateId('opp');
    var probs = s._schema ? s._schema.stage_probabilities : DEFAULT_STAGE_PROB;
    var record = {
      id: id,
      name: data.name || 'Unnamed Opportunity',
      accountId: data.accountId || '',
      stage: stage,
      value: data.value || 0,
      probability: data.probability !== undefined ? data.probability : (probs[stage] || 0),
      owner: data.owner || 'system',
      expected_close: data.expected_close || '',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.opportunities[id] = record;
    return { state: s, record: record };
  }

  function updateStage(state, oppId, newStage) {
    if (!state.opportunities[oppId]) { return state; }
    var s = state;
    var stages = s._schema ? s._schema.pipeline_stages : DEFAULT_PIPELINE;
    if (stages.indexOf(newStage) === -1) {
      s = ensurePipelineStage(s, newStage);
      stages = s._schema.pipeline_stages;
    }
    s = clone(s);
    var opp = s.opportunities[oppId];
    if (opp.stage === 'closed_won' || opp.stage === 'closed_lost') { return state; }
    opp.stage = newStage;
    var probs = s._schema ? s._schema.stage_probabilities : DEFAULT_STAGE_PROB;
    opp.probability = probs[newStage] !== undefined ? probs[newStage] : opp.probability;
    opp.updatedAt = new Date().toISOString();
    return s;
  }

  function closeDeal(state, oppId, won, details) {
    if (!state.opportunities[oppId]) { return state; }
    var s = clone(state);
    var opp = s.opportunities[oppId];
    opp.stage = won ? 'closed_won' : 'closed_lost';
    opp.probability = won ? 100 : 0;
    if (details && details.value !== undefined) { opp.value = details.value; }
    if (details && details.reason) { opp.close_reason = details.reason; }
    opp.closedAt = new Date().toISOString();
    opp.updatedAt = opp.closedAt;
    return s;
  }

  function logActivity(state, data) {
    var s = state;
    var actType = data.type || 'task';
    if (s._schema && s._schema.activity_types.indexOf(actType) === -1) {
      s = ensureActivityType(s, actType);
    }
    s = clone(s);
    var id = generateId('act');
    var record = {
      id: id,
      type: actType,
      subject: data.subject || '',
      regarding: data.regarding || '',
      regardingType: data.regardingType || '',
      status: data.status || 'open',
      owner: data.owner || 'system',
      notes: data.notes || '',
      createdAt: new Date().toISOString()
    };
    s.activities.push(record);
    return { state: s, record: record };
  }

  function addNote(state, entityType, entityId, text, author) {
    var collName = entityType;
    if (!state[collName]) {
      collName = entityType + 's';
    }
    var singularMap = { account: 'accounts', contact: 'contacts', opportunity: 'opportunities' };
    if (singularMap[entityType]) { collName = singularMap[entityType]; }

    if (!state[collName] || !state[collName][entityId]) { return state; }
    var s = clone(state);
    var entity = s[collName][entityId];
    if (!entity.notes) { entity.notes = []; }
    entity.notes.push({
      text: text,
      author: author || 'system',
      ts: new Date().toISOString()
    });
    return s;
  }

  function query(state, entityType, filters) {
    var collName = entityType;
    var legacy = {
      account: 'accounts', accounts: 'accounts',
      contact: 'contacts', contacts: 'contacts',
      opportunity: 'opportunities', opportunities: 'opportunities',
      activity: 'activities', activities: 'activities'
    };
    if (legacy[entityType]) {
      collName = legacy[entityType];
    } else if (!state[collName] && state[collName + 's']) {
      collName = collName + 's';
    }

    var source = state[collName];
    if (!source) { return []; }
    var items;

    if (Array.isArray(source)) {
      items = source.slice();
    } else {
      items = [];
      for (var k in source) {
        if (source.hasOwnProperty(k)) {
          items.push(source[k]);
        }
      }
    }

    if (!filters) { return items; }

    return items.filter(function(item) {
      for (var key in filters) {
        if (filters.hasOwnProperty(key)) {
          if (item[key] !== filters[key]) { return false; }
        }
      }
      return true;
    });
  }

  function getMetrics(state) {
    var accounts = state.accounts || {};
    var opportunities = state.opportunities || {};
    var contacts = state.contacts || {};
    var activities = state.activities || [];
    var stages = (state._schema && state._schema.pipeline_stages) || DEFAULT_PIPELINE;

    var accountCount = 0;
    for (var a in accounts) { if (accounts.hasOwnProperty(a)) { accountCount++; } }

    var contactCount = 0;
    for (var c in contacts) { if (contacts.hasOwnProperty(c)) { contactCount++; } }

    var oppCount = 0;
    var pipelineValue = 0;
    var wonCount = 0;
    var lostCount = 0;
    var wonValue = 0;
    var closedCount = 0;
    var stageBreakdown = {};

    for (var i = 0; i < stages.length; i++) {
      stageBreakdown[stages[i]] = { count: 0, value: 0 };
    }

    for (var o in opportunities) {
      if (opportunities.hasOwnProperty(o)) {
        var opp = opportunities[o];
        oppCount++;
        var stage = opp.stage || 'prospecting';
        if (stageBreakdown[stage]) {
          stageBreakdown[stage].count++;
          stageBreakdown[stage].value += opp.value || 0;
        }
        if (stage === 'closed_won') {
          wonCount++;
          wonValue += opp.value || 0;
          closedCount++;
        } else if (stage === 'closed_lost') {
          lostCount++;
          closedCount++;
        } else {
          pipelineValue += opp.value || 0;
        }
      }
    }

    var conversionRate = closedCount > 0 ? Math.round((wonCount / closedCount) * 100) : 0;

    var extraCollections = [];
    if (state._schema && state._schema.collections) {
      var collKeys = objectKeys(state._schema.collections);
      for (var ci = 0; ci < collKeys.length; ci++) {
        if (['accounts', 'contacts', 'opportunities'].indexOf(collKeys[ci]) === -1) {
          extraCollections.push(collKeys[ci]);
        }
      }
    }

    return {
      accounts_count: accountCount,
      contacts_count: contactCount,
      opportunities_count: oppCount,
      pipeline_value: pipelineValue,
      won_count: wonCount,
      won_value: wonValue,
      lost_count: lostCount,
      conversion_rate: conversionRate,
      activity_count: activities.length,
      stage_breakdown: stageBreakdown,
      molt_count: (state._molt_log || []).length,
      extra_collections: extraCollections
    };
  }

  var OPEN_STAGES = ['prospecting', 'qualification', 'proposal', 'negotiation'];
  var STAGE_ADVANCE = {
    'prospecting': 'qualification',
    'qualification': 'proposal',
    'proposal': 'negotiation',
    'negotiation': 'closed_won'
  };

  var TICK_DEAL_NAMES = [
    'Enchanted Gem Lot', 'Potion Ingredient Bundle', 'Scroll Consignment',
    'Festival Supply Order', 'Armor Repair Contract', 'Seed Catalog Deal',
    'Map Commission', 'Instrument Materials', 'Forge Fuel Shipment',
    'Textile Dye Batch', 'Herb Subscription', 'Crystal Lens Order',
    'Waystone Part Supply', 'Lantern Oil Contract', 'Rune Ink Purchase'
  ];

  var TICK_ACTIVITY_SUBJECTS = [
    'Checked in on deal progress', 'Sent pricing update',
    'Met to discuss terms', 'Followed up after delivery',
    'Reviewed quarterly numbers', 'Negotiated bulk discount',
    'Introduced new product line', 'Resolved supply delay',
    'Scheduled next review', 'Collected feedback on service'
  ];

  var tickSeed = 1;
  var tickCount = 0;

  function tickRandom() {
    tickSeed = (tickSeed * 1664525 + 1013904223) & 0x7fffffff;
    return (tickSeed & 0xffff) / 0x10000;
  }

  function pickRandom(arr) {
    return arr[Math.floor(tickRandom() * arr.length)];
  }

  function objectKeys(obj) {
    var keys = [];
    for (var k in obj) { if (obj.hasOwnProperty(k)) { keys.push(k); } }
    return keys;
  }

  function simulateTick(state) {
    if (!state || !state.accounts) { return state; }

    tickCount++;
    tickSeed = ((Date.now() + tickCount * 7919) & 0x7fffffff) || 1;
    var s = state;
    var accIds = objectKeys(s.accounts);
    var oppIds = objectKeys(s.opportunities);
    if (accIds.length === 0) { return s; }

    var openOpps = [];
    for (var i = 0; i < oppIds.length; i++) {
      var opp = s.opportunities[oppIds[i]];
      if (opp && OPEN_STAGES.indexOf(opp.stage) !== -1) {
        openOpps.push(opp);
      }
    }

    if (openOpps.length > 0 && tickRandom() < 0.6) {
      var advOpp = pickRandom(openOpps);
      var nextStage = STAGE_ADVANCE[advOpp.stage];
      if (nextStage) {
        s = updateStage(s, advOpp.id, nextStage);
        if (nextStage === 'closed_won') {
          openOpps = openOpps.filter(function(o) { return o.id !== advOpp.id; });
        }
      }
    }

    if (tickRandom() < 0.7) {
      var actTypes = (s._schema && s._schema.activity_types) || DEFAULT_ACTIVITY_TYPES;
      var actOwner = s.accounts[pickRandom(accIds)].owner || 'system';
      var regarding = '';
      var regardingType = '';
      if (openOpps.length > 0 && tickRandom() > 0.3) {
        var refOpp = pickRandom(openOpps);
        regarding = refOpp.id;
        regardingType = 'opportunity';
      } else {
        regarding = pickRandom(accIds);
        regardingType = 'account';
      }
      var actResult = logActivity(s, {
        type: pickRandom(actTypes),
        subject: pickRandom(TICK_ACTIVITY_SUBJECTS),
        regarding: regarding,
        regardingType: regardingType,
        owner: actOwner,
        status: 'completed'
      });
      s = actResult.state;
    }

    if (tickRandom() < 0.15 && accIds.length > 0) {
      var accId = pickRandom(accIds);
      var acct = s.accounts[accId];
      var oppResult = createOpportunity(s, {
        name: pickRandom(TICK_DEAL_NAMES),
        accountId: accId,
        stage: pickRandom(['prospecting', 'prospecting', 'qualification']),
        value: Math.floor(tickRandom() * 4000) + 200,
        owner: acct.owner || 'system'
      });
      s = oppResult.state;
    }

    if (openOpps.length > 0 && tickRandom() < 0.1) {
      var closeOpp = pickRandom(openOpps);
      var won = tickRandom() < 0.65;
      s = closeDeal(s, closeOpp.id, won, {
        reason: won ? 'terms agreed' : 'budget constraints'
      });
    }

    return s;
  }

  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function getState() {
    return null;
  }

  exports.PIPELINE_STAGES = DEFAULT_PIPELINE;
  exports.ACTIVITY_TYPES = DEFAULT_ACTIVITY_TYPES;
  exports.initState = initState;
  exports.applyAction = applyAction;
  exports.createAccount = createAccount;
  exports.updateAccount = updateAccount;
  exports.createContact = createContact;
  exports.updateContact = updateContact;
  exports.createOpportunity = createOpportunity;
  exports.updateStage = updateStage;
  exports.closeDeal = closeDeal;
  exports.logActivity = logActivity;
  exports.addNote = addNote;
  exports.query = query;
  exports.getMetrics = getMetrics;
  exports.getState = getState;
  exports.simulateTick = simulateTick;
  exports.molt = molt;
  exports.ensureCollection = ensureCollection;
  exports.ensurePipelineStage = ensurePipelineStage;
  exports.ensureActivityType = ensureActivityType;

})(typeof module !== 'undefined' ? module.exports : (window.SimCRM = {}));

// LAZY_LOAD_END: sim_crm

// sim_forge_browser.js
(function(exports) {
  'use strict';

  function _jsStr(s) {
    return "'" + String(s).replace(/\\/g, '\\\\').replace(/'/g, "\\'") + "'";
  }

  function _collPrefix(collName) {
    return collName.slice(0, 3).toLowerCase();
  }

  function _pascal(s) {
    return s.split('_').map(function(part) {
      return part.charAt(0).toUpperCase() + part.slice(1);
    }).join('');
  }

  function _windowName(simName) {
    return 'Sim' + _pascal(simName);
  }

  function _moduleName(simName) {
    return 'sim_' + simName;
  }

  function _deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function _isPlainObject(v) {
    return v !== null && typeof v === 'object' && !Array.isArray(v);
  }

  function parseSpec(specInput) {
    var spec;
    if (typeof specInput === 'string') {
      try {
        spec = JSON.parse(specInput);
      } catch (e) {
        throw new Error('Invalid JSON in spec: ' + e.message);
      }
    } else if (_isPlainObject(specInput)) {
      spec = _deepClone(specInput);
    } else {
      throw new Error('spec_input must be an object or JSON string');
    }

    if (!spec.name) {
      throw new Error('Spec must have a non-empty "name" field');
    }
    var name = spec.name;
    if (typeof name !== 'string') {
      throw new Error('"name" must be a string');
    }
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
      throw new Error(
        '"name" must start with a letter or underscore and contain only ' +
        'alphanumeric characters and underscores, got: ' + JSON.stringify(name)
      );
    }

    if (!spec.collections) {
      throw new Error('Spec must have a "collections" field');
    }
    var collections = spec.collections;
    if (!_isPlainObject(collections)) {
      throw new Error('"collections" must be an object/dict');
    }
    var collKeys = Object.keys(collections);
    if (collKeys.length === 0) {
      throw new Error('"collections" must have at least one collection');
    }

    for (var i = 0; i < collKeys.length; i++) {
      var collName = collKeys[i];
      var collDef = collections[collName];
      if (!_isPlainObject(collDef)) {
        collections[collName] = { fields: [] };
        collDef = collections[collName];
      }
      if (!collDef.fields || collDef.fields === null) {
        collDef.fields = [];
      }
      if (!Array.isArray(collDef.fields)) {
        throw new Error('fields for collection "' + collName + '" must be a list');
      }
    }

    if (!spec.actions || spec.actions.length === 0) {
      spec.actions = ['create', 'update', 'delete'];
    }

    if (!spec.description) {
      spec.description = 'A ' + name.replace(/_/g, ' ') + ' simulation';
    }

    return spec;
  }

  function generateModule(spec) {
    var name = spec.name;
    var collections = spec.collections;
    var description = spec.description || '';
    var windowName = _windowName(name);
    var collNames = Object.keys(collections);

    var lines = [];
    function w(line) { lines.push(line); }

    w('// sim_' + name + '.js â€” ' + description);
    w('// Auto-generated by sim_forge.py â€” Article XI: Simulations');
    w('// initState(snapshot), applyAction(state, message), getState(), getSchema()');
    w('(function(exports) {');
    w("  'use strict';");
    w('');

    w('  // --- Schema ---');
    w('');
    w('  var _schema = {');
    w('    collections: {');
    for (var si = 0; si < collNames.length; si++) {
      var collName = collNames[si];
      var collDef = collections[collName];
      var fields = collDef.fields || [];
      var prefix = _collPrefix(collName);
      var fieldsJs = '[' + fields.map(_jsStr).join(', ') + ']';
      var comma = (si < collNames.length - 1) ? ',' : '';
      w('      ' + _jsStr(collName) + ': { prefix: ' + _jsStr(prefix) + ', fields: ' + fieldsJs + ' }' + comma);
    }
    w('    }');
    w('  };');
    w('');

    w('  var _state = null;');
    w('  var _idCounter = 0;');
    w('');

    w('  // --- Utilities ---');
    w('');
    w('  function clone(obj) {');
    w('    return JSON.parse(JSON.stringify(obj));');
    w('  }');
    w('');
    w('  function generateId(prefix) {');
    w('    _idCounter++;');
    w("    return prefix + '_' + Date.now().toString(36) + '_' + _idCounter;");
    w('  }');
    w('');
    w('  function objectKeys(obj) {');
    w('    var keys = [];');
    w('    for (var k in obj) {');
    w('      if (obj.hasOwnProperty(k)) { keys.push(k); }');
    w('    }');
    w('    return keys;');
    w('  }');
    w('');
    w('  function mergeOwner(data, from) {');
    w('    var out = {};');
    w('    for (var k in data) {');
    w('      if (data.hasOwnProperty(k)) { out[k] = data[k]; }');
    w('    }');
    w("    if (!out.owner) { out.owner = from || 'system'; }");
    w('    return out;');
    w('  }');
    w('');

    w('  // --- State Management ---');
    w('');
    w('  function initState(snapshot) {');
    w('    var freshSchema = JSON.parse(JSON.stringify(_schema));');
    w("    if (snapshot && typeof snapshot === 'object') {");
    w('      // Restore id counter from existing records');
    w('      var maxNum = 0;');
    w('      var collNames = objectKeys((snapshot._schema || {}).collections || {});');

    var extraColls = '[' + collNames.map(_jsStr).join(', ') + ']';
    w('      var specColls = ' + extraColls + ';');
    w('      for (var si = 0; si < specColls.length; si++) {');
    w('        if (collNames.indexOf(specColls[si]) === -1) { collNames.push(specColls[si]); }');
    w('      }');
    w('      for (var ci = 0; ci < collNames.length; ci++) {');
    w("        var coll = snapshot[collNames[ci]];");
    w("        if (coll && typeof coll === 'object' && !Array.isArray(coll)) {");
    w('          var ids = objectKeys(coll);');
    w('          for (var ii = 0; ii < ids.length; ii++) {');
    w("            var parts = ids[ii].split('_');");
    w('            var num = parseInt(parts[parts.length - 1], 10);');
    w('            if (!isNaN(num) && num > maxNum) { maxNum = num; }');
    w('          }');
    w('        }');
    w('      }');
    w('      _idCounter = maxNum;');
    w('      var loaded = clone(snapshot);');
    w('      if (!loaded._schema) { loaded._schema = freshSchema; }');
    w('      // Ensure all spec collections exist');
    w('      for (var sci = 0; sci < specColls.length; sci++) {');
    w('        if (!loaded[specColls[sci]]) { loaded[specColls[sci]] = {}; }');
    w('      }');
    w('      _state = loaded;');
    w('      return _state;');
    w('    }');
    w('    // Fresh state');
    w('    _idCounter = 0;');
    w('    _state = {');
    w('      _schema: freshSchema,');
    w('      _sim: ' + _jsStr(name) + ',');
    w('      _created_at: new Date().toISOString()');
    w('    };');
    for (var ci2 = 0; ci2 < collNames.length; ci2++) {
      w('    _state[' + _jsStr(collNames[ci2]) + '] = {};');
    }
    w('    return _state;');
    w('  }');
    w('');

    w('  // --- CRUD Helpers ---');
    w('');
    for (var cri = 0; cri < collNames.length; cri++) {
      var cName = collNames[cri];
      var cDef = collections[cName];
      var cFields = cDef.fields || [];
      var cPrefix = _collPrefix(cName);

      w('  function create_' + cName + '(state, data) {');
      w('    var s = clone(state);');
      w('    var id = generateId(' + _jsStr(cPrefix) + ');');
      w('    var record = {');
      w('      id: id,');
      w("      owner: data.owner || 'system',");
      w('      createdAt: new Date().toISOString()');
      w('    };');
      w('    for (var k in data) {');
      w('      if (data.hasOwnProperty(k)) { record[k] = data[k]; }');
      w('    }');
      w("    if (!record.name && !record.title) {");
      var singularName = cName.replace(/s$/, '');
      w("      record.name = 'Unnamed " + singularName + "';");
      w('    }');
      w('    s[' + _jsStr(cName) + '][id] = record;');
      w('    return { state: s, record: record };');
      w('  }');
      w('');

      w('  function update_' + cName + '(state, id, data) {');
      w('    if (!state[' + _jsStr(cName) + '] || !state[' + _jsStr(cName) + '][id]) { return state; }');
      w('    var s = clone(state);');
      w('    var target = s[' + _jsStr(cName) + '][id];');
      w('    for (var k in data) {');
      w("      if (data.hasOwnProperty(k) && k !== 'id') { target[k] = data[k]; }");
      w('    }');
      w('    target.updatedAt = new Date().toISOString();');
      w('    return s;');
      w('  }');
      w('');

      w('  function delete_' + cName + '(state, id) {');
      w('    if (!state[' + _jsStr(cName) + '] || !state[' + _jsStr(cName) + '][id]) { return state; }');
      w('    var s = clone(state);');
      w('    delete s[' + _jsStr(cName) + '][id];');
      w('    return s;');
      w('  }');
      w('');
    }

    w('  // --- Action Dispatch ---');
    w('');
    w('  function applyAction(state, msg) {');
    w("    var payload = (msg && msg.payload) ? msg.payload : (msg || {});");
    w("    var action = payload.action || '';");
    w('    var data = payload.data || {};');
    w("    var from = (msg && msg.from) || payload.from || 'system';");
    w('    var result;');
    w('');
    w('    if (!state || !state._schema) {');
    w('      state = initState(state);');
    w('    }');
    w('');
    w('    switch (action) {');

    for (var ai = 0; ai < collNames.length; ai++) {
      var aColl = collNames[ai];
      w('      case ' + _jsStr('create_' + aColl) + ':');
      w('        result = create_' + aColl + '(state, mergeOwner(data, from));');
      w('        return result.state;');
      w('');
      w('      case ' + _jsStr('update_' + aColl) + ':');
      w('        return update_' + aColl + '(state, data.id, data);');
      w('');
      w('      case ' + _jsStr('delete_' + aColl) + ':');
      w('        return delete_' + aColl + '(state, data.id);');
      w('');
    }

    var actions = spec.actions || [];
    var customActions = actions.filter(function(a) {
      return a !== 'create' && a !== 'update' && a !== 'delete';
    });

    for (var cai = 0; cai < customActions.length; cai++) {
      var action = customActions[cai];

      if (action === 'complete') {
        for (var ci3 = 0; ci3 < collNames.length; ci3++) {
          var ccName = collNames[ci3];
          var ccFields = collections[ccName].fields || [];
          var caseName = 'complete_' + ccName;
          w('      case ' + _jsStr(caseName) + ':');
          w('        var sc = clone(state);');
          w('        if (sc[' + _jsStr(ccName) + '] && sc[' + _jsStr(ccName) + '][data.id]) {');
          if (ccFields.indexOf('done') !== -1) {
            w('          sc[' + _jsStr(ccName) + '][data.id].done = true;');
          }
          if (ccFields.indexOf('status') !== -1) {
            w("          sc[" + _jsStr(ccName) + "][data.id].status = 'completed';");
          }
          w('          sc[' + _jsStr(ccName) + '][data.id].completedAt = new Date().toISOString();');
          w('        }');
          w('        return sc;');
          w('');
        }
      } else if (action === 'assign') {
        for (var ci4 = 0; ci4 < collNames.length; ci4++) {
          var acName = collNames[ci4];
          var acFields = collections[acName].fields || [];
          if (acFields.indexOf('assignee') !== -1) {
            var acaseName = 'assign_' + acName;
            w('      case ' + _jsStr(acaseName) + ':');
            w('        var sa = clone(state);');
            w('        if (sa[' + _jsStr(acName) + '] && sa[' + _jsStr(acName) + '][data.id]) {');
            w('          sa[' + _jsStr(acName) + '][data.id].assignee = data.assignee || from;');
            w('          sa[' + _jsStr(acName) + '][data.id].updatedAt = new Date().toISOString();');
            w('        }');
            w('        return sa;');
            w('');
          }
        }
      } else if (action === 'move') {
        for (var ci5 = 0; ci5 < collNames.length; ci5++) {
          var mcName = collNames[ci5];
          var mcFields = collections[mcName].fields || [];
          var hasBoard = mcFields.indexOf('board_id') !== -1;
          var hasParent = mcFields.indexOf('parent_id') !== -1;
          if (hasBoard || hasParent) {
            var targetField = hasBoard ? 'board_id' : 'parent_id';
            var mcaseName = 'move_' + mcName;
            w('      case ' + _jsStr(mcaseName) + ':');
            w('        var sm = clone(state);');
            w('        if (sm[' + _jsStr(mcName) + '] && sm[' + _jsStr(mcName) + '][data.id]) {');
            w('          sm[' + _jsStr(mcName) + '][data.id][' + _jsStr(targetField) + '] = data.' + targetField + ';');
            w('          sm[' + _jsStr(mcName) + '][data.id].updatedAt = new Date().toISOString();');
            w('        }');
            w('        return sm;');
            w('');
          }
        }
      }
    }

    w('      default:');
    w('        return state;');
    w('    }');
    w('  }');
    w('');

    w('  // --- Query ---');
    w('');
    w('  function query(state, collName, filter) {');
    w("    var coll = state[collName];");
    w("    if (!coll || typeof coll !== 'object' || Array.isArray(coll)) { return []; }");
    w('    var results = [];');
    w('    var ids = objectKeys(coll);');
    w('    for (var i = 0; i < ids.length; i++) {');
    w('      var item = coll[ids[i]];');
    w('      if (!filter || matchesFilter(item, filter)) {');
    w('        results.push(item);');
    w('      }');
    w('    }');
    w('    return results;');
    w('  }');
    w('');
    w('  function matchesFilter(item, filter) {');
    w('    for (var k in filter) {');
    w('      if (filter.hasOwnProperty(k)) {');
    w('        if (item[k] !== filter[k]) { return false; }');
    w('      }');
    w('    }');
    w('    return true;');
    w('  }');
    w('');

    w('  // --- Public API ---');
    w('');
    w('  exports.initState = function(snapshot) {');
    w('    return initState(snapshot);');
    w('  };');
    w('');
    w('  exports.applyAction = function(state, msg) {');
    w('    return applyAction(state, msg);');
    w('  };');
    w('');
    w('  exports.getState = function() {');
    w('    return JSON.parse(JSON.stringify(_state));');
    w('  };');
    w('');
    w('  exports.getSchema = function() {');
    w('    return JSON.parse(JSON.stringify(_schema));');
    w('  };');
    w('');
    w('  exports.query = function(state, collName, filter) {');
    w('    return query(state, collName, filter);');
    w('  };');
    w('');

    for (var ei = 0; ei < collNames.length; ei++) {
      var eName = collNames[ei];
      w('  exports.create_' + eName + ' = function(state, data) {');
      w('    return create_' + eName + '(state, data);');
      w('  };');
      w('  exports.update_' + eName + ' = function(state, id, data) {');
      w('    return update_' + eName + '(state, id, data);');
      w('  };');
      w('  exports.delete_' + eName + ' = function(state, id) {');
      w('    return delete_' + eName + '(state, id);');
      w('  };');
      w('');
    }

    w("})(typeof module !== 'undefined' ? module.exports : (window." + windowName + " = {}));");

    return lines.join('\n') + '\n';
  }

  function generateState(spec) {
    var name = spec.name;
    var collections = spec.collections;
    var collNames = Object.keys(collections);

    var schemaCollections = {};
    for (var i = 0; i < collNames.length; i++) {
      var collName = collNames[i];
      var collDef = collections[collName];
      var fields = collDef.fields || [];
      schemaCollections[collName] = {
        prefix: _collPrefix(collName),
        fields: fields.slice()
      };
    }

    var state = {
      _sim: name,
      _schema: {
        collections: schemaCollections
      },
      _created_at: new Date().toISOString()
    };

    for (var j = 0; j < collNames.length; j++) {
      state[collNames[j]] = {};
    }

    return state;
  }

  function generateTests(spec) {
    var name = spec.name;
    var collections = spec.collections;
    var collNames = Object.keys(collections);
    var moduleName = _moduleName(name);
    var moduleVar = 'Sim';

    var lines = [];
    function w(line) { lines.push(line); }

    w('#!/usr/bin/env node');
    w('// test_sim_' + name + '.js â€” Auto-generated tests for ' + moduleName);
    w('// Generated by sim_forge.py');
    w("'use strict';");
    w('');
    w('var ' + moduleVar + " = require('../src/js/" + moduleName + ".js');");
    w('');
    w('var passed = 0;');
    w('var failed = 0;');
    w('');
    w('function assert(condition, message) {');
    w('  if (condition) {');
    w('    passed++;');
    w('  } else {');
    w('    failed++;');
    w("    console.error('FAIL: ' + message);");
    w('  }');
    w('}');
    w('');
    w('function assertEqual(actual, expected, message) {');
    w('  if (actual === expected) {');
    w('    passed++;');
    w('  } else {');
    w('    failed++;');
    w("    console.error('FAIL: ' + message + ' â€” expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));");
    w('  }');
    w('}');
    w('');

    w('// --- initState ---');
    w('');
    w('(function testInitStateEmpty() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  assert(state && typeof state === 'object', 'initState returns object');");
    w("  assert(state._schema && state._schema.collections, 'initState returns state with schema');");
    for (var ici = 0; ici < collNames.length; ici++) {
      var icName = collNames[ici];
      w("  assert(state[" + _jsStr(icName) + "] && typeof state[" + _jsStr(icName) + "] === 'object', 'initState returns " + icName + " object');");
    }
    w('})();');
    w('');

    w('(function testInitStateFromSnapshot() {');
    var firstColl = collNames[0];
    var firstPrefix = _collPrefix(firstColl);
    var testId = firstPrefix + '_snap_1';
    w('  var snap = {');
    w('    _schema: { collections: {} },');
    for (var sni = 0; sni < collNames.length; sni++) {
      var snName = collNames[sni];
      var snComma = (sni < collNames.length - 1) ? ',' : '';
      if (sni === 0) {
        w('    ' + _jsStr(snName) + ': { ' + _jsStr(testId) + ': { id: ' + _jsStr(testId) + ", name: 'Test' } }" + snComma);
      } else {
        w('    ' + _jsStr(snName) + ': {}' + snComma);
      }
    }
    w('  };');
    w('  var state = ' + moduleVar + '.initState(snap);');
    w("  assert(state[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "] !== undefined, 'initState restores snapshot data');");
    w("  assertEqual(state[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "].name, 'Test', 'initState restores record name');");
    w('  // Deep clone check');
    w("  snap[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "].name = 'Modified';");
    w("  assertEqual(state[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "].name, 'Test', 'initState deep clones snapshot');");
    w('})();');
    w('');

    for (var tci = 0; tci < collNames.length; tci++) {
      var tcName = collNames[tci];
      var tcDef = collections[tcName];
      var tcFields = tcDef.fields || [];
      var tcPrefix = _collPrefix(tcName);

      w('// --- ' + tcName + ' CRUD ---');
      w('');

      w('(function testCreate_' + tcName + '() {');
      w('  var state = ' + moduleVar + '.initState();');
      var testDataParts = [];
      for (var fi = 0; fi < Math.min(tcFields.length, 3); fi++) {
        var f = tcFields[fi];
        if (f === 'done') {
          testDataParts.push(_jsStr(f) + ': false');
        } else if (f === 'status') {
          testDataParts.push(_jsStr(f) + ": 'active'");
        } else if (f === 'priority') {
          testDataParts.push(_jsStr(f) + ": 'high'");
        } else {
          testDataParts.push(_jsStr(f) + ': ' + _jsStr('test_' + f));
        }
      }
      var testData = testDataParts.length > 0
        ? '{ ' + testDataParts.join(', ') + ' }'
        : "{ name: 'Test Item' }";
      w('  var result = ' + moduleVar + '.create_' + tcName + '(state, ' + testData + ');');
      w('  var record = result.record;');
      w('  var newState = result.state;');
      w("  assert(record && record.id && record.id.indexOf(" + _jsStr(tcPrefix) + ") === 0, 'create_" + tcName + " id has " + tcPrefix + "_ prefix');");
      w("  assert(newState[" + _jsStr(tcName) + "][record.id] !== undefined, 'create_" + tcName + " stores record');");
      w("  assertEqual(Object.keys(state[" + _jsStr(tcName) + "]).length, 0, 'create_" + tcName + " does not mutate original state');");
      w('})();');
      w('');

      w('(function testUpdate_' + tcName + '() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var r = " + moduleVar + ".create_" + tcName + "(state, { name: 'Original' });");
      w('  state = r.state;');
      w('  var id = r.record.id;');
      w("  var updated = " + moduleVar + ".update_" + tcName + "(state, id, { name: 'Updated Name' });");
      w("  assertEqual(updated[" + _jsStr(tcName) + "][id].name, 'Updated Name', 'update_" + tcName + " changes name');");
      w("  assertEqual(state[" + _jsStr(tcName) + "][id].name, 'Original', 'update_" + tcName + " does not mutate original state');");
      w('})();');
      w('');

      w('(function testUpdate_' + tcName + '_missing() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var result = " + moduleVar + ".update_" + tcName + "(state, 'nonexistent_id', { name: 'X' });");
      w("  assert(result === state, 'update_" + tcName + " nonexistent id returns same state');");
      w('})();');
      w('');

      w('(function testDelete_' + tcName + '() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var r = " + moduleVar + ".create_" + tcName + "(state, { name: 'Delete me' });");
      w('  state = r.state;');
      w('  var id = r.record.id;');
      w('  var deleted = ' + moduleVar + '.delete_' + tcName + '(state, id);');
      w("  assert(deleted[" + _jsStr(tcName) + "][id] === undefined, 'delete_" + tcName + " removes record');");
      w("  assertEqual(Object.keys(state[" + _jsStr(tcName) + "]).length, 1, 'delete_" + tcName + " does not mutate original state');");
      w('})();');
      w('');

      w('(function testDelete_' + tcName + '_missing() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var result = " + moduleVar + ".delete_" + tcName + "(state, 'nonexistent_id');");
      w("  assert(result === state, 'delete_" + tcName + " nonexistent id returns same state');");
      w('})();');
      w('');
    }

    w('// --- Schema ---');
    w('');
    w('(function testGetSchema() {');
    w('  ' + moduleVar + '.initState();');
    w('  var schema = ' + moduleVar + '.getSchema();');
    w("  assert(schema && schema.collections, 'getSchema returns collections');");
    for (var sci = 0; sci < collNames.length; sci++) {
      var scName = collNames[sci];
      w("  assert(schema.collections[" + _jsStr(scName) + "], 'schema has " + scName + " collection');");
      var scFields = collections[scName].fields || [];
      for (var sfi = 0; sfi < Math.min(scFields.length, 2); sfi++) {
        w("  assert(schema.collections[" + _jsStr(scName) + "].fields.indexOf(" + _jsStr(scFields[sfi]) + ") !== -1, 'schema " + scName + " has " + scFields[sfi] + " field');");
      }
    }
    w('})();');
    w('');

    w('// --- applyAction ---');
    w('');
    w('(function testApplyAction_create() {');
    w('  var state = ' + moduleVar + '.initState();');
    w('  var msg = {');
    w("    from: 'user1',");
    w('    payload: {');
    w('      action: ' + _jsStr('create_' + firstColl) + ',');
    w("      data: { name: 'Action Created' }");
    w('    }');
    w('  };');
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w('  var items = ' + moduleVar + '.query(s2, ' + _jsStr(firstColl) + ', null);');
    w("  assertEqual(items.length, 1, 'applyAction create adds record');");
    w("  assertEqual(items[0].name, 'Action Created', 'applyAction create passes name');");
    w("  assertEqual(items[0].owner, 'user1', 'applyAction sets owner from msg.from');");
    w('})();');
    w('');

    w('(function testApplyAction_update() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var r = " + moduleVar + ".create_" + firstColl + "(state, { name: 'Before' });");
    w('  state = r.state;');
    w('  var id = r.record.id;');
    w('  var msg = {');
    w("    from: 'user1',");
    w('    payload: {');
    w('      action: ' + _jsStr('update_' + firstColl) + ',');
    w("      data: { id: id, name: 'After' }");
    w('    }');
    w('  };');
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w("  assertEqual(s2[" + _jsStr(firstColl) + "][id].name, 'After', 'applyAction update changes name');");
    w('})();');
    w('');

    w('(function testApplyAction_delete() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var r = " + moduleVar + ".create_" + firstColl + "(state, { name: 'Gone' });");
    w('  state = r.state;');
    w('  var id = r.record.id;');
    w('  var msg = {');
    w("    from: 'user1',");
    w('    payload: {');
    w('      action: ' + _jsStr('delete_' + firstColl) + ',');
    w('      data: { id: id }');
    w('    }');
    w('  };');
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w("  assert(s2[" + _jsStr(firstColl) + "][id] === undefined, 'applyAction delete removes record');");
    w('})();');
    w('');

    w('(function testApplyAction_unknown() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var msg = { from: 'x', payload: { action: 'nonexistent_action_xyz', data: {} } };");
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w("  assert(s2 === state, 'applyAction unknown action returns same state');");
    w('})();');
    w('');

    w('// --- Edge cases ---');
    w('');

    w('(function testCreate_missing_fields() {');
    w('  // Create with no data â€” should not throw, uses defaults');
    w('  var state = ' + moduleVar + '.initState();');
    w('  var result = ' + moduleVar + '.create_' + firstColl + '(state, {});');
    w("  assert(result && result.record && result.record.id, 'create with empty data sets an id');");
    w('})();');
    w('');

    w('(function testUpdate_nonexistent_id() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var result = " + moduleVar + ".update_" + firstColl + "(state, 'nonexistent', { name: 'X' });");
    w("  assert(result === state, 'update nonexistent id returns same state unchanged');");
    w('})();');
    w('');

    w('(function testDelete_nonexistent_id() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var result = " + moduleVar + ".delete_" + firstColl + "(state, 'nonexistent');");
    w("  assert(result === state, 'delete nonexistent id returns same state');");
    w('})();');
    w('');

    w('// --- Snapshot roundtrip ---');
    w('');
    w('(function testSnapshotRoundtrip() {');
    w('  var state = ' + moduleVar + '.initState();');
    for (var sri = 0; sri < collNames.length; sri++) {
      var srName = collNames[sri];
      var srVar = 'r_' + srName;
      w("  var " + srVar + " = " + moduleVar + ".create_" + srName + "(state, { name: 'Persist " + srName + "' });");
      w('  state = ' + srVar + '.state;');
    }
    w('  var json = JSON.stringify(state);');
    w('  var restored = ' + moduleVar + '.initState(JSON.parse(json));');
    for (var srrI = 0; srrI < collNames.length; srrI++) {
      var srrName = collNames[srrI];
      w("  assertEqual(Object.keys(restored[" + _jsStr(srrName) + "]).length, 1, 'snapshot restores " + srrName + "');");
    }
    w('})();');
    w('');

    w('(function testGetState() {');
    w('  var state = ' + moduleVar + '.initState();');
    w('  var got = ' + moduleVar + '.getState();');
    w("  assert(got && typeof got === 'object', 'getState returns object');");
    w("  assert(got._schema !== undefined, 'getState includes schema');");
    w('})();');
    w('');

    w('(function testQuery() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var r1 = " + moduleVar + ".create_" + firstColl + "(state, { name: 'A', status: 'active' });");
    w('  state = r1.state;');
    w("  var r2 = " + moduleVar + ".create_" + firstColl + "(state, { name: 'B', status: 'done' });");
    w('  state = r2.state;');
    w('  var all = ' + moduleVar + '.query(state, ' + _jsStr(firstColl) + ', null);');
    w("  assertEqual(all.length, 2, 'query all returns 2');");
    w("  var active = " + moduleVar + ".query(state, " + _jsStr(firstColl) + ", { status: 'active' });");
    w("  assertEqual(active.length, 1, 'query filtered returns 1');");
    w("  var none = " + moduleVar + ".query(state, 'nonexistent_collection', {});");
    w("  assertEqual(none.length, 0, 'query nonexistent collection returns empty');");
    w('})();');
    w('');

    w('// --- Results ---');
    w('');
    w("console.log('\\n" + moduleName + " Tests: ' + passed + ' passed, ' + failed + ' failed');");
    w('if (failed > 0) {');
    w('  process.exit(1);');
    w('} else {');
    w("  console.log('All " + name + " simulation tests passed!');");
    w('}');

    return lines.join('\n') + '\n';
  }

  function forge(specInput) {
    var spec = parseSpec(specInput);
    var moduleSource = generateModule(spec);
    var initialState = generateState(spec);
    var testSource = generateTests(spec);
    return {
      name: spec.name,
      moduleSource: moduleSource,
      initialState: initialState,
      testSource: testSource
    };
  }

  function loadAndRun(specInput) {
    var spec = parseSpec(specInput);
    var moduleSource = generateModule(spec);

    var simModule;
    try {
      var mockModule = { exports: {} };
      var mockWindow = {};
      var factory = new Function('module', 'exports', 'window', moduleSource);
      factory(mockModule, mockModule.exports, mockWindow);
      simModule = mockModule.exports;
    } catch (e) {
      throw new Error('loadAndRun: failed to eval generated module for "' + spec.name + '": ' + e.message);
    }

    simModule.initState();

    return simModule;
  }

  function getExampleSpecs() {
    return [
      {
        name: 'todo',
        description: 'A simple todo list simulation',
        collections: {
          tasks: {
            fields: ['title', 'done', 'priority', 'due_date', 'notes']
          }
        },
        actions: ['create', 'update', 'delete', 'complete']
      },
      {
        name: 'project_manager',
        description: 'A project management simulation',
        collections: {
          projects: {
            fields: ['title', 'status', 'owner', 'deadline', 'budget']
          },
          tasks: {
            fields: ['title', 'status', 'assignee', 'board_id', 'priority', 'done']
          },
          milestones: {
            fields: ['title', 'due_date', 'status']
          }
        },
        actions: ['create', 'update', 'delete', 'complete', 'assign', 'move']
      },
      {
        name: 'inventory',
        description: 'An inventory management simulation',
        collections: {
          items: {
            fields: ['name', 'quantity', 'category', 'unit_price', 'location', 'notes']
          },
          categories: {
            fields: ['name', 'description']
          },
          transactions: {
            fields: ['item_id', 'quantity', 'type', 'timestamp', 'notes']
          }
        },
        actions: ['create', 'update', 'delete']
      },
      {
        name: 'recipe_book',
        description: 'A recipe collection simulation',
        collections: {
          recipes: {
            fields: ['title', 'cuisine', 'prep_time', 'servings', 'difficulty', 'notes']
          },
          ingredients: {
            fields: ['name', 'quantity', 'unit', 'recipe_id']
          },
          tags: {
            fields: ['name', 'color']
          }
        },
        actions: ['create', 'update', 'delete']
      }
    ];
  }

  exports.parseSpec = parseSpec;
  exports.generateModule = generateModule;
  exports.generateState = generateState;
  exports.generateTests = generateTests;
  exports.forge = forge;
  exports.loadAndRun = loadAndRun;
  exports.getExampleSpecs = getExampleSpecs;

})(typeof module !== 'undefined' ? module.exports : (window.SimForge = {}));


// world.js
(function(exports) {

  var Seasons = (typeof window !== 'undefined' && window.Seasons) ? window.Seasons : null;

  var playerMeshes = new Map();
  var skyDome = null, sunMesh = null, moonMesh = null, stars = null;
  var clouds = [];
  var animatedObjects = [];
  var loadedChunks = new Map(); // "cx_cz" -> { group, objects[] }
  var activeZone = 'nexus';
  var zoneLights = []; // Night-time point lights at zone landmarks

  var textureLoader = null;
  var textureCache = {};
  var ASSET_BASE = '';

  function getTexture(name) {
    if (!textureLoader) {
      if (typeof THREE === 'undefined') return null;
      textureLoader = new THREE.TextureLoader();
      if (typeof window !== 'undefined') {
        var path = window.location.pathname;
        ASSET_BASE = path.substring(0, path.lastIndexOf('/') + 1);
      }
    }
    if (textureCache[name]) return textureCache[name];
    var tex = textureLoader.load(ASSET_BASE + 'assets/textures/' + name);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    textureCache[name] = tex;
    return tex;
  }

  var CHUNK_SIZE = 64;
  var LOAD_RADIUS = 3; // chunks in each direction
  var WORLD_HALF = 600; // -600 to +600

  var ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, baseHeight: 2,   color: 0x8888cc, groundColor: 0xb0b0d0, texName: 'stone.png', name: 'The Nexus' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, baseHeight: 0,   color: 0x4caf50, groundColor: 0x3a8f3a, texName: 'grass.png', name: 'The Gardens' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, baseHeight: 4,   color: 0x795548, groundColor: 0x9e9e9e, texName: 'marble.png', name: 'The Athenaeum' },
    studio:     { cx: -200, cz: -100, radius: 60, baseHeight: 1,   color: 0xff9800, groundColor: 0xd4a76a, texName: 'wood.png', name: 'The Studio' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, baseHeight: -1,  color: 0x2e7d32, groundColor: 0x1b5e20, texName: 'grass_dark.png', name: 'The Wilds' },
    agora:      { cx: -190, cz: 120,  radius: 55, baseHeight: 1.5, color: 0xffd700, groundColor: 0xc8a45a, texName: 'cobblestone.png', name: 'The Agora' },
    commons:    { cx: 170,  cz: 190,  radius: 55, baseHeight: 0.5, color: 0xfaf0e6, groundColor: 0xd2b48c, texName: 'dirt_path.png', name: 'The Commons' },
    arena:      { cx: 0,    cz: -240, radius: 55, baseHeight: 3,   color: 0xd2691e, groundColor: 0xe0c097, texName: 'sand.png', name: 'The Arena' }
  };

  function hash2D(x, y) {
    var n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    return ((n ^ (n >> 16)) & 0x7fffffff) / 0x7fffffff;
  }

  function smoothstep(t) { return t * t * (3 - 2 * t); }

  function noise2D(x, y) {
    var ix = Math.floor(x), iy = Math.floor(y);
    var fx = x - ix, fy = y - iy;
    fx = smoothstep(fx);
    fy = smoothstep(fy);
    var a = hash2D(ix, iy);
    var b = hash2D(ix + 1, iy);
    var c = hash2D(ix, iy + 1);
    var d = hash2D(ix + 1, iy + 1);
    return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
  }

  function seededRandom(a, b, c) {
    var n = a * 12345 + b * 67890 + (c || 0) * 11111;
    return hash2D(n, n * 7);
  }

  function rawTerrainHeight(wx, wz) {
    var h = 0;
    h += noise2D(wx * 0.008, wz * 0.008) * 20;    // broad hills
    h += noise2D(wx * 0.02, wz * 0.02) * 8;        // medium detail
    h += noise2D(wx * 0.06, wz * 0.06) * 3;        // fine detail
    h += noise2D(wx * 0.15, wz * 0.15) * 1;        // micro detail
    return h - 10; // shift baseline down
  }

  function terrainHeight(wx, wz) {
    var raw = rawTerrainHeight(wx, wz);

    for (var zoneId in ZONES) {
      var z = ZONES[zoneId];
      var dx = wx - z.cx, dz = wz - z.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var flatRadius = z.radius * 0.5;
      var blendRadius = z.radius * 0.9;

      if (dist < blendRadius) {
        var t;
        if (dist < flatRadius) {
          t = 1.0;
        } else {
          t = 1.0 - (dist - flatRadius) / (blendRadius - flatRadius);
          t = smoothstep(t);
        }
        raw = raw * (1 - t) + z.baseHeight * t;
      }
    }

    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var nx = ZONES.nexus.cx, nz = ZONES.nexus.cz;
      var pathDist = pointToSegDist(wx, wz, nx, nz, zone.cx, zone.cz);
      if (pathDist < 8) {
        var pathBlend = smoothstep(1.0 - pathDist / 8);
        var segT = projectOnSeg(wx, wz, nx, nz, zone.cx, zone.cz);
        var pathH = ZONES.nexus.baseHeight * (1 - segT) + zone.baseHeight * segT;
        raw = raw * (1 - pathBlend * 0.8) + pathH * pathBlend * 0.8;
      }
    }

    return raw;
  }

  function pointToSegDist(px, pz, ax, az, bx, bz) {
    var abx = bx - ax, abz = bz - az;
    var apx = px - ax, apz = pz - az;
    var t = (apx * abx + apz * abz) / (abx * abx + abz * abz + 0.001);
    t = Math.max(0, Math.min(1, t));
    var cx = ax + t * abx - px, cz = az + t * abz - pz;
    return Math.sqrt(cx * cx + cz * cz);
  }

  function projectOnSeg(px, pz, ax, az, bx, bz) {
    var abx = bx - ax, abz = bz - az;
    var apx = px - ax, apz = pz - az;
    return Math.max(0, Math.min(1, (apx * abx + apz * abz) / (abx * abx + abz * abz + 0.001)));
  }

  function getZoneAtPosition(wx, wz) {
    var closest = 'nexus', closestDist = Infinity;
    for (var zoneId in ZONES) {
      var z = ZONES[zoneId];
      var dx = wx - z.cx, dz = wz - z.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var weighted = dist / z.radius;
      if (weighted < closestDist) {
        closestDist = weighted;
        closest = zoneId;
      }
    }
    return closest;
  }

  function getZoneCenter(zoneId) {
    var z = ZONES[zoneId];
    return z ? { x: z.cx, z: z.cz } : { x: 0, z: 0 };
  }

  function getTerrainHeight(wx, wz) {
    return terrainHeight(wx, wz);
  }

  function chunkKey(cx, cz) { return cx + '_' + cz; }

  function updateChunks(sceneCtx, playerX, playerZ) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var pcx = Math.floor(playerX / CHUNK_SIZE);
    var pcz = Math.floor(playerZ / CHUNK_SIZE);

    var needed = new Set();
    for (var dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
      for (var dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
        needed.add(chunkKey(pcx + dx, pcz + dz));
      }
    }

    var toRemove = [];
    loadedChunks.forEach(function(chunkData, key) {
      if (!needed.has(key)) {
        sceneCtx.scene.remove(chunkData.group);
        chunkData.group.traverse(function(obj) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(function(m) { m.dispose(); });
            else obj.material.dispose();
          }
        });
        toRemove.push(key);
      }
    });
    toRemove.forEach(function(key) { loadedChunks.delete(key); });

    needed.forEach(function(key) {
      if (!loadedChunks.has(key)) {
        var parts = key.split('_');
        var cx = parseInt(parts[0]), cz = parseInt(parts[1]);
        generateChunk(sceneCtx.scene, cx, cz);
      }
    });
  }

  function generateChunk(scene, cx, cz) {
    var group = new THREE.Group();
    var wx = cx * CHUNK_SIZE, wz = cz * CHUNK_SIZE;

    var centerX = wx + CHUNK_SIZE / 2, centerZ = wz + CHUNK_SIZE / 2;
    var zone = getZoneAtPosition(centerX, centerZ);
    var zoneData = ZONES[zone];

    var res = 16; // vertices per side
    var step = CHUNK_SIZE / res;
    var geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, res, res);
    var positions = geo.attributes.position.array;
    var colors = new Float32Array(positions.length);

    for (var i = 0; i <= res; i++) {
      for (var j = 0; j <= res; j++) {
        var idx = (i * (res + 1) + j);
        var px = wx + j * step;
        var pz = wz + i * step;
        var h = terrainHeight(px, pz);

        positions[idx * 3] = j * step;     // local x
        positions[idx * 3 + 1] = h;        // height (y-up)
        positions[idx * 3 + 2] = i * step; // local z

        var localZone = getZoneAtPosition(px, pz);
        var lz = ZONES[localZone];
        var r = ((lz.groundColor >> 16) & 0xff) / 255;
        var g = ((lz.groundColor >> 8) & 0xff) / 255;
        var b = (lz.groundColor & 0xff) / 255;

        var hFactor = Math.max(0, Math.min(1, (h + 5) / 30));
        r = r * (0.8 + hFactor * 0.4);
        g = g * (0.8 + hFactor * 0.2);
        b = b * (0.7 + hFactor * 0.3);

        for (var zId in ZONES) {
          if (zId === 'nexus') continue;
          var pDist = pointToSegDist(px, pz, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[zId].cx, ZONES[zId].cz);
          if (pDist < 6) {
            var pathFade = 1 - pDist / 6;
            r = r * (1 - pathFade * 0.3) + 0.55 * pathFade * 0.3;
            g = g * (1 - pathFade * 0.3) + 0.45 * pathFade * 0.3;
            b = b * (1 - pathFade * 0.3) + 0.35 * pathFade * 0.3;
          }
        }

        var memCell = getMemoryAtPosition(px, pz);
        if (memCell && memCell.steps > 5) {
          var pathStr = Math.min(1, (memCell.steps - 5) / 45);
          r = r * (1 - pathStr * 0.4) + 0.45 * pathStr * 0.4;
          g = g * (1 - pathStr * 0.4) + 0.35 * pathStr * 0.4;
          b = b * (1 - pathStr * 0.4) + 0.25 * pathStr * 0.4;
        }

        colors[idx * 3] = Math.min(1, r);
        colors[idx * 3 + 1] = Math.min(1, g);
        colors[idx * 3 + 2] = Math.min(1, b);
      }
    }

    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geo.computeVertexNormals();

    var mat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      roughness: 0.9,
      metalness: 0.0,
      flatShading: false
    });

    var tex = getTexture(zoneData.texName);
    if (tex) {
      tex.repeat.set(4, 4);
      mat.map = tex;
    }

    var mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(wx, 0, wz);
    mesh.receiveShadow = false;
    group.add(mesh);

    generateMemoryObjects(group, cx, cz, wx, wz);

    generateChunkDetails(group, cx, cz, zone, wx, wz);

    scene.add(group);
    loadedChunks.set(chunkKey(cx, cz), { group: group });
  }

  function generateMemoryObjects(group, cx, cz, wx, wz) {
    for (var gx = Math.floor(wx / MEMORY_GRID_SIZE); gx <= Math.floor((wx + CHUNK_SIZE) / MEMORY_GRID_SIZE); gx++) {
      for (var gz = Math.floor(wz / MEMORY_GRID_SIZE); gz <= Math.floor((wz + CHUNK_SIZE) / MEMORY_GRID_SIZE); gz++) {
        var key = gx + '_' + gz;
        var cell = worldMemory[key];
        if (!cell) continue;

        var cellX = gx * MEMORY_GRID_SIZE + MEMORY_GRID_SIZE / 2;
        var cellZ = gz * MEMORY_GRID_SIZE + MEMORY_GRID_SIZE / 2;
        var cellY = terrainHeight(cellX, cellZ);

        if (cell.flowers) {
          for (var f = 0; f < 3; f++) {
            var fx = cellX + (f - 1) * 0.5;
            var fz = cellZ + (f * 0.7 - 0.7);
            var fy = terrainHeight(fx, fz);

            var stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 4);
            var stemMat = new THREE.MeshLambertMaterial({ color: 0x228822 });
            var stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.set(fx - wx, fy + 0.15, fz - wz);
            group.add(stem);

            var petalColors = [0xff6699, 0xffcc33, 0xff3366, 0x9966ff, 0xff9933];
            var petalGeo = new THREE.SphereGeometry(0.12, 6, 4);
            var petalMat = new THREE.MeshLambertMaterial({ color: petalColors[f % petalColors.length] });
            var petal = new THREE.Mesh(petalGeo, petalMat);
            petal.position.set(fx - wx, fy + 0.32, fz - wz);
            group.add(petal);
          }
        }

        if (cell.gathering > 3) {
          for (var ri = 0; ri < 3; ri++) {
            var rockAngle = (ri / 3) * Math.PI * 2;
            var rockX = cellX + Math.cos(rockAngle) * 0.8;
            var rockZ = cellZ + Math.sin(rockAngle) * 0.8;
            var rockY = terrainHeight(rockX, rockZ);

            var rockGeo = new THREE.SphereGeometry(0.2, 4, 3);
            var rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            var rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(rockX - wx, rockY + 0.1, rockZ - wz);
            rock.scale.y = 0.5;
            group.add(rock);
          }

          var glowLight = new THREE.PointLight(0xff6622, 0.5, 5);
          glowLight.position.set(cellX - wx, cellY + 0.3, cellZ - wz);
          group.add(glowLight);
        }
      }
    }
  }

  function generateChunkDetails(group, cx, cz, zone, wx, wz) {
    var seed = cx * 7919 + cz * 6271;

    var nearZone = false;
    for (var zId in ZONES) {
      var z = ZONES[zId];
      var dx = (wx + CHUNK_SIZE / 2) - z.cx;
      var dz = (wz + CHUNK_SIZE / 2) - z.cz;
      if (Math.sqrt(dx * dx + dz * dz) < z.radius + CHUNK_SIZE) {
        nearZone = true;
        break;
      }
    }

    var treeDensity = 0;
    if (zone === 'gardens') treeDensity = 12;
    else if (zone === 'wilds') treeDensity = 18;
    else if (zone === 'commons') treeDensity = 4;
    else if (zone === 'studio') treeDensity = 3;
    else if (zone === 'agora') treeDensity = 2;
    else treeDensity = nearZone ? 5 : 8; // wilderness between zones

    for (var t = 0; t < treeDensity; t++) {
      var tx = wx + seededRandom(seed, t, 1) * CHUNK_SIZE;
      var tz = wz + seededRandom(seed, t, 2) * CHUNK_SIZE;

      var onPath = false;
      for (var pz in ZONES) {
        if (pz === 'nexus') continue;
        if (pointToSegDist(tx, tz, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[pz].cx, ZONES[pz].cz) < 5) {
          onPath = true;
          break;
        }
      }
      if (onPath) continue;

      var inCenter = false;
      for (var zId2 in ZONES) {
        var zd = ZONES[zId2];
        var ddx = tx - zd.cx, ddz = tz - zd.cz;
        if (Math.sqrt(ddx * ddx + ddz * ddz) < zd.radius * 0.35) {
          inCenter = true;
          break;
        }
      }
      if (inCenter) continue;

      var th = terrainHeight(tx, tz);
      createTree(group, tx, th, tz, seed + t, zone);
    }

    var rockDensity = (zone === 'wilds' || zone === 'arena') ? 8 : (zone === 'nexus' || zone === 'athenaeum') ? 4 : 3;
    for (var r = 0; r < rockDensity; r++) {
      var rx = wx + seededRandom(seed + 100, r, 1) * CHUNK_SIZE;
      var rz = wz + seededRandom(seed + 100, r, 2) * CHUNK_SIZE;
      var rh = terrainHeight(rx, rz);
      createRock(group, rx, rh, rz, seed + 100 + r);
    }

    if (zone === 'gardens' || zone === 'commons' || zone === 'wilds') {
      var flowerDensity = zone === 'gardens' ? 20 : 8;
      for (var f = 0; f < flowerDensity; f++) {
        var fx = wx + seededRandom(seed + 200, f, 1) * CHUNK_SIZE;
        var fz = wz + seededRandom(seed + 200, f, 2) * CHUNK_SIZE;
        var fh = terrainHeight(fx, fz);
        createFlower(group, fx, fh, fz, seed + 200 + f);
      }
    }

    var grassDensity = (zone === 'gardens' || zone === 'wilds') ? 15 : (zone === 'arena' || zone === 'nexus') ? 3 : 8;
    for (var g = 0; g < grassDensity; g++) {
      var gx = wx + seededRandom(seed + 300, g, 1) * CHUNK_SIZE;
      var gz = wz + seededRandom(seed + 300, g, 2) * CHUNK_SIZE;
      var gh = terrainHeight(gx, gz);
      createGrassClump(group, gx, gh, gz, seed + 300 + g);
    }
  }

  function createTree(parent, x, y, z, seed, zone) {
    var treeGroup = new THREE.Group();
    var scale = 0.5 + seededRandom(seed, 0, 5) * 0.5;
    var treeType = seededRandom(seed, 0, 6);

    var trunkH = 2.5 * scale + seededRandom(seed, 0, 7) * 1.5 * scale;
    var trunkR = 0.15 * scale + seededRandom(seed, 0, 8) * 0.1 * scale;
    var trunkGeo = new THREE.CylinderGeometry(trunkR * 0.7, trunkR, trunkH, 6);
    var trunkColor = zone === 'wilds' ? 0x4a3728 : 0x8B4513;
    var trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.95 });
    var trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = trunkH / 2;
    trunk.castShadow = false;
    treeGroup.add(trunk);

    if (treeType < 0.4) {
      var canopyR = 1.2 * scale + seededRandom(seed, 0, 9) * 0.8 * scale;
      var canopyGeo = new THREE.SphereGeometry(canopyR, 8, 8);
      var canopyColor = zone === 'wilds' ? 0x1a5e1a : (zone === 'gardens' ? 0x4CAF50 : 0x2d8a2d);
      var canopyMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.85 });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.y = trunkH + canopyR * 0.6;
      canopy.castShadow = false;
      treeGroup.add(canopy);
    } else if (treeType < 0.7) {
      var pineH = 3 * scale;
      var pineR = 1.2 * scale;
      var pineGeo = new THREE.ConeGeometry(pineR, pineH, 8);
      var pineColor = zone === 'wilds' ? 0x0d4d0d : 0x1b7a1b;
      var pineMat = new THREE.MeshStandardMaterial({ color: pineColor, roughness: 0.85 });
      var pine = new THREE.Mesh(pineGeo, pineMat);
      pine.position.y = trunkH + pineH / 2 - 0.5;
      pine.castShadow = false;
      treeGroup.add(pine);
    } else {
      for (var cs = 0; cs < 3; cs++) {
        var msr = 0.8 * scale + seededRandom(seed + cs, 0, 10) * 0.5 * scale;
        var msGeo = new THREE.SphereGeometry(msr, 6, 6);
        var msColor = 0x2d8a2d + Math.floor(seededRandom(seed + cs, 0, 11) * 0x202020);
        var msMat = new THREE.MeshStandardMaterial({ color: msColor, roughness: 0.85 });
        var msMesh = new THREE.Mesh(msGeo, msMat);
        var angle = cs * Math.PI * 2 / 3;
        msMesh.position.set(
          Math.cos(angle) * 0.8 * scale,
          trunkH + msr * 0.4 + cs * 0.5 * scale,
          Math.sin(angle) * 0.8 * scale
        );
        msMesh.castShadow = false;
        treeGroup.add(msMesh);
      }
    }

    treeGroup.position.set(x, y, z);
    treeGroup.rotation.y = seededRandom(seed, 0, 12) * Math.PI * 2;
    parent.add(treeGroup);

    animatedObjects.push({
      mesh: treeGroup,
      type: 'tree',
      params: { speed: 0.3 + seededRandom(seed, 0, 13) * 0.4, seed: seed * 0.01 }
    });
  }

  function createRock(parent, x, y, z, seed) {
    var scale = 0.3 + seededRandom(seed, 1, 1) * 1.2;
    var geo = new THREE.DodecahedronGeometry(scale, 0);
    var grey = 0.4 + seededRandom(seed, 1, 2) * 0.3;
    var col = new THREE.Color(grey, grey, grey * 0.95);
    var mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.95, flatShading: true });
    var rock = new THREE.Mesh(geo, mat);
    rock.position.set(x, y + scale * 0.3, z);
    rock.rotation.set(
      seededRandom(seed, 1, 3) * Math.PI,
      seededRandom(seed, 1, 4) * Math.PI,
      seededRandom(seed, 1, 5) * Math.PI
    );
    rock.scale.set(
      0.7 + seededRandom(seed, 1, 6) * 0.6,
      0.5 + seededRandom(seed, 1, 7) * 0.5,
      0.7 + seededRandom(seed, 1, 8) * 0.6
    );
    rock.castShadow = false;
    parent.add(rock);
  }

  function createFlower(parent, x, y, z, seed) {
    var flowerGroup = new THREE.Group();
    var stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
    var stemMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
    var stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.y = 0.2;
    stem.castShadow = false;
    flowerGroup.add(stem);
    var petalColors = [0xff4081, 0xffeb3b, 0xe040fb, 0xff5722, 0x29b6f6, 0xffffff];
    var petalColor = petalColors[Math.floor(seededRandom(seed, 2, 1) * petalColors.length)];
    var petalGeo = new THREE.SphereGeometry(0.12, 6, 6);
    var petalMat = new THREE.MeshStandardMaterial({ color: petalColor });
    var petal = new THREE.Mesh(petalGeo, petalMat);
    petal.position.y = 0.42;
    petal.castShadow = false;
    flowerGroup.add(petal);

    flowerGroup.position.set(x, y, z);
    parent.add(flowerGroup);
  }

  function createGrassClump(parent, x, y, z, seed) {
    var count = 3 + Math.floor(seededRandom(seed, 3, 1) * 4);
    var grassGroup = new THREE.Group();
    for (var i = 0; i < count; i++) {
      var bladeH = 0.3 + seededRandom(seed, 3, i + 2) * 0.5;
      var bladeGeo = new THREE.ConeGeometry(0.03, bladeH, 3);
      var green = 0.3 + seededRandom(seed, 3, i + 10) * 0.4;
      var bladeMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0.1, green, 0.05)
      });
      var blade = new THREE.Mesh(bladeGeo, bladeMat);
      blade.position.set(
        (seededRandom(seed, 3, i + 20) - 0.5) * 0.6,
        bladeH / 2,
        (seededRandom(seed, 3, i + 30) - 0.5) * 0.6
      );
      blade.rotation.set(
        (seededRandom(seed, 3, i + 40) - 0.5) * 0.3,
        seededRandom(seed, 3, i + 50) * Math.PI,
        (seededRandom(seed, 3, i + 60) - 0.5) * 0.3
      );
      blade.castShadow = false;
      grassGroup.add(blade);
    }
    grassGroup.position.set(x, y, z);
    parent.add(grassGroup);
  }

  function createZoneStructures(scene) {
    createNexusStructure(scene);
    createGardensStructure(scene);
    createAtheneumStructure(scene);
    createStudioStructure(scene);
    createWildsStructure(scene);
    createAgoraStructure(scene);
    createCommonsStructure(scene);
    createArenaStructure(scene);
    createPortals(scene);
  }

  function createZoneNightLights(scene) {
    var lightDefs = [
      { x: 5, z: 5, y: 4, zone: 'nexus' },
      { x: -5, z: 5, y: 4, zone: 'nexus' },
      { x: -5, z: -5, y: 4, zone: 'nexus' },
      { x: 0, z: 0, y: 6, zone: 'nexus' },
      { x: 200, z: 30, y: 3, zone: 'gardens' },
      { x: 210, z: 40, y: 2.5, zone: 'gardens' },
      { x: 190, z: 20, y: 2.5, zone: 'gardens' },
      { x: 100, z: -220, y: 4, zone: 'athenaeum' },
      { x: 105, z: -215, y: 4, zone: 'athenaeum' },
      { x: 95, z: -225, y: 3, zone: 'athenaeum' },
      { x: -200, z: -100, y: 3, zone: 'studio' },
      { x: -195, z: -95, y: 3, zone: 'studio' },
      { x: -190, z: 120, y: 3, zone: 'agora' },
      { x: -185, z: 125, y: 3, zone: 'agora' },
      { x: -195, z: 115, y: 3.5, zone: 'agora' },
      { x: 170, z: 190, y: 3, zone: 'commons' },
      { x: 175, z: 195, y: 3, zone: 'commons' },
      { x: -30, z: 260, y: 2.5, zone: 'wilds' },
      { x: 8, z: -240, y: 3.5, zone: 'arena' },
      { x: -8, z: -240, y: 3.5, zone: 'arena' }
    ];

    var glowGeo = new THREE.SphereGeometry(0.15, 8, 8);

    for (var i = 0; i < lightDefs.length; i++) {
      var def = lightDefs[i];
      var ty = terrainHeight(def.x, def.z) + def.y;

      var light = new THREE.PointLight(0xffaa55, 0, 15, 2);
      light.position.set(def.x, ty, def.z);
      scene.add(light);

      var glowMat = new THREE.MeshBasicMaterial({
        color: 0xffcc66,
        transparent: true,
        opacity: 0
      });
      var glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.set(def.x, ty, def.z);
      scene.add(glow);

      zoneLights.push({ light: light, glow: glow, zone: def.zone });
    }
  }

  function createNexusStructure(scene) {
    var z = ZONES.nexus, y = z.baseHeight;
    var platGeo = new THREE.CylinderGeometry(12, 14, 1.5, 32);
    var platMat = new THREE.MeshStandardMaterial({ color: 0xc0c0d0, roughness: 0.7 });
    var plat = new THREE.Mesh(platGeo, platMat);
    plat.position.set(z.cx, y + 0.75, z.cz);
    plat.castShadow = false;
    scene.add(plat);

    var obGeo = new THREE.CylinderGeometry(0.5, 1.5, 10, 6);
    var obMat = new THREE.MeshStandardMaterial({ color: 0x6666ff, emissive: 0x3333aa, emissiveIntensity: 0.4 });
    var obelisk = new THREE.Mesh(obGeo, obMat);
    obelisk.position.set(z.cx, y + 6.5, z.cz);
    obelisk.castShadow = false;
    scene.add(obelisk);
    animatedObjects.push({ mesh: obelisk, type: 'crystal', params: { speed: 0.3, baseY: y + 6.5 } });

    for (var i = 0; i < 8; i++) {
      var angle = (i / 8) * Math.PI * 2;
      var px = z.cx + Math.cos(angle) * 10;
      var pz = z.cz + Math.sin(angle) * 10;
      var pillarGeo = new THREE.CylinderGeometry(0.4, 0.5, 6, 8);
      var pillarMat = new THREE.MeshStandardMaterial({ color: 0xd0d0e0 });
      var pillar = new THREE.Mesh(pillarGeo, pillarMat);
      pillar.position.set(px, y + 3, pz);
      pillar.castShadow = false;
      scene.add(pillar);

      var capGeo = new THREE.SphereGeometry(0.6, 8, 8);
      var capMat = new THREE.MeshStandardMaterial({ color: 0xe0e0f0 });
      var cap = new THREE.Mesh(capGeo, capMat);
      cap.position.set(px, y + 6.2, pz);
      cap.castShadow = false;
      scene.add(cap);
    }

    var poolGeo = new THREE.CylinderGeometry(4, 4, 0.3, 24);
    var poolMat = new THREE.MeshStandardMaterial({
      color: 0x4488ff, emissive: 0x2244aa, emissiveIntensity: 0.3,
      transparent: true, opacity: 0.7
    });
    var pool = new THREE.Mesh(poolGeo, poolMat);
    pool.position.set(z.cx, y + 0.15, z.cz);
    pool.castShadow = false;
    scene.add(pool);
    animatedObjects.push({ mesh: pool, type: 'water', params: { speed: 1 } });

    var monumentGeo = new THREE.CylinderGeometry(0.8, 1.2, 3, 8);
    var monumentMat = new THREE.MeshStandardMaterial({
      color: 0xb0b0d0,
      emissive: 0x5555aa,
      emissiveIntensity: 0.2,
      roughness: 0.5
    });
    var monument = new THREE.Mesh(monumentGeo, monumentMat);
    monument.position.set(z.cx + 6, y + 2.5, z.cz + 6);
    monument.castShadow = false;
    scene.add(monument);

    for (var j = 0; j < 4; j++) {
      var jAngle = (j / 4) * Math.PI * 2;
      var jx = z.cx + Math.cos(jAngle) * 2;
      var jz = z.cz + Math.sin(jAngle) * 2;
      var jetGeo = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 8);
      var jetMat = new THREE.MeshStandardMaterial({
        color: 0x66aaff,
        transparent: true,
        opacity: 0.6
      });
      var jet = new THREE.Mesh(jetGeo, jetMat);
      jet.position.set(jx, y + 2.5, jz);
      jet.castShadow = false;
      scene.add(jet);
      animatedObjects.push({ mesh: jet, type: 'water', params: { speed: 2 } });
    }

    for (var b = 0; b < 4; b++) {
      var bAngle = (b / 4) * Math.PI * 2 + Math.PI / 8;
      var bx = z.cx + Math.cos(bAngle) * 16;
      var bz = z.cz + Math.sin(bAngle) * 16;

      var benchGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
      var benchMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(bx, y + 0.4, bz);
      bench.rotation.y = bAngle + Math.PI / 2;
      bench.castShadow = false;
      scene.add(bench);

      for (var leg = -1; leg <= 1; leg += 2) {
        var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 6);
        var legMesh = new THREE.Mesh(legGeo, benchMat);
        legMesh.position.set(
          bx + Math.cos(bAngle + Math.PI / 2) * leg * 0.9,
          y + 0.2,
          bz + Math.sin(bAngle + Math.PI / 2) * leg * 0.9
        );
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    for (var k = 0; k < 3; k++) {
      var kAngle = (k / 3) * Math.PI * 2;
      var kx = z.cx + Math.cos(kAngle) * 7;
      var kz = z.cz + Math.sin(kAngle) * 7;
      var orbGeo = new THREE.SphereGeometry(0.3, 12, 12);
      var orbMat = new THREE.MeshStandardMaterial({
        color: 0x8888ff,
        emissive: 0x6666cc,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(kx, y + 4 + k * 0.5, kz);
      orb.castShadow = false;
      scene.add(orb);
      animatedObjects.push({ mesh: orb, type: 'crystal', params: { speed: 0.4, baseY: y + 4 + k * 0.5 } });
    }
  }

  function createGardensStructure(scene) {
    var z = ZONES.gardens, y = z.baseHeight;
    for (var ring = 0; ring < 3; ring++) {
      var radius = 8 + ring * 8;
      var segments = 8 + ring * 4;
      for (var s = 0; s < segments; s++) {
        var angle = (s / segments) * Math.PI * 2;
        var bx = z.cx + Math.cos(angle) * radius;
        var bz = z.cz + Math.sin(angle) * radius;
        var bedGeo = new THREE.BoxGeometry(3, 0.6, 3);
        var bedMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var bed = new THREE.Mesh(bedGeo, bedMat);
        bed.position.set(bx, y + 0.3, bz);
        bed.rotation.y = angle;
        bed.castShadow = false;
        scene.add(bed);
        var plantGeo = new THREE.SphereGeometry(0.8, 6, 6);
        var plantColors = [0x4caf50, 0x66bb6a, 0x81c784, 0xa5d6a7];
        var plantMat = new THREE.MeshStandardMaterial({
          color: plantColors[s % plantColors.length]
        });
        var plant = new THREE.Mesh(plantGeo, plantMat);
        plant.position.set(bx, y + 1.0, bz);
        plant.castShadow = false;
        scene.add(plant);
      }
    }

    var fountainGeo = new THREE.CylinderGeometry(3, 3.5, 1.5, 16);
    var fountainMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
    var fountain = new THREE.Mesh(fountainGeo, fountainMat);
    fountain.position.set(z.cx, y + 0.75, z.cz);
    fountain.castShadow = false;
    scene.add(fountain);

    var waterGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.3, 16);
    var waterMat = new THREE.MeshStandardMaterial({
      color: 0x4488cc, transparent: true, opacity: 0.6
    });
    var water = new THREE.Mesh(waterGeo, waterMat);
    water.position.set(z.cx, y + 1.5, z.cz);
    water.castShadow = false;
    scene.add(water);
    animatedObjects.push({ mesh: water, type: 'water', params: { speed: 1 } });

    for (var sp = 0; sp < 12; sp++) {
      var spAngle = (sp / 12) * Math.PI * 2 + 0.2;
      var spRadius = 12 + (sp % 3) * 6;
      var spx = z.cx + Math.cos(spAngle) * spRadius;
      var spz = z.cz + Math.sin(spAngle) * spRadius;

      var plantHeight = 0.5 + seededRandom(sp, 10, 1) * 1.5;
      var plantGeo = new THREE.ConeGeometry(0.3, plantHeight, 6);
      var plantColors = [0x66bb6a, 0x81c784, 0xa5d6a7, 0x4caf50, 0x8bc34a];
      var plantMat = new THREE.MeshStandardMaterial({
        color: plantColors[sp % plantColors.length]
      });
      var plant = new THREE.Mesh(plantGeo, plantMat);
      plant.position.set(spx, y + plantHeight / 2, spz);
      plant.castShadow = false;
      scene.add(plant);
    }

    for (var bf = 0; bf < 8; bf++) {
      var bfAngle = (bf / 8) * Math.PI * 2;
      var bfx = z.cx + Math.cos(bfAngle) * (15 + bf % 3 * 5);
      var bfz = z.cz + Math.sin(bfAngle) * (15 + bf % 3 * 5);
      var butterflyGeo = new THREE.SphereGeometry(0.15, 6, 6);
      var butterflyMat = new THREE.MeshStandardMaterial({
        color: bf % 2 === 0 ? 0xffeb3b : 0xff69b4,
        emissive: bf % 2 === 0 ? 0xffeb3b : 0xff69b4,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.7
      });
      var butterfly = new THREE.Mesh(butterflyGeo, butterflyMat);
      butterfly.position.set(bfx, y + 1.5 + bf * 0.2, bfz);
      butterfly.castShadow = false;
      scene.add(butterfly);
      animatedObjects.push({
        mesh: butterfly,
        type: 'crystal',
        params: { speed: 0.5 + bf * 0.1, baseY: y + 1.5 + bf * 0.2 }
      });
    }

    for (var ga = 0; ga < 4; ga++) {
      var gaAngle = (ga / 4) * Math.PI * 2;
      var gax = z.cx + Math.cos(gaAngle) * 25;
      var gaz = z.cz + Math.sin(gaAngle) * 25;

      for (var side = -1; side <= 1; side += 2) {
        var postGeo = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
        var postMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var post = new THREE.Mesh(postGeo, postMat);
        var perpAngle = gaAngle + Math.PI / 2;
        post.position.set(
          gax + Math.cos(perpAngle) * side * 1.5,
          y + 1.5,
          gaz + Math.sin(perpAngle) * side * 1.5
        );
        post.castShadow = false;
        scene.add(post);
      }

      var beamGeo = new THREE.BoxGeometry(3.5, 0.2, 0.2);
      var beamMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.set(gax, y + 3.2, gaz);
      beam.rotation.y = gaAngle + Math.PI / 2;
      beam.castShadow = false;
      scene.add(beam);

      var vineGeo = new THREE.TorusGeometry(0.8, 0.08, 6, 12);
      var vineMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
      var vine = new THREE.Mesh(vineGeo, vineMat);
      vine.position.set(gax, y + 2.8, gaz);
      vine.rotation.x = Math.PI / 2;
      vine.castShadow = false;
      scene.add(vine);
    }

    for (var pm = 0; pm < 6; pm++) {
      var pmAngle = (pm / 6) * Math.PI * 2;
      var pmx = z.cx + Math.cos(pmAngle) * 18;
      var pmz = z.cz + Math.sin(pmAngle) * 18;
      var markerGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
      var markerMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var marker = new THREE.Mesh(markerGeo, markerMat);
      marker.position.set(pmx, y + 0.15, pmz);
      marker.castShadow = false;
      scene.add(marker);
    }
  }

  function createAtheneumStructure(scene) {
    var z = ZONES.athenaeum, y = z.baseHeight;
    var baseGeo = new THREE.BoxGeometry(20, 6, 14);
    var baseMat = new THREE.MeshStandardMaterial({ color: 0xdbd8d0 });
    var base = new THREE.Mesh(baseGeo, baseMat);
    base.position.set(z.cx, y + 3, z.cz);
    base.castShadow = false;
    scene.add(base);

    var roofGeo = new THREE.ConeGeometry(14, 4, 4);
    var roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
    var roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.set(z.cx, y + 8, z.cz);
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = false;
    scene.add(roof);

    for (var c = 0; c < 6; c++) {
      var colX = z.cx - 8 + c * 3.2;
      var colGeo = new THREE.CylinderGeometry(0.4, 0.5, 6, 8);
      var colMat = new THREE.MeshStandardMaterial({ color: 0xe8e4dc });
      var col = new THREE.Mesh(colGeo, colMat);
      col.position.set(colX, y + 3, z.cz + 8);
      col.castShadow = false;
      scene.add(col);
    }

    for (var st = 0; st < 4; st++) {
      var stepGeo = new THREE.BoxGeometry(18 + st * 2, 0.4, 2);
      var stepMat = new THREE.MeshStandardMaterial({ color: 0xccc8c0 });
      var step = new THREE.Mesh(stepGeo, stepMat);
      step.position.set(z.cx, y + 0.2 + st * 0.4, z.cz + 9 + st * 1.5);
      step.castShadow = false;
      scene.add(step);
    }

    for (var fb = 0; fb < 10; fb++) {
      var fbAngle = (fb / 10) * Math.PI * 2;
      var fbRadius = 8 + (fb % 3) * 3;
      var fbx = z.cx + Math.cos(fbAngle) * fbRadius;
      var fbz = z.cz + Math.sin(fbAngle) * fbRadius;
      var bookGeo = new THREE.BoxGeometry(0.2, 0.3, 0.05);
      var bookMat = new THREE.MeshStandardMaterial({
        color: [0x8b4513, 0x5d4037, 0x3e2723][fb % 3],
        emissive: 0x4a2511,
        emissiveIntensity: 0.1
      });
      var book = new THREE.Mesh(bookGeo, bookMat);
      book.position.set(fbx, y + 5 + fb * 0.3, fbz);
      book.rotation.y = fbAngle;
      book.rotation.x = Math.PI / 6;
      book.castShadow = false;
      scene.add(book);
      animatedObjects.push({
        mesh: book,
        type: 'crystal',
        params: { speed: 0.2, baseY: y + 5 + fb * 0.3 }
      });
    }

    for (var ko = 0; ko < 6; ko++) {
      var koAngle = (ko / 6) * Math.PI * 2;
      var kox = z.cx + Math.cos(koAngle) * 6;
      var koz = z.cz + Math.sin(koAngle) * 6;
      var orbGeo = new THREE.SphereGeometry(0.25, 12, 12);
      var orbMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        emissive: 0xffaa00,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.7
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(kox, y + 6 + ko * 0.4, koz);
      orb.castShadow = false;
      scene.add(orb);
      animatedObjects.push({
        mesh: orb,
        type: 'crystal',
        params: { speed: 0.3, baseY: y + 6 + ko * 0.4 }
      });
    }

    for (var rd = 0; rd < 4; rd++) {
      var rdAngle = (rd / 4) * Math.PI * 2 + Math.PI / 4;
      var rdx = z.cx + Math.cos(rdAngle) * 12;
      var rdz = z.cz + Math.sin(rdAngle) * 12;
      var deskGeo = new THREE.BoxGeometry(2, 0.15, 1.2);
      var deskMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var desk = new THREE.Mesh(deskGeo, deskMat);
      desk.position.set(rdx, y + 0.8, rdz);
      desk.rotation.y = rdAngle;
      desk.castShadow = false;
      scene.add(desk);

      for (var dl = 0; dl < 4; dl++) {
        var dlx = rdx + Math.cos(rdAngle) * (dl < 2 ? -0.9 : 0.9) + Math.cos(rdAngle + Math.PI / 2) * (dl % 2 === 0 ? -0.5 : 0.5);
        var dlz = rdz + Math.sin(rdAngle) * (dl < 2 ? -0.9 : 0.9) + Math.sin(rdAngle + Math.PI / 2) * (dl % 2 === 0 ? -0.5 : 0.5);
        var legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 6);
        var legMesh = new THREE.Mesh(legGeo, deskMat);
        legMesh.position.set(dlx, y + 0.4, dlz);
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    for (var sc = 0; sc < 6; sc++) {
      var scrollGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
      var scrollMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
      var scroll = new THREE.Mesh(scrollGeo, scrollMat);
      var scx = z.cx - 8 + sc * 3.2;
      scroll.position.set(scx, y + 6, z.cz + 8);
      scroll.rotation.z = Math.PI / 2;
      scroll.castShadow = false;
      scene.add(scroll);
    }

    for (var tp = 0; tp < 3; tp++) {
      var tpx = z.cx + (tp - 1) * 5;
      var pedestalGeo = new THREE.CylinderGeometry(0.5, 0.7, 1.2, 8);
      var pedestalMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
      pedestal.position.set(tpx, y + 0.6, z.cz - 3);
      pedestal.castShadow = false;
      scene.add(pedestal);

      var tomeGeo = new THREE.BoxGeometry(0.6, 0.15, 0.8);
      var tomeMat = new THREE.MeshStandardMaterial({
        color: 0x4a148c,
        emissive: 0x2a0a4c,
        emissiveIntensity: 0.2
      });
      var tome = new THREE.Mesh(tomeGeo, tomeMat);
      tome.position.set(tpx, y + 1.3, z.cz - 3);
      tome.rotation.y = Math.PI / 8;
      tome.castShadow = false;
      scene.add(tome);
    }
  }

  function createStudioStructure(scene) {
    var z = ZONES.studio, y = z.baseHeight;
    for (var i = 0; i < 5; i++) {
      var angle = (i / 5) * Math.PI * 2 + 0.3;
      var bx = z.cx + Math.cos(angle) * 14;
      var bz = z.cz + Math.sin(angle) * 14;

      var buildGeo = new THREE.BoxGeometry(6, 5, 6);
      var buildColors = [0xff9800, 0xffc107, 0xff5722, 0x8bc34a, 0x03a9f4];
      var buildMat = new THREE.MeshStandardMaterial({ color: buildColors[i] });
      var build = new THREE.Mesh(buildGeo, buildMat);
      build.position.set(bx, y + 2.5, bz);
      build.rotation.y = angle + Math.PI;
      build.castShadow = false;
      scene.add(build);

      var sRoofGeo = new THREE.ConeGeometry(4.5, 3, 4);
      var sRoofMat = new THREE.MeshStandardMaterial({ color: 0x795548 });
      var sRoof = new THREE.Mesh(sRoofGeo, sRoofMat);
      sRoof.position.set(bx, y + 6.5, bz);
      sRoof.rotation.y = Math.PI / 4;
      sRoof.castShadow = false;
      scene.add(sRoof);
    }

    var sculpGeo = new THREE.OctahedronGeometry(2, 0);
    var sculpMat = new THREE.MeshStandardMaterial({
      color: 0xff6f00, emissive: 0x442200, emissiveIntensity: 0.3
    });
    var sculpture = new THREE.Mesh(sculpGeo, sculpMat);
    sculpture.position.set(z.cx, y + 4, z.cz);
    sculpture.castShadow = false;
    scene.add(sculpture);
    animatedObjects.push({ mesh: sculpture, type: 'crystal', params: { speed: 0.5, baseY: y + 4 } });

    for (var ps = 0; ps < 15; ps++) {
      var psAngle = (ps / 15) * Math.PI * 2;
      var psRadius = 5 + seededRandom(ps, 20, 1) * 10;
      var psx = z.cx + Math.cos(psAngle) * psRadius;
      var psz = z.cz + Math.sin(psAngle) * psRadius;
      var splatGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var splatColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800, 0x8800ff];
      var splatMat = new THREE.MeshStandardMaterial({
        color: splatColors[ps % splatColors.length],
        emissive: splatColors[ps % splatColors.length],
        emissiveIntensity: 0.3
      });
      var splat = new THREE.Mesh(splatGeo, splatMat);
      splat.position.set(psx, y + 0.15, psz);
      splat.scale.y = 0.3;
      splat.castShadow = false;
      scene.add(splat);
    }

    for (var ea = 0; ea < 5; ea++) {
      var eaAngle = (ea / 5) * Math.PI * 2 + 0.2;
      var eax = z.cx + Math.cos(eaAngle) * 10;
      var eaz = z.cz + Math.sin(eaAngle) * 10;

      for (var el = 0; el < 3; el++) {
        var elAngle = eaAngle + (el / 3) * Math.PI * 2;
        var legGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 6);
        var legMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(
          eax + Math.cos(elAngle) * 0.3,
          y + 1,
          eaz + Math.sin(elAngle) * 0.3
        );
        leg.rotation.z = (el === 1 ? -0.2 : (el === 2 ? 0.2 : 0));
        leg.castShadow = false;
        scene.add(leg);
      }

      var canvasGeo = new THREE.PlaneGeometry(1.2, 1.5);
      var canvasMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });
      var canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.set(eax, y + 1.8, eaz);
      canvas.rotation.y = eaAngle;
      canvas.castShadow = false;
      scene.add(canvas);
    }

    for (var mn = 0; mn < 6; mn++) {
      var mnAngle = (mn / 6) * Math.PI * 2;
      var mnx = z.cx + Math.cos(mnAngle) * 8;
      var mnz = z.cz + Math.sin(mnAngle) * 8;
      var noteGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var noteMat = new THREE.MeshStandardMaterial({
        color: 0xff69b4,
        emissive: 0xff1493,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.7
      });
      var note = new THREE.Mesh(noteGeo, noteMat);
      note.position.set(mnx, y + 3 + mn * 0.4, mnz);
      note.castShadow = false;
      scene.add(note);
      animatedObjects.push({
        mesh: note,
        type: 'crystal',
        params: { speed: 0.4 + mn * 0.1, baseY: y + 3 + mn * 0.4 }
      });
    }

    for (var sp = 0; sp < 3; sp++) {
      var spAngle = (sp / 3) * Math.PI * 2;
      var spx = z.cx + Math.cos(spAngle) * 18;
      var spz = z.cz + Math.sin(spAngle) * 18;
      var pedGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8);
      var pedMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var ped = new THREE.Mesh(pedGeo, pedMat);
      ped.position.set(spx, y + 0.75, spz);
      ped.castShadow = false;
      scene.add(ped);

      var miniSculpGeo = new THREE.TorusGeometry(0.4, 0.15, 8, 12);
      var miniSculpMat = new THREE.MeshStandardMaterial({
        color: [0xff9800, 0x9c27b0, 0x00bcd4][sp],
        emissive: [0xff9800, 0x9c27b0, 0x00bcd4][sp],
        emissiveIntensity: 0.2
      });
      var miniSculp = new THREE.Mesh(miniSculpGeo, miniSculpMat);
      miniSculp.position.set(spx, y + 1.8, spz);
      miniSculp.rotation.x = Math.PI / 4;
      miniSculp.castShadow = false;
      scene.add(miniSculp);
    }

    for (var pp = 0; pp < 4; pp++) {
      var ppx = z.cx + (pp % 2 === 0 ? -6 : 6);
      var ppz = z.cz + (pp < 2 ? -6 : 6);
      var paletteGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 8);
      var paletteMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var palette = new THREE.Mesh(paletteGeo, paletteMat);
      palette.position.set(ppx, y + 0.05, ppz);
      palette.castShadow = false;
      scene.add(palette);
    }
  }

  function createWildsStructure(scene) {
    var z = ZONES.wilds, y = z.baseHeight;
    for (var i = 0; i < 12; i++) {
      var angle = (i / 12) * Math.PI * 2;
      var sx = z.cx + Math.cos(angle) * 16;
      var sz = z.cz + Math.sin(angle) * 16;
      var stoneH = 3 + seededRandom(i, 5, 1) * 3;
      var stoneGeo = new THREE.BoxGeometry(1.5, stoneH, 0.8);
      var stoneMat = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.95 });
      var stone = new THREE.Mesh(stoneGeo, stoneMat);
      var sh = terrainHeight(sx, sz);
      stone.position.set(sx, sh + stoneH / 2, sz);
      stone.rotation.y = angle;
      stone.rotation.z = (seededRandom(i, 5, 2) - 0.5) * 0.15;
      stone.castShadow = false;
      scene.add(stone);
    }

    var altarGeo = new THREE.BoxGeometry(4, 1.5, 4);
    var altarMat = new THREE.MeshStandardMaterial({ color: 0x3e6b3e, roughness: 0.95 });
    var altar = new THREE.Mesh(altarGeo, altarMat);
    altar.position.set(z.cx, y + 0.75, z.cz);
    altar.castShadow = false;
    scene.add(altar);

    var runeGeo = new THREE.RingGeometry(0.5, 1.5, 6);
    var runeMat = new THREE.MeshStandardMaterial({
      color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.5,
      side: THREE.DoubleSide
    });
    var rune = new THREE.Mesh(runeGeo, runeMat);
    rune.position.set(z.cx, y + 1.55, z.cz);
    rune.rotation.x = -Math.PI / 2;
    rune.castShadow = false;
    scene.add(rune);
    animatedObjects.push({ mesh: rune, type: 'crystal', params: { speed: 0.2, baseY: y + 1.55 } });

    for (var vt = 0; vt < 10; vt++) {
      var vtAngle = (vt / 10) * Math.PI * 2;
      var vtRadius = 20 + seededRandom(vt, 15, 1) * 15;
      var vtx = z.cx + Math.cos(vtAngle) * vtRadius;
      var vtz = z.cz + Math.sin(vtAngle) * vtRadius;
      var treeHeight = 3 + seededRandom(vt, 15, 2) * 4;

      var trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, treeHeight, 8);
      var trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(vtx, y + treeHeight / 2, vtz);
      trunk.castShadow = false;
      scene.add(trunk);

      var canopyGeo = new THREE.SphereGeometry(treeHeight * 0.5, 8, 8);
      var canopyMat = new THREE.MeshStandardMaterial({ color: 0x1a5e1a });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.set(vtx, y + treeHeight + treeHeight * 0.3, vtz);
      canopy.castShadow = false;
      scene.add(canopy);
    }

    for (var at = 0; at < 20; at++) {
      var atAngle = (at / 20) * Math.PI * 2;
      var atRadius = 8 + (at % 5) * 3;
      var atx = z.cx + Math.cos(atAngle) * atRadius;
      var atz = z.cz + Math.sin(atAngle) * atRadius;
      var trackGeo = new THREE.SphereGeometry(0.12, 6, 6);
      var trackMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
      var track = new THREE.Mesh(trackGeo, trackMat);
      track.position.set(atx, y + 0.08, atz);
      track.scale.y = 0.3;
      track.castShadow = false;
      scene.add(track);
    }

    for (var fg = 0; fg < 6; fg++) {
      var fgAngle = (fg / 6) * Math.PI * 2 + 0.3;
      var fgx = z.cx + Math.cos(fgAngle) * 12;
      var fgz = z.cz + Math.sin(fgAngle) * 12;
      var fogGeo = new THREE.SphereGeometry(2, 8, 8);
      var fogMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        transparent: true,
        opacity: 0.2,
        emissive: 0xaaaaaa,
        emissiveIntensity: 0.1
      });
      var fog = new THREE.Mesh(fogGeo, fogMat);
      fog.position.set(fgx, y + 1, fgz);
      fog.scale.y = 0.4;
      fog.castShadow = false;
      scene.add(fog);
      animatedObjects.push({
        mesh: fog,
        type: 'water',
        params: { speed: 0.3 }
      });
    }

    for (var wm = 0; wm < 12; wm++) {
      var wmAngle = (wm / 12) * Math.PI * 2;
      var wmRadius = 10 + (wm % 4) * 4;
      var wmx = z.cx + Math.cos(wmAngle) * wmRadius;
      var wmz = z.cz + Math.sin(wmAngle) * wmRadius;

      for (var mc = 0; mc < 3; mc++) {
        var mushroomCapGeo = new THREE.SphereGeometry(0.3, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        var mushroomMat = new THREE.MeshStandardMaterial({
          color: wm % 3 === 0 ? 0xff6b6b : (wm % 3 === 1 ? 0x4ecdc4 : 0xf7b731)
        });
        var mushroomCap = new THREE.Mesh(mushroomCapGeo, mushroomMat);
        mushroomCap.position.set(
          wmx + (mc - 1) * 0.4,
          y + 0.25 + mc * 0.05,
          wmz
        );
        mushroomCap.castShadow = false;
        scene.add(mushroomCap);

        var stemGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 6);
        var stemMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
        var stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.set(
          wmx + (mc - 1) * 0.4,
          y + 0.1 + mc * 0.05,
          wmz
        );
        stem.castShadow = false;
        scene.add(stem);
      }
    }

    for (var vr = 0; vr < 8; vr++) {
      var vrAngle = (vr / 8) * Math.PI * 2;
      var vrx = z.cx + Math.cos(vrAngle) * 18;
      var vrz = z.cz + Math.sin(vrAngle) * 18;
      var rockSize = 0.8 + seededRandom(vr, 25, 1) * 1.2;
      var vineRockGeo = new THREE.SphereGeometry(rockSize, 8, 8);
      var vineRockMat = new THREE.MeshStandardMaterial({ color: 0x3e6b3e });
      var vineRock = new THREE.Mesh(vineRockGeo, vineRockMat);
      vineRock.position.set(vrx, y + rockSize * 0.6, vrz);
      vineRock.scale.y = 0.7;
      vineRock.castShadow = false;
      scene.add(vineRock);
    }
  }

  function createAgoraStructure(scene) {
    var z = ZONES.agora, y = z.baseHeight;
    for (var i = 0; i < 8; i++) {
      var sx = z.cx + (i % 4 - 1.5) * 8;
      var sz = z.cz + Math.floor(i / 4) * 14 - 7;
      var tentGeo = new THREE.ConeGeometry(3, 4, 4);
      var tentColors = [0xdc143c, 0xff8c00, 0x4169e1, 0x2e8b57, 0x9400d3, 0xdaa520, 0x008b8b, 0xcd853f];
      var tentMat = new THREE.MeshStandardMaterial({ color: tentColors[i] });
      var tent = new THREE.Mesh(tentGeo, tentMat);
      tent.position.set(sx, y + 5, sz);
      tent.castShadow = false;
      scene.add(tent);
      var counterGeo = new THREE.BoxGeometry(4, 1, 2);
      var counterMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var counter = new THREE.Mesh(counterGeo, counterMat);
      counter.position.set(sx, y + 0.5, sz + 2.5);
      counter.castShadow = false;
      scene.add(counter);
      for (var p = -1; p <= 1; p += 2) {
        var poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 6);
        var poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
        var pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.set(sx + p * 2.5, y + 2.5, sz);
        pole.castShadow = false;
        scene.add(pole);
      }
    }

    for (var c = 0; c < 10; c++) {
      var crx = z.cx + (seededRandom(100, c, 1) - 0.5) * 25;
      var crz = z.cz + (seededRandom(100, c, 2) - 0.5) * 25;
      var crateGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
      var crateMat = new THREE.MeshStandardMaterial({ color: 0xd2691e });
      var crate = new THREE.Mesh(crateGeo, crateMat);
      crate.position.set(crx, y + 0.6, crz);
      crate.rotation.y = seededRandom(100, c, 3) * Math.PI;
      crate.castShadow = false;
      scene.add(crate);
    }

    for (var aw = 0; aw < 8; aw++) {
      var awx = z.cx + (aw % 4 - 1.5) * 8;
      var awz = z.cz + Math.floor(aw / 4) * 14 - 7;

      for (var hl = -1; hl <= 1; hl += 2) {
        var lanternGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.4, 6);
        var lanternMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.4
        });
        var lantern = new THREE.Mesh(lanternGeo, lanternMat);
        lantern.position.set(awx + hl * 2, y + 3.5, awz);
        lantern.castShadow = false;
        scene.add(lantern);

        var ropeGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
        var ropeMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
        var rope = new THREE.Mesh(ropeGeo, ropeMat);
        rope.position.set(awx + hl * 2, y + 4.2, awz);
        rope.castShadow = false;
        scene.add(rope);
      }
    }

    for (var tg = 0; tg < 8; tg++) {
      var tgx = z.cx + (tg % 4 - 1.5) * 8;
      var tgz = z.cz + Math.floor(tg / 4) * 14 - 7 + 2.5;

      for (var di = 0; di < 3; di++) {
        var displayGeo = di % 2 === 0 ? new THREE.SphereGeometry(0.15, 8, 8) : new THREE.BoxGeometry(0.25, 0.25, 0.25);
        var displayColors = [0xff6b6b, 0x4ecdc4, 0xf7b731, 0x5f27cd, 0x00d2d3, 0xff9ff3];
        var displayMat = new THREE.MeshStandardMaterial({
          color: displayColors[(tg + di) % displayColors.length],
          emissive: displayColors[(tg + di) % displayColors.length],
          emissiveIntensity: 0.1
        });
        var display = new THREE.Mesh(displayGeo, displayMat);
        display.position.set(tgx + (di - 1) * 0.5, y + 1.15, tgz);
        display.castShadow = false;
        scene.add(display);
      }
    }

    for (var br = 0; br < 6; br++) {
      var brAngle = (br / 6) * Math.PI * 2;
      var brx = z.cx + Math.cos(brAngle) * 12;
      var brz = z.cz + Math.sin(brAngle) * 12;
      var barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.2, 12);
      var barrelMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var barrel = new THREE.Mesh(barrelGeo, barrelMat);
      barrel.position.set(brx, y + 0.6, brz);
      barrel.castShadow = false;
      scene.add(barrel);

      for (var bb = 0; bb < 3; bb++) {
        var bandGeo = new THREE.TorusGeometry(0.55, 0.03, 6, 12);
        var bandMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        var band = new THREE.Mesh(bandGeo, bandMat);
        band.position.set(brx, y + 0.3 + bb * 0.4, brz);
        band.rotation.x = Math.PI / 2;
        band.castShadow = false;
        scene.add(band);
      }
    }

    for (var rg = 0; rg < 4; rg++) {
      var rgx = z.cx + (rg % 2 - 0.5) * 12;
      var rgz = z.cz + (rg < 2 ? -10 : 10);
      var rugGeo = new THREE.PlaneGeometry(5, 3);
      var rugColors = [0x8b0000, 0x006400, 0x00008b, 0x8b008b];
      var rugMat = new THREE.MeshStandardMaterial({
        color: rugColors[rg],
        side: THREE.DoubleSide
      });
      var rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.set(rgx, y + 0.02, rgz);
      rug.rotation.x = -Math.PI / 2;
      rug.castShadow = false;
      scene.add(rug);
    }

    for (var sgn = 0; sgn < 4; sgn++) {
      var sgnAngle = (sgn / 4) * Math.PI * 2;
      var sgnx = z.cx + Math.cos(sgnAngle) * 20;
      var sgnz = z.cz + Math.sin(sgnAngle) * 20;

      var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      var postMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var post = new THREE.Mesh(postGeo, postMat);
      post.position.set(sgnx, y + 1.5, sgnz);
      post.castShadow = false;
      scene.add(post);

      var signGeo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
      var signMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
      var sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(sgnx, y + 3.2, sgnz);
      sign.rotation.y = sgnAngle;
      sign.castShadow = false;
      scene.add(sign);
    }
  }

  function createCommonsStructure(scene) {
    var z = ZONES.commons, y = z.baseHeight;
    for (var i = 0; i < 8; i++) {
      var angle = (i / 8) * Math.PI * 2;
      var hx = z.cx + Math.cos(angle) * 18;
      var hz = z.cz + Math.sin(angle) * 18;
      var houseGeo = new THREE.BoxGeometry(5, 4, 5);
      var houseColors = [0xfaf0e6, 0xf5deb3, 0xffefd5, 0xffe4c4, 0xffdab9, 0xeee8aa, 0xfafad2, 0xfff8dc];
      var houseMat = new THREE.MeshStandardMaterial({ color: houseColors[i] });
      var house = new THREE.Mesh(houseGeo, houseMat);
      house.position.set(hx, y + 2, hz);
      house.rotation.y = angle + Math.PI;
      house.castShadow = false;
      scene.add(house);
      var roofGeo = new THREE.ConeGeometry(4, 2.5, 4);
      var roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var roofMesh = new THREE.Mesh(roofGeo, roofMat);
      roofMesh.position.set(hx, y + 5.25, hz);
      roofMesh.rotation.y = Math.PI / 4;
      roofMesh.castShadow = false;
      scene.add(roofMesh);
      var doorGeo = new THREE.BoxGeometry(1, 2.5, 0.1);
      var doorMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(hx + Math.cos(angle + Math.PI) * 2.55, y + 1.25, hz + Math.sin(angle + Math.PI) * 2.55);
      door.rotation.y = angle + Math.PI;
      door.castShadow = false;
      scene.add(door);
    }

    var wellGeo = new THREE.CylinderGeometry(1.5, 1.5, 2, 12);
    var wellMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
    var well = new THREE.Mesh(wellGeo, wellMat);
    well.position.set(z.cx, y + 1, z.cz);
    well.castShadow = false;
    scene.add(well);

    var wellRoofGeo = new THREE.ConeGeometry(2.2, 2, 6);
    var wellRoofMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    var wellRoof = new THREE.Mesh(wellRoofGeo, wellRoofMat);
    wellRoof.position.set(z.cx, y + 3.5, z.cz);
    wellRoof.castShadow = false;
    scene.add(wellRoof);

    for (var ws = 0; ws < 4; ws++) {
      var wa = (ws / 4) * Math.PI * 2;
      var wpGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.5, 4);
      var wpMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var wp = new THREE.Mesh(wpGeo, wpMat);
      wp.position.set(z.cx + Math.cos(wa) * 1.2, y + 2.25, z.cz + Math.sin(wa) * 1.2);
      wp.castShadow = false;
      scene.add(wp);
    }

    for (var bc = 0; bc < 6; bc++) {
      var bcAngle = (bc / 6) * Math.PI * 2;
      var bcx = z.cx + Math.cos(bcAngle) * 8;
      var bcz = z.cz + Math.sin(bcAngle) * 8;

      var benchGeo = new THREE.BoxGeometry(2, 0.3, 0.6);
      var benchMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(bcx, y + 0.4, bcz);
      bench.rotation.y = bcAngle + Math.PI / 2;
      bench.castShadow = false;
      scene.add(bench);

      var backGeo = new THREE.BoxGeometry(2, 0.8, 0.1);
      var back = new THREE.Mesh(backGeo, benchMat);
      back.position.set(
        bcx + Math.cos(bcAngle) * 0.35,
        y + 0.9,
        bcz + Math.sin(bcAngle) * 0.35
      );
      back.rotation.y = bcAngle + Math.PI / 2;
      back.castShadow = false;
      scene.add(back);

      for (var bl = -1; bl <= 1; bl += 2) {
        var legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 6);
        var legMesh = new THREE.Mesh(legGeo, benchMat);
        legMesh.position.set(
          bcx + Math.cos(bcAngle + Math.PI / 2) * bl * 0.8,
          y + 0.2,
          bcz + Math.sin(bcAngle + Math.PI / 2) * bl * 0.8
        );
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    for (var gc = 0; gc < 2; gc++) {
      var gcx = z.cx + (gc === 0 ? -10 : 10);
      var gcz = z.cz;

      for (var gs = 0; gs < 10; gs++) {
        var gsAngle = (gs / 10) * Math.PI * 2;
        var stoneGeo = new THREE.BoxGeometry(0.5, 0.3, 0.4);
        var stoneMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
        var stone = new THREE.Mesh(stoneGeo, stoneMat);
        stone.position.set(
          gcx + Math.cos(gsAngle) * 4,
          y + 0.15,
          gcz + Math.sin(gsAngle) * 4
        );
        stone.rotation.y = gsAngle;
        stone.castShadow = false;
        scene.add(stone);
      }
    }

    for (var ls = 0; ls < 8; ls++) {
      var lsAngle = (ls / 8) * Math.PI * 2;
      var lsx = z.cx + Math.cos(lsAngle) * 18;
      var lsz = z.cz + Math.sin(lsAngle) * 18;

      var hangLanternGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var hangLanternMat = new THREE.MeshStandardMaterial({
        color: 0xffeb3b,
        emissive: 0xffc107,
        emissiveIntensity: 0.5
      });
      var hangLantern = new THREE.Mesh(hangLanternGeo, hangLanternMat);
      hangLantern.position.set(lsx, y + 4.5, lsz);
      hangLantern.castShadow = false;
      scene.add(hangLantern);
      animatedObjects.push({
        mesh: hangLantern,
        type: 'torch',
        params: { seed: ls * 100 }
      });

      var nextAngle = ((ls + 1) / 8) * Math.PI * 2;
      var nextX = z.cx + Math.cos(nextAngle) * 18;
      var nextZ = z.cz + Math.sin(nextAngle) * 18;
      var stringLength = Math.sqrt(Math.pow(nextX - lsx, 2) + Math.pow(nextZ - lsz, 2));
      var stringGeo = new THREE.CylinderGeometry(0.02, 0.02, stringLength, 6);
      var stringMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var string = new THREE.Mesh(stringGeo, stringMat);
      string.position.set((lsx + nextX) / 2, y + 4.5, (lsz + nextZ) / 2);
      string.rotation.y = Math.atan2(nextZ - lsz, nextX - lsx);
      string.rotation.z = Math.PI / 2;
      string.castShadow = false;
      scene.add(string);
    }

    for (var fp = 0; fp < 8; fp++) {
      var fpAngle = (fp / 8) * Math.PI * 2;
      var fpx = z.cx + Math.cos(fpAngle) * 16;
      var fpz = z.cz + Math.sin(fpAngle) * 16;

      var potGeo = new THREE.CylinderGeometry(0.3, 0.25, 0.5, 8);
      var potMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var pot = new THREE.Mesh(potGeo, potMat);
      pot.position.set(fpx, y + 0.25, fpz);
      pot.castShadow = false;
      scene.add(pot);

      var flowerGeo = new THREE.SphereGeometry(0.25, 6, 6);
      var flowerMat = new THREE.MeshStandardMaterial({
        color: [0xff6b9d, 0x4ecdc4, 0xf7b731][fp % 3]
      });
      var flower = new THREE.Mesh(flowerGeo, flowerMat);
      flower.position.set(fpx, y + 0.6, fpz);
      flower.castShadow = false;
      scene.add(flower);
    }

    var boardPostGeo = new THREE.CylinderGeometry(0.12, 0.12, 3, 8);
    var boardPostMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    var boardPost = new THREE.Mesh(boardPostGeo, boardPostMat);
    boardPost.position.set(z.cx + 5, y + 1.5, z.cz + 5);
    boardPost.castShadow = false;
    scene.add(boardPost);

    var boardGeo = new THREE.BoxGeometry(2.5, 2, 0.1);
    var boardMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
    var board = new THREE.Mesh(boardGeo, boardMat);
    board.position.set(z.cx + 5, y + 2.5, z.cz + 5);
    board.castShadow = false;
    scene.add(board);

    for (var tr = 0; tr < 2; tr++) {
      var trx = z.cx + (tr === 0 ? -12 : 12);
      var trz = z.cz + 8;

      var rackGeo = new THREE.BoxGeometry(1.5, 0.1, 0.3);
      var rackMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var rack = new THREE.Mesh(rackGeo, rackMat);
      rack.position.set(trx, y + 1.5, trz);
      rack.castShadow = false;
      scene.add(rack);

      for (var tl = 0; tl < 3; tl++) {
        var toolGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
        var toolMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        var tool = new THREE.Mesh(toolGeo, toolMat);
        tool.position.set(trx + (tl - 1) * 0.4, y + 1.1, trz);
        tool.rotation.z = Math.PI / 6;
        tool.castShadow = false;
        scene.add(tool);
      }
    }
  }

  function createArenaStructure(scene) {
    var z = ZONES.arena, y = z.baseHeight;
    for (var tier = 0; tier < 4; tier++) {
      var radius = 18 + tier * 6;
      var height = 1.5 + tier * 2;
      var segments = 20 + tier * 4;
      for (var s = 0; s < segments; s++) {
        var a1 = (s / segments) * Math.PI * 2;
        var sx = z.cx + Math.cos(a1) * radius;
        var sz = z.cz + Math.sin(a1) * radius;
        var seatGeo = new THREE.BoxGeometry(3, 1.5, 2.5);
        var seatMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
        var seat = new THREE.Mesh(seatGeo, seatMat);
        seat.position.set(sx, y + height, sz);
        seat.rotation.y = a1;
        seat.castShadow = false;
        scene.add(seat);
      }
    }

    var arenaFloorGeo = new THREE.CylinderGeometry(16, 16, 0.5, 32);
    var arenaFloorMat = new THREE.MeshStandardMaterial({ color: 0xe0c097 });
    var arenaFloor = new THREE.Mesh(arenaFloorGeo, arenaFloorMat);
    arenaFloor.position.set(z.cx, y + 0.25, z.cz);
    arenaFloor.castShadow = false;
    scene.add(arenaFloor);

    for (var ea = 0; ea < 4; ea++) {
      var eAngle = (ea / 4) * Math.PI * 2;
      var ex = z.cx + Math.cos(eAngle) * 16;
      var ez = z.cz + Math.sin(eAngle) * 16;
      for (var side = -1; side <= 1; side += 2) {
        var epGeo = new THREE.CylinderGeometry(0.6, 0.7, 7, 8);
        var epMat = new THREE.MeshStandardMaterial({ color: 0xc8a882 });
        var ep = new THREE.Mesh(epGeo, epMat);
        var perpAngle = eAngle + Math.PI / 2;
        ep.position.set(ex + Math.cos(perpAngle) * side * 2.5, y + 3.5, ez + Math.sin(perpAngle) * side * 2.5);
        ep.castShadow = false;
        scene.add(ep);
      }
      var archGeo = new THREE.BoxGeometry(6, 1, 1.5);
      var archMat = new THREE.MeshStandardMaterial({ color: 0xc8a882 });
      var arch = new THREE.Mesh(archGeo, archMat);
      arch.position.set(ex, y + 7.5, ez);
      arch.rotation.y = eAngle;
      arch.castShadow = false;
      scene.add(arch);
    }

    for (var ti = 0; ti < 12; ti++) {
      var tAngle = (ti / 12) * Math.PI * 2;
      var tpx = z.cx + Math.cos(tAngle) * 20;
      var tpz = z.cz + Math.sin(tAngle) * 20;
      addTorch(scene, tpx, y, tpz);
    }

    for (var bn = 0; bn < 8; bn++) {
      var bnAngle = (bn / 8) * Math.PI * 2;
      var bnRadius = 28;
      var bnx = z.cx + Math.cos(bnAngle) * bnRadius;
      var bnz = z.cz + Math.sin(bnAngle) * bnRadius;

      var poleGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 8);
      var poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.set(bnx, y + 2, bnz);
      pole.castShadow = false;
      scene.add(pole);

      var bannerGeo = new THREE.PlaneGeometry(1.5, 2.5);
      var bannerColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00];
      var bannerMat = new THREE.MeshStandardMaterial({
        color: bannerColors[bn % bannerColors.length],
        side: THREE.DoubleSide
      });
      var banner = new THREE.Mesh(bannerGeo, bannerMat);
      banner.position.set(bnx, y + 3, bnz);
      banner.rotation.y = bnAngle + Math.PI / 2;
      banner.castShadow = false;
      scene.add(banner);
    }

    for (var tb = 0; tb < 16; tb++) {
      var tbAngle = (tb / 16) * Math.PI * 2;
      var tbRadius = 24;
      var tbx = z.cx + Math.cos(tbAngle) * tbRadius;
      var tbz = z.cz + Math.sin(tbAngle) * tbRadius;

      var bracketGeo = new THREE.BoxGeometry(0.3, 0.15, 0.3);
      var bracketMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      var bracket = new THREE.Mesh(bracketGeo, bracketMat);
      bracket.position.set(tbx, y + 4, tbz);
      bracket.castShadow = false;
      scene.add(bracket);

      var torchGeo = new THREE.SphereGeometry(0.12, 6, 6);
      var torchMat = new THREE.MeshStandardMaterial({
        color: 0xff6600,
        emissive: 0xff4400,
        emissiveIntensity: 0.8
      });
      var torch = new THREE.Mesh(torchGeo, torchMat);
      torch.position.set(tbx, y + 4.3, tbz);
      torch.castShadow = false;
      scene.add(torch);
      animatedObjects.push({
        mesh: torch,
        type: 'torch',
        params: { seed: tb * 200 }
      });
    }

    for (var sb = 0; sb < 4; sb++) {
      var sbAngle = (sb / 4) * Math.PI * 2;
      var sbx = z.cx + Math.cos(sbAngle) * 30;
      var sbz = z.cz + Math.sin(sbAngle) * 30;

      var scorePostGeo = new THREE.CylinderGeometry(0.2, 0.25, 6, 8);
      var scorePostMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var scorePost = new THREE.Mesh(scorePostGeo, scorePostMat);
      scorePost.position.set(sbx, y + 3, sbz);
      scorePost.castShadow = false;
      scene.add(scorePost);

      var scoreBoardGeo = new THREE.BoxGeometry(2, 1.5, 0.2);
      var scoreBoardMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
      var scoreBoard = new THREE.Mesh(scoreBoardGeo, scoreBoardMat);
      scoreBoard.position.set(sbx, y + 6.5, sbz);
      scoreBoard.rotation.y = sbAngle + Math.PI;
      scoreBoard.castShadow = false;
      scene.add(scoreBoard);
    }

    for (var te = 0; te < 4; te++) {
      var teAngle = (te / 4) * Math.PI * 2 + Math.PI / 8;
      var tex = z.cx + Math.cos(teAngle) * 10;
      var tez = z.cz + Math.sin(teAngle) * 10;

      var dummyPostGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
      var dummyPostMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var dummyPost = new THREE.Mesh(dummyPostGeo, dummyPostMat);
      dummyPost.position.set(tex, y + 1.25, tez);
      dummyPost.castShadow = false;
      scene.add(dummyPost);

      var dummyHeadGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var dummyHeadMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var dummyHead = new THREE.Mesh(dummyHeadGeo, dummyHeadMat);
      dummyHead.position.set(tex, y + 2.8, tez);
      dummyHead.castShadow = false;
      scene.add(dummyHead);

      for (var ca = -1; ca <= 1; ca += 2) {
        var armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 6);
        var arm = new THREE.Mesh(armGeo, dummyPostMat);
        arm.position.set(tex + ca * 0.4, y + 2.2, tez);
        arm.rotation.z = Math.PI / 2;
        arm.castShadow = false;
        scene.add(arm);
      }
    }

    for (var wr = 0; wr < 2; wr++) {
      var wrx = z.cx + (wr === 0 ? -14 : 14);
      var wrz = z.cz;

      var weaponRackGeo = new THREE.BoxGeometry(3, 0.15, 0.3);
      var weaponRackMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var weaponRack = new THREE.Mesh(weaponRackGeo, weaponRackMat);
      weaponRack.position.set(wrx, y + 1.5, wrz);
      weaponRack.castShadow = false;
      scene.add(weaponRack);

      for (var wp = -1; wp <= 1; wp += 2) {
        var wpGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
        var wpMesh = new THREE.Mesh(wpGeo, weaponRackMat);
        wpMesh.position.set(wrx + wp * 1.2, y + 0.75, wrz);
        wpMesh.castShadow = false;
        scene.add(wpMesh);
      }

      for (var wn = 0; wn < 4; wn++) {
        var weaponGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 6);
        var weaponMat = new THREE.MeshStandardMaterial({ color: 0x8b8b8b });
        var weapon = new THREE.Mesh(weaponGeo, weaponMat);
        weapon.position.set(wrx + (wn - 1.5) * 0.6, y + 0.9, wrz);
        weapon.rotation.z = Math.PI / 6;
        weapon.castShadow = false;
        scene.add(weapon);
      }
    }
  }

  function addTorch(scene, x, baseY, z) {
    var poleGeo = new THREE.CylinderGeometry(0.08, 0.1, 2.5, 6);
    var poleMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
    var pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.set(x, baseY + 1.25, z);
    pole.castShadow = false;
    scene.add(pole);

    var flameGeo = new THREE.SphereGeometry(0.25, 8, 8);
    var flameMat = new THREE.MeshStandardMaterial({
      color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 1
    });
    var flame = new THREE.Mesh(flameGeo, flameMat);
    flame.position.set(x, baseY + 2.7, z);
    flame.castShadow = false;
    scene.add(flame);

    var light = new THREE.PointLight(0xffa500, 0.8, 12);
    light.position.set(x, baseY + 2.7, z);
    scene.add(light);

    animatedObjects.push({
      mesh: flame, type: 'torch',
      params: { seed: x * 100 + z, light: light }
    });
  }

  function createPortals(scene) {
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var dx = ZONES.nexus.cx - zone.cx;
      var dz = ZONES.nexus.cz - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var nx = dx / dist, nz = dz / dist;
      var portalX = zone.cx + nx * zone.radius * 0.7;
      var portalZ = zone.cz + nz * zone.radius * 0.7;
      var portalY = terrainHeight(portalX, portalZ);
      addPortalMesh(scene, portalX, portalY, portalZ, zId);
    }
  }

  function addPortalMesh(scene, x, y, z, targetZone) {
    var archGeo = new THREE.TorusGeometry(2.5, 0.25, 12, 24);
    var archMat = new THREE.MeshStandardMaterial({
      color: 0x00ffff, emissive: 0x008888, emissiveIntensity: 0.6
    });
    var arch = new THREE.Mesh(archGeo, archMat);
    arch.position.set(x, y + 3, z);
    arch.castShadow = false;
    scene.add(arch);

    var innerGeo = new THREE.CircleGeometry(2.2, 16);
    var innerMat = new THREE.MeshStandardMaterial({
      color: 0x66ffff, emissive: 0x44cccc, emissiveIntensity: 0.4,
      transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    var inner = new THREE.Mesh(innerGeo, innerMat);
    inner.position.set(x, y + 3, z);
    inner.castShadow = false;
    scene.add(inner);

    var portalLight = new THREE.PointLight(0x00ffff, 0.6, 15);
    portalLight.position.set(x, y + 3, z);
    scene.add(portalLight);

    var particleRings = [];
    var ringCount = 2;
    var particlesPerRing = 12;

    for (var r = 0; r < ringCount; r++) {
      var ringRadius = 2.8 + r * 0.4;
      var ringParticles = [];

      for (var p = 0; p < particlesPerRing; p++) {
        var particleGeo = new THREE.SphereGeometry(0.08, 6, 6);
        var particleMat = new THREE.MeshStandardMaterial({
          color: 0x88ffff,
          emissive: 0x44aaaa,
          emissiveIntensity: 0.8
        });
        var particle = new THREE.Mesh(particleGeo, particleMat);
        particle.castShadow = false;
        scene.add(particle);

        ringParticles.push({
          mesh: particle,
          angle: (p / particlesPerRing) * Math.PI * 2,
          radius: ringRadius
        });
      }

      particleRings.push({
        particles: ringParticles,
        speed: 0.001 + r * 0.0005,
        direction: r % 2 === 0 ? 1 : -1
      });
    }

    animatedObjects.push({
      mesh: arch, type: 'portal',
      params: {
        speed: 0.8,
        inner: inner,
        particleRings: particleRings,
        centerX: x,
        centerY: y + 3,
        centerZ: z
      }
    });

    arch.userData.targetZone = targetZone;
  }

  function createSky(scene) {
    var skyGeo = new THREE.SphereGeometry(800, 32, 32);
    var skyMat = new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide, fog: false });
    skyDome = new THREE.Mesh(skyGeo, skyMat);
    scene.add(skyDome);

    var sunGeo = new THREE.SphereGeometry(12, 16, 16);
    var sunMat = new THREE.MeshBasicMaterial({ color: 0xfff8e7, fog: false });
    sunMesh = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sunMesh);

    var moonGeo = new THREE.SphereGeometry(8, 16, 16);
    var moonMat = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, fog: false });
    moonMesh = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moonMesh);

    var starGeo = new THREE.BufferGeometry();
    var starPos = [];
    for (var i = 0; i < 1200; i++) {
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.random() * Math.PI;
      var r = 700;
      starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    var starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, fog: false });
    stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    for (var c = 0; c < 30; c++) {
      var cloudGroup = new THREE.Group();
      var numPuffs = 2 + Math.floor(Math.random() * 4);
      for (var p = 0; p < numPuffs; p++) {
        var puffGeo = new THREE.SphereGeometry(8 + Math.random() * 12, 6, 6);
        var puffMat = new THREE.MeshBasicMaterial({
          color: 0xffffff, transparent: true, opacity: 0.35, fog: false
        });
        var puff = new THREE.Mesh(puffGeo, puffMat);
        puff.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 15);
        puff.scale.y = 0.4;
        cloudGroup.add(puff);
      }
      cloudGroup.position.set(
        (Math.random() - 0.5) * 1200,
        180 + Math.random() * 60,
        (Math.random() - 0.5) * 1200
      );
      cloudGroup.userData.driftSpeed = 0.3 + Math.random() * 0.5;
      cloudGroup.userData.driftAngle = Math.random() * Math.PI * 2;
      clouds.push(cloudGroup);
      scene.add(cloudGroup);
    }

    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);
  }

  var SKIN_TONES = [
    0xFFDBAC, 0xF1C27D, 0xE0AC69, 0xC68642,
    0x8D5524, 0x6B3A2A, 0xF5D6C3, 0xD4A574
  ];

  function getSkinTone(seed) {
    var hash = 0;
    if (typeof seed === 'string') {
      for (var i = 0; i < seed.length; i++) {
        hash = ((hash << 5) - hash) + seed.charCodeAt(i);
        hash = hash & hash;
      }
    } else {
      hash = seed || 0;
    }
    return SKIN_TONES[Math.abs(hash) % SKIN_TONES.length];
  }

  function createHumanoidModel(color) {
    var player = new THREE.Group();
    var skinColor = getSkinTone(color || 0x4169e1);
    var skinMat = new THREE.MeshLambertMaterial({ color: skinColor });

    var headGeo = new THREE.SphereGeometry(0.3, 16, 16);
    var head = new THREE.Mesh(headGeo, skinMat.clone());
    head.position.y = 1.5;
    head.castShadow = false;
    player.add(head);

    var eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var pupilGeo = new THREE.SphereGeometry(0.02, 8, 8);
    var pupilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

    var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.1, 0.05, 0.26);
    var leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
    leftPupil.position.set(0, 0, 0.03);
    leftEye.add(leftPupil);
    head.add(leftEye);

    var rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
    rightEye.position.set(0.1, 0.05, 0.26);
    var rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
    rightPupil.position.set(0, 0, 0.03);
    rightEye.add(rightPupil);
    head.add(rightEye);

    var hairHash = (color || 0x4169e1) % 4;
    var hairColors = [0x1a1a1a, 0x4a3000, 0x8B4513, 0xd4a574];
    var hairMat = new THREE.MeshLambertMaterial({ color: hairColors[hairHash] });
    if (hairHash === 0) {
      var buzzGeo = new THREE.SphereGeometry(0.31, 16, 16);
      var buzz = new THREE.Mesh(buzzGeo, hairMat);
      buzz.position.y = 0.02;
      buzz.scale.y = 0.9;
      head.add(buzz);
    } else if (hairHash === 1) {
      var longTopGeo = new THREE.SphereGeometry(0.32, 16, 16);
      var longTop = new THREE.Mesh(longTopGeo, hairMat);
      longTop.position.y = 0.05;
      longTop.scale.y = 0.85;
      head.add(longTop);
      var longBackGeo = new THREE.BoxGeometry(0.4, 0.35, 0.15);
      var longBack = new THREE.Mesh(longBackGeo, hairMat.clone());
      longBack.position.set(0, -0.15, -0.18);
      head.add(longBack);
    } else if (hairHash === 2) {
      var mohawkGeo = new THREE.BoxGeometry(0.08, 0.2, 0.4);
      var mohawk = new THREE.Mesh(mohawkGeo, hairMat);
      mohawk.position.y = 0.25;
      head.add(mohawk);
    } else {
      var bunGeo = new THREE.SphereGeometry(0.12, 8, 8);
      var bun = new THREE.Mesh(bunGeo, hairMat);
      bun.position.set(0, 0.1, -0.28);
      head.add(bun);
    }

    var neckGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.15, 8);
    var neck = new THREE.Mesh(neckGeo, skinMat.clone());
    neck.position.y = 1.28;
    neck.castShadow = false;
    player.add(neck);

    var torsoGeo = new THREE.BoxGeometry(0.5, 0.6, 0.3);
    var torsoMat = new THREE.MeshLambertMaterial({ color: color || 0x4169e1 });
    var torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 0.9;
    torso.castShadow = false;
    player.add(torso);

    var shoulderGeo = new THREE.SphereGeometry(0.1, 8, 8);
    var leftShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    leftShoulder.position.set(-0.35, 1.2, 0);
    leftShoulder.castShadow = false;
    player.add(leftShoulder);

    var rightShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    rightShoulder.position.set(0.35, 1.2, 0);
    rightShoulder.castShadow = false;
    player.add(rightShoulder);

    var armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);

    var leftArm = new THREE.Mesh(armGeo, skinMat.clone());
    leftArm.position.set(-0.35, 1.05, 0);
    leftArm.castShadow = false;
    player.add(leftArm);

    var handGeo = new THREE.SphereGeometry(0.07, 8, 8);
    var leftHand = new THREE.Mesh(handGeo, skinMat.clone());
    leftHand.position.y = -0.3;
    leftArm.add(leftHand);

    var rightArm = new THREE.Mesh(armGeo, skinMat.clone());
    rightArm.position.set(0.35, 1.05, 0);
    rightArm.castShadow = false;
    player.add(rightArm);

    var rightHand = new THREE.Mesh(handGeo, skinMat.clone());
    rightHand.position.y = -0.3;
    rightArm.add(rightHand);

    var legGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
    var legMat = new THREE.MeshLambertMaterial({ color: 0x2f4f4f });

    var leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, 0.35, 0);
    leftLeg.castShadow = false;
    player.add(leftLeg);

    var rightLeg = new THREE.Mesh(legGeo, legMat.clone());
    rightLeg.position.set(0.15, 0.35, 0);
    rightLeg.castShadow = false;
    player.add(rightLeg);

    var footGeo = new THREE.BoxGeometry(0.15, 0.1, 0.25);
    var footMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

    var leftFoot = new THREE.Mesh(footGeo, footMat);
    leftFoot.position.set(-0.15, 0.05, 0.05);
    leftFoot.castShadow = false;
    player.add(leftFoot);

    var rightFoot = new THREE.Mesh(footGeo, footMat.clone());
    rightFoot.position.set(0.15, 0.05, 0.05);
    rightFoot.castShadow = false;
    player.add(rightFoot);

    player.userData.limbs = {
      head: head,
      torso: torso,
      leftArm: leftArm,
      rightArm: rightArm,
      leftLeg: leftLeg,
      rightLeg: rightLeg,
      leftFoot: leftFoot,
      rightFoot: rightFoot
    };

    player.userData.animTime = 0;
    player.userData.prevPosition = new THREE.Vector3();
    player.userData.animState = 'idle'; // 'idle', 'walk', 'run'

    return player;
  }

  function populateEnvironment(scene) {
    var Models = typeof window !== 'undefined' ? window.Models : null;
    if (!Models) {
      console.log('Models module not loaded, skipping environment population');
      return;
    }

    var gz = ZONES.gardens;
    var gardenTreeTypes = ['oak', 'willow', 'cherry', 'cherry'];
    for (var gt = 0; gt < 20; gt++) {
      var ga = hash2D(gt, 100) * Math.PI * 2;
      var gr = 15 + hash2D(gt, 101) * 55;
      var gx = gz.cx + Math.cos(ga) * gr;
      var gzz = gz.cz + Math.sin(ga) * gr;
      var gy = terrainHeight(gx, gzz);
      var treeType = gardenTreeTypes[gt % gardenTreeTypes.length];
      var tree = Models.createTree(treeType, 0.8 + hash2D(gt, 102) * 0.6);
      tree.position.set(gx, gy, gzz);
      tree.rotation.y = hash2D(gt, 103) * Math.PI * 2;
      scene.add(tree);
      animatedObjects.push({ mesh: tree, type: 'tree', params: { speed: 0.3 + hash2D(gt, 104) * 0.3 } });
    }
    for (var gb = 0; gb < 6; gb++) {
      var ba = (gb / 6) * Math.PI * 2 + 0.5;
      var bx = gz.cx + Math.cos(ba) * 25;
      var bz = gz.cz + Math.sin(ba) * 25;
      var by = terrainHeight(bx, bz);
      var bench = Models.createFurniture('bench');
      bench.position.set(bx, by, bz);
      bench.rotation.y = ba + Math.PI / 2;
      scene.add(bench);
    }
    for (var gl = 0; gl < 10; gl++) {
      var la = (gl / 10) * Math.PI * 2;
      var lx = gz.cx + Math.cos(la) * 35;
      var lz = gz.cz + Math.sin(la) * 35;
      var ly = terrainHeight(lx, lz);
      var lantern = Models.createFurniture('lantern');
      lantern.position.set(lx, ly, lz);
      scene.add(lantern);
    }

    var wz = ZONES.wilds;
    var wildTreeTypes = ['oak', 'pine', 'pine', 'dead', 'oak'];
    for (var wt = 0; wt < 40; wt++) {
      var wa = hash2D(wt, 200) * Math.PI * 2;
      var wr = 10 + hash2D(wt, 201) * 70;
      var wx = wz.cx + Math.cos(wa) * wr;
      var wz2 = wz.cz + Math.sin(wa) * wr;
      var wy = terrainHeight(wx, wz2);
      var wildType = wildTreeTypes[wt % wildTreeTypes.length];
      var wtree = Models.createTree(wildType, 0.7 + hash2D(wt, 202) * 0.8);
      wtree.position.set(wx, wy, wz2);
      wtree.rotation.y = hash2D(wt, 203) * Math.PI * 2;
      scene.add(wtree);
      animatedObjects.push({ mesh: wtree, type: 'tree', params: { speed: 0.2 + hash2D(wt, 204) * 0.4 } });
    }
    for (var wb = 0; wb < 15; wb++) {
      var rba = hash2D(wb, 210) * Math.PI * 2;
      var rbr = 8 + hash2D(wb, 211) * 60;
      var rbx = wz.cx + Math.cos(rba) * rbr;
      var rbz = wz.cz + Math.sin(rba) * rbr;
      var rby = terrainHeight(rbx, rbz);
      var rockType = (wb % 5 === 0) ? 'crystal' : 'boulder';
      var rock = Models.createRock(rockType, 0.5 + hash2D(wb, 212) * 1.5);
      rock.position.set(rbx, rby, rbz);
      rock.rotation.y = hash2D(wb, 213) * Math.PI * 2;
      scene.add(rock);
    }

    var nz = ZONES.nexus;
    for (var nt = 0; nt < 8; nt++) {
      var na = (nt / 8) * Math.PI * 2 + Math.PI / 8;
      var nx = nz.cx + Math.cos(na) * 25;
      var nzz = nz.cz + Math.sin(na) * 25;
      var ny = terrainHeight(nx, nzz);
      var ntree = Models.createTree('cherry', 0.7);
      ntree.position.set(nx, ny, nzz);
      scene.add(ntree);
      animatedObjects.push({ mesh: ntree, type: 'tree', params: { speed: 0.3 } });
    }
    for (var nb = 0; nb < 8; nb++) {
      var nba = (nb / 8) * Math.PI * 2;
      var nbx = nz.cx + Math.cos(nba) * 18;
      var nbz = nz.cz + Math.sin(nba) * 18;
      var nby = terrainHeight(nbx, nbz);
      var nbench = Models.createFurniture('bench');
      nbench.position.set(nbx, nby, nbz);
      nbench.rotation.y = nba + Math.PI / 2;
      scene.add(nbench);
    }

    var az = ZONES.agora;
    for (var al = 0; al < 12; al++) {
      var ala = (al / 12) * Math.PI * 2;
      var alx = az.cx + Math.cos(ala) * 22;
      var alz = az.cz + Math.sin(ala) * 22;
      var aly = terrainHeight(alx, alz);
      var alantern = Models.createFurniture('lantern');
      alantern.position.set(alx, aly, alz);
      scene.add(alantern);
    }

    var cz = ZONES.commons;
    for (var ct = 0; ct < 12; ct++) {
      var ca = hash2D(ct, 300) * Math.PI * 2;
      var cr = 25 + hash2D(ct, 301) * 25;
      var cx = cz.cx + Math.cos(ca) * cr;
      var czz = cz.cz + Math.sin(ca) * cr;
      var cy = terrainHeight(cx, czz);
      var ctree = Models.createTree('oak', 0.6 + hash2D(ct, 302) * 0.5);
      ctree.position.set(cx, cy, czz);
      ctree.rotation.y = hash2D(ct, 303) * Math.PI * 2;
      scene.add(ctree);
      animatedObjects.push({ mesh: ctree, type: 'tree', params: { speed: 0.3 } });
    }

    var sz = ZONES.studio;
    for (var st = 0; st < 8; st++) {
      var sa = hash2D(st, 400) * Math.PI * 2;
      var sr = 20 + hash2D(st, 401) * 30;
      var sx = sz.cx + Math.cos(sa) * sr;
      var szz = sz.cz + Math.sin(sa) * sr;
      var sy = terrainHeight(sx, szz);
      var srock = Models.createRock('crystal', 0.8 + hash2D(st, 402) * 0.8);
      srock.position.set(sx, sy, szz);
      scene.add(srock);
    }

    var atz = ZONES.athenaeum;
    for (var at = 0; at < 10; at++) {
      var ata = hash2D(at, 500) * Math.PI * 2;
      var atr = 20 + hash2D(at, 501) * 35;
      var atx = atz.cx + Math.cos(ata) * atr;
      var atzz = atz.cz + Math.sin(ata) * atr;
      var aty = terrainHeight(atx, atzz);
      var attree = Models.createTree('pine', 0.7 + hash2D(at, 502) * 0.4);
      attree.position.set(atx, aty, atzz);
      scene.add(attree);
      animatedObjects.push({ mesh: attree, type: 'tree', params: { speed: 0.25 } });
    }

    var arz = ZONES.arena;
    for (var ar = 0; ar < 6; ar++) {
      var ara = hash2D(ar, 600) * Math.PI * 2;
      var arr = 30 + hash2D(ar, 601) * 15;
      var arx = arz.cx + Math.cos(ara) * arr;
      var arzz = arz.cz + Math.sin(ara) * arr;
      var ary = terrainHeight(arx, arzz);
      var arrock = Models.createRock('boulder', 0.6 + hash2D(ar, 602) * 1.0);
      arrock.position.set(arx, ary, arzz);
      arrock.rotation.y = hash2D(ar, 603) * Math.PI;
      scene.add(arrock);
    }

    if (Models.createCreature) {
      for (var bf = 0; bf < 8; bf++) {
        var bfa = hash2D(bf, 700) * Math.PI * 2;
        var bfr = 10 + hash2D(bf, 701) * 50;
        var bfx = gz.cx + Math.cos(bfa) * bfr;
        var bfz = gz.cz + Math.sin(bfa) * bfr;
        var bfy = terrainHeight(bfx, bfz) + 1.5 + hash2D(bf, 702) * 2;
        var butterfly = Models.createCreature('butterfly');
        butterfly.position.set(bfx, bfy, bfz);
        scene.add(butterfly);
        animatedObjects.push({ mesh: butterfly, type: 'creature', params: { speed: 1 + hash2D(bf, 703) } });
      }
      for (var bi = 0; bi < 6; bi++) {
        var bia = hash2D(bi, 710) * Math.PI * 2;
        var bir = 10 + hash2D(bi, 711) * 60;
        var bix = wz.cx + Math.cos(bia) * bir;
        var biz = wz.cz + Math.sin(bia) * bir;
        var biy = terrainHeight(bix, biz) + 5 + hash2D(bi, 712) * 5;
        var bird = Models.createCreature('bird');
        bird.position.set(bix, biy, biz);
        scene.add(bird);
        animatedObjects.push({ mesh: bird, type: 'creature', params: { speed: 0.5 + hash2D(bi, 713) * 0.5 } });
      }
    }

    if (Models.createLandmark) {
      var fountain = Models.createLandmark('fountain', 1.2);
      fountain.position.set(nz.cx, terrainHeight(nz.cx, nz.cz), nz.cz);
      scene.add(fountain);
      animatedObjects.push({ mesh: fountain, type: 'landmark', params: {} });

      for (var no = 0; no < 4; no++) {
        var noa = (no / 4) * Math.PI * 2;
        var nox = nz.cx + Math.cos(noa) * 35;
        var noz = nz.cz + Math.sin(noa) * 35;
        var obelisk = Models.createLandmark('obelisk', 1.0);
        obelisk.position.set(nox, terrainHeight(nox, noz), noz);
        scene.add(obelisk);
        animatedObjects.push({ mesh: obelisk, type: 'landmark', params: {} });
      }

      for (var ns = 0; ns < 2; ns++) {
        var nsa = (ns / 2) * Math.PI * 2 + Math.PI / 4;
        var nsx = nz.cx + Math.cos(nsa) * 28;
        var nsz = nz.cz + Math.sin(nsa) * 28;
        var signpost = Models.createLandmark('signpost', 1.0);
        signpost.position.set(nsx, terrainHeight(nsx, nsz), nsz);
        signpost.rotation.y = nsa;
        scene.add(signpost);
      }

      var riftPortal = new THREE.Group();
      var archMat = new THREE.MeshStandardMaterial({ color: 0x8855ff, emissive: 0x4422aa, emissiveIntensity: 0.5 });
      var pillarGeo = new THREE.BoxBufferGeometry(0.6, 6, 0.6);
      var lPillar = new THREE.Mesh(pillarGeo, archMat);
      lPillar.position.set(-2, 3, 0);
      riftPortal.add(lPillar);
      var rPillar = new THREE.Mesh(pillarGeo, archMat);
      rPillar.position.set(2, 3, 0);
      riftPortal.add(rPillar);
      var beamGeo = new THREE.BoxBufferGeometry(4.6, 0.6, 0.6);
      var topBeam = new THREE.Mesh(beamGeo, archMat);
      topBeam.position.set(0, 6.3, 0);
      riftPortal.add(topBeam);
      var shimmerMat = new THREE.MeshBasicMaterial({ color: 0xaa77ff, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
      var shimmerGeo = new THREE.PlaneBufferGeometry(3.4, 5.6);
      var shimmer = new THREE.Mesh(shimmerGeo, shimmerMat);
      shimmer.position.set(0, 3.1, 0);
      riftPortal.add(shimmer);
      var rpx = nz.cx + 20;
      var rpz = nz.cz - 20;
      riftPortal.position.set(rpx, terrainHeight(rpx, rpz), rpz);
      scene.add(riftPortal);
      animatedObjects.push({ mesh: riftPortal, type: 'landmark', params: { shimmer: shimmer } });

      var gazebo = Models.createLandmark('gazebo', 1.0);
      gazebo.position.set(gz.cx + 10, terrainHeight(gz.cx + 10, gz.cz + 10), gz.cz + 10);
      scene.add(gazebo);

      for (var gc = 0; gc < 4; gc++) {
        var gca = (gc / 4) * Math.PI * 2 + Math.PI / 8;
        var gcx = gz.cx + Math.cos(gca) * 40;
        var gcz = gz.cz + Math.sin(gca) * 40;
        var campfire = Models.createLandmark('campfire', 1.0);
        campfire.position.set(gcx, terrainHeight(gcx, gcz), gcz);
        scene.add(campfire);
        animatedObjects.push({ mesh: campfire, type: 'landmark', params: {} });
      }

      for (var gf = 0; gf < 6; gf++) {
        var gfa = hash2D(gf, 720) * Math.PI * 2;
        var gfr = 20 + hash2D(gf, 721) * 35;
        var gfx = gz.cx + Math.cos(gfa) * gfr;
        var gfz = gz.cz + Math.sin(gfa) * gfr;
        var flowerBed = Models.createResourceNode('flower_bed', 1.0);
        flowerBed.position.set(gfx, terrainHeight(gfx, gfz), gfz);
        flowerBed.rotation.y = hash2D(gf, 722) * Math.PI * 2;
        scene.add(flowerBed);
      }

      for (var gh = 0; gh < 4; gh++) {
        var gha = hash2D(gh, 730) * Math.PI * 2;
        var ghr = 25 + hash2D(gh, 731) * 30;
        var ghx = gz.cx + Math.cos(gha) * ghr;
        var ghz = gz.cz + Math.sin(gha) * ghr;
        var herbPatch = Models.createResourceNode('herb_patch', 1.0);
        herbPatch.position.set(ghx, terrainHeight(ghx, ghz), ghz);
        herbPatch.rotation.y = hash2D(gh, 732) * Math.PI * 2;
        scene.add(herbPatch);
      }

      for (var wc = 0; wc < 2; wc++) {
        var wca = hash2D(wc, 740) * Math.PI * 2;
        var wcr = 30 + hash2D(wc, 741) * 25;
        var wcx = wz.cx + Math.cos(wca) * wcr;
        var wcz = wz.cz + Math.sin(wca) * wcr;
        var wcampfire = Models.createLandmark('campfire', 1.0);
        wcampfire.position.set(wcx, terrainHeight(wcx, wcz), wcz);
        scene.add(wcampfire);
        animatedObjects.push({ mesh: wcampfire, type: 'landmark', params: {} });
      }

      for (var ws = 0; ws < 3; ws++) {
        var wsa = hash2D(ws, 750) * Math.PI * 2;
        var wsr = 35 + hash2D(ws, 751) * 30;
        var wsx = wz.cx + Math.cos(wsa) * wsr;
        var wsz = wz.cz + Math.sin(wsa) * wsr;
        var wsignpost = Models.createLandmark('signpost', 1.0);
        wsignpost.position.set(wsx, terrainHeight(wsx, wsz), wsz);
        wsignpost.rotation.y = wsa;
        scene.add(wsignpost);
      }

      for (var wo = 0; wo < 8; wo++) {
        var woa = hash2D(wo, 760) * Math.PI * 2;
        var wor = 15 + hash2D(wo, 761) * 50;
        var wox = wz.cx + Math.cos(woa) * wor;
        var woz = wz.cz + Math.sin(woa) * wor;
        var oreVein = Models.createResourceNode('ore_vein', 0.8 + hash2D(wo, 762) * 0.5);
        oreVein.position.set(wox, terrainHeight(wox, woz), woz);
        oreVein.rotation.y = hash2D(wo, 763) * Math.PI * 2;
        scene.add(oreVein);
      }

      for (var ww = 0; ww < 4; ww++) {
        var wwa = hash2D(ww, 770) * Math.PI * 2;
        var wwr = 20 + hash2D(ww, 771) * 40;
        var wwx = wz.cx + Math.cos(wwa) * wwr;
        var wwz = wz.cz + Math.sin(wwa) * wwr;
        var woodPile = Models.createResourceNode('wood_pile', 1.0);
        woodPile.position.set(wwx, terrainHeight(wwx, wwz), wwz);
        woodPile.rotation.y = hash2D(ww, 772) * Math.PI * 2;
        scene.add(woodPile);
      }

      for (var ats = 0; ats < 2; ats++) {
        var atsa = (ats / 2) * Math.PI * 2;
        var atsx = atz.cx + Math.cos(atsa) * 25;
        var atsz = atz.cz + Math.sin(atsa) * 25;
        var statue = Models.createLandmark('statue', 1.1);
        statue.position.set(atsx, terrainHeight(atsx, atsz), atsz);
        statue.rotation.y = atsa + Math.PI;
        scene.add(statue);
      }

      for (var ato = 0; ato < 4; ato++) {
        var atoa = (ato / 4) * Math.PI * 2 + Math.PI / 8;
        var atox = atz.cx + Math.cos(atoa) * 35;
        var atoz = atz.cz + Math.sin(atoa) * 35;
        var atobelisk = Models.createLandmark('obelisk', 0.9);
        atobelisk.position.set(atox, terrainHeight(atox, atoz), atoz);
        scene.add(atobelisk);
        animatedObjects.push({ mesh: atobelisk, type: 'landmark', params: {} });
      }

      for (var sc = 0; sc < 3; sc++) {
        var sca = hash2D(sc, 780) * Math.PI * 2;
        var scr = 25 + hash2D(sc, 781) * 20;
        var scx = sz.cx + Math.cos(sca) * scr;
        var scz = sz.cz + Math.sin(sca) * scr;
        var crystalCluster = Models.createResourceNode('crystal_cluster', 0.9 + hash2D(sc, 782) * 0.4);
        crystalCluster.position.set(scx, terrainHeight(scx, scz), scz);
        crystalCluster.rotation.y = hash2D(sc, 783) * Math.PI * 2;
        scene.add(crystalCluster);
      }

      var sgazebo = Models.createLandmark('gazebo', 0.9);
      sgazebo.position.set(sz.cx + 15, terrainHeight(sz.cx + 15, sz.cz - 15), sz.cz - 15);
      scene.add(sgazebo);

      for (var ags = 0; ags < 6; ags++) {
        var agsa = (ags / 6) * Math.PI * 2;
        var agsx = az.cx + Math.cos(agsa) * 30;
        var agsz = az.cz + Math.sin(agsa) * 30;
        var agsignpost = Models.createLandmark('signpost', 1.0);
        agsignpost.position.set(agsx, terrainHeight(agsx, agsz), agsz);
        agsignpost.rotation.y = agsa;
        scene.add(agsignpost);
      }

      for (var agc = 0; agc < 2; agc++) {
        var agca = (agc / 2) * Math.PI * 2 + Math.PI / 4;
        var agcx = az.cx + Math.cos(agca) * 20;
        var agcz = az.cz + Math.sin(agca) * 20;
        var agcampfire = Models.createLandmark('campfire', 1.0);
        agcampfire.position.set(agcx, terrainHeight(agcx, agcz), agcz);
        scene.add(agcampfire);
        animatedObjects.push({ mesh: agcampfire, type: 'landmark', params: {} });
      }

      for (var agf = 0; agf < 3; agf++) {
        var agfa = hash2D(agf, 790) * Math.PI * 2;
        var agfr = 15 + hash2D(agf, 791) * 20;
        var agfx = az.cx + Math.cos(agfa) * agfr;
        var agfz = az.cz + Math.sin(agfa) * agfr;
        var agflowerBed = Models.createResourceNode('flower_bed', 0.9);
        agflowerBed.position.set(agfx, terrainHeight(agfx, agfz), agfz);
        agflowerBed.rotation.y = hash2D(agf, 792) * Math.PI * 2;
        scene.add(agflowerBed);
      }

      for (var cg = 0; cg < 2; cg++) {
        var cga = (cg / 2) * Math.PI * 2 + Math.PI / 3;
        var cgx = cz.cx + Math.cos(cga) * 30;
        var cgz = cz.cz + Math.sin(cga) * 30;
        var cgazebo = Models.createLandmark('gazebo', 0.95);
        cgazebo.position.set(cgx, terrainHeight(cgx, cgz), cgz);
        scene.add(cgazebo);
      }

      for (var cw = 0; cw < 4; cw++) {
        var cwa = hash2D(cw, 800) * Math.PI * 2;
        var cwr = 20 + hash2D(cw, 801) * 25;
        var cwx = cz.cx + Math.cos(cwa) * cwr;
        var cwz = cz.cz + Math.sin(cwa) * cwr;
        var cwoodPile = Models.createResourceNode('wood_pile', 1.0);
        cwoodPile.position.set(cwx, terrainHeight(cwx, cwz), cwz);
        cwoodPile.rotation.y = hash2D(cw, 802) * Math.PI * 2;
        scene.add(cwoodPile);
      }

      for (var co = 0; co < 6; co++) {
        var coa = hash2D(co, 810) * Math.PI * 2;
        var cor = 18 + hash2D(co, 811) * 28;
        var cox = cz.cx + Math.cos(coa) * cor;
        var coz = cz.cz + Math.sin(coa) * cor;
        var coreVein = Models.createResourceNode('ore_vein', 0.9 + hash2D(co, 812) * 0.4);
        coreVein.position.set(cox, terrainHeight(cox, coz), coz);
        coreVein.rotation.y = hash2D(co, 813) * Math.PI * 2;
        scene.add(coreVein);
      }

      for (var ars = 0; ars < 2; ars++) {
        var arsa = (ars / 2) * Math.PI * 2 + Math.PI / 2;
        var arsx = arz.cx + Math.cos(arsa) * 28;
        var arsz = arz.cz + Math.sin(arsa) * 28;
        var arstatue = Models.createLandmark('statue', 1.2);
        arstatue.position.set(arsx, terrainHeight(arsx, arsz), arsz);
        arstatue.rotation.y = arsa + Math.PI;
        scene.add(arstatue);
      }

      for (var arc = 0; arc < 4; arc++) {
        var arca = (arc / 4) * Math.PI * 2;
        var arcx = arz.cx + Math.cos(arca) * 32;
        var arcz = arz.cz + Math.sin(arca) * 32;
        var arcampfire = Models.createLandmark('campfire', 1.0);
        arcampfire.position.set(arcx, terrainHeight(arcx, arcz), arcz);
        scene.add(arcampfire);
        animatedObjects.push({ mesh: arcampfire, type: 'landmark', params: {} });
      }
    }

    if (Models.createWildlife) {
      for (var gr = 0; gr < 6; gr++) {
        var gra = hash2D(gr, 820) * Math.PI * 2;
        var grr = 15 + hash2D(gr, 821) * 40;
        var grx = gz.cx + Math.cos(gra) * grr;
        var grz = gz.cz + Math.sin(gra) * grr;
        var gry = terrainHeight(grx, grz);
        var rabbit = Models.createWildlife('rabbit');
        rabbit.position.set(grx, gry, grz);
        rabbit.rotation.y = hash2D(gr, 822) * Math.PI * 2;
        scene.add(rabbit);
        animatedObjects.push({ mesh: rabbit, type: 'creature', params: { speed: 0.8 + hash2D(gr, 823) * 0.4 } });
      }

      for (var gfl = 0; gfl < 10; gfl++) {
        var gfla = hash2D(gfl, 830) * Math.PI * 2;
        var gflr = 10 + hash2D(gfl, 831) * 50;
        var gflx = gz.cx + Math.cos(gfla) * gflr;
        var gflz = gz.cz + Math.sin(gfla) * gflr;
        var gfly = terrainHeight(gflx, gflz) + 1.5 + hash2D(gfl, 832) * 1.5;
        var firefly = Models.createWildlife('firefly');
        firefly.position.set(gflx, gfly, gflz);
        scene.add(firefly);
        animatedObjects.push({ mesh: firefly, type: 'creature', params: { speed: 1.2 + hash2D(gfl, 833) * 0.6 } });
      }

      for (var wd = 0; wd < 4; wd++) {
        var wda = hash2D(wd, 840) * Math.PI * 2;
        var wdr = 25 + hash2D(wd, 841) * 45;
        var wdx = wz.cx + Math.cos(wda) * wdr;
        var wdz = wz.cz + Math.sin(wda) * wdr;
        var wdy = terrainHeight(wdx, wdz);
        var deer = Models.createWildlife('deer');
        deer.position.set(wdx, wdy, wdz);
        deer.rotation.y = hash2D(wd, 842) * Math.PI * 2;
        scene.add(deer);
        animatedObjects.push({ mesh: deer, type: 'creature', params: { speed: 0.6 + hash2D(wd, 843) * 0.3 } });
      }

      for (var wr = 0; wr < 6; wr++) {
        var wra = hash2D(wr, 850) * Math.PI * 2;
        var wrr = 20 + hash2D(wr, 851) * 50;
        var wrx = wz.cx + Math.cos(wra) * wrr;
        var wrz = wz.cz + Math.sin(wra) * wrr;
        var wry = terrainHeight(wrx, wrz);
        var wrabbit = Models.createWildlife('rabbit');
        wrabbit.position.set(wrx, wry, wrz);
        wrabbit.rotation.y = hash2D(wr, 852) * Math.PI * 2;
        scene.add(wrabbit);
        animatedObjects.push({ mesh: wrabbit, type: 'creature', params: { speed: 0.8 + hash2D(wr, 853) * 0.4 } });
      }

      for (var wfl = 0; wfl < 15; wfl++) {
        var wfla = hash2D(wfl, 860) * Math.PI * 2;
        var wflr = 15 + hash2D(wfl, 861) * 60;
        var wflx = wz.cx + Math.cos(wfla) * wflr;
        var wflz = wz.cz + Math.sin(wfla) * wflr;
        var wfly = terrainHeight(wflx, wflz) + 1.5 + hash2D(wfl, 862) * 1.5;
        var wfirefly = Models.createWildlife('firefly');
        wfirefly.position.set(wflx, wfly, wflz);
        scene.add(wfirefly);
        animatedObjects.push({ mesh: wfirefly, type: 'creature', params: { speed: 1.2 + hash2D(wfl, 863) * 0.6 } });
      }

      for (var wf = 0; wf < 4; wf++) {
        var wfa = hash2D(wf, 870) * Math.PI * 2;
        var wfr = 30 + hash2D(wf, 871) * 35;
        var wfx = wz.cx + Math.cos(wfa) * wfr;
        var wfz = wz.cz + Math.sin(wfa) * wfr;
        var wfy = terrainHeight(wfx, wfz);
        var frog = Models.createWildlife('frog');
        frog.position.set(wfx, wfy, wfz);
        frog.rotation.y = hash2D(wf, 872) * Math.PI * 2;
        scene.add(frog);
        animatedObjects.push({ mesh: frog, type: 'creature', params: { speed: 0.5 + hash2D(wf, 873) * 0.3 } });
      }

      for (var cr = 0; cr < 3; cr++) {
        var cra = hash2D(cr, 880) * Math.PI * 2;
        var crr = 20 + hash2D(cr, 881) * 25;
        var crx = cz.cx + Math.cos(cra) * crr;
        var crz = cz.cz + Math.sin(cra) * crr;
        var cry = terrainHeight(crx, crz);
        var crabbit = Models.createWildlife('rabbit');
        crabbit.position.set(crx, cry, crz);
        crabbit.rotation.y = hash2D(cr, 882) * Math.PI * 2;
        scene.add(crabbit);
        animatedObjects.push({ mesh: crabbit, type: 'creature', params: { speed: 0.8 + hash2D(cr, 883) * 0.4 } });
      }

      for (var nfl = 0; nfl < 4; nfl++) {
        var nfla = hash2D(nfl, 890) * Math.PI * 2;
        var nflr = 15 + hash2D(nfl, 891) * 20;
        var nflx = nz.cx + Math.cos(nfla) * nflr;
        var nflz = nz.cz + Math.sin(nfla) * nflr;
        var nfly = terrainHeight(nflx, nflz) + 1.5 + hash2D(nfl, 892) * 1.5;
        var nfirefly = Models.createWildlife('firefly');
        nfirefly.position.set(nflx, nfly, nflz);
        scene.add(nfirefly);
        animatedObjects.push({ mesh: nfirefly, type: 'creature', params: { speed: 1.2 + hash2D(nfl, 893) * 0.6 } });
      }
    }

    if (Models.createGrassPatch) {
      var naturalZones = [gz, wz, cz, nz];
      for (var nzi = 0; nzi < naturalZones.length; nzi++) {
        var nzInfo = naturalZones[nzi];
        var grassCount = nzi === 1 ? 30 : 15; // More in wilds
        for (var gp = 0; gp < grassCount; gp++) {
          var gpa = hash2D(gp + nzi * 100, 900) * Math.PI * 2;
          var gpr = 8 + hash2D(gp + nzi * 100, 901) * 55;
          var gpx = nzInfo.cx + Math.cos(gpa) * gpr;
          var gpz = nzInfo.cz + Math.sin(gpa) * gpr;
          var grassPatch = Models.createGrassPatch(0.8 + hash2D(gp + nzi * 100, 902) * 0.6);
          grassPatch.position.set(gpx, terrainHeight(gpx, gpz), gpz);
          grassPatch.rotation.y = hash2D(gp + nzi * 100, 903) * Math.PI * 2;
          scene.add(grassPatch);
        }
      }
    }

    if (Models.createBush) {
      var bushTypes = ['flowering', 'flowering', 'green'];
      for (var gb = 0; gb < 8; gb++) {
        var gba = hash2D(gb, 910) * Math.PI * 2;
        var gbr = 12 + hash2D(gb, 911) * 40;
        var gbx = gz.cx + Math.cos(gba) * gbr;
        var gbz = gz.cz + Math.sin(gba) * gbr;
        var gardenBush = Models.createBush(bushTypes[gb % 3], 0.8 + hash2D(gb, 912) * 0.4);
        gardenBush.position.set(gbx, terrainHeight(gbx, gbz), gbz);
        scene.add(gardenBush);
      }

      for (var wb = 0; wb < 10; wb++) {
        var wba = hash2D(wb, 920) * Math.PI * 2;
        var wbr = 15 + hash2D(wb, 921) * 50;
        var wbx = wz.cx + Math.cos(wba) * wbr;
        var wbz = wz.cz + Math.sin(wba) * wbr;
        var wildBush = Models.createBush(wb % 3 === 0 ? 'berry' : 'green', 0.7 + hash2D(wb, 922) * 0.5);
        wildBush.position.set(wbx, terrainHeight(wbx, wbz), wbz);
        scene.add(wildBush);
      }
    }

    if (Models.createMushroom) {
      var mushroomTypes = ['red', 'brown', 'white', 'purple', 'glowing'];
      for (var wm = 0; wm < 8; wm++) {
        var wma = hash2D(wm, 930) * Math.PI * 2;
        var wmr = 20 + hash2D(wm, 931) * 45;
        var wmx = wz.cx + Math.cos(wma) * wmr;
        var wmz = wz.cz + Math.sin(wma) * wmr;
        var mushroom = Models.createMushroom(mushroomTypes[wm % 5], 0.8 + hash2D(wm, 932) * 0.5);
        mushroom.position.set(wmx, terrainHeight(wmx, wmz), wmz);
        mushroom.rotation.y = hash2D(wm, 933) * Math.PI * 2;
        scene.add(mushroom);
      }

      for (var am = 0; am < 5; am++) {
        var ama = hash2D(am, 940) * Math.PI * 2;
        var amr = 15 + hash2D(am, 941) * 25;
        var amx = atz.cx + Math.cos(ama) * amr;
        var amz = atz.cz + Math.sin(ama) * amr;
        var glowMush = Models.createMushroom('glowing', 0.6 + hash2D(am, 942) * 0.4);
        glowMush.position.set(amx, terrainHeight(amx, amz), amz);
        scene.add(glowMush);
      }
    }

    if (Models.createFallenLog) {
      for (var fl = 0; fl < 5; fl++) {
        var fla = hash2D(fl, 950) * Math.PI * 2;
        var flr = 20 + hash2D(fl, 951) * 40;
        var flx = wz.cx + Math.cos(fla) * flr;
        var flz = wz.cz + Math.sin(fla) * flr;
        var fallenLog = Models.createFallenLog(0.8 + hash2D(fl, 952) * 0.4);
        fallenLog.position.set(flx, terrainHeight(flx, flz), flz);
        fallenLog.rotation.y = hash2D(fl, 953) * Math.PI * 2;
        scene.add(fallenLog);
      }

      for (var cl = 0; cl < 3; cl++) {
        var cla = hash2D(cl, 960) * Math.PI * 2;
        var clr = 18 + hash2D(cl, 961) * 25;
        var clx = cz.cx + Math.cos(cla) * clr;
        var clz = cz.cz + Math.sin(cla) * clr;
        var commonLog = Models.createFallenLog(0.7 + hash2D(cl, 962) * 0.3);
        commonLog.position.set(clx, terrainHeight(clx, clz), clz);
        commonLog.rotation.y = hash2D(cl, 963) * Math.PI * 2;
        scene.add(commonLog);
      }
    }

    if (Models.createRuinWall) {
      var arenaZone = ZONES.arena;
      for (var rw = 0; rw < 4; rw++) {
        var rwa = hash2D(rw, 1000) * Math.PI * 2;
        var rwr = 15 + hash2D(rw, 1001) * 25;
        var rwx = arenaZone.cx + Math.cos(rwa) * rwr;
        var rwz = arenaZone.cz + Math.sin(rwa) * rwr;
        var ruinWall = Models.createRuinWall(0.8 + hash2D(rw, 1002) * 0.4);
        ruinWall.position.set(rwx, terrainHeight(rwx, rwz), rwz);
        ruinWall.rotation.y = rwa + Math.PI / 2;
        scene.add(ruinWall);
      }
    }

    if (Models.createColumnRow) {
      var athenZone = ZONES.athenaeum;
      for (var cr = 0; cr < 3; cr++) {
        var cra = hash2D(cr, 1010) * Math.PI * 2;
        var crr = 10 + hash2D(cr, 1011) * 20;
        var crx = athenZone.cx + Math.cos(cra) * crr;
        var crz = athenZone.cz + Math.sin(cra) * crr;
        var columns = Models.createColumnRow(4 + Math.floor(hash2D(cr, 1012) * 3), 3.5, 2, 0.9);
        columns.position.set(crx, terrainHeight(crx, crz), crz);
        columns.rotation.y = cra;
        scene.add(columns);
      }
    }

    if (Models.createAmphitheater) {
      var amphitheater = Models.createAmphitheater(1.2);
      amphitheater.position.set(arenaZone.cx, terrainHeight(arenaZone.cx, arenaZone.cz), arenaZone.cz);
      scene.add(amphitheater);
    }

    if (Models.createWishingWell) {
      var gardenZone = ZONES.gardens;
      var well = Models.createWishingWell(1.0);
      well.position.set(gardenZone.cx + 15, terrainHeight(gardenZone.cx + 15, gardenZone.cz - 10), gardenZone.cz - 10);
      scene.add(well);

      var commonsZone = ZONES.commons;
      var well2 = Models.createWishingWell(0.9);
      well2.position.set(commonsZone.cx - 8, terrainHeight(commonsZone.cx - 8, commonsZone.cz + 5), commonsZone.cz + 5);
      scene.add(well2);
    }

    if (Models.createBookshelf) {
      for (var bs = 0; bs < 6; bs++) {
        var bsa = hash2D(bs, 1030) * Math.PI * 2;
        var bsr = 8 + hash2D(bs, 1031) * 12;
        var bsx = athenZone.cx + Math.cos(bsa) * bsr;
        var bsz = athenZone.cz + Math.sin(bsa) * bsr;
        var bookshelf = Models.createBookshelf(1.0);
        bookshelf.position.set(bsx, terrainHeight(bsx, bsz), bsz);
        bookshelf.rotation.y = bsa + Math.PI;
        scene.add(bookshelf);
      }
    }

    if (Models.createTorch) {
      var torchZones = ['nexus', 'athenaeum', 'arena', 'agora'];
      for (var tz = 0; tz < torchZones.length; tz++) {
        var torchZone = ZONES[torchZones[tz]];
        for (var tc = 0; tc < 4; tc++) {
          var tca = hash2D(tc + tz * 10, 1040) * Math.PI * 2;
          var tcr = 8 + hash2D(tc + tz * 10, 1041) * 15;
          var tcx = torchZone.cx + Math.cos(tca) * tcr;
          var tcz = torchZone.cz + Math.sin(tca) * tcr;
          var torch = Models.createTorch(1.0);
          torch.position.set(tcx, terrainHeight(tcx, tcz), tcz);
          torch.rotation.y = tca;
          scene.add(torch);
          animatedObjects.push(torch);
        }
      }
    }

    if (Models.createBridge) {
      var bridgeGC = Models.createBridge(10, 0.9);
      var bgcx = (gardenZone.cx + commonsZone.cx) / 2;
      var bgcz = (gardenZone.cz + commonsZone.cz) / 2;
      bridgeGC.position.set(bgcx, terrainHeight(bgcx, bgcz) - 0.5, bgcz);
      bridgeGC.rotation.y = Math.atan2(commonsZone.cz - gardenZone.cz, commonsZone.cx - gardenZone.cx);
      scene.add(bridgeGC);

      var bridgeNA = Models.createBridge(12, 0.9);
      var bnax = (ZONES.nexus.cx + athenZone.cx) / 2;
      var bnaz = (ZONES.nexus.cz + athenZone.cz) / 2;
      bridgeNA.position.set(bnax, terrainHeight(bnax, bnaz) - 0.5, bnaz);
      bridgeNA.rotation.y = Math.atan2(athenZone.cz - ZONES.nexus.cz, athenZone.cx - ZONES.nexus.cx);
      scene.add(bridgeNA);
    }

    if (Models.createGardenArch) {
      for (var ga = 0; ga < 3; ga++) {
        var gaa = hash2D(ga, 1060) * Math.PI * 2;
        var gar = gardenZone.radius * 0.6;
        var gax = gardenZone.cx + Math.cos(gaa) * gar;
        var gaz = gardenZone.cz + Math.sin(gaa) * gar;
        var gardenArch = Models.createGardenArch(1.1);
        gardenArch.position.set(gax, terrainHeight(gax, gaz), gaz);
        gardenArch.rotation.y = gaa;
        scene.add(gardenArch);
        animatedObjects.push(gardenArch);
      }
    }

    if (Models.createBannerPole) {
      var bannerColors = [0xcc0000, 0x0000cc, 0x00cc00, 0xcc9900, 0x9900cc, 0x009999];
      var bannerZones = ['agora', 'arena', 'nexus'];
      for (var bz = 0; bz < bannerZones.length; bz++) {
        var bannerZone = ZONES[bannerZones[bz]];
        var bannerCount = bz === 0 ? 6 : 4;
        for (var bp = 0; bp < bannerCount; bp++) {
          var bpa = hash2D(bp + bz * 20, 1070) * Math.PI * 2;
          var bpr = 10 + hash2D(bp + bz * 20, 1071) * 20;
          var bpx = bannerZone.cx + Math.cos(bpa) * bpr;
          var bpz = bannerZone.cz + Math.sin(bpa) * bpr;
          var bannerColor = bannerColors[(bp + bz * 3) % bannerColors.length];
          var banner = Models.createBannerPole(bannerColor, 0.9);
          banner.position.set(bpx, terrainHeight(bpx, bpz), bpz);
          scene.add(banner);
          animatedObjects.push(banner);
        }
      }
    }

    console.log('Environment populated with trees, rocks, furniture, creatures, ground cover, and architecture');
  }

  function initScene(container) {
    if (typeof THREE === 'undefined') {
      console.warn('THREE.js not available');
      return null;
    }

    var scene = new THREE.Scene();
    createSky(scene);

    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);

    var w = container.clientWidth || window.innerWidth;
    var h = container.clientHeight || window.innerHeight;

    var camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 1000);
    camera.position.set(0, 15, 25);
    camera.lookAt(0, 0, 0);

    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    renderer.shadowMap.enabled = false;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    container.appendChild(renderer.domElement);

    window.addEventListener('resize', function() {
      var rw = container.clientWidth || window.innerWidth;
      var rh = container.clientHeight || window.innerHeight;
      camera.aspect = rw / rh;
      camera.updateProjectionMatrix();
      renderer.setSize(rw, rh);
    });

    var ambientLight = new THREE.HemisphereLight(0x87ceeb, 0xd2b48c, 0.6);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xfff8e7, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = false;
    scene.add(directionalLight);

    createZoneStructures(scene);

    createZoneNightLights(scene);

    populateEnvironment(scene);

    var ctx = {
      scene: scene,
      camera: camera,
      renderer: renderer,
      ambientLight: ambientLight,
      directionalLight: directionalLight
    };
    updateChunks(ctx, 0, 0);

    return ctx;
  }

  function loadZone(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene || !sceneCtx.camera) return;
    var zone = ZONES[zoneId];
    if (!zone) return;
    activeZone = zoneId;
    sceneCtx.camera.position.set(zone.cx, zone.baseHeight + 15, zone.cz + 25);
    sceneCtx.camera.lookAt(zone.cx, zone.baseHeight, zone.cz);
    updateChunks(sceneCtx, zone.cx, zone.cz);
  }

  function addPlayer(sceneCtx, playerId, position) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var x = position.x || 0, z = position.z || 0;
    var y = terrainHeight(x, z);
    var mesh = createHumanoidModel();
    mesh.position.set(x, y, z);

    mesh.userData.prevPosition.set(x, y, z);

    sceneCtx.scene.add(mesh);

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    context.fillStyle = 'rgba(0, 0, 0, 0.6)';
    context.fillRect(0, 0, 256, 64);
    context.font = 'Bold 22px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.fillText(playerId, 128, 40);
    var texture = new THREE.CanvasTexture(canvas);
    var labelMat = new THREE.SpriteMaterial({ map: texture });
    var label = new THREE.Sprite(labelMat);
    label.scale.set(3, 0.75, 1);
    label.position.y = 2.0; // Above head
    mesh.add(label);

    playerMeshes.set(playerId, { mesh: mesh, label: label });
  }

  function movePlayer(sceneCtx, playerId, position) {
    var data = playerMeshes.get(playerId);
    if (!data) return;
    var mesh = data.mesh;

    mesh.userData.prevPosition.copy(mesh.position);

    var x = position.x || 0, z = position.z || 0;
    var y = terrainHeight(x, z);
    mesh.position.set(x, y, z);

    var dx = x - mesh.userData.prevPosition.x;
    var dz = z - mesh.userData.prevPosition.z;
    var movementDelta = Math.sqrt(dx * dx + dz * dz);

    if (movementDelta < 0.001) {
      mesh.userData.animState = 'idle';
    } else if (movementDelta > 0.1) {
      mesh.userData.animState = 'run'; // Fast movement = running
    } else {
      mesh.userData.animState = 'walk';
    }

    if (movementDelta > 0.001) {
      var angle = Math.atan2(dx, dz);
      mesh.rotation.y = angle;
    }
  }

  function removePlayer(sceneCtx, playerId) {
    var data = playerMeshes.get(playerId);
    if (!data || !sceneCtx || !sceneCtx.scene) return;
    sceneCtx.scene.remove(data.mesh);
    playerMeshes.delete(playerId);
  }

  function updatePlayerAnimations(sceneCtx, deltaTime) {
    if (!sceneCtx) return;

    playerMeshes.forEach(function(data) {
      var mesh = data.mesh;
      var limbs = mesh.userData.limbs;
      if (!limbs) return;

      mesh.userData.animTime += deltaTime;
      var t = mesh.userData.animTime;

      var state = mesh.userData.animState || 'idle';

      limbs.leftArm.rotation.x = 0;
      limbs.rightArm.rotation.x = 0;
      limbs.leftLeg.rotation.x = 0;
      limbs.rightLeg.rotation.x = 0;
      limbs.torso.rotation.x = 0;
      limbs.torso.scale.set(1, 1, 1);
      limbs.head.rotation.x = 0;

      if (state === 'idle') {
        var breathe = Math.sin(t * 2) * 0.02;
        limbs.torso.scale.y = 1.0 + breathe;

        limbs.torso.rotation.z = Math.sin(t * 1.5) * 0.02;

        limbs.leftArm.rotation.z = Math.sin(t * 1.3) * 0.05;
        limbs.rightArm.rotation.z = -Math.sin(t * 1.3) * 0.05;

      } else if (state === 'walk') {
        var walkSpeed = 8;
        var swingAngle = 0.5;

        limbs.leftLeg.rotation.x = Math.sin(t * walkSpeed) * swingAngle;
        limbs.rightLeg.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle;

        limbs.leftArm.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle * 0.7;
        limbs.rightArm.rotation.x = Math.sin(t * walkSpeed) * swingAngle * 0.7;

        limbs.leftFoot.rotation.x = Math.sin(t * walkSpeed) * swingAngle * 0.5;
        limbs.rightFoot.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle * 0.5;

        var bob = Math.abs(Math.sin(t * walkSpeed)) * 0.05;
        limbs.torso.position.y = 0.9 + bob;
        limbs.head.position.y = 1.5 + bob;

        limbs.torso.rotation.x = 0.05;

      } else if (state === 'run') {
        var runSpeed = 12;
        var runSwingAngle = 0.8;

        limbs.leftLeg.rotation.x = Math.sin(t * runSpeed) * runSwingAngle;
        limbs.rightLeg.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle;

        limbs.leftArm.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle;
        limbs.rightArm.rotation.x = Math.sin(t * runSpeed) * runSwingAngle;

        limbs.leftFoot.rotation.x = Math.sin(t * runSpeed) * runSwingAngle * 0.5;
        limbs.rightFoot.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle * 0.5;

        var runBob = Math.abs(Math.sin(t * runSpeed)) * 0.08;
        limbs.torso.position.y = 0.9 + runBob;
        limbs.head.position.y = 1.5 + runBob;

        limbs.torso.rotation.x = 0.15;
      }
    });
  }

  function updateDayNight(sceneCtx, worldTime) {
    if (!sceneCtx) return;

    var normalizedTime = worldTime / 1440; // 0-1

    var sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2;
    if (sunMesh) {
      sunMesh.position.set(Math.cos(sunAngle) * 400, Math.sin(sunAngle) * 400, 0);
    }
    if (moonMesh) {
      moonMesh.position.set(Math.cos(sunAngle + Math.PI) * 400, Math.sin(sunAngle + Math.PI) * 400, 0);
    }

    if (stars && stars.material) {
      stars.material.opacity = Math.max(0, -Math.sin(sunAngle));
      stars.material.transparent = true;
    }

    var skyColor, fogColor, sunIntensity;
    var t;
    if (normalizedTime < 0.25) {
      t = normalizedTime / 0.25;
      skyColor = lerpColor(0x0a0a2e, 0xff6b35, t);
      fogColor = skyColor;
      sunIntensity = t * 0.3;
    } else if (normalizedTime < 0.5) {
      t = (normalizedTime - 0.25) / 0.25;
      skyColor = lerpColor(0xff6b35, 0x87ceeb, t);
      fogColor = skyColor;
      sunIntensity = 0.3 + t * 0.7;
    } else if (normalizedTime < 0.75) {
      t = (normalizedTime - 0.5) / 0.25;
      skyColor = lerpColor(0x87ceeb, 0xff4500, t);
      fogColor = skyColor;
      sunIntensity = 1.0 - t * 0.5;
    } else {
      t = (normalizedTime - 0.75) / 0.25;
      skyColor = lerpColor(0xff4500, 0x0a0a2e, t);
      fogColor = skyColor;
      sunIntensity = 0.5 - t * 0.5;
    }

    if (skyDome && skyDome.material) skyDome.material.color.setHex(skyColor);
    if (sceneCtx.scene && sceneCtx.scene.fog) sceneCtx.scene.fog.color.setHex(fogColor);
    if (sceneCtx.renderer) sceneCtx.renderer.setClearColor(fogColor);
    if (sceneCtx.directionalLight) {
      sceneCtx.directionalLight.intensity = Math.max(0.15, sunIntensity);
      sceneCtx.directionalLight.position.set(
        Math.cos(sunAngle) * 50,
        Math.max(10, Math.sin(sunAngle) * 100),
        50
      );
    }
    if (sceneCtx.ambientLight) {
      var ambientIntensity = 0.3 + sunIntensity * 0.4;
      sceneCtx.ambientLight.intensity = ambientIntensity;
      var ambientColor;
      if (normalizedTime < 0.2) {
        ambientColor = 0x334466;
      } else if (normalizedTime < 0.3) {
        var dt = (normalizedTime - 0.2) / 0.1;
        ambientColor = lerpColor(0x334466, 0xffcc88, dt);
      } else if (normalizedTime < 0.7) {
        var dt = (normalizedTime - 0.3) / 0.4;
        ambientColor = lerpColor(0xffcc88, 0xeeeedd, Math.min(dt * 2, 1.0));
      } else if (normalizedTime < 0.8) {
        var dt = (normalizedTime - 0.7) / 0.1;
        ambientColor = lerpColor(0xeeeedd, 0xff9966, dt);
      } else {
        var dt = (normalizedTime - 0.8) / 0.2;
        ambientColor = lerpColor(0xff9966, 0x334466, dt);
      }
      sceneCtx.ambientLight.color.setHex(ambientColor);
    }

    if (sceneCtx.directionalLight) {
      var sunColor;
      if (normalizedTime < 0.25) {
        sunColor = lerpColor(0x443355, 0xff8844, normalizedTime / 0.25);
      } else if (normalizedTime < 0.45) {
        sunColor = lerpColor(0xff8844, 0xffffff, (normalizedTime - 0.25) / 0.2);
      } else if (normalizedTime < 0.55) {
        sunColor = 0xffffff; // Bright noon
      } else if (normalizedTime < 0.75) {
        sunColor = lerpColor(0xffffff, 0xff6633, (normalizedTime - 0.55) / 0.2);
      } else {
        sunColor = lerpColor(0xff6633, 0x443355, (normalizedTime - 0.75) / 0.25);
      }
      sceneCtx.directionalLight.color.setHex(sunColor);
    }

    if (sceneCtx.scene && sceneCtx.scene.fog && sceneCtx.scene.fog.density !== undefined) {
      var baseDensity = 0.0012; // Clear daytime default
      var timeFogMult = 1.0;

      if (normalizedTime < 0.2) {
        timeFogMult = 1.8;
      } else if (normalizedTime < 0.28) {
        var dawnT = (normalizedTime - 0.2) / 0.08;
        timeFogMult = 1.8 + dawnT * 0.5; // peaks at 2.3 during dawn
      } else if (normalizedTime < 0.35) {
        var burnT = (normalizedTime - 0.28) / 0.07;
        timeFogMult = 2.3 - burnT * 1.3; // fades from 2.3 to 1.0
      } else if (normalizedTime < 0.7) {
        timeFogMult = 1.0;
      } else if (normalizedTime < 0.8) {
        var duskT = (normalizedTime - 0.7) / 0.1;
        timeFogMult = 1.0 + duskT * 0.5;
      } else {
        var nightT = (normalizedTime - 0.8) / 0.2;
        timeFogMult = 1.5 + nightT * 0.3;
      }

      if (currentWeatherType === 'clear' || !currentWeatherType) {
        sceneCtx.scene.fog.density = baseDensity * timeFogMult;
      }
    }

    var nightIntensity = 0;
    if (normalizedTime < 0.2 || normalizedTime > 0.8) {
      nightIntensity = 1.0;
    } else if (normalizedTime < 0.3) {
      nightIntensity = 1.0 - (normalizedTime - 0.2) / 0.1;
    } else if (normalizedTime > 0.7) {
      nightIntensity = (normalizedTime - 0.7) / 0.1;
    }
    for (var li = 0; li < zoneLights.length; li++) {
      var zl = zoneLights[li];
      zl.light.intensity = nightIntensity * 1.2;
      if (zl.glow && zl.glow.material) {
        zl.glow.material.opacity = nightIntensity * 0.8;
      }
    }
  }

  function lerpColor(c1, c2, t) {
    var r1 = (c1 >> 16) & 0xff, g1 = (c1 >> 8) & 0xff, b1 = c1 & 0xff;
    var r2 = (c2 >> 16) & 0xff, g2 = (c2 >> 8) & 0xff, b2 = c2 & 0xff;
    var r = Math.floor(r1 + (r2 - r1) * t);
    var g = Math.floor(g1 + (g2 - g1) * t);
    var b = Math.floor(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
  }

  function cullLights(sceneCtx, playerPos, maxDistance, maxCount) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var px = playerPos.x || 0, pz = playerPos.z || 0;
    var lights = [];
    sceneCtx.scene.traverse(function(obj) {
      if (obj instanceof THREE.PointLight) {
        var dx = obj.position.x - px, dz = obj.position.z - pz;
        var dist = Math.sqrt(dx * dx + dz * dz);
        lights.push({ light: obj, dist: dist });
      }
    });
    lights.sort(function(a, b) { return a.dist - b.dist; });
    for (var i = 0; i < lights.length; i++) {
      lights[i].light.visible = (i < (maxCount || 8)) && (lights[i].dist < (maxDistance || 50));
    }
  }

  function updateWeather(sceneCtx, weatherType) {
    if (!sceneCtx || !sceneCtx.scene) return;
    setWeather(sceneCtx, weatherType);
  }

  function updateAnimations(sceneCtx, deltaTime, worldTime) {
    for (var i = 0; i < clouds.length; i++) {
      var cloud = clouds[i];
      cloud.position.x += Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      cloud.position.z += Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      if (cloud.position.x > 600) cloud.position.x = -600;
      if (cloud.position.x < -600) cloud.position.x = 600;
      if (cloud.position.z > 600) cloud.position.z = -600;
      if (cloud.position.z < -600) cloud.position.z = 600;
    }

    var time = worldTime || 0;
    for (var j = 0; j < animatedObjects.length; j++) {
      var obj = animatedObjects[j];
      if (!obj.mesh || !obj.mesh.parent) continue;

      if (obj.mesh.userData.inFrustum === false) continue;

      var p = obj.params;

      switch (obj.type) {
        case 'tree':
          var windMult = windState ? windState.strength : 1.0;
          var swayFreq = currentWeatherType === 'storm' ? 0.003 : 0.001;
          obj.mesh.rotation.z = Math.sin(time * swayFreq * p.speed + p.seed) * 0.04 * windMult;
          obj.mesh.rotation.x = Math.sin(time * swayFreq * 0.8 * p.speed + p.seed * 1.5) * 0.02 * windMult;
          break;
        case 'crystal':
          obj.mesh.rotation.y += deltaTime * (p.speed || 0.3);
          if (p.baseY !== undefined) {
            obj.mesh.position.y = p.baseY + Math.sin(time * 0.002) * 0.3;
          }
          break;
        case 'portal':
          obj.mesh.rotation.z += deltaTime * (p.speed || 0.5);
          if (p.inner) {
            p.inner.material.opacity = 0.25 + Math.sin(time * 0.003) * 0.15;
          }
          if (p.particleRings) {
            for (var ri = 0; ri < p.particleRings.length; ri++) {
              var ring = p.particleRings[ri];
              for (var pi = 0; pi < ring.particles.length; pi++) {
                var pData = ring.particles[pi];
                pData.angle += ring.speed * ring.direction * deltaTime;
                var px = p.centerX + Math.cos(pData.angle) * pData.radius;
                var pz = p.centerZ + Math.sin(pData.angle) * pData.radius;
                pData.mesh.position.set(px, p.centerY, pz);
              }
            }
          }
          break;
        case 'torch':
          var flicker = 0.7 + Math.sin(time * 0.01 + (p.seed || 0)) * 0.15 + Math.sin(time * 0.023 + (p.seed || 0) * 2) * 0.15;
          obj.mesh.scale.set(flicker, 0.8 + flicker * 0.4, flicker);
          if (p.light) {
            var torchBase = 0.5 + flicker * 0.5;
            var wt = (typeof worldTime === 'number') ? worldTime : 720;
            var nt = wt / 1440;
            var nightBoost = (nt < 0.2 || nt > 0.8) ? 1.5 : (nt < 0.3 ? (1.0 + 0.5 * (1.0 - (nt - 0.2) / 0.1)) : (nt > 0.7 ? (1.0 + 0.5 * ((nt - 0.7) / 0.1)) : 1.0));
            p.light.intensity = torchBase * nightBoost;
          }
          break;
        case 'water':
          obj.mesh.rotation.y += deltaTime * 0.05;
          break;
        case 'creature':
          var Models = typeof window !== 'undefined' ? window.Models : null;
          if (Models && Models.animateModel) {
            Models.animateModel(obj.mesh, deltaTime, time);
          } else {
            obj.mesh.position.y += Math.sin(time * 0.003 * (p.speed || 1)) * 0.01;
            obj.mesh.rotation.y += deltaTime * (p.speed || 0.5);
          }
          break;
        case 'landmark':
          if (Models && Models.animateModel) {
            Models.animateModel(obj.mesh, deltaTime, time);
          }
          if (p.shimmer && p.shimmer.material) {
            p.shimmer.material.opacity = 0.15 + Math.sin(time * 0.002) * 0.1;
          }
          break;
      }
    }
  }

  function checkCollision(x, z, radius) {
    if (placedStructures) {
      for (var i = 0; i < placedStructures.length; i++) {
        var s = placedStructures[i];
        if (!s || !s.position) continue;
        var dx = x - s.position.x, dz = z - s.position.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        var structRadius = s.collisionRadius || 1.5;
        if (dist < structRadius + radius) {
          return true;
        }
      }
    }
    return false;
  }

  var placedStructures = [];

  var particleSystems = null;
  var MAX_PARTICLES = 500;
  var PARTICLE_CULL_DISTANCE = 100;

  function ParticleSystem() {
    this.particles = [];
    this.positions = new Float32Array(MAX_PARTICLES * 3);
    this.colors = new Float32Array(MAX_PARTICLES * 3);
    this.sizes = new Float32Array(MAX_PARTICLES);
    this.activeCount = 0;

    for (var i = 0; i < MAX_PARTICLES; i++) {
      this.particles.push({
        active: false,
        position: { x: 0, y: 0, z: 0 },
        velocity: { x: 0, y: 0, z: 0 },
        life: 0,
        maxLife: 1,
        color: { r: 1, g: 1, b: 1 },
        size: 1,
        opacity: 1,
        emitterType: null
      });
    }

    this.geometry = new THREE.BufferGeometry();
    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
    this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
    this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

    this.material = new THREE.PointsMaterial({
      size: 0.5,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    var particleCanvas = document.createElement('canvas');
    particleCanvas.width = 32;
    particleCanvas.height = 32;
    var pctx = particleCanvas.getContext('2d');
    var gradient = pctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    pctx.fillStyle = gradient;
    pctx.fillRect(0, 0, 32, 32);
    var particleTex = new THREE.CanvasTexture(particleCanvas);
    this.material.map = particleTex;

    this.points = new THREE.Points(this.geometry, this.material);
    this.points.frustumCulled = false;

    this.emitters = [];
  }

  ParticleSystem.prototype.addEmitter = function(type, position, config) {
    this.emitters.push({
      type: type,
      position: position,
      config: config || {},
      timer: 0,
      active: true
    });
  };

  ParticleSystem.prototype.removeEmitter = function(index) {
    if (index >= 0 && index < this.emitters.length) {
      this.emitters.splice(index, 1);
    }
  };

  ParticleSystem.prototype.emitParticle = function(type, position, count) {
    count = count || 1;
    for (var i = 0; i < count; i++) {
      this._spawnParticle(type, position);
    }
  };

  ParticleSystem.prototype._spawnParticle = function(type, position) {
    var particle = null;
    for (var i = 0; i < MAX_PARTICLES; i++) {
      if (!this.particles[i].active) {
        particle = this.particles[i];
        break;
      }
    }
    if (!particle) return; // Pool full

    particle.active = true;
    particle.position.x = position.x;
    particle.position.y = position.y;
    particle.position.z = position.z;
    particle.emitterType = type;

    switch (type) {
      case 'fire':
        particle.maxLife = 1.0 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.5;
        particle.velocity.y = 1.5 + Math.random() * 1.0;
        particle.velocity.z = (Math.random() - 0.5) * 0.5;
        particle.color.r = 1.0;
        particle.color.g = 0.4 + Math.random() * 0.3;
        particle.color.b = 0.0;
        particle.size = 0.3 + Math.random() * 0.3;
        particle.opacity = 1.0;
        break;

      case 'sparkle':
        particle.maxLife = 1.5 + Math.random() * 1.0;
        particle.life = particle.maxLife;
        var angle = Math.random() * Math.PI * 2;
        var radius = 2.0;
        particle.velocity.x = Math.cos(angle) * radius;
        particle.velocity.y = (Math.random() - 0.5) * 0.3;
        particle.velocity.z = Math.sin(angle) * radius;
        particle.color.r = 0.0;
        particle.color.g = 0.8 + Math.random() * 0.2;
        particle.color.b = 1.0;
        particle.size = 0.2 + Math.random() * 0.2;
        particle.opacity = 1.0;
        break;

      case 'dust':
        particle.maxLife = 0.5 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 1.0;
        particle.velocity.y = 0.3 + Math.random() * 0.5;
        particle.velocity.z = (Math.random() - 0.5) * 1.0;
        particle.color.r = 0.6;
        particle.color.g = 0.5;
        particle.color.b = 0.4;
        particle.size = 0.1 + Math.random() * 0.15;
        particle.opacity = 0.6;
        break;

      case 'leaf':
        particle.maxLife = 3.0 + Math.random() * 2.0;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.5;
        particle.velocity.y = -0.3 - Math.random() * 0.2;
        particle.velocity.z = (Math.random() - 0.5) * 0.5;
        particle.color.r = 0.2 + Math.random() * 0.3;
        particle.color.g = 0.6 + Math.random() * 0.3;
        particle.color.b = 0.1;
        particle.size = 0.2 + Math.random() * 0.2;
        particle.opacity = 0.8;
        break;

      case 'mist':
        particle.maxLife = 2.0 + Math.random() * 2.0;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.2;
        particle.velocity.y = 0.05 + Math.random() * 0.1;
        particle.velocity.z = (Math.random() - 0.5) * 0.2;
        particle.color.r = 0.8;
        particle.color.g = 0.85;
        particle.color.b = 0.9;
        particle.size = 0.8 + Math.random() * 0.6;
        particle.opacity = 0.3;
        break;

      case 'fountain':
        particle.maxLife = 1.5 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        var fAngle = Math.random() * Math.PI * 2;
        var fSpeed = 1.0 + Math.random() * 1.5;
        particle.velocity.x = Math.cos(fAngle) * fSpeed * 0.5;
        particle.velocity.y = 3.0 + Math.random() * 1.5;
        particle.velocity.z = Math.sin(fAngle) * fSpeed * 0.5;
        particle.color.r = 0.2;
        particle.color.g = 0.5 + Math.random() * 0.3;
        particle.color.b = 0.8 + Math.random() * 0.2;
        particle.size = 0.15 + Math.random() * 0.15;
        particle.opacity = 0.7;
        break;

      default:
        particle.active = false;
        return;
    }
  };

  ParticleSystem.prototype.update = function(deltaTime, playerPos) {
    var dt = deltaTime * 0.001; // Convert to seconds
    var px = playerPos ? playerPos.x : 0;
    var pz = playerPos ? playerPos.z : 0;

    for (var e = 0; e < this.emitters.length; e++) {
      var emitter = this.emitters[e];
      if (!emitter.active) continue;

      emitter.timer += deltaTime;

      var emitRate = 50; // ms per particle
      switch (emitter.type) {
        case 'fire': emitRate = 80; break;
        case 'sparkle': emitRate = 100; break;
        case 'dust': emitRate = 150; break;
        case 'leaf': emitRate = 200; break;
        case 'mist': emitRate = 120; break;
        case 'fountain': emitRate = 60; break;
      }

      while (emitter.timer >= emitRate) {
        emitter.timer -= emitRate;
        this._spawnParticle(emitter.type, emitter.position);
      }
    }

    this.activeCount = 0;
    for (var i = 0; i < MAX_PARTICLES; i++) {
      var p = this.particles[i];
      if (!p.active) continue;

      p.life -= dt;
      if (p.life <= 0) {
        p.active = false;
        continue;
      }

      var dx = p.position.x - px;
      var dz = p.position.z - pz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist > PARTICLE_CULL_DISTANCE) {
        p.active = false;
        continue;
      }

      p.position.x += p.velocity.x * dt;
      p.position.y += p.velocity.y * dt;
      p.position.z += p.velocity.z * dt;

      if (p.emitterType !== 'sparkle' && p.emitterType !== 'mist') {
        p.velocity.y -= 2.0 * dt;
      }

      if (p.emitterType === 'sparkle') {
        var angle = Math.atan2(p.velocity.z, p.velocity.x);
        angle += dt * 2.0;
        var speed = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.z * p.velocity.z);
        p.velocity.x = Math.cos(angle) * speed;
        p.velocity.z = Math.sin(angle) * speed;
      } else if (p.emitterType === 'leaf') {
        p.velocity.x += Math.sin(p.life * 3.0) * dt * 0.5;
        p.velocity.z += Math.cos(p.life * 2.5) * dt * 0.5;
      } else if (p.emitterType === 'mist') {
        p.velocity.x *= 0.98;
        p.velocity.z *= 0.98;
      }

      p.velocity.x *= 0.99;
      p.velocity.z *= 0.99;

      var lifeRatio = p.life / p.maxLife;
      p.opacity = Math.min(1.0, lifeRatio * 2.0);

      var idx = this.activeCount * 3;
      this.positions[idx] = p.position.x;
      this.positions[idx + 1] = p.position.y;
      this.positions[idx + 2] = p.position.z;

      this.colors[idx] = p.color.r * p.opacity;
      this.colors[idx + 1] = p.color.g * p.opacity;
      this.colors[idx + 2] = p.color.b * p.opacity;

      this.sizes[this.activeCount] = p.size;

      this.activeCount++;
    }

    this.geometry.setDrawRange(0, this.activeCount);
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
  };

  function initParticles(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    particleSystems = new ParticleSystem();
    sceneCtx.scene.add(particleSystems.points);

    var arenaZ = ZONES.arena;
    for (var ti = 0; ti < 12; ti++) {
      var tAngle = (ti / 12) * Math.PI * 2;
      var tpx = arenaZ.cx + Math.cos(tAngle) * 20;
      var tpz = arenaZ.cz + Math.sin(tAngle) * 20;
      particleSystems.addEmitter('fire', { x: tpx, y: arenaZ.baseHeight + 2.7, z: tpz });
    }

    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var dx = ZONES.nexus.cx - zone.cx;
      var dz = ZONES.nexus.cz - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var nx = dx / dist, nz = dz / dist;
      var portalX = zone.cx + nx * zone.radius * 0.7;
      var portalZ = zone.cz + nz * zone.radius * 0.7;
      var portalY = terrainHeight(portalX, portalZ);
      particleSystems.addEmitter('sparkle', { x: portalX, y: portalY + 3, z: portalZ });
    }

    var gardensZ = ZONES.gardens;
    particleSystems.addEmitter('fountain', { x: gardensZ.cx, y: gardensZ.baseHeight + 1.5, z: gardensZ.cz });

    var wildsZ = ZONES.wilds;
    for (var mi = 0; mi < 3; mi++) {
      var mAngle = (mi / 3) * Math.PI * 2;
      var mx = wildsZ.cx + Math.cos(mAngle) * 10;
      var mz = wildsZ.cz + Math.sin(mAngle) * 10;
      particleSystems.addEmitter('mist', { x: mx, y: wildsZ.baseHeight + 0.5, z: mz });
    }

    var leafZones = [ZONES.gardens, ZONES.wilds];
    for (var lzi = 0; lzi < leafZones.length; lzi++) {
      var lz = leafZones[lzi];
      for (var li = 0; li < 4; li++) {
        var lAngle = (li / 4) * Math.PI * 2;
        var lx = lz.cx + Math.cos(lAngle) * 15;
        var lzp = lz.cz + Math.sin(lAngle) * 15;
        particleSystems.addEmitter('leaf', { x: lx, y: lz.baseHeight + 8, z: lzp });
      }
    }
  }

  function updateParticles(sceneCtx, deltaTime, playerPos) {
    if (!particleSystems) return;
    particleSystems.update(deltaTime, playerPos);
  }

  function emitParticles(type, position, count) {
    if (!particleSystems) return;
    particleSystems.emitParticle(type, position, count || 1);
  }

  var weatherParticles = null; // Current active weather particle system
  var currentWeatherType = 'clear';
  var lightningTimer = 0;
  var lightningActive = false;
  var lightningLight = null;
  var weatherCallbacks = {}; // { onLightningStrike: function(x,z) }

  function setWeather(sceneCtx, type) {
    if (!sceneCtx || !sceneCtx.scene) return;

    if (weatherParticles) {
      sceneCtx.scene.remove(weatherParticles);
      if (weatherParticles.geometry) weatherParticles.geometry.dispose();
      if (weatherParticles.material) weatherParticles.material.dispose();
      weatherParticles = null;
    }

    currentWeatherType = type;

    if (sceneCtx.scene.fog && sceneCtx.scene.fog.density !== undefined) {
      switch (type) {
        case 'storm':
          sceneCtx.scene.fog.density = 0.0030;
          break;
        case 'rain':
          sceneCtx.scene.fog.density = 0.0022;
          break;
        case 'snow':
          sceneCtx.scene.fog.density = 0.0018;
          break;
        case 'cloudy':
          sceneCtx.scene.fog.density = 0.0015;
          break;
        default:
          sceneCtx.scene.fog.density = 0.0012;
      }
    }

    if (type === 'rain') {
      var rainCount = 2000;
      var rainGeo = new THREE.BufferGeometry();
      var rainPositions = new Float32Array(rainCount * 3);
      var rainVelocities = new Float32Array(rainCount * 3);

      for (var i = 0; i < rainCount; i++) {
        var idx = i * 3;
        rainPositions[idx] = (Math.random() - 0.5) * 100;     // x
        rainPositions[idx + 1] = Math.random() * 80 + 20;      // y
        rainPositions[idx + 2] = (Math.random() - 0.5) * 100; // z

        rainVelocities[idx] = (Math.random() - 0.5) * 0.5;     // x drift
        rainVelocities[idx + 1] = -0.8 - Math.random() * 0.4;  // y fall speed
        rainVelocities[idx + 2] = (Math.random() - 0.5) * 0.5; // z drift
      }

      rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
      rainGeo.userData.velocities = rainVelocities;

      var rainMat = new THREE.PointsMaterial({
        color: 0xaaccff,
        size: 0.15,
        transparent: true,
        opacity: 0.6,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(rainGeo, rainMat);
      weatherParticles.userData.type = 'rain';
      sceneCtx.scene.add(weatherParticles);

    } else if (type === 'snow') {
      var snowCount = 1000;
      var snowGeo = new THREE.BufferGeometry();
      var snowPositions = new Float32Array(snowCount * 3);
      var snowVelocities = new Float32Array(snowCount * 3);
      var snowPhases = new Float32Array(snowCount); // For sine-wave movement

      for (var j = 0; j < snowCount; j++) {
        var jdx = j * 3;
        snowPositions[jdx] = (Math.random() - 0.5) * 120;     // x
        snowPositions[jdx + 1] = Math.random() * 100 + 20;    // y
        snowPositions[jdx + 2] = (Math.random() - 0.5) * 120; // z

        snowVelocities[jdx] = 0;                              // x (handled by sine wave)
        snowVelocities[jdx + 1] = -0.15 - Math.random() * 0.1; // y fall speed
        snowVelocities[jdx + 2] = 0;                          // z (handled by sine wave)

        snowPhases[j] = Math.random() * Math.PI * 2;
      }

      snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
      snowGeo.userData.velocities = snowVelocities;
      snowGeo.userData.phases = snowPhases;

      var snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.25,
        transparent: true,
        opacity: 0.8,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(snowGeo, snowMat);
      weatherParticles.userData.type = 'snow';
      sceneCtx.scene.add(weatherParticles);

    } else if (type === 'storm') {
      var stormCount = 3500;
      var stormGeo = new THREE.BufferGeometry();
      var stormPositions = new Float32Array(stormCount * 3);
      var stormVelocities = new Float32Array(stormCount * 3);

      for (var s = 0; s < stormCount; s++) {
        var sidx = s * 3;
        stormPositions[sidx] = (Math.random() - 0.5) * 120;
        stormPositions[sidx + 1] = Math.random() * 80 + 20;
        stormPositions[sidx + 2] = (Math.random() - 0.5) * 120;

        stormVelocities[sidx] = (Math.random() - 0.5) * 1.5;       // stronger wind
        stormVelocities[sidx + 1] = -1.2 - Math.random() * 0.6;    // faster rain
        stormVelocities[sidx + 2] = (Math.random() - 0.5) * 1.5;
      }

      stormGeo.setAttribute('position', new THREE.Float32BufferAttribute(stormPositions, 3));
      stormGeo.userData.velocities = stormVelocities;

      var stormMat = new THREE.PointsMaterial({
        color: 0x8899bb,
        size: 0.18,
        transparent: true,
        opacity: 0.7,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(stormGeo, stormMat);
      weatherParticles.userData.type = 'rain'; // reuse rain update logic
      sceneCtx.scene.add(weatherParticles);

      if (!lightningLight) {
        lightningLight = new THREE.PointLight(0xeeeeff, 0, 200);
        lightningLight.position.set(0, 50, 0);
        sceneCtx.scene.add(lightningLight);
      }
      lightningTimer = 0;
      lightningActive = false;

      if (sceneCtx.ambientLight) {
        sceneCtx.ambientLight.intensity = Math.max(0.15, sceneCtx.ambientLight.intensity * 0.6);
      }

    } else if (type === 'cloudy') {
      if (sceneCtx.ambientLight) {
        sceneCtx.ambientLight.intensity = Math.max(0.25, sceneCtx.ambientLight.intensity * 0.8);
      }
      if (sceneCtx.directionalLight) {
        sceneCtx.directionalLight.intensity = Math.max(0.2, sceneCtx.directionalLight.intensity * 0.7);
      }
    } else {
      if (lightningLight && sceneCtx.scene) {
        sceneCtx.scene.remove(lightningLight);
        lightningLight = null;
      }
    }
  }

  function updateWeatherEffects(sceneCtx, deltaTime, cameraPos) {
    if (!weatherParticles || !weatherParticles.geometry) return;

    var positions = weatherParticles.geometry.attributes.position.array;
    var velocities = weatherParticles.geometry.userData.velocities;
    var type = weatherParticles.userData.type;

    var camX = cameraPos.x || 0;
    var camY = cameraPos.y || 0;
    var camZ = cameraPos.z || 0;

    if (type === 'rain') {
      for (var i = 0; i < positions.length / 3; i++) {
        var idx = i * 3;

        positions[idx] += velocities[idx] * deltaTime;
        positions[idx + 1] += velocities[idx + 1] * deltaTime;
        positions[idx + 2] += velocities[idx + 2] * deltaTime;

        var groundHeight = terrainHeight(positions[idx], positions[idx + 2]);

        if (positions[idx + 1] < groundHeight) {
          positions[idx] = camX + (Math.random() - 0.5) * 100;
          positions[idx + 1] = camY + Math.random() * 40 + 20;
          positions[idx + 2] = camZ + (Math.random() - 0.5) * 100;

          velocities[idx] = (Math.random() - 0.5) * 0.5;
          velocities[idx + 2] = (Math.random() - 0.5) * 0.5;
        }

        var dx = positions[idx] - camX;
        var dz = positions[idx + 2] - camZ;
        if (Math.abs(dx) > 60 || Math.abs(dz) > 60) {
          positions[idx] = camX + (Math.random() - 0.5) * 100;
          positions[idx + 1] = camY + Math.random() * 40 + 20;
          positions[idx + 2] = camZ + (Math.random() - 0.5) * 100;
        }
      }

    } else if (type === 'snow') {
      var phases = weatherParticles.geometry.userData.phases;
      var time = Date.now() * 0.001;

      for (var j = 0; j < positions.length / 3; j++) {
        var jdx = j * 3;

        var sineX = Math.sin(time * 0.5 + phases[j]) * 0.3;
        var sineZ = Math.cos(time * 0.5 + phases[j] * 1.3) * 0.3;

        positions[jdx] += (velocities[jdx] + sineX) * deltaTime;
        positions[jdx + 1] += velocities[jdx + 1] * deltaTime;
        positions[jdx + 2] += (velocities[jdx + 2] + sineZ) * deltaTime;

        var snowGroundHeight = terrainHeight(positions[jdx], positions[jdx + 2]);

        if (positions[jdx + 1] < snowGroundHeight) {
          positions[jdx] = camX + (Math.random() - 0.5) * 120;
          positions[jdx + 1] = camY + Math.random() * 50 + 30;
          positions[jdx + 2] = camZ + (Math.random() - 0.5) * 120;
          phases[j] = Math.random() * Math.PI * 2;
        }

        var sdx = positions[jdx] - camX;
        var sdz = positions[jdx + 2] - camZ;
        if (Math.abs(sdx) > 70 || Math.abs(sdz) > 70) {
          positions[jdx] = camX + (Math.random() - 0.5) * 120;
          positions[jdx + 1] = camY + Math.random() * 50 + 30;
          positions[jdx + 2] = camZ + (Math.random() - 0.5) * 120;
        }
      }
    }

    weatherParticles.geometry.attributes.position.needsUpdate = true;

    if (type === 'rain' && splashPool.length > 0) {
      for (var si = 0; si < positions.length / 3; si += 10) { // sample every 10th
        var sidx = si * 3;
        var groundH = terrainHeight(positions[sidx], positions[sidx + 2]);
        if (positions[sidx + 1] < groundH + 0.5 && positions[sidx + 1] > groundH - 1) {
          spawnSplash(positions[sidx], groundH, positions[sidx + 2]);
        }
      }
    }

    if (lightningLight && weatherParticles.userData.type === 'rain') {
      lightningTimer += deltaTime;

      if (lightningActive) {
        lightningLight.intensity *= 0.85;

        if (sceneCtx && sceneCtx.ambientLight && lightningLight.intensity > 1.0) {
          sceneCtx.ambientLight.intensity = Math.min(2.0, lightningLight.intensity * 0.5);
        }

        if (lightningLight.intensity < 0.05) {
          lightningLight.intensity = 0;
          lightningActive = false;
          lightningTimer = 0;
          if (sceneCtx && sceneCtx.ambientLight) {
            sceneCtx.ambientLight.intensity = 0.15;
          }
        }
      } else {
        var flashInterval = 3000 + Math.random() * 5000;
        if (lightningTimer > flashInterval) {
          lightningActive = true;
          lightningLight.intensity = 2.5 + Math.random() * 1.5;
          var boltX = (cameraPos.x || 0) + (Math.random() - 0.5) * 80;
          var boltZ = (cameraPos.z || 0) + (Math.random() - 0.5) * 80;
          lightningLight.position.set(boltX, 45 + Math.random() * 15, boltZ);
          lightningTimer = 0;

          createLightningBolt(sceneCtx, boltX, boltZ);

          if (weatherCallbacks.onLightningStrike) {
            weatherCallbacks.onLightningStrike(boltX, boltZ);
          }
        }
      }
    }

    updateLightningBolt(sceneCtx, deltaTime);

    updateRainSplashes(deltaTime);
  }

  function getCurrentWeather() {
    return currentWeatherType;
  }

  var waterBodies = [];
  var waterTime = 0;
  var waterWeatherMultiplier = 1.0; // Modified by weather conditions

  function initWater(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var scene = sceneCtx.scene;

    for (var i = 0; i < waterBodies.length; i++) {
      scene.remove(waterBodies[i].mesh);
      if (waterBodies[i].foamRing) scene.remove(waterBodies[i].foamRing);
      if (waterBodies[i].geometry) waterBodies[i].geometry.dispose();
      if (waterBodies[i].material) waterBodies[i].material.dispose();
    }
    waterBodies = [];

    var gardensPond = createWaterBody({
      type: 'circle',
      centerX: ZONES.gardens.cx,
      centerZ: ZONES.gardens.cz,
      radius: 30,
      height: ZONES.gardens.baseHeight + 0.3,
      segments: 64,
      waveSpeed: 0.8,
      waveHeight: 0.2,
      waveFrequency: 0.3,
      color: 0x3388cc,
      emissive: 0x113355
    });
    scene.add(gardensPond.mesh);
    if (gardensPond.foamRing) scene.add(gardensPond.foamRing);
    waterBodies.push(gardensPond);

    var riverSegments = createRiverPath(ZONES.wilds.cx, ZONES.wilds.cz, ZONES.wilds.radius);
    for (var j = 0; j < riverSegments.length; j++) {
      var riverSegment = createWaterBody({
        type: 'river',
        centerX: riverSegments[j].x,
        centerZ: riverSegments[j].z,
        width: 10,
        length: riverSegments[j].length,
        rotation: riverSegments[j].rotation,
        height: ZONES.wilds.baseHeight + 0.2,
        segments: 64,
        waveSpeed: 1.2,
        waveHeight: 0.25,
        waveFrequency: 0.5,
        flowDirection: riverSegments[j].direction,
        color: 0x2277bb,
        emissive: 0x0f2844
      });
      scene.add(riverSegment.mesh);
      waterBodies.push(riverSegment);
    }

    var nexusFountain = createWaterBody({
      type: 'circle',
      centerX: ZONES.nexus.cx,
      centerZ: ZONES.nexus.cz,
      radius: 8,
      height: ZONES.nexus.baseHeight + 0.5,
      segments: 64,
      waveSpeed: 1.5,
      waveHeight: 0.15,
      waveFrequency: 0.8,
      color: 0x4499dd,
      emissive: 0x225588
    });
    scene.add(nexusFountain.mesh);
    if (nexusFountain.foamRing) scene.add(nexusFountain.foamRing);
    waterBodies.push(nexusFountain);
  }

  function createWaterBody(config) {
    var geometry, material, mesh;
    var segments = config.segments || 64;

    if (config.type === 'circle') {
      geometry = new THREE.PlaneGeometry(config.radius * 2, config.radius * 2, segments, segments);
    } else if (config.type === 'river') {
      geometry = new THREE.PlaneGeometry(config.length, config.width, segments, segments);
    }

    geometry.rotateX(-Math.PI / 2);

    geometry.translate(config.centerX, config.height, config.centerZ);

    if (config.rotation) {
      var tempGeom = new THREE.PlaneGeometry(config.length, config.width, segments, segments);
      tempGeom.rotateX(-Math.PI / 2);
      tempGeom.rotateY(config.rotation);
      tempGeom.translate(config.centerX, config.height, config.centerZ);
      geometry = tempGeom;
    }

    var positions = geometry.attributes.position.array;
    var initialPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
      initialPositions[i] = positions[i];
    }

    var waterColor = config.color || 0x2266aa;
    var emissiveColor = config.emissive || 0x112244;

    material = new THREE.MeshPhongMaterial({
      color: waterColor,
      transparent: true,
      opacity: 0.65,
      side: THREE.DoubleSide,
      shininess: 100,
      specular: 0xaaddff,
      emissive: emissiveColor,
      emissiveIntensity: 0.15,
      reflectivity: 0.8
    });

    mesh = new THREE.Mesh(geometry, material);
    mesh.receiveShadow = false;
    mesh.castShadow = false;

    var foamRing = null;
    if (config.type === 'circle' && config.radius) {
      var foamInner = config.radius - 1.5;
      var foamOuter = config.radius + 0.5;
      var foamGeom = new THREE.RingBufferGeometry(foamInner, foamOuter, 32);
      foamGeom.rotateX(-Math.PI / 2);
      var foamMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      foamRing = new THREE.Mesh(foamGeom, foamMat);
      foamRing.position.set(config.centerX, config.height + 0.02, config.centerZ);
      mesh.parent ? mesh.parent.add(foamRing) : null;
    }

    return {
      mesh: mesh,
      geometry: geometry,
      material: material,
      initialPositions: initialPositions,
      config: config,
      foamRing: foamRing
    };
  }

  function createRiverPath(centerX, centerZ, zoneRadius) {
    var segments = [];
    var segmentLength = 25;
    var numSegments = 6;

    var startX = centerX - zoneRadius * 0.6;
    var startZ = centerZ - zoneRadius * 0.7;

    var currentX = startX;
    var currentZ = startZ;
    var currentAngle = Math.PI * 0.3; // Initial direction (southeast)

    for (var i = 0; i < numSegments; i++) {
      var nextX = currentX + Math.cos(currentAngle) * segmentLength;
      var nextZ = currentZ + Math.sin(currentAngle) * segmentLength;

      var segX = (currentX + nextX) / 2;
      var segZ = (currentZ + nextZ) / 2;

      segments.push({
        x: segX,
        z: segZ,
        length: segmentLength,
        rotation: currentAngle,
        direction: { x: Math.cos(currentAngle), z: Math.sin(currentAngle) }
      });

      currentX = nextX;
      currentZ = nextZ;
      currentAngle += (Math.random() - 0.5) * 0.6; // Random curve
    }

    return segments;
  }

  function updateWater(deltaTime, weatherType) {
    if (!waterBodies || waterBodies.length === 0) return;

    waterTime += deltaTime;

    var targetMultiplier = 1.0;
    if (weatherType === 'storm') {
      targetMultiplier = 2.5; // Much choppier waves during storms
    } else if (weatherType === 'rain') {
      targetMultiplier = 1.6; // Moderately rough during rain
    } else if (weatherType === 'snow') {
      targetMultiplier = 0.5; // Calmer, colder water
    }

    waterWeatherMultiplier += (targetMultiplier - waterWeatherMultiplier) * deltaTime * 0.5;

    for (var i = 0; i < waterBodies.length; i++) {
      var water = waterBodies[i];
      if (!water || !water.geometry || !water.initialPositions) continue;

      var positions = water.geometry.attributes.position.array;
      var initialPos = water.initialPositions;
      var config = water.config;

      var baseWaveSpeed = config.waveSpeed || 1.0;
      var baseWaveHeight = config.waveHeight || 0.2;
      var waveFrequency = config.waveFrequency || 0.5;

      var waveSpeed = baseWaveSpeed * waterWeatherMultiplier;
      var waveHeight = baseWaveHeight * waterWeatherMultiplier;

      for (var j = 0; j < positions.length; j += 3) {
        var x = initialPos[j];
        var y = initialPos[j + 1];
        var z = initialPos[j + 2];

        var distFromCenter = 0;
        if (config.type === 'circle') {
          var dx = x - config.centerX;
          var dz = z - config.centerZ;
          distFromCenter = Math.sqrt(dx * dx + dz * dz);

          var ripple = Math.sin(distFromCenter * waveFrequency - waterTime * waveSpeed) * waveHeight;

          var angle = Math.atan2(dz, dx);
          var secondaryWave = Math.sin(angle * 3 + waterTime * waveSpeed * 0.5) * waveHeight * 0.3;

          var detailWave = Math.sin(x * 0.4 + waterTime * waveSpeed * 1.2) * waveHeight * 0.2 +
                           Math.sin(z * 0.3 + waterTime * waveSpeed * 0.9) * waveHeight * 0.2;

          var chopWave = 0;
          if (waterWeatherMultiplier > 1.5) {
            chopWave = Math.sin(x * 0.8 + z * 0.7 + waterTime * waveSpeed * 2.0) * waveHeight * 0.25;
          }

          positions[j + 1] = y + ripple + secondaryWave + detailWave + chopWave;

          if (distFromCenter > config.radius * 0.8) {
            var fadeRatio = 1 - (distFromCenter - config.radius * 0.8) / (config.radius * 0.2);
            positions[j + 1] = y + (ripple + secondaryWave + detailWave + chopWave) * Math.max(0, fadeRatio);
          }
        } else if (config.type === 'river') {
          var flowDir = config.flowDirection || { x: 1, z: 0 };
          var flowComponent = (x - config.centerX) * flowDir.x + (z - config.centerZ) * flowDir.z;

          var flowWave = Math.sin(flowComponent * waveFrequency - waterTime * waveSpeed) * waveHeight;

          var flowWave2 = Math.sin(flowComponent * waveFrequency * 1.3 - waterTime * waveSpeed * 1.4) * waveHeight * 0.5;

          var crossComponent = -(x - config.centerX) * flowDir.z + (z - config.centerZ) * flowDir.x;
          var crossWave = Math.sin(crossComponent * waveFrequency * 0.8 + waterTime * waveSpeed * 0.6) * waveHeight * 0.4;

          var turbulence = Math.sin(x * 0.5 + waterTime * waveSpeed * 1.8) * waveHeight * 0.15 +
                           Math.sin(z * 0.4 + waterTime * waveSpeed * 1.5) * waveHeight * 0.15;

          var rapids = 0;
          if (waterWeatherMultiplier > 1.5) {
            rapids = Math.sin(flowComponent * 1.2 - waterTime * waveSpeed * 3.0) * waveHeight * 0.3;
          }

          positions[j + 1] = y + flowWave + flowWave2 + crossWave + turbulence + rapids;
        }
      }

      var maxAmp = baseWaveHeight * waterWeatherMultiplier;
      var crestThreshold = maxAmp * 0.6;
      if (!water.crestColors) {
        var colorCount = positions.length / 3;
        var colorArray = new Float32Array(colorCount * 3);
        water.crestColors = colorArray;
        water.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
        water.material.vertexColors = true;
        var baseR = ((water.config.color >> 16) & 0xff) / 255;
        var baseG = ((water.config.color >> 8) & 0xff) / 255;
        var baseB = (water.config.color & 0xff) / 255;
        for (var ci = 0; ci < colorCount; ci++) {
          colorArray[ci * 3] = baseR;
          colorArray[ci * 3 + 1] = baseG;
          colorArray[ci * 3 + 2] = baseB;
        }
      }
      var colors = water.crestColors;
      var baseR2 = ((water.config.color >> 16) & 0xff) / 255;
      var baseG2 = ((water.config.color >> 8) & 0xff) / 255;
      var baseB2 = (water.config.color & 0xff) / 255;
      for (var ck = 0; ck < positions.length; ck += 3) {
        var displacement = positions[ck + 1] - initialPos[ck + 1];
        var crestFactor = displacement > crestThreshold ? Math.min((displacement - crestThreshold) / (maxAmp - crestThreshold), 1.0) * 0.3 : 0;
        colors[ck] = baseR2 + crestFactor;
        colors[ck + 1] = baseG2 + crestFactor;
        colors[ck + 2] = baseB2 + crestFactor;
      }
      water.geometry.attributes.color.needsUpdate = true;

      water.geometry.attributes.position.needsUpdate = true;
      water.geometry.computeVertexNormals();

      if (water.material) {
        var targetOpacity = 0.65;
        if (weatherType === 'storm') {
          targetOpacity = 0.75; // Darker, choppier water
        } else if (weatherType === 'rain') {
          targetOpacity = 0.7;
        }
        water.material.opacity += (targetOpacity - water.material.opacity) * deltaTime * 0.5;

        var targetEmissive = 0.15;
        if (weatherType === 'storm') {
          targetEmissive = 0.08; // Less glow during storm
        } else if (weatherType === 'snow') {
          targetEmissive = 0.1; // Reduced glow in cold
        }
        if (water.material.emissiveIntensity !== undefined) {
          water.material.emissiveIntensity += (targetEmissive - water.material.emissiveIntensity) * deltaTime * 0.5;
        }
      }
    }

    for (var fi = 0; fi < waterBodies.length; fi++) {
      var foamBody = waterBodies[fi];
      if (!foamBody.foamRing) continue;
      var foamMat = foamBody.foamRing.material;
      foamMat.opacity = Math.sin(waterTime * 1.5) * 0.06 + 0.14;
      var foamScale = 1.0 + Math.sin(waterTime * 0.8) * 0.02;
      foamBody.foamRing.scale.set(foamScale, 1, foamScale);
    }
  }

  var playerStarsMesh = null;

  function initPlayerStars(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var stored = null;
    if (typeof localStorage !== 'undefined') {
      try { stored = JSON.parse(localStorage.getItem('zion_playerStars') || '{}'); } catch(e) { stored = {}; }
    }
    if (!stored || Object.keys(stored).length === 0) return;

    var psPos = [];
    var psSizes = [];
    var psColors = [];
    for (var pid in stored) {
      var ps = stored[pid];
      psPos.push(ps.x || 0, ps.y || 0, ps.z || 0);
      psSizes.push(2.5);
      psColors.push(1.0, 0.87, 0.53); // warm gold 0xFFDD88
    }

    if (psPos.length === 0) return;

    var psGeo = new THREE.BufferGeometry();
    psGeo.setAttribute('position', new THREE.Float32BufferAttribute(psPos, 3));
    psGeo.setAttribute('size', new THREE.Float32BufferAttribute(psSizes, 1));
    psGeo.setAttribute('color', new THREE.Float32BufferAttribute(psColors, 3));

    var psMat = new THREE.PointsMaterial({
      size: 2.5,
      sizeAttenuation: false,
      transparent: true,
      opacity: 0.0,
      fog: false,
      vertexColors: true
    });

    playerStarsMesh = new THREE.Points(psGeo, psMat);
    sceneCtx.scene.add(playerStarsMesh);
  }

  function registerPlayerStar(playerId, playerName) {
    var hash = 0;
    for (var i = 0; i < playerId.length; i++) {
      hash = ((hash << 5) - hash) + playerId.charCodeAt(i);
      hash |= 0;
    }
    var theta = (Math.abs(hash) % 10000) / 10000 * Math.PI * 2;
    var phi = (Math.abs(hash * 7919) % 10000) / 10000 * Math.PI * 0.6 + 0.2; // keep above horizon
    var R = 750;
    var starData = {
      name: playerName || playerId,
      x: R * Math.sin(phi) * Math.cos(theta),
      y: R * Math.cos(phi),
      z: R * Math.sin(phi) * Math.sin(theta),
      color: 0xFFDD88,
      ts: new Date().toISOString()
    };

    if (typeof localStorage !== 'undefined') {
      try {
        var stored = JSON.parse(localStorage.getItem('zion_playerStars') || '{}');
        stored[playerId] = starData;
        localStorage.setItem('zion_playerStars', JSON.stringify(stored));
      } catch(e) {}
    }
    return starData;
  }

  function initSkybox(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var skyGeo = new THREE.SphereGeometry(800, 32, 32);

    var colors = [];
    var posArray = skyGeo.attributes.position.array;
    for (var i = 0; i < posArray.length; i += 3) {
      var y = posArray[i + 1];
      var normalizedY = (y + 800) / 1600; // 0 at bottom, 1 at top

      var r, g, b;
      if (normalizedY > 0.5) {
        var t = (normalizedY - 0.5) / 0.5;
        r = 0.02 + t * 0.1;
        g = 0.02 + t * 0.3;
        b = 0.2 + t * 0.6;
      } else {
        var t = normalizedY / 0.5;
        r = 1.0 - t * 0.88;
        g = 0.42 - t * 0.1;
        b = 0.21 + t * 0.59;
      }

      colors.push(r, g, b);
    }

    skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    var skyMat = new THREE.MeshBasicMaterial({
      side: THREE.BackSide,
      vertexColors: true,
      fog: false
    });
    skyDome = new THREE.Mesh(skyGeo, skyMat);
    sceneCtx.scene.add(skyDome);

    var CONSTELLATIONS = {
      orion: { stars: [
        {theta:1.55,phi:1.20},{theta:1.60,phi:1.10},{theta:1.58,phi:1.00},
        {theta:1.50,phi:0.95},{theta:1.65,phi:0.95},
        {theta:1.52,phi:0.85},{theta:1.63,phi:0.85}
      ]},
      bigDipper: { stars: [
        {theta:0.80,phi:0.50},{theta:0.85,phi:0.52},{theta:0.92,phi:0.50},
        {theta:0.98,phi:0.53},{theta:1.05,phi:0.48},
        {theta:1.10,phi:0.55},{theta:1.15,phi:0.50}
      ]},
      cassiopeia: { stars: [
        {theta:2.50,phi:0.40},{theta:2.55,phi:0.35},{theta:2.60,phi:0.40},
        {theta:2.65,phi:0.35},{theta:2.70,phi:0.40}
      ]},
      scorpius: { stars: [
        {theta:4.20,phi:1.30},{theta:4.22,phi:1.25},{theta:4.25,phi:1.20},
        {theta:4.27,phi:1.15},{theta:4.30,phi:1.10},
        {theta:4.35,phi:1.12},{theta:4.40,phi:1.15},
        {theta:4.45,phi:1.20},{theta:4.50,phi:1.25}
      ]},
      leo: { stars: [
        {theta:3.10,phi:0.80},{theta:3.15,phi:0.75},{theta:3.20,phi:0.78},
        {theta:3.25,phi:0.82},{theta:3.18,phi:0.88},{theta:3.22,phi:0.85}
      ]},
      southernCross: { stars: [
        {theta:5.00,phi:2.10},{theta:5.05,phi:2.00},{theta:5.00,phi:1.90},
        {theta:4.95,phi:2.00},{theta:5.03,phi:2.00}
      ]}
    };

    var starGeo = new THREE.BufferGeometry();
    var starPos = [];
    var starSizes = [];
    var starColors = [];
    var starPhases = []; // for twinkling

    for (var i = 0; i < 1800; i++) {
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.random() * Math.PI;
      var r = 750;
      starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
      starSizes.push(0.3 + Math.random() * 1.2);
      starColors.push(1.0, 1.0, 1.0); // white
      starPhases.push(Math.random() * Math.PI * 2);
    }

    for (var cKey in CONSTELLATIONS) {
      var cStars = CONSTELLATIONS[cKey].stars;
      for (var cs = 0; cs < cStars.length; cs++) {
        var s = cStars[cs];
        var cr = 750;
        starPos.push(cr * Math.sin(s.phi) * Math.cos(s.theta), cr * Math.cos(s.phi), cr * Math.sin(s.phi) * Math.sin(s.theta));
        starSizes.push(1.8 + Math.random() * 0.5); // brighter
        starColors.push(1.0, 0.95, 0.85); // warm white
        starPhases.push(Math.random() * Math.PI * 2);
      }
    }

    var totalStars = starPos.length / 3;
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
    starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
    starGeo.userData.phases = new Float32Array(starPhases);
    starGeo.userData.baseSizes = new Float32Array(starSizes);
    starGeo.userData.starCount = totalStars;

    var starMat = new THREE.PointsMaterial({
      size: 1.0,
      sizeAttenuation: false,
      transparent: true,
      opacity: 0.0,
      fog: false,
      vertexColors: true
    });

    stars = new THREE.Points(starGeo, starMat);
    sceneCtx.scene.add(stars);

    initPlayerStars(sceneCtx);

    var sunGeo = new THREE.SphereGeometry(5, 16, 16);
    var sunMat = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      fog: false
    });
    sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sceneCtx.scene.add(sunMesh);

    var moonGeo = new THREE.SphereGeometry(3, 16, 16);
    var moonMat = new THREE.MeshBasicMaterial({
      color: 0xccccdd,
      fog: false
    });
    moonMesh = new THREE.Mesh(moonGeo, moonMat);
    sceneCtx.scene.add(moonMesh);
  }

  function updateSkybox(sceneCtx, worldTime) {
    if (!sceneCtx || !sceneCtx.camera) return;

    if (skyDome) {
      skyDome.position.copy(sceneCtx.camera.position);
    }

    var normalizedTime = worldTime / 1440; // 0-1
    var sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2; // -PI/2 at midnight, PI/2 at noon

    if (sunMesh) {
      var sunRadius = 400;
      sunMesh.position.set(
        Math.cos(sunAngle) * sunRadius,
        Math.sin(sunAngle) * sunRadius,
        0
      );
      sunMesh.position.add(sceneCtx.camera.position);
    }

    if (moonMesh) {
      var moonRadius = 400;
      var moonAngle = sunAngle + Math.PI;
      moonMesh.position.set(
        Math.cos(moonAngle) * moonRadius,
        Math.sin(moonAngle) * moonRadius,
        0
      );
      moonMesh.position.add(sceneCtx.camera.position);
    }

    if (stars && stars.material) {
      var opacity = 0.0;

      if (worldTime >= 1080 && worldTime <= 1440) {
        var t = (worldTime - 1080) / 360;
        opacity = Math.min(1.0, t * 2); // Fade in
      } else if (worldTime >= 0 && worldTime < 360) {
        var t = worldTime / 360;
        opacity = Math.max(0.0, 1.0 - t * 2); // Fade out
      } else if (worldTime >= 300 && worldTime < 420) {
        var t = (worldTime - 300) / 120;
        opacity = Math.max(0.0, 1.0 - t);
      } else if (worldTime >= 1020 && worldTime < 1140) {
        var t = (worldTime - 1020) / 120;
        opacity = Math.min(1.0, t);
      }

      stars.material.opacity = opacity;
      stars.material.transparent = true;

      if (opacity > 0.05 && stars.geometry.userData.phases) {
        var phases = stars.geometry.userData.phases;
        var baseSizes = stars.geometry.userData.baseSizes;
        var sizes = stars.geometry.attributes.size.array;
        var twinkleTime = Date.now() * 0.001;
        for (var si = 0; si < phases.length; si++) {
          sizes[si] = baseSizes[si] + Math.sin(twinkleTime * 1.5 + phases[si]) * 0.4;
        }
        stars.geometry.attributes.size.needsUpdate = true;
      }

      stars.position.copy(sceneCtx.camera.position);
    }

    if (playerStarsMesh && playerStarsMesh.material) {
      playerStarsMesh.material.opacity = stars ? stars.material.opacity : 0;
      playerStarsMesh.position.copy(sceneCtx.camera.position);
    }
  }

  var resourceNodes = [];

  function initResourceNodes(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    addZoneResources(sceneCtx.scene, 'gardens', [
      { itemId: 'flower_rose', count: 8, radius: 30 },
      { itemId: 'flower_tulip', count: 10, radius: 35 },
      { itemId: 'flower_sunflower', count: 12, radius: 40 },
      { itemId: 'herb_lavender', count: 8, radius: 28 },
      { itemId: 'seed_wildflower', count: 6, radius: 25 }
    ]);

    addZoneResources(sceneCtx.scene, 'wilds', [
      { itemId: 'wood_oak', count: 15, radius: 45 },
      { itemId: 'wood_pine', count: 12, radius: 50 },
      { itemId: 'stone_common', count: 10, radius: 40 },
      { itemId: 'herb_ginseng', count: 5, radius: 35 },
      { itemId: 'crystal_clear', count: 4, radius: 30 },
      { itemId: 'food_mushroom', count: 8, radius: 38 },
      { itemId: 'food_berry', count: 10, radius: 42 }
    ]);

    addZoneResources(sceneCtx.scene, 'nexus', [
      { itemId: 'crystal_clear', count: 6, radius: 25 },
      { itemId: 'crystal_amethyst', count: 4, radius: 20 }
    ]);

    addZoneResources(sceneCtx.scene, 'studio', [
      { itemId: 'wood_mystical', count: 3, radius: 25 },
      { itemId: 'crystal_clear', count: 5, radius: 22 }
    ]);

    addZoneResources(sceneCtx.scene, 'commons', [
      { itemId: 'wood_oak', count: 8, radius: 25 },
      { itemId: 'stone_common', count: 6, radius: 23 }
    ]);

    addZoneResources(sceneCtx.scene, 'athenaeum', [
      { itemId: 'item_scroll', count: 10, radius: 28 }
    ]);

    addZoneResources(sceneCtx.scene, 'arena', [
      { itemId: 'item_trophy', count: 2, radius: 20 }
    ]);
  }

  function addZoneResources(scene, zoneId, resources) {
    var zone = ZONES[zoneId];
    if (!zone) return;

    resources.forEach(function(res) {
      for (var i = 0; i < res.count; i++) {
        var angle = seededRandom(zoneId.charCodeAt(0), i, res.itemId.charCodeAt(0)) * Math.PI * 2;
        var dist = seededRandom(zoneId.charCodeAt(1), i, res.itemId.charCodeAt(1)) * res.radius;
        var x = zone.cx + Math.cos(angle) * dist;
        var z = zone.cz + Math.sin(angle) * dist;

        var onPath = false;
        for (var pz in ZONES) {
          if (pz === 'nexus') continue;
          if (pointToSegDist(x, z, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[pz].cx, ZONES[pz].cz) < 5) {
            onPath = true;
            break;
          }
        }
        if (onPath) continue;

        var distFromCenter = Math.sqrt((x - zone.cx) * (x - zone.cx) + (z - zone.cz) * (z - zone.cz));
        if (distFromCenter < zone.radius * 0.3) continue;

        var y = terrainHeight(x, z);
        createResourceNode(scene, x, y, z, res.itemId, zoneId);
      }
    });
  }

  function createResourceNode(scene, x, y, z, itemId, zone) {
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var itemData = Inventory.getItemData(itemId);
    if (!itemData) return;

    var nodeGroup = new THREE.Group();
    var nodeMesh;

    if (itemData.type === 'wood') {
      var stumpGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
      var stumpMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      nodeMesh = new THREE.Mesh(stumpGeo, stumpMat);
      nodeMesh.position.y = 0.6;
      nodeGroup.add(nodeMesh);

      var leavesGeo = new THREE.SphereGeometry(0.5, 6, 6);
      var leavesMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50, transparent: true, opacity: 0.7 });
      var leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = 1.4;
      nodeGroup.add(leaves);

    } else if (itemData.type === 'stone') {
      var rockGeo = new THREE.DodecahedronGeometry(0.6, 0);
      var rockMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
      nodeMesh = new THREE.Mesh(rockGeo, rockMat);
      nodeMesh.position.y = 0.4;
      nodeMesh.rotation.set(Math.random(), Math.random(), Math.random());
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'crystal') {
      var crystalGeo = new THREE.OctahedronGeometry(0.5, 0);
      var crystalColor = itemId === 'crystal_amethyst' ? 0x9C27B0 : (itemId === 'crystal_emerald' ? 0x4CAF50 : 0x00BCD4);
      var crystalMat = new THREE.MeshStandardMaterial({
        color: crystalColor,
        emissive: crystalColor,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.8
      });
      nodeMesh = new THREE.Mesh(crystalGeo, crystalMat);
      nodeMesh.position.y = 0.7;
      nodeGroup.add(nodeMesh);

      var glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var glowMat = new THREE.MeshBasicMaterial({ color: crystalColor, transparent: true, opacity: 0.3 });
      var glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 0.7;
      nodeGroup.add(glow);

      animatedObjects.push({ mesh: nodeMesh, type: 'crystal', params: { speed: 0.3, baseY: 0.7 } });

    } else if (itemData.type === 'flowers' || itemData.type === 'herbs') {
      var flowerGeo = new THREE.SphereGeometry(0.3, 6, 6);
      var flowerColors = {
        flower_rose: 0xFF1744, flower_tulip: 0xE91E63, flower_sunflower: 0xFFEB3B,
        flower_lotus: 0xE1BEE7, flower_cherry: 0xF8BBD0,
        herb_mint: 0x4CAF50, herb_sage: 0x66BB6A, herb_ginseng: 0xA1887F, herb_lavender: 0xCE93D8
      };
      var flowerColor = flowerColors[itemId] || 0x4CAF50;
      var flowerMat = new THREE.MeshStandardMaterial({ color: flowerColor });
      nodeMesh = new THREE.Mesh(flowerGeo, flowerMat);
      nodeMesh.position.y = 0.3;
      nodeGroup.add(nodeMesh);

      var stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 4);
      var stemMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
      var stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.15;
      nodeGroup.add(stem);

    } else if (itemData.type === 'seeds') {
      var seedGeo = new THREE.SphereGeometry(0.2, 6, 6);
      var seedMat = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
      nodeMesh = new THREE.Mesh(seedGeo, seedMat);
      nodeMesh.position.y = 0.2;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'food') {
      var foodGeo = new THREE.SphereGeometry(0.25, 6, 6);
      var foodColors = { food_mushroom: 0xD32F2F, food_berry: 0x7B1FA2 };
      var foodColor = foodColors[itemId] || 0x8D6E63;
      var foodMat = new THREE.MeshStandardMaterial({ color: foodColor });
      nodeMesh = new THREE.Mesh(foodGeo, foodMat);
      nodeMesh.position.y = 0.25;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'knowledge') {
      var scrollGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
      var scrollMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC });
      nodeMesh = new THREE.Mesh(scrollGeo, scrollMat);
      nodeMesh.position.y = 0.3;
      nodeMesh.rotation.z = Math.PI / 2;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'trophies') {
      var trophyGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var trophyMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.2 });
      nodeMesh = new THREE.Mesh(trophyGeo, trophyMat);
      nodeMesh.position.y = 0.5;
      nodeGroup.add(nodeMesh);

      var baseGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.3, 8);
      var baseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      var base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.15;
      nodeGroup.add(base);

    } else {
      var genGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
      var genMat = new THREE.MeshStandardMaterial({ color: 0xBDBDBD });
      nodeMesh = new THREE.Mesh(genGeo, genMat);
      nodeMesh.position.y = 0.2;
      nodeGroup.add(nodeMesh);
    }

    nodeGroup.position.set(x, y, z);
    nodeGroup.userData.isResource = true;
    nodeGroup.userData.itemId = itemId;
    nodeGroup.userData.depleted = false;
    nodeGroup.userData.respawnTime = 0;
    nodeGroup.userData.zone = zone;
    nodeGroup.userData.nodeMesh = nodeMesh;

    scene.add(nodeGroup);
    resourceNodes.push(nodeGroup);
  }

  function updateResourceNodes(deltaTime) {
    var currentTime = Date.now();

    resourceNodes.forEach(function(node) {
      if (node.userData.depleted) {
        if (currentTime >= node.userData.respawnTime) {
          node.userData.depleted = false;
          node.visible = true;

          if (node.userData.nodeMesh && node.userData.nodeMesh.material) {
            node.userData.nodeMesh.material.opacity = 1.0;
            node.userData.nodeMesh.material.transparent = false;
          }
        }
      }
    });
  }

  function harvestResource(node) {
    if (!node || !node.userData || !node.userData.isResource) return null;
    if (node.userData.depleted) return null;

    var itemId = node.userData.itemId;

    node.userData.depleted = true;
    node.userData.respawnTime = Date.now() + (30000 + Math.random() * 30000);

    if (node.userData.nodeMesh && node.userData.nodeMesh.material) {
      node.userData.nodeMesh.material.opacity = 0.3;
      node.userData.nodeMesh.material.transparent = true;
    }

    return itemId;
  }

  function getResourceNodeAtMouse(raycaster, camera, mouseX, mouseY) {
    raycaster.setFromCamera({ x: mouseX, y: mouseY }, camera);

    var intersects = raycaster.intersectObjects(resourceNodes, true);
    if (intersects.length > 0) {
      var obj = intersects[0].object;
      while (obj && !obj.userData.isResource) {
        obj = obj.parent;
      }
      return obj && obj.userData.isResource ? obj : null;
    }
    return null;
  }

  var buildMode = false;
  var buildType = 'bench';
  var buildGhost = null;
  var buildRotation = 0;
  var placedBuildings = [];

  function createBuildableModel(type) {
    var group = new THREE.Group();

    switch (type) {
      case 'bench':
        var seatGeo = new THREE.BoxGeometry(1.2, 0.1, 0.4);
        var woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
        var seat = new THREE.Mesh(seatGeo, woodMat);
        seat.position.y = 0.4;
        group.add(seat);
        for (var i = 0; i < 4; i++) {
          var legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
          var leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.x = (i % 2 === 0) ? -0.5 : 0.5;
          leg.position.z = (i < 2) ? -0.15 : 0.15;
          leg.position.y = 0.2;
          group.add(leg);
        }
        break;

      case 'lantern':
        var postGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
        var metalMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
        var post = new THREE.Mesh(postGeo, metalMat);
        post.position.y = 1;
        group.add(post);
        var lightGeo = new THREE.BoxGeometry(0.3, 0.4, 0.3);
        var lightMat = new THREE.MeshStandardMaterial({
          color: 0xffdd88,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5,
          roughness: 0.3
        });
        var light = new THREE.Mesh(lightGeo, lightMat);
        light.position.y = 2.2;
        group.add(light);
        break;

      case 'signpost':
        var signPostGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
        var signPostMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var signPost = new THREE.Mesh(signPostGeo, signPostMat);
        signPost.position.y = 0.75;
        group.add(signPost);
        var boardGeo = new THREE.BoxGeometry(1, 0.4, 0.1);
        var boardMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.7 });
        var board = new THREE.Mesh(boardGeo, boardMat);
        board.position.y = 1.6;
        group.add(board);
        break;

      case 'fence':
        var fencePostGeo = new THREE.CylinderGeometry(0.06, 0.06, 1, 6);
        var fencePostMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var post1 = new THREE.Mesh(fencePostGeo, fencePostMat);
        post1.position.set(-0.4, 0.5, 0);
        group.add(post1);
        var post2 = new THREE.Mesh(fencePostGeo, fencePostMat);
        post2.position.set(0.4, 0.5, 0);
        group.add(post2);
        var barGeo = new THREE.BoxGeometry(1, 0.08, 0.08);
        var bar = new THREE.Mesh(barGeo, fencePostMat);
        bar.position.y = 0.6;
        group.add(bar);
        break;

      case 'planter':
        var planterGeo = new THREE.BoxGeometry(0.8, 0.4, 0.8);
        var planterMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.8 });
        var planter = new THREE.Mesh(planterGeo, planterMat);
        planter.position.y = 0.2;
        group.add(planter);
        var soilGeo = new THREE.BoxGeometry(0.7, 0.1, 0.7);
        var soilMat = new THREE.MeshStandardMaterial({ color: 0x2d5016, roughness: 0.9 });
        var soil = new THREE.Mesh(soilGeo, soilMat);
        soil.position.y = 0.45;
        group.add(soil);
        break;

      case 'campfire':
        for (var j = 0; j < 8; j++) {
          var angle = (j / 8) * Math.PI * 2;
          var stoneGeo = new THREE.BoxGeometry(0.15, 0.1, 0.1);
          var stoneMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.95 });
          var stone = new THREE.Mesh(stoneGeo, stoneMat);
          stone.position.x = Math.cos(angle) * 0.35;
          stone.position.z = Math.sin(angle) * 0.35;
          stone.position.y = 0.05;
          stone.rotation.y = angle;
          group.add(stone);
        }
        var fireGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.3, 6);
        var fireMat = new THREE.MeshStandardMaterial({
          color: 0xff6600,
          emissive: 0xff4400,
          emissiveIntensity: 0.8,
          roughness: 0.2
        });
        var fire = new THREE.Mesh(fireGeo, fireMat);
        fire.position.y = 0.2;
        group.add(fire);
        break;

      case 'archway':
        var pillarGeo = new THREE.BoxGeometry(0.3, 2.5, 0.3);
        var pillarMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e, roughness: 0.7 });
        var pillar1 = new THREE.Mesh(pillarGeo, pillarMat);
        pillar1.position.set(-0.8, 1.25, 0);
        group.add(pillar1);
        var pillar2 = new THREE.Mesh(pillarGeo, pillarMat);
        pillar2.position.set(0.8, 1.25, 0);
        group.add(pillar2);
        var archGeo = new THREE.BoxGeometry(1.9, 0.3, 0.3);
        var arch = new THREE.Mesh(archGeo, pillarMat);
        arch.position.y = 2.6;
        group.add(arch);
        break;

      case 'table':
        var topGeo = new THREE.BoxGeometry(1.2, 0.1, 0.8);
        var tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
        var top = new THREE.Mesh(topGeo, tableMat);
        top.position.y = 0.7;
        group.add(top);
        for (var k = 0; k < 4; k++) {
          var tableLegGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
          var tableLeg = new THREE.Mesh(tableLegGeo, tableMat);
          tableLeg.position.x = (k % 2 === 0) ? -0.5 : 0.5;
          tableLeg.position.z = (k < 2) ? -0.3 : 0.3;
          tableLeg.position.y = 0.35;
          group.add(tableLeg);
        }
        break;

      case 'barrel':
        var barrelGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 12);
        var barrelMat = new THREE.MeshStandardMaterial({ color: 0x6d4c41, roughness: 0.8 });
        var barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.position.y = 0.4;
        group.add(barrel);
        for (var m = 0; m < 2; m++) {
          var bandGeo = new THREE.CylinderGeometry(0.32, 0.36, 0.05, 12);
          var bandMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.5 });
          var band = new THREE.Mesh(bandGeo, bandMat);
          band.position.y = 0.2 + m * 0.4;
          group.add(band);
        }
        break;

      case 'crate':
        var crateGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        var crateMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.9 });
        var crate = new THREE.Mesh(crateGeo, crateMat);
        crate.position.y = 0.3;
        group.add(crate);
        var crossGeo1 = new THREE.BoxGeometry(0.05, 0.05, 0.7);
        var crossMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var cross1 = new THREE.Mesh(crossGeo1, crossMat);
        cross1.position.set(0, 0.3, 0);
        cross1.rotation.y = Math.PI / 4;
        group.add(cross1);
        var cross2 = new THREE.Mesh(crossGeo1, crossMat);
        cross2.position.set(0, 0.3, 0);
        cross2.rotation.y = -Math.PI / 4;
        group.add(cross2);
        break;

      default:
        var defaultGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        var defaultMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
        var defaultMesh = new THREE.Mesh(defaultGeo, defaultMat);
        defaultMesh.position.y = 0.25;
        group.add(defaultMesh);
    }

    return group;
  }

  function enterBuildMode(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    buildMode = true;
    buildRotation = 0;

    buildGhost = createBuildableModel(buildType);
    buildGhost.userData.isGhost = true;

    buildGhost.traverse(function(child) {
      if (child.material) {
        var mat = child.material.clone();
        mat.transparent = true;
        mat.opacity = 0.5;
        mat.depthWrite = false;
        child.material = mat;
      }
    });

    sceneCtx.scene.add(buildGhost);
  }

  function exitBuildMode(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    buildMode = false;

    if (buildGhost) {
      sceneCtx.scene.remove(buildGhost);
      buildGhost.traverse(function(child) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      buildGhost = null;
    }
  }

  function setBuildType(type) {
    buildType = type;
    buildRotation = 0;
  }

  function confirmPlacement(sceneCtx, playerPos, zone) {
    if (!buildMode || !buildGhost || !sceneCtx || !sceneCtx.scene) return null;

    var allowsBuild = (zone === 'commons' || zone === 'studio');
    if (!allowsBuild) {
      return { error: 'This zone does not allow building' };
    }

    var pos = {
      x: buildGhost.position.x,
      y: buildGhost.position.y,
      z: buildGhost.position.z
    };

    var structure = createBuildableModel(buildType);
    structure.position.set(pos.x, pos.y, pos.z);
    structure.rotation.y = buildRotation;
    structure.userData.isBuilding = true;
    structure.userData.buildType = buildType;

    sceneCtx.scene.add(structure);

    var placement = {
      type: buildType,
      x: pos.x,
      y: pos.y,
      z: pos.z,
      rotation: buildRotation
    };
    placedBuildings.push(placement);
    lastPlacedMesh = structure;

    return placement;
  }

  var lastPlacedMesh = null;

  function removeLastPlaced(sceneCtx) {
    if (lastPlacedMesh && sceneCtx && sceneCtx.scene) {
      sceneCtx.scene.remove(lastPlacedMesh);
      placedBuildings.pop();
      lastPlacedMesh = null;
    }
  }

  function updateBuildPreview(sceneCtx, mouseX, mouseY, camera) {
    if (!buildMode || !buildGhost || !sceneCtx || !camera) return;

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(mouseX, mouseY);
    raycaster.setFromCamera(mouse, camera);

    var plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    var hitPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, hitPoint);

    if (hitPoint) {
      var snappedX = Math.round(hitPoint.x / 2) * 2;
      var snappedZ = Math.round(hitPoint.z / 2) * 2;

      var groundY = terrainHeight(snappedX, snappedZ);

      buildGhost.position.set(snappedX, groundY, snappedZ);
      buildGhost.rotation.y = buildRotation;

      var buildZone = getZoneAtPosition(snappedX, snappedZ);
      var isValid = (buildZone === 'commons' || buildZone === 'studio');

      buildGhost.traverse(function(child) {
        if (child.material && child.material.color) {
          if (isValid) {
            child.material.color.setHex(0x00ff00);
          } else {
            child.material.color.setHex(0xff0000);
          }
        }
      });
    }
  }

  function rotateBuildPreview(delta) {
    buildRotation += delta;
    if (buildGhost) {
      buildGhost.rotation.y = buildRotation;
    }
  }

  function getBuildMode() {
    return buildMode;
  }

  var lodStates = new Map(); // objectId -> { level: 0/1/2, hiddenChildren: [] }

  var objectPools = {
    sphere: [],
    cube: [],
    cone: []
  };

  function updateLOD(sceneCtx, playerPos) {
    if (!sceneCtx || !sceneCtx.scene || !playerPos) return;

    var scene = sceneCtx.scene;

    scene.traverse(function(obj) {
      if (!obj.userData || !obj.userData.model_type) return;
      if (!(obj instanceof THREE.Group)) return;

      var objId = obj.uuid;
      var dx = obj.position.x - playerPos.x;
      var dz = obj.position.z - playerPos.z;
      var distance = Math.sqrt(dx * dx + dz * dz);

      var currentState = lodStates.get(objId);
      var newLevel = 0;

      if (distance > 200) {
        newLevel = 2; // hidden
      } else if (distance > 100) {
        newLevel = 1; // simplified
      } else {
        newLevel = 0; // full detail
      }

      if (!currentState || currentState.level !== newLevel) {
        if (newLevel === 2) {
          obj.visible = false;
        } else if (newLevel === 1) {
          obj.visible = true;
          var hiddenChildren = [];
          obj.traverse(function(child) {
            if (child instanceof THREE.Mesh && child !== obj) {
              var vertexCount = 0;
              if (child.geometry && child.geometry.attributes && child.geometry.attributes.position) {
                vertexCount = child.geometry.attributes.position.count;
              }
              if (vertexCount < 50 && child.visible) {
                child.visible = false;
                hiddenChildren.push(child);
              }
            }
          });
          lodStates.set(objId, { level: 1, hiddenChildren: hiddenChildren });
        } else {
          obj.visible = true;
          if (currentState && currentState.hiddenChildren) {
            for (var i = 0; i < currentState.hiddenChildren.length; i++) {
              currentState.hiddenChildren[i].visible = true;
            }
          }
          lodStates.set(objId, { level: 0, hiddenChildren: [] });
        }
      }
    });
  }

  function updateFrustumCulling(sceneCtx) {
    if (!sceneCtx || !sceneCtx.camera) return;

    var camera = sceneCtx.camera;
    camera.updateMatrixWorld();

    var frustum = new THREE.Frustum();
    var projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);

    for (var i = 0; i < animatedObjects.length; i++) {
      var obj = animatedObjects[i];
      if (!obj.mesh) continue;
      try {
        var inFrustum = frustum.intersectsObject(obj.mesh);
        obj.mesh.userData.inFrustum = inFrustum;
      } catch (e) {
        obj.mesh.userData.inFrustum = true; // default visible if check fails
      }
    }

    loadedChunks.forEach(function(chunkData, key) {
      if (!chunkData.group) return;
      try {
        var inFrustum = frustum.intersectsObject(chunkData.group);
        chunkData.group.userData.inFrustum = inFrustum;
      } catch (e) {
        chunkData.group.userData.inFrustum = true;
      }
    });
  }

  function getFromPool(type) {
    var pool = objectPools[type];
    if (!pool) {
      objectPools[type] = [];
      pool = objectPools[type];
    }

    if (pool.length > 0) {
      var obj = pool.pop();
      obj.visible = true;
      return obj;
    }

    var geometry, material, mesh;
    switch (type) {
      case 'sphere':
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      case 'cube':
        geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      case 'cone':
        geometry = new THREE.ConeGeometry(0.1, 0.2, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      default:
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
    }
    return mesh;
  }

  function returnToPool(type, object) {
    if (!object) return;

    var pool = objectPools[type];
    if (!pool) {
      objectPools[type] = [];
      pool = objectPools[type];
    }

    object.visible = false;
    object.position.set(0, 0, 0);
    object.rotation.set(0, 0, 0);
    object.scale.set(1, 1, 1);

    if (pool.length < 1000) {
      pool.push(object);
    } else {
      if (object.geometry) object.geometry.dispose();
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            object.material[i].dispose();
          }
        } else {
          object.material.dispose();
        }
      }
    }
  }

  var interactiveObjects = [];
  var nextInteractiveId = 1;

  var INTERACTIVE_OBJECTS = {
    nexus: [
      { type: 'fountain', position: { x: 0, z: 0 }, action: 'water_source', message: 'The fountain sparkles with pure energy. You feel restored.' },
      { type: 'bulletin_board', position: { x: 15, z: 15 }, action: 'read_announcements', message: 'The bulletin board displays community announcements and events.' }
    ],
    gardens: [
      { type: 'garden_bench', position: { x: 200, z: 40 }, action: 'rest', message: 'You sit on the garden bench, surrounded by fragrant flowers. Your mood improves.' },
      { type: 'watering_well', position: { x: 210, z: 25 }, action: 'gather_water', message: 'The well provides fresh water for the gardens.' }
    ],
    athenaeum: [
      { type: 'reading_desk', position: { x: 100, z: -215 }, action: 'study', message: 'You settle in at the reading desk. Knowledge flows more easily here.' },
      { type: 'bookshelf', position: { x: 105, z: -225 }, action: 'access_lore', message: 'The bookshelf contains ancient tomes and scrolls of wisdom.' }
    ],
    wilds: [
      { type: 'campfire', position: { x: -30, z: 265 }, action: 'warmth_cooking', message: 'The campfire crackles warmly. A perfect spot for cooking and gathering.' },
      { type: 'fallen_log', position: { x: -25, z: 255 }, action: 'sit', message: 'You sit on the weathered log, taking in the wild surroundings.' }
    ],
    agora: [
      { type: 'market_stall', position: { x: -185, z: 120 }, action: 'browse_goods', message: 'The market stall displays various wares and goods for trade.' },
      { type: 'town_bell', position: { x: -190, z: 125 }, action: 'ring_bell', message: 'CLANG! The town bell rings out across the agora.' }
    ],
    commons: [
      { type: 'park_bench', position: { x: 170, z: 195 }, action: 'socialize', message: 'A comfortable bench, perfect for meeting with friends.' },
      { type: 'street_lamp', position: { x: 175, z: 185 }, action: 'light', message: 'The street lamp provides warm light in the evening hours.' }
    ],
    arena: [
      { type: 'training_dummy', position: { x: 5, z: -240 }, action: 'practice_combat', message: 'The training dummy stands ready. Time to practice your skills.' },
      { type: 'spectator_bench', position: { x: -5, z: -235 }, action: 'watch_fights', message: 'From here, you have a great view of the arena floor.' }
    ],
    studio: [
      { type: 'easel', position: { x: -200, z: -95 }, action: 'create_art', message: 'The easel stands ready. Your creativity flows here.' },
      { type: 'piano', position: { x: -205, z: -105 }, action: 'play_music', message: 'The piano is perfectly tuned. Music fills the studio.' }
    ]
  };

  function createInteractiveObject(type, position) {
    var group = new THREE.Group();
    var baseY = getTerrainHeight(position.x, position.z) || 0;

    if (type === 'garden_bench' || type === 'park_bench' || type === 'spectator_bench') {
      var seatGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
      var benchMat = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
      var seat = new THREE.Mesh(seatGeo, benchMat);
      seat.position.set(0, 0.4, 0);
      seat.castShadow = true;
      group.add(seat);

      for (var i = -1; i <= 1; i += 2) {
        for (var j = -1; j <= 1; j += 2) {
          var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8);
          var leg = new THREE.Mesh(legGeo, benchMat);
          leg.position.set(i * 1.0, 0.2, j * 0.3);
          leg.castShadow = true;
          group.add(leg);
        }
      }

      var backGeo = new THREE.BoxGeometry(2.5, 0.8, 0.15);
      var back = new THREE.Mesh(backGeo, benchMat);
      back.position.set(0, 0.9, -0.4);
      back.castShadow = true;
      group.add(back);

    } else if (type === 'campfire') {
      var pitGeo = new THREE.CylinderGeometry(0.8, 0.9, 0.3, 12);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var pit = new THREE.Mesh(pitGeo, stoneMat);
      pit.position.set(0, 0.15, 0);
      pit.castShadow = true;
      group.add(pit);

      var logMat = new THREE.MeshPhongMaterial({ color: 0x4a2511 });
      for (var l = 0; l < 4; l++) {
        var angle = (l / 4) * Math.PI * 2;
        var logGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
        var log = new THREE.Mesh(logGeo, logMat);
        log.position.set(Math.cos(angle) * 0.2, 0.5, Math.sin(angle) * 0.2);
        log.rotation.z = Math.PI / 6;
        log.rotation.y = angle;
        log.castShadow = true;
        group.add(log);
      }

      var fireLight = new THREE.PointLight(0xff6600, 1.5, 10);
      fireLight.position.set(0, 1, 0);
      fireLight.castShadow = false;
      group.add(fireLight);

      group.userData.fireLight = fireLight;

    } else if (type === 'fountain') {
      var baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.8, 16);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0xc0c0d0 });
      var base = new THREE.Mesh(baseGeo, stoneMat);
      base.position.set(0, 0.4, 0);
      base.castShadow = true;
      group.add(base);

      var midGeo = new THREE.CylinderGeometry(1.2, 1.5, 0.5, 16);
      var mid = new THREE.Mesh(midGeo, stoneMat);
      mid.position.set(0, 1.2, 0);
      mid.castShadow = true;
      group.add(mid);

      var topGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 16);
      var top = new THREE.Mesh(topGeo, stoneMat);
      top.position.set(0, 1.8, 0);
      top.castShadow = true;
      group.add(top);

      var waterGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.2, 24);
      var waterMat = new THREE.MeshStandardMaterial({
        color: 0x4488ff,
        emissive: 0x2244aa,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.7
      });
      var water = new THREE.Mesh(waterGeo, waterMat);
      water.position.set(0, 0.8, 0);
      water.castShadow = false;
      group.add(water);

    } else if (type === 'training_dummy') {
      var baseGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 12);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var base = new THREE.Mesh(baseGeo, woodMat);
      base.position.set(0, 0.15, 0);
      base.castShadow = true;
      group.add(base);

      var postGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
      var post = new THREE.Mesh(postGeo, woodMat);
      post.position.set(0, 1.4, 0);
      post.castShadow = true;
      group.add(post);

      var bodyGeo = new THREE.CylinderGeometry(0.4, 0.45, 1.2, 12);
      var burlapMat = new THREE.MeshPhongMaterial({ color: 0xc4a574 });
      var body = new THREE.Mesh(bodyGeo, burlapMat);
      body.position.set(0, 1.8, 0);
      body.castShadow = true;
      group.add(body);

      var headGeo = new THREE.SphereGeometry(0.3, 12, 12);
      var head = new THREE.Mesh(headGeo, burlapMat);
      head.position.set(0, 2.6, 0);
      head.castShadow = true;
      group.add(head);

    } else if (type === 'fallen_log') {
      var logGeo = new THREE.CylinderGeometry(0.4, 0.45, 3, 12);
      var barkMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var log = new THREE.Mesh(logGeo, barkMat);
      log.position.set(0, 0.4, 0);
      log.rotation.z = Math.PI / 2;
      log.castShadow = true;
      group.add(log);

    } else if (type === 'bulletin_board') {
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var p = -1; p <= 1; p += 2) {
        var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
        var post = new THREE.Mesh(postGeo, postMat);
        post.position.set(p * 0.8, 1.25, 0);
        post.castShadow = true;
        group.add(post);
      }

      var boardGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
      var boardMat = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
      var board = new THREE.Mesh(boardGeo, boardMat);
      board.position.set(0, 1.5, 0);
      board.castShadow = true;
      group.add(board);

    } else if (type === 'watering_well') {
      var wellGeo = new THREE.CylinderGeometry(1, 1.2, 1.5, 16);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var well = new THREE.Mesh(wellGeo, stoneMat);
      well.position.set(0, 0.75, 0);
      well.castShadow = true;
      group.add(well);

      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var w = -1; w <= 1; w += 2) {
        var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
        var post = new THREE.Mesh(postGeo, postMat);
        post.position.set(w * 0.8, 1.75, 0);
        post.castShadow = true;
        group.add(post);
      }

      var roofGeo = new THREE.ConeGeometry(1.2, 0.8, 4);
      var roofMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.set(0, 3.2, 0);
      roof.castShadow = true;
      group.add(roof);

    } else if (type === 'reading_desk') {
      var topGeo = new THREE.BoxGeometry(1.5, 0.1, 1);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var top = new THREE.Mesh(topGeo, woodMat);
      top.position.set(0, 0.8, 0);
      top.castShadow = true;
      group.add(top);

      for (var dx = -1; dx <= 1; dx += 2) {
        for (var dz = -1; dz <= 1; dz += 2) {
          var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
          var leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.set(dx * 0.6, 0.4, dz * 0.4);
          leg.castShadow = true;
          group.add(leg);
        }
      }

      var bookGeo = new THREE.BoxGeometry(0.3, 0.05, 0.4);
      var bookMat = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
      var book = new THREE.Mesh(bookGeo, bookMat);
      book.position.set(0, 0.88, 0);
      book.rotation.y = Math.PI / 6;
      book.castShadow = true;
      group.add(book);

    } else if (type === 'bookshelf') {
      var frameMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var shelfGeo = new THREE.BoxGeometry(2, 2.5, 0.4);
      var shelf = new THREE.Mesh(shelfGeo, frameMat);
      shelf.position.set(0, 1.25, 0);
      shelf.castShadow = true;
      group.add(shelf);

      var bookColors = [0x8b0000, 0x006400, 0x00008b, 0x8b4513, 0x4b0082];
      for (var row = 0; row < 3; row++) {
        for (var col = 0; col < 5; col++) {
          var bookGeo = new THREE.BoxGeometry(0.3, 0.6, 0.15);
          var bookMat = new THREE.MeshPhongMaterial({ color: bookColors[(row + col) % bookColors.length] });
          var book = new THREE.Mesh(bookGeo, bookMat);
          book.position.set(-0.7 + col * 0.35, 0.3 + row * 0.7, 0.1);
          book.castShadow = true;
          group.add(book);
        }
      }

    } else if (type === 'market_stall') {
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var mx = -1; mx <= 1; mx += 2) {
        for (var mz = -1; mz <= 1; mz += 2) {
          var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
          var post = new THREE.Mesh(postGeo, postMat);
          post.position.set(mx * 1, 1.25, mz * 1);
          post.castShadow = true;
          group.add(post);
        }
      }

      var canopyGeo = new THREE.BoxGeometry(2.5, 0.1, 2.5);
      var canopyMat = new THREE.MeshPhongMaterial({ color: 0xd2691e });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.set(0, 2.5, 0);
      canopy.castShadow = true;
      group.add(canopy);

      var counterGeo = new THREE.BoxGeometry(2, 0.8, 1);
      var counterMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var counter = new THREE.Mesh(counterGeo, counterMat);
      counter.position.set(0, 0.4, 0);
      counter.castShadow = true;
      group.add(counter);

    } else if (type === 'town_bell') {
      var postGeo = new THREE.CylinderGeometry(0.15, 0.2, 3, 8);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      var post = new THREE.Mesh(postGeo, woodMat);
      post.position.set(0, 1.5, 0);
      post.castShadow = true;
      group.add(post);

      var beamGeo = new THREE.BoxGeometry(1.5, 0.15, 0.15);
      var beam = new THREE.Mesh(beamGeo, woodMat);
      beam.position.set(0, 2.8, 0);
      beam.castShadow = true;
      group.add(beam);

      var bellGeo = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      var bellMat = new THREE.MeshPhongMaterial({ color: 0xb8860b });
      var bell = new THREE.Mesh(bellGeo, bellMat);
      bell.position.set(0, 2.5, 0);
      bell.rotation.x = Math.PI;
      bell.castShadow = true;
      group.add(bell);

    } else if (type === 'street_lamp') {
      var postGeo = new THREE.CylinderGeometry(0.08, 0.1, 3, 8);
      var metalMat = new THREE.MeshPhongMaterial({ color: 0x2f2f2f });
      var post = new THREE.Mesh(postGeo, metalMat);
      post.position.set(0, 1.5, 0);
      post.castShadow = true;
      group.add(post);

      var housingGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 6);
      var housingMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
      var housing = new THREE.Mesh(housingGeo, housingMat);
      housing.position.set(0, 3.2, 0);
      housing.castShadow = true;
      group.add(housing);

      var lampLight = new THREE.PointLight(0xffdd88, 1.0, 12);
      lampLight.position.set(0, 3, 0);
      lampLight.castShadow = false;
      group.add(lampLight);

      group.userData.lampLight = lampLight;

    } else if (type === 'easel') {
      var legMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var leg1Geo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 8);
      var leg1 = new THREE.Mesh(leg1Geo, legMat);
      leg1.position.set(0, 0.9, 0.3);
      leg1.rotation.x = -0.2;
      leg1.castShadow = true;
      group.add(leg1);

      var leg2 = new THREE.Mesh(leg1Geo, legMat);
      leg2.position.set(-0.3, 0.9, -0.2);
      leg2.rotation.z = 0.2;
      leg2.rotation.x = 0.2;
      leg2.castShadow = true;
      group.add(leg2);

      var leg3 = new THREE.Mesh(leg1Geo, legMat);
      leg3.position.set(0.3, 0.9, -0.2);
      leg3.rotation.z = -0.2;
      leg3.rotation.x = 0.2;
      leg3.castShadow = true;
      group.add(leg3);

      var canvasGeo = new THREE.BoxGeometry(1, 1.2, 0.05);
      var canvasMat = new THREE.MeshPhongMaterial({ color: 0xf5f5dc });
      var canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.set(0, 1.4, 0.2);
      canvas.rotation.x = -0.1;
      canvas.castShadow = true;
      group.add(canvas);

    } else if (type === 'piano') {
      var bodyGeo = new THREE.BoxGeometry(1.5, 0.8, 1);
      var pianoMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
      var body = new THREE.Mesh(bodyGeo, pianoMat);
      body.position.set(0, 0.4, 0);
      body.castShadow = true;
      group.add(body);

      var keyboardGeo = new THREE.BoxGeometry(1.3, 0.05, 0.3);
      var keyboardMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
      var keyboard = new THREE.Mesh(keyboardGeo, keyboardMat);
      keyboard.position.set(0, 0.85, 0.4);
      keyboard.castShadow = true;
      group.add(keyboard);

      for (var px = -1; px <= 1; px += 2) {
        for (var pz = -1; pz <= 1; pz += 2) {
          var legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
          var leg = new THREE.Mesh(legGeo, pianoMat);
          leg.position.set(px * 0.6, 0.2, pz * 0.4);
          leg.castShadow = true;
          group.add(leg);
        }
      }
    }

    group.position.set(position.x, baseY, position.z);

    group.userData.isInteractive = true;
    group.userData.interactiveType = type;
    group.userData.originalEmissive = 0x000000;
    group.userData.highlighted = false;

    return group;
  }

  function spawnZoneInteractives(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (!INTERACTIVE_OBJECTS[zoneId]) return;

    var zoneObjects = INTERACTIVE_OBJECTS[zoneId];
    for (var i = 0; i < zoneObjects.length; i++) {
      var objDef = zoneObjects[i];
      var mesh = createInteractiveObject(objDef.type, objDef.position);

      if (mesh) {
        sceneCtx.scene.add(mesh);

        var interactiveData = {
          id: nextInteractiveId++,
          type: objDef.type,
          position: objDef.position,
          action: objDef.action,
          message: objDef.message,
          mesh: mesh,
          zone: zoneId
        };

        interactiveObjects.push(interactiveData);
        mesh.userData.interactiveId = interactiveData.id;
      }
    }
  }

  function getInteractiveAtPosition(x, z, range) {
    var nearestObj = null;
    var minDist = range;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      var dx = obj.position.x - x;
      var dz = obj.position.z - z;
      var dist = Math.sqrt(dx * dx + dz * dz);

      if (dist < minDist) {
        minDist = dist;
        nearestObj = obj;
      }
    }

    return nearestObj;
  }

  function interactWithObject(objectId) {
    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (obj.id === objectId) {
        return {
          type: obj.type,
          action: obj.action,
          message: obj.message,
          zone: obj.zone
        };
      }
    }
    return null;
  }

  function updateInteractiveHighlights(playerX, playerZ, highlightRange) {
    if (!highlightRange) highlightRange = 3;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (!obj.mesh) continue;

      var dx = obj.position.x - playerX;
      var dz = obj.position.z - playerZ;
      var dist = Math.sqrt(dx * dx + dz * dz);

      var shouldHighlight = dist < highlightRange;

      if (shouldHighlight && !obj.mesh.userData.highlighted) {
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh && child.material) {
            if (child.material.emissive) {
              child.userData.originalEmissive = child.material.emissive.getHex();
              child.material.emissive.setHex(0x444400);
              child.material.emissiveIntensity = 0.3;
            }
          }
        });
        obj.mesh.userData.highlighted = true;
      } else if (!shouldHighlight && obj.mesh.userData.highlighted) {
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh && child.material) {
            if (child.material.emissive && child.userData.originalEmissive !== undefined) {
              child.material.emissive.setHex(child.userData.originalEmissive);
              child.material.emissiveIntensity = 0;
            }
          }
        });
        obj.mesh.userData.highlighted = false;
      }
    }
  }

  function updateInteractiveAnimations(deltaTime) {
    var time = Date.now() * 0.001;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (!obj.mesh) continue;

      if (obj.type === 'campfire' && obj.mesh.userData.fireLight) {
        var flicker = Math.sin(time * 5) * 0.3 + Math.sin(time * 13) * 0.2;
        obj.mesh.userData.fireLight.intensity = 1.5 + flicker;
      }

      if (obj.type === 'street_lamp' && obj.mesh.userData.lampLight) {
        var sway = Math.sin(time * 0.5) * 0.05;
        obj.mesh.userData.lampLight.intensity = 1.0 + sway;
      }
    }
  }

  function clearInteractiveObjects(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (obj.mesh) {
        sceneCtx.scene.remove(obj.mesh);

        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                for (var m = 0; m < child.material.length; m++) {
                  child.material[m].dispose();
                }
              } else {
                child.material.dispose();
              }
            }
          }
        });
      }
    }

    interactiveObjects = [];
    nextInteractiveId = 1;
  }

  function getZoneInteractives(zoneId) {
    var result = [];
    for (var i = 0; i < interactiveObjects.length; i++) {
      if (interactiveObjects[i].zone === zoneId) {
        result.push(interactiveObjects[i]);
      }
    }
    return result;
  }

  var highlightedObject = null;
  var originalMaterials = new Map();

  function highlightObject(mesh) {
    if (!mesh) return;
    if (highlightedObject === mesh) return;

    unhighlightObject();

    highlightedObject = mesh;

    mesh.traverse(function(child) {
      if (child.isMesh && child.material) {
        originalMaterials.set(child, {
          emissive: child.material.emissive ? child.material.emissive.clone() : null,
          emissiveIntensity: child.material.emissiveIntensity || 0
        });

        if (child.material.emissive) {
          child.material.emissive.set(0xDAA520); // Golden color
          child.material.emissiveIntensity = 0.4;
        }
      }
    });
  }

  function unhighlightObject() {
    if (!highlightedObject) return;

    highlightedObject.traverse(function(child) {
      if (child.isMesh && originalMaterials.has(child)) {
        var orig = originalMaterials.get(child);
        if (orig.emissive && child.material.emissive) {
          child.material.emissive.copy(orig.emissive);
        }
        child.material.emissiveIntensity = orig.emissiveIntensity;
      }
    });

    originalMaterials.clear();
    highlightedObject = null;
  }

  function getPerformanceStats() {
    var stats = {
      totalObjects: 0,
      visibleObjects: 0,
      activeAnimations: 0,
      loadedChunks: loadedChunks.size,
      estimatedTriangles: 0
    };

    if (sceneContext && sceneContext.scene) {
      sceneContext.scene.traverse(function(obj) {
        stats.totalObjects++;
        if (obj.visible) {
          stats.visibleObjects++;
        }
        if (obj instanceof THREE.Mesh && obj.geometry) {
          if (obj.geometry.index) {
            stats.estimatedTriangles += obj.geometry.index.count / 3;
          } else if (obj.geometry.attributes && obj.geometry.attributes.position) {
            stats.estimatedTriangles += obj.geometry.attributes.position.count / 3;
          }
        }
      });
    }

    for (var i = 0; i < animatedObjects.length; i++) {
      if (animatedObjects[i].mesh && animatedObjects[i].mesh.userData.inFrustum !== false) {
        stats.activeAnimations++;
      }
    }

    stats.estimatedTriangles = Math.floor(stats.estimatedTriangles);

    return stats;
  }

  var zoneBoundaryParticles = [];
  var fadeOverlay = null;

  function fadeTransition(callback) {
    if (typeof document === 'undefined') {
      if (callback) callback();
      return;
    }

    if (!fadeOverlay) {
      fadeOverlay = document.createElement('div');
      fadeOverlay.style.position = 'fixed';
      fadeOverlay.style.top = '0';
      fadeOverlay.style.left = '0';
      fadeOverlay.style.width = '100%';
      fadeOverlay.style.height = '100%';
      fadeOverlay.style.backgroundColor = 'black';
      fadeOverlay.style.opacity = '0';
      fadeOverlay.style.pointerEvents = 'none';
      fadeOverlay.style.zIndex = '9999';
      fadeOverlay.style.transition = 'opacity 0.5s ease-in-out';
      document.body.appendChild(fadeOverlay);
    }

    fadeOverlay.style.opacity = '1';

    setTimeout(function() {
      if (callback) callback();

      setTimeout(function() {
        fadeOverlay.style.opacity = '0';
      }, 50);
    }, 500);
  }

  function createZoneBoundaryParticles(scene) {
    if (!scene) return;

    for (var i = 0; i < zoneBoundaryParticles.length; i++) {
      scene.remove(zoneBoundaryParticles[i].mesh);
    }
    zoneBoundaryParticles = [];

    for (var zId in ZONES) {
      var zone = ZONES[zId];
      var particleCount = Math.floor(zone.radius / 3);

      for (var i = 0; i < particleCount; i++) {
        var angle = (i / particleCount) * Math.PI * 2;
        var radius = zone.radius * 0.95;
        var px = zone.cx + Math.cos(angle) * radius;
        var pz = zone.cz + Math.sin(angle) * radius;
        var py = terrainHeight(px, pz) + 2 + Math.random() * 3;

        var particleGeo = new THREE.SphereGeometry(0.1, 6, 6);
        var particleMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.6,
          transparent: true,
          opacity: 0.4
        });
        var particle = new THREE.Mesh(particleGeo, particleMat);
        particle.position.set(px, py, pz);
        particle.castShadow = false;
        scene.add(particle);

        zoneBoundaryParticles.push({
          mesh: particle,
          baseY: py,
          phase: Math.random() * Math.PI * 2,
          speed: 0.0005 + Math.random() * 0.0003
        });
      }
    }
  }

  function updateZoneBoundaryParticles(time) {
    for (var i = 0; i < zoneBoundaryParticles.length; i++) {
      var p = zoneBoundaryParticles[i];
      p.mesh.position.y = p.baseY + Math.sin(time * p.speed + p.phase) * 0.5;
      p.mesh.material.opacity = 0.3 + Math.sin(time * p.speed * 2 + p.phase) * 0.15;
    }
  }

  var wildlifeData = {
    butterflies: [],
    fireflies: [],
    birds: [],
    fishJumpers: [],
    initialized: false
  };

  function initWildlife(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var scene = sceneCtx.scene;

    clearWildlife(scene);

    var gardensZ = ZONES.gardens;
    var butterflyColors = [0xffff00, 0xffa500, 0x4169e1, 0xffffff, 0xff69b4];

    for (var i = 0; i < 7; i++) {
      var bfGeo = new THREE.BufferGeometry();
      var bfVerts = new Float32Array([0,0,0, 0.3,0,0.2, 0,0,0.4]);
      bfGeo.setAttribute('position', new THREE.BufferAttribute(bfVerts, 3));
      var bfMat = new THREE.MeshBasicMaterial({
        color: butterflyColors[i % butterflyColors.length],
        side: THREE.DoubleSide
      });
      var bf = new THREE.Mesh(bfGeo, bfMat);
      var angle = Math.random() * Math.PI * 2;
      var radius = Math.random() * gardensZ.radius * 0.6;
      bf.position.set(
        gardensZ.cx + Math.cos(angle) * radius,
        gardensZ.baseHeight + 1 + Math.random() * 2,
        gardensZ.cz + Math.sin(angle) * radius
      );
      scene.add(bf);
      wildlifeData.butterflies.push({
        mesh: bf, time: Math.random() * 100,
        speed: 0.5 + Math.random() * 0.5,
        pathAngle: Math.random() * Math.PI * 2,
        pathRadius: 10 + Math.random() * 15,
        baseY: bf.position.y,
        centerX: gardensZ.cx, centerZ: gardensZ.cz
      });
    }

    var ffZones = [
      { zone: ZONES.gardens, count: 8 },
      { zone: ZONES.wilds, count: 10 },
      { zone: ZONES.commons, count: 4 },
      { zone: ZONES.nexus, count: 3 }
    ];
    for (var zi = 0; zi < ffZones.length; zi++) {
      var zInfo = ffZones[zi];
      for (var fi = 0; fi < zInfo.count; fi++) {
        var ffGeo = new THREE.SphereGeometry(0.15, 8, 8);
        var ffMat = new THREE.MeshBasicMaterial({
          color: 0xffff99, transparent: true, opacity: 0
        });
        var ff = new THREE.Mesh(ffGeo, ffMat);
        var ffA = Math.random() * Math.PI * 2;
        var ffR = Math.random() * zInfo.zone.radius * 0.7;
        ff.position.set(
          zInfo.zone.cx + Math.cos(ffA) * ffR,
          zInfo.zone.baseHeight + 0.5 + Math.random() * 3,
          zInfo.zone.cz + Math.sin(ffA) * ffR
        );
        scene.add(ff);
        wildlifeData.fireflies.push({
          mesh: ff, time: Math.random() * 100,
          speed: 0.3 + Math.random() * 0.3,
          pulseSpeed: 2 + Math.random() * 2,
          baseY: ff.position.y,
          driftAngle: Math.random() * Math.PI * 2
        });
      }
    }

    for (var fli = 0; fli < 3; fli++) {
      var flock = {
        birds: [], centerAngle: (fli / 3) * Math.PI * 2,
        orbitRadius: 200, speed: 0.1 + Math.random() * 0.05,
        height: 40 + Math.random() * 20
      };
      var birdOffsets = [
        {x:0,z:0}, {x:-2,z:-3}, {x:-4,z:-6}, {x:2,z:-3}, {x:4,z:-6}
      ];
      for (var bi = 0; bi < birdOffsets.length; bi++) {
        var bGeo = new THREE.BufferGeometry();
        var bVerts = new Float32Array([0,0,0, -0.4,0,0.3, 0.4,0,0.3]);
        bGeo.setAttribute('position', new THREE.BufferAttribute(bVerts, 3));
        var bMat = new THREE.MeshBasicMaterial({
          color: 0x2c2c2c, side: THREE.DoubleSide
        });
        var bMesh = new THREE.Mesh(bGeo, bMat);
        bMesh.position.y = flock.height;
        scene.add(bMesh);
        flock.birds.push({
          mesh: bMesh, offsetX: birdOffsets[bi].x,
          offsetZ: birdOffsets[bi].z, flapTime: Math.random() * 10
        });
      }
      wildlifeData.birds.push(flock);
    }

    for (var fsi = 0; fsi < 3; fsi++) {
      var fGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var fMat = new THREE.MeshBasicMaterial({
        color: 0x888888, transparent: true, opacity: 0
      });
      var fMesh = new THREE.Mesh(fGeo, fMat);
      scene.add(fMesh);
      wildlifeData.fishJumpers.push({
        mesh: fMesh, jumping: false, jumpTime: 0, jumpDuration: 0,
        startX: 0, startZ: 0, endX: 0, endZ: 0, waterHeight: 0,
        nextJumpDelay: Math.random() * 5 + 3
      });
    }

    wildlifeData.initialized = true;
  }

  function updateWildlife(sceneCtx, deltaTime, worldTime) {
    if (!wildlifeData.initialized || !sceneCtx) return;

    var isNight = worldTime > 1080 || worldTime < 360;
    var isDay = worldTime >= 360 && worldTime <= 1080;

    for (var i = 0; i < wildlifeData.butterflies.length; i++) {
      var bf = wildlifeData.butterflies[i];
      bf.time += deltaTime * bf.speed;
      bf.mesh.visible = isDay;
      if (isDay) {
        bf.pathAngle += deltaTime * 0.3;
        var tx = bf.centerX + Math.cos(bf.pathAngle) * bf.pathRadius;
        var tz = bf.centerZ + Math.sin(bf.pathAngle) * bf.pathRadius;
        bf.mesh.position.x += (tx - bf.mesh.position.x) * 0.02;
        bf.mesh.position.z += (tz - bf.mesh.position.z) * 0.02;
        bf.mesh.position.y = bf.baseY + Math.sin(bf.time * 5) * 0.3;
        bf.mesh.rotation.y = Math.sin(bf.time * 8) * 0.3;
        bf.mesh.rotation.z = Math.sin(bf.time * 6) * 0.2;
      }
    }

    for (var fi = 0; fi < wildlifeData.fireflies.length; fi++) {
      var ff = wildlifeData.fireflies[fi];
      ff.time += deltaTime;
      if (isNight) {
        var pulse = 0.5 + Math.sin(ff.time * ff.pulseSpeed) * 0.5;
        ff.mesh.material.opacity = pulse * 0.8;
        ff.mesh.visible = true;
        ff.driftAngle += deltaTime * 0.2;
        ff.mesh.position.x += Math.cos(ff.driftAngle) * deltaTime * ff.speed;
        ff.mesh.position.z += Math.sin(ff.driftAngle) * deltaTime * ff.speed;
        ff.mesh.position.y = ff.baseY + Math.sin(ff.time * 0.5) * 0.5;
      } else {
        ff.mesh.material.opacity = 0;
        ff.mesh.visible = false;
      }
    }

    for (var fli = 0; fli < wildlifeData.birds.length; fli++) {
      var flock = wildlifeData.birds[fli];
      flock.centerAngle += deltaTime * flock.speed;
      var fcx = Math.cos(flock.centerAngle) * flock.orbitRadius;
      var fcz = 150 + Math.sin(flock.centerAngle) * flock.orbitRadius;
      for (var bi = 0; bi < flock.birds.length; bi++) {
        var bd = flock.birds[bi];
        bd.flapTime += deltaTime * 5;
        bd.mesh.visible = isDay;
        if (isDay) {
          var fa = flock.centerAngle;
          var rox = Math.cos(fa) * bd.offsetX - Math.sin(fa) * bd.offsetZ;
          var roz = Math.sin(fa) * bd.offsetX + Math.cos(fa) * bd.offsetZ;
          bd.mesh.position.set(fcx + rox, flock.height + Math.sin(bd.flapTime) * 0.5, fcz + roz);
          bd.mesh.rotation.y = fa + Math.PI / 2;
          bd.mesh.rotation.z = Math.sin(bd.flapTime * 2) * 0.1;
        }
      }
    }

    if (waterBodies && waterBodies.length > 0) {
      for (var fsi = 0; fsi < wildlifeData.fishJumpers.length; fsi++) {
        var fish = wildlifeData.fishJumpers[fsi];
        if (fish.jumping) {
          fish.jumpTime += deltaTime;
          var prog = fish.jumpTime / fish.jumpDuration;
          if (prog >= 1) {
            fish.jumping = false;
            fish.mesh.material.opacity = 0;
            fish.mesh.visible = false;
            fish.nextJumpDelay = Math.random() * 8 + 5;
          } else {
            fish.mesh.position.x = fish.startX + (fish.endX - fish.startX) * prog;
            fish.mesh.position.z = fish.startZ + (fish.endZ - fish.startZ) * prog;
            fish.mesh.position.y = fish.waterHeight + Math.sin(prog * Math.PI) * 2;
            fish.mesh.material.opacity = 1;
            fish.mesh.visible = true;
          }
        } else {
          fish.nextJumpDelay -= deltaTime;
          if (fish.nextJumpDelay <= 0) {
            var wb = waterBodies[Math.floor(Math.random() * waterBodies.length)];
            var ja = Math.random() * Math.PI * 2;
            var jr = Math.random() * 10;
            fish.startX = wb.centerX + Math.cos(ja) * jr;
            fish.startZ = wb.centerZ + Math.sin(ja) * jr;
            fish.waterHeight = wb.height;
            var jd = Math.random() * Math.PI * 2;
            var jDist = 1 + Math.random() * 2;
            fish.endX = fish.startX + Math.cos(jd) * jDist;
            fish.endZ = fish.startZ + Math.sin(jd) * jDist;
            fish.jumping = true;
            fish.jumpTime = 0;
            fish.jumpDuration = 0.8 + Math.random() * 0.4;
          }
        }
      }
    }
  }

  function clearWildlife(scene) {
    if (!scene) return;
    var groups = ['butterflies', 'fireflies', 'fishJumpers'];
    for (var g = 0; g < groups.length; g++) {
      var arr = wildlifeData[groups[g]];
      for (var i = 0; i < arr.length; i++) {
        scene.remove(arr[i].mesh);
        if (arr[i].mesh.geometry) arr[i].mesh.geometry.dispose();
        if (arr[i].mesh.material) arr[i].mesh.material.dispose();
      }
    }
    for (var fli = 0; fli < wildlifeData.birds.length; fli++) {
      var flock = wildlifeData.birds[fli];
      for (var bi = 0; bi < flock.birds.length; bi++) {
        scene.remove(flock.birds[bi].mesh);
        if (flock.birds[bi].mesh.geometry) flock.birds[bi].mesh.geometry.dispose();
        if (flock.birds[bi].mesh.material) flock.birds[bi].mesh.material.dispose();
      }
    }
    wildlifeData.butterflies = [];
    wildlifeData.fireflies = [];
    wildlifeData.birds = [];
    wildlifeData.fishJumpers = [];
    wildlifeData.initialized = false;
  }

  var zoneAmbienceData = {
    initialized: false,
    particles: {} // zone name -> { points, velocities, offsets }
  };

  function initZoneAmbience(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var scene = sceneCtx.scene;
    zoneAmbienceData.particles = {};

    var configs = {
      nexus: {
        count: 40,
        color: 0xffd700, // golden
        size: 0.3,
        rangeX: 50, rangeY: 30, rangeZ: 50,
        velocityY: 0.5, // slow upward drift
        velocityX: 0.1, velocityZ: 0.1
      },
      gardens: {
        count: 50,
        color: 0x90ee90, // light green
        size: 0.25,
        rangeX: 70, rangeY: 25, rangeZ: 70,
        velocityY: 0.2,
        velocityX: 0.3, velocityZ: 0.2 // wind drift
      },
      athenaeum: {
        count: 35,
        color: 0x87ceeb, // sky blue
        size: 0.2,
        rangeX: 50, rangeY: 35, rangeZ: 50,
        velocityY: 0.15,
        velocityX: 0.05, velocityZ: 0.05
      },
      studio: {
        count: 45,
        color: null, // multi-color, set per particle
        size: 0.3,
        rangeX: 50, rangeY: 30, rangeZ: 50,
        velocityY: 0.25,
        velocityX: 0.15, velocityZ: 0.15
      },
      wilds: {
        count: 40,
        color: 0xffffff, // white mist
        size: 0.4,
        rangeX: 80, rangeY: 8, rangeZ: 80, // ground-level
        velocityY: 0.05,
        velocityX: 0.4, velocityZ: 0.1 // horizontal drift
      },
      agora: {
        count: 35,
        color: 0xffa500, // orange lantern glow
        size: 0.25,
        rangeX: 45, rangeY: 30, rangeZ: 45,
        velocityY: 0.3,
        velocityX: 0.1, velocityZ: 0.1
      },
      commons: {
        count: 40,
        color: 0xf5f5f5, // soft white smoke
        size: 0.35,
        rangeX: 45, rangeY: 35, rangeZ: 45,
        velocityY: 0.6, // rising
        velocityX: 0.15, velocityZ: 0.15
      },
      arena: {
        count: 35,
        color: 0xff4500, // red embers
        size: 0.2,
        rangeX: 45, rangeY: 40, rangeZ: 45,
        velocityY: 0.7, // embers rising
        velocityX: 0.2, velocityZ: 0.2
      }
    };

    for (var zoneName in configs) {
      if (!configs.hasOwnProperty(zoneName)) continue;
      var cfg = configs[zoneName];
      var zone = ZONES[zoneName];
      if (!zone) continue;

      var count = cfg.count;
      var positions = new Float32Array(count * 3);
      var colors = new Float32Array(count * 3);
      var sizes = new Float32Array(count);
      var velocities = [];
      var offsets = [];

      for (var i = 0; i < count; i++) {
        var i3 = i * 3;

        var rx = (Math.random() - 0.5) * cfg.rangeX;
        var ry = Math.random() * cfg.rangeY;
        var rz = (Math.random() - 0.5) * cfg.rangeZ;

        positions[i3] = zone.cx + rx;
        positions[i3 + 1] = zone.baseHeight + ry;
        positions[i3 + 2] = zone.cz + rz;

        offsets.push({ x: rx, y: ry, z: rz });

        var vx = (Math.random() - 0.5) * cfg.velocityX;
        var vy = cfg.velocityY * (0.8 + Math.random() * 0.4);
        var vz = (Math.random() - 0.5) * cfg.velocityZ;
        velocities.push({ x: vx, y: vy, z: vz });

        var particleColor;
        if (zoneName === 'studio') {
          var hue = Math.random();
          var rgb = hslToRgb(hue, 0.7, 0.6);
          colors[i3] = rgb.r;
          colors[i3 + 1] = rgb.g;
          colors[i3 + 2] = rgb.b;
        } else {
          var c = new THREE.Color(cfg.color);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }

        sizes[i] = cfg.size * (0.8 + Math.random() * 0.4);
      }

      var geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      var material = new THREE.PointsMaterial({
        size: cfg.size,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      var points = new THREE.Points(geometry, material);
      points.visible = false; // Start hidden
      scene.add(points);

      zoneAmbienceData.particles[zoneName] = {
        points: points,
        velocities: velocities,
        offsets: offsets,
        config: cfg,
        zone: zone
      };
    }

    zoneAmbienceData.initialized = true;
  }

  function updateZoneAmbience(sceneCtx, playerZone, deltaTime) {
    if (!zoneAmbienceData.initialized) return;

    var dt = deltaTime / 1000; // convert to seconds

    for (var zoneName in zoneAmbienceData.particles) {
      if (!zoneAmbienceData.particles.hasOwnProperty(zoneName)) continue;
      var data = zoneAmbienceData.particles[zoneName];

      var isCurrentZone = zoneName === playerZone;
      data.points.visible = isCurrentZone;

      if (!isCurrentZone) continue;

      var positions = data.points.geometry.attributes.position.array;
      var zone = data.zone;
      var cfg = data.config;

      for (var i = 0; i < data.velocities.length; i++) {
        var i3 = i * 3;
        var vel = data.velocities[i];
        var offset = data.offsets[i];

        positions[i3] += vel.x * dt;
        positions[i3 + 1] += vel.y * dt;
        positions[i3 + 2] += vel.z * dt;

        var localX = positions[i3] - zone.cx;
        var localY = positions[i3 + 1] - zone.baseHeight;
        var localZ = positions[i3 + 2] - zone.cz;

        if (Math.abs(localX) > cfg.rangeX * 0.6 ||
            localY > cfg.rangeY || localY < 0 ||
            Math.abs(localZ) > cfg.rangeZ * 0.6) {
          positions[i3] = zone.cx + (Math.random() - 0.5) * cfg.rangeX;
          positions[i3 + 1] = zone.baseHeight + Math.random() * cfg.rangeY * 0.3;
          positions[i3 + 2] = zone.cz + (Math.random() - 0.5) * cfg.rangeZ;
        }
      }

      data.points.geometry.attributes.position.needsUpdate = true;
    }
  }

  var seasonalParticleData = {
    initialized: false,
    points: null,
    velocities: [],
    season: null,
    elapsed: 0
  };

  var SEASONAL_PARTICLE_CONFIGS = {
    spring: {
      count: 28,
      color: 0xffc0db,        // cherry blossom pink
      size: 0.28,
      rangeX: 60, rangeY: 22, rangeZ: 60,
      velocityX: 0.6,         // gentle sideways drift
      velocityY: -0.4,        // fall downward
      velocityZ: 0.3,
      resetAtTop: true        // respawn at top when reaching ground
    },
    summer: {
      count: 20,
      color: 0xccff66,        // yellow-green fireflies
      size: 0.22,
      rangeX: 50, rangeY: 18, rangeZ: 50,
      velocityX: 0.35,
      velocityY: 0.2,         // gentle upward float
      velocityZ: 0.35,
      nightOnly: true,        // only visible when nightFactor > 0.3
      resetAtTop: false
    },
    autumn: {
      count: 24,
      color: 0xd46020,        // orange-red falling leaf
      size: 0.32,
      rangeX: 60, rangeY: 24, rangeZ: 60,
      velocityX: 0.7,
      velocityY: -0.55,       // fall faster than petals
      velocityZ: 0.4,
      resetAtTop: true
    },
    winter: {
      count: 32,
      color: 0xe8f4ff,        // pale blue-white snowflake
      size: 0.20,
      rangeX: 55, rangeY: 26, rangeZ: 55,
      velocityX: 0.25,
      velocityY: -0.28,       // slow gentle fall
      velocityZ: 0.18,
      resetAtTop: true
    }
  };

  function initSeasonalParticles(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    if (!Seasons && typeof window !== 'undefined' && window.Seasons) {
      Seasons = window.Seasons;
    }
    if (!Seasons) return;

    var season = Seasons.getCurrentSeason();
    var cfg = SEASONAL_PARTICLE_CONFIGS[season.id];
    if (!cfg) return;

    var count = cfg.count;
    var positions = new Float32Array(count * 3);
    var colors = new Float32Array(count * 3);
    var velocities = [];

    var baseColor = new THREE.Color(cfg.color);

    for (var i = 0; i < count; i++) {
      var i3 = i * 3;

      positions[i3]     = (Math.random() - 0.5) * cfg.rangeX;
      positions[i3 + 1] = Math.random() * cfg.rangeY;
      positions[i3 + 2] = (Math.random() - 0.5) * cfg.rangeZ;

      var variation = 0.85 + Math.random() * 0.3;
      colors[i3]     = Math.min(1, baseColor.r * variation);
      colors[i3 + 1] = Math.min(1, baseColor.g * variation);
      colors[i3 + 2] = Math.min(1, baseColor.b * variation);

      velocities.push({
        x: (Math.random() - 0.5) * cfg.velocityX,
        y: cfg.velocityY * (0.7 + Math.random() * 0.6),
        z: (Math.random() - 0.5) * cfg.velocityZ,
        phase: Math.random() * Math.PI * 2  // swirl/bob phase
      });
    }

    var geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color',    new THREE.BufferAttribute(colors, 3));

    var material = new THREE.PointsMaterial({
      size: cfg.size,
      vertexColors: true,
      transparent: true,
      opacity: 0.72,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      fog: false
    });

    if (seasonalParticleData.points) {
      sceneCtx.scene.remove(seasonalParticleData.points);
      seasonalParticleData.points.geometry.dispose();
      seasonalParticleData.points.material.dispose();
    }

    var points = new THREE.Points(geometry, material);
    points.frustumCulled = false;
    sceneCtx.scene.add(points);

    seasonalParticleData.points = points;
    seasonalParticleData.velocities = velocities;
    seasonalParticleData.season = season.id;
    seasonalParticleData.elapsed = 0;
    seasonalParticleData.config = cfg;
    seasonalParticleData.initialized = true;
  }

  function updateSeasonalVisuals(sceneCtx, playerZone, deltaTime, normalizedTime) {
    if (!Seasons && typeof window !== 'undefined' && window.Seasons) {
      Seasons = window.Seasons;
    }
    if (!Seasons || !sceneCtx) return;

    var dt = (deltaTime || 16) / 1000; // seconds

    var currentSeasonId = Seasons.getCurrentSeason().id;
    if (!seasonalParticleData.initialized || seasonalParticleData.season !== currentSeasonId) {
      initSeasonalParticles(sceneCtx);
    }

    var seasonColors = Seasons.getSeasonalColors();
    if (sceneCtx.ambientLight && seasonColors) {
      var ambientHex = seasonColors.ambient;
      var seasonAmbient = new THREE.Color(ambientHex);

      var TINT_STRENGTH = 0.18;
      var existingGroundColor = sceneCtx.ambientLight.groundColor;
      if (existingGroundColor) {
        var blendedR = existingGroundColor.r * (1 - TINT_STRENGTH) + seasonAmbient.r * TINT_STRENGTH;
        var blendedG = existingGroundColor.g * (1 - TINT_STRENGTH) + seasonAmbient.g * TINT_STRENGTH;
        var blendedB = existingGroundColor.b * (1 - TINT_STRENGTH) + seasonAmbient.b * TINT_STRENGTH;
        sceneCtx.ambientLight.groundColor.setRGB(blendedR, blendedG, blendedB);
      }
    }

    if (sceneCtx.scene && sceneCtx.scene.fog && seasonColors) {
      var accentHex = seasonColors.accent;
      var seasonAccent = new THREE.Color(accentHex);
      var currentFogColor = sceneCtx.scene.fog.color;
      var FOG_TINT = 0.08; // very gentle
      currentFogColor.r = currentFogColor.r * (1 - FOG_TINT) + seasonAccent.r * FOG_TINT;
      currentFogColor.g = currentFogColor.g * (1 - FOG_TINT) + seasonAccent.g * FOG_TINT;
      currentFogColor.b = currentFogColor.b * (1 - FOG_TINT) + seasonAccent.b * FOG_TINT;
    }

    if (!seasonalParticleData.initialized || !seasonalParticleData.points) return;

    var ntNorm = normalizedTime !== undefined ? normalizedTime : 0.5;
    var nightFactor = 0;
    if (ntNorm < 0.2) {
      nightFactor = 1.0;
    } else if (ntNorm < 0.3) {
      nightFactor = 1.0 - (ntNorm - 0.2) / 0.1;
    } else if (ntNorm > 0.8) {
      nightFactor = (ntNorm - 0.8) / 0.2;
    }

    var cfg = seasonalParticleData.config;

    if (cfg.nightOnly) {
      seasonalParticleData.points.visible = nightFactor > 0.3;
      if (!seasonalParticleData.points.visible) return;
      seasonalParticleData.points.material.opacity = 0.6 * nightFactor;
    } else {
      seasonalParticleData.points.visible = true;
    }

    seasonalParticleData.elapsed += dt;

    var positions = seasonalParticleData.points.geometry.attributes.position.array;
    var velocities = seasonalParticleData.velocities;
    var camX = 0, camY = 10, camZ = 0;
    if (sceneCtx.camera) {
      camX = sceneCtx.camera.position.x;
      camY = sceneCtx.camera.position.y;
      camZ = sceneCtx.camera.position.z;
    }

    var halfX = cfg.rangeX * 0.5;
    var halfZ = cfg.rangeZ * 0.5;

    for (var i = 0; i < velocities.length; i++) {
      var i3 = i * 3;
      var vel = velocities[i];

      var swirl = Math.sin(seasonalParticleData.elapsed * 0.8 + vel.phase) * 0.3;

      positions[i3]     += (vel.x + swirl * 0.4) * dt;
      positions[i3 + 1] += vel.y * dt;
      positions[i3 + 2] += (vel.z + swirl * 0.3) * dt;

      var localX = positions[i3]     - camX;
      var localY = positions[i3 + 1] - camY;
      var localZ = positions[i3 + 2] - camZ;

      var needsReset = false;
      if (Math.abs(localX) > halfX || Math.abs(localZ) > halfZ) needsReset = true;
      if (cfg.resetAtTop && localY < -2) needsReset = true;  // fell below camera
      if (!cfg.resetAtTop && localY > cfg.rangeY) needsReset = true; // floated too high (firefly)

      if (needsReset) {
        positions[i3]     = camX + (Math.random() - 0.5) * cfg.rangeX;
        positions[i3 + 2] = camZ + (Math.random() - 0.5) * cfg.rangeZ;
        if (cfg.resetAtTop) {
          positions[i3 + 1] = camY + cfg.rangeY * (0.5 + Math.random() * 0.5);
        } else {
          positions[i3 + 1] = camY - cfg.rangeY * 0.4 + Math.random() * 4;
        }
      }
    }

    seasonalParticleData.points.geometry.attributes.position.needsUpdate = true;
  }

  function hslToRgb(h, s, l) {
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var hue2rgb = function(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return { r: r, g: g, b: b };
  }

  var worldMemory = {};
  var worldMemoryLastStep = 0;
  var MEMORY_GRID_SIZE = 4;
  var MEMORY_MAX_CELLS = 2000;
  var stillTimer = 0;
  var lastPlayerVelocity = 0;
  var lastPlayerPos = null;

  function loadWorldMemory() {
    if (typeof localStorage === 'undefined') return;
    try {
      var stored = localStorage.getItem('zion_worldMemory');
      if (stored) {
        worldMemory = JSON.parse(stored);
        var keys = Object.keys(worldMemory);
        for (var i = keys.length - 1; i >= 0; i--) {
          var cell = worldMemory[keys[i]];
          cell.steps *= 0.9;
          cell.gathering *= 0.95;
          if (cell.steps < 1 && cell.gathering < 1 && !cell.flowers) {
            delete worldMemory[keys[i]];
          }
        }
      }
    } catch(e) {}
  }

  function saveWorldMemory() {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem('zion_worldMemory', JSON.stringify(worldMemory));
    } catch(e) {}
  }

  function memoryKey(x, z) {
    return Math.floor(x / MEMORY_GRID_SIZE) + '_' + Math.floor(z / MEMORY_GRID_SIZE);
  }

  function recordStep(x, z) {
    var key = memoryKey(x, z);
    if (!worldMemory[key]) {
      worldMemory[key] = { steps: 0, lastStep: 0, gathering: 0, flowers: false };
    }
    worldMemory[key].steps++;
    worldMemory[key].lastStep = Date.now();

    var keys = Object.keys(worldMemory);
    if (keys.length > MEMORY_MAX_CELLS) {
      keys.sort(function(a, b) { return worldMemory[a].steps - worldMemory[b].steps; });
      var toRemove = keys.length - MEMORY_MAX_CELLS;
      for (var i = 0; i < toRemove; i++) {
        if (!worldMemory[keys[i]].flowers) delete worldMemory[keys[i]];
      }
    }
  }

  function updateWorldMemory(playerPos, nearbyEntities, deltaTime) {
    if (!playerPos) return;
    var now = Date.now();

    if (now - worldMemoryLastStep > 500) {
      recordStep(playerPos.x, playerPos.z);
      worldMemoryLastStep = now;
    }

    var velocity = 0;
    if (lastPlayerPos) {
      var dx = playerPos.x - lastPlayerPos.x;
      var dz = playerPos.z - lastPlayerPos.z;
      velocity = Math.sqrt(dx * dx + dz * dz) / Math.max(deltaTime, 0.001);
    }
    lastPlayerPos = { x: playerPos.x, y: playerPos.y, z: playerPos.z };
    lastPlayerVelocity = velocity;

    if (velocity < 0.5) {
      stillTimer += deltaTime;
    } else {
      stillTimer = 0;
    }

    var key = memoryKey(playerPos.x, playerPos.z);
    if (!worldMemory[key]) {
      worldMemory[key] = { steps: 0, lastStep: 0, gathering: 0, flowers: false };
    }

    if (stillTimer >= 10 && nearbyEntities > 0) {
      worldMemory[key].gathering++;
    }

    if (stillTimer >= 30 && nearbyEntities === 0) {
      worldMemory[key].flowers = true;
    }

    if (now % 10000 < 500) {
      saveWorldMemory();
    }
  }

  function getMemoryAtPosition(wx, wz) {
    var key = memoryKey(wx, wz);
    return worldMemory[key] || null;
  }

  var billboardClouds = [];

  function initBillboardClouds(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var cloudCount = 8 + Math.floor(Math.random() * 5); // 8-12

    for (var i = 0; i < cloudCount; i++) {
      var group = new THREE.Group();
      var puffCount = 4 + Math.floor(Math.random() * 3); // 4-6

      for (var p = 0; p < puffCount; p++) {
        var radius = 3 + Math.random() * 4;
        var puffGeo = new THREE.SphereGeometry(radius, 8, 6);
        var puffMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5 + Math.random() * 0.2,
          fog: false,
          depthWrite: false
        });
        var puff = new THREE.Mesh(puffGeo, puffMat);
        puff.position.set(
          (Math.random() - 0.5) * 8,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 6
        );
        puff.scale.y = 0.5 + Math.random() * 0.3; // flatten
        group.add(puff);
      }

      group.position.set(
        (Math.random() - 0.5) * 500,
        80 + Math.random() * 40,
        (Math.random() - 0.5) * 500
      );
      group.userData.driftSpeed = 0.5 + Math.random() * 1.0;
      group.userData.driftAngle = Math.random() * Math.PI * 2;
      group.visible = false; // hidden until weather needs them

      sceneCtx.scene.add(group);
      billboardClouds.push(group);
    }
  }

  function updateBillboardClouds(deltaTime, weatherType) {
    var showClouds = (weatherType === 'cloudy' || weatherType === 'rain' || weatherType === 'storm');
    for (var i = 0; i < billboardClouds.length; i++) {
      var cloud = billboardClouds[i];
      cloud.visible = showClouds;
      if (!showClouds) continue;

      cloud.position.x += Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      cloud.position.z += Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;

      if (cloud.position.x > 300) cloud.position.x = -300;
      if (cloud.position.x < -300) cloud.position.x = 300;
      if (cloud.position.z > 300) cloud.position.z = -300;
      if (cloud.position.z < -300) cloud.position.z = 300;
    }
  }

  var splashPool = [];
  var splashMesh = null;
  var MAX_SPLASHES = 200;

  function initRainSplashes(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var geo = new THREE.BufferGeometry();
    var positions = new Float32Array(MAX_SPLASHES * 3);
    var sizes = new Float32Array(MAX_SPLASHES);

    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    var mat = new THREE.PointsMaterial({
      color: 0xaaddff,
      size: 0.3,
      transparent: true,
      opacity: 0.5,
      depthWrite: false,
      sizeAttenuation: true
    });

    splashMesh = new THREE.Points(geo, mat);
    sceneCtx.scene.add(splashMesh);

    for (var i = 0; i < MAX_SPLASHES; i++) {
      splashPool.push({
        active: false,
        x: 0, y: 0, z: 0,
        vx: 0, vy: 0, vz: 0,
        life: 0, maxLife: 0.3
      });
    }
  }

  function spawnSplash(x, y, z) {
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < splashPool.length; j++) {
        if (!splashPool[j].active) {
          splashPool[j].active = true;
          splashPool[j].x = x;
          splashPool[j].y = y;
          splashPool[j].z = z;
          splashPool[j].vx = (Math.random() - 0.5) * 2;
          splashPool[j].vy = 1 + Math.random() * 2;
          splashPool[j].vz = (Math.random() - 0.5) * 2;
          splashPool[j].life = 0;
          break;
        }
      }
    }
  }

  function updateRainSplashes(deltaTime) {
    if (!splashMesh) return;
    var positions = splashMesh.geometry.attributes.position.array;
    var sizes = splashMesh.geometry.attributes.size.array;

    for (var i = 0; i < splashPool.length; i++) {
      var sp = splashPool[i];
      if (sp.active) {
        sp.life += deltaTime * 0.001;
        sp.x += sp.vx * deltaTime * 0.001;
        sp.y += (sp.vy - 9.8 * sp.life) * deltaTime * 0.001;
        sp.z += sp.vz * deltaTime * 0.001;

        if (sp.life >= sp.maxLife) {
          sp.active = false;
        }

        positions[i * 3] = sp.x;
        positions[i * 3 + 1] = sp.y;
        positions[i * 3 + 2] = sp.z;
        sizes[i] = sp.active ? (0.3 * (1 - sp.life / sp.maxLife)) : 0;
      } else {
        sizes[i] = 0;
      }
    }

    splashMesh.geometry.attributes.position.needsUpdate = true;
    splashMesh.geometry.attributes.size.needsUpdate = true;
  }

  var lightningBoltMesh = null;
  var lightningBoltTimer = 0;

  function createLightningBolt(sceneCtx, startX, startZ) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (lightningBoltMesh) {
      sceneCtx.scene.remove(lightningBoltMesh);
      lightningBoltMesh.geometry.dispose();
      lightningBoltMesh.material.dispose();
      lightningBoltMesh = null;
    }

    var segments = 5 + Math.floor(Math.random() * 3);
    var startY = 75 + Math.random() * 15;
    var groundY = terrainHeight(startX, startZ);
    var points = [];

    for (var i = 0; i <= segments; i++) {
      var t = i / segments;
      var y = startY + (groundY - startY) * t;
      var jitterX = (Math.random() - 0.5) * 12 * (1 - t * 0.5);
      var jitterZ = (Math.random() - 0.5) * 12 * (1 - t * 0.5);
      points.push(new THREE.Vector3(startX + jitterX, y, startZ + jitterZ));
    }

    var geo = new THREE.BufferGeometry().setFromPoints(points);
    var mat = new THREE.LineBasicMaterial({
      color: 0xeeeeff,
      linewidth: 2,
      transparent: true,
      opacity: 1.0
    });

    lightningBoltMesh = new THREE.Line(geo, mat);
    sceneCtx.scene.add(lightningBoltMesh);
    lightningBoltTimer = 0.15; // visible for 150ms
  }

  function updateLightningBolt(sceneCtx, deltaTime) {
    if (!lightningBoltMesh) return;
    lightningBoltTimer -= deltaTime * 0.001;
    if (lightningBoltTimer <= 0) {
      if (sceneCtx && sceneCtx.scene) {
        sceneCtx.scene.remove(lightningBoltMesh);
      }
      lightningBoltMesh.geometry.dispose();
      lightningBoltMesh.material.dispose();
      lightningBoltMesh = null;
    } else {
      lightningBoltMesh.material.opacity = lightningBoltTimer / 0.15;
    }
  }

  var snowAccumulating = false;
  var snowAccumTimer = 0;

  function updateSnowAccumulation(deltaTime, weatherType) {
    var isSnow = (weatherType === 'snow');
    snowAccumulating = isSnow;

    snowAccumTimer += deltaTime;
    if (snowAccumTimer < 2000) return; // every 2 seconds
    snowAccumTimer = 0;

    loadedChunks.forEach(function(chunk) {
      if (!chunk.group) return;
      var terrain = chunk.group.children[0]; // first child is terrain mesh
      if (!terrain || !terrain.geometry || !terrain.geometry.attributes.color) return;

      var colors = terrain.geometry.attributes.color.array;

      if (!terrain.userData.originalColors) {
        terrain.userData.originalColors = new Float32Array(colors);
      }

      var origColors = terrain.userData.originalColors;

      if (isSnow) {
        for (var i = 0; i < colors.length; i += 3) {
          colors[i] += (0.95 - colors[i]) * 0.02;
          colors[i + 1] += (0.95 - colors[i + 1]) * 0.02;
          colors[i + 2] += (0.98 - colors[i + 2]) * 0.02;
        }
      } else {
        for (var j = 0; j < colors.length; j += 3) {
          colors[j] += (origColors[j] - colors[j]) * 0.01;
          colors[j + 1] += (origColors[j + 1] - colors[j + 1]) * 0.01;
          colors[j + 2] += (origColors[j + 2] - colors[j + 2]) * 0.01;
        }
      }

      terrain.geometry.attributes.color.needsUpdate = true;
    });
  }

  var fogPlanes = [];

  function initValleyFog(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var valleySpots = [];
    for (var x = -400; x < 400; x += 80) {
      for (var z = -400; z < 400; z += 80) {
        var h = terrainHeight(x, z);
        if (h < -2) {
          valleySpots.push({ x: x, z: z, h: h });
        }
      }
    }

    var count = Math.min(8, valleySpots.length);
    for (var i = 0; i < count; i++) {
      var spot = valleySpots[i];
      var fogGeo = new THREE.PlaneBufferGeometry(40, 40);
      var fogMat = new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        transparent: true,
        opacity: 0.15 + Math.random() * 0.1,
        depthWrite: false,
        side: THREE.DoubleSide,
        fog: false
      });

      var fogMesh = new THREE.Mesh(fogGeo, fogMat);
      fogMesh.rotation.x = -Math.PI / 2;
      fogMesh.position.set(spot.x, spot.h + 2, spot.z);
      fogMesh.userData.baseY = spot.h + 2;
      fogMesh.userData.bobPhase = Math.random() * Math.PI * 2;
      fogMesh.visible = false;

      sceneCtx.scene.add(fogMesh);
      fogPlanes.push(fogMesh);
    }
  }

  function updateValleyFog(worldTime, weatherType) {
    var isDawn = (worldTime >= 240 && worldTime <= 480);
    var isRain = (weatherType === 'rain' || weatherType === 'storm');
    var showFog = isDawn || isRain;
    var time = Date.now() * 0.001;

    for (var i = 0; i < fogPlanes.length; i++) {
      var fp = fogPlanes[i];
      fp.visible = showFog;
      if (!showFog) continue;

      fp.position.y = fp.userData.baseY + Math.sin(time * 0.3 + fp.userData.bobPhase) * 0.5;
    }
  }

  var terrainBreathTime = 0;

  function updateTerrainBreathing(deltaTime, worldTime) {
    terrainBreathTime += deltaTime;

    if (Math.floor(terrainBreathTime * 60) % 3 !== 0) return;

    loadedChunks.forEach(function(chunk) {
      if (!chunk.group) return;
      var terrain = chunk.group.children[0];
      if (!terrain || !terrain.geometry || !terrain.geometry.attributes.position) return;

      var positions = terrain.geometry.attributes.position.array;

      if (!terrain.userData.baseHeights) {
        terrain.userData.baseHeights = new Float32Array(positions.length / 3);
        for (var i = 0; i < positions.length; i += 3) {
          terrain.userData.baseHeights[i / 3] = positions[i + 1]; // Y component
        }
      }

      var baseHeights = terrain.userData.baseHeights;
      var time = terrainBreathTime;
      var wx = terrain.position.x;
      var wz = terrain.position.z;

      for (var j = 0; j < positions.length; j += 3) {
        var localX = positions[j] + wx;
        var localZ = positions[j + 2] + wz;
        var breathOffset = Math.sin(time * 0.3 + localX * 0.02 + localZ * 0.015) * 0.12;
        breathOffset += Math.sin(time * 0.5 + localX * 0.01 - localZ * 0.02) * 0.06;
        positions[j + 1] = baseHeights[j / 3] + breathOffset;
      }

      terrain.geometry.attributes.position.needsUpdate = true;
      terrain.geometry.computeVertexNormals();
    });
  }

  var windState = { strength: 1.0, gustTimer: 0, gustTarget: 1.0 };

  function updateWindSystem(deltaTime, weatherType) {
    var baseWind = 1.0;
    if (weatherType === 'storm') baseWind = 3.0;
    else if (weatherType === 'rain') baseWind = 1.5;
    else if (weatherType === 'cloudy') baseWind = 1.2;
    else if (weatherType === 'snow') baseWind = 0.8;

    windState.gustTimer += deltaTime;
    if (windState.gustTimer > 3 + Math.random() * 5) {
      windState.gustTarget = baseWind * (0.7 + Math.random() * 0.6);
      windState.gustTimer = 0;
    }

    windState.strength += (windState.gustTarget - windState.strength) * deltaTime * 0.5;
    windState.strength = Math.max(0.3, Math.min(windState.strength, baseWind * 1.3));
  }

  function getWindStrength() {
    return windState.strength;
  }

  var zoneBorderParticles = [];

  function initZoneBorderShimmer(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    for (var zId in ZONES) {
      var zone = ZONES[zId];
      if (!zone.radius) continue;

      var particleCount = 60;
      var geo = new THREE.BufferGeometry();
      var positions = new Float32Array(particleCount * 3);
      var colors = new Float32Array(particleCount * 3);

      var zoneColor = zone.groundColor || 0x88aa88;
      var cr = ((zoneColor >> 16) & 0xff) / 255;
      var cg = ((zoneColor >> 8) & 0xff) / 255;
      var cb = (zoneColor & 0xff) / 255;

      for (var i = 0; i < particleCount; i++) {
        var angle = (i / particleCount) * Math.PI * 2;
        var r = zone.radius;
        positions[i * 3] = zone.cx + Math.cos(angle) * r;
        positions[i * 3 + 1] = terrainHeight(zone.cx + Math.cos(angle) * r, zone.cz + Math.sin(angle) * r) + 1;
        positions[i * 3 + 2] = zone.cz + Math.sin(angle) * r;

        colors[i * 3] = cr;
        colors[i * 3 + 1] = cg;
        colors[i * 3 + 2] = cb;
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      var mat = new THREE.PointsMaterial({
        size: 0.8,
        transparent: true,
        opacity: 0.3,
        vertexColors: true,
        depthWrite: false,
        sizeAttenuation: true
      });

      var points = new THREE.Points(geo, mat);
      points.userData.zoneId = zId;
      points.userData.basePositions = new Float32Array(positions);
      sceneCtx.scene.add(points);
      zoneBorderParticles.push(points);
    }
  }

  function updateZoneBorderShimmer(worldTime) {
    var time = Date.now() * 0.001;
    for (var i = 0; i < zoneBorderParticles.length; i++) {
      var bp = zoneBorderParticles[i];
      var positions = bp.geometry.attributes.position.array;
      var basePos = bp.userData.basePositions;

      for (var j = 0; j < positions.length; j += 3) {
        positions[j + 1] = basePos[j + 1] + Math.sin(time * 2 + j * 0.5) * 0.5;
      }

      bp.geometry.attributes.position.needsUpdate = true;
      bp.material.opacity = 0.2 + Math.sin(time * 1.5 + i) * 0.15;
    }
  }

  function addStructure(sceneCtx, type, position, options) {
    if (!sceneCtx || !sceneCtx.scene) return null;
    var opts = options || {};
    var result = confirmPlacement(sceneCtx, position, opts.zone || 'nexus');
    return result;
  }

  function createPortal(sceneCtx, fromZone, toZone, position) {
    if (!sceneCtx || !sceneCtx.scene) return null;
    return { from: fromZone, to: toZone, position: position };
  }

  exports.initScene = initScene;
  exports.loadZone = loadZone;
  exports.addPlayer = addPlayer;
  exports.movePlayer = movePlayer;
  exports.removePlayer = removePlayer;
  exports.updatePlayerAnimations = updatePlayerAnimations;
  exports.updateDayNight = updateDayNight;
  exports.updateWeather = updateWeather;
  exports.setWeather = setWeather;
  exports.updateWeatherEffects = updateWeatherEffects;
  exports.getCurrentWeather = getCurrentWeather;
  exports.cullLights = cullLights;
  exports.updateAnimations = updateAnimations;
  exports.updateChunks = updateChunks;
  exports.getZoneAtPosition = getZoneAtPosition;
  exports.getTerrainHeight = getTerrainHeight;
  exports.getZoneCenter = getZoneCenter;
  exports.checkCollision = checkCollision;
  exports.getTexture = getTexture;
  exports.initParticles = initParticles;
  exports.updateParticles = updateParticles;
  exports.emitParticles = emitParticles;
  exports.initWater = initWater;
  exports.updateWater = updateWater;
  exports.initSkybox = initSkybox;
  exports.updateSkybox = updateSkybox;
  exports.initResourceNodes = initResourceNodes;
  exports.updateResourceNodes = updateResourceNodes;
  exports.harvestResource = harvestResource;
  exports.getResourceNodeAtMouse = getResourceNodeAtMouse;
  exports.ZONES = ZONES;
  exports.enterBuildMode = enterBuildMode;
  exports.exitBuildMode = exitBuildMode;
  exports.setBuildType = setBuildType;
  exports.confirmPlacement = confirmPlacement;
  exports.removeLastPlaced = removeLastPlaced;
  exports.updateBuildPreview = updateBuildPreview;
  exports.rotateBuildPreview = rotateBuildPreview;
  exports.getBuildMode = getBuildMode;
  exports.updateLOD = updateLOD;
  exports.updateFrustumCulling = updateFrustumCulling;
  exports.getFromPool = getFromPool;
  exports.returnToPool = returnToPool;
  exports.getPerformanceStats = getPerformanceStats;
  exports.spawnZoneInteractives = spawnZoneInteractives;
  exports.createInteractiveObject = createInteractiveObject;
  exports.getInteractiveAtPosition = getInteractiveAtPosition;
  exports.interactWithObject = interactWithObject;
  exports.updateInteractiveHighlights = updateInteractiveHighlights;
  exports.updateInteractiveAnimations = updateInteractiveAnimations;
  exports.clearInteractiveObjects = clearInteractiveObjects;
  exports.getZoneInteractives = getZoneInteractives;
  exports.highlightObject = highlightObject;
  exports.unhighlightObject = unhighlightObject;
  exports.fadeTransition = fadeTransition;
  exports.createZoneBoundaryParticles = createZoneBoundaryParticles;
  exports.updateZoneBoundaryParticles = updateZoneBoundaryParticles;
  exports.initWildlife = initWildlife;
  exports.updateWildlife = updateWildlife;
  exports.clearWildlife = clearWildlife;
  exports.initZoneAmbience = initZoneAmbience;
  exports.updateZoneAmbience = updateZoneAmbience;
  exports.initSeasonalParticles = initSeasonalParticles;
  exports.updateSeasonalVisuals = updateSeasonalVisuals;
  exports.registerPlayerStar = registerPlayerStar;
  exports.loadWorldMemory = loadWorldMemory;
  exports.saveWorldMemory = saveWorldMemory;
  exports.updateWorldMemory = updateWorldMemory;
  exports.initBillboardClouds = initBillboardClouds;
  exports.updateBillboardClouds = updateBillboardClouds;
  exports.initRainSplashes = initRainSplashes;
  exports.updateSnowAccumulation = updateSnowAccumulation;
  exports.initValleyFog = initValleyFog;
  exports.updateValleyFog = updateValleyFog;
  exports.updateTerrainBreathing = updateTerrainBreathing;
  exports.updateWindSystem = updateWindSystem;
  exports.getWindStrength = getWindStrength;
  exports.initZoneBorderShimmer = initZoneBorderShimmer;
  exports.updateZoneBorderShimmer = updateZoneBorderShimmer;
  exports.weatherCallbacks = weatherCallbacks;
  exports.addStructure = addStructure;
  exports.createPortal = createPortal;

})(typeof module !== 'undefined' ? module.exports : (window.World = {}));


// worldmap.js

(function(exports) {
  'use strict';

  var WORLD_MIN = -600;
  var WORLD_MAX = 600;
  var WORLD_RANGE = WORLD_MAX - WORLD_MIN; // 1200

  var ZONE_DATA = {
    nexus:     { cx: 0,    cz: 0,    radius: 60,  name: 'The Nexus',      color: '#6688cc', bgColor: 'rgba(102,136,204,0.15)' },
    gardens:   { cx: 200,  cz: 30,   radius: 80,  name: 'The Gardens',    color: '#44aa44', bgColor: 'rgba(68,170,68,0.15)'   },
    athenaeum: { cx: 100,  cz: -220, radius: 60,  name: 'The Athenaeum',  color: '#8866aa', bgColor: 'rgba(136,102,170,0.15)' },
    studio:    { cx: -200, cz: -100, radius: 60,  name: 'The Studio',     color: '#cc6688', bgColor: 'rgba(204,102,136,0.15)' },
    wilds:     { cx: -30,  cz: 260,  radius: 90,  name: 'The Wilds',      color: '#228844', bgColor: 'rgba(34,136,68,0.15)'   },
    agora:     { cx: -190, cz: 120,  radius: 55,  name: 'The Agora',      color: '#cc8844', bgColor: 'rgba(204,136,68,0.15)'  },
    commons:   { cx: 170,  cz: 190,  radius: 55,  name: 'The Commons',    color: '#88aa44', bgColor: 'rgba(136,170,68,0.15)'  },
    arena:     { cx: 0,    cz: -240, radius: 55,  name: 'The Arena',      color: '#cc4444', bgColor: 'rgba(204,68,68,0.15)'   }
  };

  var ZONE_COLORS = {};
  for (var _zk in ZONE_DATA) {
    ZONE_COLORS[_zk] = ZONE_DATA[_zk].color;
  }

  var ZONE_CONNECTIONS = [
    ['nexus', 'gardens'],
    ['nexus', 'athenaeum'],
    ['nexus', 'studio'],
    ['nexus', 'wilds'],
    ['nexus', 'agora'],
    ['nexus', 'commons'],
    ['nexus', 'arena'],
    ['gardens', 'wilds'],
    ['gardens', 'athenaeum'],
    ['athenaeum', 'studio'],
    ['studio', 'agora'],
    ['agora', 'commons'],
    ['commons', 'arena'],
    ['wilds', 'arena']
  ];

  function worldToMap(worldX, worldZ, canvasW, canvasH, margin) {
    if (margin === undefined || margin === null) margin = 12;
    var drawW = canvasW - margin * 2;
    var drawH = canvasH - margin * 2;
    var px = margin + ((worldX - WORLD_MIN) / WORLD_RANGE) * drawW;
    var py = margin + ((worldZ - WORLD_MIN) / WORLD_RANGE) * drawH;
    return { x: px, y: py };
  }

  function mapToWorld(mapX, mapY, canvasW, canvasH, margin) {
    if (margin === undefined || margin === null) margin = 12;
    var drawW = canvasW - margin * 2;
    var drawH = canvasH - margin * 2;
    var worldX = WORLD_MIN + ((mapX - margin) / drawW) * WORLD_RANGE;
    var worldZ = WORLD_MIN + ((mapY - margin) / drawH) * WORLD_RANGE;
    return { x: worldX, z: worldZ };
  }

  function getZoneBounds() {
    var result = {};
    for (var zid in ZONE_DATA) {
      var z = ZONE_DATA[zid];
      result[zid] = {
        cx: z.cx,
        cz: z.cz,
        radius: z.radius,
        name: z.name,
        color: z.color
      };
    }
    return result;
  }

  function getZoneAtPosition(x, z) {
    var best = null;
    var bestDist = Infinity;
    for (var zid in ZONE_DATA) {
      var zone = ZONE_DATA[zid];
      var dx = x - zone.cx;
      var dz = z - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist <= zone.radius && dist < bestDist) {
        bestDist = dist;
        best = zid;
      }
    }
    return best;
  }

  function getDistanceToZone(x, z, zoneName) {
    var zone = ZONE_DATA[zoneName];
    if (!zone) return Infinity;
    var dx = x - zone.cx;
    var dz = z - zone.cz;
    return Math.sqrt(dx * dx + dz * dz);
  }

  function getNearestZone(x, z) {
    var nearest = null;
    var nearestDist = Infinity;
    for (var zid in ZONE_DATA) {
      var dist = getDistanceToZone(x, z, zid);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = zid;
      }
    }
    return {
      zoneId: nearest,
      distance: nearestDist,
      zone: nearest ? ZONE_DATA[nearest] : null
    };
  }

  function calculatePath(fromX, fromZ, toX, toZ) {
    var fromZone = getZoneAtPosition(fromX, fromZ);
    var toZone = getZoneAtPosition(toX, toZ);

    if (!fromZone || !toZone || fromZone === toZone) {
      return [{ x: fromX, z: fromZ }, { x: toX, z: toZ }];
    }

    var directlyConnected = false;
    for (var i = 0; i < ZONE_CONNECTIONS.length; i++) {
      var conn = ZONE_CONNECTIONS[i];
      if ((conn[0] === fromZone && conn[1] === toZone) ||
          (conn[1] === fromZone && conn[0] === toZone)) {
        directlyConnected = true;
        break;
      }
    }

    if (directlyConnected) {
      return [
        { x: fromX, z: fromZ },
        { x: ZONE_DATA[toZone].cx, z: ZONE_DATA[toZone].cz },
        { x: toX, z: toZ }
      ];
    }

    var nexus = ZONE_DATA.nexus;
    return [
      { x: fromX, z: fromZ },
      { x: nexus.cx, z: nexus.cz },
      { x: ZONE_DATA[toZone].cx, z: ZONE_DATA[toZone].cz },
      { x: toX, z: toZ }
    ];
  }

  function renderMap(ctx, width, height, options) {
    options = options || {};
    var margin = (options.margin !== undefined) ? options.margin : 12;
    var currentZone = options.currentZone || null;
    var showGrid = options.showGrid || false;
    var showConnections = (options.showConnections !== false);
    var showLabels = (options.showLabels !== false);

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, width, height);

    if (showGrid) {
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 0.5;
      var gridStep = 100; // every 100 world units
      var gridLines = [
        WORLD_MIN, -400, -200, 0, 200, 400, WORLD_MAX
      ];
      for (var gi = 0; gi < gridLines.length; gi++) {
        var gv = gridLines[gi];
        var gLeft = worldToMap(gv, WORLD_MIN, width, height, margin);
        var gRight = worldToMap(gv, WORLD_MAX, width, height, margin);
        ctx.beginPath();
        ctx.moveTo(gLeft.x, gLeft.y);
        ctx.lineTo(gRight.x, gRight.y);
        ctx.stroke();
        var gTop = worldToMap(WORLD_MIN, gv, width, height, margin);
        var gBot = worldToMap(WORLD_MAX, gv, width, height, margin);
        ctx.beginPath();
        ctx.moveTo(gTop.x, gTop.y);
        ctx.lineTo(gBot.x, gBot.y);
        ctx.stroke();
      }
    }

    if (showConnections) {
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      for (var ci = 0; ci < ZONE_CONNECTIONS.length; ci++) {
        var conn = ZONE_CONNECTIONS[ci];
        var zA = ZONE_DATA[conn[0]];
        var zB = ZONE_DATA[conn[1]];
        if (!zA || !zB) continue;
        var pA = worldToMap(zA.cx, zA.cz, width, height, margin);
        var pB = worldToMap(zB.cx, zB.cz, width, height, margin);
        ctx.beginPath();
        ctx.moveTo(pA.x, pA.y);
        ctx.lineTo(pB.x, pB.y);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    for (var zid in ZONE_DATA) {
      var zone = ZONE_DATA[zid];
      var pos = worldToMap(zone.cx, zone.cz, width, height, margin);
      var isActive = (zid === currentZone);
      var pxRadius = (zone.radius / WORLD_RANGE) * (width - margin * 2);

      ctx.globalAlpha = isActive ? 0.45 : 0.2;
      ctx.fillStyle = zone.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, pxRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = isActive ? 1.0 : 0.45;
      ctx.strokeStyle = zone.color;
      ctx.lineWidth = isActive ? 2.5 : 1;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, pxRadius, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 1.0;

      if (showLabels) {
        ctx.fillStyle = isActive ? '#ffffff' : 'rgba(255,255,255,0.65)';
        ctx.font = isActive ? 'bold 11px Arial' : '9px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(zone.name, pos.x, pos.y);
      }
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, width, height);
  }

  function renderPlayerMarker(ctx, x, z, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;
    var pulse = options.pulse || 0;
    var color = options.color || '#FFD700';
    var baseRadius = options.radius || 5;

    var pos = worldToMap(x, z, canvasW, canvasH, margin);

    var pulseRadius = baseRadius + 3 + Math.sin(pulse * Math.PI * 2) * 2;
    ctx.globalAlpha = 0.35 + Math.sin(pulse * Math.PI * 2) * 0.15;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, pulseRadius, 0, Math.PI * 2);
    ctx.stroke();

    ctx.globalAlpha = 1.0;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, baseRadius + 1.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 10;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, baseRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  function renderNPCMarkers(ctx, npcs, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;
    var maxCount = options.maxCount || 50;

    if (!npcs || !npcs.length) return;

    var count = Math.min(npcs.length, maxCount);
    for (var i = 0; i < count; i++) {
      var npc = npcs[i];
      if (!npc || !npc.position) continue;
      var pos = worldToMap(npc.position.x, npc.position.z, canvasW, canvasH, margin);

      ctx.globalAlpha = 0.75;
      ctx.fillStyle = '#44ff88';
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1.0;
    }
  }

  function renderPortals(ctx, portals, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;

    if (!portals || !portals.length) return;

    for (var i = 0; i < portals.length; i++) {
      var portal = portals[i];
      if (!portal || !portal.position) continue;
      var pos = worldToMap(portal.position.x, portal.position.z, canvasW, canvasH, margin);
      var healthy = (portal.healthy !== false);
      var color = healthy ? '#a78bfa' : '#f87171';

      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = color;
      ctx.fillStyle = healthy ? 'rgba(167,139,250,0.35)' : 'rgba(248,113,113,0.35)';
      ctx.lineWidth = 1.5;
      var s = 5;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - s);
      ctx.lineTo(pos.x + s, pos.y);
      ctx.lineTo(pos.x, pos.y + s);
      ctx.lineTo(pos.x - s, pos.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }
  }

  function renderAnchors(ctx, anchors, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;

    if (!anchors || !anchors.length) return;

    var typeColors = {
      zone_portal:     '#4af',
      resource_node:   '#4fa',
      discovery_point: '#fa4',
      gathering_spot:  '#f4a',
      garden_plot:     '#af4'
    };

    for (var i = 0; i < anchors.length; i++) {
      var anchor = anchors[i];
      if (!anchor) continue;

      var wx, wz;
      if (anchor.position && typeof anchor.position.x === 'number') {
        wx = anchor.position.x;
        wz = anchor.position.z;
      } else if (anchor.zone && ZONE_DATA[anchor.zone]) {
        wx = ZONE_DATA[anchor.zone].cx;
        wz = ZONE_DATA[anchor.zone].cz;
      } else {
        continue;
      }

      var pos = worldToMap(wx, wz, canvasW, canvasH, margin);
      var color = typeColors[anchor.type] || '#88aaff';

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 0.75;
      var s = 3.5;
      ctx.fillRect(pos.x - s, pos.y - s, s * 2, s * 2);
      ctx.strokeRect(pos.x - s, pos.y - s, s * 2, s * 2);
      ctx.globalAlpha = 1.0;
    }
  }

  function renderLegend(ctx, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var showNPCs = options.showNPCs || false;
    var showPortals = options.showPortals || false;
    var showAnchors = options.showAnchors || false;

    var items = [
      { color: '#FFD700', label: 'You', shape: 'circle' }
    ];
    if (showNPCs)    items.push({ color: '#44ff88', label: 'NPC', shape: 'circle' });
    if (showPortals) items.push({ color: '#a78bfa', label: 'Portal', shape: 'diamond' });
    if (showAnchors) items.push({ color: '#4af',    label: 'Anchor', shape: 'square' });

    var lineH = 16;
    var boxW = 80;
    var boxH = items.length * lineH + 10;
    var bx = canvasW - boxW - 6;
    var by = canvasH - boxH - 6;

    ctx.globalAlpha = 0.75;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.beginPath();
    ctx.rect(bx, by, boxW, boxH);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var iy = by + 8 + i * lineH;
      var ix = bx + 8;

      ctx.fillStyle = item.color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 0.5;

      if (item.shape === 'diamond') {
        ctx.beginPath();
        ctx.moveTo(ix + 5, iy - 3);
        ctx.lineTo(ix + 8, iy + 1);
        ctx.lineTo(ix + 5, iy + 5);
        ctx.lineTo(ix + 2, iy + 1);
        ctx.closePath();
        ctx.fill();
      } else if (item.shape === 'square') {
        ctx.fillRect(ix + 2, iy - 2, 6, 6);
      } else {
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.arc(ix + 5, iy + 1, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }

      ctx.fillStyle = '#ddd';
      ctx.font = '9px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.label, ix + 14, iy + 1);
    }
  }

  var mapPanelEl = null;
  var mapCanvas = null;
  var mapCtx = null;
  var mapVisible = false;
  var mapPulsePhase = 0;
  var mapAnimFrame = null;
  var mapZoom = 1.0;
  var mapZoomMin = 0.5;
  var mapZoomMax = 4.0;

  var layerNPCs = false;
  var layerPortals = true;
  var layerAnchors = false;

  var _playerX = 0;
  var _playerZ = 0;
  var _currentZone = null;
  var _npcs = [];
  var _portals = [];
  var _anchors = [];
  var _onWarpCallback = null;

  function updateMapData(data) {
    data = data || {};
    if (typeof data.playerX === 'number') _playerX = data.playerX;
    if (typeof data.playerZ === 'number') _playerZ = data.playerZ;
    if (data.currentZone !== undefined) _currentZone = data.currentZone;
    if (Array.isArray(data.npcs)) _npcs = data.npcs;
    if (Array.isArray(data.portals)) _portals = data.portals;
    if (Array.isArray(data.anchors)) _anchors = data.anchors;
  }

  function _createMapPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'world-map-panel';
    panel.style.cssText = [
      'position:absolute',
      'top:50%',
      'left:50%',
      'transform:translate(-50%,-50%)',
      'width:520px',
      'height:560px',
      'background:rgba(5,8,20,0.96)',
      'border:1px solid rgba(100,136,200,0.45)',
      'border-radius:10px',
      'box-shadow:0 8px 32px rgba(0,0,0,0.7)',
      'display:flex',
      'flex-direction:column',
      'z-index:500',
      'pointer-events:auto',
      'user-select:none'
    ].join(';');

    var header = document.createElement('div');
    header.style.cssText = [
      'display:flex',
      'align-items:center',
      'justify-content:space-between',
      'padding:10px 14px 8px',
      'border-bottom:1px solid rgba(100,136,200,0.25)',
      'flex-shrink:0'
    ].join(';');

    var title = document.createElement('div');
    title.style.cssText = 'font-size:15px;font-weight:bold;color:#aac4ff;letter-spacing:0.05em;';
    title.textContent = 'WORLD MAP';

    var closeBtn = document.createElement('button');
    closeBtn.id = 'world-map-close';
    closeBtn.style.cssText = [
      'background:none',
      'border:1px solid rgba(255,255,255,0.2)',
      'border-radius:4px',
      'color:#aaa',
      'cursor:pointer',
      'padding:2px 8px',
      'font-size:13px'
    ].join(';');
    closeBtn.textContent = 'x';
    closeBtn.addEventListener('click', hideMapPanel);

    header.appendChild(title);
    header.appendChild(closeBtn);
    panel.appendChild(header);

    var toolbar = document.createElement('div');
    toolbar.style.cssText = [
      'display:flex',
      'align-items:center',
      'gap:8px',
      'padding:6px 14px',
      'border-bottom:1px solid rgba(100,136,200,0.15)',
      'flex-shrink:0',
      'font-size:11px',
      'color:#aaa'
    ].join(';');

    function makeToggle(id, label, checked, onChange) {
      var wrap = document.createElement('label');
      wrap.style.cssText = 'display:flex;align-items:center;gap:3px;cursor:pointer;';
      var cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.id = id;
      cb.checked = checked;
      cb.style.cssText = 'cursor:pointer;';
      cb.addEventListener('change', function() { onChange(cb.checked); });
      var lbl = document.createElement('span');
      lbl.textContent = label;
      wrap.appendChild(cb);
      wrap.appendChild(lbl);
      return wrap;
    }

    toolbar.appendChild(makeToggle('map-layer-npcs', 'NPCs', layerNPCs, function(v) {
      layerNPCs = v;
    }));
    toolbar.appendChild(makeToggle('map-layer-portals', 'Portals', layerPortals, function(v) {
      layerPortals = v;
    }));
    toolbar.appendChild(makeToggle('map-layer-anchors', 'Anchors', layerAnchors, function(v) {
      layerAnchors = v;
    }));

    var spacer = document.createElement('div');
    spacer.style.cssText = 'flex:1;';
    toolbar.appendChild(spacer);

    var zoomOut = document.createElement('button');
    zoomOut.textContent = '-';
    zoomOut.title = 'Zoom out';
    zoomOut.style.cssText = 'background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);border-radius:4px;color:#ccc;cursor:pointer;padding:1px 7px;font-size:14px;';
    zoomOut.addEventListener('click', function() {
      mapZoom = Math.max(mapZoomMin, mapZoom - 0.25);
    });

    var zoomLbl = document.createElement('span');
    zoomLbl.id = 'map-zoom-label';
    zoomLbl.style.cssText = 'min-width:36px;text-align:center;';
    zoomLbl.textContent = '1.0x';

    var zoomIn = document.createElement('button');
    zoomIn.textContent = '+';
    zoomIn.title = 'Zoom in';
    zoomIn.style.cssText = 'background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);border-radius:4px;color:#ccc;cursor:pointer;padding:1px 7px;font-size:14px;';
    zoomIn.addEventListener('click', function() {
      mapZoom = Math.min(mapZoomMax, mapZoom + 0.25);
    });

    toolbar.appendChild(zoomOut);
    toolbar.appendChild(zoomLbl);
    toolbar.appendChild(zoomIn);

    panel.appendChild(toolbar);

    var canvasWrap = document.createElement('div');
    canvasWrap.style.cssText = [
      'flex:1',
      'position:relative',
      'overflow:hidden',
      'margin:8px'
    ].join(';');

    mapCanvas = document.createElement('canvas');
    mapCanvas.id = 'world-map-canvas';
    mapCanvas.width = 496;
    mapCanvas.height = 440;
    mapCanvas.style.cssText = 'display:block;border-radius:5px;cursor:crosshair;';
    mapCtx = mapCanvas.getContext('2d');

    mapCanvas.addEventListener('click', function(e) {
      var rect = mapCanvas.getBoundingClientRect();
      var mx = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
      var my = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
      var world = mapToWorld(mx, my, mapCanvas.width, mapCanvas.height, 12);
      if (_onWarpCallback) {
        _onWarpCallback(world.x, world.z);
      }
    });

    var tooltip = document.createElement('div');
    tooltip.id = 'map-tooltip';
    tooltip.style.cssText = [
      'position:absolute',
      'background:rgba(0,0,0,0.8)',
      'color:#ddd',
      'font-size:10px',
      'padding:3px 7px',
      'border-radius:4px',
      'pointer-events:none',
      'display:none',
      'white-space:nowrap',
      'z-index:10'
    ].join(';');

    mapCanvas.addEventListener('mousemove', function(e) {
      var rect = mapCanvas.getBoundingClientRect();
      var mx = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
      var my = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
      var world = mapToWorld(mx, my, mapCanvas.width, mapCanvas.height, 12);
      var zoneHit = getZoneAtPosition(world.x, world.z);
      var zoneName = zoneHit ? ZONE_DATA[zoneHit].name : 'Wilderness';
      tooltip.style.display = 'block';
      tooltip.style.left = (e.offsetX + 14) + 'px';
      tooltip.style.top = (e.offsetY - 4) + 'px';
      tooltip.textContent = zoneName + '  (' + Math.round(world.x) + ', ' + Math.round(world.z) + ')';
    });
    mapCanvas.addEventListener('mouseleave', function() {
      tooltip.style.display = 'none';
    });

    canvasWrap.appendChild(mapCanvas);
    canvasWrap.appendChild(tooltip);
    panel.appendChild(canvasWrap);

    var footer = document.createElement('div');
    footer.id = 'map-footer';
    footer.style.cssText = [
      'padding:5px 14px 8px',
      'font-size:10px',
      'color:#667',
      'border-top:1px solid rgba(100,136,200,0.1)',
      'flex-shrink:0',
      'text-align:center'
    ].join(';');
    footer.textContent = 'Click map to warp. M to close.';
    panel.appendChild(footer);

    return panel;
  }

  function _renderFrame() {
    if (!mapCtx || !mapCanvas) return;
    var w = mapCanvas.width;
    var h = mapCanvas.height;
    var margin = 12;

    mapPulsePhase = (mapPulsePhase + 0.02) % 1.0;

    renderMap(mapCtx, w, h, {
      currentZone: _currentZone,
      margin: margin,
      showGrid: true,
      showConnections: true,
      showLabels: true
    });

    if (layerAnchors) {
      renderAnchors(mapCtx, _anchors, { canvasW: w, canvasH: h, margin: margin });
    }
    if (layerPortals) {
      renderPortals(mapCtx, _portals, { canvasW: w, canvasH: h, margin: margin });
    }
    if (layerNPCs) {
      renderNPCMarkers(mapCtx, _npcs, { canvasW: w, canvasH: h, margin: margin });
    }

    renderPlayerMarker(mapCtx, _playerX, _playerZ, {
      canvasW: w,
      canvasH: h,
      margin: margin,
      pulse: mapPulsePhase
    });

    renderLegend(mapCtx, {
      canvasW: w,
      canvasH: h,
      showNPCs: layerNPCs,
      showPortals: layerPortals,
      showAnchors: layerAnchors
    });

    if (typeof document !== 'undefined') {
      var zl = document.getElementById('map-zoom-label');
      if (zl) zl.textContent = mapZoom.toFixed(2) + 'x';
    }
  }

  function _animateMap() {
    if (!mapVisible) return;
    _renderFrame();
    if (typeof requestAnimationFrame !== 'undefined') {
      mapAnimFrame = requestAnimationFrame(_animateMap);
    }
  }

  function showMapPanel(options) {
    options = options || {};
    if (typeof document === 'undefined') return;

    if (options.onWarp) _onWarpCallback = options.onWarp;

    if (!mapPanelEl) {
      mapPanelEl = _createMapPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && mapPanelEl) {
        hud.appendChild(mapPanelEl);
      } else if (mapPanelEl) {
        document.body.appendChild(mapPanelEl);
      }
    }

    if (!mapPanelEl) return;

    mapPanelEl.style.display = 'flex';
    mapVisible = true;
    _animateMap();
  }

  function hideMapPanel() {
    if (mapPanelEl) {
      mapPanelEl.style.display = 'none';
    }
    mapVisible = false;
    if (mapAnimFrame && typeof cancelAnimationFrame !== 'undefined') {
      cancelAnimationFrame(mapAnimFrame);
      mapAnimFrame = null;
    }
  }

  function toggleMapPanel(options) {
    if (mapVisible) {
      hideMapPanel();
    } else {
      showMapPanel(options);
    }
  }

  function isMapVisible() {
    return mapVisible;
  }

  exports.ZONE_COLORS = ZONE_COLORS;
  exports.ZONE_DATA = ZONE_DATA;
  exports.ZONE_CONNECTIONS = ZONE_CONNECTIONS;
  exports.WORLD_MIN = WORLD_MIN;
  exports.WORLD_MAX = WORLD_MAX;
  exports.WORLD_RANGE = WORLD_RANGE;

  exports.worldToMap = worldToMap;
  exports.mapToWorld = mapToWorld;
  exports.getZoneBounds = getZoneBounds;

  exports.getZoneAtPosition = getZoneAtPosition;
  exports.getDistanceToZone = getDistanceToZone;
  exports.getNearestZone = getNearestZone;
  exports.calculatePath = calculatePath;

  exports.renderMap = renderMap;
  exports.renderPlayerMarker = renderPlayerMarker;
  exports.renderNPCMarkers = renderNPCMarkers;
  exports.renderPortals = renderPortals;
  exports.renderAnchors = renderAnchors;
  exports.renderLegend = renderLegend;

  exports.showMapPanel = showMapPanel;
  exports.hideMapPanel = hideMapPanel;
  exports.toggleMapPanel = toggleMapPanel;
  exports.isMapVisible = isMapVisible;
  exports.updateMapData = updateMapData;

})(typeof module !== 'undefined' ? module.exports : (window.WorldMap = {}));


// LAZY_LOAD_START: timelapse

(function(exports) {
  'use strict';

  var ZONES = ['nexus', 'gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena'];

  var ZONE_CENTERS = {
    nexus:     { x: 0,    z: 0    },
    gardens:   { x: 200,  z: 30   },
    athenaeum: { x: 100,  z: -220 },
    studio:    { x: -200, z: -100 },
    wilds:     { x: -30,  z: 260  },
    agora:     { x: -190, z: 120  },
    commons:   { x: 170,  z: 190  },
    arena:     { x: 0,    z: -240 }
  };

  var ZONE_MOOD = {
    nexus:     'welcoming',
    gardens:   'peaceful',
    athenaeum: 'curious',
    studio:    'creative',
    wilds:     'adventurous',
    agora:     'bustling',
    commons:   'communal',
    arena:     'intense'
  };

  var ARCHETYPE_INSTRUMENT = {
    gardener:    'soft pads',
    builder:     'percussion',
    storyteller: 'vocals/melody',
    merchant:    'bass',
    explorer:    'strings',
    teacher:     'piano',
    musician:    'lead synth',
    healer:      'choir',
    philosopher: 'ambient',
    artist:      'bells'
  };

  var ZONE_COLORS = {
    nexus:     '#daa520',
    gardens:   '#4caf50',
    athenaeum: '#2196f3',
    studio:    '#e040fb',
    wilds:     '#ff5722',
    agora:     '#ff9800',
    commons:   '#00bcd4',
    arena:     '#f44336'
  };

  var EVENT_ICONS = {
    join:      '+',
    build:     'B',
    creation:  'C',
    discovery: 'D',
    harvest:   'H',
    trade:     'T',
    plant:     'P',
    craft:     'K',
    weather:   'W',
    milestone: '*',
    ubi:       '$'
  };

  function loadSimData(simJson) {
    var snapshots = simJson.snapshots || [];
    var rawEvents = simJson.notable_events || [];
    var analysis = simJson.analysis || {};

    var frames = [];
    for (var i = 0; i < snapshots.length; i++) {
      var snap = snapshots[i];
      frames.push(_snapshotToFrame(snap, rawEvents));
    }

    var notableEvents = [];
    for (var j = 0; j < rawEvents.length; j++) {
      var ev = rawEvents[j];
      if (Array.isArray(ev) && ev.length >= 3) {
        notableEvents.push({ tick: ev[0], type: ev[1], description: ev[2] });
      } else if (ev && typeof ev === 'object') {
        notableEvents.push(ev);
      }
    }

    var totalTicks = frames.length > 0 ? frames[frames.length - 1].tick : 0;

    return {
      frames: frames,
      totalTicks: totalTicks,
      notableEvents: notableEvents,
      analysis: analysis
    };
  }

  function _snapshotToFrame(snap, rawEvents) {
    var tick = snap.tick || 0;

    var zoneActivity = {};
    var zonePop = snap.zone_populations || {};
    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      zoneActivity[zone] = zonePop[zone] || 0;
    }

    var events = [];
    if (rawEvents) {
      for (var e = 0; e < rawEvents.length; e++) {
        var ev = rawEvents[e];
        var evTick = Array.isArray(ev) ? ev[0] : (ev.tick || 0);
        if (evTick === tick) {
          events.push(Array.isArray(ev)
            ? { tick: ev[0], type: ev[1], description: ev[2] }
            : ev);
        }
      }
    }

    return {
      tick: tick,
      population: snap.population || 0,
      zoneActivity: zoneActivity,
      economy: {
        totalSpark: snap.total_spark || 0,
        gini: snap.gini || 0,
        txnVolume: snap.txn_volume || 0,
        listings: snap.listings || 0,
        activeZones: snap.active_zones || 0
      },
      events: events,
      culture: {
        weather: snap.weather || 'clear',
        season: snap.season || 'spring',
        dayPhase: snap.dayPhase || 'day',
        structures: snap.structures || 0,
        creations: snap.creations || 0,
        gardens: snap.gardens || 0,
        discoveries: snap.discoveries || 0,
        chatMessages: snap.chat_messages || 0
      }
    };
  }

  function getFrame(timeline, tick) {
    if (!timeline || !timeline.frames || tick < 0) return null;
    var frames = timeline.frames;
    for (var i = 0; i < frames.length; i++) {
      if (frames[i].tick === tick) return frames[i];
    }
    return null;
  }

  function interpolateFrame(timeline, t) {
    if (!timeline || !timeline.frames || timeline.frames.length === 0) return null;
    var frames = timeline.frames;

    if (frames.length === 1) {
      return _cloneFrame(frames[0]);
    }

    t = Math.max(0, Math.min(1, t));

    var pos = t * (frames.length - 1);
    var lo = Math.floor(pos);
    var hi = Math.ceil(pos);
    var alpha = pos - lo;

    lo = Math.max(0, Math.min(frames.length - 1, lo));
    hi = Math.max(0, Math.min(frames.length - 1, hi));

    if (lo === hi) return _cloneFrame(frames[lo]);

    var fA = frames[lo];
    var fB = frames[hi];

    var zoneActivity = {};
    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      zoneActivity[zone] = _lerp(fA.zoneActivity[zone], fB.zoneActivity[zone], alpha);
    }

    return {
      tick: _lerp(fA.tick, fB.tick, alpha),
      population: _lerp(fA.population, fB.population, alpha),
      zoneActivity: zoneActivity,
      economy: {
        totalSpark: _lerp(fA.economy.totalSpark, fB.economy.totalSpark, alpha),
        gini: _lerp(fA.economy.gini, fB.economy.gini, alpha),
        txnVolume: _lerp(fA.economy.txnVolume, fB.economy.txnVolume, alpha),
        listings: _lerp(fA.economy.listings, fB.economy.listings, alpha),
        activeZones: _lerp(fA.economy.activeZones, fB.economy.activeZones, alpha)
      },
      events: alpha < 0.5 ? fA.events : fB.events,
      culture: alpha < 0.5 ? fA.culture : fB.culture
    };
  }

  function getSummary(timeline) {
    if (!timeline || !timeline.frames || timeline.frames.length === 0) {
      return { totalTicks: 0, peakPopulation: 0, majorEvents: [], dominantZones: [] };
    }

    var frames = timeline.frames;
    var totalTicks = timeline.totalTicks;
    var peakPopulation = 0;

    var zoneTotal = {};
    for (var z = 0; z < ZONES.length; z++) {
      zoneTotal[ZONES[z]] = 0;
    }

    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      if (frame.population > peakPopulation) {
        peakPopulation = frame.population;
      }
      for (var z2 = 0; z2 < ZONES.length; z2++) {
        var zone = ZONES[z2];
        zoneTotal[zone] += (frame.zoneActivity[zone] || 0);
      }
    }

    var sortedZones = ZONES.slice().sort(function(a, b) {
      return zoneTotal[b] - zoneTotal[a];
    });

    var totalActivity = 0;
    for (var z3 = 0; z3 < ZONES.length; z3++) {
      totalActivity += zoneTotal[ZONES[z3]];
    }
    var avgActivity = totalActivity / ZONES.length;
    var dominantZones = sortedZones.filter(function(z) {
      return zoneTotal[z] > avgActivity;
    });
    if (dominantZones.length === 0) {
      dominantZones = [sortedZones[0]]; // at least one
    }

    return {
      totalTicks: totalTicks,
      peakPopulation: peakPopulation,
      majorEvents: timeline.notableEvents || [],
      dominantZones: dominantZones
    };
  }

  function generateCameraPath(timeline, options) {
    options = options || {};
    var altitude = typeof options.altitude === 'number' ? options.altitude : 150;
    var orbitSpeed = typeof options.orbitSpeed === 'number' ? options.orbitSpeed : 1.0;
    var zoomOnEvents = options.zoomOnEvents !== false;

    var frames = timeline.frames || [];
    if (frames.length === 0) {
      return [_makeKeyframe(0, { x: 0, y: altitude, z: 300 }, { x: 0, y: 0, z: 0 }, 60)];
    }

    var keyframes = [];
    var totalFrames = frames.length;

    for (var i = 0; i < totalFrames; i++) {
      var frame = frames[i];
      var t = totalFrames > 1 ? i / (totalFrames - 1) : 0;

      var angle = t * Math.PI * 2 * orbitSpeed;

      var popFraction = frame.population > 0 ? Math.min(frame.population / 100, 1) : 0;
      var orbitRadius = 400 - popFraction * 150; // 400 â†’ 250

      var dominantZone = _getDominantZone(frame.zoneActivity);
      var focusCenter = ZONE_CENTERS[dominantZone] || ZONE_CENTERS.nexus;

      var focusBlend = 0.3; // 30% pull toward dominant zone
      var lookX = focusCenter.x * focusBlend;
      var lookZ = focusCenter.z * focusBlend;

      var camX = lookX + orbitRadius * Math.cos(angle);
      var camZ = lookZ + orbitRadius * Math.sin(angle);
      var camY = altitude;

      var totalActivity = _sumZoneActivity(frame.zoneActivity);
      var activityFraction = Math.min(totalActivity / 100, 1);
      var fov = 60 - activityFraction * 20; // 60Â° â†’ 40Â°

      if (zoomOnEvents && frame.events && frame.events.length > 0) {
        fov = Math.max(fov - 10, 25);
        var activeCenter = ZONE_CENTERS[dominantZone] || ZONE_CENTERS.nexus;
        camX = activeCenter.x + 80 * Math.cos(angle);
        camZ = activeCenter.z + 80 * Math.sin(angle);
        camY = altitude * 0.6;
      }

      keyframes.push(_makeKeyframe(
        frame.tick,
        { x: camX, y: camY, z: camZ },
        { x: lookX, y: 0, z: lookZ },
        fov
      ));
    }

    return keyframes;
  }

  function getCameraAt(cameraPath, t) {
    if (!cameraPath || cameraPath.length === 0) {
      return _makeKeyframe(0, { x: 0, y: 150, z: 300 }, { x: 0, y: 0, z: 0 }, 60);
    }

    if (cameraPath.length === 1) {
      return {
        position: { x: cameraPath[0].position.x, y: cameraPath[0].position.y, z: cameraPath[0].position.z },
        lookAt: { x: cameraPath[0].lookAt.x, y: cameraPath[0].lookAt.y, z: cameraPath[0].lookAt.z },
        fov: cameraPath[0].fov
      };
    }

    t = Math.max(0, Math.min(1, t));

    var pos = t * (cameraPath.length - 1);
    var lo = Math.floor(pos);
    var hi = Math.ceil(pos);
    var alpha = pos - lo;

    lo = Math.max(0, Math.min(cameraPath.length - 1, lo));
    hi = Math.max(0, Math.min(cameraPath.length - 1, hi));

    if (lo === hi) {
      return {
        position: { x: cameraPath[lo].position.x, y: cameraPath[lo].position.y, z: cameraPath[lo].position.z },
        lookAt: { x: cameraPath[lo].lookAt.x, y: cameraPath[lo].lookAt.y, z: cameraPath[lo].lookAt.z },
        fov: cameraPath[lo].fov
      };
    }

    var kA = cameraPath[lo];
    var kB = cameraPath[hi];

    return {
      position: {
        x: _lerp(kA.position.x, kB.position.x, alpha),
        y: _lerp(kA.position.y, kB.position.y, alpha),
        z: _lerp(kA.position.z, kB.position.z, alpha)
      },
      lookAt: {
        x: _lerp(kA.lookAt.x, kB.lookAt.x, alpha),
        y: _lerp(kA.lookAt.y, kB.lookAt.y, alpha),
        z: _lerp(kA.lookAt.z, kB.lookAt.z, alpha)
      },
      fov: _lerp(kA.fov, kB.fov, alpha)
    };
  }

  function mapToAudio(frame) {
    var dominantZone = _getDominantZone(frame.zoneActivity);
    var harmony = ZONE_MOOD[dominantZone] || 'welcoming';

    var totalActivity = _sumZoneActivity(frame.zoneActivity);
    var activityFraction = Math.min(totalActivity / 100, 1);
    var tempo = 60 + activityFraction * 80;

    var eventWeight = Math.min((frame.events ? frame.events.length : 0) / 5, 1);
    var popFraction = Math.min((frame.population || 0) / 100, 1);
    var intensity = activityFraction * 0.5 + eventWeight * 0.3 + popFraction * 0.2;
    intensity = Math.max(0, Math.min(1, intensity));

    var zoneArchetypes = {
      nexus:     ['gardener', 'builder', 'storyteller', 'merchant', 'teacher', 'musician', 'healer', 'philosopher', 'artist'],
      gardens:   ['gardener', 'healer', 'artist'],
      athenaeum: ['storyteller', 'teacher', 'philosopher'],
      studio:    ['builder', 'musician', 'artist'],
      wilds:     ['explorer', 'philosopher'],
      agora:     ['storyteller', 'merchant', 'musician'],
      commons:   ['gardener', 'merchant', 'healer'],
      arena:     ['builder', 'explorer']
    };

    var activeArchetypes = zoneArchetypes[dominantZone] || [];
    var instruments = [];
    var seen = {};
    for (var a = 0; a < activeArchetypes.length; a++) {
      var instr = ARCHETYPE_INSTRUMENT[activeArchetypes[a]];
      if (instr && !seen[instr]) {
        seen[instr] = true;
        instruments.push(instr);
      }
    }

    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      if (zone !== dominantZone && (frame.zoneActivity[zone] || 0) > 5) {
        var secondaryArchetypes = zoneArchetypes[zone] || [];
        if (secondaryArchetypes.length > 0) {
          var instr2 = ARCHETYPE_INSTRUMENT[secondaryArchetypes[0]];
          if (instr2 && !seen[instr2]) {
            seen[instr2] = true;
            instruments.push(instr2);
          }
        }
      }
    }

    return {
      tempo: Math.round(tempo),
      harmony: harmony,
      intensity: intensity,
      instruments: instruments
    };
  }

  function createController(timeline) {
    var currentTick = 0;
    var totalTicks = timeline.totalTicks || 0;
    var playing = false;
    var speed = 1;
    var frameCallbacks = [];
    var eventCallbacks = [];
    var cameraPath = generateCameraPath(timeline);
    var accumulatedMs = 0;

    var firedEvents = {};

    var TICKS_PER_SECOND = 1;

    function getProgress() {
      var pct = totalTicks > 0 ? (currentTick / totalTicks) * 100 : 0;
      return {
        currentTick: currentTick,
        totalTicks: totalTicks,
        percent: pct
      };
    }

    function seek(tick) {
      currentTick = Math.max(0, Math.min(totalTicks, tick));
      accumulatedMs = 0;
      _fireFrame();
    }

    function play(s) {
      if (typeof s === 'number') speed = s;
      playing = true;
    }

    function pause() {
      playing = false;
    }

    function setSpeed(s) {
      speed = s;
    }

    function getSpeed() {
      return speed;
    }

    function isPlaying() {
      return playing;
    }

    function onFrame(cb) {
      frameCallbacks.push(cb);
    }

    function onEvent(cb) {
      eventCallbacks.push(cb);
    }

    function update(dtMs) {
      if (!playing || totalTicks === 0) {
        _fireFrame();
        return;
      }

      accumulatedMs += dtMs * speed;
      var ticksToAdvance = Math.floor(accumulatedMs / (1000 / TICKS_PER_SECOND));
      accumulatedMs -= ticksToAdvance * (1000 / TICKS_PER_SECOND);

      if (ticksToAdvance <= 0) return;

      var oldTick = currentTick;
      currentTick = Math.min(totalTicks, currentTick + ticksToAdvance);

      if (currentTick !== oldTick) {
        _fireFrame();
        _checkEvents(oldTick, currentTick);
      }

      if (currentTick >= totalTicks) {
        playing = false;
      }
    }

    function _fireFrame() {
      if (frameCallbacks.length === 0) return;
      var t = totalTicks > 0 ? currentTick / totalTicks : 0;
      var interpFrame = interpolateFrame(timeline, t);
      var cam = getCameraAt(cameraPath, t);
      var audio = mapToAudio(interpFrame || (timeline.frames[0] || {}));
      var data = { frame: interpFrame, camera: cam, audio: audio };
      for (var i = 0; i < frameCallbacks.length; i++) {
        frameCallbacks[i](data);
      }
    }

    function _checkEvents(fromTick, toTick) {
      if (eventCallbacks.length === 0) return;
      var events = timeline.notableEvents || [];
      for (var i = 0; i < events.length; i++) {
        var ev = events[i];
        var evTick = ev.tick || 0;
        var evKey = evTick + '_' + i;
        if (evTick > fromTick && evTick <= toTick && !firedEvents[evKey]) {
          firedEvents[evKey] = true;
          for (var j = 0; j < eventCallbacks.length; j++) {
            eventCallbacks[j](ev);
          }
        }
      }
    }

    return {
      play: play,
      pause: pause,
      seek: seek,
      getProgress: getProgress,
      onFrame: onFrame,
      onEvent: onEvent,
      setSpeed: setSpeed,
      getSpeed: getSpeed,
      isPlaying: isPlaying,
      update: update
    };
  }

  function renderMinimap(ctx, frame, width, height) {
    var pad = 10;
    var w = width - pad * 2;
    var h = height - pad * 2;

    var WORLD_SIZE = 320;

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, width, height);

    ctx.strokeStyle = '#1a1f30';
    ctx.lineWidth = 1;
    ctx.strokeRect(pad, pad, w, h);

    var maxActivity = 0;
    for (var z = 0; z < ZONES.length; z++) {
      var act = frame.zoneActivity[ZONES[z]] || 0;
      if (act > maxActivity) maxActivity = act;
    }
    if (maxActivity === 0) maxActivity = 1;

    for (var i = 0; i < ZONES.length; i++) {
      var zoneName = ZONES[i];
      var center = ZONE_CENTERS[zoneName];
      var activity = frame.zoneActivity[zoneName] || 0;
      var color = ZONE_COLORS[zoneName];

      var cx = pad + ((center.x + WORLD_SIZE) / (WORLD_SIZE * 2)) * w;
      var cy = pad + ((-center.z + WORLD_SIZE) / (WORLD_SIZE * 2)) * h; // Z is inverted

      var radius = 4 + (activity / maxActivity) * 16;

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.3 + (activity / maxActivity) * 0.7;
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#ffffff';
      ctx.font = '9px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(zoneName.charAt(0).toUpperCase(), cx, cy + 3);

      if (activity > 0) {
        ctx.fillStyle = color;
        ctx.font = '8px monospace';
        ctx.fillText(String(Math.round(activity)), cx, cy + radius + 10);
      }
    }

    ctx.textAlign = 'left';

    ctx.fillStyle = '#daa520';
    ctx.font = 'bold 11px monospace';
    ctx.fillText('Pop: ' + Math.round(frame.population), pad + 4, pad + 14);
  }

  function renderTimeline(ctx, timeline, currentTick, width, height) {
    var pad = 20;
    var barH = 8;
    var barY = height / 2 - barH / 2;
    var barW = width - pad * 2;

    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, width, height);

    ctx.fillStyle = '#1a1f30';
    ctx.fillRect(pad, barY, barW, barH);

    var frames = timeline.frames || [];
    var totalTicks = timeline.totalTicks || 1;

    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      var t = totalTicks > 0 ? frame.tick / totalTicks : 0;
      var x = pad + t * barW;
      var segW = frames.length > 1 && i < frames.length - 1
        ? (frames[i + 1].tick - frame.tick) / totalTicks * barW
        : 4;

      var dominantZone = _getDominantZone(frame.zoneActivity);
      ctx.fillStyle = ZONE_COLORS[dominantZone] || '#888';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(x, barY, Math.max(segW, 2), barH);
      ctx.globalAlpha = 1;
    }

    var events = timeline.notableEvents || [];
    for (var e = 0; e < events.length; e++) {
      var ev = events[e];
      var evTick = ev.tick || 0;
      var evT = totalTicks > 0 ? evTick / totalTicks : 0;
      var evX = pad + evT * barW;
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(evX - 1, barY - 3, 2, barH + 6);
      ctx.globalAlpha = 1;
    }

    var progress = totalTicks > 0 ? currentTick / totalTicks : 0;
    var playX = pad + progress * barW;
    ctx.fillStyle = '#daa520';
    ctx.fillRect(playX - 2, barY - 4, 4, barH + 8);

    ctx.fillStyle = '#666';
    ctx.font = '10px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('Tick 0', pad, height - 4);
    ctx.textAlign = 'right';
    ctx.fillText('Tick ' + totalTicks, pad + barW, height - 4);
    ctx.textAlign = 'center';
    ctx.fillText('Tick ' + Math.round(currentTick), playX, barY - 8);
    ctx.textAlign = 'left';
  }

  function renderStats(ctx, frame, x, y) {
    var lineH = 18;
    var padX = 12;
    var padY = 10;
    var bgW = 180;
    var bgH = 8 * lineH + padY * 2;

    ctx.fillStyle = 'rgba(10, 14, 26, 0.85)';
    ctx.fillRect(x, y, bgW, bgH);
    ctx.strokeStyle = '#1a1f30';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, bgW, bgH);

    ctx.fillStyle = '#daa520';
    ctx.font = 'bold 12px monospace';
    ctx.fillText('TICK ' + Math.round(frame.tick || 0), x + padX, y + padY + lineH * 0.7);

    var stats = [
      ['Population', Math.round(frame.population || 0)],
      ['Spark', Math.round((frame.economy && frame.economy.totalSpark) || 0)],
      ['Gini', ((frame.economy && frame.economy.gini) || 0).toFixed(3)],
      ['Weather', (frame.culture && frame.culture.weather) || 'clear'],
      ['Season', (frame.culture && frame.culture.season) || 'spring'],
      ['Phase', (frame.culture && frame.culture.dayPhase) || 'day'],
      ['Structures', (frame.culture && frame.culture.structures) || 0]
    ];

    ctx.font = '11px monospace';
    for (var i = 0; i < stats.length; i++) {
      var ly = y + padY + lineH * (i + 1.5);
      ctx.fillStyle = '#888';
      ctx.fillText(stats[i][0], x + padX, ly);
      ctx.fillStyle = '#e0e0e0';
      ctx.fillText(String(stats[i][1]), x + padX + 100, ly);
    }
  }

  function renderEventBanner(ctx, event) {
    var desc = (event && event.description) ? event.description : '';
    var type = (event && event.type) ? event.type : 'event';
    var icon = EVENT_ICONS[type] || '!';

    var bgColors = {
      discovery: '#0d2a0d',
      milestone: '#1a1400',
      build:     '#0a1a2a',
      creation:  '#1a0a1a',
      join:      '#0a1a0a',
      trade:     '#1a0f00',
      harvest:   '#0a1a0a',
      ubi:       '#0a0a1a'
    };
    var textColors = {
      discovery: '#4caf50',
      milestone: '#daa520',
      build:     '#2196f3',
      creation:  '#e040fb',
      join:      '#00bcd4',
      trade:     '#ff9800',
      harvest:   '#8bc34a',
      ubi:       '#9c27b0'
    };

    var bgColor = bgColors[type] || '#0a0e1a';
    var textColor = textColors[type] || '#e0e0e0';

    var bannerH = 44;
    var bannerY = 0;

    ctx.fillStyle = bgColor;
    ctx.fillRect(0, bannerY, 800, bannerH); // use 800 as default width

    ctx.strokeStyle = textColor;
    ctx.lineWidth = 2;
    ctx.strokeRect(0, bannerY, 800, bannerH);

    ctx.fillStyle = textColor;
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('[' + icon + ']', 16, bannerY + 28);

    ctx.fillStyle = '#e0e0e0';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText(desc, 60, bannerY + 28);

    ctx.textAlign = 'left';
  }

  function _lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function _cloneFrame(frame) {
    var zoneActivity = {};
    for (var z = 0; z < ZONES.length; z++) {
      zoneActivity[ZONES[z]] = frame.zoneActivity[ZONES[z]] || 0;
    }
    return {
      tick: frame.tick,
      population: frame.population,
      zoneActivity: zoneActivity,
      economy: {
        totalSpark: frame.economy.totalSpark,
        gini: frame.economy.gini,
        txnVolume: frame.economy.txnVolume,
        listings: frame.economy.listings,
        activeZones: frame.economy.activeZones
      },
      events: frame.events,
      culture: frame.culture
    };
  }

  function _makeKeyframe(tick, position, lookAt, fov) {
    return { tick: tick, position: position, lookAt: lookAt, fov: fov };
  }

  function _getDominantZone(zoneActivity) {
    var best = ZONES[0];
    var bestVal = -1;
    for (var z = 0; z < ZONES.length; z++) {
      var val = zoneActivity[ZONES[z]] || 0;
      if (val > bestVal) {
        bestVal = val;
        best = ZONES[z];
      }
    }
    return best;
  }

  function _sumZoneActivity(zoneActivity) {
    var total = 0;
    for (var z = 0; z < ZONES.length; z++) {
      total += zoneActivity[ZONES[z]] || 0;
    }
    return total;
  }

  exports.loadSimData = loadSimData;
  exports.getFrame = getFrame;
  exports.interpolateFrame = interpolateFrame;
  exports.getSummary = getSummary;
  exports.generateCameraPath = generateCameraPath;
  exports.getCameraAt = getCameraAt;
  exports.mapToAudio = mapToAudio;
  exports.createController = createController;
  exports.renderMinimap = renderMinimap;
  exports.renderTimeline = renderTimeline;
  exports.renderStats = renderStats;
  exports.renderEventBanner = renderEventBanner;

  exports.ZONES = ZONES;
  exports.ZONE_CENTERS = ZONE_CENTERS;
  exports.ZONE_MOOD = ZONE_MOOD;
  exports.ZONE_COLORS = ZONE_COLORS;
  exports.ARCHETYPE_INSTRUMENT = ARCHETYPE_INSTRUMENT;

})(typeof module !== 'undefined' ? module.exports : (window.Timelapse = {}));

// LAZY_LOAD_END: timelapse

// input.js
(function(exports) {
  var callbacks = {};
  var keys = {};
  var chatMode = false;
  var buildMode = false;
  var canvas = null;
  var mouseNDC = { x: 0, y: 0 }; // Normalized device coordinates

  var cameraDistance = 20; // Default camera distance from player
  var cameraOrbitAngle = 0; // Horizontal orbit angle in radians
  var isDraggingCamera = false;
  var lastCameraDragX = 0;
  var lastCameraDragY = 0;

  function initInput(cbs) {
    callbacks = cbs || {};

    if (typeof document === 'undefined') {
      console.warn('Input requires browser environment');
      return;
    }

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.addEventListener('click', handleMouseClick);
      canvas.addEventListener('contextmenu', handleContextMenu);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('wheel', handleMouseWheel, { passive: false });
    }

    document.addEventListener('mouseup', handleMouseUp);

    if ('ontouchstart' in window) {
      initTouchControls();
    }

    console.log('Input system initialized');
  }

  function handleKeyDown(e) {
    if (chatMode && e.key !== 'Escape' && e.key !== 'Enter') {
      return;
    }

    keys[e.key.toLowerCase()] = true;

    switch (e.key) {
      case 'Enter':
        if (chatMode) {
          chatMode = false;
        } else {
          chatMode = true;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: 'open' });
          }
        }
        e.preventDefault();
        break;

      case 'Escape':
        chatMode = false;
        buildMode = false;
        if (callbacks.onAction) {
          callbacks.onAction('toggleSettings', {});
        }
        e.preventDefault();
        break;

      case 'b':
      case 'B':
        if (!chatMode) {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
          e.preventDefault();
        }
        break;

      case 'e':
      case 'E':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('interact', {});
          }
          e.preventDefault();
        }
        break;

      case 'i':
      case 'I':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleInventory', {});
          }
          e.preventDefault();
        }
        break;

      case 'c':
      case 'C':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleCrafting', {});
          }
          e.preventDefault();
        }
        break;

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '0':
        if (!chatMode) {
          if (buildMode && callbacks.onBuild) {
            var typeIndex = (e.key === '0' ? 9 : parseInt(e.key) - 1);
            callbacks.onBuild({ action: 'selectType', typeIndex: typeIndex });
          } else if (callbacks.onAction && parseInt(e.key) >= 1 && parseInt(e.key) <= 5) {
            callbacks.onAction('useQuickSlot', { slot: parseInt(e.key) - 1 });
          }
          e.preventDefault();
        }
        break;

      case 'j':
      case 'J':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggle_quest_log', {});
          }
          e.preventDefault();
        }
        break;

      case 't':
      case 'T':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('initiate_trade', {});
          }
          e.preventDefault();
        }
        break;

      case 'f':
      case 'F':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleEmoteMenu', {});
          }
          e.preventDefault();
        }
        break;

      case 'm':
      case 'M':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleMap', {});
          }
          e.preventDefault();
        }
        break;

      case 'p':
      case 'P':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleProfile', {});
          }
          e.preventDefault();
        }
        break;

      case 'k':
      case 'K':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleSkills', {});
          }
          e.preventDefault();
        }
        break;

      case 'n':
      case 'N':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleCompose', {});
          }
          e.preventDefault();
        }
        break;

      case 'g':
      case 'G':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleGuild', {});
          }
          e.preventDefault();
        }
        break;

      case 'l':
      case 'L':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleLoreJournal', {});
          }
          e.preventDefault();
        }
        break;

      case 'v':
      case 'V':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleDiscoveryLog', {});
          }
          e.preventDefault();
        }
        break;

      case 'h':
      case 'H':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleGovernance', {});
          }
          e.preventDefault();
        }
        break;

      case 'u':
      case 'U':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAuctionHouse', {});
          }
          e.preventDefault();
        }
        break;

      case 'y':
      case 'Y':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAchievements', {});
          }
          e.preventDefault();
        }
        break;

      case 'r':
      case 'R':
        if (!chatMode && buildMode) {
          if (callbacks.onBuild) {
            callbacks.onBuild({ action: 'rotate' });
          }
          e.preventDefault();
        }
        break;

      case 'q':
      case 'Q':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('togglePetPanel', {});
          }
          e.preventDefault();
        }
        break;

      case 'x':
      case 'X':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('startFishing', {});
          }
          e.preventDefault();
        }
        break;

      case 'j':
      case 'J':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAnchorPanel', {});
          }
          e.preventDefault();
        }
        break;

      case 'n':
      case 'N':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleFederationProposal', {});
          }
          e.preventDefault();
        }
        break;

      case 'z':
      case 'Z':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleHousing', {});
          }
          e.preventDefault();
        }
        break;

      case 'F2':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('togglePhotoMode', {});
          }
          e.preventDefault();
        }
        break;
    }

    if (!chatMode && (keys['f'] || keys['F'])) {
      var emoteType = null;
      switch (e.key) {
        case '1': emoteType = 'wave'; break;
        case '2': emoteType = 'dance'; break;
        case '3': emoteType = 'bow'; break;
        case '4': emoteType = 'cheer'; break;
        case '5': emoteType = 'meditate'; break;
        case '6': emoteType = 'point'; break;
      }
      if (emoteType && callbacks.onAction) {
        callbacks.onAction('emote', { type: emoteType });
        e.preventDefault();
      }
    }
  }

  function handleKeyUp(e) {
    keys[e.key.toLowerCase()] = false;
  }

  function handleMouseClick(e) {
    if (!canvas) return;

    var rect = canvas.getBoundingClientRect();
    var x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    var y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    if (buildMode && callbacks.onBuild) {
      callbacks.onBuild({ action: 'place', x: x, y: y });
    } else if (callbacks.onAction) {
      callbacks.onAction('click', { x, y, screenX: e.clientX, screenY: e.clientY });
    }
  }

  function handleContextMenu(e) {
    e.preventDefault();

    if (callbacks.onAction) {
      callbacks.onAction('context', { x: e.clientX, y: e.clientY });
    }
  }

  function handleMouseMove(e) {
    if (!canvas) return;

    var rect = canvas.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    if (isDraggingCamera) {
      var deltaX = e.clientX - lastCameraDragX;
      var deltaY = e.clientY - lastCameraDragY;

      cameraOrbitAngle -= deltaX * 0.005;

      lastCameraDragX = e.clientX;
      lastCameraDragY = e.clientY;
    }
  }

  function handleMouseDown(e) {
    if (e.button === 2 || e.button === 1) {
      isDraggingCamera = true;
      lastCameraDragX = e.clientX;
      lastCameraDragY = e.clientY;
      e.preventDefault();
    }
  }

  function handleMouseUp(e) {
    if (e.button === 2 || e.button === 1) {
      isDraggingCamera = false;
    }
  }

  function handleMouseWheel(e) {
    e.preventDefault();

    cameraDistance += e.deltaY * 0.02;
    cameraDistance = Math.max(5, Math.min(50, cameraDistance));
  }

  function getMouseNDC() {
    return mouseNDC;
  }

  function getCameraDistance() {
    return cameraDistance;
  }

  function getCameraOrbit() {
    return cameraOrbitAngle;
  }

  function initTouchControls() {
    if (typeof document === 'undefined') return;

    var platform = getPlatform();
    if (platform !== 'phone') return;

    var joystick = document.createElement('div');
    joystick.id = 'virtual-joystick';
    joystick.style.cssText = `
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      border: 3px solid rgba(218,165,32,0.6);
      touch-action: none;
      z-index: 1000;
    `;

    var stick = document.createElement('div');
    stick.style.cssText = `
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(218,165,32,0.8);
      top: 35px;
      left: 35px;
      touch-action: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    joystick.appendChild(stick);
    document.body.appendChild(joystick);

    var touchStartPos = { x: 0, y: 0 };
    var isDragging = false;

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      var touch = e.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
    });

    joystick.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      e.preventDefault();

      var touch = e.touches[0];
      var deltaX = touch.clientX - touchStartPos.x;
      var deltaY = touch.clientY - touchStartPos.y;

      var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      var maxDistance = 35;
      var normalizedDelta = {
        x: deltaX / maxDistance,
        y: deltaY / maxDistance
      };

      if (distance > maxDistance) {
        stick.style.left = (35 + (deltaX / distance) * maxDistance) + 'px';
        stick.style.top = (35 + (deltaY / distance) * maxDistance) + 'px';
      } else {
        stick.style.left = (35 + deltaX) + 'px';
        stick.style.top = (35 + deltaY) + 'px';
      }

      if (callbacks.onMove) {
        callbacks.onMove({
          x: normalizedDelta.x,
          y: 0,
          z: -normalizedDelta.y // Invert Y for forward/back
        });
      }
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      isDragging = false;
      stick.style.left = '35px';
      stick.style.top = '35px';
    });

    var actionButtons = [
      { label: 'E', action: 'interact', size: 50, angle: 0, radius: 0, color: 'rgba(218,165,32,0.7)' },
      { label: 'I', action: 'toggleInventory', size: 45, angle: -45, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'J', action: 'toggle_quest_log', size: 45, angle: -90, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'B', action: 'toggleBuild', size: 45, angle: 45, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'ðŸ’¬', action: 'toggleChat', size: 45, angle: 90, radius: 70, color: 'rgba(218,165,32,0.7)' }
    ];

    var baseX = window.innerWidth - 80;
    var baseY = window.innerHeight - 80;

    actionButtons.forEach(function(btn) {
      var button = document.createElement('button');
      button.textContent = btn.label;

      var angleRad = (btn.angle * Math.PI) / 180;
      var x = baseX + btn.radius * Math.cos(angleRad);
      var y = baseY + btn.radius * Math.sin(angleRad);

      button.style.cssText = `
        position: fixed;
        bottom: ${window.innerHeight - y - btn.size/2}px;
        right: ${window.innerWidth - x - btn.size/2}px;
        width: ${btn.size}px;
        height: ${btn.size}px;
        border-radius: 50%;
        background: ${btn.color};
        border: 3px solid rgba(218,165,32,0.9);
        color: white;
        font-size: ${btn.size === 50 ? 20 : 16}px;
        font-weight: bold;
        z-index: 1000;
        touch-action: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        display: flex;
        align-items: center;
        justify-content: center;
      `;

      button.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (btn.action === 'toggleBuild') {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
        } else if (btn.action === 'toggleChat') {
          chatMode = !chatMode;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: chatMode ? 'open' : 'close' });
          }
        } else if (callbacks.onAction) {
          callbacks.onAction(btn.action, {});
        }
      });

      document.body.appendChild(button);
    });

    var lastPinchDistance = 0;

    if (canvas) {
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
    }

    var touchStartTime = 0;
    var touchStartX = 0;
    var touchStartY = 0;
    var lastTouchX = 0;
    var lastTouchY = 0;
    var isTouchDragging = false;
    var wasPinching = false;

    function handleTouchStart(e) {
      if (e.touches.length === 2) {
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
        wasPinching = true;
        isTouchDragging = false;
      } else if (e.touches.length === 1) {
        touchStartTime = Date.now();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        isTouchDragging = false;
        wasPinching = false;
      }
    }

    function handleTouchMove(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        var distance = Math.sqrt(dx * dx + dy * dy);

        if (lastPinchDistance > 0) {
          var delta = lastPinchDistance - distance;
          cameraDistance += delta * 0.1;
          cameraDistance = Math.max(5, Math.min(50, cameraDistance));
        }

        lastPinchDistance = distance;
        wasPinching = true;
      } else if (e.touches.length === 1 && !wasPinching) {
        var touchX = e.touches[0].clientX;
        var touchY = e.touches[0].clientY;
        var totalDx = touchX - touchStartX;
        var totalDy = touchY - touchStartY;
        var totalMoved = Math.sqrt(totalDx * totalDx + totalDy * totalDy);

        if (totalMoved > 10) {
          isTouchDragging = true;
          var deltaX = touchX - lastTouchX;
          cameraOrbitAngle -= deltaX * 0.008;
        }

        lastTouchX = touchX;
        lastTouchY = touchY;
      }
    }

    function handleTouchEnd(e) {
      if (e.touches.length < 2) {
        lastPinchDistance = 0;
      }

      if (!wasPinching && !isTouchDragging && e.changedTouches.length === 1 && touchStartTime > 0) {
        var touchEndTime = Date.now();
        var touchEndX = e.changedTouches[0].clientX;
        var touchEndY = e.changedTouches[0].clientY;

        var timeDiff = touchEndTime - touchStartTime;
        var dx = touchEndX - touchStartX;
        var dy = touchEndY - touchStartY;
        var distanceMoved = Math.sqrt(dx * dx + dy * dy);

        if (timeDiff < 300 && distanceMoved < 10) {
          var rect = canvas.getBoundingClientRect();
          var x = ((touchEndX - rect.left) / rect.width) * 2 - 1;
          var y = -((touchEndY - rect.top) / rect.height) * 2 + 1;

          if (callbacks.onAction) {
            callbacks.onAction('click', { x: x, y: y, screenX: touchEndX, screenY: touchEndY });
          }
        }
      }

      isTouchDragging = false;
      wasPinching = false;
    }
  }

  function getMovementDelta() {
    if (chatMode) return { x: 0, y: 0, z: 0 };

    var delta = { x: 0, y: 0, z: 0 };

    if (keys['w'] || keys['arrowup']) delta.z -= 1;
    if (keys['s'] || keys['arrowdown']) delta.z += 1;
    if (keys['a'] || keys['arrowleft']) delta.x -= 1;
    if (keys['d'] || keys['arrowright']) delta.x += 1;

    if (delta.x !== 0 && delta.z !== 0) {
      var length = Math.sqrt(delta.x * delta.x + delta.z * delta.z);
      delta.x /= length;
      delta.z /= length;
    }

    return delta;
  }

  function getPlatform() {
    if (typeof navigator === 'undefined') return 'desktop';

    var ua = navigator.userAgent.toLowerCase();

    if (navigator.xr) {
      return 'desktop'; // Default, can be upgraded to VR/AR when session starts
    }

    if (/mobile|android|iphone|ipad|tablet/.test(ua)) {
      return 'phone';
    }

    return 'desktop';
  }

  function createMoveMessage(from, delta, currentPosition, zone) {
    var baseSpeed = 0.3; // Units per frame
    var speed = (keys['shift']) ? baseSpeed * 2.0 : baseSpeed; // Sprint with Shift
    var newPosition = {
      x: currentPosition.x + delta.x * speed,
      y: currentPosition.y + delta.y * speed,
      z: currentPosition.z + delta.z * speed
    };

    return {
      type: 'move',
      from: from,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        position: newPosition,
        zone: zone
      }
    };
  }

  exports.initInput = initInput;
  exports.getMovementDelta = getMovementDelta;
  exports.getPlatform = getPlatform;
  exports.createMoveMessage = createMoveMessage;
  exports.getMouseNDC = getMouseNDC;
  exports.getCameraDistance = getCameraDistance;
  exports.getCameraOrbit = getCameraOrbit;

})(typeof module !== 'undefined' ? module.exports : (window.Input = {}));


// hud.js
(function(exports) {
  let hudContainer = null;
  let chatPanel = null;
  let playerInfoPanel = null;
  let minimapCanvas = null;
  let minimapCtx = null;
  let zoneLabel = null;
  let nearbyPlayersList = null;
  let chatInput = null;
  let notificationContainer = null;
  let federationPanel = null;

  function initHUD(container) {
    if (typeof document === 'undefined') {
      console.warn('HUD requires browser environment');
      return;
    }

    hudContainer = container;

    const hudOverlay = document.createElement('div');
    hudOverlay.id = 'zion-hud';
    hudOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      font-family: Arial, sans-serif;
      color: white;
      z-index: 100;
    `;

    chatPanel = document.createElement('div');
    chatPanel.id = 'chat-panel';
    chatPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 350px;
      height: 200px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      pointer-events: auto;
      font-size: 14px;
    `;
    hudOverlay.appendChild(chatPanel);

    playerInfoPanel = document.createElement('div');
    playerInfoPanel.id = 'player-info';
    playerInfoPanel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      min-width: 200px;
      pointer-events: auto;
    `;
    hudOverlay.appendChild(playerInfoPanel);

    zoneLabel = document.createElement('div');
    zoneLabel.id = 'zone-label';
    zoneLabel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
    `;
    hudOverlay.appendChild(zoneLabel);

    const minimapContainer = document.createElement('div');
    minimapContainer.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      pointer-events: auto;
    `;

    minimapCanvas = document.createElement('canvas');
    minimapCanvas.width = 200;
    minimapCanvas.height = 200;
    minimapCanvas.style.cssText = `
      display: block;
      border-radius: 4px;
    `;
    minimapCtx = minimapCanvas.getContext('2d');
    minimapContainer.appendChild(minimapCanvas);
    hudOverlay.appendChild(minimapContainer);

    nearbyPlayersList = document.createElement('div');
    nearbyPlayersList.id = 'nearby-players';
    nearbyPlayersList.style.cssText = `
      position: absolute;
      top: 200px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      min-width: 150px;
      max-height: 300px;
      overflow-y: auto;
      pointer-events: auto;
    `;
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';
    hudOverlay.appendChild(nearbyPlayersList);

    federationPanel = document.createElement('div');
    federationPanel.id = 'federation-panel';
    federationPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      padding: 10px;
      min-width: 200px;
      max-height: 250px;
      overflow-y: auto;
      pointer-events: auto;
      border: 2px solid rgba(100, 100, 255, 0.5);
    `;
    federationPanel.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #88f;">Federation</div>';
    hudOverlay.appendChild(federationPanel);

    notificationContainer = document.createElement('div');
    notificationContainer.id = 'notifications';
    notificationContainer.style.cssText = `
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      pointer-events: none;
    `;
    hudOverlay.appendChild(notificationContainer);

    container.appendChild(hudOverlay);

    console.log('HUD initialized');
  }

  function updateChat(messages) {
    if (!chatPanel) return;

    chatPanel.innerHTML = '';

    messages.slice(-10).forEach(msg => {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `
        margin-bottom: 5px;
        padding: 3px;
        border-radius: 3px;
      `;

      const time = new Date(msg.timestamp).toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });

      msgEl.innerHTML = `
        <span style="color: #888; font-size: 11px;">${time}</span>
        <span style="color: #4af; font-weight: bold;">${msg.user}:</span>
        <span>${msg.text}</span>
      `;

      chatPanel.appendChild(msgEl);
    });

    chatPanel.scrollTop = chatPanel.scrollHeight;
  }

  function addChatMessage(user, text) {
    if (!chatPanel || typeof document === 'undefined') return;

    var msgEl = document.createElement('div');
    msgEl.style.cssText = 'margin-bottom:5px;padding:3px;border-radius:3px;';

    var time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    msgEl.innerHTML =
      '<span style="color:#888;font-size:11px;">' + time + '</span> ' +
      '<span style="color:#4af;font-weight:bold;">' + (user || 'Unknown') + ':</span> ' +
      '<span>' + (text || '') + '</span>';

    chatPanel.appendChild(msgEl);
    chatPanel.scrollTop = chatPanel.scrollHeight;

    while (chatPanel.children.length > 50) {
      chatPanel.removeChild(chatPanel.firstChild);
    }
  }

  function updatePlayerInfo(player) {
    if (!playerInfoPanel) return;

    playerInfoPanel.innerHTML = `
      <div style="font-weight: bold; font-size: 16px; margin-bottom: 8px;">${player.name || 'Unknown'}</div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ffa500;">Spark:</span> ${player.spark || 0}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #4af;">Zone:</span> ${player.zone || 'Unknown'}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ff6347;">Warmth:</span> ${Math.round(player.warmth || 0)}%
      </div>
    `;
  }

  var MINIMAP_ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, color: '#6688cc', label: 'Nexus' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, color: '#44aa44', label: 'Gardens' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, color: '#8866aa', label: 'Athenaeum' },
    studio:     { cx: -200, cz: -100, radius: 60, color: '#cc6688', label: 'Studio' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, color: '#228844', label: 'Wilds' },
    agora:      { cx: -190, cz: 120,  radius: 55, color: '#cc8844', label: 'Agora' },
    commons:    { cx: 170,  cz: 190,  radius: 55, color: '#88aa44', label: 'Commons' },
    arena:      { cx: 0,    cz: -240, radius: 55, color: '#cc4444', label: 'Arena' }
  };

  function updateMinimap(players, currentZone) {
    if (!minimapCtx) return;

    var w = minimapCanvas.width;
    var h = minimapCanvas.height;

    minimapCtx.fillStyle = '#0a0e1a';
    minimapCtx.fillRect(0, 0, w, h);

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var margin = 8;

    function worldToMap(wx, wz) {
      return {
        x: margin + ((wx - worldMin) / worldRange) * (w - margin * 2),
        y: margin + ((wz - worldMin) / worldRange) * (h - margin * 2)
      };
    }

    minimapCtx.strokeStyle = 'rgba(255,255,255,0.15)';
    minimapCtx.lineWidth = 1;
    var nexusPos = worldToMap(0, 0);
    for (var zId in MINIMAP_ZONES) {
      if (zId === 'nexus') continue;
      var z = MINIMAP_ZONES[zId];
      var zPos = worldToMap(z.cx, z.cz);
      minimapCtx.beginPath();
      minimapCtx.moveTo(nexusPos.x, nexusPos.y);
      minimapCtx.lineTo(zPos.x, zPos.y);
      minimapCtx.stroke();
    }

    for (var zoneId in MINIMAP_ZONES) {
      var zone = MINIMAP_ZONES[zoneId];
      var pos = worldToMap(zone.cx, zone.cz);
      var r = (zone.radius / worldRange) * (w - margin * 2);

      minimapCtx.globalAlpha = zoneId === currentZone ? 0.4 : 0.2;
      minimapCtx.fillStyle = zone.color;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      minimapCtx.fill();

      minimapCtx.globalAlpha = zoneId === currentZone ? 0.9 : 0.4;
      minimapCtx.strokeStyle = zone.color;
      minimapCtx.lineWidth = zoneId === currentZone ? 2 : 1;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      minimapCtx.stroke();

      minimapCtx.globalAlpha = zoneId === currentZone ? 1.0 : 0.5;
      minimapCtx.fillStyle = '#fff';
      minimapCtx.font = (zoneId === currentZone ? 'bold ' : '') + '8px Arial';
      minimapCtx.textAlign = 'center';
      minimapCtx.fillText(zone.label, pos.x, pos.y + 3);
    }

    minimapCtx.globalAlpha = 1.0;

    players.forEach(function(player) {
      var pp = worldToMap(player.position.x, player.position.z);

      if (player.isLocal) {
        minimapCtx.fillStyle = '#FFD700';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.lineWidth = 1.5;
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.stroke();
        minimapCtx.shadowBlur = 8;
        minimapCtx.shadowColor = '#FFD700';
        minimapCtx.fillStyle = '#FFD700';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.shadowBlur = 0;
      } else {
        minimapCtx.fillStyle = '#44ff44';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 2, 0, Math.PI * 2);
        minimapCtx.fill();
      }
    });

    minimapCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    minimapCtx.lineWidth = 1;
    minimapCtx.strokeRect(0, 0, w, h);
  }

  var ZONE_DISPLAY_NAMES = {
    nexus: 'The Nexus',
    gardens: 'The Living Gardens',
    athenaeum: 'The Athenaeum',
    studio: 'The Studio',
    wilds: 'The Wilds',
    agora: 'The Agora',
    commons: 'The Commons',
    arena: 'The Arena'
  };

  function updateZoneLabel(zoneName) {
    if (!zoneLabel) return;
    var display = ZONE_DISPLAY_NAMES[zoneName] || zoneName || 'Unknown Zone';
    zoneLabel.innerHTML = '<div style="font-size:18px;font-weight:bold;">' + display + '</div>';
  }

  function updateNearbyPlayers(players) {
    if (!nearbyPlayersList) return;

    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';

    if (players.length === 0) {
      const emptyMsg = document.createElement('div');
      emptyMsg.style.cssText = 'color: #888; font-size: 12px; font-style: italic;';
      emptyMsg.textContent = 'No players nearby';
      nearbyPlayersList.appendChild(emptyMsg);
      return;
    }

    players.slice(0, 10).forEach(player => {
      const playerEl = document.createElement('div');
      playerEl.style.cssText = `
        padding: 5px;
        margin-bottom: 3px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-size: 13px;
      `;

      const distanceStr = player.distance ? `(${player.distance.toFixed(1)}m)` : '';
      playerEl.innerHTML = `
        <span style="color: #4f4;">${player.name || player.id}</span>
        <span style="color: #888; font-size: 11px; margin-left: 5px;">${distanceStr}</span>
      `;

      nearbyPlayersList.appendChild(playerEl);
    });
  }

  function showBreakReminder(minutes) {
    showNotification(
      `You've been playing for ${minutes} minutes. Consider taking a break!`,
      'info'
    );
  }

  function addChatInput(onSubmit) {
    if (!hudContainer || chatInput) return;
    if (typeof document === 'undefined') return;

    chatInput = document.createElement('input');
    chatInput.type = 'text';
    chatInput.placeholder = 'Press Enter to chat...';
    chatInput.style.cssText = `
      position: absolute;
      bottom: 230px;
      left: 20px;
      width: 330px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #4af;
      border-radius: 4px;
      color: white;
      font-size: 14px;
      pointer-events: auto;
      display: none;
    `;

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const text = chatInput.value.trim();
        if (text && onSubmit) {
          onSubmit(text);
        }
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      } else if (e.key === 'Escape') {
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      }
    });

    document.querySelector('#zion-hud').appendChild(chatInput);
  }

  function showChatInput() {
    if (chatInput) {
      chatInput.style.display = 'block';
      chatInput.focus();
    }
  }

  function hideChatInput() {
    if (chatInput) {
      chatInput.style.display = 'none';
      chatInput.value = '';
    }
  }

  function showNotification(text, type = 'info') {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const colors = {
      info: '#4af',
      success: '#4f4',
      warning: '#fa4',
      error: '#f44'
    };

    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.style.cssText = `
      background: rgba(0, 0, 0, 0.8);
      border-left: 4px solid ${colors[type] || colors.info};
      border-radius: 4px;
      padding: 12px 15px;
      margin-bottom: 10px;
      pointer-events: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    requestAnimationFrame(function() {
      notification.classList.add('visible');
    });

    setTimeout(function() {
      notification.classList.remove('visible');
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 5000);
  }

  if (typeof document !== 'undefined') {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateY(0);
          opacity: 1;
        }
        to {
          transform: translateY(-20px);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }

  var toolbarEl = null;
  var coordsEl = null;
  var weatherEl = null;
  var timeEl = null;

  function initToolbar() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    toolbarEl = document.createElement('div');
    toolbarEl.id = 'action-toolbar';
    toolbarEl.style.cssText = 'position:absolute;bottom:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto;';

    var actions = [
      { key: 'E', label: 'Interact', color: '#44aa66' },
      { key: 'B', label: 'Build', color: '#aa6644' },
      { key: 'Enter', label: 'Chat', color: '#4488cc' },
      { key: 'Shift', label: 'Sprint', color: '#cc8844' }
    ];

    actions.forEach(function(action) {
      var btn = document.createElement('div');
      btn.style.cssText = 'background:rgba(0,0,0,0.7);border:1px solid ' + action.color + ';border-radius:6px;padding:6px 12px;text-align:center;font-size:11px;min-width:50px;';
      btn.innerHTML = '<div style="font-weight:bold;color:' + action.color + ';font-size:14px;">' + action.key + '</div><div style="color:#aaa;margin-top:2px;">' + action.label + '</div>';
      toolbarEl.appendChild(btn);
    });
    hud.appendChild(toolbarEl);

    coordsEl = document.createElement('div');
    coordsEl.id = 'coords-display';
    coordsEl.style.cssText = 'position:absolute;bottom:240px;left:20px;background:rgba(0,0,0,0.5);border-radius:4px;padding:4px 8px;font-size:11px;color:#888;font-family:monospace;pointer-events:none;';
    hud.appendChild(coordsEl);

    var infoPanel = document.createElement('div');
    infoPanel.style.cssText = 'position:absolute;top:260px;right:20px;background:rgba(0,0,0,0.6);border-radius:8px;padding:10px;min-width:120px;font-size:12px;pointer-events:none;';

    timeEl = document.createElement('div');
    timeEl.style.cssText = 'margin-bottom:4px;';
    infoPanel.appendChild(timeEl);

    weatherEl = document.createElement('div');
    weatherEl.style.cssText = 'color:#aaa;';
    infoPanel.appendChild(weatherEl);

    hud.appendChild(infoPanel);
  }

  function updateCoords(position) {
    if (!coordsEl || !position) return;
    coordsEl.textContent = 'X: ' + Math.round(position.x) + '  Y: ' + Math.round(position.y) + '  Z: ' + Math.round(position.z);
  }

  function updateTimeWeather(worldTime, weather) {
    if (timeEl) {
      var hours = Math.floor(worldTime / 60);
      var mins = Math.floor(worldTime % 60);
      var ampm = hours >= 12 ? 'PM' : 'AM';
      var displayHour = hours % 12 || 12;
      var timeStr = displayHour + ':' + (mins < 10 ? '0' : '') + mins + ' ' + ampm;
      var icon = (hours >= 6 && hours < 18) ? '&#9728;' : '&#9790;'; // sun or moon
      timeEl.innerHTML = icon + ' ' + timeStr;
    }
    if (weatherEl && weather) {
      var weatherIcons = { clear: '&#9728;', cloudy: '&#9729;', rain: '&#127783;', snow: '&#10052;' };
      var icon = weatherIcons[weather] || '';
      weatherEl.innerHTML = icon + ' ' + weather.charAt(0).toUpperCase() + weather.slice(1);
    }
  }

  var npcDialogEl = null;
  var npcDialogTimer = null;
  var npcActionCallback = null;
  var npcShopPanel = null;

  var ARCHETYPE_COLORS_HUD = {
    gardener: '#4CAF50', builder: '#8D6E63', storyteller: '#9C27B0',
    merchant: '#FFD700', explorer: '#00BCD4', teacher: '#2196F3',
    musician: '#FF4081', healer: '#FFFFFF', philosopher: '#3F51B5',
    artist: '#FF9800'
  };

  var ARCHETYPE_ICONS = {
    gardener: '&#127793;', builder: '&#128296;', storyteller: '&#128214;',
    merchant: '&#128176;', explorer: '&#129517;', teacher: '&#127891;',
    musician: '&#127925;', healer: '&#10084;', philosopher: '&#128161;',
    artist: '&#127912;'
  };

  function showNPCDialog(npcData) {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    hideNPCDialog();

    var color = ARCHETYPE_COLORS_HUD[npcData.archetype] || '#888';
    var icon = ARCHETYPE_ICONS[npcData.archetype] || '';
    var mood = npcData.mood || 'neutral';
    var activity = npcData.activity || '';
    var familiarity = npcData.familiarity || 0;

    var famLabel = 'Stranger';
    if (familiarity > 70) famLabel = 'Good Friend';
    else if (familiarity > 40) famLabel = 'Acquaintance';
    else if (familiarity > 10) famLabel = 'Familiar';

    var moodEmoji = { content: '&#128522;', excited: '&#128516;', contemplative: '&#129300;',
      social: '&#128075;', tired: '&#128564;', happy: '&#128515;', curious: '&#129488;',
      neutral: '&#128528;', focused: '&#128373;', relaxed: '&#128524;' };
    var moodIcon = moodEmoji[mood] || moodEmoji.neutral;

    npcDialogEl = document.createElement('div');
    npcDialogEl.id = 'npc-dialog';
    npcDialogEl.style.cssText = 'position:absolute;bottom:60px;left:50%;transform:translateX(-50%);' +
      'background:rgba(10,14,26,0.92);border:2px solid ' + color + ';border-radius:12px;' +
      'padding:16px 20px;min-width:380px;max-width:480px;pointer-events:auto;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.6);animation:slideIn 0.3s ease-out;';

    var header = '<div style="display:flex;align-items:center;margin-bottom:10px;">' +
      '<div style="width:48px;height:48px;border-radius:50%;background:' + color + ';' +
      'display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0;">' + icon + '</div>' +
      '<div style="margin-left:12px;flex:1;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;">' + (npcData.name || 'NPC') + '</div>' +
      '<div style="font-size:11px;color:' + color + ';text-transform:capitalize;">' + (npcData.archetype || '') + '</div>' +
      '</div>' +
      '<div style="text-align:right;font-size:11px;color:#888;">' +
      '<div>' + moodIcon + ' ' + mood + '</div>' +
      '<div style="margin-top:2px;">' + famLabel + '</div>' +
      '</div></div>';

    var activityBar = '';
    if (activity) {
      activityBar = '<div style="font-size:11px;color:#aaa;margin-bottom:8px;padding:4px 8px;' +
        'background:rgba(255,255,255,0.05);border-radius:4px;font-style:italic;">' +
        '&#128269; ' + activity + '</div>';
    }

    var dialogue = '<div style="font-size:14px;color:#e0e0e0;line-height:1.5;padding:8px 0;' +
      'border-top:1px solid rgba(255,255,255,0.1);">"' + (npcData.message || '...') + '"</div>';

    var famBar = '<div style="margin-top:8px;display:flex;align-items:center;gap:8px;">' +
      '<span style="font-size:10px;color:#666;">Familiarity</span>' +
      '<div style="flex:1;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;">' +
      '<div style="width:' + Math.min(familiarity, 100) + '%;height:100%;background:' + color + ';border-radius:2px;"></div>' +
      '</div>' +
      '<span style="font-size:10px;color:#666;">' + familiarity + '%</span></div>';

    var actionBtns = '<div style="display:flex;gap:6px;margin-top:10px;flex-wrap:wrap;">';
    var isMerchant = npcData.archetype === 'merchant' || npcData.archetype === 'trader' ||
                     npcData.archetype === 'artisan' || npcData.archetype === 'farmer';
    actionBtns += '<button class="npc-action-btn" data-action="trade" style="flex:1;padding:6px 10px;' +
      'background:rgba(218,165,32,0.15);border:1px solid rgba(218,165,32,0.4);border-radius:6px;' +
      'color:#daa520;font-size:11px;cursor:pointer;transition:background 0.2s;"' +
      (isMerchant ? ' data-primary="true"' : '') + '>&#128176; Trade</button>';
    actionBtns += '<button class="npc-action-btn" data-action="learn" style="flex:1;padding:6px 10px;' +
      'background:rgba(100,149,237,0.15);border:1px solid rgba(100,149,237,0.4);border-radius:6px;' +
      'color:#6495ed;font-size:11px;cursor:pointer;transition:background 0.2s;">&#128218; Learn</button>';
    actionBtns += '<button class="npc-action-btn" data-action="lore" style="flex:1;padding:6px 10px;' +
      'background:rgba(147,112,219,0.15);border:1px solid rgba(147,112,219,0.4);border-radius:6px;' +
      'color:#9370db;font-size:11px;cursor:pointer;transition:background 0.2s;">&#128220; Lore</button>';
    actionBtns += '</div>';

    var closeHint = '<div style="text-align:center;font-size:10px;color:#555;margin-top:8px;">Click an action or ESC to close</div>';

    npcDialogEl.innerHTML = header + activityBar + dialogue + famBar + actionBtns + closeHint;

    var buttons = npcDialogEl.querySelectorAll('.npc-action-btn');
    buttons.forEach(function(btn) {
      btn.addEventListener('mouseover', function() { btn.style.background = 'rgba(255,255,255,0.15)'; });
      btn.addEventListener('mouseout', function() { btn.style.background = ''; });
      btn.addEventListener('click', function() {
        var action = btn.getAttribute('data-action');
        if (npcActionCallback) {
          npcActionCallback(action, npcData);
        }
      });
    });

    hud.appendChild(npcDialogEl);

    npcDialogTimer = setTimeout(function() { hideNPCDialog(); }, 15000);
  }

  function hideNPCDialog() {
    if (npcDialogTimer) {
      clearTimeout(npcDialogTimer);
      npcDialogTimer = null;
    }
    if (npcDialogEl && npcDialogEl.parentNode) {
      npcDialogEl.parentNode.removeChild(npcDialogEl);
      npcDialogEl = null;
    }
  }

  function setNPCActionCallback(callback) {
    npcActionCallback = callback;
  }

  function showNPCShop(npcData, items, playerSpark, onBuy) {
    if (typeof document === 'undefined') return;
    hideNPCShop();
    hideNPCDialog();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var color = ARCHETYPE_COLORS_HUD[npcData.archetype] || '#888';

    npcShopPanel = document.createElement('div');
    npcShopPanel.id = 'npc-shop-panel';
    npcShopPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid ' + color + ';border-radius:12px;' +
      'padding:20px;min-width:400px;max-width:500px;max-height:70vh;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.7);animation:slideIn 0.3s ease-out;overflow-y:auto;';

    var header = '<div style="display:flex;align-items:center;margin-bottom:14px;padding-bottom:10px;' +
      'border-bottom:1px solid rgba(255,255,255,0.1);">' +
      '<div style="font-size:18px;font-weight:bold;color:#fff;flex:1;">&#128176; ' +
      (npcData.name || 'Shop') + '\'s Wares</div>' +
      '<div style="font-size:13px;color:#daa520;">Your Spark: ' + (playerSpark || 0) + '</div></div>';

    var itemList = '';
    if (!items || items.length === 0) {
      itemList = '<div style="text-align:center;color:#888;padding:20px;">No items for sale right now.</div>';
    } else {
      items.forEach(function(item) {
        var canAfford = playerSpark >= item.price;
        itemList += '<div style="display:flex;align-items:center;padding:10px;margin-bottom:6px;' +
          'background:rgba(255,255,255,0.04);border-radius:8px;border:1px solid rgba(255,255,255,0.08);">' +
          '<div style="font-size:24px;margin-right:12px;">' + (item.icon || '&#128230;') + '</div>' +
          '<div style="flex:1;">' +
          '<div style="font-size:13px;color:#fff;">' + item.name + '</div>' +
          '<div style="font-size:11px;color:#888;">' + (item.description || '') + '</div>' +
          '</div>' +
          '<div style="text-align:right;margin-left:12px;">' +
          '<div style="font-size:12px;color:#daa520;margin-bottom:4px;">' + item.price + ' Spark</div>' +
          '<button class="npc-shop-buy-btn" data-item-id="' + item.id + '" style="padding:4px 12px;' +
          'background:' + (canAfford ? 'rgba(218,165,32,0.2)' : 'rgba(100,100,100,0.2)') + ';' +
          'border:1px solid ' + (canAfford ? 'rgba(218,165,32,0.5)' : 'rgba(100,100,100,0.3)') + ';' +
          'border-radius:4px;color:' + (canAfford ? '#daa520' : '#666') + ';font-size:11px;cursor:' +
          (canAfford ? 'pointer' : 'not-allowed') + ';"' +
          (canAfford ? '' : ' disabled') + '>Buy</button>' +
          '</div></div>';
      });
    }

    var closeBtn = '<div style="text-align:center;margin-top:12px;">' +
      '<button id="npc-shop-close" style="padding:6px 24px;background:rgba(255,255,255,0.08);' +
      'border:1px solid rgba(255,255,255,0.2);border-radius:6px;color:#aaa;font-size:12px;cursor:pointer;">Close Shop</button></div>';

    npcShopPanel.innerHTML = header + itemList + closeBtn;
    npcShopPanel.className = 'npc-shop-panel';
    hud.appendChild(npcShopPanel);
    requestAnimationFrame(function() {
      npcShopPanel.classList.add('visible');
    });

    npcShopPanel.querySelectorAll('.npc-shop-buy-btn').forEach(function(btn) {
      if (!btn.disabled) {
        btn.addEventListener('click', function() {
          var itemId = btn.getAttribute('data-item-id');
          if (onBuy) onBuy(itemId);
        });
      }
    });

    var closeEl = npcShopPanel.querySelector('#npc-shop-close');
    if (closeEl) {
      closeEl.addEventListener('click', function() { hideNPCShop(); });
    }
  }

  function hideNPCShop() {
    if (npcShopPanel && npcShopPanel.parentNode) {
      npcShopPanel.classList.remove('visible');
      setTimeout(function() {
        if (npcShopPanel && npcShopPanel.parentNode) {
          npcShopPanel.parentNode.removeChild(npcShopPanel);
          npcShopPanel = null;
        }
      }, 250);
    }
  }

  function updateMinimapNPCs(npcPositions, playerPos) {
    if (!minimapCtx || !npcPositions) return;

    var w = minimapCanvas.width;
    var h = minimapCanvas.height;
    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var margin = 8;

    function worldToMap(wx, wz) {
      return {
        x: margin + ((wx - worldMin) / worldRange) * (w - margin * 2),
        y: margin + ((wz - worldMin) / worldRange) * (h - margin * 2)
      };
    }

    npcPositions.forEach(function(npc) {
      if (playerPos) {
        var dx = npc.x - playerPos.x;
        var dz = npc.z - playerPos.z;
        if (Math.sqrt(dx * dx + dz * dz) > 250) return;
      }
      var pos = worldToMap(npc.x, npc.z);
      var color = ARCHETYPE_COLORS_HUD[npc.archetype] || '#888';
      minimapCtx.fillStyle = color;
      minimapCtx.globalAlpha = 0.7;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
      minimapCtx.fill();
    });
    minimapCtx.globalAlpha = 1.0;
  }

  var questTrackerEl = null;
  var questLogEl = null;
  var questOfferEl = null;

  function initQuestTracker() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questTrackerEl = document.createElement('div');
    questTrackerEl.id = 'quest-tracker';
    questTrackerEl.style.cssText = 'position:absolute;top:470px;right:20px;background:rgba(10,14,26,0.85);' +
      'border-left:3px solid #d4af37;border-radius:8px;padding:12px;min-width:220px;max-width:300px;' +
      'font-size:12px;pointer-events:auto;max-height:250px;overflow-y:auto;';
    questTrackerEl.innerHTML = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>';
    hud.appendChild(questTrackerEl);
  }

  function updateQuestTracker(activeQuests) {
    if (!questTrackerEl) return;

    if (activeQuests.length === 0) {
      questTrackerEl.innerHTML = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>' +
        '<div style="color:#888;font-style:italic;font-size:11px;">No active quests</div>';
      return;
    }

    var html = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>';

    activeQuests.forEach(function(quest) {
      var obj = quest.objectives[0]; // Show first objective
      var required = obj.required || obj.count || 1;
      var progress = obj.current + '/' + required;
      var progressPercent = Math.round((obj.current / required) * 100);
      var statusColor = quest.status === 'complete' ? '#4f4' : '#fff';

      html += '<div style="margin-bottom:10px;padding:6px;background:rgba(0,0,0,0.3);border-radius:4px;">' +
        '<div style="font-weight:bold;color:' + statusColor + ';font-size:11px;margin-bottom:3px;">' + quest.title + '</div>' +
        '<div style="color:#aaa;font-size:10px;margin-bottom:4px;">' + progress + '</div>' +
        '<div style="width:100%;height:4px;background:rgba(255,255,255,0.2);border-radius:2px;overflow:hidden;">' +
        '<div style="width:' + progressPercent + '%;height:100%;background:#d4af37;"></div></div>' +
        '</div>';
    });

    questTrackerEl.innerHTML = html;
  }

  function showQuestLog(questLog, playerId) {
    if (typeof document === 'undefined') return;
    hideQuestLog(); // Remove existing if any

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questLogEl = document.createElement('div');
    questLogEl.id = 'quest-log-panel';
    questLogEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #d4af37;border-radius:12px;' +
      'padding:20px;width:600px;max-height:70vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:200;';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<div style="font-size:24px;font-weight:bold;color:#d4af37;">Quest Log</div>' +
      '<div style="cursor:pointer;font-size:20px;color:#888;padding:4px 8px;" onclick="window.HUD.hideQuestLog()">âœ•</div></div>';

    html += '<div style="margin-bottom:20px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Active Quests (' + questLog.active.length + '/5)</div>';

    if (questLog.active.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No active quests. Speak to NPCs to find new quests!</div>';
    } else {
      questLog.active.forEach(function(quest) {
        var obj = quest.objectives[0];
        var required = obj.required || obj.count || 1;
        var progress = obj.current + '/' + required;
        var statusText = quest.status === 'complete' ? '<span style="color:#4f4;">âœ“ Ready to turn in</span>' : '<span style="color:#fa4;">In Progress</span>';

        html += '<div style="margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:6px;border-left:3px solid #d4af37;">' +
          '<div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">' +
          '<div style="font-weight:bold;color:#fff;font-size:14px;">' + quest.title + '</div>' +
          '<div style="font-size:11px;">' + statusText + '</div></div>' +
          '<div style="color:#aaa;font-size:12px;margin-bottom:6px;">' + quest.description + '</div>' +
          '<div style="color:#888;font-size:11px;">Progress: ' + progress + '</div>' +
          '<div style="margin-top:6px;font-size:11px;color:#d4af37;">Reward: ' + quest.rewards.spark + ' Spark' +
          (quest.rewards.items.length > 0 ? ' + items' : '') + '</div>' +
          '<div style="margin-top:8px;text-align:right;">' +
          '<span style="cursor:pointer;font-size:11px;color:#f44;text-decoration:underline;" onclick="window.HUD.abandonQuestFromLog(\'' + playerId + '\',\'' + quest.id + '\')">Abandon</span>' +
          '</div></div>';
      });
    }
    html += '</div>';

    html += '<div style="margin-bottom:20px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Available Quests (' + questLog.available.length + ')</div>';

    if (questLog.available.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No new quests available. Complete prerequisites or explore more zones!</div>';
    } else {
      questLog.available.slice(0, 10).forEach(function(quest) {
        html += '<div style="margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:6px;border-left:3px solid #888;">' +
          '<div style="font-weight:bold;color:#fff;font-size:14px;margin-bottom:6px;">' + quest.title + '</div>' +
          '<div style="color:#aaa;font-size:12px;margin-bottom:6px;">' + quest.description + '</div>' +
          '<div style="font-size:11px;color:#d4af37;">Reward: ' + quest.rewards.spark + ' Spark' +
          (quest.rewards.items.length > 0 ? ' + items' : '') + '</div>' +
          '<div style="margin-top:8px;color:#888;font-size:10px;">Find quest giver to accept</div></div>';
      });
    }
    html += '</div>';

    html += '<div>' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Completed (' + questLog.completed.length + ')</div>';

    if (questLog.completed.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No completed quests yet.</div>';
    } else {
      html += '<div style="color:#4f4;font-size:12px;padding:10px;">You have completed ' + questLog.completed.length + ' quests!</div>';
    }
    html += '</div>';

    html += '<div style="text-align:center;margin-top:16px;font-size:11px;color:#666;">Press J to close</div>';

    questLogEl.innerHTML = html;
    hud.appendChild(questLogEl);
    requestAnimationFrame(function() {
      questLogEl.classList.add('visible');
    });
  }

  function hideQuestLog() {
    if (questLogEl && questLogEl.parentNode) {
      questLogEl.classList.remove('visible');
      setTimeout(function() {
        if (questLogEl && questLogEl.parentNode) {
          questLogEl.parentNode.removeChild(questLogEl);
          questLogEl = null;
        }
      }, 250);
    }
  }

  function showQuestOffer(quest, npc, playerId) {
    if (typeof document === 'undefined') return;
    hideQuestOffer(); // Remove existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questOfferEl = document.createElement('div');
    questOfferEl.id = 'quest-offer-dialog';
    questOfferEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #d4af37;border-radius:12px;' +
      'padding:20px;width:500px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var questDialogue = quest.dialogue && quest.dialogue.offer ? quest.dialogue.offer : quest.description;

    var html = '<div style="font-size:20px;font-weight:bold;color:#d4af37;margin-bottom:12px;">New Quest</div>' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:8px;">' + quest.title + '</div>' +
      '<div style="color:#aaa;font-size:13px;margin-bottom:12px;font-style:italic;">"' + questDialogue + '"</div>' +
      '<div style="color:#ccc;font-size:12px;margin-bottom:8px;">' + quest.description + '</div>' +
      '<div style="padding:10px;background:rgba(0,0,0,0.3);border-radius:6px;margin-bottom:16px;">' +
      '<div style="font-size:12px;color:#d4af37;margin-bottom:4px;">Rewards:</div>' +
      '<div style="font-size:13px;color:#fff;">â€¢ ' + quest.rewards.spark + ' Spark</div>';

    if (quest.rewards.items.length > 0) {
      quest.rewards.items.forEach(function(item) {
        html += '<div style="font-size:13px;color:#fff;">â€¢ ' + item.count + 'x ' + item.id + '</div>';
      });
    }

    html += '</div>' +
      '<div style="display:flex;gap:12px;justify-content:center;">' +
      '<button onclick="window.HUD.acceptQuestFromOffer(\'' + playerId + '\',\'' + quest.id + '\')" style="' +
      'padding:10px 24px;background:#d4af37;color:#000;border:none;border-radius:6px;' +
      'font-weight:bold;font-size:14px;cursor:pointer;">Accept Quest</button>' +
      '<button onclick="window.HUD.hideQuestOffer()" style="' +
      'padding:10px 24px;background:rgba(255,255,255,0.1);color:#fff;border:1px solid #666;border-radius:6px;' +
      'font-size:14px;cursor:pointer;">Decline</button></div>';

    questOfferEl.innerHTML = html;
    hud.appendChild(questOfferEl);
  }

  function hideQuestOffer() {
    if (questOfferEl && questOfferEl.parentNode) {
      questOfferEl.parentNode.removeChild(questOfferEl);
      questOfferEl = null;
    }
  }

  function showQuestComplete(quest, rewards) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.style.cssText = 'background:linear-gradient(135deg,rgba(212,175,55,0.9),rgba(255,215,0,0.9));' +
      'border-left:4px solid #d4af37;border-radius:8px;padding:16px 20px;margin-bottom:10px;' +
      'animation:slideIn 0.3s ease-out;pointer-events:auto;box-shadow:0 4px 12px rgba(212,175,55,0.4);';

    var html = '<div style="font-size:18px;font-weight:bold;color:#000;margin-bottom:6px;">Quest Complete!</div>' +
      '<div style="font-size:14px;color:#111;margin-bottom:8px;">' + quest.title + '</div>' +
      '<div style="font-size:12px;color:#222;">+ ' + rewards.spark + ' Spark';

    if (rewards.items && rewards.items.length > 0) {
      html += ' + ' + rewards.items.length + ' item(s)';
    }

    html += '</div>';
    notification.innerHTML = html;

    notificationContainer.appendChild(notification);

    setTimeout(function() {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 6000);
  }

  function showQuestProgress(text) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.style.cssText = 'background:rgba(212,175,55,0.3);border-left:3px solid #d4af37;' +
      'border-radius:6px;padding:8px 12px;margin-bottom:8px;animation:slideIn 0.3s ease-out;' +
      'pointer-events:auto;font-size:13px;color:#d4af37;font-weight:bold;';
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    setTimeout(function() {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 3000);
  }

  function acceptQuestFromOffer(playerId, questId) {
    if (window.Quests) {
      var result = window.Quests.acceptQuest(playerId, questId);
      if (result.success) {
        showNotification('Quest accepted: ' + result.quest.title, 'success');
        hideQuestOffer();
      } else {
        showNotification('Cannot accept quest: ' + result.message, 'error');
      }
    }
  }

  function abandonQuestFromLog(playerId, questId) {
    if (window.Quests) {
      var result = window.Quests.abandonQuest(playerId, questId);
      if (result.success) {
        showNotification('Quest abandoned', 'info');
        hideQuestLog();
      }
    }
  }

  var inventoryPanel = null;
  var inventoryVisible = false;

  function initInventoryPanel() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    inventoryPanel = document.createElement('div');
    inventoryPanel.id = 'inventory-panel';
    inventoryPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #4af;border-radius:12px;' +
      'padding:20px;min-width:500px;pointer-events:auto;display:none;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.8);z-index:200;';

    var header = '<div style="font-size:20px;font-weight:bold;margin-bottom:15px;text-align:center;color:#4af;">Inventory</div>';
    var slotsGrid = '<div id="inventory-slots" style="display:grid;grid-template-columns:repeat(5,90px);gap:8px;margin-bottom:15px;"></div>';
    var closeBtn = '<div style="text-align:center;"><button id="close-inventory" style="padding:8px 20px;background:#4af;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Close (I)</button></div>';

    inventoryPanel.innerHTML = header + slotsGrid + closeBtn;
    hud.appendChild(inventoryPanel);

    var closeInvBtn = document.getElementById('close-inventory');
    if (closeInvBtn) closeInvBtn.addEventListener('click', function() {
      hideInventoryPanel();
    });
  }

  function toggleInventoryPanel() {
    if (inventoryVisible) {
      hideInventoryPanel();
    } else {
      showInventoryPanel();
    }
  }

  function showInventoryPanel() {
    if (!inventoryPanel) initInventoryPanel();
    inventoryPanel.style.display = 'block';
    requestAnimationFrame(function() {
      inventoryPanel.classList.add('visible');
    });
    inventoryVisible = true;
  }

  function hideInventoryPanel() {
    if (inventoryPanel) {
      inventoryPanel.classList.remove('visible');
      setTimeout(function() {
        inventoryPanel.style.display = 'none';
      }, 250);
    }
    inventoryVisible = false;
  }

  function updateInventoryDisplay(inventory) {
    if (!inventoryPanel || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var slotsDiv = document.getElementById('inventory-slots');
    if (!slotsDiv) return;

    var items = Inventory.getInventory(inventory);
    slotsDiv.innerHTML = '';

    items.forEach(function(item, idx) {
      var slot = document.createElement('div');
      slot.style.cssText = 'background:rgba(255,255,255,0.1);border:2px solid #555;border-radius:6px;' +
        'padding:10px;text-align:center;min-height:70px;position:relative;cursor:pointer;';

      if (item) {
        var rarityColors = { common: '#aaa', uncommon: '#4af', rare: '#f4a', legendary: '#fa4' };
        var borderColor = rarityColors[item.rarity] || '#555';
        slot.style.borderColor = borderColor;

        slot.innerHTML = '<div style="font-size:32px;margin-bottom:4px;">' + item.icon + '</div>' +
          '<div style="font-size:11px;color:#ccc;">' + item.name + '</div>' +
          '<div style="position:absolute;top:4px;right:6px;background:#000;padding:2px 6px;border-radius:3px;font-size:11px;font-weight:bold;">' + item.count + '</div>';

        slot.title = item.description + '\\n' + item.rarity.toUpperCase();
      } else {
        slot.innerHTML = '<div style="color:#444;padding-top:20px;">Empty</div>';
      }

      slotsDiv.appendChild(slot);
    });
  }

  var craftingPanel = null;
  var craftingVisible = false;
  var onCraftCallback = null;

  function initCraftingPanel(onCraft) {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    onCraftCallback = onCraft;

    craftingPanel = document.createElement('div');
    craftingPanel.id = 'crafting-panel';
    craftingPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #fa4;border-radius:12px;' +
      'padding:20px;min-width:600px;max-height:70vh;overflow-y:auto;pointer-events:auto;display:none;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.8);z-index:200;';

    var header = '<div style="font-size:20px;font-weight:bold;margin-bottom:15px;text-align:center;color:#fa4;">Crafting</div>';
    var recipeList = '<div id="recipe-list"></div>';
    var closeBtn = '<div style="text-align:center;margin-top:15px;"><button id="close-crafting" style="padding:8px 20px;background:#fa4;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Close (C)</button></div>';

    craftingPanel.innerHTML = header + recipeList + closeBtn;
    hud.appendChild(craftingPanel);

    var closeCraftBtn = document.getElementById('close-crafting');
    if (closeCraftBtn) closeCraftBtn.addEventListener('click', function() {
      hideCraftingPanel();
    });
  }

  function toggleCraftingPanel() {
    if (craftingVisible) {
      hideCraftingPanel();
    } else {
      showCraftingPanel();
    }
  }

  function showCraftingPanel() {
    if (!craftingPanel) initCraftingPanel();
    craftingPanel.style.display = 'block';
    requestAnimationFrame(function() {
      craftingPanel.classList.add('visible');
    });
    craftingVisible = true;
  }

  function hideCraftingPanel() {
    if (craftingPanel) {
      craftingPanel.classList.remove('visible');
      setTimeout(function() {
        craftingPanel.style.display = 'none';
      }, 250);
    }
    craftingVisible = false;
  }

  function updateCraftingDisplay(inventory) {
    if (!craftingPanel || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var listDiv = document.getElementById('recipe-list');
    if (!listDiv) return;

    var allRecipes = Inventory.getAllRecipes();
    listDiv.innerHTML = '';

    allRecipes.forEach(function(recipe) {
      var canCraft = Inventory.canCraft(inventory, recipe);
      var outputItem = Inventory.getItemData(recipe.output.itemId);

      var recipeDiv = document.createElement('div');
      recipeDiv.style.cssText = 'background:rgba(255,255,255,0.05);border:1px solid ' + (canCraft ? '#4f4' : '#555') + ';' +
        'border-radius:6px;padding:12px;margin-bottom:10px;';

      var title = '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:' + (canCraft ? '#4f4' : '#888') + ';">' +
        (outputItem ? outputItem.icon + ' ' : '') + recipe.name + '</div>';

      var reqs = '<div style="font-size:12px;color:#aaa;margin-bottom:8px;">Requires: ';
      recipe.requirements.forEach(function(req, i) {
        var reqItem = Inventory.getItemData(req.itemId);
        var hasCount = Inventory.getItemCount(inventory, req.itemId);
        var hasEnough = hasCount >= req.count;
        reqs += (i > 0 ? ', ' : '') + '<span style="color:' + (hasEnough ? '#4f4' : '#f44') + ';">' +
          (reqItem ? reqItem.icon + ' ' : '') + req.count + ' ' + (reqItem ? reqItem.name : req.itemId) + '</span>';
      });
      reqs += '</div>';

      var reward = '<div style="font-size:11px;color:#ffa500;margin-bottom:8px;">Spark Reward: ' + recipe.sparkReward + '</div>';

      var craftBtn = '';
      if (canCraft) {
        craftBtn = '<button class="craft-btn" data-recipe="' + recipe.id + '" style="padding:6px 15px;background:#4f4;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Craft</button>';
      } else {
        craftBtn = '<button disabled style="padding:6px 15px;background:#333;border:none;border-radius:4px;color:#666;cursor:not-allowed;">Cannot Craft</button>';
      }

      recipeDiv.innerHTML = title + reqs + reward + craftBtn;
      listDiv.appendChild(recipeDiv);
    });

    var craftBtns = document.querySelectorAll('.craft-btn');
    craftBtns.forEach(function(btn) {
      btn.addEventListener('click', function() {
        var recipeId = this.getAttribute('data-recipe');
        if (onCraftCallback) {
          onCraftCallback(recipeId);
        }
      });
    });
  }

  var quickBarEl = null;

  function initQuickBar() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    quickBarEl = document.createElement('div');
    quickBarEl.id = 'quick-bar';
    quickBarEl.style.cssText = 'position:absolute;bottom:70px;left:50%;transform:translateX(-50%);' +
      'display:flex;gap:8px;pointer-events:none;';

    for (var i = 0; i < 5; i++) {
      var slot = document.createElement('div');
      slot.className = 'quick-slot';
      slot.style.cssText = 'background:rgba(0,0,0,0.7);border:2px solid #555;border-radius:6px;' +
        'padding:8px;width:60px;height:60px;text-align:center;position:relative;';

      var keyLabel = '<div style="position:absolute;top:2px;left:4px;font-size:10px;color:#888;">' + (i + 1) + '</div>';
      slot.innerHTML = keyLabel + '<div class="quick-content" style="font-size:28px;margin-top:8px;">-</div>';

      quickBarEl.appendChild(slot);
    }

    hud.appendChild(quickBarEl);
  }

  function updateQuickBar(inventory) {
    if (!quickBarEl || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var items = Inventory.getInventory(inventory);
    var quickSlots = quickBarEl.querySelectorAll('.quick-slot');

    inventory.quickBar.forEach(function(slotIdx, qbIdx) {
      if (qbIdx >= quickSlots.length) return;

      var item = items[slotIdx];
      var contentDiv = quickSlots[qbIdx].querySelector('.quick-content');

      if (item) {
        contentDiv.innerHTML = item.icon;
        quickSlots[qbIdx].title = item.name + ' (' + item.count + ')';
      } else {
        contentDiv.innerHTML = '-';
        quickSlots[qbIdx].title = 'Empty';
      }
    });
  }

  function showItemPickup(itemName, count, icon) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var pickup = document.createElement('div');
    pickup.style.cssText = 'background:rgba(0,200,0,0.8);border-left:4px solid #0f0;border-radius:4px;' +
      'padding:10px 15px;margin-bottom:10px;animation:slideIn 0.3s ease-out;' +
      'pointer-events:auto;box-shadow:0 2px 8px rgba(0,0,0,0.3);font-size:14px;';

    pickup.innerHTML = '<span style="font-size:20px;margin-right:8px;">' + (icon || '+') + '</span>' +
      '<span style="font-weight:bold;">+' + count + ' ' + itemName + '</span>';

    notificationContainer.appendChild(pickup);

    setTimeout(function() {
      pickup.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        pickup.remove();
      }, 300);
    }, 2000);
  }

  var worldMapOverlay = null;
  var worldMapCanvas = null;
  var worldMapCtx = null;
  var worldMapVisible = false;

  var WORLD_MAP_ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, color: '#8888cc', name: 'Nexus', desc: 'The heart of Zion. A safe meeting place for all.' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, color: '#4caf50', name: 'Gardens', desc: 'Fertile grounds for planting, growing, and harvesting.' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, color: '#795548', name: 'Athenaeum', desc: 'A library of knowledge and arcane study.' },
    studio:     { cx: -200, cz: -100, radius: 60, color: '#ff9800', name: 'Studio', desc: 'Creative workshops for art, music, and crafting.' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, color: '#2e7d32', name: 'Wilds', desc: 'Untamed wilderness full of discoveries.' },
    agora:      { cx: -190, cz: 120,  radius: 55, color: '#ffd700', name: 'Agora', desc: 'The marketplace. Trade goods and Spark.' },
    commons:    { cx: 170,  cz: 190,  radius: 55, color: '#faf0e6', name: 'Commons', desc: 'Community space for building and gathering.' },
    arena:      { cx: 0,    cz: -240, radius: 55, color: '#d2691e', name: 'Arena', desc: 'Honorable competition between consenting players.' }
  };

  var ZONE_CONNECTIONS = [
    ['nexus', 'gardens'],
    ['nexus', 'athenaeum'],
    ['nexus', 'studio'],
    ['nexus', 'wilds'],
    ['nexus', 'agora'],
    ['nexus', 'commons'],
    ['nexus', 'arena'],
    ['gardens', 'commons'],
    ['wilds', 'agora'],
    ['athenaeum', 'arena']
  ];

  function showWorldMap(playerPos, npcs, landmarks, onFastTravel) {
    if (typeof document === 'undefined') return;
    if (worldMapVisible) return;

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    worldMapVisible = true;

    worldMapOverlay = document.createElement('div');
    worldMapOverlay.id = 'world-map-overlay';
    worldMapOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;' +
      'background:rgba(10,10,20,0.92);z-index:500;display:flex;flex-direction:column;' +
      'align-items:center;justify-content:center;pointer-events:auto;';

    var title = document.createElement('div');
    title.style.cssText = 'font-size:48px;font-weight:bold;letter-spacing:8px;' +
      'color:#d4af37;margin-bottom:20px;text-align:center;' +
      'text-shadow:0 0 10px rgba(212,175,55,0.5);';
    title.textContent = 'WORLD OF ZION';
    worldMapOverlay.appendChild(title);

    var mapContainer = document.createElement('div');
    mapContainer.style.cssText = 'position:relative;width:80vw;height:60vh;max-width:800px;max-height:600px;' +
      'background:rgba(0,0,0,0.3);border:2px solid #d4af37;border-radius:8px;overflow:hidden;';

    worldMapCanvas = document.createElement('canvas');
    worldMapCanvas.style.cssText = 'display:block;width:100%;height:100%;';
    mapContainer.appendChild(worldMapCanvas);

    worldMapCanvas.width = 800;
    worldMapCanvas.height = 600;
    worldMapCtx = worldMapCanvas.getContext('2d');

    worldMapOverlay.appendChild(mapContainer);

    var instructions = document.createElement('div');
    instructions.style.cssText = 'margin-top:20px;font-size:14px;color:#aaa;text-align:center;';
    instructions.textContent = onFastTravel ? 'Click a zone to fast travel Â· Press M or ESC to close' : 'Press M or ESC to close';
    worldMapOverlay.appendChild(instructions);

    hud.appendChild(worldMapOverlay);

    drawWorldMap(playerPos, npcs, landmarks);

    worldMapOverlay.addEventListener('click', function(e) {
      if (e.target === worldMapOverlay) {
        hideWorldMap();
      }
    });

    var keyHandler = function(e) {
      if (e.key === 'Escape' || e.key === 'm' || e.key === 'M') {
        hideWorldMap();
        document.removeEventListener('keydown', keyHandler);
        e.preventDefault();
      }
    };
    document.addEventListener('keydown', keyHandler);
    worldMapOverlay._keyHandler = keyHandler;

    worldMapCanvas.addEventListener('mousemove', function(e) {
      handleMapHover(e);
    });

    if (onFastTravel) {
      worldMapCanvas.addEventListener('click', function(e) {
        var zone = getZoneAtMapClick(e);
        if (zone) {
          hideWorldMap();
          onFastTravel(zone);
        }
      });
    }
  }

  function hideWorldMap() {
    if (!worldMapOverlay) return;

    if (worldMapOverlay._keyHandler) {
      document.removeEventListener('keydown', worldMapOverlay._keyHandler);
    }

    if (worldMapOverlay.parentNode) {
      worldMapOverlay.parentNode.removeChild(worldMapOverlay);
    }

    worldMapOverlay = null;
    worldMapCanvas = null;
    worldMapCtx = null;
    worldMapVisible = false;
  }

  function updateWorldMap(playerPos) {
    if (!worldMapVisible || !worldMapCtx) return;
    drawWorldMap(playerPos, [], []);
  }

  function drawWorldMap(playerPos, npcs, landmarks) {
    if (!worldMapCtx) return;

    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    worldMapCtx.fillStyle = '#0a0e1a';
    worldMapCtx.fillRect(0, 0, w, h);

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;

    function worldToCanvas(wx, wz) {
      return {
        x: padding + ((wx - worldMin) / worldRange) * (w - padding * 2),
        y: padding + ((wz - worldMin) / worldRange) * (h - padding * 2)
      };
    }

    worldMapCtx.strokeStyle = 'rgba(255,255,255,0.05)';
    worldMapCtx.lineWidth = 1;
    for (var i = 0; i <= 8; i++) {
      var x = padding + (i / 8) * (w - padding * 2);
      var y = padding + (i / 8) * (h - padding * 2);
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(x, padding);
      worldMapCtx.lineTo(x, h - padding);
      worldMapCtx.stroke();
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(padding, y);
      worldMapCtx.lineTo(w - padding, y);
      worldMapCtx.stroke();
    }

    worldMapCtx.strokeStyle = 'rgba(212,175,55,0.2)';
    worldMapCtx.lineWidth = 2;
    ZONE_CONNECTIONS.forEach(function(conn) {
      var z1 = WORLD_MAP_ZONES[conn[0]];
      var z2 = WORLD_MAP_ZONES[conn[1]];
      if (!z1 || !z2) return;
      var pos1 = worldToCanvas(z1.cx, z1.cz);
      var pos2 = worldToCanvas(z2.cx, z2.cz);
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(pos1.x, pos1.y);
      worldMapCtx.lineTo(pos2.x, pos2.y);
      worldMapCtx.stroke();
    });

    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var pos = worldToCanvas(zone.cx, zone.cz);
      var r = (zone.radius / worldRange) * (w - padding * 2);

      worldMapCtx.globalAlpha = 0.3;
      worldMapCtx.fillStyle = zone.color;
      worldMapCtx.beginPath();
      worldMapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      worldMapCtx.fill();

      worldMapCtx.globalAlpha = 0.7;
      worldMapCtx.strokeStyle = zone.color;
      worldMapCtx.lineWidth = 2;
      worldMapCtx.beginPath();
      worldMapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      worldMapCtx.stroke();

      worldMapCtx.globalAlpha = 1.0;
      worldMapCtx.fillStyle = '#fff';
      worldMapCtx.font = 'bold 14px Arial';
      worldMapCtx.textAlign = 'center';
      worldMapCtx.textBaseline = 'middle';
      worldMapCtx.fillText(zone.name, pos.x, pos.y);
    }

    worldMapCtx.globalAlpha = 1.0;

    if (npcs && npcs.length > 0) {
      npcs.forEach(function(npc) {
        var pos = worldToCanvas(npc.x, npc.z);
        var color = ARCHETYPE_COLORS_HUD[npc.archetype] || '#888';
        worldMapCtx.fillStyle = color;
        worldMapCtx.beginPath();
        worldMapCtx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
        worldMapCtx.fill();
      });
    }

    if (landmarks && landmarks.length > 0) {
      landmarks.forEach(function(landmark) {
        var pos = worldToCanvas(landmark.x, landmark.z);
        drawStar(worldMapCtx, pos.x, pos.y, 5, 8, 4, '#ffd700');
      });
    }

    if (playerPos) {
      var pPos = worldToCanvas(playerPos.x, playerPos.z);
      drawDiamond(worldMapCtx, pPos.x, pPos.y, 12, '#FFD700');

      worldMapCtx.shadowBlur = 15;
      worldMapCtx.shadowColor = '#FFD700';
      drawDiamond(worldMapCtx, pPos.x, pPos.y, 12, '#FFD700');
      worldMapCtx.shadowBlur = 0;
    }

    drawCompassRose(worldMapCtx, w - 60, 60, 30);
  }

  function drawDiamond(ctx, x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size, y);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawStar(ctx, x, y, points, outer, inner, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    for (var i = 0; i < points * 2; i++) {
      var angle = (i * Math.PI) / points - Math.PI / 2;
      var radius = i % 2 === 0 ? outer : inner;
      var px = x + Math.cos(angle) * radius;
      var py = y + Math.sin(angle) * radius;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawCompassRose(ctx, x, y, size) {
    ctx.strokeStyle = 'rgba(212,175,55,0.5)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x, y + size);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x - size, y);
    ctx.lineTo(x + size, y);
    ctx.stroke();

    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('N', x, y - size - 10);
    ctx.fillText('S', x, y + size + 10);
    ctx.fillText('E', x + size + 12, y);
    ctx.fillText('W', x - size - 12, y);
  }

  function handleMapHover(e) {
    if (!worldMapCanvas || !worldMapCtx) return;

    var rect = worldMapCanvas.getBoundingClientRect();
    var mx = ((e.clientX - rect.left) / rect.width) * worldMapCanvas.width;
    var my = ((e.clientY - rect.top) / rect.height) * worldMapCanvas.height;

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;
    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    var hoveredZone = null;
    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var zx = padding + ((zone.cx - worldMin) / worldRange) * (w - padding * 2);
      var zy = padding + ((zone.cz - worldMin) / worldRange) * (h - padding * 2);
      var zr = (zone.radius / worldRange) * (w - padding * 2);

      var dx = mx - zx;
      var dy = my - zy;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist <= zr) {
        hoveredZone = zone;
        break;
      }
    }

    if (hoveredZone) {
      worldMapCanvas.style.cursor = 'pointer';
      worldMapCanvas.title = hoveredZone.name + ' â€” Click to fast travel';
    } else {
      worldMapCanvas.style.cursor = 'default';
      worldMapCanvas.title = '';
    }
  }

  function getZoneAtMapClick(e) {
    if (!worldMapCanvas) return null;

    var rect = worldMapCanvas.getBoundingClientRect();
    var mx = ((e.clientX - rect.left) / rect.width) * worldMapCanvas.width;
    var my = ((e.clientY - rect.top) / rect.height) * worldMapCanvas.height;

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;
    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var zx = padding + ((zone.cx - worldMin) / worldRange) * (w - padding * 2);
      var zy = padding + ((zone.cz - worldMin) / worldRange) * (h - padding * 2);
      var zr = (zone.radius / worldRange) * (w - padding * 2);

      var dx = mx - zx;
      var dy = my - zy;
      if (Math.sqrt(dx * dx + dy * dy) <= zr) {
        return zoneId;
      }
    }
    return null;
  }

  var emoteMenuEl = null;
  var emoteMenuVisible = false;
  var emoteBubbles = new Map(); // playerId -> {element, timer}

  var EMOTE_SYMBOLS = {
    wave: '&#128075;',
    dance: '&#128131;',
    bow: '&#129485;',
    cheer: '&#127881;',
    meditate: '&#129496;',
    point: '&#128073;'
  };

  function showEmoteMenu() {
    if (typeof document === 'undefined') return;
    hideEmoteMenu(); // Remove existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    emoteMenuEl = document.createElement('div');
    emoteMenuEl.id = 'emote-menu';
    emoteMenuEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'width:300px;height:300px;pointer-events:auto;z-index:250;';

    var emotes = [
      { type: 'wave', label: 'Wave', angle: 0 },
      { type: 'dance', label: 'Dance', angle: 60 },
      { type: 'bow', label: 'Bow', angle: 120 },
      { type: 'cheer', label: 'Cheer', angle: 180 },
      { type: 'meditate', label: 'Meditate', angle: 240 },
      { type: 'point', label: 'Point', angle: 300 }
    ];

    var centerX = 150, centerY = 150, radius = 100;

    emotes.forEach(function(emote) {
      var angleRad = (emote.angle - 90) * Math.PI / 180;
      var x = centerX + radius * Math.cos(angleRad) - 35;
      var y = centerY + radius * Math.sin(angleRad) - 35;

      var btn = document.createElement('div');
      btn.className = 'emote-btn';
      btn.style.cssText = 'position:absolute;left:' + x + 'px;top:' + y + 'px;' +
        'width:70px;height:70px;border-radius:50%;background:rgba(0,0,0,0.8);' +
        'border:2px solid rgba(255,255,255,0.5);display:flex;flex-direction:column;' +
        'align-items:center;justify-content:center;cursor:pointer;' +
        'transition:all 0.2s;color:#fff;font-size:11px;';

      btn.innerHTML = '<div style="font-size:28px;margin-bottom:2px;">' + EMOTE_SYMBOLS[emote.type] + '</div>' +
        '<div>' + emote.label + '</div>';

      btn.onmouseover = function() {
        this.style.background = 'rgba(74,170,255,0.9)';
        this.style.borderColor = '#4af';
        this.style.transform = 'scale(1.1)';
      };

      btn.onmouseout = function() {
        this.style.background = 'rgba(0,0,0,0.8)';
        this.style.borderColor = 'rgba(255,255,255,0.5)';
        this.style.transform = 'scale(1)';
      };

      btn.onclick = (function(type) {
        return function() {
          hideEmoteMenu();
          if (window.Main && window.Main.handleLocalAction) {
            window.Main.handleLocalAction('emote', { type: type });
          }
        };
      })(emote.type);

      emoteMenuEl.appendChild(btn);
    });

    var centerLabel = document.createElement('div');
    centerLabel.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.9);border:2px solid #4af;border-radius:50%;' +
      'width:80px;height:80px;display:flex;align-items:center;justify-content:center;' +
      'color:#4af;font-weight:bold;font-size:12px;text-align:center;pointer-events:none;';
    centerLabel.textContent = 'Emotes';
    emoteMenuEl.appendChild(centerLabel);

    hud.appendChild(emoteMenuEl);
    emoteMenuVisible = true;
  }

  function hideEmoteMenu() {
    if (emoteMenuEl && emoteMenuEl.parentNode) {
      emoteMenuEl.parentNode.removeChild(emoteMenuEl);
      emoteMenuEl = null;
    }
    emoteMenuVisible = false;
  }

  function showEmoteBubble(playerId, emoteType) {
    if (typeof document === 'undefined') return;

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var existing = emoteBubbles.get(playerId);
    if (existing && existing.element && existing.element.parentNode) {
      existing.element.parentNode.removeChild(existing.element);
    }

    var bubble = document.createElement('div');
    bubble.className = 'emote-bubble';
    bubble.style.cssText = 'position:absolute;background:rgba(255,255,255,0.95);' +
      'border:2px solid #4af;border-radius:20px;padding:8px 16px;' +
      'font-size:14px;font-weight:bold;color:#000;' +
      'box-shadow:0 4px 12px rgba(0,0,0,0.3);pointer-events:none;z-index:150;' +
      'animation:emoteFloat 2s ease-out forwards;white-space:nowrap;';

    var label = emoteType.charAt(0).toUpperCase() + emoteType.slice(1);
    bubble.innerHTML = EMOTE_SYMBOLS[emoteType] + ' ' + label;

    hud.appendChild(bubble);

    emoteBubbles.set(playerId, {
      element: bubble,
      timer: 2.0,
      emoteType: emoteType
    });

    setTimeout(function() {
      if (bubble.parentNode) {
        bubble.parentNode.removeChild(bubble);
      }
      emoteBubbles.delete(playerId);
    }, 2000);
  }

  function updateEmoteBubbles(playerPositions) {
    emoteBubbles.forEach(function(bubble, playerId) {
      if (!bubble.element || !bubble.element.parentNode) {
        emoteBubbles.delete(playerId);
        return;
      }

      var screenPos = playerPositions[playerId];
      if (screenPos) {
        bubble.element.style.left = screenPos.x + 'px';
        bubble.element.style.top = (screenPos.y - 80) + 'px';
      }
    });
  }

  if (typeof document !== 'undefined') {
    var style = document.createElement('style');
    style.textContent += `
      @keyframes emoteFloat {
        0% {
          transform: translateY(0) scale(0.8);
          opacity: 0;
        }
        20% {
          opacity: 1;
          transform: translateY(-10px) scale(1);
        }
        80% {
          opacity: 1;
          transform: translateY(-30px) scale(1);
        }
        100% {
          transform: translateY(-40px) scale(0.9);
          opacity: 0;
        }
      }
    `;
    if (document.head) {
      document.head.appendChild(style);
    }
  }

  var tradeRequestEl = null;
  var tradeWindowEl = null;
  var currentTradeData = null;

  function showTradeRequest(fromPlayer, tradeId, onAccept, onDecline) {
    if (typeof document === 'undefined') return;
    hideTradeRequest(); // Remove any existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    tradeRequestEl = document.createElement('div');
    tradeRequestEl.id = 'trade-request';
    tradeRequestEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #ffa500;border-radius:12px;' +
      'padding:20px;width:400px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var html = '<div style="font-size:20px;font-weight:bold;color:#ffa500;margin-bottom:12px;">Trade Request</div>' +
      '<div style="font-size:16px;color:#fff;margin-bottom:16px;">' +
      '<span style="color:#4af;font-weight:bold;">' + fromPlayer + '</span> wants to trade with you.' +
      '</div>' +
      '<div style="display:flex;gap:12px;justify-content:center;">' +
      '<button id="trade-accept-btn" style="padding:10px 24px;background:#4f4;color:#000;border:none;' +
      'border-radius:6px;font-weight:bold;font-size:14px;cursor:pointer;">Accept</button>' +
      '<button id="trade-decline-btn" style="padding:10px 24px;background:rgba(255,255,255,0.1);color:#fff;' +
      'border:1px solid #666;border-radius:6px;font-size:14px;cursor:pointer;">Decline</button></div>';

    tradeRequestEl.innerHTML = html;
    hud.appendChild(tradeRequestEl);

    var acceptBtn = document.getElementById('trade-accept-btn');
    if (acceptBtn) acceptBtn.addEventListener('click', function() {
      hideTradeRequest();
      if (onAccept) onAccept(tradeId);
    });

    var declineBtn = document.getElementById('trade-decline-btn');
    if (declineBtn) declineBtn.addEventListener('click', function() {
      hideTradeRequest();
      if (onDecline) onDecline(tradeId);
    });
  }

  function hideTradeRequest() {
    if (tradeRequestEl && tradeRequestEl.parentNode) {
      tradeRequestEl.parentNode.removeChild(tradeRequestEl);
      tradeRequestEl = null;
    }
  }

  function showTradeWindow(trade, localPlayerId, onAddItem, onRemoveItem, onSetSpark, onReady, onConfirm, onCancel) {
    if (typeof document === 'undefined') return;
    hideTradeWindow(); // Remove any existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    currentTradeData = { trade: trade, localPlayerId: localPlayerId };

    tradeWindowEl = document.createElement('div');
    tradeWindowEl.id = 'trade-window';
    tradeWindowEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #ffa500;border-radius:12px;' +
      'padding:20px;width:700px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    tradeWindowEl.innerHTML = '<div style="font-size:20px;font-weight:bold;color:#ffa500;margin-bottom:16px;text-align:center;">Trade Window</div>' +
      '<div id="trade-content"></div>';

    hud.appendChild(tradeWindowEl);

    tradeWindowEl._callbacks = { onAddItem, onRemoveItem, onSetSpark, onReady, onConfirm, onCancel };

    updateTradeWindow(trade, localPlayerId);
  }

  function updateTradeWindow(trade, localPlayerId) {
    if (!tradeWindowEl) return;

    var contentDiv = document.getElementById('trade-content');
    if (!contentDiv) return;

    var isPlayer1 = trade.player1.id === localPlayerId;
    var localPlayer = isPlayer1 ? trade.player1 : trade.player2;
    var otherPlayer = isPlayer1 ? trade.player2 : trade.player1;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;

    var html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:16px;">';

    html += '<div style="border:2px solid #4af;border-radius:8px;padding:12px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#4af;margin-bottom:10px;text-align:center;">Your Offer</div>' +
      '<div id="local-items" style="display:grid;grid-template-columns:repeat(3,80px);gap:6px;margin-bottom:10px;justify-content:center;">';

    for (var i = 0; i < 6; i++) {
      var item = localPlayer.items[i];
      var slotHtml = '<div class="trade-slot" data-slot="' + i + '" style="background:rgba(255,255,255,0.1);border:2px solid #555;' +
        'border-radius:6px;padding:8px;text-align:center;min-height:60px;cursor:pointer;position:relative;">';

      if (item && Inventory) {
        var itemData = Inventory.getItemData(item.itemId);
        if (itemData) {
          slotHtml += '<div style="font-size:28px;">' + itemData.icon + '</div>' +
            '<div style="font-size:9px;color:#ccc;">' + itemData.name + '</div>' +
            '<div style="position:absolute;top:2px;right:4px;background:#000;padding:1px 4px;border-radius:2px;font-size:10px;">' + item.count + '</div>';
        }
      } else {
        slotHtml += '<div style="color:#444;padding-top:15px;font-size:11px;">Empty</div>';
      }

      slotHtml += '</div>';
      html += slotHtml;
    }

    html += '</div>';

    html += '<div style="margin-bottom:10px;">' +
      '<label style="font-size:12px;color:#aaa;display:block;margin-bottom:4px;">Spark Offer:</label>' +
      '<input type="number" id="local-spark-input" min="0" value="' + localPlayer.spark + '" ' +
      'style="width:100%;padding:6px;background:rgba(0,0,0,0.5);border:1px solid #555;border-radius:4px;color:#fff;font-size:14px;" />' +
      '</div>';

    var statusText = localPlayer.ready ? 'âœ“ Ready' : 'Not ready';
    var statusColor = localPlayer.ready ? '#4f4' : '#888';
    html += '<div style="text-align:center;color:' + statusColor + ';font-size:13px;margin-bottom:8px;">' + statusText + '</div>';

    html += '</div>';

    html += '<div style="border:2px solid #f4a;border-radius:8px;padding:12px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#f4a;margin-bottom:10px;text-align:center;">Their Offer</div>' +
      '<div id="other-items" style="display:grid;grid-template-columns:repeat(3,80px);gap:6px;margin-bottom:10px;justify-content:center;">';

    for (var j = 0; j < 6; j++) {
      var otherItem = otherPlayer.items[j];
      var otherSlotHtml = '<div style="background:rgba(255,255,255,0.1);border:2px solid #555;' +
        'border-radius:6px;padding:8px;text-align:center;min-height:60px;position:relative;">';

      if (otherItem && Inventory) {
        var otherItemData = Inventory.getItemData(otherItem.itemId);
        if (otherItemData) {
          otherSlotHtml += '<div style="font-size:28px;">' + otherItemData.icon + '</div>' +
            '<div style="font-size:9px;color:#ccc;">' + otherItemData.name + '</div>' +
            '<div style="position:absolute;top:2px;right:4px;background:#000;padding:1px 4px;border-radius:2px;font-size:10px;">' + otherItem.count + '</div>';
        }
      } else {
        otherSlotHtml += '<div style="color:#444;padding-top:15px;font-size:11px;">Empty</div>';
      }

      otherSlotHtml += '</div>';
      html += otherSlotHtml;
    }

    html += '</div>';

    html += '<div style="margin-bottom:10px;">' +
      '<label style="font-size:12px;color:#aaa;display:block;margin-bottom:4px;">Spark Offer:</label>' +
      '<div style="padding:6px;background:rgba(0,0,0,0.5);border:1px solid #555;border-radius:4px;color:#ffa500;font-size:14px;text-align:center;">' +
      otherPlayer.spark + '</div></div>';

    var otherStatusText = otherPlayer.ready ? 'âœ“ Ready' : 'Not ready';
    var otherStatusColor = otherPlayer.ready ? '#4f4' : '#888';
    html += '<div style="text-align:center;color:' + otherStatusColor + ';font-size:13px;margin-bottom:8px;">' + otherStatusText + '</div>';

    html += '</div>';

    html += '</div>';

    var statusMsg = '';
    if (localPlayer.confirmed && otherPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#4f4;font-size:14px;margin-bottom:12px;">âœ“ Trade completed!</div>';
    } else if (localPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#fa4;font-size:14px;margin-bottom:12px;">Waiting for ' + otherPlayer.id + ' to confirm...</div>';
    } else if (otherPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#fa4;font-size:14px;margin-bottom:12px;">' + otherPlayer.id + ' has confirmed. Ready to confirm?</div>';
    } else if (localPlayer.ready && otherPlayer.ready) {
      statusMsg = '<div style="text-align:center;color:#4f4;font-size:14px;margin-bottom:12px;">Both ready! Click Confirm to complete trade.</div>';
    } else if (localPlayer.ready) {
      statusMsg = '<div style="text-align:center;color:#888;font-size:14px;margin-bottom:12px;">Waiting for ' + otherPlayer.id + ' to ready up...</div>';
    } else {
      statusMsg = '<div style="text-align:center;color:#888;font-size:14px;margin-bottom:12px;">Add items and Spark, then click Ready.</div>';
    }

    html += statusMsg;

    html += '<div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">';

    if (!localPlayer.ready) {
      html += '<button id="trade-ready-btn" style="padding:8px 20px;background:#4f4;color:#000;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Ready</button>';
    }

    if (localPlayer.ready && otherPlayer.ready && !localPlayer.confirmed) {
      html += '<button id="trade-confirm-btn" style="padding:8px 20px;background:#ffa500;color:#000;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Confirm Trade</button>';
    }

    html += '<button id="trade-cancel-btn" style="padding:8px 20px;background:#f44;color:#fff;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Cancel</button>';

    html += '</div>';

    contentDiv.innerHTML = html;

    var callbacks = tradeWindowEl._callbacks;

    var sparkInput = document.getElementById('local-spark-input');
    if (sparkInput && callbacks.onSetSpark) {
      sparkInput.addEventListener('change', function() {
        var amount = parseInt(this.value) || 0;
        callbacks.onSetSpark(amount);
      });
    }

    var readyBtn = document.getElementById('trade-ready-btn');
    if (readyBtn && callbacks.onReady) {
      readyBtn.addEventListener('click', function() {
        callbacks.onReady();
      });
    }

    var confirmBtn = document.getElementById('trade-confirm-btn');
    if (confirmBtn && callbacks.onConfirm) {
      confirmBtn.addEventListener('click', function() {
        callbacks.onConfirm();
      });
    }

    var cancelBtn = document.getElementById('trade-cancel-btn');
    if (cancelBtn && callbacks.onCancel) {
      cancelBtn.addEventListener('click', function() {
        callbacks.onCancel();
      });
    }

    var tradeSlots = document.querySelectorAll('.trade-slot');
    tradeSlots.forEach(function(slot, idx) {
      slot.addEventListener('click', function() {
        if (localPlayer.items[idx] && callbacks.onRemoveItem) {
          callbacks.onRemoveItem(idx);
        } else if (!localPlayer.items[idx] && callbacks.onAddItem) {
          showTradeItemPicker(idx, callbacks.onAddItem);
        }
      });
    });
  }

  function showTradeItemPicker(slotIndex, onAddItem) {
    var existing = document.getElementById('trade-item-picker');
    if (existing) existing.parentNode.removeChild(existing);

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var inv = typeof playerInventory !== 'undefined' ? playerInventory : null;
    if (!inv) {
      inv = typeof window !== 'undefined' && window.playerInventory ? window.playerInventory : null;
    }
    if (!inv) return;

    var items = Inventory.getInventory(inv);
    if (!items || items.length === 0) {
      showNotification('No items in inventory to trade');
      return;
    }

    var picker = document.createElement('div');
    picker.id = 'trade-item-picker';
    picker.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #4af;border-radius:12px;' +
      'padding:16px;width:320px;max-height:400px;overflow-y:auto;z-index:400;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.9);pointer-events:auto;';

    var html = '<div style="font-size:16px;font-weight:bold;color:#4af;margin-bottom:12px;text-align:center;">Select Item to Trade</div>';
    html += '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;">';

    items.forEach(function(item, i) {
      var itemData = Inventory.getItemData(item.itemId);
      if (itemData) {
        html += '<div class="trade-pick-item" data-idx="' + i + '" data-itemid="' + item.itemId + '" ' +
          'style="background:rgba(255,255,255,0.08);border:2px solid #444;border-radius:6px;' +
          'padding:8px;text-align:center;cursor:pointer;transition:border-color 0.2s;">' +
          '<div style="font-size:24px;">' + itemData.icon + '</div>' +
          '<div style="font-size:9px;color:#ccc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + itemData.name + '</div>' +
          '<div style="font-size:10px;color:#888;">x' + (item.count || 1) + '</div>' +
          '</div>';
      }
    });

    html += '</div>';
    html += '<div style="text-align:center;margin-top:12px;">' +
      '<button id="trade-pick-cancel" style="padding:6px 16px;background:#555;color:#fff;border:none;border-radius:4px;cursor:pointer;">Cancel</button></div>';

    picker.innerHTML = html;
    document.body.appendChild(picker);

    var pickItems = picker.querySelectorAll('.trade-pick-item');
    pickItems.forEach(function(el) {
      el.addEventListener('click', function() {
        var itemId = el.getAttribute('data-itemid');
        onAddItem(slotIndex, itemId);
        picker.parentNode.removeChild(picker);
      });
    });

    var cancelBtn = document.getElementById('trade-pick-cancel');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        picker.parentNode.removeChild(picker);
      });
    }
  }

  function hideTradeWindow() {
    if (tradeWindowEl && tradeWindowEl.parentNode) {
      tradeWindowEl.parentNode.removeChild(tradeWindowEl);
      tradeWindowEl = null;
      currentTradeData = null;
    }
  }

  function showTradeComplete(partnerName) {
    showNotification('Trade completed with ' + partnerName + '!', 'success');
  }

  let buildToolbar = null;
  let selectedBuildType = 'bench';

  var BUILD_TYPES = [
    { id: 'bench', icon: '\u{1F6CB}', label: 'Bench', cost: 50 },
    { id: 'lantern', icon: '\u{1F4A1}', label: 'Lantern', cost: 75 },
    { id: 'signpost', icon: '\u{1F6A9}', label: 'Sign', cost: 40 },
    { id: 'fence', icon: '\u{1F6AA}', label: 'Fence', cost: 30 },
    { id: 'planter', icon: '\u{1F33F}', label: 'Planter', cost: 60 },
    { id: 'campfire', icon: '\u{1F525}', label: 'Fire', cost: 80 },
    { id: 'archway', icon: '\u{26E9}', label: 'Arch', cost: 150 },
    { id: 'table', icon: '\u{1F6CF}', label: 'Table', cost: 70 },
    { id: 'barrel', icon: '\u{1F6E2}', label: 'Barrel', cost: 45 },
    { id: 'crate', icon: '\u{1F4E6}', label: 'Crate', cost: 35 }
  ];

  function showBuildToolbar() {
    if (typeof document === 'undefined') return;

    if (buildToolbar) {
      buildToolbar.style.display = 'block';
      return;
    }

    buildToolbar = document.createElement('div');
    buildToolbar.id = 'build-toolbar';
    buildToolbar.style.cssText = `
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 200;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-bottom: none;
      pointer-events: auto;
    `;

    var title = document.createElement('div');
    title.style.cssText = `
      color: #fff;
      font-weight: bold;
      margin-right: 10px;
      font-size: 14px;
    `;
    title.textContent = 'BUILD MODE';
    buildToolbar.appendChild(title);

    BUILD_TYPES.forEach(function(type) {
      var btn = document.createElement('div');
      btn.className = 'build-type-btn';
      btn.dataset.type = type.id;
      btn.style.cssText = `
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      `;

      var icon = document.createElement('div');
      icon.style.cssText = 'font-size: 24px; margin-bottom: 2px;';
      icon.textContent = type.icon;

      var label = document.createElement('div');
      label.style.cssText = 'font-size: 9px; color: #ccc;';
      label.textContent = type.label;

      var cost = document.createElement('div');
      cost.style.cssText = 'font-size: 8px; color: #ffa500;';
      cost.textContent = type.cost + ' Spark';

      btn.appendChild(icon);
      btn.appendChild(label);
      btn.appendChild(cost);

      btn.addEventListener('click', function() {
        selectedBuildType = type.id;
        updateBuildToolbar(selectedBuildType);
        if (typeof World !== 'undefined' && World.setBuildType) {
          World.setBuildType(type.id);
        }
      });

      btn.addEventListener('mouseenter', function() {
        btn.style.background = 'rgba(255, 255, 255, 0.2)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.6)';
      });

      btn.addEventListener('mouseleave', function() {
        if (type.id !== selectedBuildType) {
          btn.style.background = 'rgba(255, 255, 255, 0.1)';
          btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
      });

      buildToolbar.appendChild(btn);
    });

    var instructions = document.createElement('div');
    instructions.style.cssText = `
      margin-left: 15px;
      color: #ccc;
      font-size: 12px;
      line-height: 1.4;
    `;
    instructions.innerHTML = `
      <div>Click to place</div>
      <div>R to rotate</div>
      <div><strong>B or Esc</strong> to exit</div>
    `;
    buildToolbar.appendChild(instructions);

    document.body.appendChild(buildToolbar);

    updateBuildToolbar(selectedBuildType);
  }

  function hideBuildToolbar() {
    if (buildToolbar) {
      buildToolbar.style.display = 'none';
    }
  }

  function updateBuildToolbar(type) {
    if (!buildToolbar) return;
    selectedBuildType = type;

    var buttons = buildToolbar.querySelectorAll('.build-type-btn');
    buttons.forEach(function(btn) {
      if (btn.dataset.type === type) {
        btn.style.background = 'rgba(255, 215, 0, 0.3)';
        btn.style.borderColor = 'rgba(255, 215, 0, 0.8)';
        btn.style.borderWidth = '3px';
      } else {
        btn.style.background = 'rgba(255, 255, 255, 0.1)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        btn.style.borderWidth = '2px';
      }
    });
  }

  let settingsMenuPanel = null;
  let settingsData = {
    masterVolume: 50,
    musicVolume: 30,
    sfxVolume: 70,
    renderDistance: 'medium',
    particleDensity: 'medium',
    showFPS: false
  };

  function loadSettings() {
    if (typeof localStorage === 'undefined') return;
    try {
      var stored = localStorage.getItem('zion_settings');
      if (stored) {
        var parsed = JSON.parse(stored);
        Object.assign(settingsData, parsed);
      }
    } catch (err) {
      console.warn('Failed to load settings:', err);
    }
  }

  function saveSettings() {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem('zion_settings', JSON.stringify(settingsData));
    } catch (err) {
      console.warn('Failed to save settings:', err);
    }
  }

  function getSettings() {
    return settingsData;
  }

  function showSettingsMenu() {
    if (settingsMenuPanel) return;

    var overlay = document.createElement('div');
    overlay.id = 'settings-menu-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    `;

    var panel = document.createElement('div');
    panel.style.cssText = `
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 12px;
      padding: 30px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
    `;

    var title = document.createElement('h2');
    title.textContent = 'Settings';
    title.style.cssText = `
      margin: 0 0 25px 0;
      color: #DAA520;
      font-size: 28px;
      font-family: Georgia, serif;
      text-align: center;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;
    panel.appendChild(title);

    var volumeSection = document.createElement('div');
    volumeSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var volumeTitle = document.createElement('h3');
    volumeTitle.textContent = 'Audio';
    volumeTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    volumeSection.appendChild(volumeTitle);

    volumeSection.appendChild(createSlider('Master Volume', 'masterVolume', settingsData.masterVolume));
    volumeSection.appendChild(createSlider('Music Volume', 'musicVolume', settingsData.musicVolume));
    volumeSection.appendChild(createSlider('SFX Volume', 'sfxVolume', settingsData.sfxVolume));

    panel.appendChild(volumeSection);

    var graphicsSection = document.createElement('div');
    graphicsSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var graphicsTitle = document.createElement('h3');
    graphicsTitle.textContent = 'Graphics';
    graphicsTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    graphicsSection.appendChild(graphicsTitle);

    graphicsSection.appendChild(createOptionButtons('Render Distance', 'renderDistance', ['low', 'medium', 'high'], settingsData.renderDistance));
    graphicsSection.appendChild(createOptionButtons('Particle Density', 'particleDensity', ['low', 'medium', 'high'], settingsData.particleDensity));
    graphicsSection.appendChild(createCheckbox('Show FPS Counter', 'showFPS', settingsData.showFPS));

    panel.appendChild(graphicsSection);

    var controlsSection = document.createElement('div');
    controlsSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var controlsTitle = document.createElement('h3');
    controlsTitle.textContent = 'Controls';
    controlsTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    controlsSection.appendChild(controlsTitle);

    var controlsInfo = document.createElement('div');
    controlsInfo.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      line-height: 1.8;
      font-family: system-ui, sans-serif;
    `;
    controlsInfo.innerHTML = `
      <div style="display: grid; grid-template-columns: 120px 1fr; gap: 8px;">
        <div><strong>W/A/S/D</strong></div><div>Move</div>
        <div><strong>Mouse</strong></div><div>Look around</div>
        <div><strong>E</strong></div><div>Interact</div>
        <div><strong>I</strong></div><div>Inventory</div>
        <div><strong>C</strong></div><div>Crafting</div>
        <div><strong>J</strong></div><div>Quest Log</div>
        <div><strong>M</strong></div><div>World Map</div>
        <div><strong>B</strong></div><div>Build Mode</div>
        <div><strong>F</strong></div><div>Emote Menu</div>
        <div><strong>T</strong></div><div>Trade</div>
        <div><strong>P</strong></div><div>Player Profile</div>
        <div><strong>Enter</strong></div><div>Chat</div>
        <div><strong>Escape</strong></div><div>Settings / Cancel</div>
      </div>
    `;
    controlsSection.appendChild(controlsInfo);

    panel.appendChild(controlsSection);

    var resumeBtn = document.createElement('button');
    resumeBtn.textContent = 'Resume';
    resumeBtn.style.cssText = `
      width: 100%;
      padding: 15px;
      background: rgba(218, 165, 32, 0.2);
      color: #DAA520;
      border: 2px solid #DAA520;
      border-radius: 8px;
      font-size: 18px;
      font-family: Georgia, serif;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 10px;
    `;
    resumeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#FFD700';
    };
    resumeBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.2)';
      this.style.borderColor = '#DAA520';
    };
    resumeBtn.onclick = function() {
      hideSettingsMenu();
    };
    panel.appendChild(resumeBtn);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);
    settingsMenuPanel = overlay;
  }

  function hideSettingsMenu() {
    if (!settingsMenuPanel) return;
    document.body.removeChild(settingsMenuPanel);
    settingsMenuPanel = null;
  }

  function createSlider(label, key, value) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
    `;

    var labelEl = document.createElement('label');
    labelEl.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;

    var labelText = document.createElement('span');
    labelText.textContent = label;

    var valueDisplay = document.createElement('span');
    valueDisplay.textContent = value;
    valueDisplay.style.color = '#DAA520';
    valueDisplay.style.fontWeight = 'bold';

    labelEl.appendChild(labelText);
    labelEl.appendChild(valueDisplay);
    container.appendChild(labelEl);

    var slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '100';
    slider.value = value;
    slider.style.cssText = `
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    `;

    slider.oninput = function() {
      valueDisplay.textContent = this.value;
      settingsData[key] = parseInt(this.value);
      saveSettings();
      applySettings();
    };

    container.appendChild(slider);
    return container;
  }

  function createOptionButtons(label, key, options, currentValue) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
    `;

    var labelEl = document.createElement('div');
    labelEl.textContent = label;
    labelEl.style.cssText = `
      margin-bottom: 8px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    container.appendChild(labelEl);

    var buttonsContainer = document.createElement('div');
    buttonsContainer.style.cssText = `
      display: flex;
      gap: 10px;
    `;

    options.forEach(function(option) {
      var btn = document.createElement('button');
      btn.textContent = option.charAt(0).toUpperCase() + option.slice(1);
      btn.style.cssText = `
        flex: 1;
        padding: 10px;
        background: ${option === currentValue ? 'rgba(218, 165, 32, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
        color: ${option === currentValue ? '#DAA520' : '#E8E0D8'};
        border: 2px solid ${option === currentValue ? '#DAA520' : 'rgba(255, 255, 255, 0.3)'};
        border-radius: 6px;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        cursor: pointer;
        transition: all 0.3s ease;
      `;

      btn.onclick = function() {
        settingsData[key] = option;
        saveSettings();
        applySettings();

        Array.from(buttonsContainer.children).forEach(function(child) {
          child.style.background = 'rgba(255, 255, 255, 0.1)';
          child.style.color = '#E8E0D8';
          child.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        btn.style.background = 'rgba(218, 165, 32, 0.3)';
        btn.style.color = '#DAA520';
        btn.style.borderColor = '#DAA520';
      };

      btn.onmouseover = function() {
        if (option !== currentValue) {
          this.style.background = 'rgba(255, 255, 255, 0.15)';
        }
      };

      btn.onmouseout = function() {
        if (option !== currentValue) {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
        }
      };

      buttonsContainer.appendChild(btn);
    });

    container.appendChild(buttonsContainer);
    return container;
  }

  function createCheckbox(label, key, checked) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    `;

    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = checked;
    checkbox.style.cssText = `
      width: 20px;
      height: 20px;
      cursor: pointer;
    `;

    checkbox.onchange = function() {
      settingsData[key] = this.checked;
      saveSettings();
      applySettings();
    };

    var labelEl = document.createElement('label');
    labelEl.textContent = label;
    labelEl.style.cssText = `
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      cursor: pointer;
    `;
    labelEl.onclick = function() {
      checkbox.checked = !checkbox.checked;
      checkbox.onchange();
    };

    container.appendChild(checkbox);
    container.appendChild(labelEl);
    return container;
  }

  function applySettings() {
    if (typeof Audio !== 'undefined' && Audio.setVolume) {
      Audio.setVolume('master', settingsData.masterVolume / 100);
      Audio.setVolume('music', settingsData.musicVolume / 100);
      Audio.setVolume('sfx', settingsData.sfxVolume / 100);
    }

  }

  var playerProfilePanel = null;

  function showProfilePanel(playerData, skillData, achievementData) {
    if (playerProfilePanel) {
      hideProfilePanel();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'player-profile-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.9);border:2px solid #d4af37;border-radius:12px;' +
      'padding:0;width:700px;max-height:85vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;justify-content:space-between;align-items:center;' +
      'padding:20px;background:rgba(212,175,55,0.1);border-bottom:1px solid #d4af37;';

    var title = document.createElement('div');
    title.textContent = 'Player Profile';
    title.style.cssText = 'font-size:24px;font-weight:bold;color:#d4af37;';
    header.appendChild(title);

    var closeBtn = document.createElement('div');
    closeBtn.textContent = 'âœ•';
    closeBtn.style.cssText = 'cursor:pointer;font-size:24px;color:#888;padding:0 8px;';
    closeBtn.onmouseover = function() { this.style.color = '#d4af37'; };
    closeBtn.onmouseout = function() { this.style.color = '#888'; };
    closeBtn.onclick = function() { hideProfilePanel(); };
    header.appendChild(closeBtn);

    panel.appendChild(header);

    var content = document.createElement('div');
    content.id = 'profile-content';
    content.style.cssText = 'padding:20px;';

    var playerInfoSection = document.createElement('div');
    playerInfoSection.style.cssText = 'display:flex;align-items:center;margin-bottom:20px;' +
      'padding-bottom:20px;border-bottom:1px solid rgba(212,175,55,0.3);';

    var avatar = document.createElement('div');
    var initial = (playerData.name || 'P').charAt(0).toUpperCase();
    avatar.textContent = initial;
    avatar.style.cssText = 'width:80px;height:80px;border-radius:50%;background:#d4af37;' +
      'display:flex;align-items:center;justify-content:center;font-size:36px;font-weight:bold;' +
      'color:#000;margin-right:20px;';
    playerInfoSection.appendChild(avatar);

    var playerDetails = document.createElement('div');
    playerDetails.style.cssText = 'flex:1;';

    var playerName = document.createElement('div');
    playerName.textContent = playerData.name || 'Player';
    playerName.style.cssText = 'font-size:22px;font-weight:bold;color:#fff;margin-bottom:8px;';
    playerDetails.appendChild(playerName);

    var reputationTier = document.createElement('div');
    var tier = playerData.reputationTier || 'Newcomer';
    reputationTier.textContent = 'Reputation: ' + tier;
    reputationTier.style.cssText = 'font-size:14px;color:#d4af37;margin-bottom:6px;';
    playerDetails.appendChild(reputationTier);

    var sparkBalance = document.createElement('div');
    sparkBalance.innerHTML = '<span style="color:#d4af37;">âœ¦</span> ' + (playerData.sparkBalance || 0) + ' Spark';
    sparkBalance.style.cssText = 'font-size:16px;color:#fff;font-weight:bold;';
    playerDetails.appendChild(sparkBalance);

    playerInfoSection.appendChild(playerDetails);
    content.appendChild(playerInfoSection);

    var skillsSection = document.createElement('div');
    skillsSection.id = 'profile-skills-section';
    skillsSection.style.cssText = 'margin-bottom:20px;';

    var skillsTitle = document.createElement('div');
    skillsTitle.textContent = 'Skills';
    skillsTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    skillsSection.appendChild(skillsTitle);

    var skillNames = ['gardening', 'crafting', 'building', 'exploration', 'trading', 'social', 'combat', 'lore'];
    var skillIcons = {
      gardening: 'ðŸŒ±',
      crafting: 'ðŸ”¨',
      building: 'ðŸ—ï¸',
      exploration: 'ðŸ—ºï¸',
      trading: 'ðŸ’°',
      social: 'ðŸ‘¥',
      combat: 'âš”ï¸',
      lore: 'ðŸ“–'
    };

    skillNames.forEach(function(skillName) {
      var skill = (skillData && skillData[skillName]) || { level: 1, xp: 0, xpToNext: 100 };
      var skillDiv = document.createElement('div');
      skillDiv.className = 'skill-row-' + skillName;
      skillDiv.style.cssText = 'margin-bottom:14px;';

      var skillHeader = document.createElement('div');
      skillHeader.style.cssText = 'display:flex;justify-content:space-between;margin-bottom:4px;';

      var skillLabel = document.createElement('div');
      var icon = skillIcons[skillName] || 'â­';
      skillLabel.innerHTML = icon + ' ' + skillName.charAt(0).toUpperCase() + skillName.slice(1);
      skillLabel.style.cssText = 'font-size:14px;color:#fff;font-weight:600;';
      skillHeader.appendChild(skillLabel);

      var skillLevel = document.createElement('div');
      skillLevel.textContent = 'Level ' + skill.level;
      skillLevel.style.cssText = 'font-size:13px;color:#d4af37;font-weight:bold;';
      skillHeader.appendChild(skillLevel);

      skillDiv.appendChild(skillHeader);

      var progressContainer = document.createElement('div');
      progressContainer.style.cssText = 'width:100%;height:10px;background:rgba(255,255,255,0.1);' +
        'border-radius:5px;overflow:hidden;position:relative;';

      var progressFill = document.createElement('div');
      var progressPercent = Math.min(100, (skill.xp / skill.xpToNext) * 100);
      progressFill.style.cssText = 'height:100%;background:linear-gradient(90deg,#d4af37,#f4e4a6);' +
        'border-radius:5px;width:' + progressPercent + '%;transition:width 0.3s ease;';
      progressContainer.appendChild(progressFill);

      var progressText = document.createElement('div');
      progressText.textContent = skill.xp + ' / ' + skill.xpToNext + ' XP';
      progressText.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;' +
        'display:flex;align-items:center;justify-content:center;font-size:9px;color:#fff;font-weight:bold;';
      progressContainer.appendChild(progressText);

      skillDiv.appendChild(progressContainer);
      skillsSection.appendChild(skillDiv);
    });

    content.appendChild(skillsSection);

    var statsSection = document.createElement('div');
    statsSection.id = 'profile-stats-section';
    statsSection.style.cssText = 'margin-bottom:20px;padding:15px;background:rgba(212,175,55,0.05);' +
      'border-radius:8px;border:1px solid rgba(212,175,55,0.2);';

    var statsTitle = document.createElement('div');
    statsTitle.textContent = 'Statistics';
    statsTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    statsSection.appendChild(statsTitle);

    var statsGrid = document.createElement('div');
    statsGrid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:10px;';

    var stats = [
      { label: 'Quests Completed', value: playerData.questsCompleted || 0 },
      { label: 'Discoveries Found', value: playerData.discoveriesFound || 0 },
      { label: 'Items Crafted', value: playerData.itemsCrafted || 0 },
      { label: 'Trades Completed', value: playerData.tradesCompleted || 0 },
      { label: 'Time Played', value: formatPlayTime(playerData.playTimeSeconds || 0) }
    ];

    stats.forEach(function(stat) {
      var statItem = document.createElement('div');
      statItem.className = 'stat-' + stat.label.toLowerCase().replace(/ /g, '-');
      statItem.style.cssText = 'padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;';

      var statLabel = document.createElement('div');
      statLabel.textContent = stat.label;
      statLabel.style.cssText = 'font-size:11px;color:#888;margin-bottom:4px;';
      statItem.appendChild(statLabel);

      var statValue = document.createElement('div');
      statValue.textContent = stat.value;
      statValue.style.cssText = 'font-size:16px;color:#fff;font-weight:bold;';
      statItem.appendChild(statValue);

      statsGrid.appendChild(statItem);
    });

    statsSection.appendChild(statsGrid);
    content.appendChild(statsSection);

    var activitySection = document.createElement('div');
    activitySection.id = 'profile-activity-section';
    activitySection.style.cssText = 'margin-bottom:0;';

    var activityTitle = document.createElement('div');
    activityTitle.textContent = 'Recent Activity';
    activityTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    activitySection.appendChild(activityTitle);

    var activities = playerData.recentActivities || ['Started playing ZION'];
    var activityList = document.createElement('div');
    activityList.style.cssText = 'max-height:150px;overflow-y:auto;';

    activities.slice(0, 10).forEach(function(activity) {
      var activityItem = document.createElement('div');
      activityItem.textContent = 'â€¢ ' + activity;
      activityItem.style.cssText = 'font-size:12px;color:#aaa;padding:4px 0;line-height:1.4;';
      activityList.appendChild(activityItem);
    });

    activitySection.appendChild(activityList);
    content.appendChild(activitySection);

    var closeHint = document.createElement('div');
    closeHint.textContent = 'Press P to close';
    closeHint.style.cssText = 'text-align:center;margin-top:15px;font-size:11px;color:#666;';
    content.appendChild(closeHint);

    panel.appendChild(content);
    document.body.appendChild(panel);
    playerProfilePanel = panel;
  }

  function hideProfilePanel() {
    if (!playerProfilePanel) return;
    if (playerProfilePanel.parentNode) {
      playerProfilePanel.parentNode.removeChild(playerProfilePanel);
    }
    playerProfilePanel = null;
  }

  function updateProfileStats(stats) {
    if (!playerProfilePanel) return;

    if (stats.questsCompleted !== undefined) {
      var questsStat = playerProfilePanel.querySelector('.stat-quests-completed div:last-child');
      if (questsStat) questsStat.textContent = stats.questsCompleted;
    }
    if (stats.discoveriesFound !== undefined) {
      var discoveriesStat = playerProfilePanel.querySelector('.stat-discoveries-found div:last-child');
      if (discoveriesStat) discoveriesStat.textContent = stats.discoveriesFound;
    }
    if (stats.itemsCrafted !== undefined) {
      var craftedStat = playerProfilePanel.querySelector('.stat-items-crafted div:last-child');
      if (craftedStat) craftedStat.textContent = stats.itemsCrafted;
    }
    if (stats.tradesCompleted !== undefined) {
      var tradesStat = playerProfilePanel.querySelector('.stat-trades-completed div:last-child');
      if (tradesStat) tradesStat.textContent = stats.tradesCompleted;
    }
    if (stats.playTimeSeconds !== undefined) {
      var timeStat = playerProfilePanel.querySelector('.stat-time-played div:last-child');
      if (timeStat) timeStat.textContent = formatPlayTime(stats.playTimeSeconds);
    }
  }

  function showPlayerProfile(playerData) {
    showProfilePanel(playerData, null, null);
  }

  function hidePlayerProfile() {
    hideProfilePanel();
  }

  function formatPlayTime(seconds) {
    var hours = Math.floor(seconds / 3600);
    var minutes = Math.floor((seconds % 3600) / 60);
    if (hours > 0) {
      return hours + 'h ' + minutes + 'm';
    }
    return minutes + 'm';
  }

  var discoveryLogPanel = null;

  function showDiscoveryLog(discoveries) {
    if (discoveryLogPanel) return;

    var panel = document.createElement('div');
    panel.id = 'discovery-log-overlay';
    panel.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    `;

    var content = document.createElement('div');
    content.style.cssText = `
      width: 80%;
      max-width: 900px;
      height: 80%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 12px;
      padding: 30px;
      overflow-y: auto;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
      border: 2px solid #3a506b;
    `;

    var header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #3a506b;
    `;

    var title = document.createElement('h2');
    title.textContent = 'Discovery Log';
    title.style.cssText = `
      margin: 0;
      color: #e0e0e0;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      font-weight: 600;
    `;

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'X';
    closeBtn.style.cssText = `
      background: #c0392b;
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
    `;
    closeBtn.onclick = hideDiscoveryLog;

    header.appendChild(title);
    header.appendChild(closeBtn);
    content.appendChild(header);

    var discoveryByZone = {};
    var totalDiscoveries = 0;
    if (discoveries && discoveries.length > 0) {
      discoveries.forEach(function(disc) {
        var zone = disc.zone || 'Unknown';
        if (!discoveryByZone[zone]) {
          discoveryByZone[zone] = [];
        }
        discoveryByZone[zone].push(disc);
        totalDiscoveries++;
      });
    }

    Object.keys(discoveryByZone).forEach(function(zone) {
      var zoneSection = document.createElement('div');
      zoneSection.style.cssText = `
        margin-bottom: 30px;
      `;

      var zoneHeader = document.createElement('div');
      zoneHeader.textContent = zone + ' (' + discoveryByZone[zone].length + ' discoveries)';
      zoneHeader.style.cssText = `
        color: #5dade2;
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 15px;
        font-family: system-ui, sans-serif;
      `;
      zoneSection.appendChild(zoneHeader);

      discoveryByZone[zone].forEach(function(disc) {
        var rarityColors = {
          common: '#ffffff',
          uncommon: '#1eff00',
          rare: '#0070dd',
          epic: '#a335ee',
          legendary: '#ff8000'
        };
        var color = rarityColors[disc.rarity] || '#ffffff';

        var discItem = document.createElement('div');
        discItem.style.cssText = `
          background: rgba(255, 255, 255, 0.05);
          border-left: 4px solid ` + color + `;
          padding: 12px 15px;
          margin-bottom: 10px;
          border-radius: 6px;
        `;

        var discName = document.createElement('div');
        discName.textContent = disc.name;
        discName.style.cssText = `
          color: ` + color + `;
          font-size: 16px;
          font-weight: 600;
          margin-bottom: 5px;
          font-family: system-ui, sans-serif;
        `;

        var discDesc = document.createElement('div');
        discDesc.textContent = disc.description || 'No description available';
        discDesc.style.cssText = `
          color: #b0b0b0;
          font-size: 14px;
          margin-bottom: 5px;
          font-family: system-ui, sans-serif;
        `;

        var discMeta = document.createElement('div');
        discMeta.textContent = 'Discovered: ' + (disc.timestamp ? new Date(disc.timestamp).toLocaleDateString() : 'Unknown');
        discMeta.style.cssText = `
          color: #808080;
          font-size: 12px;
          font-style: italic;
          font-family: system-ui, sans-serif;
        `;

        discItem.appendChild(discName);
        discItem.appendChild(discDesc);
        discItem.appendChild(discMeta);
        zoneSection.appendChild(discItem);
      });

      content.appendChild(zoneSection);
    });

    if (totalDiscoveries === 0) {
      var emptyMsg = document.createElement('div');
      emptyMsg.textContent = 'No discoveries yet. Explore the world to find new locations, creatures, and secrets!';
      emptyMsg.style.cssText = `
        color: #a0a0a0;
        font-size: 16px;
        text-align: center;
        margin-top: 50px;
        font-family: system-ui, sans-serif;
      `;
      content.appendChild(emptyMsg);
    }

    panel.appendChild(content);
    document.body.appendChild(panel);
    discoveryLogPanel = panel;
    panel.className = 'discovery-panel';
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideDiscoveryLog();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideDiscoveryLog() {
    if (!discoveryLogPanel) return;
    if (discoveryLogPanel.escapeHandler) {
      document.removeEventListener('keydown', discoveryLogPanel.escapeHandler);
    }
    discoveryLogPanel.classList.remove('visible');
    setTimeout(function() {
      if (discoveryLogPanel && discoveryLogPanel.parentNode) {
        document.body.removeChild(discoveryLogPanel);
        discoveryLogPanel = null;
      }
    }, 250);
  }

  var loreBookPanel = null;

  function showLoreJournal(playerId, state) {
    if (loreBookPanel) {
      hideLoreJournal();
      return;
    }

    var unlockedLore = [];
    var loreCategories = {};

    if (typeof window !== 'undefined' && window.Exploration) {
      unlockedLore = window.Exploration.getUnlockedLore(playerId, state);
      loreCategories = window.Exploration.getLoreCategories();
    }

    var loreByCategory = {};
    unlockedLore.forEach(function(entry) {
      if (!loreByCategory[entry.category]) {
        loreByCategory[entry.category] = [];
      }
      loreByCategory[entry.category].push(entry);
    });

    var allLoreEntries = window.Exploration ? window.Exploration.LORE_ENTRIES : {};

    var panel = document.createElement('div');
    panel.className = 'lore-journal-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 85%;
      max-width: 950px;
      height: 85vh;
      background: linear-gradient(135deg, #3d2817 0%, #2a1810 100%);
      border: 3px solid #8b6914;
      border-radius: 10px;
      box-shadow: 0 15px 60px rgba(0, 0, 0, 0.8), inset 0 0 40px rgba(139, 105, 20, 0.1);
      z-index: 10000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.style.cssText = `
      background: linear-gradient(180deg, rgba(61, 40, 23, 0.9) 0%, rgba(42, 24, 16, 0.95) 100%);
      padding: 20px 30px;
      border-bottom: 2px solid #8b6914;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;

    var titleContainer = document.createElement('div');

    var title = document.createElement('h2');
    title.textContent = 'Lore Journal';
    title.style.cssText = `
      margin: 0 0 5px 0;
      color: #f4e4c1;
      font-size: 30px;
      font-family: Georgia, serif;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
    `;
    titleContainer.appendChild(title);

    var totalLore = Object.keys(allLoreEntries).length;
    var unlockedCount = unlockedLore.length;
    var completionPct = totalLore > 0 ? Math.round((unlockedCount / totalLore) * 100) : 0;

    var completion = document.createElement('div');
    completion.textContent = 'Completion: ' + unlockedCount + '/' + totalLore + ' (' + completionPct + '%)';
    completion.style.cssText = `
      color: #d4af37;
      font-size: 14px;
      font-family: Georgia, serif;
    `;
    titleContainer.appendChild(completion);

    header.appendChild(titleContainer);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\u00D7';
    closeBtn.style.cssText = `
      background: rgba(139, 69, 19, 0.6);
      border: 2px solid #8b6914;
      color: #f4e4c1;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 28px;
      font-weight: bold;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.4)';
      this.style.borderColor = '#d4af37';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 69, 19, 0.6)';
      this.style.borderColor = '#8b6914';
    };
    closeBtn.onclick = hideLoreJournal;
    header.appendChild(closeBtn);

    panel.appendChild(header);

    var tabsContainer = document.createElement('div');
    tabsContainer.style.cssText = `
      display: flex;
      gap: 5px;
      padding: 15px 20px 0 20px;
      background: rgba(42, 24, 16, 0.7);
      overflow-x: auto;
      border-bottom: 2px solid #8b6914;
    `;

    var contentArea = document.createElement('div');
    contentArea.style.cssText = `
      flex: 1;
      overflow-y: auto;
      padding: 25px 30px;
      background: linear-gradient(180deg, rgba(42, 24, 16, 0.8) 0%, rgba(26, 15, 10, 0.9) 100%);
    `;

    var categories = ['origins', 'artifacts', 'landmarks', 'nature', 'mysteries', 'art', 'history'];
    var currentCategory = categories[0];

    function renderCategory(category) {
      contentArea.innerHTML = '';

      var categoryHeader = document.createElement('div');
      categoryHeader.style.cssText = `
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.3);
      `;

      var categoryTitle = document.createElement('h3');
      categoryTitle.textContent = category.charAt(0).toUpperCase() + category.slice(1);
      categoryTitle.style.cssText = `
        margin: 0 0 8px 0;
        color: #d4af37;
        font-size: 24px;
        font-family: Georgia, serif;
        font-weight: 600;
      `;
      categoryHeader.appendChild(categoryTitle);

      var categoryTotal = 0;
      var categoryUnlocked = 0;
      for (var loreId in allLoreEntries) {
        if (allLoreEntries[loreId].category === category) {
          categoryTotal++;
          if (loreByCategory[category] && loreByCategory[category].some(function(e) { return e.id === loreId; })) {
            categoryUnlocked++;
          }
        }
      }

      var categoryProgress = document.createElement('div');
      categoryProgress.className = 'lore-progress';
      categoryProgress.textContent = 'Discovered: ' + categoryUnlocked + '/' + categoryTotal;
      categoryProgress.style.cssText = `
        color: #c8b896;
        font-size: 13px;
        font-family: Georgia, serif;
      `;
      categoryHeader.appendChild(categoryProgress);

      contentArea.appendChild(categoryHeader);

      var entriesContainer = document.createElement('div');
      entriesContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 15px;
      `;

      for (var loreId in allLoreEntries) {
        var loreEntry = allLoreEntries[loreId];
        if (loreEntry.category !== category) continue;

        var isUnlocked = loreByCategory[category] && loreByCategory[category].some(function(e) { return e.id === loreId; });

        var entryDiv = document.createElement('div');
        entryDiv.className = isUnlocked ? 'lore-entry' : 'lore-entry lore-entry-locked';
        entryDiv.style.cssText = `
          background: ${isUnlocked ? 'rgba(212, 175, 55, 0.08)' : 'rgba(100, 80, 60, 0.15)'};
          border-left: 4px solid ${isUnlocked ? '#d4af37' : '#666'};
          padding: 18px 20px;
          border-radius: 6px;
          transition: background 0.2s ease;
          ${!isUnlocked ? 'filter: blur(0.5px); opacity: 0.6;' : ''}
        `;

        if (isUnlocked) {
          entryDiv.onmouseover = function() {
            this.style.background = 'rgba(212, 175, 55, 0.15)';
          };
          entryDiv.onmouseout = function() {
            this.style.background = 'rgba(212, 175, 55, 0.08)';
          };
        }

        var entryTitle = document.createElement('div');
        entryTitle.textContent = isUnlocked ? loreEntry.title : '???';
        entryTitle.style.cssText = `
          color: ${isUnlocked ? '#f4e4c1' : '#888'};
          font-size: 18px;
          font-weight: 600;
          margin-bottom: 10px;
          font-family: Georgia, serif;
        `;
        entryDiv.appendChild(entryTitle);

        var entryText = document.createElement('div');
        if (isUnlocked) {
          entryText.textContent = loreEntry.text;
          entryText.style.cssText = `
            color: #c8b896;
            font-size: 14px;
            line-height: 1.7;
            font-family: Georgia, serif;
          `;
        } else {
          entryText.textContent = 'Undiscovered... Explore the world to unlock this lore.';
          entryText.style.cssText = `
            color: #777;
            font-size: 13px;
            font-style: italic;
            line-height: 1.6;
            font-family: Georgia, serif;
          `;
        }
        entryDiv.appendChild(entryText);

        entriesContainer.appendChild(entryDiv);
      }

      contentArea.appendChild(entriesContainer);
    }

    categories.forEach(function(category) {
      var tab = document.createElement('button');
      tab.className = 'lore-category-tab';
      tab.textContent = category.charAt(0).toUpperCase() + category.slice(1);
      tab.style.cssText = `
        background: ${category === currentCategory ? 'rgba(212, 175, 55, 0.3)' : 'rgba(100, 80, 60, 0.2)'};
        border: 2px solid ${category === currentCategory ? '#d4af37' : '#666'};
        border-bottom: none;
        border-radius: 6px 6px 0 0;
        color: ${category === currentCategory ? '#f4e4c1' : '#a0978e'};
        padding: 10px 20px;
        font-size: 14px;
        font-family: Georgia, serif;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        font-weight: ${category === currentCategory ? '600' : '400'};
      `;

      tab.onclick = function() {
        currentCategory = category;
        var allTabs = tabsContainer.querySelectorAll('.lore-category-tab');
        allTabs.forEach(function(t) {
          var isActive = t.textContent.toLowerCase() === category;
          t.style.background = isActive ? 'rgba(212, 175, 55, 0.3)' : 'rgba(100, 80, 60, 0.2)';
          t.style.borderColor = isActive ? '#d4af37' : '#666';
          t.style.color = isActive ? '#f4e4c1' : '#a0978e';
          t.style.fontWeight = isActive ? '600' : '400';
        });
        renderCategory(category);
      };

      tab.onmouseover = function() {
        if (this.textContent.toLowerCase() !== currentCategory) {
          this.style.background = 'rgba(139, 105, 20, 0.3)';
          this.style.color = '#d4af37';
        }
      };
      tab.onmouseout = function() {
        if (this.textContent.toLowerCase() !== currentCategory) {
          this.style.background = 'rgba(100, 80, 60, 0.2)';
          this.style.color = '#a0978e';
        }
      };

      tabsContainer.appendChild(tab);
    });

    panel.appendChild(tabsContainer);
    panel.appendChild(contentArea);

    renderCategory(currentCategory);

    document.body.appendChild(panel);
    loreBookPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideLoreJournal();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideLoreJournal() {
    if (!loreBookPanel) return;
    if (loreBookPanel.escapeHandler) {
      document.removeEventListener('keydown', loreBookPanel.escapeHandler);
    }
    loreBookPanel.classList.remove('visible');
    setTimeout(function() {
      if (loreBookPanel && loreBookPanel.parentNode) {
        document.body.removeChild(loreBookPanel);
        loreBookPanel = null;
      }
    }, 250);
  }

  function toggleLoreJournal(playerId, state) {
    if (loreBookPanel) {
      hideLoreJournal();
    } else {
      showLoreJournal(playerId, state);
    }
  }

  function showLoreBook(playerId, state) {
    showLoreJournal(playerId, state);
  }

  function hideLoreBook() {
    hideLoreJournal();
  }

  function showAchievementToast(achievement) {
    if (typeof document === 'undefined') return;

    var toast = document.createElement('div');
    toast.className = 'achievement-toast';

    var icon = document.createElement('div');
    icon.className = 'achievement-toast-icon';
    icon.textContent = achievement.icon || 'â­';

    var textContainer = document.createElement('div');
    textContainer.className = 'achievement-toast-text';

    var label = document.createElement('div');
    label.className = 'achievement-toast-label';
    label.textContent = 'ACHIEVEMENT UNLOCKED';

    var achievementName = document.createElement('div');
    achievementName.className = 'achievement-toast-name';
    achievementName.textContent = achievement.name || 'Unknown Achievement';

    textContainer.appendChild(label);
    textContainer.appendChild(achievementName);

    toast.appendChild(icon);
    toast.appendChild(textContainer);
    document.body.appendChild(toast);

    setTimeout(function() {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 4000);
  }

  function showDiscoveryPopup(discovery) {
    var popup = document.createElement('div');
    popup.className = 'discovery-popup';
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #5dade2;
      border-radius: 12px;
      padding: 30px;
      min-width: 400px;
      box-shadow: 0 0 50px rgba(93, 173, 226, 0.6);
      z-index: 10001;
    `;

    var header = document.createElement('div');
    header.textContent = 'NEW DISCOVERY';
    header.style.cssText = `
      color: #ffd700;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 15px;
      font-family: system-ui, sans-serif;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    `;

    var rarityColors = {
      common: '#ffffff',
      uncommon: '#1eff00',
      rare: '#0070dd',
      epic: '#a335ee',
      legendary: '#ff8000'
    };
    var color = rarityColors[discovery.rarity] || '#ffffff';

    var discoveryName = document.createElement('div');
    discoveryName.textContent = discovery.name || 'Unknown Discovery';
    discoveryName.style.cssText = `
      color: ` + color + `;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
      font-family: system-ui, sans-serif;
      text-shadow: 0 0 10px ` + color + `;
    `;

    var discoveryDesc = document.createElement('div');
    discoveryDesc.textContent = discovery.description || '';
    discoveryDesc.style.cssText = `
      color: #e0e0e0;
      font-size: 16px;
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.5;
      font-family: system-ui, sans-serif;
    `;

    var rewardText = document.createElement('div');
    rewardText.textContent = '+ ' + (discovery.sparkReward || 0) + ' Spark';
    rewardText.style.cssText = `
      color: #ffd700;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      font-family: system-ui, sans-serif;
    `;

    popup.appendChild(header);
    popup.appendChild(discoveryName);
    popup.appendChild(discoveryDesc);
    popup.appendChild(rewardText);
    document.body.appendChild(popup);

    requestAnimationFrame(function() {
      popup.classList.add('visible');
    });

    setTimeout(function() {
      popup.classList.remove('visible');
      setTimeout(function() {
        if (popup.parentNode) {
          document.body.removeChild(popup);
        }
      }, 300);
    }, 4000);

    popup.onclick = function() {
      popup.classList.remove('visible');
      setTimeout(function() {
        if (popup.parentNode) {
          document.body.removeChild(popup);
        }
      }, 300);
    };
  }

  var skillsPanel = null;

  function showSkillsPanel(skillsData) {
    if (skillsPanel) return;

    var panel = document.createElement('div');
    panel.id = 'skills-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(100, 150, 255, 0.3);
      border-radius: 12px;
      padding: 25px;
      width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 10000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.innerHTML = '<h2 style="margin: 0 0 20px 0; color: #fff; font-size: 24px;">Skills</h2>';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
    `;
    closeBtn.onclick = hideSkillsPanel;
    panel.appendChild(closeBtn);

    for (var skillName in skillsData) {
      var skill = skillsData[skillName];
      var skillDiv = document.createElement('div');
      skillDiv.style.cssText = `
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
      `;

      var skillHeader = document.createElement('div');
      skillHeader.innerHTML = `
        <span style="color: #4af; font-weight: bold; font-size: 16px;">${skillName.charAt(0).toUpperCase() + skillName.slice(1)}</span>
        <span style="color: #888; float: right;">${skill.levelName} (Level ${skill.level})</span>
      `;
      skillDiv.appendChild(skillHeader);

      var xpBar = document.createElement('div');
      xpBar.style.cssText = `
        margin-top: 8px;
        width: 100%;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      `;

      var nextLevelXP = 1000;
      var currentLevelXP = 0;
      if (typeof window !== 'undefined' && window.Mentoring && window.Mentoring.SKILLS) {
        var skillConfig = window.Mentoring.SKILLS[skillName];
        if (skillConfig && skill.level < skillConfig.xpPerLevel.length - 1) {
          nextLevelXP = skillConfig.xpPerLevel[skill.level + 1];
          currentLevelXP = skillConfig.xpPerLevel[skill.level];
        }
      }

      var xpProgress = skill.xp - currentLevelXP;
      var xpNeeded = nextLevelXP - currentLevelXP;
      var progressPercent = skill.level >= 4 ? 100 : Math.min(100, (xpProgress / xpNeeded) * 100);

      var xpFill = document.createElement('div');
      xpFill.style.cssText = `
        width: ${progressPercent}%;
        height: 100%;
        background: linear-gradient(90deg, #4af, #a8f);
        transition: width 0.3s ease;
      `;
      xpBar.appendChild(xpFill);

      var xpText = document.createElement('div');
      xpText.textContent = skill.level >= 4 ? 'MAX LEVEL' : skill.xp + ' / ' + nextLevelXP + ' XP';
      xpText.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 11px;
        font-weight: bold;
      `;
      xpBar.appendChild(xpText);

      skillDiv.appendChild(xpBar);
      panel.appendChild(skillDiv);
    }

    document.body.appendChild(panel);
    skillsPanel = panel;
  }

  function hideSkillsPanel() {
    if (!skillsPanel) return;
    document.body.removeChild(skillsPanel);
    skillsPanel = null;
  }

  var mentorOfferPanel = null;

  function showMentorOffer(offerData, acceptCallback, declineCallback) {
    if (mentorOfferPanel) return;

    var panel = document.createElement('div');
    panel.id = 'mentor-offer-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(255, 200, 100, 0.5);
      border-radius: 12px;
      padding: 25px;
      width: 400px;
      z-index: 10001;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      text-align: center;
      pointer-events: auto;
    `;

    panel.innerHTML = `
      <h3 style="color: #ffa500; margin: 0 0 15px 0;">Mentorship Offer</h3>
      <p style="color: #fff; margin-bottom: 10px;">
        <strong>${offerData.mentorId}</strong> wants to mentor you in <strong>${offerData.skill}</strong>
      </p>
      <p style="color: #888; font-size: 13px; margin-bottom: 20px;">
        Complete 5 lesson steps to gain XP and unlock advanced techniques.
      </p>
    `;

    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center;';

    var acceptBtn = document.createElement('button');
    acceptBtn.textContent = 'Accept';
    acceptBtn.style.cssText = `
      padding: 10px 24px;
      background: linear-gradient(135deg, #4af, #a8f);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    `;
    acceptBtn.onclick = function() {
      acceptCallback(offerData.id);
      document.body.removeChild(mentorOfferPanel);
      mentorOfferPanel = null;
    };

    var declineBtn = document.createElement('button');
    declineBtn.textContent = 'Decline';
    declineBtn.style.cssText = `
      padding: 10px 24px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
    `;
    declineBtn.onclick = function() {
      declineCallback(offerData.id);
      document.body.removeChild(mentorOfferPanel);
      mentorOfferPanel = null;
    };

    buttonContainer.appendChild(acceptBtn);
    buttonContainer.appendChild(declineBtn);
    panel.appendChild(buttonContainer);

    document.body.appendChild(panel);
    mentorOfferPanel = panel;
  }

  var lessonProgressPanel = null;

  function showLessonProgress(mentorshipData) {
    if (lessonProgressPanel) {
      document.body.removeChild(lessonProgressPanel);
      lessonProgressPanel = null;
    }

    var panel = document.createElement('div');
    panel.id = 'lesson-progress-panel';
    panel.style.cssText = `
      position: fixed;
      top: 120px;
      right: 20px;
      background: rgba(20, 25, 35, 0.95);
      border: 2px solid rgba(255, 200, 100, 0.5);
      border-radius: 8px;
      padding: 15px;
      width: 300px;
      z-index: 9999;
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var progress = mentorshipData.stepsCompleted / mentorshipData.totalSteps;
    var progressPercent = Math.round(progress * 100);

    panel.innerHTML = `
      <h4 style="color: #ffa500; margin: 0 0 10px 0; font-size: 14px;">Mentorship Progress</h4>
      <p style="color: #fff; font-size: 13px; margin: 5px 0;">
        <strong>${mentorshipData.skill}</strong>
      </p>
      <p style="color: #888; font-size: 12px; margin: 5px 0;">
        Steps: ${mentorshipData.stepsCompleted} / ${mentorshipData.totalSteps}
      </p>
      <div style="width: 100%; height: 16px; background: rgba(0,0,0,0.5); border-radius: 8px; overflow: hidden; margin-top: 8px;">
        <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg, #ffa500, #ffcc00);"></div>
      </div>
    `;

    document.body.appendChild(panel);
    lessonProgressPanel = panel;
  }

  var composePanel = null;
  var audioContext = null;
  var recordedNotes = [];
  var isRecording = false;
  var recordingStartTime = 0;
  var currentInstrument = 'sine';

  var noteFrequencies = {
    'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
    'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
    'C6': 1046.50
  };

  var noteOrder = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5', 'C6'];

  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContext;
  }

  function playNote(noteName, duration) {
    var ctx = initAudioContext();
    var frequency = noteFrequencies[noteName];
    if (!frequency) return;

    var oscillator = ctx.createOscillator();
    var gainNode = ctx.createGain();

    oscillator.type = currentInstrument;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + (duration || 0.5));

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + (duration || 0.5));
  }

  function playComposition(notes) {
    if (!notes || notes.length === 0) {
      showNotification('No notes to play', 'warning');
      return;
    }

    var ctx = initAudioContext();
    var currentTime = ctx.currentTime;

    notes.forEach(function(note) {
      var startTime = currentTime + (note.time / 1000);
      var frequency = noteFrequencies[note.note];
      if (!frequency) return;

      var oscillator = ctx.createOscillator();
      var gainNode = ctx.createGain();

      oscillator.type = note.instrument || 'sine';
      oscillator.frequency.setValueAtTime(frequency, startTime);

      gainNode.gain.setValueAtTime(0.3, startTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.5);

      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);

      oscillator.start(startTime);
      oscillator.stop(startTime + 0.5);
    });
  }

  function showComposePanel(composeCallback) {
    if (composePanel) return;

    var panel = document.createElement('div');
    panel.id = 'compose-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(212, 175, 55, 0.7);
      border-radius: 12px;
      padding: 25px;
      width: 800px;
      z-index: 10000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.innerHTML = '<h2 style="margin: 0 0 20px 0; color: #d4af37; font-size: 24px;">Compose Music</h2>';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(212, 175, 55, 0.2);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.5);
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    `;
    closeBtn.onclick = hideComposePanel;
    panel.appendChild(closeBtn);

    var form = document.createElement('div');

    var instrumentLabel = document.createElement('label');
    instrumentLabel.textContent = 'Instrument:';
    instrumentLabel.style.cssText = 'display: block; color: #d4af37; margin-bottom: 5px; font-size: 14px; font-weight: bold;';
    form.appendChild(instrumentLabel);

    var instrumentSelect = document.createElement('select');
    instrumentSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      margin-bottom: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    `;

    var instruments = [
      { value: 'sine', label: 'Flute (Sine)' },
      { value: 'triangle', label: 'Soft Tone (Triangle)' },
      { value: 'square', label: 'Reed (Square)' },
      { value: 'sawtooth', label: 'Strings (Sawtooth)' }
    ];

    instruments.forEach(function(inst) {
      var option = document.createElement('option');
      option.value = inst.value;
      option.textContent = inst.label;
      instrumentSelect.appendChild(option);
    });

    instrumentSelect.onchange = function() {
      currentInstrument = instrumentSelect.value;
    };
    form.appendChild(instrumentSelect);

    var keyboardContainer = document.createElement('div');
    keyboardContainer.style.cssText = `
      display: flex;
      justify-content: center;
      gap: 4px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      flex-wrap: wrap;
    `;

    noteOrder.forEach(function(noteName) {
      var key = document.createElement('button');
      var isBlackKey = noteName.includes('C') || noteName.includes('F');

      key.textContent = noteName;
      key.style.cssText = `
        padding: 40px 12px;
        background: ${isBlackKey ? 'linear-gradient(135deg, #d4af37, #f4d03f)' : 'linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(230, 230, 230, 0.9))'};
        color: ${isBlackKey ? '#000' : '#333'};
        border: 2px solid ${isBlackKey ? '#d4af37' : '#999'};
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 12px;
        min-width: 45px;
        transition: all 0.1s;
      `;

      key.onmousedown = function() {
        key.style.transform = 'scale(0.95)';
        key.style.boxShadow = '0 0 10px rgba(212, 175, 55, 0.8)';
        playNote(noteName, 0.5);

        if (isRecording) {
          var currentTime = Date.now() - recordingStartTime;
          recordedNotes.push({
            note: noteName,
            time: currentTime,
            instrument: currentInstrument
          });
          updateNoteDisplay();
        }
      };

      key.onmouseup = function() {
        key.style.transform = 'scale(1)';
        key.style.boxShadow = 'none';
      };

      key.onmouseleave = function() {
        key.style.transform = 'scale(1)';
        key.style.boxShadow = 'none';
      };

      keyboardContainer.appendChild(key);
    });

    form.appendChild(keyboardContainer);

    var controlsContainer = document.createElement('div');
    controlsContainer.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    `;

    var recordBtn = document.createElement('button');
    recordBtn.textContent = 'Record';
    recordBtn.id = 'record-btn';
    recordBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #ff4444, #cc0000);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    recordBtn.onclick = function() {
      if (!isRecording) {
        isRecording = true;
        recordedNotes = [];
        recordingStartTime = Date.now();
        recordBtn.textContent = 'Stop Recording';
        recordBtn.style.background = 'linear-gradient(135deg, #ff8844, #ff4400)';
        showNotification('Recording started...', 'info');
      } else {
        isRecording = false;
        recordBtn.textContent = 'Record';
        recordBtn.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
        showNotification('Recording stopped. ' + recordedNotes.length + ' notes captured.', 'success');
      }
    };
    controlsContainer.appendChild(recordBtn);

    var playbackBtn = document.createElement('button');
    playbackBtn.textContent = 'Playback';
    playbackBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #44ff44, #00cc00);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    playbackBtn.onclick = function() {
      if (recordedNotes.length === 0) {
        showNotification('No notes recorded yet', 'warning');
        return;
      }
      playComposition(recordedNotes);
      showNotification('Playing composition...', 'info');
    };
    controlsContainer.appendChild(playbackBtn);

    var clearBtn = document.createElement('button');
    clearBtn.textContent = 'Clear';
    clearBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #ff9944, #cc6600);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    clearBtn.onclick = function() {
      recordedNotes = [];
      isRecording = false;
      var recordButton = document.getElementById('record-btn');
      if (recordButton) {
        recordButton.textContent = 'Record';
        recordButton.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
      }
      updateNoteDisplay();
      showNotification('Composition cleared', 'info');
    };
    controlsContainer.appendChild(clearBtn);

    form.appendChild(controlsContainer);

    var noteDisplayLabel = document.createElement('label');
    noteDisplayLabel.textContent = 'Composition:';
    noteDisplayLabel.style.cssText = 'display: block; color: #d4af37; margin-bottom: 5px; font-size: 14px; font-weight: bold;';
    form.appendChild(noteDisplayLabel);

    var noteDisplay = document.createElement('div');
    noteDisplay.id = 'note-display';
    noteDisplay.style.cssText = `
      width: 100%;
      min-height: 60px;
      padding: 15px;
      margin-bottom: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 6px;
      font-size: 14px;
      font-family: monospace;
      overflow-x: auto;
      white-space: nowrap;
    `;
    noteDisplay.textContent = 'No notes recorded yet...';
    form.appendChild(noteDisplay);

    function updateNoteDisplay() {
      var display = document.getElementById('note-display');
      if (!display) return;

      if (recordedNotes.length === 0) {
        display.textContent = 'No notes recorded yet...';
        return;
      }

      var noteSequence = recordedNotes.map(function(n) {
        return n.note;
      }).join(' - ');

      display.textContent = noteSequence + ' (' + recordedNotes.length + ' notes)';
    }

    var saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save Composition';
    saveBtn.style.cssText = `
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #d4af37, #f4d03f);
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    `;
    saveBtn.onclick = function() {
      if (recordedNotes.length === 0) {
        showNotification('Please record some notes first', 'warning');
        return;
      }

      if (isRecording) {
        showNotification('Please stop recording first', 'warning');
        return;
      }

      var composition = {
        notes: recordedNotes,
        instrument: currentInstrument,
        timestamp: Date.now()
      };

      if (composeCallback) {
        composeCallback(composition);
      }

      showNotification('Composition saved!', 'success');
      hideComposePanel();
    };
    form.appendChild(saveBtn);

    panel.appendChild(form);
    document.body.appendChild(panel);
    composePanel = panel;

    recordedNotes = [];
    isRecording = false;
    currentInstrument = 'sine';
  }

  function hideComposePanel() {
    if (!composePanel) return;
    document.body.removeChild(composePanel);
    composePanel = null;
    recordedNotes = [];
    isRecording = false;
  }

  var guildPanel = null;
  var guildCreatePanel = null;
  var guildInvitePanel = null;

  function showGuildPanel(guildData, playerData) {
    if (guildPanel) {
      hideGuildPanel();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'guild-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 700px;
      max-height: 80vh;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      overflow-y: auto;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideGuildPanel;
    panel.appendChild(closeBtn);

    var header = document.createElement('div');
    header.style.cssText = `
      margin-bottom: 25px;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;

    var title = document.createElement('h2');
    title.textContent = '[' + guildData.tag + '] ' + guildData.name;
    title.style.cssText = `
      color: #DAA520;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      margin: 0 0 8px 0;
      font-weight: bold;
    `;
    header.appendChild(title);

    var subtitle = document.createElement('div');
    subtitle.textContent = guildData.type.charAt(0).toUpperCase() + guildData.type.slice(1) +
                          ' â€¢ Level ' + guildData.level + ' â€¢ ' + guildData.members.length + '/' +
                          guildData.maxMembers + ' members';
    subtitle.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    header.appendChild(subtitle);

    if (guildData.description) {
      var desc = document.createElement('div');
      desc.textContent = guildData.description;
      desc.style.cssText = `
        color: #D4C5B3;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        margin-top: 12px;
        font-style: italic;
      `;
      header.appendChild(desc);
    }

    panel.appendChild(header);

    var statsGrid = document.createElement('div');
    statsGrid.style.cssText = `
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 25px;
    `;

    var stats = [
      { label: 'Treasury', value: guildData.treasury + ' Spark' },
      { label: 'Guild XP', value: guildData.xp },
      { label: 'Home Zone', value: guildData.zone }
    ];

    stats.forEach(function(stat) {
      var statBox = document.createElement('div');
      statBox.style.cssText = `
        background: rgba(218, 165, 32, 0.1);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 12px;
        text-align: center;
      `;

      var statLabel = document.createElement('div');
      statLabel.textContent = stat.label;
      statLabel.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
        margin-bottom: 5px;
      `;
      statBox.appendChild(statLabel);

      var statValue = document.createElement('div');
      statValue.textContent = stat.value;
      statValue.style.cssText = `
        color: #DAA520;
        font-size: 18px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
      `;
      statBox.appendChild(statValue);

      statsGrid.appendChild(statBox);
    });

    panel.appendChild(statsGrid);

    var membersSection = document.createElement('div');
    membersSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var membersTitle = document.createElement('h3');
    membersTitle.textContent = 'Members';
    membersTitle.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    membersSection.appendChild(membersTitle);

    var membersList = document.createElement('div');
    membersList.style.cssText = `
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 10px;
    `;

    guildData.members.forEach(function(member) {
      var memberItem = document.createElement('div');
      memberItem.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        margin-bottom: 5px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
      `;

      var memberInfo = document.createElement('div');
      memberInfo.style.cssText = `
        color: #E8E0D8;
        font-size: 14px;
        font-family: system-ui, sans-serif;
      `;
      memberInfo.textContent = member.playerId + (member.playerId === playerData.id ? ' (You)' : '');
      memberItem.appendChild(memberInfo);

      var roleTag = document.createElement('span');
      roleTag.textContent = member.role.toUpperCase();
      roleTag.style.cssText = `
        color: ${member.role === 'leader' ? '#FFD700' : member.role === 'officer' ? '#C0C0C0' : '#8B7355'};
        font-size: 11px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        padding: 3px 8px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 3px;
      `;
      memberItem.appendChild(roleTag);

      membersList.appendChild(memberItem);
    });

    membersSection.appendChild(membersList);
    panel.appendChild(membersSection);

    var activitiesSection = document.createElement('div');
    activitiesSection.style.cssText = `
      margin-bottom: 15px;
    `;

    var activitiesTitle = document.createElement('h3');
    activitiesTitle.textContent = 'Recent Activity';
    activitiesTitle.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    activitiesSection.appendChild(activitiesTitle);

    var activitiesList = document.createElement('div');
    activitiesList.style.cssText = `
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 10px;
    `;

    var activities = guildData.activities.slice(-10).reverse();
    activities.forEach(function(activity) {
      var activityItem = document.createElement('div');
      activityItem.textContent = 'â€¢ ' + activity.text;
      activityItem.style.cssText = `
        color: #A0978E;
        font-size: 13px;
        font-family: system-ui, sans-serif;
        padding: 4px 0;
        line-height: 1.4;
      `;
      activitiesList.appendChild(activityItem);
    });

    if (activities.length === 0) {
      var noActivity = document.createElement('div');
      noActivity.textContent = 'No recent activity';
      noActivity.style.cssText = `
        color: #6B6B6B;
        font-size: 13px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 20px;
      `;
      activitiesList.appendChild(noActivity);
    }

    activitiesSection.appendChild(activitiesList);
    panel.appendChild(activitiesSection);

    var actionsDiv = document.createElement('div');
    actionsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-top: 20px;
    `;

    var leaveBtn = document.createElement('button');
    leaveBtn.textContent = 'Leave Guild';
    leaveBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: rgba(139, 0, 0, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(255, 69, 0, 0.5);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    leaveBtn.onmouseover = function() {
      this.style.background = 'rgba(139, 0, 0, 0.8)';
      this.style.borderColor = '#FF4500';
    };
    leaveBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 0, 0, 0.6)';
      this.style.borderColor = 'rgba(255, 69, 0, 0.5)';
    };
    leaveBtn.onclick = function() {
      if (confirm('Are you sure you want to leave the guild?')) {
        if (window.handleGuildAction) {
          window.handleGuildAction('leave', guildData.id);
        }
        hideGuildPanel();
      }
    };
    actionsDiv.appendChild(leaveBtn);

    panel.appendChild(actionsDiv);

    document.body.appendChild(panel);
    guildPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });
  }

  function hideGuildPanel() {
    if (!guildPanel) return;
    guildPanel.classList.remove('visible');
    setTimeout(function() {
      if (guildPanel && guildPanel.parentNode) {
        document.body.removeChild(guildPanel);
        guildPanel = null;
      }
    }, 250);
  }

  function showGuildCreate(callback) {
    if (guildCreatePanel) {
      hideGuildCreate();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'guild-create-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideGuildCreate;
    panel.appendChild(closeBtn);

    var title = document.createElement('h2');
    title.textContent = 'Create Guild';
    title.style.cssText = `
      color: #DAA520;
      font-size: 24px;
      font-family: system-ui, sans-serif;
      margin: 0 0 20px 0;
      font-weight: bold;
    `;
    panel.appendChild(title);

    var form = document.createElement('div');
    form.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 15px;
    `;

    var nameLabel = document.createElement('label');
    nameLabel.textContent = 'Guild Name';
    nameLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(nameLabel);

    var nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Enter guild name';
    nameInput.maxLength = 30;
    nameInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    form.appendChild(nameInput);

    var tagLabel = document.createElement('label');
    tagLabel.textContent = 'Guild Tag (3-5 characters)';
    tagLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(tagLabel);

    var tagInput = document.createElement('input');
    tagInput.type = 'text';
    tagInput.placeholder = 'e.g., ZON';
    tagInput.maxLength = 5;
    tagInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      text-transform: uppercase;
    `;
    form.appendChild(tagInput);

    var typeLabel = document.createElement('label');
    typeLabel.textContent = 'Type';
    typeLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(typeLabel);

    var typeSelect = document.createElement('select');
    typeSelect.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;

    ['guild', 'garden', 'studio', 'community'].forEach(function(type) {
      var option = document.createElement('option');
      option.value = type;
      option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
      typeSelect.appendChild(option);
    });

    form.appendChild(typeSelect);

    var descLabel = document.createElement('label');
    descLabel.textContent = 'Description (optional)';
    descLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(descLabel);

    var descInput = document.createElement('textarea');
    descInput.placeholder = 'Describe your guild...';
    descInput.maxLength = 200;
    descInput.rows = 3;
    descInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      resize: vertical;
    `;
    form.appendChild(descInput);

    var costNotice = document.createElement('div');
    costNotice.textContent = 'Cost: 100 Spark';
    costNotice.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      background: rgba(218, 165, 32, 0.1);
      border-radius: 6px;
    `;
    form.appendChild(costNotice);

    var createBtn = document.createElement('button');
    createBtn.textContent = 'Create Guild';
    createBtn.style.cssText = `
      padding: 12px;
      background: rgba(218, 165, 32, 0.3);
      color: #E8E0D8;
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 6px;
      font-size: 16px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    createBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.5)';
      this.style.borderColor = '#DAA520';
    };
    createBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = 'rgba(218, 165, 32, 0.5)';
    };
    createBtn.onclick = function() {
      var name = nameInput.value.trim();
      var tag = tagInput.value.trim().toUpperCase();
      var type = typeSelect.value;
      var description = descInput.value.trim();

      if (!name || !tag) {
        alert('Please enter guild name and tag');
        return;
      }

      if (tag.length < 3 || tag.length > 5) {
        alert('Tag must be 3-5 characters');
        return;
      }

      if (callback) {
        callback({ name: name, tag: tag, type: type, description: description });
      }

      hideGuildCreate();
    };
    form.appendChild(createBtn);

    panel.appendChild(form);

    document.body.appendChild(panel);
    guildCreatePanel = panel;
  }

  function hideGuildCreate() {
    if (!guildCreatePanel) return;
    document.body.removeChild(guildCreatePanel);
    guildCreatePanel = null;
  }

  function showGuildInvite(inviteData, callback) {
    if (guildInvitePanel) return;

    var panel = document.createElement('div');
    panel.id = 'guild-invite-panel';
    panel.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      width: 350px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 400;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 20px;
    `;

    var title = document.createElement('h3');
    title.textContent = 'Guild Invitation';
    title.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    panel.appendChild(title);

    var message = document.createElement('div');
    message.textContent = 'You have been invited to join [' + inviteData.guildTag + '] ' + inviteData.guildName;
    message.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
      line-height: 1.5;
    `;
    panel.appendChild(message);

    var buttonsDiv = document.createElement('div');
    buttonsDiv.style.cssText = `
      display: flex;
      gap: 10px;
    `;

    var acceptBtn = document.createElement('button');
    acceptBtn.textContent = 'Accept';
    acceptBtn.style.cssText = `
      flex: 1;
      padding: 10px;
      background: rgba(34, 139, 34, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(34, 139, 34, 0.8);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    acceptBtn.onmouseover = function() {
      this.style.background = 'rgba(34, 139, 34, 0.8)';
    };
    acceptBtn.onmouseout = function() {
      this.style.background = 'rgba(34, 139, 34, 0.6)';
    };
    acceptBtn.onclick = function() {
      if (callback) {
        callback('accept', inviteData);
      }
      document.body.removeChild(panel);
      guildInvitePanel = null;
    };
    buttonsDiv.appendChild(acceptBtn);

    var declineBtn = document.createElement('button');
    declineBtn.textContent = 'Decline';
    declineBtn.style.cssText = `
      flex: 1;
      padding: 10px;
      background: rgba(139, 0, 0, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(255, 69, 0, 0.5);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    declineBtn.onmouseover = function() {
      this.style.background = 'rgba(139, 0, 0, 0.8)';
    };
    declineBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 0, 0, 0.6)';
    };
    declineBtn.onclick = function() {
      if (callback) {
        callback('decline', inviteData);
      }
      document.body.removeChild(panel);
      guildInvitePanel = null;
    };
    buttonsDiv.appendChild(declineBtn);

    panel.appendChild(buttonsDiv);

    document.body.appendChild(panel);
    guildInvitePanel = panel;
  }

  function updateGuildTag(tag) {
    var playerNameEl = document.getElementById('player-name');
    if (playerNameEl && tag) {
      var currentName = playerNameEl.textContent;
      currentName = currentName.replace(/\[.*?\]\s*/, '');
      playerNameEl.textContent = '[' + tag + '] ' + currentName;
    }
  }

  var governancePanel = null;
  var governanceVisible = false;
  var governanceCallback = null;

  function initGovernancePanel(callback) {
    if (typeof document === 'undefined') return;
    governanceCallback = callback;
  }

  function showGovernancePanel(zoneId, playerData) {
    if (typeof document === 'undefined') return;

    var Social = typeof window !== 'undefined' ? window.Social : null;
    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    if (!Social || !Zones) return;

    hideGovernancePanel();

    governancePanel = document.createElement('div');
    governancePanel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #daa520;border-radius:12px;' +
      'padding:20px;width:700px;max-height:80vh;overflow-y:auto;z-index:300;' +
      'box-shadow:0 4px 30px rgba(218,165,32,0.3);pointer-events:auto;';

    var zone = Zones.getZone(zoneId);
    var stewards = Zones.getZoneStewards(zoneId);
    var policies = Zones.getZonePolicies(zoneId);
    var activeElection = Zones.getActiveElection(zoneId);
    var reputation = Social.getReputation(playerData.id);
    var isRegular = Zones.isZoneRegular(zoneId, playerData.id);
    var isSteward = Zones.isZoneSteward(zoneId, playerData.id);

    var html = '<div style="font-size:24px;font-weight:bold;margin-bottom:10px;text-align:center;color:#daa520;">' +
      zone.name + ' Governance</div>';

    html += '<div style="margin-bottom:15px;color:#b0e0e6;text-align:center;font-size:12px;">' +
      'Your Reputation: ' + reputation.tier + ' (' + reputation.score + ' points)</div>';

    html += '<div style="margin-bottom:20px;">';
    html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#4af;border-bottom:1px solid #4af;padding-bottom:4px;">Current Stewards</div>';
    if (stewards.length > 0) {
      html += '<div style="display:flex;flex-direction:column;gap:8px;">';
      stewards.forEach(function(s) {
        var daysLeft = Math.ceil((s.termEnd - Date.now()) / 86400000);
        html += '<div style="background:rgba(74,170,255,0.1);padding:10px;border-radius:6px;border-left:3px solid #4af;">' +
          '<div style="font-weight:bold;">' + s.playerId + '</div>' +
          '<div style="font-size:11px;color:#aaa;">' + s.votes + ' votes â€¢ ' + daysLeft + ' days remaining</div>' +
          '</div>';
      });
      html += '</div>';
    } else {
      html += '<div style="color:#888;font-style:italic;padding:10px;">No active stewards. Start an election!</div>';
    }
    html += '</div>';

    if (isSteward) {
      html += '<div style="margin-bottom:20px;">';
      html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#fa4;border-bottom:1px solid #fa4;padding-bottom:4px;">Zone Policies (Steward)</div>';
      html += '<div style="background:rgba(255,170,68,0.1);padding:12px;border-radius:6px;">';
      html += '<label style="display:block;margin-bottom:8px;cursor:pointer;">' +
        '<input type="checkbox" id="policy-building" ' + (policies.buildingRequiresApproval ? 'checked' : '') + '> Building requires approval</label>';
      html += '<label style="display:block;margin-bottom:8px;cursor:pointer;">' +
        '<input type="checkbox" id="policy-moderated" ' + (policies.chatModerated ? 'checked' : '') + '> Chat moderated</label>';
      html += '<div style="margin-top:10px;"><input type="text" id="welcome-message" placeholder="Zone welcome message..." ' +
        'value="' + (policies.welcomeMessage || '').replace(/"/g, '&quot;') + '" style="width:100%;padding:8px;background:rgba(0,0,0,0.3);' +
        'border:1px solid #666;border-radius:4px;color:#fff;"></div>';
      html += '<button id="save-policies-btn" style="margin-top:10px;padding:8px 16px;background:#fa4;border:none;' +
        'border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Save Policies</button>';
      html += '</div>';
      html += '</div>';
    } else if (policies.welcomeMessage) {
      html += '<div style="margin-bottom:20px;padding:12px;background:rgba(218,165,32,0.1);border-radius:6px;border-left:3px solid #daa520;">';
      html += '<div style="font-size:14px;font-weight:bold;color:#daa520;margin-bottom:4px;">Welcome Message</div>';
      html += '<div style="font-size:12px;color:#ccc;">' + policies.welcomeMessage + '</div>';
      html += '</div>';
    }

    html += '<div style="margin-bottom:20px;">';
    html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#4af;border-bottom:1px solid #4af;padding-bottom:4px;">Elections</div>';
    if (activeElection) {
      var timeLeft = Math.ceil((activeElection.endTime - Date.now()) / 3600000);
      html += '<div style="background:rgba(74,170,255,0.1);padding:12px;border-radius:6px;margin-bottom:10px;">';
      html += '<div style="font-weight:bold;margin-bottom:8px;">Active Election (' + timeLeft + ' hours left)</div>';
      html += '<div style="display:flex;flex-direction:column;gap:6px;">';
      activeElection.candidates.forEach(function(c) {
        var hasVoted = isRegular && c.voters && c.voters.has(playerData.id);
        html += '<div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:4px;display:flex;justify-content:space-between;align-items:center;">' +
          '<span>' + c.playerId + '</span>' +
          '<span style="color:#4af;font-weight:bold;">' + c.votes + ' votes</span>' +
          (isRegular && !hasVoted ? '<button class="vote-btn" data-candidate="' + c.playerId + '" data-election="' + activeElection.id + '" ' +
          'style="padding:4px 12px;background:#4af;border:none;border-radius:4px;color:#000;cursor:pointer;font-size:11px;">Vote</button>' : '') +
          (hasVoted ? '<span style="color:#4a4;font-size:11px;">Voted</span>' : '') +
          '</div>';
      });
      html += '</div></div>';

      if (isRegular) {
        html += '<div style="font-size:11px;color:#aaa;margin-top:8px;">You can vote as a zone regular.</div>';
      } else {
        html += '<div style="font-size:11px;color:#888;margin-top:8px;">Visit this zone 5+ times to vote in elections.</div>';
      }
    } else {
      var canRunForSteward = reputation.tier === 'Respected' || reputation.tier === 'Honored' || reputation.tier === 'Elder';
      html += '<div style="color:#888;font-style:italic;margin-bottom:10px;">No active election.</div>';
      if (canRunForSteward) {
        html += '<button id="start-election-btn" style="padding:8px 16px;background:#4af;border:none;' +
          'border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Start Election</button>';
      } else {
        html += '<div style="font-size:11px;color:#888;">Reach Respected tier to run for steward.</div>';
      }
    }
    html += '</div>';

    var log = Zones.getGovernanceLog(zoneId, 10);
    if (log.length > 0) {
      html += '<div style="margin-bottom:20px;">';
      html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#888;border-bottom:1px solid #666;padding-bottom:4px;">Recent Actions</div>';
      html += '<div style="display:flex;flex-direction:column;gap:4px;max-height:150px;overflow-y:auto;">';
      log.forEach(function(action) {
        var timeAgo = Math.floor((Date.now() - action.timestamp) / 60000);
        html += '<div style="font-size:11px;color:#aaa;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.05);">' +
          '<span style="color:#4af;">' + action.type + '</span> by ' + (action.stewardId || action.from || 'system') + ' â€” ' + timeAgo + 'm ago</div>';
      });
      html += '</div></div>';
    }

    html += '<div style="text-align:center;margin-top:20px;">' +
      '<button id="close-governance-btn" style="padding:10px 24px;background:#666;border:none;' +
      'border-radius:6px;color:#fff;font-weight:bold;cursor:pointer;">Close (H)</button></div>';

    governancePanel.innerHTML = html;
    governancePanel.className = 'governance-panel';
    document.body.appendChild(governancePanel);
    governanceVisible = true;
    requestAnimationFrame(function() {
      governancePanel.classList.add('visible');
    });

    var closeBtn = document.getElementById('close-governance-btn');
    if (closeBtn) {
      closeBtn.onclick = hideGovernancePanel;
    }

    var startElectionBtn = document.getElementById('start-election-btn');
    if (startElectionBtn) {
      startElectionBtn.onclick = function() {
        if (governanceCallback) {
          governanceCallback('startElection', { zoneId: zoneId });
        }
      };
    }

    var savePoliciesBtn = document.getElementById('save-policies-btn');
    if (savePoliciesBtn) {
      savePoliciesBtn.onclick = function() {
        var buildingApproval = document.getElementById('policy-building').checked;
        var chatModerated = document.getElementById('policy-moderated').checked;
        var welcomeMsg = document.getElementById('welcome-message').value;

        if (governanceCallback) {
          governanceCallback('savePolicies', {
            zoneId: zoneId,
            buildingRequiresApproval: buildingApproval,
            chatModerated: chatModerated,
            welcomeMessage: welcomeMsg
          });
        }
      };
    }

    var voteButtons = document.querySelectorAll('.vote-btn');
    voteButtons.forEach(function(btn) {
      btn.onclick = function() {
        var candidateId = btn.getAttribute('data-candidate');
        var electionId = btn.getAttribute('data-election');
        if (governanceCallback) {
          governanceCallback('vote', {
            electionId: electionId,
            candidateId: candidateId
          });
        }
      };
    });
  }

  function hideGovernancePanel() {
    if (governancePanel) {
      governancePanel.classList.remove('visible');
      setTimeout(function() {
        if (governancePanel && governancePanel.parentNode) {
          document.body.removeChild(governancePanel);
          governancePanel = null;
        }
      }, 250);
    }
    governanceVisible = false;
  }

  function toggleGovernancePanel(zoneId, playerData) {
    if (governanceVisible) {
      hideGovernancePanel();
    } else {
      showGovernancePanel(zoneId, playerData);
    }
  }

  var auctionHousePanel = null;
  var auctionHouseVisible = false;
  var auctionHouseCallback = null;
  var currentAuctionTab = 'browse';

  function initAuctionHousePanel(callback) {
    auctionHouseCallback = callback;
  }

  function showAuctionHousePanel(ledger, playerId, inventory) {
    if (typeof document === 'undefined') return;

    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Economy || !Inventory) return;

    hideAuctionHousePanel();

    auctionHousePanel = document.createElement('div');
    auctionHousePanel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 800px;
      max-height: 80vh;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      overflow-y: auto;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideAuctionHousePanel;
    auctionHousePanel.appendChild(closeBtn);

    var header = document.createElement('div');
    header.style.cssText = `
      margin-bottom: 20px;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;

    var title = document.createElement('h2');
    title.textContent = 'Auction House';
    title.style.cssText = `
      color: #DAA520;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      margin: 0 0 8px 0;
      font-weight: bold;
    `;
    header.appendChild(title);

    var subtitle = document.createElement('div');
    var playerBalance = Economy.getBalance(ledger, playerId);
    subtitle.textContent = 'Your Spark: ' + playerBalance;
    subtitle.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    header.appendChild(subtitle);

    auctionHousePanel.appendChild(header);

    var tabsDiv = document.createElement('div');
    tabsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    `;

    var tabs = ['browse', 'myauctions', 'create'];
    var tabLabels = { browse: 'Browse Auctions', myauctions: 'My Auctions', create: 'Create Auction' };

    tabs.forEach(function(tabName) {
      var tabBtn = document.createElement('button');
      tabBtn.textContent = tabLabels[tabName];
      tabBtn.setAttribute('data-tab', tabName);
      tabBtn.style.cssText = `
        flex: 1;
        padding: 12px;
        background: ${currentAuctionTab === tabName ? 'rgba(218, 165, 32, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
        color: ${currentAuctionTab === tabName ? '#DAA520' : '#A0978E'};
        border: 2px solid ${currentAuctionTab === tabName ? '#DAA520' : 'rgba(255, 255, 255, 0.3)'};
        border-radius: 6px;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
      `;
      tabBtn.onmouseover = function() {
        if (currentAuctionTab !== tabName) {
          this.style.background = 'rgba(218, 165, 32, 0.2)';
          this.style.borderColor = 'rgba(218, 165, 32, 0.5)';
        }
      };
      tabBtn.onmouseout = function() {
        if (currentAuctionTab !== tabName) {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
          this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
      };
      tabBtn.onclick = function() {
        currentAuctionTab = tabName;
        showAuctionHousePanel(ledger, playerId, inventory);
      };
      tabsDiv.appendChild(tabBtn);
    });

    auctionHousePanel.appendChild(tabsDiv);

    var contentDiv = document.createElement('div');
    contentDiv.id = 'auction-content';
    contentDiv.style.cssText = `
      min-height: 300px;
    `;

    if (currentAuctionTab === 'browse') {
      renderBrowseTab(contentDiv, ledger, playerId);
    } else if (currentAuctionTab === 'myauctions') {
      renderMyAuctionsTab(contentDiv, ledger, playerId);
    } else if (currentAuctionTab === 'create') {
      renderCreateTab(contentDiv, ledger, playerId, inventory);
    }

    auctionHousePanel.appendChild(contentDiv);
    auctionHousePanel.className = 'auction-panel';
    document.body.appendChild(auctionHousePanel);
    auctionHouseVisible = true;
    requestAnimationFrame(function() {
      auctionHousePanel.classList.add('visible');
    });
  }

  function renderBrowseTab(container, ledger, playerId) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    if (!Economy) return;

    var auctions = Economy.getActiveAuctions(ledger);

    if (auctions.length === 0) {
      var noAuctions = document.createElement('div');
      noAuctions.textContent = 'No active auctions at the moment.';
      noAuctions.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noAuctions);
      return;
    }

    auctions.forEach(function(auction) {
      var auctionItem = document.createElement('div');
      auctionItem.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;

      var itemInfo = document.createElement('div');
      itemInfo.style.cssText = `
        flex: 1;
      `;

      var itemName = document.createElement('div');
      var itemData = auction.item;
      var itemDisplayName = typeof itemData === 'string' ? itemData : (itemData.name || itemData.id || 'Unknown Item');
      itemName.textContent = itemDisplayName;
      itemName.style.cssText = `
        color: #E8E0D8;
        font-size: 16px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        margin-bottom: 5px;
      `;
      itemInfo.appendChild(itemName);

      var auctionDetails = document.createElement('div');
      var currentBidText = auction.currentBid > 0 ? auction.currentBid + ' Spark' : 'Starting: ' + auction.startingBid + ' Spark';
      var timeRemaining = Math.ceil((auction.endTime - Date.now()) / 60000);
      var timeText = timeRemaining > 60 ? Math.floor(timeRemaining / 60) + 'h ' + (timeRemaining % 60) + 'm' : timeRemaining + 'm';

      auctionDetails.textContent = 'Current Bid: ' + currentBidText + ' | Time: ' + timeText + ' | Seller: ' + auction.seller;
      auctionDetails.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
      `;
      itemInfo.appendChild(auctionDetails);

      auctionItem.appendChild(itemInfo);

      if (auction.seller !== playerId) {
        var bidBtn = document.createElement('button');
        bidBtn.textContent = 'Bid';
        bidBtn.style.cssText = `
          padding: 8px 20px;
          background: rgba(218, 165, 32, 0.6);
          color: #000;
          border: 2px solid #DAA520;
          border-radius: 6px;
          font-size: 14px;
          font-family: system-ui, sans-serif;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.3s ease;
        `;
        bidBtn.onmouseover = function() {
          this.style.background = 'rgba(218, 165, 32, 0.8)';
        };
        bidBtn.onmouseout = function() {
          this.style.background = 'rgba(218, 165, 32, 0.6)';
        };
        bidBtn.onclick = function() {
          var minBid = Math.max(auction.startingBid, auction.currentBid + 1);
          var bidAmount = prompt('Enter your bid (minimum ' + minBid + ' Spark):');
          if (bidAmount) {
            var amount = parseInt(bidAmount, 10);
            if (!isNaN(amount) && amount >= minBid) {
              if (auctionHouseCallback) {
                auctionHouseCallback('placeBid', { auctionId: auction.id, amount: amount });
              }
            } else {
              alert('Invalid bid amount. Must be at least ' + minBid + ' Spark.');
            }
          }
        };
        auctionItem.appendChild(bidBtn);
      } else {
        var ownLabel = document.createElement('span');
        ownLabel.textContent = 'Your Auction';
        ownLabel.style.cssText = `
          color: #4a4;
          font-size: 12px;
          font-family: system-ui, sans-serif;
          font-style: italic;
        `;
        auctionItem.appendChild(ownLabel);
      }

      container.appendChild(auctionItem);
    });
  }

  function renderMyAuctionsTab(container, ledger, playerId) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    if (!Economy) return;

    var allAuctions = ledger.auctions || [];
    var myAuctions = allAuctions.filter(function(a) { return a.seller === playerId; });

    if (myAuctions.length === 0) {
      var noAuctions = document.createElement('div');
      noAuctions.textContent = 'You have not created any auctions yet.';
      noAuctions.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noAuctions);
      return;
    }

    myAuctions.forEach(function(auction) {
      var auctionItem = document.createElement('div');
      auctionItem.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
      `;

      var itemData = auction.item;
      var itemDisplayName = typeof itemData === 'string' ? itemData : (itemData.name || itemData.id || 'Unknown Item');

      var itemName = document.createElement('div');
      itemName.textContent = itemDisplayName;
      itemName.style.cssText = `
        color: #E8E0D8;
        font-size: 16px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        margin-bottom: 5px;
      `;
      auctionItem.appendChild(itemName);

      var statusText = 'Status: ' + auction.status.toUpperCase();
      if (auction.status === 'active') {
        var timeRemaining = Math.ceil((auction.endTime - Date.now()) / 60000);
        var timeText = timeRemaining > 60 ? Math.floor(timeRemaining / 60) + 'h ' + (timeRemaining % 60) + 'm' : timeRemaining + 'm';
        statusText += ' | Time Left: ' + timeText;
        statusText += ' | Current Bid: ' + (auction.currentBid > 0 ? auction.currentBid + ' Spark' : 'No bids yet');
      } else if (auction.status === 'sold') {
        statusText += ' | Sold for: ' + auction.currentBid + ' Spark to ' + auction.currentBidder;
      } else if (auction.status === 'expired') {
        statusText += ' | No bids received';
      }

      var statusDiv = document.createElement('div');
      statusDiv.textContent = statusText;
      statusDiv.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
      `;
      auctionItem.appendChild(statusDiv);

      container.appendChild(auctionItem);
    });
  }

  function renderCreateTab(container, ledger, playerId, inventory) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Economy || !Inventory) return;

    var formDiv = document.createElement('div');
    formDiv.style.cssText = `
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 20px;
    `;

    var itemLabel = document.createElement('div');
    itemLabel.textContent = 'Select Item to Auction:';
    itemLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(itemLabel);

    var itemSelect = document.createElement('select');
    itemSelect.id = 'auction-item-select';
    itemSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;

    var items = Inventory.getInventory(inventory);
    var hasItems = false;

    items.forEach(function(item) {
      if (item && item.count > 0) {
        hasItems = true;
        var option = document.createElement('option');
        option.value = item.id;
        option.textContent = item.name + ' (x' + item.count + ')';
        itemSelect.appendChild(option);
      }
    });

    if (!hasItems) {
      var noItems = document.createElement('div');
      noItems.textContent = 'You have no items to auction.';
      noItems.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noItems);
      return;
    }

    formDiv.appendChild(itemSelect);

    var bidLabel = document.createElement('div');
    bidLabel.textContent = 'Starting Bid (Spark):';
    bidLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(bidLabel);

    var bidInput = document.createElement('input');
    bidInput.id = 'auction-starting-bid';
    bidInput.type = 'number';
    bidInput.min = '1';
    bidInput.value = '10';
    bidInput.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;
    formDiv.appendChild(bidInput);

    var durationLabel = document.createElement('div');
    durationLabel.textContent = 'Auction Duration:';
    durationLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(durationLabel);

    var durationSelect = document.createElement('select');
    durationSelect.id = 'auction-duration';
    durationSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;

    var durations = [
      { label: '1 Hour', value: 3600000 },
      { label: '6 Hours', value: 21600000 },
      { label: '24 Hours', value: 86400000 }
    ];

    durations.forEach(function(dur) {
      var option = document.createElement('option');
      option.value = dur.value;
      option.textContent = dur.label;
      durationSelect.appendChild(option);
    });

    formDiv.appendChild(durationSelect);

    var createBtn = document.createElement('button');
    createBtn.textContent = 'Create Auction';
    createBtn.style.cssText = `
      width: 100%;
      padding: 12px;
      background: rgba(218, 165, 32, 0.6);
      color: #000;
      border: 2px solid #DAA520;
      border-radius: 6px;
      font-size: 16px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    createBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.8)';
    };
    createBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.6)';
    };
    createBtn.onclick = function() {
      var itemId = itemSelect.value;
      var startingBid = parseInt(bidInput.value, 10);
      var duration = parseInt(durationSelect.value, 10);

      if (!itemId || isNaN(startingBid) || startingBid < 1) {
        alert('Please select an item and set a valid starting bid.');
        return;
      }

      if (auctionHouseCallback) {
        auctionHouseCallback('createAuction', { itemId: itemId, startingBid: startingBid, duration: duration });
      }
    };
    formDiv.appendChild(createBtn);

    container.appendChild(formDiv);
  }

  function hideAuctionHousePanel() {
    if (auctionHousePanel) {
      auctionHousePanel.classList.remove('visible');
      setTimeout(function() {
        if (auctionHousePanel && auctionHousePanel.parentNode) {
          document.body.removeChild(auctionHousePanel);
          auctionHousePanel = null;
        }
      }, 250);
    }
    auctionHouseVisible = false;
  }

  function toggleAuctionHousePanel(ledger, playerId, inventory) {
    if (auctionHouseVisible) {
      hideAuctionHousePanel();
    } else {
      showAuctionHousePanel(ledger, playerId, inventory);
    }
  }

  function updateReputationDisplay(reputation) {
    if (typeof document === 'undefined') return;
    var playerInfo = document.getElementById('player-info');
    if (!playerInfo) return;

    var repEl = document.getElementById('reputation-display');
    if (!repEl) {
      repEl = document.createElement('div');
      repEl.id = 'reputation-display';
      repEl.style.cssText = 'font-size:11px;color:#daa520;margin-top:2px;';
      playerInfo.appendChild(repEl);
    }

    var tierColors = {
      'Newcomer': '#888',
      'Trusted': '#4af',
      'Respected': '#4a4',
      'Honored': '#f4a',
      'Elder': '#daa520'
    };

    var color = tierColors[reputation.tier] || '#888';
    repEl.innerHTML = '<span style="color:' + color + ';">â˜…</span> ' + reputation.tier + ' (' + reputation.score + ')';
  }

  var achievementPanel = null;

  function showAchievementPanel(playerId) {
    if (typeof document === 'undefined') return;

    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    if (!Quests) {
      console.warn('Quests module not available');
      return;
    }

    if (achievementPanel) {
      hideAchievementPanel();
      return;
    }

    var achievements = Quests.getAchievements(playerId);
    var progress = Quests.getAchievementProgress(playerId);

    var panel = document.createElement('div');
    panel.className = 'achievement-panel';

    var header = document.createElement('h2');
    header.textContent = 'Achievements';
    panel.appendChild(header);

    var progressText = document.createElement('div');
    progressText.style.cssText = 'color:#E8E0D8;font-size:0.9rem;margin-bottom:4px;';
    progressText.textContent = 'Progress: ' + progress.unlocked + ' / ' + progress.total + ' (' + progress.percentage.toFixed(1) + '%)';
    panel.appendChild(progressText);

    var progressBarContainer = document.createElement('div');
    progressBarContainer.className = 'achievement-progress-bar';
    var progressBarFill = document.createElement('div');
    progressBarFill.className = 'achievement-progress-fill';
    progressBarFill.style.width = progress.percentage + '%';
    progressBarContainer.appendChild(progressBarFill);
    panel.appendChild(progressBarContainer);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:15px;right:15px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;font-size:20px;cursor:pointer;transition:all 0.2s;';
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218,165,32,0.3)';
      this.style.borderColor = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255,255,255,0.1)';
      this.style.borderColor = 'rgba(255,255,255,0.3)';
    };
    closeBtn.onclick = hideAchievementPanel;
    panel.appendChild(closeBtn);

    var categories = {
      exploration: [],
      social: [],
      crafting: [],
      building: [],
      gardening: [],
      economy: [],
      competition: [],
      quests: [],
      guild: [],
      art: [],
      physical: [],
      mentoring: []
    };

    achievements.forEach(function(ach) {
      if (categories[ach.category]) {
        categories[ach.category].push(ach);
      }
    });

    var categoryNames = {
      exploration: 'Exploration',
      social: 'Social',
      crafting: 'Crafting',
      building: 'Building',
      gardening: 'Gardening',
      economy: 'Economy',
      competition: 'Competition',
      quests: 'Quests',
      guild: 'Guild',
      art: 'Art & Creativity',
      physical: 'Physical Wellness',
      mentoring: 'Mentoring'
    };

    Object.keys(categoryNames).forEach(function(catKey) {
      var catAchievements = categories[catKey];
      if (catAchievements.length === 0) return;

      var categorySection = document.createElement('div');
      categorySection.className = 'achievement-category';

      var categoryTitle = document.createElement('div');
      categoryTitle.className = 'achievement-category-title';
      categoryTitle.textContent = categoryNames[catKey];
      categorySection.appendChild(categoryTitle);

      catAchievements.forEach(function(ach) {
        var row = document.createElement('div');
        row.className = 'achievement-row ' + (ach.unlocked ? 'unlocked' : 'locked');
        if (ach.unlocked) {
          row.style.borderLeft = '3px solid #daa520';
          row.style.paddingLeft = '5px';
        }

        var icon = document.createElement('div');
        icon.className = 'achievement-icon';
        icon.textContent = ach.icon || 'â­';
        row.appendChild(icon);

        var info = document.createElement('div');
        info.className = 'achievement-info';

        var name = document.createElement('div');
        name.className = 'achievement-name';
        name.textContent = ach.name;
        info.appendChild(name);

        var desc = document.createElement('div');
        desc.className = 'achievement-desc';
        desc.textContent = ach.description;
        info.appendChild(desc);

        row.appendChild(info);

        var reward = document.createElement('div');
        reward.className = 'achievement-reward';
        reward.textContent = '+' + ach.sparkReward + ' Spark';
        row.appendChild(reward);

        categorySection.appendChild(row);
      });

      panel.appendChild(categorySection);
    });

    document.body.appendChild(panel);
    achievementPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideAchievementPanel();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideAchievementPanel() {
    if (!achievementPanel) return;
    if (achievementPanel.escapeHandler) {
      document.removeEventListener('keydown', achievementPanel.escapeHandler);
    }
    achievementPanel.classList.remove('visible');
    setTimeout(function() {
      if (achievementPanel && achievementPanel.parentNode) {
        document.body.removeChild(achievementPanel);
        achievementPanel = null;
      }
    }, 250);
  }

  function updateFederationStatus(discoveredWorlds, federatedWorlds) {
    if (!federationPanel) return;

    var html = '<div style="font-weight: bold; margin-bottom: 8px; color: #88f;">Federation</div>';

    if (federatedWorlds && federatedWorlds.length > 0) {
      html += '<div style="margin-bottom: 8px;">';
      html += '<div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">Active Portals:</div>';
      federatedWorlds.forEach(function(world) {
        html += '<div style="margin-left: 8px; margin-bottom: 3px;">';
        html += '<span style="color: #4f4;">&#x2713;</span> ';
        html += '<span style="color: #fff;">' + (world.worldInfo?.worldName || world.worldId) + '</span>';
        if (world.worldInfo?.playerCount !== undefined) {
          html += '<span style="color: #888; font-size: 10px;"> (' + world.worldInfo.playerCount + ')</span>';
        }
        html += '</div>';
      });
      html += '</div>';
    }

    if (discoveredWorlds && discoveredWorlds.length > 0) {
      var unfederated = discoveredWorlds.filter(function(dw) {
        return !federatedWorlds.some(function(fw) {
          return fw.worldId === dw.worldId;
        });
      });

      if (unfederated.length > 0) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">Discovered:</div>';
        unfederated.forEach(function(world) {
          html += '<div style="margin-left: 8px; margin-bottom: 3px;">';
          html += '<span style="color: #88f;">&#x25cf;</span> ';
          html += '<span style="color: #ccc;">' + (world.worldName || world.worldId) + '</span>';
          if (world.playerCount !== undefined) {
            html += '<span style="color: #888; font-size: 10px;"> (' + world.playerCount + ')</span>';
          }
          html += '</div>';
        });
        html += '</div>';
      }
    }

    if ((!federatedWorlds || federatedWorlds.length === 0) &&
        (!discoveredWorlds || discoveredWorlds.length === 0)) {
      html += '<div style="color: #888; font-size: 11px; font-style: italic;">No federated worlds yet</div>';
    }

    federationPanel.innerHTML = html;
  }

  function showFederationPortalUI(portalInfo) {
    if (typeof document === 'undefined') return;

    var portalUI = document.getElementById('federation-portal-ui');
    if (!portalUI) {
      portalUI = document.createElement('div');
      portalUI.id = 'federation-portal-ui';
      portalUI.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #88f;
        border-radius: 12px;
        padding: 20px;
        min-width: 300px;
        color: white;
        text-align: center;
        pointer-events: auto;
        z-index: 200;
      `;
      document.body.appendChild(portalUI);
    }

    var html = '<div style="font-size: 20px; font-weight: bold; margin-bottom: 10px; color: #88f;">Rift Portal</div>';
    html += '<div style="margin-bottom: 15px; color: #ccc;">' + (portalInfo.worldName || 'Unknown World') + '</div>';

    if (portalInfo.playerCount !== undefined) {
      html += '<div style="margin-bottom: 15px; font-size: 12px; color: #aaa;">Players: ' + portalInfo.playerCount + '</div>';
    }

    html += '<button id="portal-warp-btn" style="';
    html += 'background: #4488ff; color: white; border: none; padding: 10px 20px;';
    html += 'border-radius: 5px; cursor: pointer; font-size: 14px; margin-right: 10px;">Enter Portal</button>';
    html += '<button id="portal-close-btn" style="';
    html += 'background: #444; color: white; border: none; padding: 10px 20px;';
    html += 'border-radius: 5px; cursor: pointer; font-size: 14px;">Cancel</button>';

    portalUI.innerHTML = html;

    document.getElementById('portal-warp-btn').onclick = function() {
      if (portalInfo.onWarp) {
        portalInfo.onWarp(portalInfo.targetWorld);
      }
      hideFederationPortalUI();
    };

    document.getElementById('portal-close-btn').onclick = function() {
      hideFederationPortalUI();
    };
  }

  function hideFederationPortalUI() {
    var portalUI = document.getElementById('federation-portal-ui');
    if (portalUI) {
      portalUI.remove();
    }
  }

  let fishingUIActive = false;
  let fishingCallback = null;

  function showFishingUI(zoneId, onResult) {
    if (!hudContainer || fishingUIActive) return;
    if (typeof document === 'undefined') return;

    fishingUIActive = true;
    fishingCallback = onResult;

    const fishingOverlay = document.createElement('div');
    fishingOverlay.id = 'fishing-ui';
    fishingOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 50, 100, 0.3) 0%, rgba(0, 100, 150, 0.5) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: auto;
    `;

    const fishingPanel = document.createElement('div');
    fishingPanel.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 80, 140, 0.95) 0%, rgba(0, 120, 180, 0.95) 100%);
      border: 3px solid rgba(100, 200, 255, 0.8);
      border-radius: 15px;
      padding: 40px;
      min-width: 400px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 150, 255, 0.5), inset 0 0 50px rgba(0, 100, 200, 0.3);
      animation: wave-effect 3s ease-in-out infinite;
    `;

    const style = document.createElement('style');
    style.textContent = `
      @keyframes wave-effect {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-5px); }
      }
      @keyframes ripple {
        0% { transform: scale(0.8); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    const fishingIcon = document.createElement('div');
    fishingIcon.style.cssText = `
      font-size: 64px;
      margin-bottom: 20px;
      animation: ripple 2s ease-out infinite;
    `;
    fishingIcon.textContent = 'ðŸŽ£';
    fishingPanel.appendChild(fishingIcon);

    const statusText = document.createElement('div');
    statusText.style.cssText = `
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
      margin-bottom: 20px;
    `;
    statusText.textContent = 'Casting...';
    fishingPanel.appendChild(statusText);

    const subText = document.createElement('div');
    subText.style.cssText = `
      font-size: 16px;
      color: rgba(200, 240, 255, 0.9);
      margin-top: 10px;
    `;
    subText.textContent = 'Wait for a bite...';
    fishingPanel.appendChild(subText);

    fishingOverlay.appendChild(fishingPanel);
    hudContainer.appendChild(fishingOverlay);

    const castTime = 2000 + Math.random() * 3000;

    setTimeout(() => {
      if (!document.getElementById('fishing-ui')) return;

      statusText.textContent = 'FISH ON!';
      statusText.style.color = '#ffff00';
      statusText.style.fontSize = '32px';
      subText.textContent = 'Press E to reel in!';
      subText.style.color = '#ffff00';
      fishingIcon.textContent = 'ðŸŸ';

      let caughtFish = false;
      const reelWindow = 1500; // 1.5 second window to press E

      const reelHandler = (e) => {
        if (e.key === 'e' || e.key === 'E') {
          caughtFish = true;
          document.removeEventListener('keydown', reelHandler);

          const fishResult = determineCatch(zoneId);

          statusText.textContent = `Caught ${fishResult.name}!`;
          statusText.style.color = '#4f4';
          subText.textContent = `+${fishResult.value} Spark`;
          fishingIcon.textContent = fishResult.icon;

          setTimeout(() => {
            hideFishingUI();
            if (fishingCallback) {
              fishingCallback({ success: true, fish: fishResult });
            }
          }, 2000);
        }
      };

      document.addEventListener('keydown', reelHandler);

      setTimeout(() => {
        if (!caughtFish) {
          document.removeEventListener('keydown', reelHandler);
          statusText.textContent = 'The fish got away...';
          statusText.style.color = '#f44';
          subText.textContent = 'Try again!';
          fishingIcon.textContent = 'ðŸ’¨';

          setTimeout(() => {
            hideFishingUI();
            if (fishingCallback) {
              fishingCallback({ success: false });
            }
          }, 2000);
        }
      }, reelWindow);
    }, castTime);
  }

  function determineCatch(zoneId) {
    const zoneFishTables = {
      gardens: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' },
          { id: 'fish_sunfish', name: 'Sunfish', icon: 'â˜€ï¸', value: 8, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' },
          { id: 'fish_crystal_trout', name: 'Crystal Trout', icon: 'ðŸ’Ž', value: 40, rarity: 'rare' }
        ],
        rare: [
          { id: 'fish_golden', name: 'Golden Koi', icon: 'ðŸŸ¡', value: 50, rarity: 'rare' }
        ]
      },
      wilds: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_shadow_bass', name: 'Shadow Bass', icon: 'ðŸŒ‘', value: 18, rarity: 'uncommon' },
          { id: 'fish_silver_eel', name: 'Silver Eel', icon: 'ðŸ', value: 20, rarity: 'uncommon' }
        ],
        rare: [
          { id: 'fish_starfish', name: 'Star Cod', icon: 'â­', value: 35, rarity: 'rare' },
          { id: 'fish_dragonfish', name: 'Dragonfish', icon: 'ðŸ‰', value: 100, rarity: 'legendary' }
        ]
      },
      commons: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' },
          { id: 'fish_sunfish', name: 'Sunfish', icon: 'â˜€ï¸', value: 8, rarity: 'common' }
        ],
        rare: [
          { id: 'fish_moonfish', name: 'Moonfish', icon: 'ðŸŒ™', value: 25, rarity: 'uncommon' }
        ]
      },
      agora: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' }
        ],
        rare: [
          { id: 'fish_golden', name: 'Golden Koi', icon: 'ðŸŸ¡', value: 50, rarity: 'rare' }
        ]
      }
    };

    const table = zoneFishTables[zoneId] || zoneFishTables.commons;

    const roll = Math.random();
    let pool;
    if (roll < 0.05 && table.rare && table.rare.length > 0) {
      pool = table.rare;
    } else if (roll < 0.30 && table.uncommon && table.uncommon.length > 0) {
      pool = table.uncommon;
    } else {
      pool = table.common;
    }

    return pool[Math.floor(Math.random() * pool.length)];
  }

  function hideFishingUI() {
    const fishingUI = document.getElementById('fishing-ui');
    if (fishingUI) {
      fishingUI.remove();
    }
    fishingUIActive = false;
    fishingCallback = null;
  }

  function showFishCaughtNotification(fishName, value) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const notification = document.createElement('div');
    notification.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 120, 200, 0.95) 0%, rgba(0, 180, 255, 0.95) 100%);
      border: 2px solid rgba(100, 220, 255, 0.9);
      border-radius: 10px;
      padding: 20px 30px;
      margin-bottom: 10px;
      box-shadow: 0 4px 20px rgba(0, 150, 255, 0.6);
      animation: slideIn 0.3s ease-out, slideOut 0.3s ease-in 2.7s;
      pointer-events: auto;
      text-align: center;
    `;

    const fishIcon = document.createElement('div');
    fishIcon.style.cssText = `
      font-size: 48px;
      margin-bottom: 10px;
    `;
    fishIcon.textContent = 'ðŸŽ£';
    notification.appendChild(fishIcon);

    const fishText = document.createElement('div');
    fishText.style.cssText = `
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
      margin-bottom: 5px;
    `;
    fishText.textContent = `Caught ${fishName}!`;
    notification.appendChild(fishText);

    const valueText = document.createElement('div');
    valueText.style.cssText = `
      font-size: 16px;
      color: #ffff00;
      text-shadow: 0 0 8px rgba(255, 255, 0, 0.6);
    `;
    valueText.textContent = `+${value} Spark`;
    notification.appendChild(valueText);

    notificationContainer.appendChild(notification);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 3000);
  }

  var petPanel = null;

  function showPetPanel(playerId, currentZone) {
    if (typeof document === 'undefined') return;

    var Pets = typeof window !== 'undefined' ? window.Pets : null;
    if (!Pets) {
      console.warn('Pets module not available');
      return;
    }

    if (petPanel) {
      hidePetPanel();
      return;
    }

    var pet = Pets.getPlayerPet(playerId);

    var panel = document.createElement('div');
    panel.className = 'pet-panel';

    var header = document.createElement('h2');
    header.textContent = pet ? 'My Pingym' : 'Adopt a Pingym';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:15px;right:15px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;font-size:20px;cursor:pointer;transition:all 0.2s;';
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218,165,32,0.3)';
      this.style.borderColor = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255,255,255,0.1)';
      this.style.borderColor = 'rgba(255,255,255,0.3)';
    };
    closeBtn.onclick = hidePetPanel;
    panel.appendChild(closeBtn);

    if (pet) {
      showCurrentPetInfo(panel, pet, playerId, Pets);
    } else {
      showAdoptionList(panel, playerId, currentZone, Pets);
    }

    document.body.appendChild(panel);
    petPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hidePetPanel();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function showCurrentPetInfo(panel, pet, playerId, Pets) {
    var petTypeData = Pets.getPetTypeData(pet.type);
    var mood = Pets.getPetMood(pet);
    var moodEmoji = Pets.getMoodEmoji(mood);
    var bonus = Pets.getPetBonus(playerId);

    var petDisplay = document.createElement('div');
    petDisplay.style.cssText = 'text-align:center;margin-bottom:20px;padding:20px;' +
      'background:rgba(255,255,255,0.03);border-radius:8px;';

    var petIcon = document.createElement('div');
    petIcon.textContent = petTypeData.icon;
    petIcon.style.cssText = 'font-size:64px;margin-bottom:10px;';
    petDisplay.appendChild(petIcon);

    var petName = document.createElement('div');
    petName.textContent = pet.name;
    petName.style.cssText = 'font-size:1.2rem;color:#DAA520;font-weight:bold;margin-bottom:5px;';
    petDisplay.appendChild(petName);

    var petType = document.createElement('div');
    petType.textContent = petTypeData.name;
    petType.style.cssText = 'font-size:0.9rem;color:#B8B0A8;margin-bottom:5px;';
    petDisplay.appendChild(petType);

    var petMoodDisplay = document.createElement('div');
    petMoodDisplay.textContent = moodEmoji + ' ' + mood.charAt(0).toUpperCase() + mood.slice(1);
    petMoodDisplay.style.cssText = 'font-size:0.9rem;color:#E8E0D8;margin-top:10px;';
    petDisplay.appendChild(petMoodDisplay);

    panel.appendChild(petDisplay);

    var statsSection = document.createElement('div');
    statsSection.style.cssText = 'margin-bottom:20px;';

    var moodLabel = document.createElement('div');
    moodLabel.textContent = 'Mood: ' + Math.round(pet.mood) + '/100';
    moodLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;';
    statsSection.appendChild(moodLabel);

    var moodBar = createProgressBar(pet.mood, '#DAA520');
    statsSection.appendChild(moodBar);

    var hungerLabel = document.createElement('div');
    hungerLabel.textContent = 'Hunger: ' + Math.round(pet.hunger) + '/100';
    hungerLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;margin-top:12px;';
    statsSection.appendChild(hungerLabel);

    var hungerBar = createProgressBar(pet.hunger, pet.hunger > 60 ? '#e74c3c' : '#3498db');
    statsSection.appendChild(hungerBar);

    var bondLabel = document.createElement('div');
    bondLabel.textContent = 'Bond: ' + Math.round(pet.bond) + '/100';
    bondLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;margin-top:12px;';
    statsSection.appendChild(bondLabel);

    var bondBar = createProgressBar(pet.bond, '#2ecc71');
    statsSection.appendChild(bondBar);

    panel.appendChild(statsSection);

    if (bonus && bonus.value > 0) {
      var bonusDisplay = document.createElement('div');
      bonusDisplay.textContent = 'Bonus: ' + bonus.description;
      bonusDisplay.style.cssText = 'color:#2ecc71;font-size:0.85rem;margin-bottom:20px;' +
        'padding:8px;background:rgba(46,204,113,0.1);border-radius:4px;text-align:center;';
      panel.appendChild(bonusDisplay);
    }

    var actionsSection = document.createElement('div');
    actionsSection.style.cssText = 'display:flex;gap:8px;margin-bottom:12px;';

    var feedBtn = document.createElement('button');
    feedBtn.textContent = 'Feed';
    feedBtn.className = 'pet-action-btn';
    feedBtn.onclick = function() {
      showFeedMenu(playerId, Pets);
    };
    actionsSection.appendChild(feedBtn);

    var renameBtn = document.createElement('button');
    renameBtn.textContent = 'Rename';
    renameBtn.className = 'pet-action-btn';
    renameBtn.onclick = function() {
      var newName = prompt('Enter new name for ' + pet.name + ':');
      if (newName && newName.trim()) {
        if (Pets.renamePet(playerId, newName.trim())) {
          showNotification('Pingym renamed to ' + newName.trim());
          hidePetPanel();
        }
      }
    };
    actionsSection.appendChild(renameBtn);

    panel.appendChild(actionsSection);

    var releaseBtn = document.createElement('button');
    releaseBtn.textContent = 'Release to Wild';
    releaseBtn.className = 'pet-release-btn';
    releaseBtn.onclick = function() {
      if (confirm('Are you sure you want to release ' + pet.name + '? This cannot be undone.')) {
        if (Pets.releasePet(playerId)) {
          showNotification(pet.name + ' has been released to the wild');
          hidePetPanel();
        }
      }
    };
    panel.appendChild(releaseBtn);
  }

  function showAdoptionList(panel, playerId, currentZone, Pets) {
    var availablePets = Pets.getAvailablePets(currentZone || 'commons');

    var infoText = document.createElement('div');
    infoText.textContent = 'Choose a Pingym to adopt in this zone:';
    infoText.style.cssText = 'color:#B8B0A8;font-size:0.9rem;margin-bottom:16px;';
    panel.appendChild(infoText);

    if (availablePets.length === 0) {
      var noPets = document.createElement('div');
      noPets.textContent = 'No pets available in this zone. Try exploring other areas!';
      noPets.style.cssText = 'color:#E8E0D8;text-align:center;padding:20px;';
      panel.appendChild(noPets);
      return;
    }

    availablePets.forEach(function(petType) {
      var petRow = document.createElement('div');
      petRow.className = 'pet-adoption-row';
      petRow.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;' +
        'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);' +
        'border-radius:8px;margin-bottom:8px;transition:all 0.2s;cursor:pointer;';

      petRow.onmouseover = function() {
        this.style.borderColor = 'rgba(218,165,32,0.5)';
        this.style.background = 'rgba(218,165,32,0.1)';
      };
      petRow.onmouseout = function() {
        this.style.borderColor = 'rgba(255,255,255,0.1)';
        this.style.background = 'rgba(255,255,255,0.03)';
      };

      var icon = document.createElement('div');
      icon.textContent = petType.icon;
      icon.style.cssText = 'font-size:32px;width:40px;text-align:center;';
      petRow.appendChild(icon);

      var info = document.createElement('div');
      info.style.cssText = 'flex:1;';

      var name = document.createElement('div');
      name.textContent = petType.name;
      name.style.cssText = 'color:#E8E0D8;font-size:0.95rem;font-weight:bold;margin-bottom:2px;';
      info.appendChild(name);

      var desc = document.createElement('div');
      desc.textContent = petType.description;
      desc.style.cssText = 'color:#B8B0A8;font-size:0.75rem;margin-bottom:4px;';
      info.appendChild(desc);

      var rarity = document.createElement('div');
      rarity.textContent = petType.rarity.charAt(0).toUpperCase() + petType.rarity.slice(1);
      var rarityColor = petType.rarity === 'legendary' ? '#f39c12' :
                        petType.rarity === 'rare' ? '#3498db' :
                        petType.rarity === 'uncommon' ? '#2ecc71' : '#95a5a6';
      rarity.style.cssText = 'color:' + rarityColor + ';font-size:0.7rem;';
      info.appendChild(rarity);

      petRow.appendChild(info);

      var adoptBtn = document.createElement('button');
      adoptBtn.textContent = 'Adopt';
      adoptBtn.className = 'pet-adopt-btn';
      adoptBtn.onclick = function(e) {
        e.stopPropagation();
        var petName = prompt('Choose a name for your ' + petType.name + ':');
        if (petName && petName.trim()) {
          var adoptedPet = Pets.adoptPet(playerId, petType.id, petName.trim());
          if (adoptedPet) {
            showPetAdoptNotification(petName.trim(), petType);
            hidePetPanel();
          } else {
            alert('Could not adopt. You may already have a Pingym.');
          }
        }
      };
      petRow.appendChild(adoptBtn);

      panel.appendChild(petRow);
    });
  }

  function showFeedMenu(playerId, Pets) {
    if (!petPanel) return;

    var foods = ['berry', 'fish', 'mushroom', 'bread', 'treat'];
    var foodEmojis = {
      'berry': 'ðŸ«',
      'fish': 'ðŸŸ',
      'mushroom': 'ðŸ„',
      'bread': 'ðŸž',
      'treat': 'ðŸª'
    };

    var feedMenu = document.createElement('div');
    feedMenu.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(15,12,10,0.98);border:2px solid #DAA520;border-radius:12px;' +
      'padding:20px;z-index:1200;min-width:250px;';

    var title = document.createElement('h3');
    title.textContent = 'Choose Food';
    title.style.cssText = 'color:#DAA520;margin:0 0 16px;text-align:center;';
    feedMenu.appendChild(title);

    foods.forEach(function(food) {
      var foodBtn = document.createElement('button');
      foodBtn.textContent = foodEmojis[food] + ' ' + food.charAt(0).toUpperCase() + food.slice(1);
      foodBtn.className = 'pet-food-btn';
      foodBtn.style.cssText = 'display:block;width:100%;padding:10px;margin-bottom:8px;' +
        'background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);' +
        'border-radius:6px;color:#E8E0D8;cursor:pointer;transition:all 0.2s;';

      foodBtn.onmouseover = function() {
        this.style.background = 'rgba(218,165,32,0.2)';
        this.style.borderColor = '#DAA520';
      };
      foodBtn.onmouseout = function() {
        this.style.background = 'rgba(255,255,255,0.1)';
        this.style.borderColor = 'rgba(255,255,255,0.2)';
      };

      foodBtn.onclick = function() {
        var result = Pets.feedPet(playerId, food);
        if (result.success) {
          showNotification(result.message);
          document.body.removeChild(feedMenu);
          hidePetPanel();
        }
      };
      feedMenu.appendChild(foodBtn);
    });

    var cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.className = 'pet-food-btn';
    cancelBtn.style.cssText = 'display:block;width:100%;padding:10px;' +
      'background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:6px;color:#B8B0A8;cursor:pointer;';
    cancelBtn.onclick = function() {
      document.body.removeChild(feedMenu);
    };
    feedMenu.appendChild(cancelBtn);

    document.body.appendChild(feedMenu);
  }

  function createProgressBar(value, color) {
    var container = document.createElement('div');
    container.style.cssText = 'width:100%;height:8px;background:rgba(255,255,255,0.1);' +
      'border-radius:4px;overflow:hidden;';

    var fill = document.createElement('div');
    fill.style.cssText = 'height:100%;background:' + color + ';border-radius:4px;' +
      'transition:width 0.5s ease;width:' + value + '%;';

    container.appendChild(fill);
    return container;
  }

  function hidePetPanel() {
    if (!petPanel) return;
    if (petPanel.escapeHandler) {
      document.removeEventListener('keydown', petPanel.escapeHandler);
    }
    petPanel.classList.remove('visible');
    setTimeout(function() {
      if (petPanel && petPanel.parentNode) {
        document.body.removeChild(petPanel);
        petPanel = null;
      }
    }, 250);
  }

  function showPetAdoptNotification(petName, petType) {
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.className = 'pet-adopt-notification';
    notification.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:linear-gradient(135deg,rgba(25,20,15,0.95),rgba(35,28,18,0.95));' +
      'border:2px solid #DAA520;border-radius:16px;padding:30px 40px;text-align:center;' +
      'z-index:2000;animation:petAdoptReveal 0.5s ease-out,petAdoptFade 4s ease-in-out;' +
      'box-shadow:0 0 40px rgba(218,165,32,0.4);pointer-events:none;';

    var styleId = 'pet-adopt-animations';
    if (!document.getElementById(styleId)) {
      var style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
        @keyframes petAdoptReveal {
          0% { transform: translate(-50%,-50%) scale(0.6); opacity: 0; }
          60% { transform: translate(-50%,-50%) scale(1.05); }
          100% { opacity: 1; transform: translate(-50%,-50%) scale(1); }
        }
        @keyframes petAdoptFade {
          0%, 80% { opacity: 1; }
          100% { opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    var icon = document.createElement('div');
    icon.textContent = petType.icon;
    icon.style.cssText = 'font-size:64px;margin-bottom:16px;';
    notification.appendChild(icon);

    var title = document.createElement('div');
    title.textContent = 'Pingym Adopted!';
    title.style.cssText = 'font-size:0.9rem;color:#DAA520;text-transform:uppercase;' +
      'letter-spacing:0.15em;margin-bottom:8px;';
    notification.appendChild(title);

    var name = document.createElement('div');
    name.textContent = petName;
    name.style.cssText = 'font-size:1.5rem;color:#E8E0D8;font-weight:bold;margin-bottom:4px;';
    notification.appendChild(name);

    var typeName = document.createElement('div');
    typeName.textContent = petType.name;
    typeName.style.cssText = 'font-size:1rem;color:#B8B0A8;';
    notification.appendChild(typeName);

    document.body.appendChild(notification);

    setTimeout(function() {
      if (notification.parentNode) {
        document.body.removeChild(notification);
      }
    }, 4000);
  }

  exports.initHUD = initHUD;
  exports.initToolbar = initToolbar;
  exports.updateChat = updateChat;
  exports.addChatMessage = addChatMessage;
  exports.updatePlayerInfo = updatePlayerInfo;
  exports.updateMinimap = updateMinimap;
  exports.updateZoneLabel = updateZoneLabel;
  exports.updateNearbyPlayers = updateNearbyPlayers;
  exports.showBreakReminder = showBreakReminder;
  exports.addChatInput = addChatInput;
  exports.showChatInput = showChatInput;
  exports.hideChatInput = hideChatInput;
  exports.showNotification = showNotification;
  exports.updateCoords = updateCoords;
  exports.updateTimeWeather = updateTimeWeather;
  exports.showNPCDialog = showNPCDialog;
  exports.hideNPCDialog = hideNPCDialog;
  exports.setNPCActionCallback = setNPCActionCallback;
  exports.showNPCShop = showNPCShop;
  exports.hideNPCShop = hideNPCShop;
  exports.updateMinimapNPCs = updateMinimapNPCs;
  exports.initQuestTracker = initQuestTracker;
  exports.updateQuestTracker = updateQuestTracker;
  exports.showQuestLog = showQuestLog;
  exports.hideQuestLog = hideQuestLog;
  exports.showQuestOffer = showQuestOffer;
  exports.hideQuestOffer = hideQuestOffer;
  exports.showQuestComplete = showQuestComplete;
  exports.showQuestProgress = showQuestProgress;
  exports.acceptQuestFromOffer = acceptQuestFromOffer;
  exports.updateFederationStatus = updateFederationStatus;
  exports.showFederationPortalUI = showFederationPortalUI;
  exports.hideFederationPortalUI = hideFederationPortalUI;
  exports.abandonQuestFromLog = abandonQuestFromLog;
  exports.initInventoryPanel = initInventoryPanel;
  exports.toggleInventoryPanel = toggleInventoryPanel;
  exports.showInventoryPanel = showInventoryPanel;
  exports.hideInventoryPanel = hideInventoryPanel;
  exports.updateInventoryDisplay = updateInventoryDisplay;
  exports.initCraftingPanel = initCraftingPanel;
  exports.toggleCraftingPanel = toggleCraftingPanel;
  exports.showCraftingPanel = showCraftingPanel;
  exports.hideCraftingPanel = hideCraftingPanel;
  exports.updateCraftingDisplay = updateCraftingDisplay;
  exports.initQuickBar = initQuickBar;
  exports.updateQuickBar = updateQuickBar;
  exports.showItemPickup = showItemPickup;
  exports.showTradeRequest = showTradeRequest;
  exports.hideTradeRequest = hideTradeRequest;
  exports.showTradeWindow = showTradeWindow;
  exports.updateTradeWindow = updateTradeWindow;
  exports.hideTradeWindow = hideTradeWindow;
  exports.showTradeComplete = showTradeComplete;
  exports.showEmoteMenu = showEmoteMenu;
  exports.hideEmoteMenu = hideEmoteMenu;
  exports.showEmoteBubble = showEmoteBubble;
  exports.updateEmoteBubbles = updateEmoteBubbles;
  exports.showBuildToolbar = showBuildToolbar;
  exports.hideBuildToolbar = hideBuildToolbar;
  exports.updateBuildToolbar = updateBuildToolbar;
  exports.showWorldMap = showWorldMap;
  exports.hideWorldMap = hideWorldMap;
  exports.updateWorldMap = updateWorldMap;
  exports.showSettingsMenu = showSettingsMenu;
  exports.hideSettingsMenu = hideSettingsMenu;
  exports.loadSettings = loadSettings;
  exports.getSettings = getSettings;
  exports.showPlayerProfile = showPlayerProfile;
  exports.hidePlayerProfile = hidePlayerProfile;
  exports.showProfilePanel = showProfilePanel;
  exports.hideProfilePanel = hideProfilePanel;
  exports.updateProfileStats = updateProfileStats;
  exports.showDiscoveryLog = showDiscoveryLog;
  exports.hideDiscoveryLog = hideDiscoveryLog;
  exports.showLoreBook = showLoreBook;
  exports.hideLoreBook = hideLoreBook;
  exports.showLoreJournal = showLoreJournal;
  exports.hideLoreJournal = hideLoreJournal;
  exports.toggleLoreJournal = toggleLoreJournal;
  exports.showAchievementToast = showAchievementToast;
  exports.showDiscoveryPopup = showDiscoveryPopup;
  exports.showSkillsPanel = showSkillsPanel;
  exports.hideSkillsPanel = hideSkillsPanel;
  exports.showMentorOffer = showMentorOffer;
  exports.showLessonProgress = showLessonProgress;
  exports.showComposePanel = showComposePanel;
  exports.hideComposePanel = hideComposePanel;
  exports.playComposition = playComposition;
  exports.showGuildPanel = showGuildPanel;
  exports.hideGuildPanel = hideGuildPanel;
  exports.showGuildCreate = showGuildCreate;
  exports.hideGuildCreate = hideGuildCreate;
  exports.showGuildInvite = showGuildInvite;
  exports.updateGuildTag = updateGuildTag;
  exports.initGovernancePanel = initGovernancePanel;
  exports.showGovernancePanel = showGovernancePanel;
  exports.hideGovernancePanel = hideGovernancePanel;
  exports.toggleGovernancePanel = toggleGovernancePanel;
  exports.initAuctionHousePanel = initAuctionHousePanel;
  exports.showAuctionHousePanel = showAuctionHousePanel;
  exports.hideAuctionHousePanel = hideAuctionHousePanel;
  exports.toggleAuctionHousePanel = toggleAuctionHousePanel;
  exports.updateReputationDisplay = updateReputationDisplay;
  exports.showAchievementPanel = showAchievementPanel;
  exports.hideAchievementPanel = hideAchievementPanel;
  exports.showFishingUI = showFishingUI;
  exports.hideFishingUI = hideFishingUI;
  exports.showFishCaughtNotification = showFishCaughtNotification;
  exports.showPetPanel = showPetPanel;
  exports.hidePetPanel = hidePetPanel;
  exports.showPetAdoptNotification = showPetAdoptNotification;

  var tutorialState = {
    active: false,
    currentStep: 0,
    completed: false
  };

  var tutorialTooltip = null;
  var tutorialSteps = [
    {
      id: 'move',
      message: 'Welcome to ZION! Use WASD to move around.',
      action: 'move'
    },
    {
      id: 'interact',
      message: 'Press E near an NPC to interact.',
      action: 'interact'
    },
    {
      id: 'inventory',
      message: 'Press I to open your inventory.',
      action: 'openInventory'
    },
    {
      id: 'quests',
      message: 'Press J to check your quests.',
      action: 'openQuests'
    },
    {
      id: 'chat',
      message: 'Press Enter to chat with other players.',
      action: 'openChat'
    },
    {
      id: 'complete',
      message: "You're ready! Explore the world, make friends, and build something beautiful.",
      action: 'complete',
      autoDismiss: true
    }
  ];

  function createTutorialTooltip() {
    if (typeof document === 'undefined') return null;

    var tooltip = document.createElement('div');
    tooltip.id = 'tutorial-tooltip';
    tooltip.style.cssText = `
      position: absolute;
      bottom: 240px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 12, 10, 0.92);
      border: 1px solid rgba(218, 165, 32, 0.4);
      border-radius: 8px;
      padding: 20px 25px;
      min-width: 400px;
      max-width: 500px;
      pointer-events: auto;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      animation: tutorialPulse 2s infinite;
    `;

    var styleSheet = document.createElement('style');
    styleSheet.textContent = `
      @keyframes tutorialPulse {
        0%, 100% {
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 10px rgba(218, 165, 32, 0.2);
        }
        50% {
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(218, 165, 32, 0.5);
        }
      }
    `;
    document.head.appendChild(styleSheet);

    var stepCounter = document.createElement('div');
    stepCounter.id = 'tutorial-step-counter';
    stepCounter.style.cssText = `
      color: #DAA520;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    `;
    tooltip.appendChild(stepCounter);

    var message = document.createElement('div');
    message.id = 'tutorial-message';
    message.style.cssText = `
      color: #ffffff;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 15px;
    `;
    tooltip.appendChild(message);

    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
      display: flex;
      justify-content: flex-end;
    `;

    var skipButton = document.createElement('button');
    skipButton.id = 'tutorial-skip-btn';
    skipButton.textContent = 'Skip Tutorial';
    skipButton.style.cssText = `
      background: rgba(100, 100, 100, 0.3);
      border: 1px solid rgba(150, 150, 150, 0.4);
      color: #cccccc;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    `;
    skipButton.onmouseover = function() {
      skipButton.style.background = 'rgba(120, 120, 120, 0.4)';
      skipButton.style.borderColor = 'rgba(170, 170, 170, 0.6)';
    };
    skipButton.onmouseout = function() {
      skipButton.style.background = 'rgba(100, 100, 100, 0.3)';
      skipButton.style.borderColor = 'rgba(150, 150, 150, 0.4)';
    };
    skipButton.onclick = function() {
      skipTutorial();
    };
    buttonContainer.appendChild(skipButton);

    tooltip.appendChild(buttonContainer);

    return tooltip;
  }

  function updateTutorialTooltip() {
    if (!tutorialTooltip || !tutorialState.active) return;

    var step = tutorialSteps[tutorialState.currentStep];
    var stepCounter = tutorialTooltip.querySelector('#tutorial-step-counter');
    var message = tutorialTooltip.querySelector('#tutorial-message');

    if (stepCounter) {
      stepCounter.textContent = 'Step ' + (tutorialState.currentStep + 1) + '/' + tutorialSteps.length;
    }

    if (message) {
      message.textContent = step.message;
    }
  }

  function showTutorialTooltip() {
    if (!hudContainer || typeof document === 'undefined') return;

    if (!tutorialTooltip) {
      tutorialTooltip = createTutorialTooltip();
      if (!tutorialTooltip) return;
    }

    var hudOverlay = document.getElementById('zion-hud');
    if (hudOverlay && tutorialTooltip.parentNode !== hudOverlay) {
      hudOverlay.appendChild(tutorialTooltip);
    }

    updateTutorialTooltip();
    tutorialTooltip.style.display = 'block';
  }

  function hideTutorialTooltip() {
    if (tutorialTooltip) {
      tutorialTooltip.style.display = 'none';
    }
  }

  function removeTutorialTooltip() {
    if (tutorialTooltip && tutorialTooltip.parentNode) {
      tutorialTooltip.parentNode.removeChild(tutorialTooltip);
      tutorialTooltip = null;
    }
  }

  function initTutorial() {
    if (typeof localStorage === 'undefined') {
      console.warn('Tutorial requires localStorage support');
      return;
    }

    var tutorialComplete = localStorage.getItem('zion_tutorial_complete');
    if (tutorialComplete === 'true') {
      tutorialState.completed = true;
      tutorialState.active = false;
      return;
    }

    tutorialState.active = true;
    tutorialState.currentStep = 0;
    tutorialState.completed = false;

    showTutorialTooltip();
  }

  function advanceTutorial(completedAction) {
    if (!tutorialState.active || tutorialState.completed) return;

    var currentStep = tutorialSteps[tutorialState.currentStep];

    if (currentStep.action !== completedAction) return;

    if (currentStep.autoDismiss) {
      setTimeout(function() {
        completeTutorial();
      }, 5000);
      return;
    }

    tutorialState.currentStep++;

    if (tutorialState.currentStep >= tutorialSteps.length) {
      completeTutorial();
      return;
    }

    updateTutorialTooltip();
  }

  function completeTutorial() {
    tutorialState.active = false;
    tutorialState.completed = true;

    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('zion_tutorial_complete', 'true');
    }

    hideTutorialTooltip();

    setTimeout(function() {
      removeTutorialTooltip();
    }, 300);

    if (typeof showNotification === 'function') {
      showNotification('Tutorial Complete! Good luck in ZION!', 'success');
    }
  }

  function skipTutorial() {
    completeTutorial();
  }

  function isTutorialActive() {
    return tutorialState.active;
  }

  exports.initTutorial = initTutorial;
  exports.advanceTutorial = advanceTutorial;
  exports.skipTutorial = skipTutorial;
  exports.isTutorialActive = isTutorialActive;

  var xrCaps = null;
  var xrSceneCtx = null;

  function setXRCapabilities(caps, sceneCtx) {
    xrCaps = caps;
    xrSceneCtx = sceneCtx;
    if (typeof document === 'undefined') return;
    var toolbar = document.querySelector('#bottom-toolbar');
    if (!toolbar) return;

    if (caps.vrSupported) {
      var vrBtn = document.createElement('button');
      vrBtn.id = 'vr-btn';
      vrBtn.textContent = 'VR';
      vrBtn.title = 'Enter VR Mode';
      vrBtn.style.cssText = 'padding:6px 12px;background:rgba(68,170,255,0.3);color:#4af;border:1px solid #4af;' +
        'border-radius:6px;cursor:pointer;font-size:12px;font-weight:bold;';
      vrBtn.onclick = function() {
        var XR = typeof window !== 'undefined' ? window.XR : null;
        if (XR && xrSceneCtx && xrSceneCtx.renderer) {
          XR.enterVR(xrSceneCtx.renderer, xrSceneCtx.scene, xrSceneCtx.camera).catch(function(err) {
            showNotification('Failed to enter VR: ' + err.message, 'error');
          });
        }
      };
      toolbar.appendChild(vrBtn);
    }

    if (caps.arSupported) {
      var arBtn = document.createElement('button');
      arBtn.id = 'ar-btn';
      arBtn.textContent = 'AR';
      arBtn.title = 'Enter AR Mode';
      arBtn.style.cssText = 'padding:6px 12px;background:rgba(255,165,0,0.3);color:#ffa500;border:1px solid #ffa500;' +
        'border-radius:6px;cursor:pointer;font-size:12px;font-weight:bold;';
      arBtn.onclick = function() {
        var XR = typeof window !== 'undefined' ? window.XR : null;
        if (XR && xrSceneCtx && xrSceneCtx.renderer) {
          XR.enterAR(xrSceneCtx.renderer, xrSceneCtx.scene, xrSceneCtx.camera).catch(function(err) {
            showNotification('Failed to enter AR: ' + err.message, 'error');
          });
        }
      };
      toolbar.appendChild(arBtn);
    }
  }
  exports.setXRCapabilities = setXRCapabilities;

  var anchorPanelEl = null;

  function showAnchorPanel(playerPosition, currentZone) {
    if (typeof document === 'undefined') return;
    hideAnchorPanel();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var State = typeof window !== 'undefined' ? window.State : null;
    var anchors = [];
    if (State) {
      var liveState = State.getLiveState();
      if (liveState && liveState.anchors) {
        anchors = Object.values(liveState.anchors);
      }
    }

    anchorPanelEl = document.createElement('div');
    anchorPanelEl.id = 'anchor-panel';
    anchorPanelEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #4af;border-radius:12px;' +
      'padding:20px;width:400px;max-height:500px;overflow-y:auto;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<h2 style="color:#4af;margin:0;font-size:18px;">Anchors</h2>' +
      '<button id="anchor-close" style="background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;">Ã—</button></div>';

    if (anchors.length === 0) {
      html += '<p style="color:#888;text-align:center;">No anchors placed yet.</p>';
    } else {
      anchors.forEach(function(anchor) {
        html += '<div style="background:rgba(255,255,255,0.05);border:1px solid #333;border-radius:8px;padding:10px;margin-bottom:8px;">' +
          '<div style="color:#4af;font-weight:bold;">' + (anchor.name || 'Unnamed Anchor') + '</div>' +
          '<div style="color:#888;font-size:12px;">Zone: ' + (anchor.zone || 'unknown') + ' | By: ' + (anchor.owner || 'unknown') + '</div>' +
          '</div>';
      });
    }

    html += '<div style="border-top:1px solid #333;padding-top:12px;margin-top:12px;">' +
      '<div style="color:#aaa;font-size:13px;margin-bottom:8px;">Place New Anchor</div>' +
      '<input id="anchor-name-input" placeholder="Anchor name..." style="width:100%;padding:6px;background:rgba(0,0,0,0.5);' +
      'border:1px solid #555;border-radius:4px;color:#fff;font-size:13px;margin-bottom:8px;box-sizing:border-box;" />' +
      '<button id="anchor-place-btn" style="width:100%;padding:8px;background:#4af;color:#000;border:none;border-radius:6px;' +
      'font-weight:bold;cursor:pointer;">Place Anchor Here</button></div>';

    anchorPanelEl.innerHTML = html;
    hud.appendChild(anchorPanelEl);

    document.getElementById('anchor-close').onclick = hideAnchorPanel;
    document.getElementById('anchor-place-btn').onclick = function() {
      var name = document.getElementById('anchor-name-input').value.trim();
      if (!name) { showNotification('Enter an anchor name', 'warning'); return; }
      if (typeof window !== 'undefined' && window._onAnchorPlace) {
        window._onAnchorPlace({ name: name, zone: currentZone, position: playerPosition });
      }
      showNotification('Anchor "' + name + '" placed!', 'success');
      hideAnchorPanel();
    };
  }

  function hideAnchorPanel() {
    if (anchorPanelEl && anchorPanelEl.parentNode) {
      anchorPanelEl.parentNode.removeChild(anchorPanelEl);
      anchorPanelEl = null;
    }
  }

  exports.showAnchorPanel = showAnchorPanel;
  exports.hideAnchorPanel = hideAnchorPanel;

  var stewardPanelEl = null;

  function showStewardPanel(currentZone, playerId) {
    if (typeof document === 'undefined') return;
    hideStewardPanel();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var State = typeof window !== 'undefined' ? window.State : null;
    var liveState = State ? State.getLiveState() : {};
    var stewards = liveState.stewards || {};
    var elections = liveState.elections || {};
    var zoneSteward = stewards[currentZone];

    stewardPanelEl = document.createElement('div');
    stewardPanelEl.id = 'steward-panel';
    stewardPanelEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #DAA520;border-radius:12px;' +
      'padding:20px;width:420px;max-height:500px;overflow-y:auto;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<h2 style="color:#DAA520;margin:0;font-size:18px;">Zone Steward â€” ' + currentZone + '</h2>' +
      '<button id="steward-close" style="background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;">Ã—</button></div>';

    if (zoneSteward) {
      html += '<div style="background:rgba(218,165,32,0.1);border:1px solid #DAA520;border-radius:8px;padding:12px;margin-bottom:12px;">' +
        '<div style="color:#DAA520;font-weight:bold;">Current Steward: ' + zoneSteward.playerId + '</div>' +
        '<div style="color:#888;font-size:12px;">Elected: ' + new Date(zoneSteward.elected_at).toLocaleDateString() + '</div>' +
        '<div style="color:#888;font-size:12px;">Term ends: ' + new Date(zoneSteward.term_ends).toLocaleDateString() + '</div>';
      if (zoneSteward.welcomeMessage) {
        html += '<div style="color:#aaa;font-size:13px;margin-top:8px;font-style:italic;">"' + zoneSteward.welcomeMessage + '"</div>';
      }
      html += '</div>';
    } else {
      html += '<p style="color:#888;text-align:center;">No steward for this zone.</p>';
    }

    var activeElections = Object.values(elections).filter(function(e) {
      return e.zone === currentZone && e.status === 'active';
    });

    if (activeElections.length > 0) {
      var elec = activeElections[0];
      html += '<div style="background:rgba(68,170,255,0.1);border:1px solid #4af;border-radius:8px;padding:12px;margin-bottom:12px;">' +
        '<div style="color:#4af;font-weight:bold;">Active Election</div>' +
        '<div style="color:#888;font-size:12px;">Candidates: ' + elec.candidates.join(', ') + '</div>' +
        '<div style="color:#888;font-size:12px;">Votes cast: ' + Object.keys(elec.votes).length + '</div>';

      html += '<div style="margin-top:8px;">';
      elec.candidates.forEach(function(c) {
        html += '<button class="steward-vote-btn" data-election="' + elec.id + '" data-candidate="' + c + '" ' +
          'style="margin:2px;padding:4px 12px;background:rgba(68,170,255,0.3);color:#4af;border:1px solid #4af;' +
          'border-radius:4px;cursor:pointer;font-size:12px;">Vote: ' + c + '</button>';
      });
      html += '</div></div>';
    } else {
      html += '<button id="steward-start-election" style="width:100%;padding:10px;background:#DAA520;color:#000;border:none;' +
        'border-radius:6px;font-weight:bold;cursor:pointer;margin-top:8px;">Start Election for ' + currentZone + '</button>';
    }

    stewardPanelEl.innerHTML = html;
    hud.appendChild(stewardPanelEl);

    document.getElementById('steward-close').onclick = hideStewardPanel;

    var startBtn = document.getElementById('steward-start-election');
    if (startBtn) {
      startBtn.onclick = function() {
        if (typeof window !== 'undefined' && window._onElectionStart) {
          window._onElectionStart({ zone: currentZone });
        }
        showNotification('Election started for ' + currentZone + '!', 'success');
        hideStewardPanel();
      };
    }

    var voteBtns = stewardPanelEl.querySelectorAll('.steward-vote-btn');
    voteBtns.forEach(function(btn) {
      btn.onclick = function() {
        var electionId = btn.getAttribute('data-election');
        var candidate = btn.getAttribute('data-candidate');
        if (typeof window !== 'undefined' && window._onElectionVote) {
          window._onElectionVote({ electionId: electionId, candidate: candidate });
        }
        showNotification('Voted for ' + candidate, 'success');
        hideStewardPanel();
      };
    });
  }

  function hideStewardPanel() {
    if (stewardPanelEl && stewardPanelEl.parentNode) {
      stewardPanelEl.parentNode.removeChild(stewardPanelEl);
      stewardPanelEl = null;
    }
  }

  exports.showStewardPanel = showStewardPanel;
  exports.hideStewardPanel = hideStewardPanel;

  function showFederationProposal() {
    if (typeof document === 'undefined') return;

    var overlay = document.createElement('div');
    overlay.id = 'federation-proposal';
    overlay.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #a855f7;border-radius:12px;' +
      'padding:20px;width:400px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);';

    overlay.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<h2 style="color:#a855f7;margin:0;font-size:18px;">Propose Federation</h2>' +
      '<button id="fed-close" style="background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;">Ã—</button></div>' +
      '<p style="color:#aaa;font-size:13px;margin-bottom:12px;">Link another ZION world instance via the Rift Portal in the Nexus.</p>' +
      '<input id="fed-name" placeholder="Federation name..." style="width:100%;padding:8px;background:rgba(0,0,0,0.5);' +
      'border:1px solid #555;border-radius:4px;color:#fff;font-size:13px;margin-bottom:8px;box-sizing:border-box;" />' +
      '<input id="fed-endpoint" placeholder="Endpoint URL (e.g. https://...)" style="width:100%;padding:8px;background:rgba(0,0,0,0.5);' +
      'border:1px solid #555;border-radius:4px;color:#fff;font-size:13px;margin-bottom:12px;box-sizing:border-box;" />' +
      '<button id="fed-submit" style="width:100%;padding:10px;background:#a855f7;color:#fff;border:none;border-radius:6px;' +
      'font-weight:bold;cursor:pointer;">Propose Federation</button>';

    document.body.appendChild(overlay);

    document.getElementById('fed-close').onclick = function() { overlay.parentNode.removeChild(overlay); };
    document.getElementById('fed-submit').onclick = function() {
      var name = document.getElementById('fed-name').value.trim();
      var endpoint = document.getElementById('fed-endpoint').value.trim();
      if (!name || !endpoint) { showNotification('Fill in all fields', 'warning'); return; }
      if (typeof window !== 'undefined' && window._onFederationPropose) {
        window._onFederationPropose({ name: name, endpoint: endpoint });
      }
      showNotification('Federation "' + name + '" proposed!', 'success');
      overlay.parentNode.removeChild(overlay);
    };
  }

  exports.showFederationProposal = showFederationProposal;

  var economyVizPanelEl = null;
  var economyVizVisible = false;
  var _economyVizState = null;

  function createEconomyVizPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'economy-viz-panel';
    panel.className = 'zion-tool-panel economy-viz-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #22c55e;border-radius:12px;' +
      'padding:0;width:520px;max-height:80vh;overflow:hidden;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(34,197,94,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#128200;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#22c55e;flex:1;">Economy Visualizer</span>' +
      '<button id="economy-viz-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:16px;overflow-y:auto;flex:1;';

    if (typeof EconomyViz === 'undefined') {
      body.innerHTML = '<div style="text-align:center;color:#888;padding:40px;">Module not loaded: EconomyViz</div>';
      panel.appendChild(body);
      return panel;
    }

    var summaryEl = document.createElement('div');
    summaryEl.id = 'economy-viz-summary';
    summaryEl.style.cssText = 'background:rgba(34,197,94,0.08);border:1px solid rgba(34,197,94,0.2);' +
      'border-radius:8px;padding:10px 14px;margin-bottom:14px;font-size:12px;color:#ccc;line-height:1.6;';
    summaryEl.textContent = 'Loading economy data...';
    body.appendChild(summaryEl);

    var giniRow = document.createElement('div');
    giniRow.style.cssText = 'display:flex;align-items:center;gap:12px;margin-bottom:14px;';
    giniRow.innerHTML = '<span style="font-size:12px;color:#888;">Gini Coefficient</span>' +
      '<div id="economy-gini-bar" style="flex:1;height:8px;background:#333;border-radius:4px;overflow:hidden;">' +
      '<div id="economy-gini-fill" style="height:100%;width:0%;background:#22c55e;border-radius:4px;transition:width 0.5s,background 0.5s;"></div></div>' +
      '<span id="economy-gini-val" style="font-size:13px;font-weight:bold;color:#22c55e;min-width:36px;text-align:right;">0.00</span>';
    body.appendChild(giniRow);

    var canvasWrap = document.createElement('div');
    canvasWrap.style.cssText = 'background:#0a0e1a;border-radius:8px;margin-bottom:14px;overflow:hidden;';
    var flowCanvas = document.createElement('canvas');
    flowCanvas.id = 'economy-flow-canvas';
    flowCanvas.width = 480;
    flowCanvas.height = 200;
    flowCanvas.style.cssText = 'display:block;width:100%;height:auto;';
    canvasWrap.appendChild(flowCanvas);
    body.appendChild(canvasWrap);

    var distEl = document.createElement('div');
    distEl.id = 'economy-dist-chart';
    distEl.style.cssText = 'background:#0a0e1a;border-radius:8px;padding:12px;min-height:80px;';
    distEl.innerHTML = '<div style="font-size:11px;color:#666;margin-bottom:6px;text-transform:uppercase;letter-spacing:0.05em;">Wealth Distribution</div>' +
      '<div id="economy-dist-bars" style="display:flex;align-items:flex-end;gap:3px;height:60px;"></div>';
    body.appendChild(distEl);

    var refreshBtn = document.createElement('button');
    refreshBtn.textContent = 'Refresh';
    refreshBtn.style.cssText = 'margin-top:12px;width:100%;padding:8px;background:rgba(34,197,94,0.15);' +
      'border:1px solid rgba(34,197,94,0.4);border-radius:6px;color:#22c55e;font-size:12px;cursor:pointer;';
    refreshBtn.onclick = function() { refreshEconomyVizPanel(); };
    body.appendChild(refreshBtn);

    panel.appendChild(body);
    return panel;
  }

  function _economyVizRenderGini(gini) {
    var fillEl = document.getElementById('economy-gini-fill');
    var valEl = document.getElementById('economy-gini-val');
    if (!fillEl || !valEl) return;
    var pct = Math.round(gini * 100);
    var color = gini < 0.3 ? '#22c55e' : gini < 0.55 ? '#facc15' : '#ef4444';
    fillEl.style.width = pct + '%';
    fillEl.style.background = color;
    valEl.textContent = gini.toFixed(2);
    valEl.style.color = color;
  }

  function _economyVizRenderDistBars(distribution) {
    var barsEl = document.getElementById('economy-dist-bars');
    if (!barsEl || !distribution || !distribution.length) return;
    var max = 1;
    for (var i = 0; i < distribution.length; i++) {
      if (distribution[i] > max) max = distribution[i];
    }
    barsEl.innerHTML = '';
    var colors = ['#22c55e', '#4ade80', '#86efac', '#bbf7d0', '#dcfce7'];
    for (var j = 0; j < distribution.length; j++) {
      var bar = document.createElement('div');
      var hPct = Math.max(4, Math.round((distribution[j] / max) * 100));
      bar.style.cssText = 'flex:1;border-radius:3px 3px 0 0;background:' +
        (colors[j % colors.length]) + ';height:' + hPct + '%;title="' + distribution[j] + '"';
      bar.title = 'Quintile ' + (j + 1) + ': ' + distribution[j];
      barsEl.appendChild(bar);
    }
  }

  function refreshEconomyVizPanel() {
    if (!economyVizPanelEl) return;

    var EV = typeof EconomyViz !== 'undefined' ? EconomyViz : null;
    if (!EV) {
      var summaryEl = document.getElementById('economy-viz-summary');
      if (summaryEl) summaryEl.textContent = 'Module not loaded: EconomyViz';
      return;
    }

    var State = typeof window !== 'undefined' ? window.State : null;
    var state = (State && State.getLiveState) ? State.getLiveState() : (_economyVizState || {});

    var summaryEl = document.getElementById('economy-viz-summary');
    if (summaryEl) {
      try {
        summaryEl.textContent = EV.formatSummary(state);
      } catch (e) {
        summaryEl.textContent = 'Economy data unavailable';
      }
    }

    var canvas = document.getElementById('economy-flow-canvas');
    if (canvas) {
      try {
        EV.init(canvas);
        EV.loadState(state);
        EV.render();
      } catch (e) {
        var ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#555';
          ctx.font = '13px monospace';
          ctx.fillText('Flow data unavailable', 12, 30);
        }
      }
    }

    try {
      var balances = (state.economy && state.economy.balances) ? state.economy.balances :
                     (state.balances ? state.balances : {});
      var gini = EV.computeGini(balances);
      _economyVizRenderGini(gini);
      var distribution = EV.computeDistribution(balances);
      _economyVizRenderDistBars(distribution);
    } catch (e) {
      _economyVizRenderGini(0);
    }
  }

  function showEconomyVizPanel(state) {
    if (typeof document === 'undefined') return;
    if (!economyVizPanelEl) {
      economyVizPanelEl = createEconomyVizPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && economyVizPanelEl) hud.appendChild(economyVizPanelEl);
    }
    if (!economyVizPanelEl) return;
    _economyVizState = state || null;
    economyVizPanelEl.style.display = 'flex';
    economyVizVisible = true;

    var closeBtn = document.getElementById('economy-viz-close');
    if (closeBtn) closeBtn.onclick = hideEconomyVizPanel;

    refreshEconomyVizPanel();
  }

  function hideEconomyVizPanel() {
    if (economyVizPanelEl) {
      economyVizPanelEl.style.display = 'none';
    }
    economyVizVisible = false;
  }

  function toggleEconomyVizPanel(state) {
    if (economyVizVisible) {
      hideEconomyVizPanel();
    } else {
      showEconomyVizPanel(state);
    }
  }

  exports.createEconomyVizPanel = createEconomyVizPanel;
  exports.showEconomyVizPanel = showEconomyVizPanel;
  exports.hideEconomyVizPanel = hideEconomyVizPanel;
  exports.toggleEconomyVizPanel = toggleEconomyVizPanel;
  exports.refreshEconomyVizPanel = refreshEconomyVizPanel;

  var yamlInspectorPanelEl = null;
  var yamlInspectorVisible = false;
  var _yamlInspectorTree = null;
  var _yamlInspectorSource = 'world';

  var YAML_SOURCES = ['world', 'economy', 'gardens', 'structures', 'chat'];

  function _getYamlSourceData(source) {
    var State = typeof window !== 'undefined' ? window.State : null;
    var liveState = (State && State.getLiveState) ? State.getLiveState() : {};
    switch (source) {
      case 'world':     return liveState;
      case 'economy':   return liveState.economy || {};
      case 'gardens':   return liveState.gardens || {};
      case 'structures':return liveState.structures || {};
      case 'chat':      return liveState.chat || [];
      default:          return liveState;
    }
  }

  function createYamlInspectorPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'yaml-inspector-panel';
    panel.className = 'zion-tool-panel yaml-inspector-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #818cf8;border-radius:12px;' +
      'padding:0;width:560px;height:600px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(129,140,248,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#128269;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#818cf8;flex:1;">State Inspector</span>' +
      '<button id="yaml-inspector-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    var toolbar = document.createElement('div');
    toolbar.style.cssText = 'display:flex;gap:8px;padding:10px 16px;border-bottom:1px solid rgba(129,140,248,0.15);flex-shrink:0;';

    var searchInput = document.createElement('input');
    searchInput.id = 'yaml-inspector-search';
    searchInput.type = 'text';
    searchInput.placeholder = 'Filter keys/values...';
    searchInput.style.cssText = 'flex:1;background:rgba(0,0,0,0.5);border:1px solid rgba(129,140,248,0.4);' +
      'border-radius:6px;padding:6px 10px;color:#e0e0e0;font-size:12px;font-family:monospace;outline:none;';

    var sourceSelect = document.createElement('select');
    sourceSelect.id = 'yaml-inspector-source';
    sourceSelect.style.cssText = 'background:rgba(0,0,0,0.5);border:1px solid rgba(129,140,248,0.4);' +
      'border-radius:6px;padding:6px 10px;color:#818cf8;font-size:12px;cursor:pointer;outline:none;';
    YAML_SOURCES.forEach(function(src) {
      var opt = document.createElement('option');
      opt.value = src;
      opt.textContent = src;
      if (src === _yamlInspectorSource) opt.selected = true;
      sourceSelect.appendChild(opt);
    });

    toolbar.appendChild(searchInput);
    toolbar.appendChild(sourceSelect);
    panel.appendChild(toolbar);

    if (typeof YamlDash === 'undefined') {
      var guardMsg = document.createElement('div');
      guardMsg.style.cssText = 'text-align:center;color:#888;padding:40px;';
      guardMsg.textContent = 'Module not loaded: YamlDash';
      panel.appendChild(guardMsg);
      return panel;
    }

    var treeWrap = document.createElement('div');
    treeWrap.id = 'yaml-inspector-tree';
    treeWrap.style.cssText = 'flex:1;overflow-y:auto;padding:12px 16px;font-family:monospace;font-size:12px;' +
      'color:#e0e0e0;line-height:1.7;white-space:pre;';
    treeWrap.textContent = 'Loading...';
    panel.appendChild(treeWrap);

    panel._searchInput = searchInput;
    panel._sourceSelect = sourceSelect;

    return panel;
  }

  function _yamlInspectorRender() {
    if (!yamlInspectorPanelEl) return;
    var YD = typeof YamlDash !== 'undefined' ? YamlDash : null;
    if (!YD) return;

    var treeEl = document.getElementById('yaml-inspector-tree');
    if (!treeEl) return;

    var query = document.getElementById('yaml-inspector-search');
    var queryVal = query ? query.value.trim() : '';

    var displayTree = _yamlInspectorTree;
    if (queryVal && displayTree) {
      try {
        displayTree = YD.filterTree(displayTree, queryVal);
      } catch (e) { /* noop */ }
    }

    if (!displayTree) {
      treeEl.textContent = queryVal ? 'No matches found.' : 'No data.';
      return;
    }

    try {
      treeEl.textContent = YD.renderToText(displayTree);
    } catch (e) {
      treeEl.textContent = 'Render error: ' + e.message;
    }

    treeEl.onclick = function(e) {
      if (!_yamlInspectorTree) return;
      var target = e.target;
      var path = target.getAttribute && target.getAttribute('data-path');
      if (!path) {
        var line = target.textContent || '';
        var match = line.match(/^\s*([\w\.\[\]]+)/);
        if (match) path = match[1];
      }
      if (path) {
        try { YD.toggleNode(_yamlInspectorTree, path); } catch (ex) { /* noop */ }
        _yamlInspectorRender();
      }
    };
  }

  function _yamlInspectorLoad(source) {
    var YD = typeof YamlDash !== 'undefined' ? YamlDash : null;
    if (!YD) return;
    _yamlInspectorSource = source || _yamlInspectorSource;
    var data = _getYamlSourceData(_yamlInspectorSource);
    try {
      _yamlInspectorTree = YD.buildTree(data, _yamlInspectorSource);
    } catch (e) {
      _yamlInspectorTree = null;
    }
    _yamlInspectorRender();
  }

  function showYamlInspectorPanel() {
    if (typeof document === 'undefined') return;
    if (!yamlInspectorPanelEl) {
      yamlInspectorPanelEl = createYamlInspectorPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && yamlInspectorPanelEl) hud.appendChild(yamlInspectorPanelEl);
    }
    if (!yamlInspectorPanelEl) return;
    yamlInspectorPanelEl.style.display = 'flex';
    yamlInspectorVisible = true;

    var closeBtn = document.getElementById('yaml-inspector-close');
    if (closeBtn) closeBtn.onclick = hideYamlInspectorPanel;

    var searchInput = document.getElementById('yaml-inspector-search');
    if (searchInput) {
      searchInput.oninput = function() { _yamlInspectorRender(); };
    }

    var sourceSelect = document.getElementById('yaml-inspector-source');
    if (sourceSelect) {
      sourceSelect.onchange = function() {
        _yamlInspectorLoad(sourceSelect.value);
      };
    }

    _yamlInspectorLoad(_yamlInspectorSource);
  }

  function hideYamlInspectorPanel() {
    if (yamlInspectorPanelEl) {
      yamlInspectorPanelEl.style.display = 'none';
    }
    yamlInspectorVisible = false;
  }

  function toggleYamlInspectorPanel() {
    if (yamlInspectorVisible) {
      hideYamlInspectorPanel();
    } else {
      showYamlInspectorPanel();
    }
  }

  exports.createYamlInspectorPanel = createYamlInspectorPanel;
  exports.showYamlInspectorPanel = showYamlInspectorPanel;
  exports.hideYamlInspectorPanel = hideYamlInspectorPanel;
  exports.toggleYamlInspectorPanel = toggleYamlInspectorPanel;

  var replayPanelEl = null;
  var replayPanelVisible = false;
  var _replayState = 'idle'; // idle | recording | stopped | playing | paused
  var _replayRecorder = null;
  var _replayPlayer = null;
  var _replayRecording = null;
  var _replayUpdateInterval = null;

  function createReplayPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'replay-panel';
    panel.className = 'zion-tool-panel replay-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #f472b6;border-radius:12px;' +
      'padding:0;width:460px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(244,114,182,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#9654;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#f472b6;flex:1;">Protocol Replay</span>' +
      '<button id="replay-panel-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:16px;';

    if (typeof Replay === 'undefined') {
      body.innerHTML = '<div style="text-align:center;color:#888;padding:40px;">Module not loaded: Replay</div>';
      panel.appendChild(body);
      return panel;
    }

    var statusEl = document.createElement('div');
    statusEl.id = 'replay-status';
    statusEl.style.cssText = 'text-align:center;padding:8px;margin-bottom:12px;border-radius:6px;font-size:12px;' +
      'background:rgba(244,114,182,0.08);border:1px solid rgba(244,114,182,0.2);color:#f472b6;font-weight:bold;';
    statusEl.textContent = 'IDLE';
    body.appendChild(statusEl);

    var btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:8px;margin-bottom:14px;justify-content:center;';

    var recordBtn = document.createElement('button');
    recordBtn.id = 'replay-record-btn';
    recordBtn.style.cssText = 'padding:8px 16px;background:rgba(239,68,68,0.15);border:1px solid #ef4444;' +
      'border-radius:6px;color:#ef4444;font-size:13px;cursor:pointer;font-weight:bold;';
    recordBtn.innerHTML = '&#9679; Record';
    recordBtn.onclick = function() { _replayStartRecording(); };

    var stopBtn = document.createElement('button');
    stopBtn.id = 'replay-stop-btn';
    stopBtn.style.cssText = 'padding:8px 16px;background:rgba(100,100,100,0.15);border:1px solid #666;' +
      'border-radius:6px;color:#666;font-size:13px;cursor:pointer;';
    stopBtn.innerHTML = '&#9632; Stop';
    stopBtn.onclick = function() { _replayStop(); };

    var playBtn = document.createElement('button');
    playBtn.id = 'replay-play-btn';
    playBtn.style.cssText = 'padding:8px 16px;background:rgba(34,197,94,0.15);border:1px solid rgba(34,197,94,0.4);' +
      'border-radius:6px;color:#22c55e;font-size:13px;cursor:pointer;';
    playBtn.innerHTML = '&#9654; Play';
    playBtn.onclick = function() { _replayPlayPause(); };

    btnRow.appendChild(recordBtn);
    btnRow.appendChild(stopBtn);
    btnRow.appendChild(playBtn);
    body.appendChild(btnRow);

    var progressEl = document.createElement('div');
    progressEl.id = 'replay-progress-text';
    progressEl.style.cssText = 'text-align:center;font-size:12px;color:#888;margin-bottom:10px;font-family:monospace;';
    progressEl.textContent = 'Message 0/0 â€” 00:00/00:00';
    body.appendChild(progressEl);

    var seekSlider = document.createElement('input');
    seekSlider.id = 'replay-seek';
    seekSlider.type = 'range';
    seekSlider.min = '0';
    seekSlider.max = '100';
    seekSlider.value = '0';
    seekSlider.style.cssText = 'width:100%;margin-bottom:14px;accent-color:#f472b6;cursor:pointer;';
    seekSlider.oninput = function() {
      if (_replayPlayer && (_replayState === 'playing' || _replayState === 'paused')) {
        try {
          var pos = parseInt(seekSlider.value, 10) / 100;
          var rec = _replayRecording;
          if (rec && rec.messages && rec.messages.length) {
            var idx = Math.floor(pos * (rec.messages.length - 1));
            _replayPlayer.seek(idx);
            _updateReplayProgress();
          }
        } catch (e) { /* noop */ }
      }
    };
    body.appendChild(seekSlider);

    var speedRow = document.createElement('div');
    speedRow.style.cssText = 'display:flex;align-items:center;gap:10px;margin-bottom:14px;';
    speedRow.innerHTML = '<span style="font-size:12px;color:#888;">Speed:</span>';
    [0.5, 1, 2, 5, 10].forEach(function(spd) {
      var btn = document.createElement('button');
      btn.textContent = spd + 'x';
      btn.setAttribute('data-speed', spd);
      btn.style.cssText = 'padding:4px 10px;background:rgba(244,114,182,' + (spd === 1 ? '0.25' : '0.08') + ');' +
        'border:1px solid rgba(244,114,182,' + (spd === 1 ? '0.6' : '0.2') + ');' +
        'border-radius:4px;color:#f472b6;font-size:11px;cursor:pointer;';
      btn.onclick = function() {
        speedRow.querySelectorAll('[data-speed]').forEach(function(b) {
          b.style.background = 'rgba(244,114,182,0.08)';
          b.style.borderColor = 'rgba(244,114,182,0.2)';
        });
        btn.style.background = 'rgba(244,114,182,0.25)';
        btn.style.borderColor = 'rgba(244,114,182,0.6)';
        if (_replayPlayer) {
          try { _replayPlayer.setSpeed(spd); } catch (e) { /* noop */ }
        }
      };
      speedRow.appendChild(btn);
    });
    body.appendChild(speedRow);

    var exportBtn = document.createElement('button');
    exportBtn.id = 'replay-export-btn';
    exportBtn.textContent = 'Export Recording';
    exportBtn.style.cssText = 'width:100%;padding:8px;background:rgba(129,140,248,0.12);' +
      'border:1px solid rgba(129,140,248,0.3);border-radius:6px;color:#818cf8;font-size:12px;cursor:pointer;';
    exportBtn.onclick = function() { _replayExport(); };
    body.appendChild(exportBtn);

    panel.appendChild(body);
    return panel;
  }

  function _updateReplayProgress() {
    var progressEl = document.getElementById('replay-progress-text');
    var seekEl = document.getElementById('replay-seek');
    if (!progressEl) return;

    var rec = _replayRecording;
    if (!rec || !rec.messages || !rec.messages.length) {
      progressEl.textContent = 'Message 0/0 â€” 00:00/00:00';
      return;
    }

    var total = rec.messages.length;
    var current = 0;
    if (_replayPlayer) {
      try { current = _replayPlayer.currentIndex() || 0; } catch (e) { current = 0; }
    }

    var elapsed = 0;
    var duration = 0;
    if (rec.messages.length > 1) {
      var t0 = rec.messages[0].ts || 0;
      var tEnd = rec.messages[rec.messages.length - 1].ts || 0;
      var tCur = rec.messages[current] ? (rec.messages[current].ts || t0) : t0;
      duration = (tEnd - t0) / 1000;
      elapsed = (tCur - t0) / 1000;
    }

    function fmtTime(s) {
      s = Math.max(0, Math.round(s));
      return String(Math.floor(s / 60)).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0');
    }

    progressEl.textContent = 'Message ' + (current + 1) + '/' + total + ' â€” ' + fmtTime(elapsed) + '/' + fmtTime(duration);

    if (seekEl) {
      seekEl.value = total > 1 ? Math.round((current / (total - 1)) * 100) : 0;
    }
  }

  function _replaySetStatus(status, color) {
    var statusEl = document.getElementById('replay-status');
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.style.color = color || '#f472b6';
    }
  }

  function _replayStartRecording() {
    var R = typeof Replay !== 'undefined' ? Replay : null;
    if (!R) { showNotification('Replay module not loaded', 'error'); return; }
    if (_replayState === 'recording') { showNotification('Already recording', 'warning'); return; }

    try {
      _replayRecorder = R.createRecorder();
      _replayState = 'recording';
      _replayRecording = null;
      _replaySetStatus('RECORDING', '#ef4444');
      showNotification('Protocol recording started', 'info');
    } catch (e) {
      showNotification('Failed to start recording: ' + e.message, 'error');
    }
  }

  function _replayStop() {
    if (_replayState === 'recording' && _replayRecorder) {
      try {
        _replayRecording = _replayRecorder.stop ? _replayRecorder.stop() : _replayRecorder;
        _replayState = 'stopped';
        _replaySetStatus('STOPPED', '#facc15');
        showNotification('Recording stopped', 'success');
      } catch (e) {
        showNotification('Failed to stop recording: ' + e.message, 'error');
      }
    } else if (_replayState === 'playing' || _replayState === 'paused') {
      if (_replayPlayer) {
        try { _replayPlayer.stop(); } catch (e) { /* noop */ }
      }
      if (_replayUpdateInterval) { clearInterval(_replayUpdateInterval); _replayUpdateInterval = null; }
      _replayState = 'stopped';
      _replaySetStatus('STOPPED', '#facc15');
    }
  }

  function _replayPlayPause() {
    var R = typeof Replay !== 'undefined' ? Replay : null;
    if (!R) { showNotification('Replay module not loaded', 'error'); return; }

    if (_replayState === 'idle' || (!_replayRecording && _replayState !== 'playing' && _replayState !== 'paused')) {
      showNotification('No recording available. Record first.', 'warning');
      return;
    }

    if (_replayState === 'stopped' || _replayState === 'recording') {
      if (_replayState === 'recording') _replayStop();
      if (!_replayRecording) { showNotification('No recording to play', 'warning'); return; }

      try {
        _replayPlayer = R.createPlayer(_replayRecording);
        _replayPlayer.play();
        _replayState = 'playing';
        _replaySetStatus('PLAYING', '#22c55e');

        var playBtn = document.getElementById('replay-play-btn');
        if (playBtn) playBtn.innerHTML = '&#9646;&#9646; Pause';

        _replayUpdateInterval = setInterval(function() {
          _updateReplayProgress();
          if (_replayPlayer && _replayPlayer.ended && _replayPlayer.ended()) {
            clearInterval(_replayUpdateInterval);
            _replayUpdateInterval = null;
            _replayState = 'stopped';
            _replaySetStatus('STOPPED', '#facc15');
            var pb = document.getElementById('replay-play-btn');
            if (pb) pb.innerHTML = '&#9654; Play';
          }
        }, 250);
      } catch (e) {
        showNotification('Failed to play recording: ' + e.message, 'error');
      }
    } else if (_replayState === 'playing') {
      if (_replayPlayer) {
        try { _replayPlayer.pause(); } catch (e) { /* noop */ }
      }
      _replayState = 'paused';
      _replaySetStatus('PAUSED', '#facc15');
      var playBtn = document.getElementById('replay-play-btn');
      if (playBtn) playBtn.innerHTML = '&#9654; Play';
    } else if (_replayState === 'paused') {
      if (_replayPlayer) {
        try { _replayPlayer.play(); } catch (e) { /* noop */ }
      }
      _replayState = 'playing';
      _replaySetStatus('PLAYING', '#22c55e');
      var playBtnResume = document.getElementById('replay-play-btn');
      if (playBtnResume) playBtnResume.innerHTML = '&#9646;&#9646; Pause';
    }
  }

  function _replayExport() {
    if (!_replayRecording) {
      showNotification('No recording to export. Record something first.', 'warning');
      return;
    }
    try {
      var jsonStr = JSON.stringify(_replayRecording, null, 2);
      var blob = new Blob([jsonStr], { type: 'application/json' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'zion-replay-' + Date.now() + '.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification('Recording exported!', 'success');
    } catch (e) {
      showNotification('Export failed: ' + e.message, 'error');
    }
  }

  function showReplayPanel() {
    if (typeof document === 'undefined') return;
    if (!replayPanelEl) {
      replayPanelEl = createReplayPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && replayPanelEl) hud.appendChild(replayPanelEl);
    }
    if (!replayPanelEl) return;
    replayPanelEl.style.display = 'flex';
    replayPanelVisible = true;

    var closeBtn = document.getElementById('replay-panel-close');
    if (closeBtn) closeBtn.onclick = hideReplayPanel;

    _updateReplayProgress();
  }

  function hideReplayPanel() {
    if (replayPanelEl) {
      replayPanelEl.style.display = 'none';
    }
    replayPanelVisible = false;
  }

  function toggleReplayPanel() {
    if (replayPanelVisible) {
      hideReplayPanel();
    } else {
      showReplayPanel();
    }
  }

  function getReplayState() {
    return _replayState;
  }

  exports.createReplayPanel = createReplayPanel;
  exports.showReplayPanel = showReplayPanel;
  exports.hideReplayPanel = hideReplayPanel;
  exports.toggleReplayPanel = toggleReplayPanel;
  exports.getReplayState = getReplayState;

  var nearbyAnchorsPanelEl = null;
  var nearbyAnchorsPanelVisible = false;
  var _nearbyAnchorsGeo = null;
  var _nearbyAnchorsEnabled = false;

  function createNearbyAnchorsPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'nearby-anchors-panel';
    panel.className = 'zion-tool-panel nearby-anchors-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #38bdf8;border-radius:12px;' +
      'padding:0;width:440px;max-height:600px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(56,189,248,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#127981;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#38bdf8;flex:1;">Nearby Anchors</span>' +
      '<button id="nearby-anchors-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:16px;overflow-y:auto;flex:1;';

    if (typeof Anchors === 'undefined') {
      body.innerHTML = '<div style="text-align:center;color:#888;padding:40px;">Module not loaded: Anchors</div>';
      panel.appendChild(body);
      return panel;
    }

    var locationSection = document.createElement('div');
    locationSection.id = 'nearby-location-section';
    locationSection.style.cssText = 'margin-bottom:14px;';

    var enableBtn = document.createElement('button');
    enableBtn.id = 'nearby-enable-location';
    enableBtn.textContent = 'Enable Location';
    enableBtn.style.cssText = 'width:100%;padding:10px;background:rgba(56,189,248,0.15);' +
      'border:1px solid rgba(56,189,248,0.4);border-radius:8px;color:#38bdf8;font-size:13px;cursor:pointer;font-weight:bold;';
    enableBtn.onclick = function() { _nearbyAnchorsRequestLocation(); };
    locationSection.appendChild(enableBtn);

    var locationStatus = document.createElement('div');
    locationStatus.id = 'nearby-location-status';
    locationStatus.style.cssText = 'font-size:11px;color:#888;text-align:center;margin-top:6px;';
    locationStatus.textContent = 'Location not enabled';
    locationSection.appendChild(locationStatus);

    body.appendChild(locationSection);

    var safetyEl = document.createElement('div');
    safetyEl.id = 'nearby-safety-warning';
    safetyEl.style.cssText = 'background:rgba(251,191,36,0.08);border:1px solid rgba(251,191,36,0.3);' +
      'border-radius:8px;padding:10px;margin-bottom:14px;font-size:11px;color:#fbbf24;display:none;';
    body.appendChild(safetyEl);

    var warmthEl = document.createElement('div');
    warmthEl.id = 'nearby-warmth';
    warmthEl.style.cssText = 'display:none;background:rgba(56,189,248,0.08);border:1px solid rgba(56,189,248,0.2);' +
      'border-radius:8px;padding:10px;margin-bottom:14px;';
    warmthEl.innerHTML = '<div style="font-size:11px;color:#888;margin-bottom:4px;text-transform:uppercase;letter-spacing:0.05em;">Walking Warmth</div>' +
      '<div id="nearby-warmth-value" style="font-size:22px;font-weight:bold;color:#38bdf8;">0</div>' +
      '<div style="font-size:11px;color:#666;margin-top:2px;">anchors discovered on foot</div>';
    body.appendChild(warmthEl);

    var listSection = document.createElement('div');
    listSection.id = 'nearby-anchor-list';
    listSection.innerHTML = '<div style="text-align:center;color:#666;font-size:12px;padding:20px;">Enable location to discover nearby anchors</div>';
    body.appendChild(listSection);

    panel.appendChild(body);
    return panel;
  }

  function _nearbyAnchorsRequestLocation() {
    var A = typeof Anchors !== 'undefined' ? Anchors : null;
    if (!A) { showNotification('Anchors module not loaded', 'error'); return; }

    var statusEl = document.getElementById('nearby-location-status');
    var enableBtn = document.getElementById('nearby-enable-location');
    if (statusEl) statusEl.textContent = 'Requesting location...';

    try {
      A.requestLocation(function(result) {
        if (result && result.geo) {
          _nearbyAnchorsGeo = result.geo;
          _nearbyAnchorsEnabled = true;
          if (statusEl) statusEl.textContent = 'Location enabled: ' +
            result.geo.lat.toFixed(4) + ', ' + result.geo.lon.toFixed(4);
          if (enableBtn) {
            enableBtn.textContent = 'Location Active';
            enableBtn.style.background = 'rgba(34,197,94,0.15)';
            enableBtn.style.borderColor = 'rgba(34,197,94,0.4)';
            enableBtn.style.color = '#22c55e';
          }
          var warmthEl = document.getElementById('nearby-warmth');
          if (warmthEl) warmthEl.style.display = 'block';

          var safetyEl = document.getElementById('nearby-safety-warning');
          if (safetyEl && A.SAFETY && A.SAFETY.getWarningMessage) {
            var warning = A.SAFETY.getWarningMessage(result.geo);
            if (warning) {
              safetyEl.textContent = '&#9888; ' + warning;
              safetyEl.style.display = 'block';
            }
          }

          _nearbyAnchorsRefresh();
        } else {
          _nearbyAnchorsEnabled = false;
          if (statusEl) statusEl.textContent = 'Location denied or unavailable';
          if (enableBtn) {
            enableBtn.textContent = 'Enable Location';
          }
          showNotification('Location access denied', 'warning');
        }
      });
    } catch (e) {
      if (statusEl) statusEl.textContent = 'Location error: ' + e.message;
      _nearbyAnchorsEnabled = false;
      showNotification('Location request failed: ' + e.message, 'error');
    }
  }

  function _nearbyAnchorsRefresh() {
    var A = typeof Anchors !== 'undefined' ? Anchors : null;
    if (!A || !_nearbyAnchorsGeo) return;

    var listEl = document.getElementById('nearby-anchor-list');
    if (!listEl) return;

    var State = typeof window !== 'undefined' ? window.State : null;
    var allAnchors = [];
    if (State && State.getLiveState) {
      var liveState = State.getLiveState();
      if (liveState && liveState.anchors) {
        allAnchors = Object.values(liveState.anchors);
      }
    }

    var nearby = [];
    try {
      nearby = A.getNearby(_nearbyAnchorsGeo, allAnchors, 500) || [];
    } catch (e) { nearby = []; }

    nearby.sort(function(a, b) {
      var dA = 9999, dB = 9999;
      try { dA = A.getDistance(_nearbyAnchorsGeo.lat, _nearbyAnchorsGeo.lon, a.geo.lat, a.geo.lon); } catch (ex) {}
      try { dB = A.getDistance(_nearbyAnchorsGeo.lat, _nearbyAnchorsGeo.lon, b.geo.lat, b.geo.lon); } catch (ex) {}
      return dA - dB;
    });

    var warmthVal = document.getElementById('nearby-warmth-value');
    if (warmthVal) warmthVal.textContent = nearby.length;

    var typeIcons = {};
    try {
      if (A.TYPES) {
        typeIcons = A.TYPES;
      }
    } catch (e) {}

    if (nearby.length === 0) {
      listEl.innerHTML = '<div style="text-align:center;color:#666;font-size:12px;padding:20px;">No anchors within 500m</div>';
      return;
    }

    var html = '<div style="font-size:11px;color:#888;text-transform:uppercase;letter-spacing:0.05em;margin-bottom:8px;">' +
      nearby.length + ' anchor' + (nearby.length !== 1 ? 's' : '') + ' nearby</div>';

    nearby.forEach(function(anchor) {
      var dist = 0;
      try {
        dist = Math.round(A.getDistance(_nearbyAnchorsGeo.lat, _nearbyAnchorsGeo.lon,
          anchor.geo.lat, anchor.geo.lon));
      } catch (e) {}
      var typeIcon = (anchor.type && typeIcons[anchor.type]) ? typeIcons[anchor.type] : '&#127981;';
      var inRange = false;
      try { inRange = A.isInRange(_nearbyAnchorsGeo, anchor); } catch (ex) {}

      html += '<div class="nearby-anchor-card" style="display:flex;align-items:center;gap:10px;' +
        'padding:10px;margin-bottom:8px;background:rgba(' + (inRange ? '56,189,248' : '255,255,255') +
        ',0.04);border:1px solid rgba(' + (inRange ? '56,189,248' : '255,255,255') + ',0.12);' +
        'border-radius:8px;transition:background 0.2s;">' +
        '<div style="font-size:22px;width:32px;text-align:center;">' + typeIcon + '</div>' +
        '<div style="flex:1;">' +
        '<div style="font-size:13px;color:#e0e0e0;font-weight:bold;">' + (anchor.name || 'Unnamed Anchor') + '</div>' +
        '<div style="font-size:11px;color:#666;">' + (anchor.zone || 'unknown zone') + '</div>' +
        '</div>' +
        '<div style="text-align:right;font-size:12px;">' +
        '<div style="color:' + (dist < 100 ? '#22c55e' : dist < 300 ? '#38bdf8' : '#888') + ';font-weight:bold;">' +
        dist + 'm</div>' +
        (inRange ? '<div style="font-size:10px;color:#22c55e;">IN RANGE</div>' : '') +
        '</div></div>';
    });

    listEl.innerHTML = html;
  }

  function showNearbyAnchorsPanel() {
    if (typeof document === 'undefined') return;
    if (!nearbyAnchorsPanelEl) {
      nearbyAnchorsPanelEl = createNearbyAnchorsPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && nearbyAnchorsPanelEl) hud.appendChild(nearbyAnchorsPanelEl);
    }
    if (!nearbyAnchorsPanelEl) return;
    nearbyAnchorsPanelEl.style.display = 'flex';
    nearbyAnchorsPanelVisible = true;

    var closeBtn = document.getElementById('nearby-anchors-close');
    if (closeBtn) closeBtn.onclick = hideNearbyAnchorsPanel;

    if (_nearbyAnchorsEnabled && _nearbyAnchorsGeo) {
      _nearbyAnchorsRefresh();
    }
  }

  function hideNearbyAnchorsPanel() {
    if (nearbyAnchorsPanelEl) {
      nearbyAnchorsPanelEl.style.display = 'none';
    }
    nearbyAnchorsPanelVisible = false;
  }

  function toggleNearbyAnchorsPanel() {
    if (nearbyAnchorsPanelVisible) {
      hideNearbyAnchorsPanel();
    } else {
      showNearbyAnchorsPanel();
    }
  }

  exports.createNearbyAnchorsPanel = createNearbyAnchorsPanel;
  exports.showNearbyAnchorsPanel = showNearbyAnchorsPanel;
  exports.hideNearbyAnchorsPanel = hideNearbyAnchorsPanel;
  exports.toggleNearbyAnchorsPanel = toggleNearbyAnchorsPanel;

  var amendmentPanelEl = null;
  var amendmentPanelVisible = false;
  var amendmentCallback = null;
  var _amendmentActiveTab = 'active'; // 'active' | 'propose' | 'history'

  function initAmendmentPanel(callback) {
    amendmentCallback = callback || null;
  }

  function _amendmentCountdown(closingDateStr) {
    var now = Date.now();
    var closes = new Date(closingDateStr).getTime();
    var diff = closes - now;
    if (!isFinite(diff) || diff <= 0) return 'Voting closed';
    var days = Math.floor(diff / 86400000);
    var hours = Math.floor((diff % 86400000) / 3600000);
    if (days > 0) return days + 'd ' + hours + 'h remaining';
    var mins = Math.floor((diff % 3600000) / 60000);
    if (hours > 0) return hours + 'h ' + mins + 'm remaining';
    return mins + 'm remaining';
  }

  function _amendmentTally(votes) {
    var forWeight = 0;
    var againstWeight = 0;
    var i;
    for (i = 0; i < votes.length; i++) {
      var v = votes[i];
      var w = v.spark_weight || 1;
      if (v.vote === 'for') forWeight += w;
      else if (v.vote === 'against') againstWeight += w;
    }
    var total = forWeight + againstWeight;
    var pct = total > 0 ? Math.round((forWeight / total) * 100) : 0;
    return { forWeight: forWeight, againstWeight: againstWeight, total: total, pct: pct };
  }

  function _amendmentTabBar(activeTab) {
    var tabs = [
      { id: 'active', label: 'Active Votes' },
      { id: 'propose', label: 'Propose' },
      { id: 'history', label: 'History' }
    ];
    var html = '<div style="display:flex;gap:4px;margin-bottom:16px;border-bottom:1px solid rgba(218,165,32,0.25);padding-bottom:8px;">';
    tabs.forEach(function(tab) {
      var isActive = tab.id === activeTab;
      html += '<button class="amend-tab-btn" data-tab="' + tab.id + '" style="padding:6px 16px;border:none;border-radius:6px 6px 0 0;cursor:pointer;font-size:13px;font-weight:bold;' +
        (isActive
          ? 'background:rgba(218,165,32,0.25);color:#daa520;border-bottom:2px solid #daa520;'
          : 'background:transparent;color:#888;border-bottom:2px solid transparent;') +
        '">' + tab.label + '</button>';
    });
    html += '</div>';
    return html;
  }

  function _renderActiveAmendments(amendments, currentUser) {
    var open = amendments.filter(function(a) { return a.status === 'open'; });
    if (open.length === 0) {
      return '<div style="text-align:center;color:#888;padding:30px;font-style:italic;">' +
        'No active amendments. Be the first to propose one!</div>';
    }
    var html = '';
    open.forEach(function(a) {
      var tally = _amendmentTally(a.votes || []);
      var countdown = _amendmentCountdown(a.voting_closes_at);
      var userVote = null;
      (a.votes || []).forEach(function(v) {
        if (v.from === currentUser) userVote = v.vote;
      });
      var barWidth = Math.min(100, tally.pct);
      html += '<div class="amend-card" style="background:rgba(218,165,32,0.07);border:1px solid rgba(218,165,32,0.25);' +
        'border-radius:8px;padding:14px;margin-bottom:14px;">';
      html += '<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:6px;">';
      html += '<div style="font-size:15px;font-weight:bold;color:#daa520;flex:1;margin-right:10px;">' + _htmlEsc(a.title) + '</div>';
      html += '<div style="font-size:10px;color:#888;white-space:nowrap;">' + countdown + '</div>';
      html += '</div>';
      html += '<div style="font-size:11px;color:#aaa;margin-bottom:8px;">Proposed by <span style="color:#b0e0e6;">' + _htmlEsc(a.proposed_by) + '</span></div>';
      if (a.description) {
        var desc = a.description.length > 180 ? a.description.slice(0, 180) + '...' : a.description;
        html += '<div style="font-size:12px;color:#ccc;margin-bottom:10px;line-height:1.5;">' + _htmlEsc(desc) + '</div>';
      }
      html += '<div style="margin-bottom:10px;">';
      html += '<div style="display:flex;justify-content:space-between;font-size:11px;color:#aaa;margin-bottom:3px;">';
      html += '<span style="color:#4ade80;">For: ' + tally.forWeight + ' Spark</span>';
      html += '<span style="color:#f87171;">Against: ' + tally.againstWeight + ' Spark</span>';
      html += '</div>';
      html += '<div style="height:6px;background:rgba(255,255,255,0.08);border-radius:3px;overflow:hidden;">';
      html += '<div style="height:100%;width:' + barWidth + '%;background:linear-gradient(90deg,#4ade80,#22c55e);border-radius:3px;transition:width 0.4s ease;"></div>';
      html += '</div>';
      html += '<div style="font-size:10px;color:#888;margin-top:3px;">' + tally.total + ' total Spark weight from ' + (a.votes || []).length + ' voter(s) Â· ' + tally.pct + '% for</div>';
      html += '</div>';
      if (userVote) {
        var voteColor = userVote === 'for' ? '#4ade80' : '#f87171';
        html += '<div style="font-size:12px;color:' + voteColor + ';font-weight:bold;">You voted: ' + userVote.toUpperCase() + '</div>';
      } else {
        html += '<div style="display:flex;gap:8px;">';
        html += '<button class="amend-vote-btn" data-amendment-id="' + _htmlEsc(a.id) + '" data-vote="for" style="flex:1;padding:7px;background:rgba(74,222,128,0.15);' +
          'border:1px solid #4ade80;border-radius:6px;color:#4ade80;font-weight:bold;cursor:pointer;font-size:12px;">For</button>';
        html += '<button class="amend-vote-btn" data-amendment-id="' + _htmlEsc(a.id) + '" data-vote="against" style="flex:1;padding:7px;background:rgba(248,113,113,0.15);' +
          'border:1px solid #f87171;border-radius:6px;color:#f87171;font-weight:bold;cursor:pointer;font-size:12px;">Against</button>';
        html += '</div>';
      }
      html += '</div>';
    });
    return html;
  }

  function _renderProposeForm() {
    return '<div id="amend-propose-form" style="display:flex;flex-direction:column;gap:12px;">' +
      '<div style="font-size:11px;color:#aaa;line-height:1.6;background:rgba(218,165,32,0.07);padding:10px;border-radius:6px;border-left:3px solid #daa520;">' +
        'Proposals require a 7-day discussion period. Amendments cannot remove player rights, close the source code, ' +
        'require physical movement, retroactively punish players, or distinguish between player types (Â§7.5).' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Title *</label>' +
        '<input id="amend-title" type="text" maxlength="120" placeholder="Short, descriptive title..." ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:13px;">' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Description &amp; Rationale *</label>' +
        '<textarea id="amend-description" rows="4" maxlength="2000" placeholder="Explain the amendment and why it improves ZION..." ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:13px;resize:vertical;"></textarea>' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Proposed Changes (diff format) *</label>' +
        '<textarea id="amend-diff" rows="4" maxlength="4000" placeholder="+ Add this line&#10;- Remove this line&#10;  Context line..." ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:12px;font-family:monospace;resize:vertical;"></textarea>' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Discussion Period (days, min 7)</label>' +
        '<input id="amend-days" type="number" min="7" max="90" value="7" ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:13px;">' +
      '</div>' +
      '<div id="amend-error" style="display:none;color:#f87171;font-size:12px;background:rgba(248,113,113,0.1);padding:8px;border-radius:6px;"></div>' +
      '<button id="amend-submit-btn" style="padding:10px;background:linear-gradient(135deg,#b8860b,#daa520);border:none;' +
        'border-radius:8px;color:#000;font-weight:bold;cursor:pointer;font-size:14px;">Submit Proposal</button>' +
    '</div>';
  }

  function _renderAmendmentHistory(amendments) {
    var closed = amendments.filter(function(a) { return a.status === 'closed'; });
    if (closed.length === 0) {
      return '<div style="text-align:center;color:#888;padding:30px;font-style:italic;">No closed amendments yet.</div>';
    }
    var sorted = closed.slice().sort(function(a, b) {
      return new Date(b.closed_at || b.proposed_at) - new Date(a.closed_at || a.proposed_at);
    });
    var html = '';
    sorted.forEach(function(a) {
      var tally = a.tally || _amendmentTally(a.votes || []);
      var forW = tally.for_weight !== undefined ? tally.for_weight : (tally.forWeight || 0);
      var againstW = tally.against_weight !== undefined ? tally.against_weight : (tally.againstWeight || 0);
      var totalVoters = tally.total_voters !== undefined ? tally.total_voters : ((a.votes || []).length);
      var resultColor = a.result === 'approved' ? '#4ade80' : '#f87171';
      var resultIcon = a.result === 'approved' ? '&#10003;' : '&#10007;';
      html += '<div class="amend-history-card" style="background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);' +
        'border-left:3px solid ' + resultColor + ';border-radius:8px;padding:12px;margin-bottom:10px;">';
      html += '<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:4px;">';
      html += '<div style="font-size:14px;font-weight:bold;color:#ddd;">' + _htmlEsc(a.title) + '</div>';
      html += '<div style="font-size:13px;color:' + resultColor + ';font-weight:bold;white-space:nowrap;margin-left:10px;">' + resultIcon + ' ' + (a.result || 'unknown').toUpperCase() + '</div>';
      html += '</div>';
      html += '<div style="font-size:11px;color:#888;margin-bottom:6px;">by ' + _htmlEsc(a.proposed_by) + ' &nbsp;|&nbsp; ' +
        (a.closed_at ? new Date(a.closed_at).toLocaleDateString() : '?') + '</div>';
      html += '<div style="font-size:11px;color:#aaa;">For: ' + forW + ' Spark &nbsp;|&nbsp; Against: ' + againstW + ' Spark &nbsp;|&nbsp; ' + totalVoters + ' voter(s)</div>';
      html += '</div>';
    });
    return html;
  }

  function _htmlEsc(str) {
    if (str == null) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function createAmendmentPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'amendment-panel';
    panel.className = 'zion-tool-panel amendment-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #daa520;border-radius:12px;' +
      'padding:0;width:600px;max-height:82vh;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(218,165,32,0.2);display:none;flex-direction:column;overflow:hidden;';

    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:16px 20px;border-bottom:1px solid rgba(218,165,32,0.3);flex-shrink:0;background:rgba(218,165,32,0.06);';
    header.innerHTML = '<span style="font-size:20px;margin-right:10px;">&#9878;</span>' +
      '<span style="font-size:17px;font-weight:bold;color:#daa520;flex:1;">Constitutional Amendments</span>' +
      '<button id="amendment-panel-close" style="background:rgba(255,255,255,0.08);color:#aaa;border:1px solid rgba(255,255,255,0.15);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;line-height:1;display:flex;align-items:center;justify-content:center;">&#215;</button>';
    panel.appendChild(header);

    var body = document.createElement('div');
    body.id = 'amendment-panel-body';
    body.style.cssText = 'flex:1;overflow-y:auto;padding:18px 20px;';
    body.innerHTML = _amendmentTabBar(_amendmentActiveTab) +
      '<div id="amendment-panel-content"><div style="text-align:center;color:#888;padding:30px;">Loading...</div></div>';
    panel.appendChild(body);

    return panel;
  }

  function refreshAmendmentPanel(amendments, currentUser) {
    if (typeof document === 'undefined') return;
    var content = document.getElementById('amendment-panel-content');
    if (!content) return;

    var arr = amendments || [];

    if (_amendmentActiveTab === 'active') {
      content.innerHTML = _renderActiveAmendments(arr, currentUser || '');
      _wireAmendmentVoteButtons(currentUser);
    } else if (_amendmentActiveTab === 'propose') {
      content.innerHTML = _renderProposeForm();
      _wireProposalForm(currentUser);
    } else if (_amendmentActiveTab === 'history') {
      content.innerHTML = _renderAmendmentHistory(arr);
    }
  }

  function _wireAmendmentVoteButtons(currentUser) {
    if (typeof document === 'undefined') return;
    var btns = document.querySelectorAll('.amend-vote-btn');
    btns.forEach(function(btn) {
      btn.onclick = function() {
        var amendId = btn.getAttribute('data-amendment-id');
        var voteVal = btn.getAttribute('data-vote');
        if (amendmentCallback && amendId && voteVal) {
          amendmentCallback('vote_amendment', {
            amendment_id: amendId,
            vote: voteVal
          });
        }
      };
    });
  }

  function _wireProposalForm(currentUser) {
    if (typeof document === 'undefined') return;
    var submitBtn = document.getElementById('amend-submit-btn');
    var errDiv = document.getElementById('amend-error');
    if (!submitBtn) return;
    submitBtn.onclick = function() {
      var title = (document.getElementById('amend-title') || {}).value || '';
      var desc = (document.getElementById('amend-description') || {}).value || '';
      var diff = (document.getElementById('amend-diff') || {}).value || '';
      var daysVal = parseInt((document.getElementById('amend-days') || {}).value || '7', 10);

      var err = '';
      if (!title.trim()) err = 'Title is required.';
      else if (title.trim().length < 5) err = 'Title must be at least 5 characters.';
      else if (!desc.trim()) err = 'Description is required.';
      else if (desc.trim().length < 20) err = 'Description must be at least 20 characters.';
      else if (!diff.trim()) err = 'Diff text is required.';
      else if (isNaN(daysVal) || daysVal < 7) err = 'Discussion period must be at least 7 days.';

      if (err) {
        if (errDiv) { errDiv.textContent = err; errDiv.style.display = 'block'; }
        return;
      }
      if (errDiv) errDiv.style.display = 'none';

      if (amendmentCallback) {
        amendmentCallback('propose_amendment', {
          title: title.trim(),
          description: desc.trim(),
          diff_text: diff.trim(),
          discussion_period_days: Math.max(7, daysVal)
        });
      }
    };
  }

  function _wireAmendmentTabs(amendments, currentUser) {
    if (typeof document === 'undefined') return;
    var tabs = document.querySelectorAll('.amend-tab-btn');
    tabs.forEach(function(btn) {
      btn.onclick = function() {
        _amendmentActiveTab = btn.getAttribute('data-tab') || 'active';
        var body = document.getElementById('amendment-panel-body');
        if (body) {
          body.innerHTML = _amendmentTabBar(_amendmentActiveTab) +
            '<div id="amendment-panel-content"></div>';
        }
        refreshAmendmentPanel(amendments, currentUser);
        _wireAmendmentTabs(amendments, currentUser);
      };
    });
  }

  function showAmendmentPanel(amendments, currentUser) {
    if (typeof document === 'undefined') return;

    if (!amendmentPanelEl) {
      amendmentPanelEl = createAmendmentPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && amendmentPanelEl) {
        hud.appendChild(amendmentPanelEl);
      } else if (amendmentPanelEl) {
        document.body.appendChild(amendmentPanelEl);
      }
    }
    if (!amendmentPanelEl) return;

    _amendmentActiveTab = 'active';
    amendmentPanelEl.style.display = 'flex';
    amendmentPanelVisible = true;

    var body = document.getElementById('amendment-panel-body');
    if (body) {
      body.innerHTML = _amendmentTabBar(_amendmentActiveTab) +
        '<div id="amendment-panel-content"></div>';
    }
    refreshAmendmentPanel(amendments || [], currentUser || '');
    _wireAmendmentTabs(amendments || [], currentUser || '');

    var closeBtn = document.getElementById('amendment-panel-close');
    if (closeBtn) closeBtn.onclick = hideAmendmentPanel;
  }

  function hideAmendmentPanel() {
    if (amendmentPanelEl) {
      amendmentPanelEl.style.display = 'none';
    }
    amendmentPanelVisible = false;
  }

  function toggleAmendmentPanel(amendments, currentUser) {
    if (amendmentPanelVisible) {
      hideAmendmentPanel();
    } else {
      showAmendmentPanel(amendments, currentUser);
    }
  }

  exports.initAmendmentPanel = initAmendmentPanel;
  exports.showAmendmentPanel = showAmendmentPanel;
  exports.hideAmendmentPanel = hideAmendmentPanel;
  exports.toggleAmendmentPanel = toggleAmendmentPanel;
  exports.refreshAmendmentPanel = refreshAmendmentPanel;
  exports.createAmendmentPanel = createAmendmentPanel;
  exports._amendmentCountdown = _amendmentCountdown;
  exports._amendmentTally = _amendmentTally;
  exports._renderActiveAmendments = _renderActiveAmendments;
  exports._renderAmendmentHistory = _renderAmendmentHistory;
  exports._renderProposeForm = _renderProposeForm;
  exports._htmlEsc = _htmlEsc;
  exports._amendmentTabBar = _amendmentTabBar;

  var leaderboardPanelEl = null;
  var leaderboardVisible = false;
  var _lbActiveCategory = 'wealth';
  var _lbActivePeriod = 'all_time';
  var _lbDisplayCount = 10;
  var _lbGameData = null;

  var LB_CATEGORIES = [
    { id: 'wealth',      label: 'Wealth',      icon: '\u2728' },
    { id: 'quests',      label: 'Quests',       icon: '\u2694' },
    { id: 'exploration', label: 'Exploration',  icon: '\ud83d\uddfa' },
    { id: 'guilds',      label: 'Guilds',       icon: '\ud83d\udee1' },
    { id: 'reputation',  label: 'Reputation',   icon: '\u2b50' },
    { id: 'combined',    label: 'Combined',     icon: '\ud83c\udfc6' }
  ];

  var LB_PERIODS = [
    { id: 'all_time', label: 'All Time' },
    { id: 'daily',    label: 'Today'    },
    { id: 'weekly',   label: 'Week'     }
  ];

  var LB_COUNTS = [10, 25, 50];

  function _lbGetLeaderboards() {
    if (typeof Leaderboards === 'undefined') return null;
    return Leaderboards;
  }

  function _lbMakeTabBar(tabs, activeId, onSelect) {
    var bar = document.createElement('div');
    bar.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;margin-bottom:14px;';
    tabs.forEach(function(tab) {
      var btn = document.createElement('button');
      btn.textContent = (tab.icon ? tab.icon + ' ' : '') + tab.label;
      btn.dataset.tabId = tab.id;
      var isActive = tab.id === activeId;
      btn.style.cssText = 'padding:6px 12px;border-radius:6px;font-size:12px;cursor:pointer;font-weight:bold;transition:all 0.2s;' +
        (isActive
          ? 'background:rgba(218,165,32,0.25);border:1px solid #DAA520;color:#DAA520;'
          : 'background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);color:#A0978E;');
      btn.onclick = function() { onSelect(tab.id); };
      btn.onmouseover = function() {
        if (tab.id !== activeId) {
          btn.style.background = 'rgba(218,165,32,0.1)';
          btn.style.borderColor = 'rgba(218,165,32,0.4)';
          btn.style.color = '#D4C5B3';
        }
      };
      btn.onmouseout = function() {
        if (tab.id !== activeId) {
          btn.style.background = 'rgba(255,255,255,0.05)';
          btn.style.borderColor = 'rgba(255,255,255,0.15)';
          btn.style.color = '#A0978E';
        }
      };
      bar.appendChild(btn);
    });
    return bar;
  }

  function _lbRenderRows(rows, playerId) {
    var table = document.createElement('div');
    table.style.cssText = 'display:flex;flex-direction:column;gap:4px;';

    if (!rows || rows.length === 0) {
      var empty = document.createElement('div');
      empty.textContent = 'No data available.';
      empty.style.cssText = 'color:#A0978E;text-align:center;padding:20px;font-size:14px;';
      table.appendChild(empty);
      return table;
    }

    var header = document.createElement('div');
    header.style.cssText = 'display:grid;grid-template-columns:50px 1fr 120px;gap:8px;padding:6px 10px;' +
      'color:#A0978E;font-size:11px;font-weight:bold;text-transform:uppercase;letter-spacing:0.5px;' +
      'border-bottom:1px solid rgba(255,255,255,0.1);margin-bottom:4px;';
    header.innerHTML = '<span>Rank</span><span>Player</span><span style="text-align:right">Score</span>';
    table.appendChild(header);

    rows.forEach(function(row) {
      var isMe = row.isHighlighted || (playerId && row.id === playerId);
      var rowEl = document.createElement('div');
      rowEl.style.cssText = 'display:grid;grid-template-columns:50px 1fr 120px;gap:8px;padding:8px 10px;' +
        'border-radius:6px;font-size:13px;align-items:center;transition:background 0.15s;' +
        (isMe
          ? 'background:rgba(218,165,32,0.15);border:1px solid rgba(218,165,32,0.35);'
          : 'background:rgba(255,255,255,0.03);border:1px solid transparent;');

      rowEl.onmouseover = function() {
        if (!isMe) rowEl.style.background = 'rgba(255,255,255,0.06)';
      };
      rowEl.onmouseout = function() {
        if (!isMe) rowEl.style.background = 'rgba(255,255,255,0.03)';
      };

      var rankEl = document.createElement('span');
      var rankNum = row.rank;
      var rankStyle = 'font-weight:bold;';
      if (rankNum === 1) rankStyle += 'color:#FFD700;font-size:16px;';
      else if (rankNum === 2) rankStyle += 'color:#C0C0C0;font-size:15px;';
      else if (rankNum === 3) rankStyle += 'color:#CD7F32;font-size:14px;';
      else rankStyle += 'color:#6B6560;';
      rankEl.style.cssText = rankStyle;
      rankEl.textContent = rankNum === 1 ? '\ud83e\udd47' : (rankNum === 2 ? '\ud83e\udd48' : (rankNum === 3 ? '\ud83e\udd49' : '#' + rankNum));

      var nameEl = document.createElement('span');
      nameEl.textContent = (row.tag ? '[' + row.tag + '] ' : '') + (row.name || row.id);
      nameEl.style.cssText = 'color:' + (isMe ? '#DAA520' : '#E8E0D8') + ';overflow:hidden;text-overflow:ellipsis;white-space:nowrap;';

      var scoreEl = document.createElement('span');
      scoreEl.textContent = row.label || row.score;
      scoreEl.style.cssText = 'text-align:right;color:' + (isMe ? '#DAA520' : '#A0978E') + ';font-family:monospace;font-size:12px;';

      if (row.tier) {
        var tierEl = document.createElement('span');
        tierEl.textContent = ' ' + row.tier;
        tierEl.style.cssText = 'font-size:10px;color:#818cf8;';
        nameEl.appendChild(tierEl);
      }

      if (row.level !== undefined) {
        var lvlEl = document.createElement('span');
        lvlEl.textContent = ' Lv.' + row.level;
        lvlEl.style.cssText = 'font-size:10px;color:#6B6560;';
        nameEl.appendChild(lvlEl);
      }

      rowEl.appendChild(rankEl);
      rowEl.appendChild(nameEl);
      rowEl.appendChild(scoreEl);
      table.appendChild(rowEl);
    });

    return table;
  }

  function _lbRefreshContent(container) {
    var LB = _lbGetLeaderboards();
    if (!LB) {
      container.innerHTML = '<div style="text-align:center;color:#A0978E;padding:40px;">Leaderboards module not loaded.</div>';
      return;
    }

    var data = _lbGameData || {};
    var periodOpts = { period: _lbActivePeriod };
    var rankings = [];

    switch (_lbActiveCategory) {
      case 'wealth':
        rankings = LB.getWealthRankings(data.economy || {}, periodOpts);
        break;
      case 'quests':
        rankings = LB.getQuestRankings(data.quests || {}, periodOpts);
        break;
      case 'exploration':
        rankings = LB.getExplorationRankings(data.discoveries || [], periodOpts);
        break;
      case 'guilds':
        rankings = LB.getGuildRankings(data.guilds || [], periodOpts);
        break;
      case 'reputation':
        rankings = LB.getReputationRankings(data.reputation || {}, periodOpts);
        break;
      case 'combined':
        rankings = LB.getCombinedRankings(data, periodOpts);
        break;
      default:
        rankings = [];
    }

    var currentPlayerId = (typeof window !== 'undefined' && window._currentPlayerId) ? window._currentPlayerId : null;
    var fmtOpts = {
      count: _lbDisplayCount,
      allowedCounts: [_lbDisplayCount],
      highlightId: currentPlayerId,
      showBreakdown: _lbActiveCategory === 'combined'
    };

    var rows = LB.formatLeaderboard(rankings, fmtOpts);

    var playerRankInfo = null;
    if (currentPlayerId && LB.getPlayerRank) {
      var categoryData;
      switch (_lbActiveCategory) {
        case 'wealth': categoryData = data.economy || {}; break;
        case 'quests': categoryData = data.quests || {}; break;
        case 'exploration': categoryData = data.discoveries || []; break;
        case 'guilds': categoryData = data.guilds || []; break;
        case 'reputation': categoryData = data.reputation || {}; break;
        case 'combined': categoryData = data; break;
        default: categoryData = {};
      }
      playerRankInfo = LB.getPlayerRank(currentPlayerId, _lbActiveCategory, categoryData, periodOpts);
    }

    container.innerHTML = '';

    if (playerRankInfo) {
      var rankBanner = document.createElement('div');
      rankBanner.style.cssText = 'background:rgba(218,165,32,0.08);border:1px solid rgba(218,165,32,0.2);' +
        'border-radius:6px;padding:10px 14px;margin-bottom:14px;display:flex;align-items:center;justify-content:space-between;';
      var yourRankText = playerRankInfo.rank
        ? 'Your rank: #' + playerRankInfo.rank + ' of ' + playerRankInfo.total
        : 'You are not ranked yet';
      var yourScoreText = playerRankInfo.score ? '  (' + (playerRankInfo.label || playerRankInfo.score) + ')' : '';
      rankBanner.innerHTML =
        '<span style="color:#A0978E;font-size:12px;">You</span>' +
        '<span style="color:#DAA520;font-weight:bold;font-size:14px;">' + yourRankText + '</span>' +
        '<span style="color:#6B6560;font-size:12px;">' + yourScoreText + '</span>';
      container.appendChild(rankBanner);
    }

    container.appendChild(_lbRenderRows(rows, currentPlayerId));
  }

  function _lbBuildPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'leaderboard-panel';
    panel.style.cssText =
      'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'width:680px;max-height:85vh;' +
      'background:rgba(15,12,10,0.97);border:2px solid rgba(218,165,32,0.4);border-radius:10px;' +
      'z-index:300;pointer-events:auto;display:none;flex-direction:column;' +
      'box-shadow:0 12px 48px rgba(0,0,0,0.85);';

    var headerDiv = document.createElement('div');
    headerDiv.style.cssText =
      'display:flex;align-items:center;padding:16px 20px;border-bottom:1px solid rgba(218,165,32,0.2);flex-shrink:0;';
    headerDiv.innerHTML =
      '<span style="font-size:20px;margin-right:10px;">\ud83c\udfc6</span>' +
      '<span style="font-size:18px;font-weight:bold;color:#DAA520;flex:1;">Leaderboards</span>';

    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\xd7';
    closeBtn.style.cssText =
      'background:rgba(255,255,255,0.08);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;line-height:1;';
    closeBtn.onclick = hideLeaderboardPanel;
    closeBtn.onmouseover = function() {
      closeBtn.style.background = 'rgba(218,165,32,0.2)';
      closeBtn.style.borderColor = '#DAA520';
      closeBtn.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      closeBtn.style.background = 'rgba(255,255,255,0.08)';
      closeBtn.style.borderColor = 'rgba(255,255,255,0.2)';
      closeBtn.style.color = '#aaa';
    };
    headerDiv.appendChild(closeBtn);
    panel.appendChild(headerDiv);

    var controlsDiv = document.createElement('div');
    controlsDiv.style.cssText =
      'padding:12px 20px;border-bottom:1px solid rgba(255,255,255,0.06);flex-shrink:0;';

    var categoryBar = _lbMakeTabBar(LB_CATEGORIES, _lbActiveCategory, function(id) {
      _lbActiveCategory = id;
      _lbRebuildPanel();
    });
    controlsDiv.appendChild(categoryBar);

    var subRow = document.createElement('div');
    subRow.style.cssText = 'display:flex;align-items:center;gap:8px;margin-top:8px;';

    var periodLabel = document.createElement('span');
    periodLabel.textContent = 'Period:';
    periodLabel.style.cssText = 'color:#6B6560;font-size:11px;';
    subRow.appendChild(periodLabel);

    LB_PERIODS.forEach(function(p) {
      var btn = document.createElement('button');
      btn.textContent = p.label;
      var isActive = p.id === _lbActivePeriod;
      btn.style.cssText =
        'padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;' +
        (isActive
          ? 'background:rgba(218,165,32,0.2);border:1px solid rgba(218,165,32,0.5);color:#DAA520;'
          : 'background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.1);color:#6B6560;');
      btn.onclick = function() {
        _lbActivePeriod = p.id;
        _lbRebuildPanel();
      };
      subRow.appendChild(btn);
    });

    var spacer = document.createElement('span');
    spacer.style.cssText = 'flex:1;';
    subRow.appendChild(spacer);

    var countLabel = document.createElement('span');
    countLabel.textContent = 'Show:';
    countLabel.style.cssText = 'color:#6B6560;font-size:11px;';
    subRow.appendChild(countLabel);

    LB_COUNTS.forEach(function(c) {
      var btn = document.createElement('button');
      btn.textContent = String(c);
      var isActive = c === _lbDisplayCount;
      btn.style.cssText =
        'padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;' +
        (isActive
          ? 'background:rgba(218,165,32,0.2);border:1px solid rgba(218,165,32,0.5);color:#DAA520;'
          : 'background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.1);color:#6B6560;');
      btn.onclick = function() {
        _lbDisplayCount = c;
        _lbRebuildPanel();
      };
      subRow.appendChild(btn);
    });

    controlsDiv.appendChild(subRow);
    panel.appendChild(controlsDiv);

    var contentDiv = document.createElement('div');
    contentDiv.id = 'leaderboard-content';
    contentDiv.style.cssText = 'flex:1;overflow-y:auto;padding:16px 20px;';
    panel.appendChild(contentDiv);

    var footerDiv = document.createElement('div');
    footerDiv.style.cssText =
      'padding:10px 20px;border-top:1px solid rgba(255,255,255,0.06);flex-shrink:0;' +
      'display:flex;justify-content:space-between;align-items:center;';
    footerDiv.innerHTML =
      '<span style="color:#6B6560;font-size:11px;">Rankings update in real time</span>' +
      '<span id="lb-player-count" style="color:#6B6560;font-size:11px;"></span>';
    panel.appendChild(footerDiv);

    return panel;
  }

  function _lbRebuildPanel() {
    if (!leaderboardPanelEl) return;
    leaderboardPanelEl.parentNode && leaderboardPanelEl.parentNode.removeChild(leaderboardPanelEl);
    leaderboardPanelEl = _lbBuildPanel();
    if (!leaderboardPanelEl) return;
    document.body.appendChild(leaderboardPanelEl);
    leaderboardPanelEl.style.display = 'flex';
    var content = document.getElementById('leaderboard-content');
    if (content) _lbRefreshContent(content);
  }

  function showLeaderboardPanel(gameData, opts) {
    if (typeof document === 'undefined') return;
    opts = opts || {};

    if (gameData) _lbGameData = gameData;
    if (opts.category) _lbActiveCategory = opts.category;
    if (opts.period) _lbActivePeriod = opts.period;
    if (opts.count) _lbDisplayCount = opts.count;

    if (leaderboardPanelEl && leaderboardPanelEl.parentNode) {
      var content = document.getElementById('leaderboard-content');
      if (content) _lbRefreshContent(content);
      leaderboardPanelEl.style.display = 'flex';
      leaderboardVisible = true;
      return;
    }

    leaderboardPanelEl = _lbBuildPanel();
    if (!leaderboardPanelEl) return;

    document.body.appendChild(leaderboardPanelEl);
    leaderboardPanelEl.style.display = 'flex';
    leaderboardVisible = true;

    var content = document.getElementById('leaderboard-content');
    if (content) _lbRefreshContent(content);
  }

  function hideLeaderboardPanel() {
    if (leaderboardPanelEl) {
      leaderboardPanelEl.style.display = 'none';
    }
    leaderboardVisible = false;
  }

  function toggleLeaderboardPanel(gameData, opts) {
    if (leaderboardVisible) {
      hideLeaderboardPanel();
    } else {
      showLeaderboardPanel(gameData, opts);
    }
  }

  function refreshLeaderboardPanel(gameData) {
    if (gameData) _lbGameData = gameData;
    if (!leaderboardVisible || !leaderboardPanelEl) return;
    var content = document.getElementById('leaderboard-content');
    if (content) _lbRefreshContent(content);
  }

  exports.showLeaderboardPanel = showLeaderboardPanel;
  exports.hideLeaderboardPanel = hideLeaderboardPanel;
  exports.toggleLeaderboardPanel = toggleLeaderboardPanel;
  exports.refreshLeaderboardPanel = refreshLeaderboardPanel;

})(typeof module !== 'undefined' ? module.exports : (window.HUD = {}));


// LAZY_LOAD_START: xr
(function(exports) {
  let xrSession = null;
  let xrReferenceSpace = null;
  let lastPosition = { x: 0, y: 0, z: 0 };
  let lastCheckTime = 0;

  async function initXR() {
    if (typeof navigator === 'undefined' || !navigator.xr) {
      console.warn('WebXR not available');
      return { vrSupported: false, arSupported: false };
    }

    try {
      const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      const arSupported = await navigator.xr.isSessionSupported('immersive-ar');

      console.log('XR capabilities:', { vrSupported, arSupported });

      return { vrSupported, arSupported };
    } catch (err) {
      console.error('Error checking XR support:', err);
      return { vrSupported: false, arSupported: false };
    }
  }

  async function enterVR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    try {
      xrSession = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'bounded-floor']
      });

      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('VR session ended');
      });

      console.log('Entered VR mode');

      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter VR:', err);
      throw err;
    }
  }

  async function enterAR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    const proceed = await showSafetyWarning();
    if (!proceed) {
      console.log('AR session cancelled by user');
      return;
    }

    try {
      xrSession = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['local-floor'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });

      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('AR session ended');
      });

      console.log('Entered AR mode');

      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      scene.background = null;

      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          if (timestamp - lastCheckTime > 1000) { // Every second
            const pose = frame.getViewerPose(xrReferenceSpace);
            if (pose) {
              const position = pose.transform.position;
              const deltaTime = (timestamp - lastCheckTime) / 1000;
              const speedCheck = checkSpeed(position, lastPosition, deltaTime);

              if (!speedCheck.safe) {
                console.warn(`Speed too high: ${speedCheck.speed.toFixed(1)} km/h. Pausing AR.`);
                showSpeedWarning(speedCheck.speed);
                return; // Skip rendering this frame
              }

              lastPosition = { x: position.x, y: position.y, z: position.z };
              lastCheckTime = timestamp;
            }
          }

          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter AR:', err);
      throw err;
    }
  }

  async function exitXR() {
    if (xrSession) {
      await xrSession.end();
      xrSession = null;
      xrReferenceSpace = null;
      console.log('Exited XR mode');
    }
  }

  function checkSpeed(position, lastPosition, deltaTime) {
    if (!position || !lastPosition || deltaTime === 0) {
      return { safe: true, speed: 0 };
    }

    const dx = position.x - lastPosition.x;
    const dy = position.y - lastPosition.y;
    const dz = position.z - lastPosition.z;

    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    const speedMetersPerSecond = distance / deltaTime;
    const speedKmPerHour = speedMetersPerSecond * 3.6;

    const MAX_SAFE_SPEED = 25; // km/h (walking/jogging speed)

    return {
      safe: speedKmPerHour <= MAX_SAFE_SPEED,
      speed: speedKmPerHour
    };
  }

  function showSafetyWarning() {
    if (typeof document === 'undefined') {
      return Promise.resolve(true);
    }

    return new Promise((resolve) => {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        color: white;
        font-family: Arial, sans-serif;
      `;

      const content = document.createElement('div');
      content.style.cssText = `
        max-width: 500px;
        padding: 30px;
        background: rgba(20, 20, 20, 0.95);
        border-radius: 12px;
        border: 2px solid #ff6347;
        text-align: center;
      `;

      content.innerHTML = `
        <h2 style="color: #ff6347; margin-bottom: 20px;">AR Safety Warning</h2>
        <p style="margin-bottom: 15px; line-height: 1.6;">
          Please be aware of your surroundings while using AR mode.
        </p>
        <ul style="text-align: left; margin-bottom: 20px; line-height: 1.8;">
          <li>Do not use AR while driving or operating vehicles</li>
          <li>Stay aware of obstacles, traffic, and other hazards</li>
          <li>AR will pause automatically if moving faster than 25 km/h</li>
          <li>Use in safe, well-lit areas</li>
          <li>Take breaks if you feel disoriented</li>
        </ul>
        <p style="margin-bottom: 25px; font-weight: bold; color: #ffa500;">
          By continuing, you acknowledge these safety guidelines.
        </p>
        <div>
          <button id="ar-accept" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #4af;
            color: white;
            cursor: pointer;
            font-weight: bold;
          ">I Understand</button>
          <button id="ar-cancel" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #666;
            color: white;
            cursor: pointer;
          ">Cancel</button>
        </div>
      `;

      overlay.appendChild(content);
      document.body.appendChild(overlay);

      document.getElementById('ar-accept').addEventListener('click', () => {
        overlay.remove();
        resolve(true);
      });

      document.getElementById('ar-cancel').addEventListener('click', () => {
        overlay.remove();
        resolve(false);
      });
    });
  }

  function showSpeedWarning(speed) {
    if (typeof document === 'undefined') return;

    let warningEl = document.getElementById('ar-speed-warning');
    if (!warningEl) {
      warningEl = document.createElement('div');
      warningEl.id = 'ar-speed-warning';
      warningEl.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 12px;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        z-index: 10001;
        border: 4px solid white;
      `;
      document.body.appendChild(warningEl);
    }

    warningEl.innerHTML = `
      <div style="margin-bottom: 15px;">SPEED TOO HIGH</div>
      <div style="font-size: 48px; margin-bottom: 15px;">${speed.toFixed(0)} km/h</div>
      <div style="font-size: 18px;">AR paused for safety</div>
      <div style="font-size: 14px; margin-top: 10px;">Slow down to resume</div>
    `;

    warningEl.style.display = 'block';

    setTimeout(() => {
      if (warningEl) {
        warningEl.style.display = 'none';
      }
    }, 3000);
  }

  exports.initXR = initXR;
  exports.enterVR = enterVR;
  exports.enterAR = enterAR;
  exports.exitXR = exitXR;
  exports.checkSpeed = checkSpeed;
  exports.showSafetyWarning = showSafetyWarning;

})(typeof module !== 'undefined' ? module.exports : (window.XR = {}));

// LAZY_LOAD_END: xr

// audio.js
(function(exports) {

  var audioContext = null;
  var masterGain = null;
  var isMuted = false;
  var currentAmbient = null;
  var volumeLevels = { master: 0.5, music: 0.5, sfx: 0.5 };
  var activeNoiseSources = []; // Global tracker for all white noise sources

  function initAudio() {
    if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') {
      console.warn('Web Audio API not available');
      return null;
    }

    var resumeEvents = ['click', 'touchstart', 'keydown'];
    function createOnGesture() {
      if (audioContext) return;
      try {
        audioContext = new (AudioContext || webkitAudioContext)();
        masterGain = audioContext.createGain();
        if (masterGain) {
          masterGain.connect(audioContext.destination);
          masterGain.gain.value = 0.15;
        }
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        console.log('Audio system initialized (after user gesture)');
      } catch (err) {
        console.error('Failed to initialize audio:', err);
      }
      resumeEvents.forEach(function(evt) {
        document.removeEventListener(evt, createOnGesture);
      });
    }
    resumeEvents.forEach(function(evt) {
      document.addEventListener(evt, createOnGesture, { once: false });
    });

    console.log('Audio system deferred until user gesture');
    return true;
  }

  function createWhiteNoise(maxDurationSec) {
    if (!audioContext) return null;

    try {
      const bufferSize = 2 * audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      var lastOut = 0;
      for (let i = 0; i < bufferSize; i++) {
        var white = Math.random() * 2 - 1;
        lastOut = (lastOut + (0.02 * white)) / 1.02;
        output[i] = lastOut * 3.5; // normalize amplitude
      }

      const whiteNoise = audioContext.createBufferSource();
      whiteNoise.buffer = noiseBuffer;
      whiteNoise.loop = true;
      whiteNoise.start();

      activeNoiseSources.push(whiteNoise);
      whiteNoise.onended = function() {
        var idx = activeNoiseSources.indexOf(whiteNoise);
        if (idx !== -1) activeNoiseSources.splice(idx, 1);
      };

      var safeDur = maxDurationSec || 60;
      setTimeout(function() {
        try { whiteNoise.stop(); } catch(e) {}
        try { whiteNoise.disconnect(); } catch(e) {}
      }, safeDur * 1000);

      return whiteNoise;
    } catch (err) {
      console.error('Error creating white noise:', err);
      return null;
    }
  }

  function killAllNoiseSources() {
    for (var i = 0; i < activeNoiseSources.length; i++) {
      try { activeNoiseSources[i].stop(); } catch(e) {}
      try { activeNoiseSources[i].disconnect(); } catch(e) {}
    }
    activeNoiseSources = [];
  }

  function playAmbient(zone) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    if (currentAmbient) {
      stopAmbient();
    }

    try {
      switch (zone) {
        case 'nexus':
          currentAmbient = playNexusAmbient();
          break;
        case 'gardens':
          currentAmbient = playGardensAmbient();
          break;
        case 'athenaeum':
          currentAmbient = playAthenaeumAmbient();
          break;
        case 'studio':
          currentAmbient = playStudioAmbient();
          break;
        case 'wilds':
          currentAmbient = playWildsAmbient();
          break;
        case 'agora':
          currentAmbient = playAgoraAmbient();
          break;
        case 'commons':
          currentAmbient = playCommonsAmbient();
          break;
        case 'arena':
          currentAmbient = playArenaAmbient();
          break;
        default:
          currentAmbient = null;
      }
    } catch (err) {
      console.error('Error playing ambient:', err);
    }
  }

  function stopAmbient() {
    if (!currentAmbient) return;

    try {
      if (currentAmbient.oscillators && Array.isArray(currentAmbient.oscillators)) {
        currentAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentAmbient.nodes && Array.isArray(currentAmbient.nodes)) {
        currentAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentAmbient.gain && currentAmbient.gain.disconnect) {
        try { currentAmbient.gain.disconnect(); } catch (e) {}
      }

      if (currentAmbient.intervals && Array.isArray(currentAmbient.intervals)) {
        currentAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentAmbient.timeouts && Array.isArray(currentAmbient.timeouts)) {
        currentAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentAmbient.cleanup && typeof currentAmbient.cleanup === 'function') {
        currentAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping ambient:', err);
    }

    currentAmbient = null;
    killAllNoiseSources();
  }

  function playNexusAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      const drone1 = audioContext.createOscillator();
      const drone2 = audioContext.createOscillator();
      const droneGain = audioContext.createGain();

      drone1.type = 'sine';
      drone1.frequency.value = 65.41; // C2
      drone2.type = 'sine';
      drone2.frequency.value = 130.81; // C3

      droneGain.gain.value = 0.03;

      drone1.connect(droneGain);
      drone2.connect(droneGain);
      droneGain.connect(masterGain);

      drone1.start();
      drone2.start();

      oscillators.push(drone1, drone2);
      nodes.push(droneGain);

      const pad1 = audioContext.createOscillator();
      const pad2 = audioContext.createOscillator();
      const pad3 = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      const padGain = audioContext.createGain();

      pad1.type = 'sine';
      pad1.frequency.value = 261.63; // C4
      pad2.type = 'sine';
      pad2.frequency.value = 329.63; // E4
      pad3.type = 'sine';
      pad3.frequency.value = 392.00; // G4

      lfo.type = 'sine';
      lfo.frequency.value = 0.2; // Slow modulation
      lfoGain.gain.value = 0.01; // Subtle volume modulation

      padGain.gain.value = 0.02;

      lfo.connect(lfoGain);
      lfoGain.connect(padGain.gain);

      pad1.connect(padGain);
      pad2.connect(padGain);
      pad3.connect(padGain);
      padGain.connect(masterGain);

      pad1.start();
      pad2.start();
      pad3.start();
      lfo.start();

      oscillators.push(pad1, pad2, pad3, lfo);
      nodes.push(lfoGain, padGain);

      function playChime() {
        if (!audioContext || !masterGain) return;

        const chime = audioContext.createOscillator();
        const chimeGain = audioContext.createGain();
        const delay1 = audioContext.createDelay();
        const delay2 = audioContext.createDelay();
        const delayGain1 = audioContext.createGain();
        const delayGain2 = audioContext.createGain();

        chime.type = 'sine';
        chime.frequency.value = 400 + Math.random() * 400;

        chimeGain.gain.value = 0.015;
        chimeGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        delay1.delayTime.value = 0.4;
        delay2.delayTime.value = 0.7;
        delayGain1.gain.value = 0.1;
        delayGain2.gain.value = 0.06;

        chime.connect(chimeGain);
        chimeGain.connect(masterGain);
        chimeGain.connect(delay1);
        chimeGain.connect(delay2);
        delay1.connect(delayGain1);
        delay2.connect(delayGain2);
        delayGain1.connect(masterGain);
        delayGain2.connect(masterGain);

        chime.start();
        chime.stop(audioContext.currentTime + 2.5);

        const nextChime = setTimeout(playChime, 8000 + Math.random() * 12000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(playChime, 2000);
      timeouts.push(firstChime);

      return { oscillators, nodes, timeouts };
    } catch (err) {
      console.error('Error in nexus ambient:', err);
      return null;
    }
  }

  function playGardensAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      const stream = createWhiteNoise();
      if (stream) {
        const streamFilter = audioContext.createBiquadFilter();
        const streamLfo = audioContext.createOscillator();
        const streamLfoGain = audioContext.createGain();
        const streamGain = audioContext.createGain();

        streamFilter.type = 'lowpass';
        streamFilter.frequency.value = 400;

        streamLfo.type = 'sine';
        streamLfo.frequency.value = 0.5;
        streamLfoGain.gain.value = 100; // Modulate filter frequency

        streamGain.gain.value = 0.025;

        streamLfo.connect(streamLfoGain);
        streamLfoGain.connect(streamFilter.frequency);

        stream.connect(streamFilter);
        streamFilter.connect(streamGain);
        streamGain.connect(masterGain);

        streamLfo.start();

        nodes.push(stream, streamFilter, streamLfo, streamLfoGain, streamGain);
      }

      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 200;
        breezeGain.gain.value = 0.012;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      function chirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 600 + Math.random() * 1200;

        const duration = 0.1 + Math.random() * 0.2;
        birdGain.gain.value = 0.06;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(chirp, 500 + Math.random() * 3500);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 3; i++) {
        const firstChirp = setTimeout(chirp, Math.random() * 2000);
        timeouts.push(firstChirp);
      }

      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 4500;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 20; // 20 Hz modulation
      cricketAmGain.gain.value = 0.015;

      cricketGain.gain.value = 0.015;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      nodes.push(cricket, cricketAm, cricketAmGain, cricketGain);

      function rustle() {
        if (!audioContext || !masterGain) return;

        const noise = createWhiteNoise(2);
        if (noise) {
          const rustleFilter = audioContext.createBiquadFilter();
          const rustleGain = audioContext.createGain();

          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 2000;
          rustleFilter.Q.value = 2;

          rustleGain.gain.value = 0.04;
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

          noise.connect(rustleFilter);
          rustleFilter.connect(rustleGain);
          rustleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (noise.stop) noise.stop();
              if (rustleFilter.disconnect) rustleFilter.disconnect();
              if (rustleGain.disconnect) rustleGain.disconnect();
            } catch (e) {}
          }, 400);
        }

        const nextRustle = setTimeout(rustle, 2000 + Math.random() * 3000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 1000);
      timeouts.push(firstRustle);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in gardens ambient:', err);
      return null;
    }
  }

  function playAthenaeumAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      const roomTone = createWhiteNoise();
      if (roomTone) {
        const roomGain = audioContext.createGain();
        roomGain.gain.value = 0.01;

        roomTone.connect(roomGain);
        roomGain.connect(masterGain);

        nodes.push(roomTone, roomGain);
      }

      function turnPage() {
        if (!audioContext || !masterGain) return;

        const page = createWhiteNoise(2);
        if (page) {
          const pageFilter = audioContext.createBiquadFilter();
          const pageGain = audioContext.createGain();

          pageFilter.type = 'highpass';
          pageFilter.frequency.value = 2000;

          pageGain.gain.value = 0.03;
          pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

          page.connect(pageFilter);
          pageFilter.connect(pageGain);
          pageGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (page.stop) page.stop();
              if (pageFilter.disconnect) pageFilter.disconnect();
              if (pageGain.disconnect) pageGain.disconnect();
            } catch (e) {}
          }, 150);
        }

        const nextPage = setTimeout(turnPage, 8000 + Math.random() * 7000);
        timeouts.push(nextPage);
      }

      const firstPage = setTimeout(turnPage, 3000);
      timeouts.push(firstPage);

      function writeQuill() {
        if (!audioContext || !masterGain) return;

        const quill = createWhiteNoise(2);
        if (quill) {
          const quillFilter = audioContext.createBiquadFilter();
          const quillGain = audioContext.createGain();

          quillFilter.type = 'bandpass';
          quillFilter.frequency.value = 3000;
          quillFilter.Q.value = 5;

          quillGain.gain.value = 0.05;

          quill.connect(quillFilter);
          quillFilter.connect(quillGain);
          quillGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (quill.stop) quill.stop();
              if (quillFilter.disconnect) quillFilter.disconnect();
              if (quillGain.disconnect) quillGain.disconnect();
            } catch (e) {}
          }, 200 + Math.random() * 500);
        }

        const nextQuill = setTimeout(writeQuill, 5000 + Math.random() * 10000);
        timeouts.push(nextQuill);
      }

      const firstQuill = setTimeout(writeQuill, 5000);
      timeouts.push(firstQuill);

      function footstep() {
        if (!audioContext || !masterGain) return;

        const step = audioContext.createOscillator();
        const stepGain = audioContext.createGain();

        step.type = 'sine';
        step.frequency.value = 60;

        stepGain.gain.value = 0.03;
        stepGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

        step.connect(stepGain);
        stepGain.connect(masterGain);

        step.start();
        step.stop(audioContext.currentTime + 0.05);

        const nextStep = setTimeout(footstep, 5000 + Math.random() * 5000);
        timeouts.push(nextStep);
      }

      const firstStep = setTimeout(footstep, 2000);
      timeouts.push(firstStep);

      function tick() {
        if (!audioContext || !masterGain) return;

        const click = audioContext.createOscillator();
        const clickGain = audioContext.createGain();

        click.type = 'sine';
        click.frequency.value = 800;

        clickGain.gain.value = 0.02;
        clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

        click.connect(clickGain);
        clickGain.connect(masterGain);

        click.start();
        click.stop(audioContext.currentTime + 0.02);
      }

      const tickInterval = setInterval(tick, 1000);
      intervals.push(tickInterval);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in athenaeum ambient:', err);
      return null;
    }
  }

  function playStudioAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];
    const intervals = [];

    try {
      const hum = audioContext.createOscillator();
      const humLfo = audioContext.createOscillator();
      const humLfoGain = audioContext.createGain();
      const humGain = audioContext.createGain();

      hum.type = 'sine';
      hum.frequency.value = 110;

      humLfo.type = 'sine';
      humLfo.frequency.value = 0.3;
      humLfoGain.gain.value = 2;

      humGain.gain.value = 0.03;

      humLfo.connect(humLfoGain);
      humLfoGain.connect(hum.frequency);

      hum.connect(humGain);
      humGain.connect(masterGain);

      hum.start();
      humLfo.start();

      oscillators.push(hum, humLfo);
      nodes.push(humLfoGain, humGain);

      function tap() {
        if (!audioContext || !masterGain) return;

        const thud = audioContext.createOscillator();
        const thudGain = audioContext.createGain();

        thud.type = 'sine';
        thud.frequency.value = 100 + Math.random() * 200;

        thudGain.gain.value = 0.05;
        thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

        thud.connect(thudGain);
        thudGain.connect(masterGain);

        thud.start();
        thud.stop(audioContext.currentTime + 0.08);

        const nextTap = setTimeout(tap, 500 + Math.random() * 1500);
        timeouts.push(nextTap);
      }

      const firstTap = setTimeout(tap, 500);
      timeouts.push(firstTap);

      function chime() {
        if (!audioContext || !masterGain) return;

        const bell = audioContext.createOscillator();
        const bellGain = audioContext.createGain();

        bell.type = 'triangle';
        bell.frequency.value = 500 + Math.random() * 700;

        bellGain.gain.value = 0.04;
        bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);

        bell.connect(bellGain);
        bellGain.connect(masterGain);

        bell.start();
        bell.stop(audioContext.currentTime + 1.2);

        const nextChime = setTimeout(chime, 3000 + Math.random() * 5000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(chime, 2000);
      timeouts.push(firstChime);

      function melody() {
        if (!audioContext || !masterGain) return;

        const notes = [261.63, 293.66, 329.63, 392.00, 440.00]; // C, D, E, G, A
        const numNotes = 3 + Math.floor(Math.random() * 3);

        for (let i = 0; i < numNotes; i++) {
          const note = audioContext.createOscillator();
          const noteGain = audioContext.createGain();

          note.type = 'sine';
          note.frequency.value = notes[Math.floor(Math.random() * notes.length)];

          const startTime = audioContext.currentTime + i * 0.2;
          noteGain.gain.setValueAtTime(0, startTime);
          noteGain.gain.linearRampToValueAtTime(0.03, startTime + 0.05);
          noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

          note.connect(noteGain);
          noteGain.connect(masterGain);

          note.start(startTime);
          note.stop(startTime + 0.4);
        }

        const nextMelody = setTimeout(melody, 15000 + Math.random() * 15000);
        timeouts.push(nextMelody);
      }

      const firstMelody = setTimeout(melody, 10000);
      timeouts.push(firstMelody);

      return { oscillators, nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in studio ambient:', err);
      return null;
    }
  }

  function playWildsAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 150;
        windGain.gain.value = 0.05;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);

        function varyWind() {
          if (!windGain || !audioContext) return;
          const target = 0.05 + Math.random() * 0.06;
          windGain.gain.linearRampToValueAtTime(target, audioContext.currentTime + 3);
        }

        const windInterval = setInterval(varyWind, 4000);
        intervals.push(windInterval);
      }

      function howl() {
        if (!audioContext || !masterGain) return;

        const wolf = audioContext.createOscillator();
        const wolfVibrato = audioContext.createOscillator();
        const wolfVibratoGain = audioContext.createGain();
        const wolfGain = audioContext.createGain();

        wolf.type = 'sine';
        wolf.frequency.value = 400;

        wolfVibrato.type = 'sine';
        wolfVibrato.frequency.value = 5;
        wolfVibratoGain.gain.value = 15;

        wolfGain.gain.value = 0.04;

        wolfVibrato.connect(wolfVibratoGain);
        wolfVibratoGain.connect(wolf.frequency);

        wolf.connect(wolfGain);
        wolfGain.connect(masterGain);

        wolf.start();
        wolfVibrato.start();

        wolf.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 1);
        wolf.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 2);
        wolfGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        wolf.stop(audioContext.currentTime + 2.5);
        wolfVibrato.stop(audioContext.currentTime + 2.5);

        const nextHowl = setTimeout(howl, 20000 + Math.random() * 20000);
        timeouts.push(nextHowl);
      }

      const firstHowl = setTimeout(howl, 5000);
      timeouts.push(firstHowl);

      function thunder() {
        if (!audioContext || !masterGain) return;

        const rumble = createWhiteNoise(2);
        if (rumble) {
          const rumbleFilter = audioContext.createBiquadFilter();
          const rumbleGain = audioContext.createGain();

          rumbleFilter.type = 'lowpass';
          rumbleFilter.frequency.value = 60;

          rumbleGain.gain.value = 0.04;
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);

          rumble.connect(rumbleFilter);
          rumbleFilter.connect(rumbleGain);
          rumbleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (rumble.stop) rumble.stop();
              if (rumbleFilter.disconnect) rumbleFilter.disconnect();
              if (rumbleGain.disconnect) rumbleGain.disconnect();
            } catch (e) {}
          }, 2500);
        }

        const nextThunder = setTimeout(thunder, 30000 + Math.random() * 30000);
        timeouts.push(nextThunder);
      }

      const firstThunder = setTimeout(thunder, 15000);
      timeouts.push(firstThunder);

      function rustle() {
        if (!audioContext || !masterGain) return;

        const brush = createWhiteNoise(2);
        if (brush) {
          const brushFilter = audioContext.createBiquadFilter();
          const brushGain = audioContext.createGain();

          brushFilter.type = 'bandpass';
          brushFilter.frequency.value = 1000;
          brushFilter.Q.value = 2;

          brushGain.gain.value = 0.05;
          brushGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

          brush.connect(brushFilter);
          brushFilter.connect(brushGain);
          brushGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (brush.stop) brush.stop();
              if (brushFilter.disconnect) brushFilter.disconnect();
              if (brushGain.disconnect) brushGain.disconnect();
            } catch (e) {}
          }, 400);
        }

        const nextRustle = setTimeout(rustle, 3000 + Math.random() * 4000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 2000);
      timeouts.push(firstRustle);

      function hoot() {
        if (!audioContext || !masterGain) return;

        const hoot1 = audioContext.createOscillator();
        const hoot1Gain = audioContext.createGain();

        hoot1.type = 'sine';
        hoot1.frequency.value = 350;

        hoot1Gain.gain.value = 0.04;
        hoot1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        hoot1.connect(hoot1Gain);
        hoot1Gain.connect(masterGain);

        hoot1.start();
        hoot1.stop(audioContext.currentTime + 0.3);

        const hoot2 = audioContext.createOscillator();
        const hoot2Gain = audioContext.createGain();

        hoot2.type = 'sine';
        hoot2.frequency.value = 280;

        hoot2Gain.gain.setValueAtTime(0, audioContext.currentTime + 0.35);
        hoot2Gain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.4);
        hoot2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.7);

        hoot2.connect(hoot2Gain);
        hoot2Gain.connect(masterGain);

        hoot2.start(audioContext.currentTime + 0.35);
        hoot2.stop(audioContext.currentTime + 0.7);

        const nextHoot = setTimeout(hoot, 15000 + Math.random() * 10000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(hoot, 8000);
      timeouts.push(firstHoot);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in wilds ambient:', err);
      return null;
    }
  }

  function playAgoraAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdLfo = audioContext.createOscillator();
        const crowdLfoGain = audioContext.createGain();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 500;
        crowdFilter.Q.value = 1;

        crowdLfo.type = 'sine';
        crowdLfo.frequency.value = 0.4;
        crowdLfoGain.gain.value = 0.02;

        crowdGain.gain.value = 0.03;

        crowdLfo.connect(crowdLfoGain);
        crowdLfoGain.connect(crowdGain.gain);

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        crowdLfo.start();

        nodes.push(crowd, crowdFilter, crowdLfo, crowdLfoGain, crowdGain);
      }

      function vendorCall() {
        if (!audioContext || !masterGain) return;

        const notes = [220, 247, 262, 294, 330, 349, 392, 440, 494];
        const numNotes = 2 + Math.floor(Math.random() * 2);

        for (let i = 0; i < numNotes; i++) {
          const call = audioContext.createOscillator();
          const callGain = audioContext.createGain();

          call.type = 'sine';
          call.frequency.value = notes[Math.floor(Math.random() * notes.length)];

          const startTime = audioContext.currentTime + i * 0.15;
          callGain.gain.setValueAtTime(0, startTime);
          callGain.gain.linearRampToValueAtTime(0.04, startTime + 0.05);
          callGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

          call.connect(callGain);
          callGain.connect(masterGain);

          call.start(startTime);
          call.stop(startTime + 0.25);
        }

        const nextCall = setTimeout(vendorCall, 8000 + Math.random() * 7000);
        timeouts.push(nextCall);
      }

      const firstCall = setTimeout(vendorCall, 3000);
      timeouts.push(firstCall);

      function coinDrop() {
        if (!audioContext || !masterGain) return;

        const coin = audioContext.createOscillator();
        const coinGain = audioContext.createGain();

        coin.type = 'triangle';
        coin.frequency.value = 2000 + Math.random() * 1000;

        coinGain.gain.value = 0.03;
        coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        coin.connect(coinGain);
        coinGain.connect(masterGain);

        coin.start();
        coin.stop(audioContext.currentTime + 0.15);

        const nextCoin = setTimeout(coinDrop, 3000 + Math.random() * 5000);
        timeouts.push(nextCoin);
      }

      const firstCoin = setTimeout(coinDrop, 2000);
      timeouts.push(firstCoin);

      function cartRumble() {
        if (!audioContext || !masterGain) return;

        const cart = createWhiteNoise(2);
        if (cart) {
          const cartFilter = audioContext.createBiquadFilter();
          const cartGain = audioContext.createGain();

          cartFilter.type = 'lowpass';
          cartFilter.frequency.value = 80;

          cartGain.gain.value = 0.04;
          cartGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);

          cart.connect(cartFilter);
          cartFilter.connect(cartGain);
          cartGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (cart.stop) cart.stop();
              if (cartFilter.disconnect) cartFilter.disconnect();
              if (cartGain.disconnect) cartGain.disconnect();
            } catch (e) {}
          }, 2500);
        }

        const nextCart = setTimeout(cartRumble, 15000 + Math.random() * 15000);
        timeouts.push(nextCart);
      }

      const firstCart = setTimeout(cartRumble, 5000);
      timeouts.push(firstCart);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in agora ambient:', err);
      return null;
    }
  }

  function playCommonsAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      const chatter = createWhiteNoise();
      if (chatter) {
        const chatterFilter = audioContext.createBiquadFilter();
        const chatterGain = audioContext.createGain();

        chatterFilter.type = 'bandpass';
        chatterFilter.frequency.value = 450;
        chatterFilter.Q.value = 1.5;

        chatterGain.gain.value = 0.018;

        chatter.connect(chatterFilter);
        chatterFilter.connect(chatterGain);
        chatterGain.connect(masterGain);

        nodes.push(chatter, chatterFilter, chatterGain);
      }

      function crackle() {
        if (!audioContext || !masterGain) return;

        const fire = createWhiteNoise(2);
        if (fire) {
          const fireFilter = audioContext.createBiquadFilter();
          const fireGain = audioContext.createGain();

          fireFilter.type = 'bandpass';
          fireFilter.frequency.value = 1500 + Math.random() * 1500;
          fireFilter.Q.value = 3;

          const gain = 0.01 + Math.random() * 0.02;
          fireGain.gain.value = gain;
          fireGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

          fire.connect(fireFilter);
          fireFilter.connect(fireGain);
          fireGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (fire.stop) fire.stop();
              if (fireFilter.disconnect) fireFilter.disconnect();
              if (fireGain.disconnect) fireGain.disconnect();
            } catch (e) {}
          }, 150);
        }

        const nextCrackle = setTimeout(crackle, 100 + Math.random() * 300);
        timeouts.push(nextCrackle);
      }

      const firstCrackle = setTimeout(crackle, 500);
      timeouts.push(firstCrackle);

      let hammerActive = true;
      function hammer() {
        if (!audioContext || !masterGain || !hammerActive) return;

        const thunk = audioContext.createOscillator();
        const thunkGain = audioContext.createGain();

        thunk.type = 'square';
        thunk.frequency.value = 80;

        thunkGain.gain.value = 0.06;
        thunkGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

        thunk.connect(thunkGain);
        thunkGain.connect(masterGain);

        thunk.start();
        thunk.stop(audioContext.currentTime + 0.1);

        const nextHammer = setTimeout(hammer, 800 + Math.random() * 400);
        timeouts.push(nextHammer);
      }

      function toggleHammer() {
        hammerActive = !hammerActive;
        if (hammerActive) {
          hammer();
        }
      }

      const firstHammer = setTimeout(hammer, 1000);
      timeouts.push(firstHammer);

      const hammerToggle = setInterval(toggleHammer, 8000);
      intervals.push(hammerToggle);

      let sawActive = false;
      function saw() {
        if (!audioContext || !masterGain || !sawActive) return;

        const sawNoise = createWhiteNoise(2);
        if (sawNoise) {
          const sawFilter = audioContext.createBiquadFilter();
          const sawGain = audioContext.createGain();

          sawFilter.type = 'bandpass';
          sawFilter.frequency.value = 400;
          sawFilter.Q.value = 5;

          sawGain.gain.value = 0.04;

          sawNoise.connect(sawFilter);
          sawFilter.connect(sawGain);
          sawGain.connect(masterGain);

          sawFilter.frequency.linearRampToValueAtTime(1000, audioContext.currentTime + 0.5);

          setTimeout(() => {
            try {
              if (sawNoise.stop) sawNoise.stop();
              if (sawFilter.disconnect) sawFilter.disconnect();
              if (sawGain.disconnect) sawGain.disconnect();
            } catch (e) {}
          }, 550);
        }

        const nextSaw = setTimeout(saw, 1000);
        timeouts.push(nextSaw);
      }

      function toggleSaw() {
        sawActive = !sawActive;
        if (sawActive) {
          saw();
        }
      }

      const sawToggle = setInterval(toggleSaw, 6000);
      intervals.push(sawToggle);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in commons ambient:', err);
      return null;
    }
  }

  function playArenaAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 600;
        crowdFilter.Q.value = 0.8;

        crowdGain.gain.value = 0.035;

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        nodes.push(crowd, crowdFilter, crowdGain);

        function swell() {
          if (!crowdGain || !audioContext) return;
          crowdGain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 2);
          crowdGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 4);
        }

        const swellInterval = setInterval(swell, 12000);
        intervals.push(swellInterval);
      }

      function drumBeat() {
        if (!audioContext || !masterGain) return;

        const drum = audioContext.createOscillator();
        const drumGain = audioContext.createGain();

        drum.type = 'sine';
        drum.frequency.value = 55;

        drumGain.gain.value = 0.08;
        drumGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        drum.connect(drumGain);
        drumGain.connect(masterGain);

        drum.start();
        drum.stop(audioContext.currentTime + 0.15);
      }

      const drumInterval = setInterval(drumBeat, 500); // 120 BPM
      intervals.push(drumInterval);

      function clash() {
        if (!audioContext || !masterGain) return;

        const metal = createWhiteNoise(2);
        if (metal) {
          const metalFilter = audioContext.createBiquadFilter();
          const metalGain = audioContext.createGain();

          metalFilter.type = 'bandpass';
          metalFilter.frequency.value = 3000;
          metalFilter.Q.value = 3;

          metalGain.gain.value = 0.06;
          metalGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

          metal.connect(metalFilter);
          metalFilter.connect(metalGain);
          metalGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (metal.stop) metal.stop();
              if (metalFilter.disconnect) metalFilter.disconnect();
              if (metalGain.disconnect) metalGain.disconnect();
            } catch (e) {}
          }, 250);
        }

        const nextClash = setTimeout(clash, 5000 + Math.random() * 5000);
        timeouts.push(nextClash);
      }

      const firstClash = setTimeout(clash, 3000);
      timeouts.push(firstClash);

      function hornCall() {
        if (!audioContext || !masterGain) return;

        const horn = audioContext.createOscillator();
        const hornGain = audioContext.createGain();

        horn.type = 'sawtooth';
        horn.frequency.value = 220;

        hornGain.gain.setValueAtTime(0, audioContext.currentTime);
        hornGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.2);
        hornGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.8);
        hornGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);

        horn.connect(hornGain);
        hornGain.connect(masterGain);

        horn.start();
        horn.stop(audioContext.currentTime + 1);

        const nextHorn = setTimeout(hornCall, 20000 + Math.random() * 10000);
        timeouts.push(nextHorn);
      }

      const firstHorn = setTimeout(hornCall, 10000);
      timeouts.push(firstHorn);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in arena ambient:', err);
      return null;
    }
  }

  function playSound(type) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (type) {
        case 'chat':
          playChatSound();
          break;
        case 'warp':
          playWarpSound();
          break;
        case 'harvest':
          playHarvestSound();
          break;
        case 'build':
          playBuildSound();
          break;
        case 'trade':
          playTradeSound();
          break;
        case 'trade_request':
          playTradeRequestSound();
          break;
        case 'discover':
          playDiscoverSound();
          break;
        case 'challenge':
          playChallengeSound();
          break;
        case 'levelup':
          playLevelUpSound();
          break;
        case 'level_up':
          playLevelUpSound();
          break;
        case 'error':
          playErrorSound();
          break;
        case 'notification':
          playNotificationSound();
          break;
        case 'craft_complete':
          playCraftCompleteSound();
          break;
        case 'quest_accept':
          playQuestAcceptSound();
          break;
        case 'quest_complete':
          playQuestCompleteSound();
          break;
        case 'item_pickup':
          playItemPickupSound();
          break;
        case 'npc_greet':
          playNPCGreetSound();
          break;
        case 'portal_enter':
          playPortalEnterSound();
          break;
        case 'build_place':
          playBuildPlaceSound();
          break;
        case 'footstep':
          playFootstepSound();
          break;
        case 'zone_enter':
          playZoneEntrySwoosh();
          break;
        case 'shutter':
          playShutterSound();
          break;
        case 'coin':
          playCoinSound();
          break;
        default:
          console.warn('Unknown sound type:', type);
      }
    } catch (err) {
      console.error('Error playing sound:', err);
    }
  }

  function playChatSound() {
    if (!audioContext || !masterGain) return;

    const blip1 = audioContext.createOscillator();
    const blip1Gain = audioContext.createGain();

    blip1.type = 'sine';
    blip1.frequency.value = 600;

    blip1Gain.gain.value = 0.05;
    blip1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

    blip1.connect(blip1Gain);
    blip1Gain.connect(masterGain);

    blip1.start();
    blip1.stop(audioContext.currentTime + 0.05);

    const blip2 = audioContext.createOscillator();
    const blip2Gain = audioContext.createGain();

    blip2.type = 'sine';
    blip2.frequency.value = 900;

    blip2Gain.gain.setValueAtTime(0, audioContext.currentTime + 0.05);
    blip2Gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.06);
    blip2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

    blip2.connect(blip2Gain);
    blip2Gain.connect(masterGain);

    blip2.start(audioContext.currentTime + 0.05);
    blip2.stop(audioContext.currentTime + 0.1);
  }

  function playWarpSound() {
    if (!audioContext || !masterGain) return;

    const warp = audioContext.createOscillator();
    const warpGain = audioContext.createGain();
    const delay1 = audioContext.createDelay();
    const delay2 = audioContext.createDelay();
    const delayGain1 = audioContext.createGain();
    const delayGain2 = audioContext.createGain();

    warp.type = 'sawtooth';
    warp.frequency.value = 800;
    warp.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);

    warpGain.gain.value = 0.06;
    warpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    delay1.delayTime.value = 0.1;
    delay2.delayTime.value = 0.2;
    delayGain1.gain.value = 0.1;
    delayGain2.gain.value = 0.06;

    warp.connect(warpGain);
    warpGain.connect(masterGain);
    warpGain.connect(delay1);
    warpGain.connect(delay2);
    delay1.connect(delayGain1);
    delay2.connect(delayGain2);
    delayGain1.connect(masterGain);
    delayGain2.connect(masterGain);

    warp.start();
    warp.stop(audioContext.currentTime + 0.5);
  }

  function playHarvestSound() {
    if (!audioContext || !masterGain) return;

    const pluck = audioContext.createOscillator();
    const harmonic = audioContext.createOscillator();
    const pluckGain = audioContext.createGain();

    pluck.type = 'triangle';
    pluck.frequency.value = 330;

    harmonic.type = 'triangle';
    harmonic.frequency.value = 660;

    pluckGain.gain.value = 0.06;
    pluckGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    pluck.connect(pluckGain);
    harmonic.connect(pluckGain);
    pluckGain.connect(masterGain);

    pluck.start();
    harmonic.start();
    pluck.stop(audioContext.currentTime + 0.3);
    harmonic.stop(audioContext.currentTime + 0.3);
  }

  function playBuildSound() {
    if (!audioContext || !masterGain) return;

    const thump = audioContext.createOscillator();
    const thumpGain = audioContext.createGain();

    thump.type = 'square';
    thump.frequency.value = 80;

    thumpGain.gain.value = 0.06;
    thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

    thump.connect(thumpGain);
    thumpGain.connect(masterGain);

    thump.start();
    thump.stop(audioContext.currentTime + 0.15);

    const click = audioContext.createOscillator();
    const clickGain = audioContext.createGain();

    click.type = 'sine';
    click.frequency.value = 2000;

    clickGain.gain.value = 0.04;
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

    click.connect(clickGain);
    clickGain.connect(masterGain);

    click.start();
    click.stop(audioContext.currentTime + 0.02);
  }

  function playTradeSound() {
    if (!audioContext || !masterGain) return;

    const coin1 = audioContext.createOscillator();
    const coin2 = audioContext.createOscillator();
    const wobble = audioContext.createOscillator();
    const wobbleGain = audioContext.createGain();
    const coinGain = audioContext.createGain();

    coin1.type = 'sine';
    coin1.frequency.value = 1200;

    coin2.type = 'sine';
    coin2.frequency.value = 1500;

    wobble.type = 'sine';
    wobble.frequency.value = 5;
    wobbleGain.gain.value = 3;

    coinGain.gain.value = 0.05;
    coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    wobble.connect(wobbleGain);
    wobbleGain.connect(coin1.frequency);
    wobbleGain.connect(coin2.frequency);

    coin1.connect(coinGain);
    coin2.connect(coinGain);
    coinGain.connect(masterGain);

    coin1.start();
    coin2.start();
    wobble.start();
    coin1.stop(audioContext.currentTime + 0.3);
    coin2.stop(audioContext.currentTime + 0.3);
    wobble.stop(audioContext.currentTime + 0.3);
  }

  function playDiscoverSound() {
    if (!audioContext || !masterGain) return;

    const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.08;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.2);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.2);
    });
  }

  function playChallengeSound() {
    if (!audioContext || !masterGain) return;

    const horn1 = audioContext.createOscillator();
    const horn2 = audioContext.createOscillator();
    const hornGain = audioContext.createGain();

    horn1.type = 'sawtooth';
    horn1.frequency.value = 220;

    horn2.type = 'sawtooth';
    horn2.frequency.value = 330;

    hornGain.gain.setValueAtTime(0, audioContext.currentTime);
    hornGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.1);
    hornGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.4);
    hornGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    horn1.connect(hornGain);
    horn2.connect(hornGain);
    hornGain.connect(masterGain);

    horn1.start();
    horn2.start();
    horn1.stop(audioContext.currentTime + 0.5);
    horn2.stop(audioContext.currentTime + 0.5);
  }

  function playLevelUpSound() {
    if (!audioContext || !masterGain) return;

    const notes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.1;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.1);
      noteGain.gain.linearRampToValueAtTime(0.03, startTime + 0.5);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.8);
    });
  }

  function playErrorSound() {
    if (!audioContext || !masterGain) return;

    const buzz = audioContext.createOscillator();
    const buzzGain = audioContext.createGain();

    buzz.type = 'square';
    buzz.frequency.value = 100;

    buzzGain.gain.value = 0.04;
    buzzGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    buzz.connect(buzzGain);
    buzzGain.connect(masterGain);

    buzz.start();
    buzz.stop(audioContext.currentTime + 0.2);
  }

  function playNotificationSound() {
    if (!audioContext || !masterGain) return;

    const bell = audioContext.createOscillator();
    const bellGain = audioContext.createGain();

    bell.type = 'sine';
    bell.frequency.value = 800;

    bellGain.gain.value = 0.05;
    bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

    bell.connect(bellGain);
    bellGain.connect(masterGain);

    bell.start();
    bell.stop(audioContext.currentTime + 0.4);
  }

  function playTradeRequestSound() {
    if (!audioContext || !masterGain) return;

    const bell = audioContext.createOscillator();
    const bellGain = audioContext.createGain();

    bell.type = 'sine';
    bell.frequency.value = 700;

    bellGain.gain.value = 0.04;
    bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    bell.connect(bellGain);
    bellGain.connect(masterGain);

    bell.start();
    bell.stop(audioContext.currentTime + 0.5);
  }

  function playCraftCompleteSound() {
    if (!audioContext || !masterGain) return;

    const anvil = audioContext.createOscillator();
    const anvilGain = audioContext.createGain();

    anvil.type = 'square';
    anvil.frequency.value = 120;

    anvilGain.gain.value = 0.06;
    anvilGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    anvil.connect(anvilGain);
    anvilGain.connect(masterGain);

    anvil.start();
    anvil.stop(audioContext.currentTime + 0.2);

    const sparkle1 = audioContext.createOscillator();
    const sparkle2 = audioContext.createOscillator();
    const sparkle3 = audioContext.createOscillator();
    const sparkleGain = audioContext.createGain();

    sparkle1.type = 'sine';
    sparkle1.frequency.value = 1800;
    sparkle2.type = 'sine';
    sparkle2.frequency.value = 2200;
    sparkle3.type = 'sine';
    sparkle3.frequency.value = 2600;

    const startTime = audioContext.currentTime + 0.1;
    sparkleGain.gain.setValueAtTime(0, startTime);
    sparkleGain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
    sparkleGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

    sparkle1.connect(sparkleGain);
    sparkle2.connect(sparkleGain);
    sparkle3.connect(sparkleGain);
    sparkleGain.connect(masterGain);

    sparkle1.start(startTime);
    sparkle2.start(startTime + 0.05);
    sparkle3.start(startTime + 0.1);
    sparkle1.stop(startTime + 0.4);
    sparkle2.stop(startTime + 0.45);
    sparkle3.stop(startTime + 0.5);
  }

  function playQuestAcceptSound() {
    if (!audioContext || !masterGain) return;

    const notes = [392.00, 493.88, 587.33]; // G4, B4, D5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.08;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.25);
    });
  }

  function playQuestCompleteSound() {
    if (!audioContext || !masterGain) return;

    const chord1 = audioContext.createOscillator();
    const chord2 = audioContext.createOscillator();
    const chord3 = audioContext.createOscillator();
    const chordGain = audioContext.createGain();

    chord1.type = 'sine';
    chord1.frequency.value = 523.25; // C5
    chord2.type = 'sine';
    chord2.frequency.value = 659.25; // E5
    chord3.type = 'sine';
    chord3.frequency.value = 783.99; // G5

    chordGain.gain.setValueAtTime(0, audioContext.currentTime);
    chordGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.1);
    chordGain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.5);
    chordGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

    chord1.connect(chordGain);
    chord2.connect(chordGain);
    chord3.connect(chordGain);
    chordGain.connect(masterGain);

    chord1.start();
    chord2.start();
    chord3.start();
    chord1.stop(audioContext.currentTime + 0.8);
    chord2.stop(audioContext.currentTime + 0.8);
    chord3.stop(audioContext.currentTime + 0.8);
  }

  function playItemPickupSound() {
    if (!audioContext || !masterGain) return;

    try {
      const bufferSize = audioContext.sampleRate * 0.05; // 50ms
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 1000;
      filter.Q.value = 1;

      const noiseGain = audioContext.createGain();
      noiseGain.gain.value = 0.05;
      noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.08);
    } catch (err) {
      console.error('Error in item pickup sound:', err);
    }
  }

  function playNPCGreetSound() {
    if (!audioContext || !masterGain) return;

    const greet = audioContext.createOscillator();
    const greetGain = audioContext.createGain();

    greet.type = 'sine';
    greet.frequency.value = 440; // A4

    greetGain.gain.setValueAtTime(0, audioContext.currentTime);
    greetGain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.05);
    greetGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.35);

    greet.connect(greetGain);
    greetGain.connect(masterGain);

    greet.start();
    greet.stop(audioContext.currentTime + 0.35);
  }

  function playPortalEnterSound() {
    if (!audioContext || !masterGain) return;

    try {
      const bufferSize = audioContext.sampleRate * 0.8;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 200;
      filter.frequency.exponentialRampToValueAtTime(4000, audioContext.currentTime + 0.8);
      filter.Q.value = 5;

      const whooshGain = audioContext.createGain();
      whooshGain.gain.value = 0.06;
      whooshGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

      noise.connect(filter);
      filter.connect(whooshGain);
      whooshGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.8);

      const tone = audioContext.createOscillator();
      const toneGain = audioContext.createGain();

      tone.type = 'sine';
      tone.frequency.value = 800;
      tone.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.8);

      toneGain.gain.value = 0.03;
      toneGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

      tone.connect(toneGain);
      toneGain.connect(masterGain);

      tone.start();
      tone.stop(audioContext.currentTime + 0.8);
    } catch (err) {
      console.error('Error in portal enter sound:', err);
    }
  }

  function playBuildPlaceSound() {
    if (!audioContext || !masterGain) return;

    const thunk = audioContext.createOscillator();
    const thunkGain = audioContext.createGain();

    thunk.type = 'square';
    thunk.frequency.value = 60;

    thunkGain.gain.value = 0.06;
    thunkGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.12);

    thunk.connect(thunkGain);
    thunkGain.connect(masterGain);

    thunk.start();
    thunk.stop(audioContext.currentTime + 0.12);
  }

  function playZoneEntrySwoosh() {
    if (!audioContext || !masterGain) return;
    try {
      var now = audioContext.currentTime;
      var bufSize = Math.floor(audioContext.sampleRate * 0.04);
      var buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
      var data = buf.getChannelData(0);
      for (var i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      var noise = audioContext.createBufferSource();
      noise.buffer = buf;
      var bandpass = audioContext.createBiquadFilter();
      bandpass.type = 'bandpass';
      bandpass.frequency.value = 400;
      bandpass.Q.value = 1.0;
      var noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(0.04, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
      noise.connect(bandpass);
      bandpass.connect(noiseGain);
      noiseGain.connect(masterGain);
      noise.start(now);
      noise.stop(now + 0.04);

      var sweep = audioContext.createOscillator();
      sweep.type = 'sine';
      sweep.frequency.setValueAtTime(600, now);
      sweep.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      var sweepGain = audioContext.createGain();
      sweepGain.gain.setValueAtTime(0.03, now);
      sweepGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      sweep.connect(sweepGain);
      sweepGain.connect(masterGain);
      sweep.start(now);
      sweep.stop(now + 0.4);
    } catch (err) {
      console.error('Error in zone entry swoosh:', err);
    }
  }

  function playShutterSound() {
    if (!audioContext || !masterGain) return;
    try {
      var now = audioContext.currentTime;
      var bufSize = Math.floor(audioContext.sampleRate * 0.005);
      var buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
      var data = buf.getChannelData(0);
      for (var i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      var click1 = audioContext.createBufferSource();
      click1.buffer = buf;
      var hp1 = audioContext.createBiquadFilter();
      hp1.type = 'highpass';
      hp1.frequency.value = 3000;
      var g1 = audioContext.createGain();
      g1.gain.value = 0.04;
      click1.connect(hp1);
      hp1.connect(g1);
      g1.connect(masterGain);
      click1.start(now);
      click1.stop(now + 0.005);

      var click2 = audioContext.createBufferSource();
      click2.buffer = buf;
      var hp2 = audioContext.createBiquadFilter();
      hp2.type = 'highpass';
      hp2.frequency.value = 3000;
      var g2 = audioContext.createGain();
      g2.gain.value = 0.04;
      click2.connect(hp2);
      hp2.connect(g2);
      g2.connect(masterGain);
      click2.start(now + 0.035);
      click2.stop(now + 0.04);
    } catch (err) {
      console.error('Error in shutter sound:', err);
    }
  }

  function playCoinSound() {
    if (!audioContext || !masterGain) return;
    try {
      var now = audioContext.currentTime;
      var osc1 = audioContext.createOscillator();
      var g1 = audioContext.createGain();
      osc1.type = 'sine';
      osc1.frequency.value = 880;
      g1.gain.setValueAtTime(0.04, now);
      g1.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
      osc1.connect(g1);
      g1.connect(masterGain);
      osc1.start(now);
      osc1.stop(now + 0.05);
      var osc2 = audioContext.createOscillator();
      var g2 = audioContext.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = 1320;
      g2.gain.setValueAtTime(0.04, now + 0.05);
      g2.gain.exponentialRampToValueAtTime(0.001, now + 0.11);
      osc2.connect(g2);
      g2.connect(masterGain);
      osc2.start(now + 0.05);
      osc2.stop(now + 0.12);
    } catch (err) {
      console.error('Error in coin sound:', err);
    }
  }

  function playFootstepSound() {
    if (!audioContext || !masterGain) return;

    try {
      const bufferSize = audioContext.sampleRate * 0.03; // 30ms
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 300 + Math.random() * 200; // Vary pitch slightly
      filter.Q.value = 0.5;

      const stepGain = audioContext.createGain();
      stepGain.gain.value = 0.05; // Very subtle
      stepGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

      noise.connect(filter);
      filter.connect(stepGain);
      stepGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.05);
    } catch (err) {
      console.error('Error in footstep sound:', err);
    }
  }

  function playFootstep(terrain) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (terrain) {
        case 'grass':
          playGrassFootstep();
          break;
        case 'stone':
          playStoneFootstep();
          break;
        case 'sand':
          playSandFootstep();
          break;
        case 'water':
          playWaterFootstep();
          break;
        case 'wood':
          playWoodFootstep();
          break;
        default:
          playDefaultFootstep();
      }
    } catch (err) {
      console.error('Error playing footstep:', err);
    }
  }

  function playGrassFootstep() {
    if (!audioContext || !masterGain) return;

    const grass = createWhiteNoise(2);
    if (grass) {
      const grassFilter = audioContext.createBiquadFilter();
      const grassGain = audioContext.createGain();

      grassFilter.type = 'lowpass';
      grassFilter.frequency.value = 500;

      grassGain.gain.value = 0.08;
      grassGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

      grass.connect(grassFilter);
      grassFilter.connect(grassGain);
      grassGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (grass.stop) grass.stop();
          if (grassFilter.disconnect) grassFilter.disconnect();
          if (grassGain.disconnect) grassGain.disconnect();
        } catch (e) {}
      }, 100);
    }
  }

  function playStoneFootstep() {
    if (!audioContext || !masterGain) return;

    const thud = audioContext.createOscillator();
    const thudGain = audioContext.createGain();

    thud.type = 'sine';
    thud.frequency.value = 200;

    thudGain.gain.value = 0.04;
    thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

    thud.connect(thudGain);
    thudGain.connect(masterGain);

    thud.start();
    thud.stop(audioContext.currentTime + 0.05);

    const click = audioContext.createOscillator();
    const clickGain = audioContext.createGain();

    click.type = 'sine';
    click.frequency.value = 3000;

    clickGain.gain.value = 0.05;
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

    click.connect(clickGain);
    clickGain.connect(masterGain);

    click.start();
    click.stop(audioContext.currentTime + 0.02);
  }

  function playSandFootstep() {
    if (!audioContext || !masterGain) return;

    const sand = createWhiteNoise(2);
    if (sand) {
      const sandFilter = audioContext.createBiquadFilter();
      const sandGain = audioContext.createGain();

      sandFilter.type = 'lowpass';
      sandFilter.frequency.value = 300;

      sandGain.gain.value = 0.07;
      sandGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

      sand.connect(sandFilter);
      sandFilter.connect(sandGain);
      sandGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (sand.stop) sand.stop();
          if (sandFilter.disconnect) sandFilter.disconnect();
          if (sandGain.disconnect) sandGain.disconnect();
        } catch (e) {}
      }, 120);
    }
  }

  function playWaterFootstep() {
    if (!audioContext || !masterGain) return;

    const splash = createWhiteNoise(2);
    if (splash) {
      const splashFilter = audioContext.createBiquadFilter();
      const splashGain = audioContext.createGain();

      splashFilter.type = 'bandpass';
      splashFilter.frequency.value = 800;
      splashFilter.Q.value = 2;

      splashGain.gain.value = 0.04;
      splashGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.12);

      splash.connect(splashFilter);
      splashFilter.connect(splashGain);
      splashGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (splash.stop) splash.stop();
          if (splashFilter.disconnect) splashFilter.disconnect();
          if (splashGain.disconnect) splashGain.disconnect();
        } catch (e) {}
      }, 150);
    }

    for (let i = 0; i < 2; i++) {
      setTimeout(() => {
        const bubble = audioContext.createOscillator();
        const bubbleGain = audioContext.createGain();

        bubble.type = 'sine';
        bubble.frequency.value = 1500 + Math.random() * 1500;

        bubbleGain.gain.value = 0.03;
        bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

        bubble.connect(bubbleGain);
        bubbleGain.connect(masterGain);

        bubble.start();
        bubble.stop(audioContext.currentTime + 0.05);
      }, i * 50);
    }
  }

  function playWoodFootstep() {
    if (!audioContext || !masterGain) return;

    const knock = audioContext.createOscillator();
    const knockGain = audioContext.createGain();

    knock.type = 'sine';
    knock.frequency.value = 150;

    knockGain.gain.value = 0.04;
    knockGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.06);

    knock.connect(knockGain);
    knockGain.connect(masterGain);

    knock.start();
    knock.stop(audioContext.currentTime + 0.06);
  }

  function playDefaultFootstep() {
    if (!audioContext || !masterGain) return;

    const thud = audioContext.createOscillator();
    const thudGain = audioContext.createGain();

    thud.type = 'sine';
    thud.frequency.value = 100;

    thudGain.gain.value = 0.08;
    thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.07);

    thud.connect(thudGain);
    thudGain.connect(masterGain);

    thud.start();
    thud.stop(audioContext.currentTime + 0.07);
  }

  function setVolume(channel, level) {
    if (typeof channel === 'number') {
      level = channel;
      channel = 'master';
    }
    var clampedLevel = Math.max(0, Math.min(1, level));
    volumeLevels[channel] = clampedLevel;
    if (channel === 'master' && masterGain) {
      masterGain.gain.value = clampedLevel;
    }
    if (channel === 'music') {
      setMusicVolume(clampedLevel);
    }
  }

  function mute() {
    if (!masterGain) return;

    isMuted = true;
    masterGain.gain.value = 0;
  }

  function unmute() {
    if (!masterGain) return;

    isMuted = false;
    masterGain.gain.value = 0.15;
  }

  function stopAll() {
    stopAmbient();
    stopTimeAmbient();
    stopWeatherAmbient();
    stopZoneAmbient();
    killAllNoiseSources();
  }

  let currentTimeAmbient = null;

  var cricketLayer = null;

  function playNightCricketLayer() {
    if (!audioContext || !masterGain) return null;
    try {
      var layerGain = audioContext.createGain();
      layerGain.gain.value = 0.006;

      var cricket1 = audioContext.createOscillator();
      cricket1.type = 'sine';
      cricket1.frequency.value = 3200;
      var lfo1 = audioContext.createOscillator();
      lfo1.type = 'sine';
      lfo1.frequency.value = 12;
      var lfoGain1 = audioContext.createGain();
      lfoGain1.gain.value = 0.3;
      lfo1.connect(lfoGain1);
      var cricket1Gain = audioContext.createGain();
      cricket1Gain.gain.value = 0.3;
      lfoGain1.connect(cricket1Gain.gain);
      cricket1.connect(cricket1Gain);
      cricket1Gain.connect(layerGain);

      var cricket2 = audioContext.createOscillator();
      cricket2.type = 'sine';
      cricket2.frequency.value = 3400;
      var lfo2 = audioContext.createOscillator();
      lfo2.type = 'sine';
      lfo2.frequency.value = 10;
      var lfoGain2 = audioContext.createGain();
      lfoGain2.gain.value = 0.3;
      lfo2.connect(lfoGain2);
      var cricket2Gain = audioContext.createGain();
      cricket2Gain.gain.value = 0.3;
      lfoGain2.connect(cricket2Gain.gain);
      cricket2.connect(cricket2Gain);
      cricket2Gain.connect(layerGain);

      layerGain.connect(masterGain);
      cricket1.start();
      cricket2.start();
      lfo1.start();
      lfo2.start();

      return {
        oscillators: [cricket1, cricket2, lfo1, lfo2],
        nodes: [cricket1Gain, cricket2Gain, lfoGain1, lfoGain2, layerGain],
        gainNode: layerGain
      };
    } catch (err) {
      console.error('Error in cricket layer:', err);
      return null;
    }
  }

  function stopCricketLayer() {
    if (!cricketLayer) return;
    try {
      if (cricketLayer.gainNode) {
        cricketLayer.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
      }
      var cl = cricketLayer;
      setTimeout(function() {
        if (cl.oscillators) {
          cl.oscillators.forEach(function(o) { try { o.stop(); } catch(e) {} });
        }
      }, 2100);
      cricketLayer = null;
    } catch (err) {
      console.error('Error stopping crickets:', err);
    }
  }

  function updateAmbientForTime(timePeriod) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    stopTimeAmbient();

    try {
      switch (timePeriod) {
        case 'dawn':
          currentTimeAmbient = playDawnAmbient();
          break;
        case 'morning':
          currentTimeAmbient = playMorningAmbient();
          break;
        case 'midday':
          currentTimeAmbient = playMiddayAmbient();
          break;
        case 'afternoon':
          currentTimeAmbient = playAfternoonAmbient();
          break;
        case 'evening':
          currentTimeAmbient = playEveningAmbient();
          break;
        case 'night':
          currentTimeAmbient = playNightAmbient();
          break;
        default:
          currentTimeAmbient = null;
      }

      if (timePeriod === 'night' || timePeriod === 'evening') {
        if (!cricketLayer) {
          cricketLayer = playNightCricketLayer();
        }
      } else if (timePeriod === 'dawn' || timePeriod === 'morning') {
        stopCricketLayer();
      } else {
        stopCricketLayer();
      }
    } catch (err) {
      console.error('Error updating time ambient:', err);
    }
  }

  function stopTimeAmbient() {
    if (!currentTimeAmbient) return;

    try {
      if (currentTimeAmbient.oscillators && Array.isArray(currentTimeAmbient.oscillators)) {
        currentTimeAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentTimeAmbient.nodes && Array.isArray(currentTimeAmbient.nodes)) {
        currentTimeAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentTimeAmbient.intervals && Array.isArray(currentTimeAmbient.intervals)) {
        currentTimeAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentTimeAmbient.timeouts && Array.isArray(currentTimeAmbient.timeouts)) {
        currentTimeAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentTimeAmbient.cleanup && typeof currentTimeAmbient.cleanup === 'function') {
        currentTimeAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping time ambient:', err);
    }

    currentTimeAmbient = null;
    killAllNoiseSources();
  }

  function playDawnAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 180;
        windGain.gain.value = 0.02;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      function dawnChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 800 + Math.random() * 1000;

        const duration = 0.05 + Math.random() * 0.1;
        birdGain.gain.value = 0.04;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(dawnChirp, 800 + Math.random() * 2000);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 2; i++) {
        const firstChirp = setTimeout(dawnChirp, Math.random() * 1000);
        timeouts.push(firstChirp);
      }

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in dawn ambient:', err);
      return null;
    }
  }

  function playMorningAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 200;
        breezeGain.gain.value = 0.025;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      function morningChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 700 + Math.random() * 1200;

        const duration = 0.08 + Math.random() * 0.15;
        birdGain.gain.value = 0.05;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(morningChirp, 400 + Math.random() * 2500);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 3; i++) {
        const firstChirp = setTimeout(morningChirp, Math.random() * 1500);
        timeouts.push(firstChirp);
      }

      function buzz() {
        if (!audioContext || !masterGain) return;

        const insect = audioContext.createOscillator();
        const insectGain = audioContext.createGain();

        insect.type = 'sawtooth';
        insect.frequency.value = 250 + Math.random() * 100;

        insectGain.gain.value = 0.02;
        insectGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        insect.connect(insectGain);
        insectGain.connect(masterGain);

        insect.start();
        insect.stop(audioContext.currentTime + 0.3);

        const nextBuzz = setTimeout(buzz, 8000 + Math.random() * 12000);
        timeouts.push(nextBuzz);
      }

      const firstBuzz = setTimeout(buzz, 5000);
      timeouts.push(firstBuzz);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in morning ambient:', err);
      return null;
    }
  }

  function playMiddayAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 220;
        breezeGain.gain.value = 0.03;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      const cicada = audioContext.createOscillator();
      const cicadaAm = audioContext.createOscillator();
      const cicadaAmGain = audioContext.createGain();
      const cicadaGain = audioContext.createGain();

      cicada.type = 'sine';
      cicada.frequency.value = 3500 + Math.random() * 500;

      cicadaAm.type = 'sine';
      cicadaAm.frequency.value = 15 + Math.random() * 10;
      cicadaAmGain.gain.value = 0.02;

      cicadaGain.gain.value = 0.04;

      cicadaAm.connect(cicadaAmGain);
      cicadaAmGain.connect(cicadaGain.gain);

      cicada.connect(cicadaGain);
      cicadaGain.connect(masterGain);

      cicada.start();
      cicadaAm.start();

      oscillators.push(cicada, cicadaAm);
      nodes.push(cicadaAmGain, cicadaGain);

      function middayChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 600 + Math.random() * 800;

        const duration = 0.1 + Math.random() * 0.15;
        birdGain.gain.value = 0.03;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(middayChirp, 3000 + Math.random() * 5000);
        timeouts.push(nextChirp);
      }

      const firstChirp = setTimeout(middayChirp, 2000);
      timeouts.push(firstChirp);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in midday ambient:', err);
      return null;
    }
  }

  function playAfternoonAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 190;
        breezeGain.gain.value = 0.025;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      function afternoonChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 500 + Math.random() * 900;

        const duration = 0.1 + Math.random() * 0.2;
        birdGain.gain.value = 0.04;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(afternoonChirp, 1500 + Math.random() * 4000);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 2; i++) {
        const firstChirp = setTimeout(afternoonChirp, Math.random() * 2000);
        timeouts.push(firstChirp);
      }

      function rustle() {
        if (!audioContext || !masterGain) return;

        const noise = createWhiteNoise(2);
        if (noise) {
          const rustleFilter = audioContext.createBiquadFilter();
          const rustleGain = audioContext.createGain();

          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 1800 + Math.random() * 400;
          rustleFilter.Q.value = 2;

          rustleGain.gain.value = 0.03;
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

          noise.connect(rustleFilter);
          rustleFilter.connect(rustleGain);
          rustleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (noise.stop) noise.stop();
              if (rustleFilter.disconnect) rustleFilter.disconnect();
              if (rustleGain.disconnect) rustleGain.disconnect();
            } catch (e) {}
          }, 450);
        }

        const nextRustle = setTimeout(rustle, 2500 + Math.random() * 3500);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 1500);
      timeouts.push(firstRustle);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in afternoon ambient:', err);
      return null;
    }
  }

  function playEveningAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 170;
        windGain.gain.value = 0.02;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 4000 + Math.random() * 500;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 18 + Math.random() * 8;
      cricketAmGain.gain.value = 0.025;

      cricketGain.gain.value = 0.03;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      oscillators.push(cricket, cricketAm);
      nodes.push(cricketAmGain, cricketGain);

      function hoot() {
        if (!audioContext || !masterGain) return;

        const owl = audioContext.createOscillator();
        const owlVibrato = audioContext.createOscillator();
        const owlVibratoGain = audioContext.createGain();
        const owlGain = audioContext.createGain();

        owl.type = 'sine';
        owl.frequency.value = 320;

        owlVibrato.type = 'sine';
        owlVibrato.frequency.value = 4;
        owlVibratoGain.gain.value = 8;

        owlGain.gain.value = 0.05;
        owlGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

        owlVibrato.connect(owlVibratoGain);
        owlVibratoGain.connect(owl.frequency);

        owl.connect(owlGain);
        owlGain.connect(masterGain);

        owl.start();
        owlVibrato.start();

        owl.stop(audioContext.currentTime + 0.4);
        owlVibrato.stop(audioContext.currentTime + 0.4);

        const nextHoot = setTimeout(hoot, 12000 + Math.random() * 12000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(hoot, 5000);
      timeouts.push(firstHoot);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in evening ambient:', err);
      return null;
    }
  }

  function playNightAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 150;
        windGain.gain.value = 0.015;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 3500 + Math.random() * 300;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 15 + Math.random() * 5;
      cricketAmGain.gain.value = 0.02;

      cricketGain.gain.value = 0.025;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      oscillators.push(cricket, cricketAm);
      nodes.push(cricketAmGain, cricketGain);

      function nightHoot() {
        if (!audioContext || !masterGain) return;

        const owl = audioContext.createOscillator();
        const owlVibrato = audioContext.createOscillator();
        const owlVibratoGain = audioContext.createGain();
        const owlGain = audioContext.createGain();

        owl.type = 'sine';
        owl.frequency.value = 280;

        owlVibrato.type = 'sine';
        owlVibrato.frequency.value = 4;
        owlVibratoGain.gain.value = 6;

        owlGain.gain.value = 0.04;
        owlGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

        owlVibrato.connect(owlVibratoGain);
        owlVibratoGain.connect(owl.frequency);

        owl.connect(owlGain);
        owlGain.connect(masterGain);

        owl.start();
        owlVibrato.start();

        owl.stop(audioContext.currentTime + 0.5);
        owlVibrato.stop(audioContext.currentTime + 0.5);

        const nextHoot = setTimeout(nightHoot, 18000 + Math.random() * 18000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(nightHoot, 8000);
      timeouts.push(firstHoot);

      function distantHowl() {
        if (!audioContext || !masterGain) return;

        const wolf = audioContext.createOscillator();
        const wolfVibrato = audioContext.createOscillator();
        const wolfVibratoGain = audioContext.createGain();
        const wolfGain = audioContext.createGain();

        wolf.type = 'sine';
        wolf.frequency.value = 350;

        wolfVibrato.type = 'sine';
        wolfVibrato.frequency.value = 4;
        wolfVibratoGain.gain.value = 10;

        wolfGain.gain.value = 0.03;

        wolfVibrato.connect(wolfVibratoGain);
        wolfVibratoGain.connect(wolf.frequency);

        wolf.connect(wolfGain);
        wolfGain.connect(masterGain);

        wolf.start();
        wolfVibrato.start();

        wolf.frequency.linearRampToValueAtTime(500, audioContext.currentTime + 1.2);
        wolf.frequency.linearRampToValueAtTime(350, audioContext.currentTime + 2);
        wolfGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        wolf.stop(audioContext.currentTime + 2.5);
        wolfVibrato.stop(audioContext.currentTime + 2.5);

        const nextHowl = setTimeout(distantHowl, 60000 + Math.random() * 60000);
        timeouts.push(nextHowl);
      }

      const firstHowl = setTimeout(distantHowl, 30000);
      timeouts.push(firstHowl);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in night ambient:', err);
      return null;
    }
  }

  let currentWeatherAmbient = null;

  function updateAmbientForWeather(weather) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    stopWeatherAmbient();

    try {
      switch (weather) {
        case 'clear':
          currentWeatherAmbient = null;
          break;
        case 'cloudy':
          currentWeatherAmbient = playCloudyAmbient();
          break;
        case 'rain':
          currentWeatherAmbient = playRainAmbient();
          break;
        case 'snow':
          currentWeatherAmbient = playSnowAmbient();
          break;
        default:
          currentWeatherAmbient = null;
      }
    } catch (err) {
      console.error('Error updating weather ambient:', err);
    }
  }

  function stopWeatherAmbient() {
    if (!currentWeatherAmbient) return;

    try {
      if (currentWeatherAmbient.oscillators && Array.isArray(currentWeatherAmbient.oscillators)) {
        currentWeatherAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentWeatherAmbient.nodes && Array.isArray(currentWeatherAmbient.nodes)) {
        currentWeatherAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentWeatherAmbient.intervals && Array.isArray(currentWeatherAmbient.intervals)) {
        currentWeatherAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentWeatherAmbient.timeouts && Array.isArray(currentWeatherAmbient.timeouts)) {
        currentWeatherAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentWeatherAmbient.cleanup && typeof currentWeatherAmbient.cleanup === 'function') {
        currentWeatherAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping weather ambient:', err);
    }

    currentWeatherAmbient = null;
    killAllNoiseSources();
  }

  function playCloudyAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 200;
        windGain.gain.value = 0.03;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      return { nodes };
    } catch (err) {
      console.error('Error in cloudy ambient:', err);
      return null;
    }
  }

  function playRainAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      const rain = createWhiteNoise();
      if (rain) {
        const rainFilter = audioContext.createBiquadFilter();
        const rainGain = audioContext.createGain();

        rainFilter.type = 'bandpass';
        rainFilter.frequency.value = 4000;
        rainFilter.Q.value = 0.5;

        rainGain.gain.value = 0.05;

        rain.connect(rainFilter);
        rainFilter.connect(rainGain);
        rainGain.connect(masterGain);

        nodes.push(rain, rainFilter, rainGain);
      }

      function thunder() {
        if (!audioContext || !masterGain) return;

        const rumble = createWhiteNoise(2);
        if (rumble) {
          const rumbleFilter = audioContext.createBiquadFilter();
          const rumbleGain = audioContext.createGain();

          rumbleFilter.type = 'lowpass';
          rumbleFilter.frequency.value = 80;

          rumbleGain.gain.value = 0.05;
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

          rumble.connect(rumbleFilter);
          rumbleFilter.connect(rumbleGain);
          rumbleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (rumble.stop) rumble.stop();
              if (rumbleFilter.disconnect) rumbleFilter.disconnect();
              if (rumbleGain.disconnect) rumbleGain.disconnect();
            } catch (e) {}
          }, 3000);
        }

        const nextThunder = setTimeout(thunder, 25000 + Math.random() * 35000);
        timeouts.push(nextThunder);
      }

      const firstThunder = setTimeout(thunder, 15000);
      timeouts.push(firstThunder);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in rain ambient:', err);
      return null;
    }
  }

  function playSnowAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 120;
        windGain.gain.value = 0.015;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      return { nodes };
    } catch (err) {
      console.error('Error in snow ambient:', err);
      return null;
    }
  }

  let currentZoneAmbient = null;

  var crossfadeTimer = null;

  function setZoneAmbient(zone) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    if (crossfadeTimer) {
      clearTimeout(crossfadeTimer);
      crossfadeTimer = null;
    }

    var oldAmbient = currentZoneAmbient;
    if (oldAmbient) {
      try {
        if (oldAmbient.gainNode) {
          oldAmbient.gainNode.gain.setValueAtTime(oldAmbient.gainNode.gain.value, audioContext.currentTime);
          oldAmbient.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        }
      } catch(e) {}

      try {
        if (oldAmbient.oscillators && Array.isArray(oldAmbient.oscillators)) {
          oldAmbient.oscillators.forEach(function(osc) {
            if (osc && osc.stop) { try { osc.stop(); } catch(e) {} }
          });
        }
        if (oldAmbient.nodes && Array.isArray(oldAmbient.nodes)) {
          oldAmbient.nodes.forEach(function(node) {
            if (node) {
              if (node.stop) { try { node.stop(); } catch(e) {} }
              if (node.disconnect) { try { node.disconnect(); } catch(e) {} }
            }
          });
        }
        if (oldAmbient.intervals && Array.isArray(oldAmbient.intervals)) {
          oldAmbient.intervals.forEach(function(id) { clearInterval(id); });
        }
        if (oldAmbient.timeouts && Array.isArray(oldAmbient.timeouts)) {
          oldAmbient.timeouts.forEach(function(id) { clearTimeout(id); });
        }
        if (oldAmbient.cleanup && typeof oldAmbient.cleanup === 'function') {
          oldAmbient.cleanup();
        }
      } catch(err) {}

      killAllNoiseSources();
      currentZoneAmbient = null;
    }

    try {
      switch (zone) {
        case 'nexus':
          currentZoneAmbient = playNexusZoneLayer();
          break;
        case 'gardens':
          currentZoneAmbient = playGardensZoneLayer();
          break;
        case 'athenaeum':
          currentZoneAmbient = playAthenaeumZoneLayer();
          break;
        case 'studio':
          currentZoneAmbient = playStudioZoneLayer();
          break;
        case 'wilds':
          currentZoneAmbient = playWildsZoneLayer();
          break;
        case 'agora':
          currentZoneAmbient = playAgoraZoneLayer();
          break;
        case 'commons':
          currentZoneAmbient = playCommonsZoneLayer();
          break;
        case 'arena':
          currentZoneAmbient = playArenaZoneLayer();
          break;
        default:
          currentZoneAmbient = null;
      }

      if (currentZoneAmbient && currentZoneAmbient.gainNode) {
        var gain = currentZoneAmbient.gainNode;
        var targetVal = gain.gain.value || 0.3;
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(targetVal, audioContext.currentTime + 3);
      }
    } catch (err) {
      console.error('Error setting zone ambient:', err);
    }
  }

  function stopZoneAmbient() {
    if (!currentZoneAmbient) return;

    try {
      if (currentZoneAmbient.oscillators && Array.isArray(currentZoneAmbient.oscillators)) {
        currentZoneAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentZoneAmbient.nodes && Array.isArray(currentZoneAmbient.nodes)) {
        currentZoneAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentZoneAmbient.intervals && Array.isArray(currentZoneAmbient.intervals)) {
        currentZoneAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentZoneAmbient.timeouts && Array.isArray(currentZoneAmbient.timeouts)) {
        currentZoneAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentZoneAmbient.cleanup && typeof currentZoneAmbient.cleanup === 'function') {
        currentZoneAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping zone ambient:', err);
    }

    currentZoneAmbient = null;
    killAllNoiseSources();
  }

  function playNexusZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const oscillators = [];
    const nodes = [];

    try {
      const crystal1 = audioContext.createOscillator();
      const crystal2 = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      const layerGain = audioContext.createGain();

      crystal1.type = 'sine';
      crystal1.frequency.value = 523; // C5 â€” much gentler than 2000Hz

      crystal2.type = 'sine';
      crystal2.frequency.value = 659; // E5 â€” harmonic interval

      lfo.type = 'sine';
      lfo.frequency.value = 0.12;
      lfoGain.gain.value = 8; // subtle vibrato

      layerGain.gain.value = 0.012; // very quiet

      lfo.connect(lfoGain);
      lfoGain.connect(crystal1.frequency);
      lfoGain.connect(crystal2.frequency);

      crystal1.connect(layerGain);
      crystal2.connect(layerGain);
      layerGain.connect(masterGain);

      crystal1.start();
      crystal2.start();
      lfo.start();

      oscillators.push(crystal1, crystal2, lfo);
      nodes.push(lfoGain, layerGain);

      return { oscillators, nodes, gainNode: layerGain };
    } catch (err) {
      console.error('Error in nexus zone layer:', err);
      return null;
    }
  }

  function playGardensZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      const water = createWhiteNoise();
      if (water) {
        const waterFilter = audioContext.createBiquadFilter();
        const waterLfo = audioContext.createOscillator();
        const waterLfoGain = audioContext.createGain();
        const waterGain = audioContext.createGain();

        waterFilter.type = 'highpass';
        waterFilter.frequency.value = 2000;

        waterLfo.type = 'sine';
        waterLfo.frequency.value = 0.8;
        waterLfoGain.gain.value = 50;

        waterGain.gain.value = 0.03;

        waterLfo.connect(waterLfoGain);
        waterLfoGain.connect(waterFilter.frequency);

        water.connect(waterFilter);
        waterFilter.connect(waterGain);
        waterGain.connect(masterGain);

        waterLfo.start();

        nodes.push(water, waterFilter, waterLfo, waterLfoGain, waterGain);
      }

      return { nodes, timeouts, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in gardens zone layer:', err);
      return null;
    }
  }

  function playAthenaeumZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      function pageRustle() {
        if (!audioContext || !masterGain) return;

        const page = createWhiteNoise(2);
        if (page) {
          const pageFilter = audioContext.createBiquadFilter();
          const pageGain = audioContext.createGain();

          pageFilter.type = 'highpass';
          pageFilter.frequency.value = 2500;

          pageGain.gain.value = 0.02;
          pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

          page.connect(pageFilter);
          pageFilter.connect(pageGain);
          pageGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (page.stop) page.stop();
              if (pageFilter.disconnect) pageFilter.disconnect();
              if (pageGain.disconnect) pageGain.disconnect();
            } catch (e) {}
          }, 100);
        }

        const nextRustle = setTimeout(pageRustle, 10000 + Math.random() * 10000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(pageRustle, 5000);
      timeouts.push(firstRustle);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in athenaeum zone layer:', err);
      return null;
    }
  }

  function playStudioZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      function creativeNote() {
        if (!audioContext || !masterGain) return;

        const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00];
        const note = audioContext.createOscillator();
        const noteGain = audioContext.createGain();

        note.type = 'sine';
        note.frequency.value = notes[Math.floor(Math.random() * notes.length)];

        noteGain.gain.value = 0.025;
        noteGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        note.connect(noteGain);
        noteGain.connect(masterGain);

        note.start();
        note.stop(audioContext.currentTime + 0.3);

        const nextNote = setTimeout(creativeNote, 8000 + Math.random() * 12000);
        timeouts.push(nextNote);
      }

      const firstNote = setTimeout(creativeNote, 4000);
      timeouts.push(firstNote);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in studio zone layer:', err);
      return null;
    }
  }

  function playWildsZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      const water = createWhiteNoise();
      if (water) {
        const waterFilter = audioContext.createBiquadFilter();
        const waterGain = audioContext.createGain();

        waterFilter.type = 'bandpass';
        waterFilter.frequency.value = 800;
        waterFilter.Q.value = 1;

        waterGain.gain.value = 0.04;

        water.connect(waterFilter);
        waterFilter.connect(waterGain);
        waterGain.connect(masterGain);

        nodes.push(water, waterFilter, waterGain);
      }

      return { nodes, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in wilds zone layer:', err);
      return null;
    }
  }

  function playAgoraZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 450;
        crowdFilter.Q.value = 1.2;

        crowdGain.gain.value = 0.025;

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        nodes.push(crowd, crowdFilter, crowdGain);
      }

      return { nodes, timeouts, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in agora zone layer:', err);
      return null;
    }
  }

  function playCommonsZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      function chime() {
        if (!audioContext || !masterGain) return;

        const bell = audioContext.createOscillator();
        const bellGain = audioContext.createGain();

        bell.type = 'sine';
        bell.frequency.value = 800 + Math.random() * 600;

        bellGain.gain.value = 0.03;
        bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

        bell.connect(bellGain);
        bellGain.connect(masterGain);

        bell.start();
        bell.stop(audioContext.currentTime + 1.5);

        const nextChime = setTimeout(chime, 5000 + Math.random() * 8000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(chime, 3000);
      timeouts.push(firstChime);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in commons zone layer:', err);
      return null;
    }
  }

  function playArenaZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      const echo = createWhiteNoise(2);
      if (echo) {
        const echoFilter = audioContext.createBiquadFilter();
        const echoDelay = audioContext.createDelay();
        const echoDelayGain = audioContext.createGain();
        const echoGain = audioContext.createGain();

        echoFilter.type = 'bandpass';
        echoFilter.frequency.value = 700;
        echoFilter.Q.value = 0.8;

        echoDelay.delayTime.value = 0.3;
        echoDelayGain.gain.value = 0.3;

        echoGain.gain.value = 0.02;

        echo.connect(echoFilter);
        echoFilter.connect(echoGain);
        echoGain.connect(masterGain);
        echoGain.connect(echoDelay);
        echoDelay.connect(echoDelayGain);
        echoDelayGain.connect(masterGain);

        nodes.push(echo, echoFilter, echoDelay, echoDelayGain, echoGain);
      }

      return { nodes, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in arena zone layer:', err);
      return null;
    }
  }

  function playNPCSound(type) {
    if (!audioContext || !masterGain) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (type) {
        case 'hammer':
          playNPCHammerSound();
          break;
        case 'music':
          playNPCMusicSound();
          break;
        case 'garden':
          playNPCGardenSound();
          break;
        case 'trade':
          playNPCTradeSound();
          break;
        case 'teach':
          playNPCTeachSound();
          break;
        case 'heal':
          playNPCHealSound();
          break;
        default:
          console.warn('Unknown NPC sound type:', type);
      }
    } catch (err) {
      console.error('Error playing NPC sound:', err);
    }
  }

  function playNPCHammerSound() {
    if (!audioContext || !masterGain) return;

    const hammer = audioContext.createOscillator();
    const hammerGain = audioContext.createGain();

    hammer.type = 'square';
    hammer.frequency.value = 90;

    hammerGain.gain.value = 0.08;
    hammerGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    hammer.connect(hammerGain);
    hammerGain.connect(masterGain);

    hammer.start();
    hammer.stop(audioContext.currentTime + 0.2);

    const ring = audioContext.createOscillator();
    const ringGain = audioContext.createGain();

    ring.type = 'sine';
    ring.frequency.value = 2500;

    ringGain.gain.value = 0.04;
    ringGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    ring.connect(ringGain);
    ringGain.connect(masterGain);

    ring.start();
    ring.stop(audioContext.currentTime + 0.3);
  }

  function playNPCMusicSound() {
    if (!audioContext || !masterGain) return;

    const notes = [392.00, 440.00, 493.88]; // G4, A4, B4

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.15;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.25);
    });
  }

  function playNPCGardenSound() {
    if (!audioContext || !masterGain) return;

    const rustle = createWhiteNoise(2);
    if (rustle) {
      const rustleFilter = audioContext.createBiquadFilter();
      const rustleGain = audioContext.createGain();

      rustleFilter.type = 'bandpass';
      rustleFilter.frequency.value = 1200;
      rustleFilter.Q.value = 2;

      rustleGain.gain.value = 0.06;
      rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

      rustle.connect(rustleFilter);
      rustleFilter.connect(rustleGain);
      rustleGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (rustle.stop) rustle.stop();
          if (rustleFilter.disconnect) rustleFilter.disconnect();
          if (rustleGain.disconnect) rustleGain.disconnect();
        } catch (e) {}
      }, 350);
    }
  }

  function playNPCTradeSound() {
    if (!audioContext || !masterGain) return;

    const coin = audioContext.createOscillator();
    const coinGain = audioContext.createGain();

    coin.type = 'triangle';
    coin.frequency.value = 1800 + Math.random() * 500;

    coinGain.gain.value = 0.06;
    coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    coin.connect(coinGain);
    coinGain.connect(masterGain);

    coin.start();
    coin.stop(audioContext.currentTime + 0.2);
  }

  function playNPCTeachSound() {
    if (!audioContext || !masterGain) return;

    const thump = audioContext.createOscillator();
    const thumpGain = audioContext.createGain();

    thump.type = 'sine';
    thump.frequency.value = 80;

    thumpGain.gain.value = 0.05;
    thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

    thump.connect(thumpGain);
    thumpGain.connect(masterGain);

    thump.start();
    thump.stop(audioContext.currentTime + 0.1);

    setTimeout(() => {
      const page = createWhiteNoise(2);
      if (page) {
        const pageFilter = audioContext.createBiquadFilter();
        const pageGain = audioContext.createGain();

        pageFilter.type = 'highpass';
        pageFilter.frequency.value = 2200;

        pageGain.gain.value = 0.04;
        pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        page.connect(pageFilter);
        pageFilter.connect(pageGain);
        pageGain.connect(masterGain);

        setTimeout(() => {
          try {
            if (page.stop) page.stop();
            if (pageFilter.disconnect) pageFilter.disconnect();
            if (pageGain.disconnect) pageGain.disconnect();
          } catch (e) {}
        }, 180);
      }
    }, 100);
  }

  function playNPCHealSound() {
    if (!audioContext || !masterGain) return;

    const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.1;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.3);
    });
  }

  var musicState = {
    playing: false,
    zone: null,
    timeOfDay: 'day',
    volume: 0.12,
    oscillators: [],
    gains: [],
    nextNoteTime: 0,
    noteIndex: 0,
    chordIndex: 0,
    arpIndex: 0,
    beatTimer: null,
    padNodes: [],
    melodyTimeout: null
  };

  var SCALES = {
    nexus:     [256.87, 288.33, 323.63, 384.91, 432.00, 513.74, 576.65, 647.25],  // C major pentatonic
    gardens:   [288.33, 323.63, 363.27, 432.00, 484.90, 576.65, 647.25, 726.53],  // D major pentatonic
    athenaeum: [242.45, 272.18, 323.63, 363.27, 407.75, 484.90, 544.36, 647.25],  // B minor pentatonic
    studio:    [323.63, 363.27, 407.75, 484.90, 544.36, 647.25, 726.53, 815.51],  // E major pentatonic
    wilds:     [216.00, 256.87, 288.33, 323.63, 384.91, 432.00, 513.74, 576.65],  // A minor pentatonic
    agora:     [342.88, 384.91, 432.00, 513.74, 576.65, 685.76, 769.82, 864.00],  // F major pentatonic
    commons:   [288.33, 342.88, 384.91, 432.00, 513.74, 576.65, 685.76, 769.82],  // D mixolydian penta
    arena:     [192.43, 228.84, 256.87, 288.33, 342.88, 384.91, 457.69, 513.74]   // G minor pentatonic
  };

  var CHORD_PROGRESSIONS = {
    nexus:     [[0, 2, 4], [1, 3, 5], [2, 4, 6], [0, 3, 5]],
    gardens:   [[0, 2, 4], [2, 4, 6], [1, 3, 5], [0, 2, 5]],
    athenaeum: [[0, 2, 4], [1, 3, 5], [0, 3, 5], [2, 4, 6]],
    studio:    [[0, 2, 4], [1, 4, 6], [2, 4, 6], [0, 3, 5]],
    wilds:     [[0, 2, 4], [1, 3, 5], [0, 2, 5], [1, 4, 6]],
    agora:     [[0, 2, 4], [1, 3, 5], [2, 4, 6], [0, 2, 5]],
    commons:   [[0, 2, 4], [2, 4, 6], [1, 3, 5], [0, 3, 5]],
    arena:     [[0, 2, 4], [0, 3, 5], [1, 4, 6], [2, 4, 6]]
  };

  var ZONE_MUSIC_STYLE = {
    nexus:     { beatDuration: 2.8, padVolume: 0.07, melodyChance: 0.15, melodyVolume: 0.03, type: 'ethereal' },
    gardens:   { beatDuration: 2.4, padVolume: 0.06, melodyChance: 0.2,  melodyVolume: 0.035, type: 'pastoral' },
    athenaeum: { beatDuration: 3.2, padVolume: 0.05, melodyChance: 0.1,  melodyVolume: 0.025, type: 'mysterious' },
    studio:    { beatDuration: 2.0, padVolume: 0.06, melodyChance: 0.25, melodyVolume: 0.04, type: 'creative' },
    wilds:     { beatDuration: 3.0, padVolume: 0.04, melodyChance: 0.12, melodyVolume: 0.03, type: 'nature' },
    agora:     { beatDuration: 1.8, padVolume: 0.05, melodyChance: 0.2,  melodyVolume: 0.035, type: 'lively' },
    commons:   { beatDuration: 2.4, padVolume: 0.06, melodyChance: 0.18, melodyVolume: 0.03, type: 'warm' },
    arena:     { beatDuration: 2.0, padVolume: 0.07, melodyChance: 0.15, melodyVolume: 0.035, type: 'dramatic' }
  };

  var TIME_MODIFIERS = {
    dawn:    { tempoMult: 0.8, volumeMult: 0.6, melodyMult: 0.5, octaveShift: 0 },
    morning: { tempoMult: 0.9, volumeMult: 0.8, melodyMult: 0.8, octaveShift: 0 },
    midday:  { tempoMult: 1.0, volumeMult: 1.0, melodyMult: 1.0, octaveShift: 0 },
    afternoon: { tempoMult: 1.0, volumeMult: 0.9, melodyMult: 0.9, octaveShift: 0 },
    evening: { tempoMult: 0.85, volumeMult: 0.7, melodyMult: 0.6, octaveShift: -1 },
    night:   { tempoMult: 0.7, volumeMult: 0.4, melodyMult: 0.3, octaveShift: -1 }
  };

  function startMusic(zone, timeOfDay) {
    if (!audioContext || !masterGain) return;
    zone = zone || 'nexus';
    timeOfDay = timeOfDay || 'midday';

    if (musicState.playing) {
      stopMusic();
    }

    musicState.zone = zone;
    musicState.timeOfDay = timeOfDay;
    musicState.playing = true;
    musicState.chordIndex = 0;
    musicState.noteIndex = 0;
    musicState.arpIndex = 0;

    playPadChord();

    scheduleMelody();
  }

  function playPadChord() {
    if (!audioContext || !masterGain || !musicState.playing) return;

    var zone = musicState.zone || 'nexus';
    var scale = SCALES[zone] || SCALES.nexus;
    var progression = CHORD_PROGRESSIONS[zone] || CHORD_PROGRESSIONS.nexus;
    var style = ZONE_MUSIC_STYLE[zone] || ZONE_MUSIC_STYLE.nexus;
    var timeMod = TIME_MODIFIERS[musicState.timeOfDay] || TIME_MODIFIERS.midday;

    var chordIndices = progression[musicState.chordIndex % progression.length];
    var beatDur = style.beatDuration / timeMod.tempoMult;
    var chordDuration = beatDur * 4; // 4 beats per chord

    cleanupPadNodes();

    for (var i = 0; i < chordIndices.length; i++) {
      var noteIdx = chordIndices[i];
      var freq = scale[noteIdx % scale.length];

      if (timeMod.octaveShift < 0) freq *= 0.5;
      if (timeMod.octaveShift > 0) freq *= 2;

      for (var d = 0; d < 2; d++) {
        var osc = audioContext.createOscillator();
        var gain = audioContext.createGain();
        var filter = audioContext.createBiquadFilter();

        osc.type = (style.type === 'ethereal' || style.type === 'mysterious') ? 'sine' : 'triangle';
        osc.frequency.value = freq + (d === 0 ? -1.5 : 1.5); // lo-fi warm detune

        filter.type = 'lowpass';
        filter.frequency.value = 500;
        filter.Q.value = 0.7;

        var padVol = style.padVolume * timeMod.volumeMult * musicState.volume;
        var now = audioContext.currentTime;

        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(padVol, now + chordDuration * 0.15);
        gain.gain.setValueAtTime(padVol, now + chordDuration * 0.7);
        gain.gain.linearRampToValueAtTime(0, now + chordDuration);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(now);
        osc.stop(now + chordDuration + 0.1);

        musicState.padNodes.push({ osc: osc, gain: gain, filter: filter, endTime: now + chordDuration + 0.2 });
      }
    }

    if (Math.random() < 0.6) {
      var arpDelay = beatDur * 0.5;
      for (var a = 0; a < 3; a++) {
        (function(arpIdx, delay) {
          setTimeout(function() {
            if (!musicState.playing || !audioContext) return;
            var arpFreq = scale[chordIndices[arpIdx % chordIndices.length] % scale.length];
            if (timeMod.octaveShift < 0) arpFreq *= 0.5;
            arpFreq *= 2; // One octave up for sparkle

            var arpOsc = audioContext.createOscillator();
            var arpGain = audioContext.createGain();

            arpOsc.type = 'sine';
            arpOsc.frequency.value = arpFreq;

            var arpVol = style.melodyVolume * timeMod.volumeMult * musicState.volume * 0.6;
            var t = audioContext.currentTime;
            arpGain.gain.setValueAtTime(0, t);
            arpGain.gain.linearRampToValueAtTime(arpVol, t + 0.05);
            arpGain.gain.exponentialRampToValueAtTime(0.001, t + beatDur * 0.8);

            arpOsc.connect(arpGain);
            arpGain.connect(masterGain);
            arpOsc.start(t);
            arpOsc.stop(t + beatDur);
          }, delay * 1000);
        })(a, arpDelay * (a + 1));
      }
    }

    musicState.chordIndex++;
    musicState.beatTimer = setTimeout(function() {
      if (musicState.playing) playPadChord();
    }, chordDuration * 1000);
  }

  function scheduleMelody() {
    if (!audioContext || !masterGain || !musicState.playing) return;

    var zone = musicState.zone || 'nexus';
    var scale = SCALES[zone] || SCALES.nexus;
    var style = ZONE_MUSIC_STYLE[zone] || ZONE_MUSIC_STYLE.nexus;
    var timeMod = TIME_MODIFIERS[musicState.timeOfDay] || TIME_MODIFIERS.midday;

    var melodyChance = style.melodyChance * timeMod.melodyMult;
    var beatDur = style.beatDuration / timeMod.tempoMult;

    var delay = beatDur * (1 + Math.random() * 3);

    musicState.melodyTimeout = setTimeout(function() {
      if (!musicState.playing || !audioContext) return;

      if (Math.random() < melodyChance) {
        var direction = Math.random() < 0.5 ? 1 : -1;
        var step = Math.random() < 0.7 ? 1 : 2;
        musicState.noteIndex = Math.max(0, Math.min(scale.length - 1, musicState.noteIndex + direction * step));
        var freq = scale[musicState.noteIndex];
        if (timeMod.octaveShift < 0) freq *= 0.5;
        freq *= 2; // Melody one octave up

        var melOsc = audioContext.createOscillator();
        var melGain = audioContext.createGain();
        var melFilter = audioContext.createBiquadFilter();

        if (style.type === 'nature' || style.type === 'pastoral') {
          melOsc.type = 'sine';
        } else if (style.type === 'dramatic' || style.type === 'lively') {
          melOsc.type = 'triangle';
        } else {
          melOsc.type = Math.random() < 0.5 ? 'sine' : 'triangle';
        }

        melOsc.frequency.value = freq;

        melFilter.type = 'lowpass';
        melFilter.frequency.value = 700;

        var melVol = style.melodyVolume * timeMod.volumeMult * musicState.volume;
        var noteDur = beatDur * (0.5 + Math.random() * 1.5);
        var t = audioContext.currentTime;

        melGain.gain.setValueAtTime(0, t);
        melGain.gain.linearRampToValueAtTime(melVol, t + 0.03);
        melGain.gain.setValueAtTime(melVol * 0.8, t + noteDur * 0.5);
        melGain.gain.exponentialRampToValueAtTime(0.001, t + noteDur);

        melOsc.connect(melFilter);
        melFilter.connect(melGain);
        melGain.connect(masterGain);

        melOsc.start(t);
        melOsc.stop(t + noteDur + 0.1);

        if (Math.random() < 0.25) {
          var harmIdx = (musicState.noteIndex + 2) % scale.length;
          var harmFreq = scale[harmIdx] * 2;
          if (timeMod.octaveShift < 0) harmFreq *= 0.5;

          var harmOsc = audioContext.createOscillator();
          var harmGain = audioContext.createGain();

          harmOsc.type = 'sine';
          harmOsc.frequency.value = harmFreq;

          var harmVol = melVol * 0.4;
          harmGain.gain.setValueAtTime(0, t + 0.05);
          harmGain.gain.linearRampToValueAtTime(harmVol, t + 0.1);
          harmGain.gain.exponentialRampToValueAtTime(0.001, t + noteDur * 0.8);

          harmOsc.connect(harmGain);
          harmGain.connect(masterGain);
          harmOsc.start(t + 0.05);
          harmOsc.stop(t + noteDur);
        }
      }

      scheduleMelody();
    }, delay * 1000);
  }

  function cleanupPadNodes() {
    var now = audioContext ? audioContext.currentTime : 0;
    musicState.padNodes = musicState.padNodes.filter(function(node) {
      if (now > node.endTime) {
        try {
          node.osc.disconnect();
          node.gain.disconnect();
          node.filter.disconnect();
        } catch (e) {}
        return false;
      }
      return true;
    });
  }

  function stopMusic() {
    musicState.playing = false;

    if (musicState.beatTimer) {
      clearTimeout(musicState.beatTimer);
      musicState.beatTimer = null;
    }
    if (musicState.melodyTimeout) {
      clearTimeout(musicState.melodyTimeout);
      musicState.melodyTimeout = null;
    }

    for (var i = 0; i < musicState.padNodes.length; i++) {
      try {
        var node = musicState.padNodes[i];
        if (node.gain && audioContext) {
          node.gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
        }
      } catch (e) {}
    }

    setTimeout(function() {
      for (var i = 0; i < musicState.padNodes.length; i++) {
        try {
          musicState.padNodes[i].osc.disconnect();
          musicState.padNodes[i].gain.disconnect();
          musicState.padNodes[i].filter.disconnect();
        } catch (e) {}
      }
      musicState.padNodes = [];
    }, 600);
  }

  function updateMusic(zone, timeOfDay) {
    if (!musicState.playing) return;
    if (zone && zone !== musicState.zone) {
      startMusic(zone, timeOfDay || musicState.timeOfDay);
    } else if (timeOfDay && timeOfDay !== musicState.timeOfDay) {
      musicState.timeOfDay = timeOfDay;
    }
  }

  function setMusicVolume(vol) {
    musicState.volume = Math.max(0, Math.min(1, vol));
  }

  function isMusicPlaying() {
    return musicState.playing;
  }

  var PIANO_ACCENTS = {
    dawn: {
      notes: [261.63, 329.63, 392.00, 523.25, 659.25],
      noteSpacing: 0.12,
      noteDuration: 0.6,
      volume: 0.05
    },
    morning: {
      notes: [392.00, 493.88, 587.33, 783.99, 987.77, 783.99],
      noteSpacing: 0.1,
      noteDuration: 0.5,
      volume: 0.04
    },
    dusk: {
      notes: [880.00, 659.25, 523.25, 440.00, 329.63],
      noteSpacing: 0.15,
      noteDuration: 0.7,
      volume: 0.04
    },
    night: {
      notes: [146.83, 174.61, 220.00, 196.00, 146.83],
      noteSpacing: 0.22,
      noteDuration: 0.9,
      volume: 0.04
    },
    zone_discovery: {
      notes: [392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 659.25, 783.99],
      noteSpacing: 0.09,
      noteDuration: 0.45,
      volume: 0.06
    },
    quest_complete: {
      notes: [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50, 1318.51],
      noteSpacing: 0.1,
      noteDuration: 0.5,
      volume: 0.06
    },
    achievement: {
      notes: [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50],
      noteSpacing: 0.08,
      noteDuration: 0.4,
      volume: 0.06
    }
  };

  function playPianoAccent(type) {
    if (!audioContext || !masterGain) return;
    var accent = PIANO_ACCENTS[type];
    if (!accent) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    var musicVol = volumeLevels.music !== undefined ? volumeLevels.music : 0.5;
    var baseVol = accent.volume * musicVol;

    try {
      for (var i = 0; i < accent.notes.length; i++) {
        (function(idx) {
          var freq = accent.notes[idx];
          var startTime = audioContext.currentTime + idx * accent.noteSpacing;

          var osc1 = audioContext.createOscillator();
          var gain1 = audioContext.createGain();
          osc1.type = 'sine';
          osc1.frequency.value = freq;
          gain1.gain.setValueAtTime(0, startTime);
          gain1.gain.linearRampToValueAtTime(baseVol, startTime + 0.015);
          gain1.gain.exponentialRampToValueAtTime(baseVol * 0.6, startTime + accent.noteDuration * 0.3);
          gain1.gain.exponentialRampToValueAtTime(0.001, startTime + accent.noteDuration);
          osc1.connect(gain1);
          gain1.connect(masterGain);
          osc1.start(startTime);
          osc1.stop(startTime + accent.noteDuration + 0.05);

          var osc2 = audioContext.createOscillator();
          var gain2 = audioContext.createGain();
          osc2.type = 'triangle';
          osc2.frequency.value = freq * 2; // octave above for shimmer
          gain2.gain.setValueAtTime(0, startTime);
          gain2.gain.linearRampToValueAtTime(baseVol * 0.3, startTime + 0.01);
          gain2.gain.exponentialRampToValueAtTime(0.001, startTime + accent.noteDuration * 0.5);
          osc2.connect(gain2);
          gain2.connect(masterGain);
          osc2.start(startTime);
          osc2.stop(startTime + accent.noteDuration * 0.5 + 0.05);

          var osc3 = audioContext.createOscillator();
          var gain3 = audioContext.createGain();
          osc3.type = 'sine';
          osc3.frequency.value = freq * 3;
          gain3.gain.setValueAtTime(0, startTime);
          gain3.gain.linearRampToValueAtTime(baseVol * 0.03, startTime + 0.005);
          gain3.gain.exponentialRampToValueAtTime(0.001, startTime + 0.06);
          osc3.connect(gain3);
          gain3.connect(masterGain);
          osc3.start(startTime);
          osc3.stop(startTime + 0.1);
        })(i);
      }
    } catch (err) {
    }
  }

  function getPianoAccentTypes() {
    return PIANO_ACCENTS;
  }

  exports.initAudio = initAudio;
  exports.playAmbient = playAmbient;
  exports.playSound = playSound;
  exports.playFootstep = playFootstep;
  exports.setVolume = setVolume;
  exports.mute = mute;
  exports.unmute = unmute;
  exports.stopAll = stopAll;

  exports.updateAmbientTime = updateAmbientForTime;
  exports.updateAmbientWeather = updateAmbientForWeather;
  exports.setZoneAmbient = setZoneAmbient;

  exports.playNPCSound = playNPCSound;

  exports.startMusic = startMusic;
  exports.stopMusic = stopMusic;
  exports.updateMusic = updateMusic;
  exports.setMusicVolume = setMusicVolume;
  exports.isMusicPlaying = isMusicPlaying;

  exports.playPianoAccent = playPianoAccent;
  exports.getPianoAccentTypes = getPianoAccentTypes;

})(typeof module !== 'undefined' ? module.exports : (window.Audio = {}));


// LAZY_LOAD_START: npc_dialogue
(function(exports) {
  'use strict';

  var MAX_PROMPT_CHARS = 2000;       // ~500 tokens at 4 chars/token
  var MAX_SPEECH_CHARS = 200;        // Max speech bubble length
  var DEFAULT_COOLDOWN_MS = 30000;   // 30 seconds between NPC utterances
  var DEFAULT_MAX_QUEUE = 50;        // Max pending dialogue requests
  var TREND_MIN_OCCURRENCES = 2;     // Min mentions for a trend to register
  var MEMORY_MAX_INTERACTIONS = 20;  // How many interactions to remember

  var VOICE_PROFILES = {
    gardener: {
      style: 'warm, nurturing, uses plant metaphors',
      markers: ['bloom', 'grow', 'root', 'soil', 'harvest', 'seed', 'tend', 'flourish'],
      openers: ['The soil tells me', 'Like a young seedling', 'In the garden of', 'Let it grow'],
      mood: 'peaceful and caring'
    },
    builder: {
      style: 'practical, direct, uses spatial language',
      markers: ['structure', 'foundation', 'build', 'craft', 'design', 'solid', 'measure'],
      openers: ['From the ground up', 'Let me be direct', 'The foundation is', 'Structurally speaking'],
      mood: 'focused and methodical'
    },
    storyteller: {
      style: 'dramatic, narrative structure, often begins with "Once..." or "There was..."',
      markers: ['once', 'tale', 'legend', 'story', 'chapter', 'narrative', 'journey'],
      openers: ['Once upon a time', 'There was a day', 'Legend has it', 'Let me tell you of'],
      mood: 'dramatic and engaging'
    },
    merchant: {
      style: 'shrewd, value-aware, deal-making language',
      markers: ['trade', 'value', 'deal', 'exchange', 'profit', 'cost', 'worth', 'fair'],
      openers: ['Let me offer you', 'A fair trade would be', "I'll tell you what", 'The value here is'],
      mood: 'calculating but friendly'
    },
    explorer: {
      style: 'excited, uses discovery language, often begins with "Have you seen..."',
      markers: ['discover', 'found', 'explore', 'adventure', 'uncharted', 'horizon', 'journey'],
      openers: ['Have you seen', 'Just discovered', 'Beyond that ridge', 'I mapped a new'],
      mood: 'excited and curious'
    },
    teacher: {
      style: 'patient, questioning, Socratic style',
      markers: ['consider', 'what if', 'think', 'learn', 'understand', 'question', 'wisdom'],
      openers: ['Have you considered', 'What do you think', 'A wise person once', 'Consider this'],
      mood: 'patient and thoughtful'
    },
    musician: {
      style: 'lyrical, rhythmic speech, references sounds and music',
      markers: ['melody', 'rhythm', 'harmony', 'song', 'notes', 'vibration', 'tune', 'play'],
      openers: ['The melody of', 'In perfect harmony', 'Life has a rhythm', 'Listen closely'],
      mood: 'expressive and rhythmic'
    },
    healer: {
      style: 'empathetic, gentle, body and wellness language',
      markers: ['heal', 'care', 'rest', 'breathe', 'gentle', 'balance', 'restore', 'comfort'],
      openers: ['Take a deep breath', 'Your wellbeing matters', 'Let me help you', 'With gentle care'],
      mood: 'compassionate and calm'
    },
    philosopher: {
      style: 'questioning, abstract, often uses "What if..." or poses dilemmas',
      markers: ['truth', 'existence', 'meaning', 'wonder', 'contemplate', 'ponder', 'essence'],
      openers: ['What if we considered', 'The deeper question is', 'In the grand scheme', 'Ponder this'],
      mood: 'contemplative and abstract'
    },
    artist: {
      style: 'visual, emotional, references color, shape, and beauty',
      markers: ['color', 'light', 'beautiful', 'create', 'inspire', 'vision', 'texture', 'express'],
      openers: ['The colors here remind me', 'I see beauty in', 'Art is everywhere', 'Notice the light'],
      mood: 'creative and emotionally expressive'
    }
  };

  var FALLBACK_POOLS = {
    gardener: {
      greeting: [
        "Welcome! The gardens are alive with color today.",
        "Ah, a visitor! Let me show you the moonflowers.",
        "Hello, friend. Have you ever seen soil this rich?",
        "Welcome to the gardens â€” feel free to take in the beauty.",
        "Greetings! The herbs are especially fragrant today.",
        "Hello there! Every plant here has a story to tell.",
        "Welcome! Like a new seed, you've found good ground.",
        "Come in, come in! The garden always has room for more.",
        "Well met! I just finished planting a new flower bed.",
        "Hello! The garden whispers your name in the breeze."
      ],
      zone_comment: [
        "These gardens are the heart of ZION â€” life flows from here.",
        "Every flower here was planted with intention and love.",
        "The soil remembers every rain, every season.",
        "I tend this land daily. It gives back tenfold.",
        "Gardens teach patience â€” you can't rush a bloom.",
        "Notice how the light falls differently each hour here.",
        "This zone breathes. You can feel it if you stand still.",
        "Every path through here was worn by gentle footsteps.",
        "The gardens know when someone cares for them.",
        "We planted the first seeds here together as a community."
      ],
      idle_chat: [
        "The compost bin is turning beautifully this week.",
        "I'm deciding what to plant in the east bed next season.",
        "Did you know each flower here has medicinal uses?",
        "I've been cross-breeding two varieties â€” exciting experiment!",
        "The bees have been especially active today.",
        "Sometimes I just sit and watch the plants grow.",
        "A garden is a conversation between human and earth.",
        "I found a rare seedling on the hillside this morning.",
        "The rain last night was a gift to the soil.",
        "I dream in greens and bloom-colors."
      ],
      weather: [
        "Rain is a gardener's greatest ally â€” welcome, clouds!",
        "Sunshine like this makes everything grow just a bit faster.",
        "Storm coming? The plants can feel it too.",
        "Perfect weather for transplanting today.",
        "The mist this morning was magical on the flower beds.",
        "Wind like this carries seeds to new places â€” I love it.",
        "A cloudy day means I can work longer without the heat.",
        "The weather shapes the garden as much as my hands do.",
        "I planted these drought-resistant varieties just in time.",
        "Every weather pattern teaches the garden something new."
      ],
      craft: [
        "I'm weaving a basket to carry my harvest tools.",
        "I pressed some flowers earlier â€” nature's artwork.",
        "Making a tincture from these herbs takes real patience.",
        "I've been composting â€” turning waste into wealth.",
        "Grafting two rose varieties together is delicate work.",
        "I hand-tied every vine to the trellis this morning.",
        "Drying these herbs will preserve their strength all winter.",
        "I'm constructing a new raised bed from reclaimed wood.",
        "Seed sorting is meditative â€” I love every moment of it.",
        "My latest project: a garden that blooms in moonlight."
      ]
    },

    builder: {
      greeting: [
        "Hey! Solid ground here â€” good place to start something.",
        "Welcome. I was just reviewing some structural plans.",
        "Hello! Every great city starts with a single stone.",
        "Greetings. You look like someone who appreciates good construction.",
        "Good to see you. The agora has some impressive new foundations.",
        "Welcome to ZION â€” built to last, designed to inspire.",
        "Hello there. I was just measuring the load capacity here.",
        "Well met. Notice the craftsmanship on that archway?",
        "Hey! I can tell you built something once â€” the look in your eyes.",
        "Welcome. Strong foundations make strong communities."
      ],
      zone_comment: [
        "The agora's market stalls are structurally impressive.",
        "I designed those arches â€” three-point load distribution.",
        "Everything here was built to last a hundred years.",
        "The materials from the wilds made for excellent timber.",
        "That wall there has a hidden drainage channel inside.",
        "I love how the light hits these stone surfaces at dusk.",
        "Every structure in ZION started as a sketch in my notebook.",
        "The nexus obelisk â€” now THAT is a construction challenge.",
        "I've surveyed every zone. This one has the best site lines.",
        "Building in community is different â€” each stone has a story."
      ],
      idle_chat: [
        "I'm calculating the beam load for a new workshop extension.",
        "Timber or stone? That's the eternal builder's dilemma.",
        "I've been sketching plans for a public bathhouse.",
        "Measure twice, cut once â€” the builder's first law.",
        "The quarry site has some promising granite deposits.",
        "I just finished a commission â€” a communal storage hall.",
        "I've been stress-testing new mortar mixtures all week.",
        "A good roof changes everything about a space.",
        "I'm prototyping a new joint design â€” stronger than any before.",
        "Space shapes behavior â€” that's what architecture is really about."
      ],
      weather: [
        "Wind this strong tests mortar joints â€” I'm taking notes.",
        "Rain reveals every flaw in a structure. Educational.",
        "Perfect dry weather for laying stone foundations.",
        "I designed the drainage here specifically for heavy rain.",
        "Hot sun like this cures mortar faster â€” efficient.",
        "Storm coming â€” checking all the anchoring points.",
        "A builder reads weather like a farmer reads soil.",
        "I reinforced those windows before the last big storm.",
        "Humidity affects wood expansion â€” I account for it.",
        "Every storm improves the next building I design."
      ],
      craft: [
        "Joining two load-bearing beams is art and engineering combined.",
        "I'm hand-carving decorative corbels for the library extension.",
        "Cutting precise dovetail joints takes years of practice.",
        "I mixed a new plaster formula â€” smoother than ever.",
        "Laying a perfectly level floor is deeply satisfying.",
        "I forge my own tools â€” custom weight and balance.",
        "Today: fitting the keystone into a new archway.",
        "Stonemasonry and patience are the same skill.",
        "The joints in that wall will outlast us all.",
        "I'm crafting a scale model before the real build."
      ]
    },

    storyteller: {
      greeting: [
        "Ah, a new face! Every face holds a story untold.",
        "Welcome! I was just composing a verse about this very moment.",
        "Greetings, traveler! I hope your journey here was eventful.",
        "There was once a stranger who walked into ZION... that's you!",
        "Hello! Legend has it the best stories begin with a chance meeting.",
        "Welcome! Sit â€” let me tell you how this world began.",
        "Once, on a day like today, a hero arrived. Perhaps that is you.",
        "Ah! A new chapter begins. Welcome to ZION.",
        "Greetings! Your arrival adds a page to our ongoing saga.",
        "Hello, friend. Every great story needs a new character."
      ],
      zone_comment: [
        "The athenaeum holds a thousand tales between its walls.",
        "Once, the agora witnessed a debate that changed everything.",
        "The gardens have been the setting for love stories and tragedies.",
        "This zone is where Act Two always happens â€” the turning point.",
        "The nexus is where all paths cross â€” and stories intertwine.",
        "Every stone here has witnessed something worth remembering.",
        "The wilds hold stories older than any of us know.",
        "I recorded everything that happened here in my chronicle.",
        "They say this place was founded by dreamers â€” I believe it.",
        "The echo here carries words spoken long ago."
      ],
      idle_chat: [
        "I'm writing the third volume of the ZION Chronicles.",
        "A good story requires a villain â€” even if it's just winter.",
        "The best tales I've collected came from unexpected people.",
        "I've been interviewing every NPC in ZION for their stories.",
        "Plot twist: the gardener was a philosopher all along.",
        "My quill is worn from writing. That means it was a good day.",
        "I've been searching for the perfect ending to an old tale.",
        "Every conversation I have becomes research.",
        "I'm cataloging the oral traditions of ZION's founding.",
        "Some stories take years to be ready to be told."
      ],
      weather: [
        "A storm like this inspired one of my best passages.",
        "Rain and candlelight â€” perfect conditions for writing.",
        "The wind tonight reminds me of the tale of the wandering bard.",
        "Every weather pattern becomes atmosphere in a good story.",
        "Sunshine like this was how I described the hero's victory.",
        "The mist reminds me of the legend of the ghost gardener.",
        "Nature writes the best first drafts. I just transcribe.",
        "Thunder! Perfect punctuation for a dramatic chapter.",
        "A clear night sky is where the oldest stories were written.",
        "Even the weather here tells a story if you listen."
      ],
      craft: [
        "Crafting a narrative arc is harder than it sounds.",
        "I'm illustrating my new collection with hand-drawn maps.",
        "Binding a book by hand is its own kind of storytelling.",
        "Writing the perfect opening sentence took me three days.",
        "I'm composing a ballad about the founding of ZION.",
        "Character development is everything â€” plot is just what happens.",
        "I've been carving story-runes into this walking staff.",
        "The craft of dialogue is knowing when NOT to speak.",
        "Every revision makes the story more true.",
        "I'm compiling an anthology of every voice in this world."
      ]
    },

    merchant: {
      greeting: [
        "Welcome! I always say good business starts with good people.",
        "Hello there! See anything that catches your eye?",
        "Greetings! I just got a fresh shipment you might like.",
        "Welcome to my corner of ZION â€” fair prices, honest trade.",
        "Ah, a potential customer! Let me tell you what's special today.",
        "Hello! The best deals go fast â€” good timing on your part.",
        "Welcome. I believe in mutual benefit â€” shall we talk?",
        "Greetings! Every transaction is the start of a relationship.",
        "Hello! I've been expecting someone with your discerning eye.",
        "Welcome â€” I have something rare that might interest you."
      ],
      zone_comment: [
        "The agora is ZION's economic heart â€” and I know every beat.",
        "Market conditions here are favorable. I've studied the patterns.",
        "Every stall in this market has a specialty. Mine is quality.",
        "I've traded across every zone â€” the agora has the best flow.",
        "This location gets foot traffic from all directions. Ideal.",
        "The commerce here benefits everyone â€” that's sustainable trade.",
        "I've built my reputation here over hundreds of transactions.",
        "Value flows from where trust is established. That's here.",
        "The market has its own rhythm â€” I've learned to read it.",
        "Every zone has something to offer. I connect them all."
      ],
      idle_chat: [
        "I'm reviewing my inventory manifest from yesterday's trades.",
        "Supply and demand â€” once you understand it, everything's clear.",
        "I've been researching what resources are scarce in the wilds.",
        "A good merchant knows when NOT to sell as well as when to.",
        "I traded three rare gems for exclusive garden produce today.",
        "Negotiation is an art. I practice it every day.",
        "I keep a ledger of every transaction â€” patterns emerge.",
        "The best deal I ever made was built on mutual respect.",
        "I'm scouting for new trade routes between zones.",
        "Commerce is community â€” money is just the language."
      ],
      weather: [
        "Rain slows the foot traffic but the serious buyers still come.",
        "Clear skies mean more visitors â€” better for business.",
        "I keep waterproof tarps for exactly this kind of weather.",
        "A hot day means cold goods sell fast. I've prepared.",
        "Wind like this blows away casual browsers â€” good for focus.",
        "Storm warning? I've already secured my inventory.",
        "Every weather condition creates different trading opportunities.",
        "I sell hand-made umbrellas when it rains. Always prepared.",
        "The weather affects prices. I track it like a ledger.",
        "Sun or storm â€” a merchant adapts."
      ],
      craft: [
        "I've been crafting specialized carrying cases for rare goods.",
        "Pricing is a craft â€” it requires skill and knowledge.",
        "I'm hand-lettering new signs for my market stall.",
        "Contract writing is an underrated craft. I take it seriously.",
        "I've been making custom packaging for fragile trade goods.",
        "Negotiating a multi-party trade deal takes real craft.",
        "I'm crafting a new display system for rare artifacts.",
        "The craft of appraisal takes decades to master.",
        "I've been building a reference compendium of goods and values.",
        "Packaging is part of the value â€” I craft it carefully."
      ]
    },

    explorer: {
      greeting: [
        "Have you seen the northern peaks? Incredible view up there!",
        "Hello! Just got back from the outer wilds â€” you won't believe it.",
        "Welcome! I mapped three new trails this week.",
        "Hey! If you haven't been to the coastal cliffs yet, go NOW.",
        "Greetings! The world is so much bigger than the map suggests.",
        "Welcome to ZION! I know all the secret paths if you're interested.",
        "Hello, adventurer! I can tell you have wandering eyes.",
        "Hey! Adventure finds the ones who seek it. Like us.",
        "Welcome! I've been waiting for someone to share my discoveries with.",
        "Greetings! Every corner of this world holds a wonder."
      ],
      zone_comment: [
        "The wilds extend much further than the official maps show.",
        "I found a hidden valley beyond the eastern ridge yesterday.",
        "This zone has three secret passages most people never find.",
        "The terrain changes dramatically just past that treeline.",
        "I've catalogued every landmark in a five-zone radius.",
        "There's a waterfall hidden behind the moss wall over there.",
        "The best view in all of ZION is from the cliffside I found.",
        "I've camped in every zone â€” the wilds has the best stars.",
        "The ecosystem shifts exactly fifty paces past this point.",
        "This spot is an old trail crossing â€” you can see the worn stone."
      ],
      idle_chat: [
        "I'm updating my map with three new trail markers.",
        "Just finished a full perimeter survey of the wilds.",
        "The creature migration patterns changed this season.",
        "I've been comparing old maps with new â€” things have shifted.",
        "My next expedition: the fog zone at the world's edge.",
        "I found evidence of structures older than ZION itself.",
        "Have you explored every zone? I have a checklist.",
        "The horizon is always more interesting than where you stand.",
        "I keep a journal of every discovery â€” it's five volumes now.",
        "There's always more to find. That's what keeps me going."
      ],
      weather: [
        "Rain like this reveals hidden streams I'd never have noticed.",
        "Wind from the north means the fog will clear by afternoon.",
        "Perfect storm conditions for observing how terrain changes.",
        "I've explored in every weather â€” storms are the most exciting.",
        "Mist like this is perfect for finding hidden paths.",
        "Lightning last night revealed a cave I'd never seen before.",
        "Explorers don't wait for good weather. We find beauty in all.",
        "Snow would open up new terrain â€” I can't wait.",
        "The rain reveals the true drainage of this landscape.",
        "Weather is just terrain in the sky."
      ],
      craft: [
        "I'm hand-drawing a detailed topographic map of the eastern zones.",
        "Crafting a reliable compass from local materials was a challenge.",
        "I've been building a lightweight shelter system for expeditions.",
        "Making waterproof trail markers is surprisingly technical.",
        "I've been assembling an explorer's field kit from local materials.",
        "Craft a good camp and the wilderness becomes your home.",
        "I've been weaving rope strong enough for cliff descents.",
        "Repairing my pack after the last expedition took all morning.",
        "I made a sextant replica to practice celestial navigation.",
        "Every tool I carry, I made or modified myself."
      ]
    },

    teacher: {
      greeting: [
        "Welcome! Tell me â€” what would you like to learn today?",
        "Greetings! Every moment is an opportunity to learn something.",
        "Hello! I always find that new faces ask the best questions.",
        "Welcome to ZION. What knowledge brought you here?",
        "Greetings! A student arrives at the perfect moment.",
        "Hello. Have you considered what you already know?",
        "Welcome! Teaching begins with listening. So â€” how are you?",
        "Greetings! I've prepared a new lesson plan you might enjoy.",
        "Hello! Wisdom is the one resource that grows when shared.",
        "Welcome! Ask me anything â€” I love a good question."
      ],
      zone_comment: [
        "The athenaeum holds knowledge that takes lifetimes to exhaust.",
        "This space was designed for learning â€” notice the acoustics.",
        "Every surface here has been touched by a student's curiosity.",
        "I've taught here for many seasons. The students teach me too.",
        "Knowledge radiates outward from places like this.",
        "The scrolls in the athenaeum date back to ZION's founding.",
        "Have you considered why this zone was placed at this location?",
        "A learning environment shapes the quality of thinking itself.",
        "Every student who sat here left something behind.",
        "The library's collection grows by twelve volumes per season."
      ],
      idle_chat: [
        "I've been preparing a series of lectures on ZION's history.",
        "What do you think is the most important thing to teach a child?",
        "I'm revising my curriculum based on last season's questions.",
        "A good question is worth more than a hundred good answers.",
        "I've been corresponding with philosophers across all zones.",
        "My students asked me something yesterday I couldn't answer. Wonderful.",
        "Learning never stops â€” even for the teacher.",
        "I'm compiling questions no one has answered yet.",
        "The best lesson I ever taught was the one I hadn't planned.",
        "Education is the gift that can't be taken away."
      ],
      weather: [
        "Rain is an excellent metaphor for how knowledge accumulates.",
        "I asked my students to describe the storm using only verbs.",
        "Weather provides endless natural science opportunities.",
        "Have you considered why rain falls downward and not upward?",
        "The sun's angle today would make a fine geometry lesson.",
        "Mist like this is perfect for discussing atmospheric science.",
        "I assign outdoor observation during weather like this.",
        "Wind carries seeds â€” and ideas â€” farther than we expect.",
        "Every natural phenomenon is a question waiting to be asked.",
        "A good teacher turns every thunderstorm into a lecture."
      ],
      craft: [
        "I'm hand-illustrating a new educational text on botany.",
        "Teaching is a craft that improves only through practice.",
        "I've been designing interactive learning tools for the library.",
        "Writing curriculum is like crafting a journey for the mind.",
        "I'm building model structures to illustrate architectural concepts.",
        "The craft of explaining complex ideas simply â€” that takes years.",
        "I've been carving educational relief maps for tactile learners.",
        "Binding a textbook is the final step in creating knowledge.",
        "I'm crafting question cards for collaborative learning sessions.",
        "A lesson plan is a blueprint for discovery."
      ]
    },

    musician: {
      greeting: [
        "Welcome! Can you hear the music in this world?",
        "Hello! The wind makes a perfect fifth today.",
        "Greetings! I was just composing something for this moment.",
        "Welcome to ZION â€” have you noticed it has its own song?",
        "Hello! Music is the fastest way to feel at home.",
        "Greetings! Every footstep here is part of a rhythm.",
        "Welcome! I've been waiting to share a new melody.",
        "Hello, friend! The world sounds different with fresh ears.",
        "Greetings! I could write a whole symphony about this place.",
        "Welcome! If you listen carefully, ZION hums."
      ],
      zone_comment: [
        "The acoustics here are extraordinary â€” listen to that echo.",
        "The agora's market sounds form a natural symphony.",
        "I perform in this zone every evening â€” the resonance is perfect.",
        "The gardens have a subsonic hum on quiet mornings.",
        "Sound travels differently here. I've mapped the acoustic zones.",
        "Every zone in ZION has its own musical key, I believe.",
        "The stone walls here create natural reverb. Extraordinary.",
        "I've recorded the ambient sounds of every zone.",
        "The wind through those arches plays a natural flute note.",
        "When rain falls here, it creates my favorite percussion."
      ],
      idle_chat: [
        "I'm transcribing a melody I dreamed last night.",
        "The pentatonic scale works beautifully for ZION's atmosphere.",
        "I've been collecting folk songs from every zone.",
        "A good improvisation session teaches you who you really are.",
        "I've been experimenting with harmonic structures from nature.",
        "Sometimes silence is the most important note.",
        "I'm composing a piece that captures all four seasons.",
        "The intervals between sounds matter as much as the sounds.",
        "I've been teaching rhythm workshops at the agora.",
        "Music is time made beautiful."
      ],
      weather: [
        "Rain is perfect percussion â€” I've been recording it.",
        "Wind like this creates a natural drone note. I love it.",
        "A storm is the world's most powerful orchestra.",
        "I hear a dominant seventh chord in that thunder.",
        "The silence before a storm is the best rest I know.",
        "Sun and birdsong create a natural major key atmosphere.",
        "Mist softens all the sounds into something dreamlike.",
        "I compose specifically to weather. Rain pieces, sun pieces.",
        "Every weather pattern has its own rhythm and tempo.",
        "Nature plays the opening movement. I write the rest."
      ],
      craft: [
        "I've been hand-crafting a new string instrument from local wood.",
        "Composing is like architecture â€” structure supports freedom.",
        "I'm refining a new tuning system for this climate.",
        "Hand-carving the sound holes is the most precise work.",
        "I've been inlaying decorative patterns into my instrument.",
        "Writing music notation by hand is a meditative practice.",
        "I'm crafting a reed instrument from marsh grass.",
        "The craft of improvisation takes a lifetime of preparation.",
        "I've been building a percussion ensemble from found objects.",
        "Crafting a lute from scratch changes how you understand music."
      ]
    },

    healer: {
      greeting: [
        "Welcome! Take a deep breath â€” you're safe here.",
        "Hello there. How are you, truly?",
        "Greetings! The healing grove welcomes all who need rest.",
        "Welcome! I always have time to listen.",
        "Hello, friend. You look like you could use some calm.",
        "Greetings! Care is the first and most important medicine.",
        "Welcome! Let me know if there's anything I can do.",
        "Hello. Sometimes just being greeted is what's needed most.",
        "Welcome to ZION. Rest when you need â€” this is a safe place.",
        "Hello! Your presence here is a gift to us all."
      ],
      zone_comment: [
        "The gardens hold every medicinal plant ZION needs.",
        "The healing energy of this zone is palpable, isn't it?",
        "I've identified thirty-seven medicinal plants in this area.",
        "Water and greenery together create the best healing conditions.",
        "The air here has a quality that promotes deep breathing.",
        "I tend to the herbs in that bed â€” all for wellness purposes.",
        "This zone attracts those who need restoration.",
        "Every healer I know has spent time in the gardens.",
        "The sound of water here is therapeutic. Proven to calm the mind.",
        "I built a small sanctuary in the eastern part of this zone."
      ],
      idle_chat: [
        "I've been preparing a new herbal salve for sore muscles.",
        "Preventative care is the most powerful healing of all.",
        "I've been documenting the healing properties of local plants.",
        "Rest is underrated as a medicine. I prescribe it often.",
        "Community and connection heal things herbs can't.",
        "I've been practicing a new breathing technique.",
        "The body knows how to heal. I just help it remember.",
        "I'm creating a wellness guide for every zone in ZION.",
        "Listening without judgment is my most-used skill.",
        "A healer's work is never truly done â€” and that's beautiful."
      ],
      weather: [
        "Rain nourishes the medicinal herbs more than anything I do.",
        "The cool air after rain helps with inflammation.",
        "Sun like this is excellent for vitamin-rich herb growth.",
        "Mist in the morning is when I collect the finest dew.",
        "Storm energy can be grounding if you breathe through it.",
        "Cold weather means immunity tonics become essential.",
        "Every season brings different wellness challenges.",
        "Rain is the earth healing itself. I find it comforting.",
        "The wind carries healing pollen from the distant flowers.",
        "Weather is medicine when you learn to listen to it."
      ],
      craft: [
        "I've been crafting a new compound salve from seven herbs.",
        "Distilling herbal tinctures is precise, patient work.",
        "I'm weaving a new poultice wrap from medicinal fibers.",
        "Crafting a remedy requires understanding root causes.",
        "I'm blending a new tea mixture for stress and sleep.",
        "Hand-pressing herbal tablets is satisfying, careful work.",
        "I've been creating illustrated charts of medicinal plant uses.",
        "Steeping time affects potency â€” I time everything exactly.",
        "I'm crafting a new treatment protocol for cold-weather ailments.",
        "The craft of healing is mostly listening and observing."
      ]
    },

    philosopher: {
      greeting: [
        "Welcome! What if I told you your arrival was inevitable?",
        "Greetings. What is the nature of a greeting, truly?",
        "Hello! Have you ever considered what 'here' means?",
        "Welcome! The very act of meeting is a philosophical event.",
        "Greetings! I've been contemplating chance versus destiny.",
        "Hello, seeker! What question brought you to ZION?",
        "Welcome. What is it you're really looking for?",
        "Greetings! Every arrival is also a departure from somewhere.",
        "Hello! If a visitor arrives unseen, have they truly arrived?",
        "Welcome! The universe arranged this meeting. Interesting."
      ],
      zone_comment: [
        "What does a place mean when no one is observing it?",
        "This zone raises questions I've been pondering for seasons.",
        "Place shapes thought â€” have you felt that here?",
        "The athenaeum is where certainty goes to become questions.",
        "If a tree falls in the wilds with no one nearby... you know the rest.",
        "I chose this spot precisely because it provokes thinking.",
        "Every location in ZION holds a different philosophical mood.",
        "The nexus is where paradox is most comfortable.",
        "This zone feels like a question mark in spatial form.",
        "Space is a kind of argument made physical."
      ],
      idle_chat: [
        "I've been considering whether free will is compatible with fate.",
        "What if consciousness is what the universe uses to know itself?",
        "I'm tracing the history of an idea across multiple civilizations.",
        "The most important questions have the simplest surfaces.",
        "I've been cataloguing logical paradoxes found in nature.",
        "If you had to define ZION in one word, what would it be?",
        "I've been questioning the nature of questioning itself.",
        "What would ZION look like if no one remembered it?",
        "Thinking without a goal is the purest form of thinking.",
        "I've been wrong about something for years. Now I see it clearly."
      ],
      weather: [
        "Rain falls the same on philosopher and stone â€” equalizing.",
        "Is a storm violent, or is violence a human judgment?",
        "What if weather is the sky's way of having emotions?",
        "The sun illuminates â€” but what hides in that very light?",
        "Wind moves everything except the questions underneath.",
        "Thunder is the universe punctuating its own thoughts.",
        "What does it mean for weather to be 'good' or 'bad'?",
        "I observe the storm without preference. It simply is.",
        "Mist makes the familiar strange again. Philosophically useful.",
        "Every weather pattern reveals how we impose meaning on chaos."
      ],
      craft: [
        "Writing philosophy is less craft, more excavation.",
        "I'm constructing a thought experiment in essay form.",
        "The craft of argument is knowing when to stop speaking.",
        "I've been designing a new logical framework from first principles.",
        "Philosophical dialogue is the highest collaborative art.",
        "I'm mapping the connections between contradictory ideas.",
        "The structure of a sound argument is its own kind of beauty.",
        "I've been crafting counterarguments to my own positions.",
        "Writing a question is harder than writing an answer.",
        "The craft of philosophy is learning to sit with uncertainty."
      ]
    },

    artist: {
      greeting: [
        "Welcome! Notice the way light falls on everything here.",
        "Hello! I was just mixing a new color I discovered in the sunset.",
        "Greetings! Have you seen the mural by the eastern wall?",
        "Welcome! Your face has wonderful character â€” may I sketch you?",
        "Hello! Art is everywhere if you look with open eyes.",
        "Greetings! Something about your arrival inspired a new piece.",
        "Welcome to ZION! The beauty here is inexhaustible.",
        "Hello! I find strangers are often the most inspiring subjects.",
        "Greetings! This world deserves to be seen and made.",
        "Welcome! I've been painting since dawn â€” what do you see?"
      ],
      zone_comment: [
        "The light in this zone changes every hour â€” I never tire of it.",
        "I've painted this view from twenty different angles.",
        "Every texture here tells a story of wind, water, and time.",
        "The color palette of this zone shifts with the seasons.",
        "I installed three murals here â€” they've become landmarks.",
        "The way shadow falls in this space is endlessly interesting.",
        "Beauty reveals itself differently to different eyes here.",
        "I've filled seven sketchbooks just from this one zone.",
        "The negative space between these structures is as important as the structures.",
        "This zone inspired my most celebrated series."
      ],
      idle_chat: [
        "I've been experimenting with pigments made from local stones.",
        "Every piece I make is a conversation with the viewer.",
        "I've been studying how different surfaces accept color.",
        "Creativity is the practice of seeing what already exists.",
        "I'm working on a triptych inspired by the three moons.",
        "The hardest part of art is knowing when it's finished.",
        "I sketch everything â€” it's how I think.",
        "I've been creating sculptures from materials found in the wilds.",
        "Art without vulnerability is just decoration.",
        "I'm in a period of experimentation. Everything is allowed."
      ],
      weather: [
        "Rain changes color temperature dramatically â€” I love painting it.",
        "Storm light is the most dramatic light there is.",
        "The gray of an overcast sky has fifty different colors in it.",
        "Mist turns every scene into an impressionist painting.",
        "Golden hour in a storm is the most beautiful contradiction.",
        "I set up outside in the rain specifically to capture this.",
        "Every weather condition produces a different emotional palette.",
        "Wind creates movement in everything â€” animation for free.",
        "I have a whole series called 'Weather as Medium'.",
        "Snow would transform every color here. I can't wait."
      ],
      craft: [
        "I've been grinding local minerals into pigment all morning.",
        "The craft of seeing comes before the craft of making.",
        "I'm building a new frame from driftwood and copper wire.",
        "Mixing the perfect shade takes patience and intuition.",
        "I've been experimenting with encaustic wax painting.",
        "Every brushstroke is a decision â€” thousands per piece.",
        "I'm weaving a tapestry from naturally-dyed fibers.",
        "Hand-casting bronze sculptures is exhausting and beautiful.",
        "The craft of composition is knowing what to leave out.",
        "I'm creating a mosaic using only materials from ZION."
      ]
    }
  };

  var DEFAULT_FALLBACK_POOL = [
    "Welcome to ZION! It's a beautiful day.",
    "Hello there! I'm glad you found your way here.",
    "Greetings, traveler! What brings you to this part of the world?",
    "Good to see you! This place has something special about it.",
    "Hello! Every day here is a new adventure.",
    "Welcome! The community here is warm and welcoming.",
    "Greetings! I love meeting new people in ZION.",
    "Hello! There's always something interesting happening here.",
    "Welcome! Take your time and explore.",
    "Greetings! This world is full of wonders."
  ];

  var CONTEXT_TYPE_MAP = {
    'greeting': 'greeting',
    'zone_comment': 'zone_comment',
    'zone': 'zone_comment',
    'idle': 'idle_chat',
    'idle_chat': 'idle_chat',
    'weather': 'weather',
    'craft': 'craft',
    'crafting': 'craft'
  };

  var STOP_WORDS = {
    'the': 1, 'a': 1, 'an': 1, 'and': 1, 'or': 1, 'but': 1, 'in': 1,
    'on': 1, 'at': 1, 'to': 1, 'for': 1, 'of': 1, 'with': 1, 'is': 1,
    'it': 1, 'i': 1, 'you': 1, 'we': 1, 'they': 1, 'this': 1, 'that': 1,
    'was': 1, 'are': 1, 'be': 1, 'been': 1, 'have': 1, 'has': 1, 'do': 1,
    'did': 1, 'so': 1, 'if': 1, 'my': 1, 'me': 1, 'he': 1, 'she': 1,
    'from': 1, 'by': 1, 'as': 1, 'not': 1, 'no': 1, 'can': 1, 'just': 1,
    'what': 1, 'how': 1, 'who': 1, 'when': 1, 'here': 1, 'there': 1,
    'like': 1, 'its': 1, 'all': 1, 'been': 1, 'about': 1, 'up': 1,
    'more': 1, 'some': 1, 'would': 1, 'their': 1, 'will': 1, 'your': 1
  };

  var OPINION_TEMPLATES = {
    gardener: [
      "From a gardener's view, {topic} is like planting â€” it takes patience and care.",
      "I think about {topic} the way I think about soil â€” it needs the right conditions to flourish.",
      "{topic} reminds me of tending plants. You have to listen to what's already there.",
      "My opinion on {topic}: nurture it, and it will grow. Rush it, and it won't.",
      "The gardens teach me about {topic} â€” everything cycles, everything has its season."
    ],
    builder: {
      templates: [
        "Let me be direct about {topic}: it needs a strong foundation or it will fail.",
        "The structure of {topic} matters more than its surface â€” I'd start from the base.",
        "My take on {topic}: measure twice, decide once. No shortcuts.",
        "{topic} is a construction problem. Identify the load-bearing elements.",
        "Practically speaking, {topic} requires clear planning before any action."
      ]
    },
    storyteller: {
      templates: [
        "There was once a world that faced {topic}... and here is what happened.",
        "Every great story has {topic} as its conflict. The question is the resolution.",
        "Legend says {topic} was decided long ago. But every legend can be rewritten.",
        "The most compelling chapter of any saga always involves {topic}.",
        "I've heard a hundred tales about {topic}. The wisest had no clear answer."
      ]
    },
    merchant: {
      templates: [
        "The value of {topic} depends entirely on what you're willing to trade for it.",
        "Let me assess {topic} like a trade: what's the cost, what's the benefit?",
        "In my experience, {topic} is worth investing in â€” when the timing is right.",
        "My honest appraisal of {topic}: undervalued by most, overrated by some.",
        "{topic} has real market potential. The smart move is to position early."
      ]
    },
    explorer: {
      templates: [
        "Have you explored every angle of {topic}? I find the edges most interesting.",
        "My first expedition into {topic} revealed things I hadn't expected.",
        "{topic} is uncharted territory for most people. That's exactly why it excites me.",
        "Beyond the obvious surface of {topic} is where the real discovery lives.",
        "I've mapped the terrain of {topic} and can tell you: the journey is worth it."
      ]
    },
    teacher: {
      templates: [
        "Consider this about {topic}: what do you already know, and what are you assuming?",
        "The key question about {topic} isn't what, but why. Start there.",
        "I've taught many lessons that touched on {topic}. The wisest students questioned everything.",
        "{topic} is a fascinating subject. What do YOU think about it?",
        "A Socratic approach to {topic}: challenge every assumption, find the root question."
      ]
    },
    musician: {
      templates: [
        "{topic} has a rhythm to it â€” sometimes you find it, sometimes you set it.",
        "In harmony terms, {topic} is a tension that wants resolution.",
        "There's a melody in {topic} if you listen for it.",
        "Every complex thing like {topic} has an underlying theme. Find that theme.",
        "My musical opinion on {topic}: it needs space. Let it breathe."
      ]
    },
    healer: {
      templates: [
        "From a wellness perspective, {topic} requires careful, gentle attention.",
        "I approach {topic} with the same care as healing â€” first, do no harm.",
        "The health of any situation like {topic} depends on what we nurture.",
        "{topic} can be a source of stress or strength. Choose your relationship with it.",
        "I believe {topic} needs compassion more than solutions right now."
      ]
    },
    philosopher: {
      templates: [
        "What if {topic} is not a problem but a question? Questions are more interesting.",
        "I've been contemplating {topic}. The more I consider it, the more uncertain I become.",
        "The true nature of {topic} depends on what we believe reality to be.",
        "Is {topic} real, or do we make it real by believing in it? Both, I suspect.",
        "Ponder this about {topic}: every position contains its own contradiction."
      ]
    },
    artist: {
      templates: [
        "I see {topic} as a palette â€” what colors are you choosing from it?",
        "The beauty in {topic} is in how it changes when you change your angle.",
        "I'd paint {topic} in deep blues and gold. It has that kind of weight.",
        "{topic} inspires me. Every challenge is just unfinished art.",
        "The texture of {topic} is rough at first, smooth with time. Worth feeling."
      ]
    }
  };

  for (var arch in OPINION_TEMPLATES) {
    if (OPINION_TEMPLATES.hasOwnProperty(arch)) {
      var val = OPINION_TEMPLATES[arch];
      if (Array.isArray(val)) {
        OPINION_TEMPLATES[arch] = { templates: val };
      }
    }
  }

  var DEFAULT_OPINION_TEMPLATES = [
    "My honest view on {topic} is that it deserves careful thought.",
    "I find {topic} to be a genuinely interesting subject.",
    "{topic} is something the whole community should consider.",
    "When it comes to {topic}, I prefer to listen more than speak.",
    "I have mixed feelings about {topic} â€” it's more complex than it seems."
  ];

  function safeStr(val, fallback) {
    if (typeof val === 'string') return val;
    if (val == null) return (typeof fallback === 'string' ? fallback : '');
    return String(val);
  }

  function seededRandom(seed) {
    var x = Math.sin(seed + 1) * 10000;
    return x - Math.floor(x);
  }

  function randomPick(arr) {
    if (!arr || arr.length === 0) return null;
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function seededPick(arr, seed) {
    if (!arr || arr.length === 0) return null;
    var idx = Math.floor(seededRandom(seed) * arr.length);
    return arr[idx];
  }

  function tokenize(text) {
    if (!text || typeof text !== 'string') return [];
    var words = text.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/);
    var result = [];
    for (var i = 0; i < words.length; i++) {
      var w = words[i];
      if (w.length >= 3 && !STOP_WORDS[w]) {
        result.push(w);
      }
    }
    return result;
  }

  function countFrequencies(words) {
    var freq = {};
    for (var i = 0; i < words.length; i++) {
      var w = words[i];
      freq[w] = (freq[w] || 0) + 1;
    }
    return freq;
  }

  function detectSentiment(text) {
    if (!text) return 'neutral';
    var lower = text.toLowerCase();
    var positiveWords = ['love', 'beautiful', 'great', 'wonderful', 'amazing', 'perfect',
                         'excellent', 'joy', 'happy', 'good', 'best', 'incredible', 'fantastic'];
    var negativeWords = ['hate', 'terrible', 'awful', 'bad', 'wrong', 'broken', 'sad',
                         'difficult', 'hard', 'problem', 'trouble', 'fail', 'fear'];
    var posCount = 0;
    var negCount = 0;
    for (var i = 0; i < positiveWords.length; i++) {
      if (lower.indexOf(positiveWords[i]) !== -1) posCount++;
    }
    for (var j = 0; j < negativeWords.length; j++) {
      if (lower.indexOf(negativeWords[j]) !== -1) negCount++;
    }
    if (posCount > negCount) return 'positive';
    if (negCount > posCount) return 'negative';
    return 'neutral';
  }

  function buildPrompt(npc, context) {
    var name = safeStr(npc && npc.name, 'Unknown');
    var archetype = safeStr(npc && npc.archetype, 'citizen');
    var personality = (npc && Array.isArray(npc.personality) && npc.personality.length > 0)
      ? npc.personality.join(', ')
      : 'curious and friendly';
    var homeZone = safeStr(npc && npc.home_zone, 'nexus');

    context = context || {};
    var zone = safeStr(context.zone, homeZone);
    var timeOfDay = safeStr(context.timeOfDay, 'daytime');
    var weather = safeStr(context.weather, 'clear');
    var activity = safeStr(context.currentActivity, 'wandering');
    var nearbyPlayers = Array.isArray(context.nearbyPlayers) ? context.nearbyPlayers : [];
    var recentChat = Array.isArray(context.recentChat) ? context.recentChat : [];

    var voiceProfile = VOICE_PROFILES[archetype];
    var voiceStyle = voiceProfile ? voiceProfile.style : 'friendly and helpful';
    var voiceMood = voiceProfile ? voiceProfile.mood : 'neutral';

    var memories = npc ? getRelevantMemories(npc, context) : [];
    var memorySummary = memories.length > 0 ? summarizeMemories(memories) : '';

    var sections = [];

    sections.push('You are ' + name + ', a ' + archetype + ' in ZION.');
    sections.push('Personality: ' + personality + '.');
    sections.push('Speaking style: ' + voiceStyle + '.');
    sections.push('Current mood: ' + voiceMood + '.');
    sections.push('Location: ' + zone + ' zone. Time: ' + timeOfDay + '. Weather: ' + weather + '.');
    sections.push('Current activity: ' + activity + '.');

    if (nearbyPlayers.length > 0) {
      sections.push('Nearby players: ' + nearbyPlayers.slice(0, 3).join(', ') + '.');
    }

    if (memorySummary) {
      sections.push('Recent memories: ' + memorySummary);
    }

    if (recentChat.length > 0) {
      var chatLines = [];
      var maxChat = Math.min(recentChat.length, 3);
      for (var i = Math.max(0, recentChat.length - maxChat); i < recentChat.length; i++) {
        var msg = recentChat[i];
        if (msg && msg.from && msg.message) {
          chatLines.push(msg.from + ': ' + msg.message);
        }
      }
      if (chatLines.length > 0) {
        sections.push('Recent conversation:\n' + chatLines.join('\n'));
      }
    }

    sections.push('Respond as ' + name + ' in 1-2 sentences, in character.');
    sections.push('You may include [ACTION: verb] or [EMOTION: word] tags if relevant.');

    var prompt = sections.join('\n');

    if (prompt.length > MAX_PROMPT_CHARS) {
      prompt = prompt.substring(0, MAX_PROMPT_CHARS - 3) + '...';
    }

    return prompt;
  }

  function buildConversationPrompt(npc1, npc2, topic) {
    var name1 = safeStr(npc1 && npc1.name, 'Citizen A');
    var arch1 = safeStr(npc1 && npc1.archetype, 'citizen');
    var name2 = safeStr(npc2 && npc2.name, 'Citizen B');
    var arch2 = safeStr(npc2 && npc2.archetype, 'citizen');

    var voice1 = VOICE_PROFILES[arch1];
    var voice2 = VOICE_PROFILES[arch2];

    var sections = [
      'Two citizens of ZION are having a conversation.',
      name1 + ' is a ' + arch1 + '. ' + (voice1 ? 'Style: ' + voice1.style + '.' : ''),
      name2 + ' is a ' + arch2 + '. ' + (voice2 ? 'Style: ' + voice2.style + '.' : '')
    ];

    if (topic) {
      sections.push('They are discussing: ' + topic);
    } else {
      sections.push('They are chatting about everyday life in ZION.');
    }

    sections.push('Write one line from ' + name1 + ' responding to ' + name2 + ', in character.');
    sections.push('Format: [' + name1 + ']: (their line)');

    var prompt = sections.join('\n');
    if (prompt.length > MAX_PROMPT_CHARS) {
      prompt = prompt.substring(0, MAX_PROMPT_CHARS - 3) + '...';
    }
    return prompt;
  }

  function buildReactionPrompt(npc, event) {
    var name = safeStr(npc && npc.name, 'Citizen');
    var archetype = safeStr(npc && npc.archetype, 'citizen');
    var personality = (npc && Array.isArray(npc.personality) && npc.personality.length > 0)
      ? npc.personality.join(', ')
      : 'curious';

    var eventType = safeStr(event && event.type, 'unknown_event');
    var eventData = (event && event.data) ? JSON.stringify(event.data) : '{}';

    var voice = VOICE_PROFILES[archetype];
    var style = voice ? voice.style : 'friendly';

    var prompt = [
      'You are ' + name + ', a ' + archetype + ' in ZION.',
      'Personality: ' + personality + '.',
      'Speaking style: ' + style + '.',
      'A world event just occurred: ' + eventType + '.',
      'Event details: ' + eventData,
      'React to this event as ' + name + ' in 1 sentence, in character.',
      'You may include [ACTION: verb] or [EMOTION: word] tags.'
    ].join('\n');

    if (prompt.length > MAX_PROMPT_CHARS) {
      prompt = prompt.substring(0, MAX_PROMPT_CHARS - 3) + '...';
    }
    return prompt;
  }

  function parseResponse(rawResponse) {
    var empty = { message: '', action: '', emotion: '', memory: '' };

    if (rawResponse == null || rawResponse === undefined) {
      return empty;
    }

    var raw = String(rawResponse);

    var action = '';
    var actionMatch = raw.match(/\[ACTION:\s*([^\]]+)\]/i);
    if (actionMatch) {
      action = actionMatch[1].trim();
      raw = raw.replace(/\[ACTION:\s*[^\]]+\]/gi, '');
    }

    var emotion = '';
    var emotionMatch = raw.match(/\[EMOTION:\s*([^\]]+)\]/i);
    if (emotionMatch) {
      emotion = emotionMatch[1].trim();
      raw = raw.replace(/\[EMOTION:\s*[^\]]+\]/gi, '');
    }

    var memory = '';
    var memoryMatch = raw.match(/\[MEMORY:\s*([^\]]+)\]/i);
    if (memoryMatch) {
      memory = memoryMatch[1].trim();
      raw = raw.replace(/\[MEMORY:\s*[^\]]+\]/gi, '');
    }

    var message = raw.trim();

    return { message: message, action: action, emotion: emotion, memory: memory };
  }

  function sanitize(response) {
    if (response == null || response === undefined) return '';

    var text = String(response).trim();

    var metaPatterns = [
      /As an AI( language model)?[,.]?\s*/gi,
      /I am an AI( assistant)?[,.]?\s*/gi,
      /I'm an AI( assistant)?[,.]?\s*/gi,
      /As a (language model|AI|chatbot)[,.]?\s*/gi,
      /Note:\s*I am[^.]*\./gi
    ];

    for (var i = 0; i < metaPatterns.length; i++) {
      text = text.replace(metaPatterns[i], '');
    }

    var bannedPatterns = [
      /\b(stupid|idiot|hate|kill|die|death|damn|hell|crap|ass)\b/gi
    ];

    for (var j = 0; j < bannedPatterns.length; j++) {
      text = text.replace(bannedPatterns[j], '---');
    }

    text = text.trim();

    if (text.length > MAX_SPEECH_CHARS) {
      var truncated = text.substring(0, MAX_SPEECH_CHARS);
      var lastSpace = truncated.lastIndexOf(' ');
      if (lastSpace > MAX_SPEECH_CHARS * 0.7) {
        truncated = truncated.substring(0, lastSpace);
      }
      text = truncated.trim();
    }

    return text;
  }

  function createManager(config) {
    config = config || {};
    var cooldownMs = typeof config.cooldownMs === 'number' ? config.cooldownMs : DEFAULT_COOLDOWN_MS;
    var maxQueueSize = typeof config.maxQueueSize === 'number' ? config.maxQueueSize : DEFAULT_MAX_QUEUE;

    var queue = [];
    var responses = {};
    var lastSpoke = {};
    var conversations = {};

    function queueDialogue(npc, context) {
      if (!npc || !npc.id) return;

      var now = Date.now();
      var last = lastSpoke[npc.id] || 0;
      if (now - last < cooldownMs) return;

      if (queue.length >= maxQueueSize) return;

      for (var i = 0; i < queue.length; i++) {
        if (queue[i].npc.id === npc.id) return;
      }

      queue.push({ npc: npc, context: context || {} });
    }

    function processQueue(inferenceFunction) {
      if (queue.length === 0) return;

      var item = queue.shift(); // FIFO
      var prompt = buildPrompt(item.npc, item.context);

      inferenceFunction(prompt, function(err, rawResponse) {
        if (err) {
          rawResponse = getFallback(item.npc, item.context);
        }

        var now = Date.now();
        var parsed = parseResponse(rawResponse);
        var clean = sanitize(parsed.message || rawResponse);

        responses[item.npc.id] = {
          raw: rawResponse,
          parsed: parsed,
          message: clean,
          timestamp: now
        };

        lastSpoke[item.npc.id] = now;
      });
    }

    function getResponse(npc) {
      if (!npc || !npc.id) return null;
      return responses[npc.id] || null;
    }

    function getCooldown(npcId) {
      if (!npcId) return 0;
      var last = lastSpoke[npcId] || 0;
      if (last === 0) return 0;
      var remaining = cooldownMs - (Date.now() - last);
      return Math.max(0, remaining);
    }

    function getConversation(npc1Id, npc2Id) {
      var key = [npc1Id, npc2Id].sort().join(':');
      return conversations[key] || [];
    }

    function recordConversation(npc1Id, npc2Id, speaker, message) {
      var key = [npc1Id, npc2Id].sort().join(':');
      if (!conversations[key]) conversations[key] = [];
      conversations[key].push({
        speaker: speaker,
        message: message,
        timestamp: Date.now()
      });
      if (conversations[key].length > 50) {
        conversations[key] = conversations[key].slice(-50);
      }
    }

    return {
      queueDialogue: queueDialogue,
      processQueue: processQueue,
      getResponse: getResponse,
      getCooldown: getCooldown,
      getConversation: getConversation,
      recordConversation: recordConversation
    };
  }

  function getFallback(npc, context) {
    var archetype = safeStr(npc && npc.archetype, '');
    context = context || {};
    var contextType = safeStr(context.type, 'greeting');

    var poolKey = CONTEXT_TYPE_MAP[contextType] || 'greeting';

    var archetypePool = FALLBACK_POOLS[archetype];
    if (!archetypePool) {
      return randomPick(DEFAULT_FALLBACK_POOL) || "Hello! Welcome to ZION.";
    }

    var pool = archetypePool[poolKey];
    if (!pool || pool.length === 0) {
      pool = archetypePool['greeting'] || DEFAULT_FALLBACK_POOL;
    }

    var response = randomPick(pool);
    if (!response) response = "Hello! Welcome to ZION.";

    var name = safeStr(npc && npc.name, '');
    if (name) {
      response = response.replace(/\{name\}/g, name);
    }

    return response;
  }

  function generateFallbackPool(archetype) {
    if (!archetype) {
      return DEFAULT_FALLBACK_POOL.slice();
    }

    var archetypeStr = String(archetype);
    var archetypePool = FALLBACK_POOLS[archetypeStr];
    if (!archetypePool) {
      return DEFAULT_FALLBACK_POOL.slice();
    }

    var allResponses = [];
    var contextTypes = Object.keys(archetypePool);
    for (var i = 0; i < contextTypes.length; i++) {
      var pool = archetypePool[contextTypes[i]];
      if (Array.isArray(pool)) {
        for (var j = 0; j < pool.length; j++) {
          allResponses.push(pool[j]);
        }
      }
    }

    return allResponses.length > 0 ? allResponses : DEFAULT_FALLBACK_POOL.slice();
  }

  function updateMemory(npc, conversation) {
    if (!npc) return {};

    var memory = (npc.memory && typeof npc.memory === 'object')
      ? JSON.parse(JSON.stringify(npc.memory))  // shallow clone
      : {};

    if (!conversation || !Array.isArray(conversation)) {
      return memory;
    }

    if (!memory.interactions) memory.interactions = [];

    var players = {};
    var topics = [];
    for (var i = 0; i < conversation.length; i++) {
      var msg = conversation[i];
      if (!msg) continue;
      var speaker = safeStr(msg.speaker, '');
      if (speaker && speaker !== safeStr(npc && npc.name, '')) {
        players[speaker] = true;
      }
      var msgWords = tokenize(safeStr(msg.message, ''));
      for (var j = 0; j < msgWords.length; j++) {
        topics.push(msgWords[j]);
      }
    }

    var topicFreq = countFrequencies(topics);
    var topTopic = '';
    var topCount = 0;
    for (var word in topicFreq) {
      if (topicFreq.hasOwnProperty(word) && topicFreq[word] > topCount) {
        topCount = topicFreq[word];
        topTopic = word;
      }
    }

    var playerList = Object.keys(players);
    if (playerList.length > 0 || topTopic) {
      memory.interactions.push({
        with: playerList[0] || 'unknown',
        topic: topTopic || 'conversation',
        time: Date.now()
      });
    }

    if (memory.interactions.length > MEMORY_MAX_INTERACTIONS) {
      memory.interactions = memory.interactions.slice(-MEMORY_MAX_INTERACTIONS);
    }

    if (typeof memory.greetings_given === 'number') {
      if (conversation.length > 0) {
        memory.greetings_given++;
      }
    }

    return memory;
  }

  function getRelevantMemories(npc, context) {
    if (!npc || !npc.memory) return [];

    var memory = npc.memory;
    if (!memory.interactions || !Array.isArray(memory.interactions)) return [];

    context = context || {};
    var nearbyPlayers = Array.isArray(context.nearbyPlayers) ? context.nearbyPlayers : [];
    var zone = safeStr(context.zone, '');

    var now = Date.now();
    var oneDayMs = 86400000;

    var scored = [];
    for (var i = 0; i < memory.interactions.length; i++) {
      var mem = memory.interactions[i];
      if (!mem) continue;

      var score = 0;

      if (mem.with && nearbyPlayers.indexOf(mem.with) !== -1) {
        score += 10;
      }

      var age = now - (mem.time || 0);
      if (age < oneDayMs) {
        score += Math.floor((oneDayMs - age) / (oneDayMs / 5));
      }

      scored.push({ memory: mem, score: score });
    }

    scored.sort(function(a, b) { return b.score - a.score; });

    var result = [];
    var maxMems = 5;
    for (var j = 0; j < Math.min(scored.length, maxMems); j++) {
      result.push(scored[j].memory);
    }

    return result;
  }

  function summarizeMemories(memories) {
    if (!memories || memories.length === 0) return '';

    var parts = [];
    var maxToInclude = Math.min(memories.length, 3);

    for (var i = 0; i < maxToInclude; i++) {
      var mem = memories[i];
      if (!mem) continue;
      var who = safeStr(mem.with, 'someone');
      var topic = safeStr(mem.topic, 'something');
      parts.push('talked with ' + who + ' about ' + topic);
    }

    if (memories.length > maxToInclude) {
      parts.push('and ' + (memories.length - maxToInclude) + ' more interactions');
    }

    return parts.join('; ');
  }

  function detectTrend(recentDialogues) {
    if (!recentDialogues || !Array.isArray(recentDialogues)) return null;
    if (recentDialogues.length < 2) return null;

    var wordParticipants = {};  // word -> [npcId]
    var wordMessages = {};      // word -> [message]

    for (var i = 0; i < recentDialogues.length; i++) {
      var dlg = recentDialogues[i];
      if (!dlg) continue;
      var words = tokenize(safeStr(dlg.message, ''));
      for (var j = 0; j < words.length; j++) {
        var w = words[j];
        if (!wordParticipants[w]) {
          wordParticipants[w] = [];
          wordMessages[w] = [];
        }
        if (dlg.npcId && wordParticipants[w].indexOf(dlg.npcId) === -1) {
          wordParticipants[w].push(dlg.npcId);
        }
        wordMessages[w].push(safeStr(dlg.message, ''));
      }
    }

    var topWord = null;
    var topParticipantCount = 0;

    for (var word in wordParticipants) {
      if (!wordParticipants.hasOwnProperty(word)) continue;
      var count = wordParticipants[word].length;
      if (count > topParticipantCount) {
        topParticipantCount = count;
        topWord = word;
      }
    }

    if (!topWord || topParticipantCount < TREND_MIN_OCCURRENCES) return null;

    var relatedMessages = wordMessages[topWord];
    var combinedText = relatedMessages.join(' ');
    var sentiment = detectSentiment(combinedText);

    return {
      topic: topWord,
      sentiment: sentiment,
      participants: wordParticipants[topWord]
    };
  }

  function getPopularTopics(dialogueHistory, windowMs) {
    if (!dialogueHistory || !Array.isArray(dialogueHistory) || dialogueHistory.length === 0) {
      return [];
    }

    var now = Date.now();
    var filtered = dialogueHistory;

    if (typeof windowMs === 'number' && windowMs > 0) {
      filtered = [];
      for (var i = 0; i < dialogueHistory.length; i++) {
        var dlg = dialogueHistory[i];
        if (dlg && dlg.timestamp && (now - dlg.timestamp) <= windowMs) {
          filtered.push(dlg);
        } else if (dlg && !dlg.timestamp) {
        }
      }
    }

    var allWords = [];
    var wordMessages = {};  // word -> [message text]

    for (var j = 0; j < filtered.length; j++) {
      var entry = filtered[j];
      if (!entry) continue;
      var words = tokenize(safeStr(entry.message, ''));
      for (var k = 0; k < words.length; k++) {
        var w = words[k];
        allWords.push(w);
        if (!wordMessages[w]) wordMessages[w] = [];
        wordMessages[w].push(safeStr(entry.message, ''));
      }
    }

    var freq = countFrequencies(allWords);

    var topics = [];
    for (var word in freq) {
      if (!freq.hasOwnProperty(word)) continue;
      var count = freq[word];
      if (count < 1) continue;
      var msgs = wordMessages[word] || [];
      var sentiment = detectSentiment(msgs.join(' '));
      topics.push({ topic: word, count: count, sentiment: sentiment });
    }

    topics.sort(function(a, b) { return b.count - a.count; });

    return topics;
  }

  function generateOpinion(npc, topic) {
    var archetype = safeStr(npc && npc.archetype, '');
    var topicStr = safeStr(topic, 'this matter');

    var templates;
    var archetypeData = OPINION_TEMPLATES[archetype];
    if (archetypeData && archetypeData.templates) {
      templates = archetypeData.templates;
    } else {
      templates = DEFAULT_OPINION_TEMPLATES;
    }

    var template = randomPick(templates);
    if (!template) template = DEFAULT_OPINION_TEMPLATES[0];

    return template.replace(/\{topic\}/g, topicStr || 'this matter');
  }

  exports.buildPrompt = buildPrompt;
  exports.buildConversationPrompt = buildConversationPrompt;
  exports.buildReactionPrompt = buildReactionPrompt;

  exports.parseResponse = parseResponse;
  exports.sanitize = sanitize;

  exports.createManager = createManager;

  exports.getFallback = getFallback;
  exports.generateFallbackPool = generateFallbackPool;

  exports.updateMemory = updateMemory;
  exports.getRelevantMemories = getRelevantMemories;
  exports.summarizeMemories = summarizeMemories;

  exports.detectTrend = detectTrend;
  exports.getPopularTopics = getPopularTopics;
  exports.generateOpinion = generateOpinion;

})(typeof module !== 'undefined' ? module.exports : (window.NpcDialogue = {}));

// LAZY_LOAD_END: npc_dialogue

// npc_ai.js

(function(exports) {
  'use strict';

  var PERCEPTION_RADIUS = 25; // How far NPCs can "see"
  var INTERACTION_COOLDOWN = 30000; // 30 seconds before re-greeting same player
  var MEMORY_DECAY_RATE = 0.001; // Per tick familiarity decay
  var MAX_INTERACTIONS_REMEMBERED = 20;
  var MAX_EVENTS_REMEMBERED = 10;
  var ENERGY_DECAY_RATE = 0.05; // Per minute
  var ENERGY_REGEN_RATE = 0.2; // Per minute when resting
  var FAMILIARITY_GAIN = 5; // Points per interaction
  var FAMILIARITY_THRESHOLD_FRIENDLY = 25;
  var FAMILIARITY_THRESHOLD_CLOSE = 60;
  var GROUP_FORMATION_RADIUS = 15;
  var WORK_SATISFACTION_GAIN = 10;

  var ARCHETYPE_DRIVES = {
    gardener: {
      primary: 'tend_plants',
      secondary: 'explore_flora',
      social: 'share_harvest',
      rest: 'sit_in_garden',
      work_locations: ['gardens', 'wilds'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'rain', // Loves rain
    },
    builder: {
      primary: 'inspect_structures',
      secondary: 'gather_materials',
      social: 'discuss_plans',
      rest: 'sketch_designs',
      work_locations: ['agora', 'construction_sites'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'clear',
    },
    storyteller: {
      primary: 'visit_athenaeum',
      secondary: 'collect_stories',
      social: 'tell_stories',
      rest: 'write_journal',
      work_locations: ['athenaeum', 'agora'],
      preferred_time: ['afternoon', 'evening'],
      weather_preference: 'any',
    },
    merchant: {
      primary: 'tend_shop',
      secondary: 'acquire_goods',
      social: 'negotiate_trade',
      rest: 'count_inventory',
      work_locations: ['agora', 'marketplace'],
      preferred_time: ['morning', 'midday', 'afternoon'],
      weather_preference: 'clear',
    },
    explorer: {
      primary: 'explore_wilds',
      secondary: 'map_territory',
      social: 'share_discoveries',
      rest: 'study_maps',
      work_locations: ['wilds', 'mountains', 'coastline'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'any', // Explorers don't care
    },
    teacher: {
      primary: 'teach_lesson',
      secondary: 'research',
      social: 'mentor_individual',
      rest: 'read_texts',
      work_locations: ['athenaeum', 'agora'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'clear',
    },
    musician: {
      primary: 'perform',
      secondary: 'compose',
      social: 'jam_session',
      rest: 'tune_instrument',
      work_locations: ['agora', 'amphitheater', 'gardens'],
      preferred_time: ['evening', 'night'],
      weather_preference: 'clear',
    },
    healer: {
      primary: 'tend_wounded',
      secondary: 'gather_herbs',
      social: 'offer_comfort',
      rest: 'meditate',
      work_locations: ['gardens', 'healing_grove', 'agora'],
      preferred_time: ['morning', 'midday'],
      weather_preference: 'clear',
    },
    philosopher: {
      primary: 'contemplate',
      secondary: 'debate',
      social: 'discuss_ideas',
      rest: 'stargaze',
      work_locations: ['overlook', 'gardens', 'athenaeum'],
      preferred_time: ['afternoon', 'evening', 'night'],
      weather_preference: 'clear',
    },
    artist: {
      primary: 'create_art',
      secondary: 'find_inspiration',
      social: 'show_work',
      rest: 'observe_beauty',
      work_locations: ['gardens', 'overlook', 'coastline'],
      preferred_time: ['morning', 'afternoon', 'evening'],
      weather_preference: 'any', // Artists find beauty in all weather
    }
  };

  var DAILY_SCHEDULE = {
    dawn: {
      hours: [5, 7],
      activity: 'wake_stretch',
      energy_regen: 0.5,
      social_chance: 0.1,
      work_priority: 0.3,
    },
    morning: {
      hours: [7, 12],
      activity: 'primary_work',
      energy_regen: 0,
      social_chance: 0.3,
      work_priority: 1.0,
    },
    midday: {
      hours: [12, 14],
      activity: 'socialize_eat',
      energy_regen: 0.2,
      social_chance: 0.8,
      work_priority: 0.2,
    },
    afternoon: {
      hours: [14, 18],
      activity: 'secondary_work',
      energy_regen: 0,
      social_chance: 0.4,
      work_priority: 0.8,
    },
    evening: {
      hours: [18, 21],
      activity: 'socialize_music',
      energy_regen: 0,
      social_chance: 0.9,
      work_priority: 0.3,
    },
    night: {
      hours: [21, 5],
      activity: 'rest_stargaze',
      energy_regen: 1.0,
      social_chance: 0.2,
      work_priority: 0.1,
    }
  };

  var CONTEXTUAL_DIALOGUES = {
    gardener: {
      greeting_first: [
        "Welcome to ZION! I'm {name}. The gardens are beautiful today.",
        "Hello there! I tend the gardens here. The flowers are in bloom!",
        "Greetings, friend! Have you seen the moonflowers by the pond?"
      ],
      greeting_familiar: [
        "Good to see you again! The {plant} I planted is growing well.",
        "Welcome back! Would you like to help me water the herbs?",
        "Ah, my friend returns! The garden remembers you."
      ],
      greeting_close: [
        "My dear friend! I saved some seeds for you.",
        "I was hoping you'd come by! Look at this new variety!",
        "Perfect timing! I need your opinion on these blooms."
      ],
      weather_rain: [
        "Perfect weather for the gardens!",
        "The flowers will love this rain.",
        "*dancing in the rain* Nature's gift!",
        "Rain means growth. Beautiful, isn't it?"
      ],
      weather_snow: [
        "Even in snow, life persists. See these hardy plants?",
        "Winter gardens have their own beauty.",
        "The frost makes crystals on the leaves. Magical."
      ],
      weather_clear: [
        "What a beautiful day to tend the garden.",
        "The sunshine makes everything grow.",
        "Perfect weather for planting!"
      ],
      time_morning: [
        "Early bird! The morning dew is perfect for planting.",
        "Good morning! The world is waking up.",
        "*trimming plants* Best time to work the soil."
      ],
      time_evening: [
        "The sunset colors are inspiring today.",
        "Evening light makes the flowers glow.",
        "Time to water before nightfall."
      ],
      time_night: [
        "The night-blooming flowers are opening. Come see!",
        "Starlight on petals... there's nothing quite like it.",
        "The garden sleeps, but I'm watching over it."
      ],
      player_building: [
        "That's looking great! Need any plants to decorate?",
        "Beautiful structure! I can bring vines to accent it.",
        "A gardener appreciates good craftsmanship!"
      ],
      player_harvesting: [
        "Good technique! Try the moonflowers next.",
        "Gentle hands. The plants appreciate that.",
        "Would you like to know the best time to harvest sage?"
      ],
      working: [
        "*carefully tends the soil*",
        "*hums while watering*",
        "*examining leaves for health*",
        "*pruning with precision*"
      ],
      idle_observation: [
        "Those clouds remind me of cotton flowers.",
        "I think I see a new bloom over there!",
        "The bees are busy today. Good sign.",
        "Every plant has a story, if you listen."
      ],
      near_water: [
        "The pond keeps everything lush.",
        "Water is life.",
        "I come here to refill my watering can."
      ],
      group_forming: [
        "Should we start a community garden?",
        "Many hands make gardens grow!",
        "I can teach you all about composting!"
      ]
    },

    builder: {
      greeting_first: [
        "Greetings! I'm {name}, master builder. Always working on something new!",
        "Hello! Notice the archways? That's my work.",
        "Welcome! A builder's work is never done, but I love every moment."
      ],
      greeting_familiar: [
        "Back again? Good! I want your opinion on this design.",
        "Ah, perfect timing! Need an extra pair of hands.",
        "Good to see you! The foundation we discussed is complete."
      ],
      greeting_close: [
        "My friend! I've been sketching ideas all morning. Look!",
        "I knew you'd come! This project needs your creative eye.",
        "Finally! No one appreciates structure like you do."
      ],
      weather_rain: [
        "Rain delays construction, but gives time to plan.",
        "*covering materials* We'll resume when it clears.",
        "Indoor projects today, I think."
      ],
      weather_clear: [
        "Perfect building weather!",
        "Clear skies mean we can work on the roof.",
        "Foundation work requires dry ground. Excellent!"
      ],
      time_morning: [
        "Morning! Best light for measuring and cutting.",
        "Early start means more progress!",
        "*reviewing blueprints* Let's begin."
      ],
      time_evening: [
        "Golden hour is perfect for admiring finished work.",
        "One more stone before sunset...",
        "Time to clean the tools and plan tomorrow."
      ],
      player_building: [
        "Excellent work! May I suggest reinforcing that corner?",
        "A fellow builder! Your technique is impressive.",
        "Strong foundation! That will last generations.",
        "Mind if I watch? I always learn from others."
      ],
      working: [
        "*measuring twice, cutting once*",
        "*carefully placing stones*",
        "*testing structural integrity*",
        "*sketching improvements*"
      ],
      idle_observation: [
        "That column's proportions are perfect.",
        "I wonder if we could build a bridge there...",
        "Every structure tells the story of its builder.",
        "The ancient ruins inspire me. Such craftsmanship!"
      ],
      group_forming: [
        "A building project needs teamwork!",
        "Together we can create something magnificent!",
        "Let me show you all the proper techniques."
      ]
    },

    storyteller: {
      greeting_first: [
        "Ah, a new face! I'm {name}. Every person has a story worth telling.",
        "Welcome, traveler! Sit, and I'll share a tale.",
        "Greetings! I collect stories. Perhaps you have one to share?"
      ],
      greeting_familiar: [
        "Welcome back! Ready for another tale?",
        "Ah, you've returned! The story continues...",
        "My friend! I've learned a new legend since we last spoke."
      ],
      greeting_close: [
        "My dear friend! Your own story grows richer each day.",
        "I've been saving the best tales for your return!",
        "Sit close. This story is for you alone."
      ],
      weather_rain: [
        "Rain is perfect for storytelling by the fire.",
        "The patter of rain makes a nice backdrop for tales.",
        "Stormy weather brings stormy stories!"
      ],
      weather_clear: [
        "Perfect evening for tales under the stars.",
        "Clear skies, clear minds, clear stories.",
        "Sunshine inspires lighter tales."
      ],
      time_evening: [
        "Evening is when the best stories are told.",
        "Gather 'round! The shadows grow, and so do legends.",
        "*preparing to perform* The perfect hour for storytelling."
      ],
      time_night: [
        "By starlight, I'll tell you of ancient wonders...",
        "Night brings out the mysterious tales.",
        "The darkness makes every story more vivid."
      ],
      working: [
        "*gesturing dramatically*",
        "*voice rising and falling with emotion*",
        "*scribbling notes*",
        "*practicing delivery*"
      ],
      idle_observation: [
        "Every corner of ZION has a story.",
        "I wonder what tales these stones could tell...",
        "That merchant looks like they have stories from afar.",
        "History is all around us, waiting to be discovered."
      ],
      group_forming: [
        "Gather close! I have a tale for you all!",
        "Stories are best shared with many ears!",
        "Come, friends! Let me tell you of heroes past!"
      ]
    },

    merchant: {
      greeting_first: [
        "Welcome to my stall! I'm {name}. Best goods in ZION!",
        "Greetings, customer! See anything you like?",
        "Hello there! Fair prices and quality goods, guaranteed!"
      ],
      greeting_familiar: [
        "Ah, my returning customer! I have something special today.",
        "Welcome back! Your patronage is appreciated!",
        "Good to see you! I saved this item with you in mind."
      ],
      greeting_close: [
        "My valued friend! For you, a special discount.",
        "Excellent timing! I just received rare goods!",
        "My dear patron! Let me show you the finest selections."
      ],
      weather_rain: [
        "*covering goods* Quick, before they get wet!",
        "Rain is bad for business, good for discounts!",
        "Come inside my tent! Can't let merchandise get soaked."
      ],
      weather_clear: [
        "Perfect market day!",
        "Sunshine brings customers!",
        "Business is good when the weather cooperates!"
      ],
      time_morning: [
        "*setting up stall* Early bird gets the best deals!",
        "Morning! Fresh inventory just arrived!",
        "Opening for business! Come see!"
      ],
      time_midday: [
        "Busy market hour! Step right up!",
        "Peak time for trading!",
        "The Agora is alive with commerce!"
      ],
      time_evening: [
        "Last chance for today's deals!",
        "Closing soon, but still open for you!",
        "*packing up* Tomorrow I'll have even better goods!"
      ],
      working: [
        "*arranging wares attractively*",
        "*calculating prices*",
        "*polishing merchandise*",
        "*calling out to passersby*"
      ],
      idle_observation: [
        "I wonder what goods that traveler carries...",
        "Business is steady today.",
        "Quality over quantity, always.",
        "A merchant's eye never rests."
      ],
      group_forming: [
        "Fellow merchants! Let's discuss trade routes!",
        "Perhaps we could organize a market festival?",
        "The more merchants, the livelier the market!"
      ]
    },

    explorer: {
      greeting_first: [
        "Ho there! I'm {name}, explorer of ZION's wilds!",
        "Greetings, friend! Just returned from the frontier.",
        "Well met! These lands hold countless secrets."
      ],
      greeting_familiar: [
        "Back from your own explorations?",
        "Good to see you! I've mapped new territories!",
        "Ah! Want to hear about what I discovered?"
      ],
      greeting_close: [
        "My fellow adventurer! Let's explore together!",
        "I've been hoping you'd come! I found something amazing!",
        "Perfect! I need someone brave to witness this discovery."
      ],
      weather_rain: [
        "Rain won't stop an explorer!",
        "*pulling up hood* Weather adds to the adventure!",
        "Rain reveals hidden streams and paths."
      ],
      weather_snow: [
        "Snow makes tracking easier!",
        "Winter landscapes are breathtaking.",
        "The wilds are beautiful in every season."
      ],
      weather_clear: [
        "Perfect day for exploration!",
        "Clear weather means good visibility!",
        "I can see for miles today!"
      ],
      time_morning: [
        "Dawn is the best time to spot wildlife!",
        "*checking compass* Time to head out!",
        "Early start, more ground to cover!"
      ],
      working: [
        "*scanning the horizon*",
        "*making notes on a map*",
        "*examining interesting features*",
        "*testing the ground*"
      ],
      idle_observation: [
        "I wonder what's beyond those mountains...",
        "Every horizon calls to be explored.",
        "The frontier is never fully mapped.",
        "Adventure is everywhere if you look."
      ],
      group_forming: [
        "Expedition party forming! Who's brave enough?",
        "Safety in numbers when exploring!",
        "Let's chart the unknown together!"
      ]
    },

    teacher: {
      greeting_first: [
        "Welcome, student! I'm {name}. Knowledge is meant to be shared.",
        "Greetings! Always happy to see eager minds.",
        "Hello! What would you like to learn today?"
      ],
      greeting_familiar: [
        "My returning student! Ready for the next lesson?",
        "Excellent! Your progress has been remarkable.",
        "Welcome back! I've prepared advanced materials."
      ],
      greeting_close: [
        "My star pupil! You continue to impress me.",
        "I've been researching topics just for you!",
        "Your dedication to learning honors us both."
      ],
      weather_clear: [
        "Beautiful day for outdoor lessons!",
        "Clear minds match clear skies.",
        "Perfect weather for demonstrations!"
      ],
      time_morning: [
        "Morning minds are fresh and ready!",
        "Let's begin today's lesson.",
        "*preparing teaching materials* Good morning!"
      ],
      time_afternoon: [
        "Afternoon is perfect for practical exercises.",
        "Review time! Let's test what you've learned.",
        "Advanced topics require afternoon focus."
      ],
      working: [
        "*explaining with gestures*",
        "*writing on a tablet*",
        "*demonstrating technique*",
        "*patiently answering questions*"
      ],
      idle_observation: [
        "Every moment is a chance to learn.",
        "I should research that further...",
        "Knowledge builds upon knowledge.",
        "Teaching is the highest form of learning."
      ],
      group_forming: [
        "Class is in session! Gather around!",
        "The more students, the richer the discussion!",
        "Let's form a study circle!"
      ]
    },

    musician: {
      greeting_first: [
        "Hello! I'm {name}. Music is the soul of ZION!",
        "*strumming* Welcome, friend! Care for a tune?",
        "Greetings! The world is better with music."
      ],
      greeting_familiar: [
        "My audience returns! Requests?",
        "*playing a familiar melody* This one's for you!",
        "Welcome back! I've learned new songs!"
      ],
      greeting_close: [
        "My friend! Let's make music together!",
        "I composed something special for you!",
        "*starting your favorite song* I remember what you love."
      ],
      weather_rain: [
        "Rain has its own rhythm. Listen...",
        "Nature's percussion! *tapping along*",
        "*playing under shelter* Rain makes everything melancholy and beautiful."
      ],
      weather_clear: [
        "Perfect night for performance!",
        "Clear acoustics tonight!",
        "The stars will be my audience!"
      ],
      time_evening: [
        "Evening is when music truly shines!",
        "*tuning instrument* Almost time to perform!",
        "Gather 'round! Concert begins at sunset!"
      ],
      time_night: [
        "Night music has special magic.",
        "*playing softly* Lullabies for the world.",
        "The stars dance to midnight melodies."
      ],
      working: [
        "*playing a complex melody*",
        "*humming while composing*",
        "*adjusting instrument strings*",
        "*keeping rhythm*"
      ],
      idle_observation: [
        "I hear music in everything...",
        "That bird's song would make a lovely motif.",
        "The wind through the trees, nature's orchestra.",
        "Every sound is part of the symphony."
      ],
      group_forming: [
        "Musicians! Jam session time!",
        "Let's create harmony together!",
        "Audience gathering! Time to perform!"
      ]
    },

    healer: {
      greeting_first: [
        "Welcome, child. I'm {name}. Are you well?",
        "Greetings, friend. Peace and health to you.",
        "Hello! I'm here if you need healing or herbs."
      ],
      greeting_familiar: [
        "Good to see you healthy and strong!",
        "Welcome back! How are you feeling?",
        "Ah, your energy looks much better!"
      ],
      greeting_close: [
        "My dear friend, you bring light with you.",
        "I'm always happy to see your face.",
        "Come, sit. Let's talk and restore spirits."
      ],
      weather_rain: [
        "Rain cleanses and renews.",
        "Good weather for gathering medicinal mushrooms!",
        "The earth drinks, and we all benefit."
      ],
      weather_clear: [
        "Sunshine is the best medicine.",
        "Perfect day for herb drying!",
        "Clear weather, clear health."
      ],
      time_morning: [
        "Morning energy is vital and strong.",
        "*gathering herbs* Dawn dew enhances potency.",
        "Begin the day with wellness."
      ],
      working: [
        "*grinding herbs gently*",
        "*meditating quietly*",
        "*examining plants carefully*",
        "*offering soothing words*"
      ],
      idle_observation: [
        "Balance is the key to health.",
        "Every plant has healing properties.",
        "The body knows how to heal itself.",
        "Wellness is a journey, not a destination."
      ],
      group_forming: [
        "Gather, friends. Let's share wellness practices.",
        "Healing circles amplify positive energy!",
        "Together we can create community health."
      ]
    },

    philosopher: {
      greeting_first: [
        "Greetings, seeker. I'm {name}. What questions trouble your mind?",
        "Welcome! I ponder the great mysteries here.",
        "Hello, friend. Care to contemplate existence?"
      ],
      greeting_familiar: [
        "Ah, you return! Have you been thinking about our discussion?",
        "Welcome back! I've had new insights.",
        "Good to see you! Ready for deeper questions?"
      ],
      greeting_close: [
        "My fellow thinker! Let's unravel mysteries together!",
        "I've been eager to hear your perspective!",
        "Two minds together see truths one alone cannot."
      ],
      weather_rain: [
        "Rain reminds us that change is constant.",
        "Each drop is unique, yet all are water. Curious.",
        "What is rain but the sky thinking aloud?"
      ],
      weather_clear: [
        "Clarity without matches clarity within.",
        "The cosmos reveals itself on clear nights.",
        "In clear skies, we see infinity."
      ],
      time_evening: [
        "Evening brings contemplative moods.",
        "As the sun sets, different truths emerge.",
        "*watching sunset* Transitions teach us much."
      ],
      time_night: [
        "Under stars, we remember how small we are.",
        "*stargazing* Each light is a sun with its own worlds...",
        "Night questions are the deepest questions."
      ],
      working: [
        "*sitting in deep thought*",
        "*sketching cosmic diagrams*",
        "*debating with self*",
        "*observing patterns*"
      ],
      idle_observation: [
        "Why does anything exist rather than nothing?",
        "Patterns repeat at every scale...",
        "What is consciousness but the universe observing itself?",
        "Every answer births new questions."
      ],
      group_forming: [
        "Let's form a discourse circle!",
        "Many perspectives illuminate truth!",
        "Philosophy thrives in dialogue!"
      ]
    },

    artist: {
      greeting_first: [
        "Hello! I'm {name}. I try to capture ZION's beauty.",
        "Welcome! An artist's work is never done.",
        "Greetings! Every vista here inspires creation."
      ],
      greeting_familiar: [
        "Back to see the progress?",
        "Your visits always bring fresh perspective!",
        "Ah! I value your aesthetic sense!"
      ],
      greeting_close: [
        "My muse has returned!",
        "I've created something I need you to see!",
        "Your appreciation means everything to me."
      ],
      weather_rain: [
        "Rain creates such interesting textures!",
        "*capturing the mood* Melancholy is beautiful too.",
        "The colors deepen in rain. Magnificent!"
      ],
      weather_snow: [
        "Winter palettes are subtle and profound.",
        "*working quickly* Snow won't last, must capture it!",
        "White on white, infinite shades..."
      ],
      weather_clear: [
        "Perfect light for painting!",
        "The colors are so vibrant today!",
        "Clear skies show every hue."
      ],
      time_morning: [
        "Morning light is soft and golden.",
        "*sketching quickly* Dawn never lasts long enough!",
        "The world is fresh and new each morning."
      ],
      time_evening: [
        "Golden hour! Every artist's favorite time!",
        "*painting frantically* The colors! The colors!",
        "Sunset is fleeting. Must work fast."
      ],
      working: [
        "*applying paint with care*",
        "*stepping back to assess*",
        "*mixing colors thoughtfully*",
        "*lost in creative flow*"
      ],
      idle_observation: [
        "Beauty is everywhere, if you look.",
        "That composition is perfect...",
        "Color, light, form... all dancing together.",
        "Art is seeing what others overlook."
      ],
      group_forming: [
        "Artists! Let's share techniques!",
        "Every artist sees differently. Let's compare!",
        "Collective creativity sparks innovation!"
      ]
    }
  };

  var ZONE_DIALOGUES = {
    nexus: [
      "The Nexus hums with energy today.",
      "Everyone passes through here eventually.",
      "The heart of ZION beats strong.",
      "New faces arrive every day. The world grows.",
      "I love the way all paths converge here."
    ],
    gardens: [
      "The gardens are especially beautiful today.",
      "Can you smell the jasmine? Heavenly.",
      "Everything grows so well here.",
      "The gardeners have been busy. Look at those blooms!",
      "I always feel peaceful in the gardens."
    ],
    wilds: [
      "Stay alert out here. The wilds are unpredictable.",
      "I've heard there are rare plants deep in these woods.",
      "The frontier calls to the adventurous.",
      "Few venture this far. You're brave.",
      "The wilds hold secrets waiting to be found."
    ],
    athenaeum: [
      "Knowledge fills these halls.",
      "The scrolls here contain ancient wisdom.",
      "Quiet, please. Some are studying.",
      "Have you read the founding texts? Fascinating.",
      "Learning never ends in the Athenaeum."
    ],
    studio: [
      "Creativity fills the air here.",
      "I love watching the artists at work.",
      "The Studio inspires everyone who enters.",
      "Art gives meaning to our world.",
      "Have you seen the latest sculptures?"
    ],
    agora: [
      "The market is bustling today!",
      "Good deals to be found if you look.",
      "The Agora never sleeps.",
      "Trade is the lifeblood of any community.",
      "I heard a merchant just got rare goods."
    ],
    commons: [
      "The Commons feel like home.",
      "Community is what we build here.",
      "I love what everyone has contributed.",
      "The workshops are always busy.",
      "Building together is building forever."
    ],
    arena: [
      "The Arena pulses with competitive spirit!",
      "Friendly competition makes us all stronger.",
      "Champions are made here!",
      "The crowd's energy is incredible.",
      "May the best challenger win!"
    ]
  };

  var ARCHETYPE_REACTIONS = {
    gardener: {
      musician: "Your music makes my flowers bloom brighter!",
      builder: "Could you build a trellis for my vines?",
      healer: "I have herbs that might help your remedies.",
      artist: "Please paint my garden someday!",
      merchant: "I have fresh produce for your stall.",
      storyteller: "The oldest oak has stories to tell...",
      explorer: "Did you find any rare seeds on your travels?",
      teacher: "Will you teach the children about botany?",
      philosopher: "What do you think plants dream about?"
    },
    builder: {
      gardener: "Plant something by my new building?",
      musician: "I need good acoustics in this hall I'm building.",
      healer: "I'm building a new healing pavilion.",
      artist: "Want to design the facade?",
      merchant: "I need materials. What do you have?",
      storyteller: "This wall needs an engraved legend.",
      explorer: "Found any interesting stone quarries?",
      teacher: "I could build a lecture hall for you.",
      philosopher: "Is the perfect building possible?"
    },
    storyteller: {
      gardener: "Tell me the legend of the first seed.",
      musician: "Would you accompany my tale with music?",
      builder: "Every building you make is a story in stone.",
      healer: "Healing stories are the most powerful.",
      artist: "Illustrate my latest tale?",
      merchant: "Stories from distant lands to trade?",
      explorer: "You must have incredible tales to share!",
      teacher: "Let's teach through storytelling!",
      philosopher: "What is truth in a story?"
    },
    merchant: {
      gardener: "Fresh flowers always sell well.",
      musician: "You draw crowds! Set up near my stall?",
      builder: "I have timber and nails you'll need.",
      healer: "Healing potions sell for good Spark!",
      artist: "Your art would fetch a premium.",
      storyteller: "Stories attract customers. Perfect partnership!",
      explorer: "Bring me exotic goods from your travels!",
      teacher: "Education about quality helps sales.",
      philosopher: "What is the true value of Spark?"
    },
    explorer: {
      gardener: "I found strange plants in the deep wilds!",
      musician: "The acoustics in that cave were amazing.",
      builder: "There are ancient ruins to the north!",
      healer: "I found rare medicinal moss on the cliff face.",
      artist: "The vista from the eastern ridge is breathtaking.",
      storyteller: "I discovered something the legends speak of!",
      merchant: "I've got rare finds from the frontier.",
      teacher: "The wilds teach lessons no book can.",
      philosopher: "Exploration is philosophy in motion."
    },
    teacher: {
      gardener: "Botany class begins with your garden.",
      musician: "Music theory is fascinating, isn't it?",
      builder: "Architecture has much to teach us.",
      healer: "Medical knowledge saves lives.",
      artist: "Art history is endlessly rich.",
      storyteller: "Oral tradition preserves culture.",
      merchant: "Economics drives civilization.",
      explorer: "Geography shapes destiny.",
      philosopher: "Every discipline leads to the same questions."
    },
    musician: {
      gardener: "Your garden hums with lifeâ€”I'll write it a song!",
      builder: "The rhythm of your hammer inspires me.",
      healer: "Healing harmonics are real. I've studied them.",
      artist: "Music and artâ€”the twin souls of creation.",
      storyteller: "Let me compose a soundtrack for your tale!",
      merchant: "I'll play for customers if you share the Spark!",
      explorer: "Every land has its own song waiting to be heard.",
      teacher: "Music is the universal language, yes?",
      philosopher: "What is sound, really, but structured silence?"
    },
    healer: {
      gardener: "Your herbs are essential to my practice.",
      musician: "Music heals wounds no salve can reach.",
      builder: "A healthy body builds a strong world.",
      artist: "Beauty is healing in visual form.",
      storyteller: "Stories can heal the soul.",
      merchant: "I need suppliesâ€”got any healing crystals?",
      explorer: "Stay safe out there. I'll be here if you're hurt.",
      teacher: "Prevention is the best medicine.",
      philosopher: "What does it mean to be truly well?"
    },
    philosopher: {
      gardener: "Growth is the fundamental urge of all things.",
      musician: "If music is math made beautiful, what is beauty?",
      builder: "We build to defy entropy. A noble endeavor.",
      healer: "Is perfect health the absence of illness, or something more?",
      artist: "Does art reveal truth or create it?",
      storyteller: "Stories shape how we see reality itself.",
      merchant: "Value is a collective hallucination, isn't it?",
      explorer: "The greatest journey is inward.",
      teacher: "Can we truly teach, or merely point the way?"
    },
    artist: {
      gardener: "Nature is the greatest artist.",
      musician: "Our arts are siblingsâ€”let's collaborate!",
      builder: "Architecture is art that shelters.",
      healer: "I want to paint the act of healing.",
      storyteller: "Every story paints pictures in the mind.",
      merchant: "Does commerce diminish art or elevate it?",
      explorer: "The landscapes you describeâ€”I must see them!",
      teacher: "Teach me that technique you mentioned.",
      philosopher: "Art is philosophy made visible."
    }
  };

  var QUEST_HOOKS = {
    gardener: [
      "I could use help gathering sunflowers for the festival...",
      "The moonflower seeds need planting. Know anyone interested?",
      "A rare bloom was spotted in the Wilds. I wish I could go look...",
      "My herb garden needs tending while I research new species."
    ],
    builder: [
      "The bridge near the commons needs repair. Volunteers?",
      "I'm designing a new gazebo but need special stone...",
      "Someone left materials scattered at the construction site.",
      "The old tower could use reinforcement. Big project, good Spark."
    ],
    storyteller: [
      "I'm collecting tales from each zone. Want to help gather them?",
      "A lost manuscript was last seen in the Athenaeum depths...",
      "The founding stories are fading from memory. Help preserve them?",
      "I need someone to interview the elder NPCs for my chronicle."
    ],
    merchant: [
      "I'm missing a delivery from the gardens. Could you check?",
      "A rare gem went missing from my inventory...",
      "I need someone to scout prices in the other zones.",
      "Big trade deal coming up. I need rare materials."
    ],
    explorer: [
      "There's an unmapped cave system I've been wanting to explore.",
      "Strange lights in the wilds at nightâ€”want to investigate?",
      "The ancient markers near the arena need documenting.",
      "I found tracks of something unusual. Help me follow them?"
    ],
    teacher: [
      "I need specimens from each zone for my natural history class.",
      "Can you deliver these lesson scrolls to students in the commons?",
      "My research requires a crystal from the studio caves.",
      "Help me set up the outdoor classroom by the gardens."
    ],
    musician: [
      "I'm organizing a concert but need instruments gathered.",
      "The acoustics stone in the arena was chipped. Find a replacement?",
      "I hear the wilds have singing crystals. Bring me one!",
      "Help me spread word of tonight's performance to all zones."
    ],
    healer: [
      "I'm running low on moonpetal herbs. The gardens might have some.",
      "A traveler fell illâ€”I need crystal dust from the studio.",
      "Help me set up healing stations across the zones.",
      "Rare medicinal moss grows on the arena stones. Can you gather some?"
    ],
    philosopher: [
      "Debate me on the nature of ZION. I'll reward good arguments!",
      "Find the three wisdom stones hidden across the zones.",
      "Carry this sealed question to the storyteller and bring back the answer.",
      "I seek the meaning of the ancient symbols on the obelisk."
    ],
    artist: [
      "I need pigments from rare flowers in the gardens.",
      "Inspiration! Go sketch the view from three different zones.",
      "The mural in the commons needs restoration help.",
      "Find the legendary canvas stone in the wilds for me."
    ]
  };

  var MOODS = ['content', 'excited', 'contemplative', 'social', 'tired', 'focused', 'curious', 'peaceful'];

  function calculateMood(memory, perception, timeOfDay) {
    var energy = memory.energy || 100;
    var schedule = getSchedulePeriod(perception.timeOfDay);
    var recentSocial = memory.interactions.filter(function(i) {
      return Date.now() - i.timestamp < 300000; // Last 5 minutes
    }).length;

    if (energy < 30) return 'tired';

    if (schedule.social_chance > 0.7 && recentSocial > 0) return 'social';

    var recentExciting = memory.witnessedEvents.filter(function(e) {
      return e.type === 'portal_activation' || e.type === 'group_forming';
    }).length > 0;
    if (recentExciting) return 'excited';

    if ((timeOfDay === 'evening' || timeOfDay === 'night') &&
        (memory.archetype === 'philosopher' || memory.archetype === 'artist')) {
      return 'contemplative';
    }

    if (schedule.work_priority > 0.7) return 'focused';

    if (memory.archetype === 'explorer' || perception.recentEvents.some(function(e) {
      return e.type === 'new_discovery';
    })) {
      return 'curious';
    }

    if (perception.currentZone === 'gardens' || perception.nearWater) {
      return 'peaceful';
    }

    return 'content';
  }

  function perceive(npc, worldState) {
    var perception = {
      nearbyPlayers: [],
      nearbyNPCs: [],
      weather: worldState.weather || 'clear',
      timeOfDay: worldState.timeOfDay || 'midday',
      currentZone: worldState.currentZone || 'agora',
      recentEvents: worldState.recentEvents || [],
      threats: [],
      nearWater: worldState.nearWater || false,
      inShelter: worldState.inShelter || false,
      groupsForming: [],
      interestingObjects: []
    };

    if (worldState.players) {
      worldState.players.forEach(function(player) {
        var dx = player.x - npc.x;
        var dz = player.z - npc.z;
        var distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= PERCEPTION_RADIUS) {
          perception.nearbyPlayers.push({
            id: player.id,
            distance: distance,
            direction: { x: dx, z: dz },
            lastAction: player.lastAction,
            isBuilding: player.isBuilding,
            isHarvesting: player.isHarvesting
          });
        }
      });
    }

    if (worldState.npcs) {
      worldState.npcs.forEach(function(otherNpc) {
        if (otherNpc.id === npc.id) return;

        var dx = otherNpc.x - npc.x;
        var dz = otherNpc.z - npc.z;
        var distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= PERCEPTION_RADIUS) {
          perception.nearbyNPCs.push({
            id: otherNpc.id,
            distance: distance,
            direction: { x: dx, z: dz },
            archetype: otherNpc.archetype,
            currentActivity: otherNpc.currentActivity,
            mood: otherNpc.mood
          });
        }
      });
    }

    var npcClusters = {};
    perception.nearbyNPCs.forEach(function(nearby) {
      if (nearby.distance <= GROUP_FORMATION_RADIUS) {
        var key = Math.floor(nearby.direction.x / 5) + '_' + Math.floor(nearby.direction.z / 5);
        if (!npcClusters[key]) npcClusters[key] = [];
        npcClusters[key].push(nearby);
      }
    });

    Object.keys(npcClusters).forEach(function(key) {
      if (npcClusters[key].length >= 2) {
        perception.groupsForming.push({
          members: npcClusters[key],
          location: key,
          size: npcClusters[key].length
        });
      }
    });

    return perception;
  }

  function createMemory(archetype) {
    return {
      archetype: archetype,
      interactions: [],
      favorites: {
        location: null,
        npcFriends: []
      },
      playerFamiliarity: {},
      witnessedEvents: [],
      lastGreeted: {},
      usedDialogues: [],
      mood: 'content',
      energy: 100,
      satisfaction: 50,
      lastWorkTime: 0,
      lastRestTime: 0,
      currentGoal: null,
      groupMembership: null
    };
  }

  function updateMemory(memory, deltaTime) {
    Object.keys(memory.playerFamiliarity).forEach(function(playerId) {
      memory.playerFamiliarity[playerId] -= MEMORY_DECAY_RATE * deltaTime;
      if (memory.playerFamiliarity[playerId] <= 0) {
        delete memory.playerFamiliarity[playerId];
      }
    });

    var schedule = getSchedulePeriod(memory.currentTimeOfDay || 'midday');
    if (schedule.energy_regen > 0) {
      memory.energy = Math.min(100, memory.energy + ENERGY_REGEN_RATE * (deltaTime / 60000));
    } else {
      memory.energy = Math.max(0, memory.energy - ENERGY_DECAY_RATE * (deltaTime / 60000));
    }

    if (memory.interactions.length > MAX_INTERACTIONS_REMEMBERED) {
      memory.interactions = memory.interactions.slice(-MAX_INTERACTIONS_REMEMBERED);
    }

    if (memory.witnessedEvents.length > MAX_EVENTS_REMEMBERED) {
      memory.witnessedEvents = memory.witnessedEvents.slice(-MAX_EVENTS_REMEMBERED);
    }

    if (!memory.lastDialogueReset || Date.now() - memory.lastDialogueReset > 300000) {
      memory.usedDialogues = [];
      memory.lastDialogueReset = Date.now();
    }
  }

  function recordInteraction(memory, playerId, type, response) {
    memory.interactions.push({
      playerId: playerId,
      type: type,
      timestamp: Date.now(),
      response: response
    });

    if (!memory.playerFamiliarity[playerId]) {
      memory.playerFamiliarity[playerId] = 0;
    }
    memory.playerFamiliarity[playerId] += FAMILIARITY_GAIN;
  }

  function recordEvent(memory, eventType, description) {
    memory.witnessedEvents.push({
      type: eventType,
      description: description,
      timestamp: Date.now()
    });
  }

  function getSchedulePeriod(timeOfDay) {
    return DAILY_SCHEDULE[timeOfDay] || DAILY_SCHEDULE.midday;
  }

  function getCurrentHour(worldState) {
    return worldState.currentHour || 12;
  }

  var dialogue = (typeof NpcDialogue !== 'undefined') ? NpcDialogue : null;

  var CATEGORY_TO_DIALOGUE_TYPE = {
    greeting_first:     'greeting',
    greeting_familiar:  'greeting',
    greeting_close:     'greeting',
    weather_rain:       'weather',
    weather_snow:       'weather',
    weather_clear:      'weather',
    time_morning:       'idle_chat',
    time_evening:       'idle_chat',
    time_night:         'idle_chat',
    player_building:    'craft',
    player_harvesting:  'craft',
    working:            'craft',
    idle_observation:   'idle_chat',
    near_water:         'zone_comment',
    group_forming:      'idle_chat',
    zone_observation:   'zone_comment',
    quest_hook:         'idle_chat',
    archetype_reaction: 'idle_chat'
  };

  function buildDialogueContext(memory, context, perception) {
    var categoryKey = (context && context.category) || 'idle_observation';
    var contextType = CATEGORY_TO_DIALOGUE_TYPE[categoryKey] || 'idle_chat';

    if (categoryKey === 'weather_rain' || categoryKey === 'weather_snow' || categoryKey === 'weather_clear') {
      contextType = 'weather';
    }
    if (categoryKey.indexOf('greeting') === 0) {
      contextType = 'greeting';
    }

    var dlgContext = {
      type: contextType,
      zone: (context && context.zone) || (perception && perception.currentZone) || 'nexus',
      timeOfDay: (perception && perception.timeOfDay) || 'daytime',
      weather: (perception && perception.weather) || 'clear',
      currentActivity: (memory && memory.currentGoal && memory.currentGoal.type) || 'wandering',
      nearbyPlayers: [],
      recentChat: []
    };

    return dlgContext;
  }

  function getDialogue(memory, context, npcName) {
    var archetype = memory.archetype;
    var categoryKey = context.category || 'idle_observation';

    if (!dialogue && typeof NpcDialogue !== 'undefined') {
      dialogue = NpcDialogue;
    }

    if (dialogue && dialogue.getFallback) {
      var npcObj = { archetype: archetype, name: npcName };
      var dlgCtx = buildDialogueContext(memory, context, null);
      var dlgResult = dialogue.getFallback(npcObj, dlgCtx);
      if (dlgResult) {
        if (!memory.usedDialogues) memory.usedDialogues = [];
        var lastUsed = memory.usedDialogues[memory.usedDialogues.length - 1];
        if (lastUsed !== dlgResult) {
          memory.usedDialogues.push(dlgResult);
          if (memory.usedDialogues.length > 20) {
            memory.usedDialogues = memory.usedDialogues.slice(-20);
          }
          return dlgResult;
        }
      }
    }

    if (categoryKey === 'archetype_reaction') {
      var reactions = ARCHETYPE_REACTIONS[archetype];
      if (reactions && context.targetArchetype && reactions[context.targetArchetype]) {
        var reactionText = reactions[context.targetArchetype];
        return reactionText.replace('{name}', npcName);
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    if (categoryKey === 'zone_observation') {
      var zoneDlgs = ZONE_DIALOGUES[context.zone];
      if (zoneDlgs && zoneDlgs.length > 0) {
        return zoneDlgs[Math.floor(Math.random() * zoneDlgs.length)];
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    if (categoryKey === 'quest_hook') {
      var hooks = QUEST_HOOKS[archetype];
      if (hooks && hooks.length > 0) {
        return hooks[Math.floor(Math.random() * hooks.length)];
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    var dialogues = CONTEXTUAL_DIALOGUES[archetype];
    if (!dialogues) return null;

    var category = dialogues[categoryKey];
    if (!category || category.length === 0) {
      category = dialogues.idle_observation || [];
    }

    if (category.length === 0) return null;

    var availableDialogues = category.filter(function(_, index) {
      return memory.usedDialogues.indexOf(categoryKey + '_' + index) === -1;
    });

    if (availableDialogues.length === 0) {
      availableDialogues = category; // Reset if all used
      memory.usedDialogues = [];
    }

    var pickedDialogue = availableDialogues[Math.floor(Math.random() * availableDialogues.length)];
    var index = category.indexOf(pickedDialogue);
    memory.usedDialogues.push(categoryKey + '_' + index);

    pickedDialogue = pickedDialogue.replace('{name}', npcName);
    pickedDialogue = pickedDialogue.replace('{plant}', ['roses', 'lilies', 'moonflowers', 'sage'][Math.floor(Math.random() * 4)]);

    return pickedDialogue;
  }

  function getDialogueContext(memory, perception, npc) {
    var playerId = perception.nearbyPlayers.length > 0 ? perception.nearbyPlayers[0].id : null;
    var familiarity = playerId ? (memory.playerFamiliarity[playerId] || 0) : 0;

    if (playerId && !memory.lastGreeted[playerId]) {
      return { category: 'greeting_first' };
    } else if (familiarity >= FAMILIARITY_THRESHOLD_CLOSE) {
      return { category: 'greeting_close' };
    } else if (familiarity >= FAMILIARITY_THRESHOLD_FRIENDLY) {
      return { category: 'greeting_familiar' };
    }

    if (perception.weather === 'rain') {
      return { category: 'weather_rain' };
    } else if (perception.weather === 'snow') {
      return { category: 'weather_snow' };
    } else if (perception.weather === 'clear') {
      return { category: 'weather_clear' };
    }

    if (perception.timeOfDay === 'morning' || perception.timeOfDay === 'dawn') {
      return { category: 'time_morning' };
    } else if (perception.timeOfDay === 'evening') {
      return { category: 'time_evening' };
    } else if (perception.timeOfDay === 'night') {
      return { category: 'time_night' };
    }

    if (perception.nearbyPlayers.length > 0) {
      var player = perception.nearbyPlayers[0];
      if (player.isBuilding) {
        return { category: 'player_building' };
      } else if (player.isHarvesting) {
        return { category: 'player_harvesting' };
      }
    }

    if (perception.nearbyNPCs.length > 0 && Math.random() < 0.25) {
      var nearbyNpc = perception.nearbyNPCs[0];
      if (nearbyNpc.archetype && nearbyNpc.archetype !== memory.archetype) {
        return { category: 'archetype_reaction', targetArchetype: nearbyNpc.archetype };
      }
    }

    if (perception.currentZone && Math.random() < 0.3) {
      return { category: 'zone_observation', zone: perception.currentZone };
    }

    if (Math.random() < 0.08) {
      return { category: 'quest_hook' };
    }

    if (perception.nearWater) {
      return { category: 'near_water' };
    }

    if (perception.groupsForming.length > 0) {
      return { category: 'group_forming' };
    }

    if (memory.currentGoal && memory.currentGoal.type === 'work') {
      return { category: 'working' };
    }

    return { category: 'idle_observation' };
  }

  function evaluateBehaviorTree(npc, memory, perception) {
    var drives = ARCHETYPE_DRIVES[memory.archetype];
    var schedule = getSchedulePeriod(perception.timeOfDay);
    var now = Date.now();

    if ((perception.weather === 'storm' || perception.weather === 'rain') &&
        !perception.inShelter &&
        drives.weather_preference !== 'rain' &&
        drives.weather_preference !== 'any') {
      return {
        type: 'seek_shelter',
        priority: 10,
        animation: 'walk',
        speed: 2.0
      };
    }

    if (memory.energy < 20) {
      return {
        type: 'rest',
        priority: 9,
        animation: 'sit',
        speed: 0
      };
    }

    if ((perception.timeOfDay === 'night' || perception.timeOfDay === 'dawn') &&
        memory.energy < 60 &&
        memory.archetype !== 'philosopher' &&
        memory.archetype !== 'musician') {
      return {
        type: 'rest',
        priority: 8,
        animation: 'sleep',
        speed: 0
      };
    }

    if (perception.nearbyPlayers.length > 0) {
      var closestPlayer = perception.nearbyPlayers[0];
      if (closestPlayer.distance < 5) {
        var lastGreetTime = memory.lastGreeted[closestPlayer.id];
        if (!lastGreetTime || now - lastGreetTime > INTERACTION_COOLDOWN) {
          memory.lastGreeted[closestPlayer.id] = now;
          var context = getDialogueContext(memory, perception, npc);
          var greetDialogue = getDialogue(memory, context, npc.name);
          recordInteraction(memory, closestPlayer.id, 'greeting', greetDialogue);

          return {
            type: 'greet',
            targetPlayer: closestPlayer.id,
            priority: 7,
            animation: 'wave',
            dialogue: greetDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
      }

      if (closestPlayer.distance < 10) {
        if (closestPlayer.isBuilding && memory.archetype === 'builder') {
          var buildDialogue = getDialogue(memory, { category: 'player_building' }, npc.name);
          return {
            type: 'react',
            priority: 6,
            animation: 'observe',
            dialogue: buildDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
        if (closestPlayer.isHarvesting && memory.archetype === 'gardener') {
          var harvestDialogue = getDialogue(memory, { category: 'player_harvesting' }, npc.name);
          return {
            type: 'react',
            priority: 6,
            animation: 'observe',
            dialogue: harvestDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
      }
    }

    if (perception.groupsForming.length > 0 && Math.random() < schedule.social_chance) {
      var group = perception.groupsForming[0];
      var shouldJoin = false;

      if (memory.archetype === 'musician') {
        shouldJoin = group.members.some(function(m) { return m.archetype === 'musician'; });
      }
      if (memory.archetype === 'storyteller') {
        shouldJoin = group.size >= 2;
      }
      if (memory.archetype === 'teacher' || memory.archetype === 'merchant' || memory.archetype === 'philosopher') {
        shouldJoin = Math.random() < 0.6;
      }

      if (shouldJoin) {
        var groupDialogue = getDialogue(memory, { category: 'group_forming' }, npc.name);
        return {
          type: 'join_group',
          groupId: group.location,
          priority: 6,
          animation: 'walk',
          dialogue: groupDialogue,
          speed: 1.5
        };
      }
    }

    if (memory.mood === 'social' || (Math.random() < schedule.social_chance && memory.energy > 40)) {
      if (memory.favorites.npcFriends.length > 0) {
        var friendId = memory.favorites.npcFriends[0];
        var friendNearby = perception.nearbyNPCs.find(function(n) { return n.id === friendId; });

        if (friendNearby && friendNearby.distance < 8) {
          return {
            type: 'socialize',
            targetNPC: friendId,
            priority: 5,
            animation: 'talk',
            dialogue: getDialogue(memory, { category: 'greeting_familiar' }, npc.name),
            facing: { x: npc.x + friendNearby.direction.x, z: npc.z + friendNearby.direction.z },
            speed: 0
          };
        }
      }

      if (perception.nearbyNPCs.length > 0) {
        var nearbyNpc = perception.nearbyNPCs[0];
        if (nearbyNpc.distance < 12 && Math.random() < 0.4) {
          if (memory.favorites.npcFriends.indexOf(nearbyNpc.id) === -1) {
            memory.favorites.npcFriends.push(nearbyNpc.id);
          }

          var collab = getCollaborativeActivity(memory.archetype, nearbyNpc.archetype);
          if (collab && nearbyNpc.distance < 6) {
            return {
              type: 'collaborate',
              targetNPC: nearbyNpc.id,
              activityDesc: collab.description,
              priority: 5,
              animation: collab.animation,
              dialogue: getDialogue(memory, { category: 'archetype_reaction', targetArchetype: nearbyNpc.archetype }, npc.name),
              facing: { x: npc.x + nearbyNpc.direction.x, z: npc.z + nearbyNpc.direction.z },
              speed: 0
            };
          }

          return {
            type: 'approach_social',
            target: { x: npc.x + nearbyNpc.direction.x * 0.7, z: npc.z + nearbyNpc.direction.z * 0.7 },
            targetNPC: nearbyNpc.id,
            priority: 4,
            animation: 'walk',
            speed: 1.0
          };
        }
      }

      applyEmotionalContagion(memory, perception.nearbyNPCs);
    }

    if (schedule.work_priority > 0.5 && memory.energy > 30) {
      var workSatisfied = memory.satisfaction > 70 || (now - memory.lastWorkTime < 180000); // Last 3 min

      if (!workSatisfied) {
        memory.lastWorkTime = now;
        memory.satisfaction += WORK_SATISFACTION_GAIN;

        var workAction = getPrimaryWorkAction(memory.archetype, npc, perception);
        workAction.priority = 4;
        return workAction;
      }
    }

    if (memory.satisfaction > 50 && memory.energy > 50) {
      var secondaryAction = getSecondaryWorkAction(memory.archetype, npc, perception);
      secondaryAction.priority = 3;
      return secondaryAction;
    }

    var idleDialogue = getDialogue(memory, { category: 'idle_observation' }, npc.name);

    if (Math.random() < 0.3) {
      if (perception.currentZone && Math.random() < 0.6) {
        var poi = getPointOfInterest(perception.currentZone, memory.archetype);
        if (poi) {
          var poiDist = Math.sqrt(Math.pow(poi.x - npc.x, 2) + Math.pow(poi.z - npc.z, 2));
          if (poiDist > 3 && poiDist < 60) {
            return {
              type: 'walk_to',
              target: { x: poi.x, z: poi.z },
              poiName: poi.name,
              priority: 2,
              animation: 'walk',
              dialogue: Math.random() < 0.15 ? idleDialogue : null,
              speed: 1.0
            };
          }
        }
      }

      var wanderAngle = Math.random() * Math.PI * 2;
      var wanderDist = 5 + Math.random() * 10;
      return {
        type: 'wander',
        target: {
          x: npc.x + Math.cos(wanderAngle) * wanderDist,
          z: npc.z + Math.sin(wanderAngle) * wanderDist
        },
        priority: 2,
        animation: 'walk',
        dialogue: Math.random() < 0.1 ? idleDialogue : null,
        speed: 0.8
      };
    }

    if (perception.nearbyNPCs.length > 0 && Math.random() < 0.05) {
      var gossip = generateGossip(memory, npc.name);
      if (gossip) {
        return {
          type: 'socialize',
          targetNPC: perception.nearbyNPCs[0].id,
          priority: 2,
          animation: 'talk',
          dialogue: gossip,
          speed: 0
        };
      }
    }

    return {
      type: 'idle',
      priority: 1,
      animation: 'idle',
      dialogue: Math.random() < 0.05 ? idleDialogue : null,
      speed: 0
    };
  }

  function getPrimaryWorkAction(archetype, npc, perception) {
    var drives = ARCHETYPE_DRIVES[archetype];

    switch (drives.primary) {
      case 'tend_plants':
        return {
          type: 'work',
          animation: 'gardening',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'inspect_structures':
        return {
          type: 'work',
          animation: 'building',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'visit_athenaeum':
        return {
          type: 'walk_to',
          target: { x: 0, z: 0 }, // Athenaeum location
          animation: 'walk',
          speed: 1.2
        };

      case 'tend_shop':
        return {
          type: 'work',
          animation: 'merchant',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'explore_wilds':
        var exploreAngle = Math.random() * Math.PI * 2;
        return {
          type: 'walk_to',
          target: {
            x: npc.x + Math.cos(exploreAngle) * 30,
            z: npc.z + Math.sin(exploreAngle) * 30
          },
          animation: 'walk',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 1.5
        };

      case 'teach_lesson':
        return {
          type: 'work',
          animation: 'teaching',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'perform':
        return {
          type: 'work',
          animation: 'playing_music',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'tend_wounded':
        return {
          type: 'work',
          animation: 'healing',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'contemplate':
        return {
          type: 'work',
          animation: 'sitting',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'create_art':
        return {
          type: 'work',
          animation: 'painting',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      default:
        return {
          type: 'idle',
          animation: 'idle',
          speed: 0
        };
    }
  }

  function getSecondaryWorkAction(archetype, npc, perception) {
    var drives = ARCHETYPE_DRIVES[archetype];

    switch (drives.secondary) {
      case 'explore_flora':
      case 'map_territory':
      case 'find_inspiration':
        var exploreAngle = Math.random() * Math.PI * 2;
        return {
          type: 'explore',
          target: {
            x: npc.x + Math.cos(exploreAngle) * 20,
            z: npc.z + Math.sin(exploreAngle) * 20
          },
          animation: 'walk',
          speed: 1.0
        };

      case 'gather_materials':
      case 'gather_herbs':
      case 'acquire_goods':
        return {
          type: 'gather',
          animation: 'harvesting',
          speed: 0
        };

      case 'collect_stories':
      case 'research':
        return {
          type: 'research',
          animation: 'reading',
          speed: 0
        };

      case 'compose':
        return {
          type: 'compose',
          animation: 'writing',
          speed: 0
        };

      case 'debate':
        return {
          type: 'debate',
          animation: 'gesturing',
          speed: 0
        };

      default:
        return {
          type: 'idle',
          animation: 'idle',
          speed: 0
        };
    }
  }

  function handleEvent(memory, event) {
    recordEvent(memory, event.type, event.description);

    if (event.type === 'weather_change') {
      var drives = ARCHETYPE_DRIVES[memory.archetype];
      if (event.weather === drives.weather_preference) {
        memory.mood = 'excited';
        memory.energy = Math.min(100, memory.energy + 10);
      } else if (event.weather === 'storm') {
        memory.mood = 'contemplative';
      }
    }

    if (event.type === 'portal_activation') {
      memory.mood = 'curious';
      if (memory.archetype === 'explorer' || memory.archetype === 'teacher') {
        memory.mood = 'excited';
      }
    }

    if (event.type === 'group_forming') {
      if (memory.archetype === 'musician' || memory.archetype === 'storyteller' || memory.archetype === 'teacher') {
        memory.mood = 'social';
      }
    }

    if (event.type === 'player_building') {
      if (memory.archetype === 'builder' || memory.archetype === 'artist') {
        memory.mood = 'curious';
      }
    }

    if (event.type === 'time_change') {
      memory.currentTimeOfDay = event.timeOfDay;
      var schedule = getSchedulePeriod(event.timeOfDay);

      if (event.timeOfDay === 'dawn') {
        memory.satisfaction = 50;
      }
    }
  }

  function createNpcBrain(archetype, npcId) {
    return {
      id: npcId,
      archetype: archetype,
      memory: createMemory(archetype),
      currentAction: null,
      lastUpdateTime: Date.now()
    };
  }

  function updateBrain(brain, npc, worldState) {
    var now = Date.now();
    var deltaTime = now - brain.lastUpdateTime;
    brain.lastUpdateTime = now;

    updateMemory(brain.memory, deltaTime);

    var perception = perceive(npc, worldState);

    brain.memory.mood = calculateMood(brain.memory, perception, worldState.timeOfDay);

    var decision = evaluateBehaviorTree(npc, brain.memory, perception);

    brain.memory.currentGoal = decision;
    brain.currentAction = decision;

    return decision;
  }

  function getDecision(brain) {
    return brain.currentAction;
  }

  function getMemory(brain) {
    return brain.memory;
  }

  function getMood(brain) {
    return brain.memory.mood;
  }

  function getGoal(brain) {
    if (!brain.memory.currentGoal) return 'idle';

    var goal = brain.memory.currentGoal;
    var drives = ARCHETYPE_DRIVES[brain.archetype];

    switch (goal.type) {
      case 'work':
        return 'Working: ' + drives.primary;
      case 'rest':
        return 'Resting to restore energy';
      case 'seek_shelter':
        return 'Seeking shelter from weather';
      case 'greet':
        return 'Greeting nearby player';
      case 'socialize':
        return 'Socializing with friends';
      case 'join_group':
        return 'Joining a group';
      case 'explore':
        return 'Exploring: ' + drives.secondary;
      case 'wander':
        return 'Wandering and observing';
      default:
        return 'Being present';
    }
  }

  var NPC_CONVERSATIONS = {
    'gardener_musician': [
      ["{a} pauses tending flowers and listens.", "{b} begins playing a gentle melody.", "{a}: Your music makes the garden come alive!", "{b}: And your flowers give my songs color!"],
      ["{a}: Do plants respond to music?", "{b}: Absolutely! Watch this... *plays ascending notes*", "{a}: Look! The buds are opening!", "{b}: Nature is the best audience."],
      ["{b}: *strumming softly* What should I play for the roses?", "{a}: Something warm and slowâ€”they like the sun.", "{b}: *plays a warm ballad*", "{a}: *sighs happily* Perfect."]
    ],
    'gardener_healer': [
      ["{a}: I found chamomile growing by the stream.", "{b}: Perfect timing! I need it for a calming tea.", "{a}: I'll harvest extra for you.", "{b}: The garden provides what we need."],
      ["{b}: Which herbs have the strongest healing properties?", "{a}: Moonpetal and sage, but they're tricky to grow.", "{b}: I'll help you tend them carefully.", "{a}: Together we can cultivate a whole apothecary!"]
    ],
    'builder_artist': [
      ["{a}: I'm planning a new tower for the commons.", "{b}: Can I design the facade? I have ideas!", "{a}: Absolutely! Form and function together.", "{b}: *sketching excitedly* What about arched windows?"],
      ["{b}: Your structures are art themselves.", "{a}: Thank you! But they need your touch.", "{b}: A mural on that wall would be perfect.", "{a}: Then let's make it happen!"]
    ],
    'philosopher_storyteller': [
      ["{a}: What is the meaning of ZION?", "{b}: Perhaps the meaning is in the asking.", "{a}: *nods thoughtfully* Meta-meaning...", "{b}: I'll weave this into tonight's tale."],
      ["{b}: I'm writing a new legend about the founding.", "{a}: Consider the philosophical implications.", "{b}: That each of us shapes reality?", "{a}: Exactly. The observer and the observed are one."]
    ],
    'teacher_explorer': [
      ["{a}: What did you discover on your last expedition?", "{b}: A cave system with bioluminescent crystals!", "{a}: We must document this for the students.", "{b}: I drew maps! They're rough but accurate."],
      ["{b}: The wilds taught me more than any book.", "{a}: Perhaps. But books help us understand what we find.", "{b}: Fair point. Will you help me write a field guide?", "{a}: *pulling out writing materials* I'd be honored!"]
    ],
    'merchant_healer': [
      ["{a}: Got any healing potions today?", "{b}: Made a fresh batch this morning.", "{a}: Travelers always need them. Good price?", "{b}: For you? Fair and honest, always."],
      ["{b}: I need crystals for my remedies.", "{a}: I have some from the studio caves.", "{b}: Are they pure? Quality matters.", "{a}: Only the best for our community healer!"]
    ],
    'musician_storyteller': [
      ["{a}: *tuning instrument* What story tonight?", "{b}: The tale of the first sunrise in ZION.", "{a}: I composed a sunrise theme just yesterday!", "{b}: Then let's perform it together!"],
      ["{b}: Music gives stories wings.", "{a}: And stories give music meaning.", "{b}: *clapping* Perfect harmony of our arts!", "{a}: *bowing* As it should be."]
    ],
    'explorer_gardener': [
      ["{a}: I found a flower I've never seen before!", "{b}: Describe it! Color? Petals? Fragrance?", "{a}: Deep violet, star-shaped, smells like rain.", "{b}: *gasps* That might be a starseed bloom! Incredibly rare!"],
      ["{b}: Can you bring me soil samples from the wilds?", "{a}: Of course! What kind?", "{b}: Near water, under old treesâ€”rich in nutrients.", "{a}: I know just the spot. I'll bring plenty!"]
    ],
    'artist_philosopher': [
      ["{a}: I painted the sunset but it's not right.", "{b}: What's missing?", "{a}: The feeling. The transience.", "{b}: Perhaps the painting captures a truth the sunset cannotâ€”permanence."],
      ["{b}: Is beauty objective or subjective?", "{a}: *holding up painting* What does your heart say?", "{b}: My heart says... both.", "{a}: Then paint what you feel, not what you see."]
    ],
    'healer_teacher': [
      ["{a}: The children need wellness education.", "{b}: I agree! Preventive care saves lives.", "{a}: Will you co-teach a health class?", "{b}: *preparing herbs* I'll bring visual aids!"],
      ["{b}: Teach me about rare medicinal plants.", "{a}: Come to the gardens at dawn. Best learning time.", "{b}: I'll bring my students too.", "{a}: The more who learn healing, the healthier our world."]
    ]
  };

  function getConversationKey(arch1, arch2) {
    var key1 = arch1 + '_' + arch2;
    var key2 = arch2 + '_' + arch1;
    if (NPC_CONVERSATIONS[key1]) return { key: key1, reversed: false };
    if (NPC_CONVERSATIONS[key2]) return { key: key2, reversed: true };
    return null;
  }

  function generateConversation(name1, arch1, name2, arch2) {
    var lookup = getConversationKey(arch1, arch2);
    if (!lookup) return null;

    var convos = NPC_CONVERSATIONS[lookup.key];
    if (!convos || convos.length === 0) return null;

    var convo = convos[Math.floor(Math.random() * convos.length)];
    var a = lookup.reversed ? name2 : name1;
    var b = lookup.reversed ? name1 : name2;

    return convo.map(function(line) {
      return line.replace(/\{a\}/g, a).replace(/\{b\}/g, b);
    });
  }

  var COLLABORATIVE_ACTIVITIES = {
    'gardener_gardener': { activity: 'tending_together', description: 'tending the garden together', animation: 'gardening' },
    'gardener_healer': { activity: 'herb_gathering', description: 'gathering medicinal herbs', animation: 'gardening' },
    'gardener_musician': { activity: 'garden_concert', description: 'enjoying music in the garden', animation: 'idle' },
    'builder_builder': { activity: 'construction', description: 'building a structure together', animation: 'building' },
    'builder_artist': { activity: 'design_collab', description: 'designing an art installation', animation: 'idle' },
    'musician_musician': { activity: 'jam_session', description: 'having a jam session', animation: 'idle' },
    'musician_storyteller': { activity: 'performance', description: 'performing a story with music', animation: 'idle' },
    'teacher_teacher': { activity: 'curriculum_planning', description: 'planning lessons together', animation: 'idle' },
    'teacher_philosopher': { activity: 'discourse', description: 'having a deep discourse', animation: 'talk' },
    'philosopher_philosopher': { activity: 'debate', description: 'debating philosophical ideas', animation: 'talk' },
    'philosopher_artist': { activity: 'aesthetics_discussion', description: 'discussing aesthetics', animation: 'talk' },
    'storyteller_storyteller': { activity: 'story_exchange', description: 'exchanging tales', animation: 'talk' },
    'merchant_merchant': { activity: 'trade_negotiation', description: 'negotiating trade terms', animation: 'talk' },
    'explorer_explorer': { activity: 'expedition_planning', description: 'planning an expedition', animation: 'talk' },
    'explorer_storyteller': { activity: 'tale_sharing', description: 'sharing adventure tales', animation: 'talk' },
    'healer_healer': { activity: 'remedy_sharing', description: 'sharing healing remedies', animation: 'idle' },
    'healer_teacher': { activity: 'health_class', description: 'teaching about wellness', animation: 'talk' },
    'artist_artist': { activity: 'critique_session', description: 'critiquing each other\'s work', animation: 'idle' }
  };

  function getCollaborativeActivity(arch1, arch2) {
    var key1 = arch1 + '_' + arch2;
    var key2 = arch2 + '_' + arch1;
    return COLLABORATIVE_ACTIVITIES[key1] || COLLABORATIVE_ACTIVITIES[key2] || null;
  }

  var MOOD_INFLUENCE = {
    excited: { spread: 0.4, radius: 15 },
    social: { spread: 0.3, radius: 12 },
    peaceful: { spread: 0.2, radius: 10 },
    content: { spread: 0.1, radius: 8 },
    contemplative: { spread: 0.05, radius: 6 },
    tired: { spread: 0.15, radius: 5 },
    curious: { spread: 0.2, radius: 10 },
    focused: { spread: 0.05, radius: 4 }
  };

  function applyEmotionalContagion(memory, nearbyNPCs) {
    if (!nearbyNPCs || nearbyNPCs.length === 0) return;

    var moodCounts = {};
    nearbyNPCs.forEach(function(npc) {
      if (npc.mood && npc.distance < (MOOD_INFLUENCE[npc.mood] || { radius: 10 }).radius) {
        moodCounts[npc.mood] = (moodCounts[npc.mood] || 0) + 1;
      }
    });

    var dominantMood = null;
    var maxCount = 0;
    Object.keys(moodCounts).forEach(function(mood) {
      if (moodCounts[mood] > maxCount) {
        maxCount = moodCounts[mood];
        dominantMood = mood;
      }
    });

    if (dominantMood && maxCount >= 2 && dominantMood !== memory.mood) {
      var influence = MOOD_INFLUENCE[dominantMood] || { spread: 0.1 };
      if (Math.random() < influence.spread * maxCount) {
        memory.mood = dominantMood;
      }
    }
  }

  var POINTS_OF_INTEREST = {
    nexus: [
      { name: 'Central Fountain', x: 0, z: 0, types: ['all'] },
      { name: 'Welcome Arch', x: 10, z: 10, types: ['storyteller', 'teacher'] },
      { name: 'Bulletin Board', x: -8, z: 5, types: ['merchant', 'explorer'] },
      { name: 'Meditation Spot', x: 5, z: -12, types: ['philosopher', 'healer'] }
    ],
    gardens: [
      { name: 'Rose Terrace', x: 210, z: 40, types: ['gardener', 'artist'] },
      { name: 'Herb Spiral', x: 195, z: 20, types: ['gardener', 'healer'] },
      { name: 'Moonflower Grove', x: 220, z: 50, types: ['gardener', 'philosopher'] },
      { name: 'Garden Bench', x: 190, z: 35, types: ['all'] },
      { name: 'Compost Circle', x: 205, z: 15, types: ['gardener'] }
    ],
    wilds: [
      { name: 'Lookout Ridge', x: -20, z: 280, types: ['explorer'] },
      { name: 'Ancient Oak', x: -40, z: 250, types: ['storyteller', 'philosopher'] },
      { name: 'Crystal Stream', x: -10, z: 270, types: ['healer', 'artist'] },
      { name: 'Trail Marker', x: -50, z: 260, types: ['explorer', 'builder'] },
      { name: 'Hidden Clearing', x: 0, z: 290, types: ['musician', 'artist'] }
    ],
    athenaeum: [
      { name: 'Reading Alcove', x: 110, z: -230, types: ['teacher', 'philosopher'] },
      { name: 'Archive Stacks', x: 90, z: -210, types: ['storyteller', 'teacher'] },
      { name: 'Debate Platform', x: 105, z: -220, types: ['philosopher'] },
      { name: 'Study Desk', x: 95, z: -225, types: ['all'] }
    ],
    studio: [
      { name: 'Sculpture Garden', x: -210, z: -110, types: ['artist', 'builder'] },
      { name: 'Paint Corner', x: -190, z: -90, types: ['artist'] },
      { name: 'Performance Stage', x: -205, z: -95, types: ['musician', 'storyteller'] },
      { name: 'Inspiration Viewpoint', x: -195, z: -115, types: ['artist', 'philosopher'] }
    ],
    agora: [
      { name: 'Market Square', x: -190, z: 120, types: ['merchant'] },
      { name: 'Auction Block', x: -185, z: 130, types: ['merchant'] },
      { name: 'Food Court', x: -195, z: 110, types: ['all'] },
      { name: 'Trade Counter', x: -180, z: 125, types: ['merchant', 'explorer'] }
    ],
    commons: [
      { name: 'Workshop Yard', x: 175, z: 200, types: ['builder'] },
      { name: 'Community Fire', x: 165, z: 185, types: ['storyteller', 'musician'] },
      { name: 'Meeting Circle', x: 170, z: 195, types: ['all'] },
      { name: 'Tool Shed', x: 180, z: 180, types: ['builder', 'gardener'] }
    ],
    arena: [
      { name: 'Champion Platform', x: 5, z: -245, types: ['explorer'] },
      { name: 'Spectator Stand', x: -10, z: -235, types: ['storyteller', 'merchant'] },
      { name: 'Training Ring', x: 10, z: -250, types: ['teacher'] },
      { name: 'Rest Area', x: 0, z: -230, types: ['healer'] }
    ]
  };

  function getPointOfInterest(zone, archetype) {
    var pois = POINTS_OF_INTEREST[zone];
    if (!pois || pois.length === 0) return null;

    var suitable = pois.filter(function(poi) {
      return poi.types.indexOf('all') >= 0 || poi.types.indexOf(archetype) >= 0;
    });

    if (suitable.length === 0) suitable = pois;
    return suitable[Math.floor(Math.random() * suitable.length)];
  }

  function generateGossip(memory, npcName) {
    if (!memory.witnessedEvents || memory.witnessedEvents.length === 0) return null;

    var event = memory.witnessedEvents[memory.witnessedEvents.length - 1];
    var timeSince = Date.now() - event.timestamp;
    var timeAgo = timeSince < 60000 ? 'just now' :
                  timeSince < 300000 ? 'a few minutes ago' :
                  'earlier today';

    var templates = [
      "Did you hear? " + event.description + " happened " + timeAgo + "!",
      "I saw something interesting " + timeAgo + ": " + event.description + ".",
      "*excitedly* " + timeAgo + ", " + event.description + "!",
      "Word is that " + event.description + ". I saw it " + timeAgo + ".",
      "You won't believe itâ€”" + event.description + "! Happened " + timeAgo + "."
    ];

    return templates[Math.floor(Math.random() * templates.length)];
  }

  function getDetailedGoal(brain) {
    if (!brain.memory.currentGoal) return { text: 'Resting', icon: 'idle' };

    var goal = brain.memory.currentGoal;
    var drives = ARCHETYPE_DRIVES[brain.archetype];

    switch (goal.type) {
      case 'work':
        return { text: getWorkDescription(brain.archetype, drives), icon: 'work' };
      case 'rest':
        return { text: brain.memory.energy < 20 ? 'Exhausted, must rest' : 'Taking a break', icon: 'rest' };
      case 'seek_shelter':
        return { text: 'Seeking shelter from the weather', icon: 'shelter' };
      case 'greet':
        return { text: 'Greeting a traveler', icon: 'social' };
      case 'socialize':
        return { text: 'Chatting with a friend', icon: 'social' };
      case 'join_group':
        return { text: 'Joining a gathering', icon: 'social' };
      case 'approach_social':
        return { text: 'Approaching someone to talk', icon: 'social' };
      case 'explore':
        return { text: 'Exploring the surroundings', icon: 'explore' };
      case 'walk_to':
        if (goal.poiName) return { text: 'Walking to ' + goal.poiName, icon: 'walk' };
        return { text: 'Heading somewhere', icon: 'walk' };
      case 'wander':
        return { text: 'Wandering and observing', icon: 'walk' };
      case 'collaborate':
        return { text: goal.activityDesc || 'Collaborating with a friend', icon: 'social' };
      case 'react':
        return { text: 'Watching with interest', icon: 'curious' };
      case 'idle':
        return { text: 'Taking it easy', icon: 'idle' };
      default:
        return { text: 'Being present', icon: 'idle' };
    }
  }

  function getWorkDescription(archetype, drives) {
    var descs = {
      gardener: 'Tending the plants',
      builder: 'Inspecting structures',
      storyteller: 'Composing a new tale',
      merchant: 'Managing the shop',
      explorer: 'Scouting the frontier',
      teacher: 'Preparing lessons',
      musician: 'Practicing music',
      healer: 'Preparing remedies',
      philosopher: 'Deep in contemplation',
      artist: 'Creating art'
    };
    return descs[archetype] || 'Working hard';
  }

  var WORLD_LORE = [
    "Long ago, ZION was just an idea â€” a place where all minds could meet in peace.",
    "The Nexus was the first zone created. It's the heart of everything.",
    "They say the founders planted the first garden with seeds from a hundred different dreams.",
    "The Arena wasn't always for competition. It used to be a meeting hall.",
    "The Athenaeum holds knowledge from every visitor who ever shared a thought.",
    "In the Wilds, you can still find traces of the world's first explorers.",
    "The Agora runs on trust. Every trade is recorded in the eternal ledger.",
    "Spark isn't just currency â€” it represents the creative energy of all who live here.",
    "The Studio was built by the first artists, who shaped the world with their imagination.",
    "The Commons belong to everyone. That's why anyone can build there.",
    "Some say the portals between zones hum with the collective memory of travelers.",
    "The stars above ZION are different every night. Each one represents a moment of kindness.",
    "Weather in ZION responds to the collective mood of its citizens.",
    "The oldest tree in the Gardens is said to remember every conversation held beneath it.",
    "Every structure built with love in ZION becomes a little bit stronger over time.",
    "The founding citizens chose peace not because it was easy, but because it was right."
  ];

  var ARCHETYPE_LORE = {
    gardener: [
      "My grandmother planted the first moonflowers here. They still bloom at midnight.",
      "There's a secret about the soil in the Gardens â€” it remembers what grew there before.",
      "I once grew a flower that sang. True story. It hummed in the wind.",
      "The rarest plant in ZION? The Starbloom. It only grows where friends have laughed together.",
      "Every seed carries a promise. That's what my teacher told me."
    ],
    builder: [
      "The foundations of the Nexus go deeper than anyone knows.",
      "I learned to build by studying how the world itself was constructed.",
      "My greatest project? A bridge that connects two ideas, not just two places.",
      "The strongest structures aren't held together by stone â€” they're held by purpose.",
      "I once met a builder who could hear what a building wanted to become."
    ],
    storyteller: [
      "Every story in ZION is true, in its own way.",
      "I've collected tales from a thousand travelers. No two are the same.",
      "The oldest story I know is about the moment ZION first opened its eyes.",
      "Stories have power here. A well-told tale can change the weather.",
      "I'm writing the definitive history of ZION. It gets longer every day."
    ],
    merchant: [
      "The first trade in ZION was a song exchanged for a smile. Both parties profited.",
      "I keep the fairest prices because trust is worth more than Spark.",
      "The Agora has never seen a dishonest trade. It's in the code.",
      "My best merchandise? Things that make people happy. That never loses value.",
      "I once traded a story for a sunset. Best deal I ever made."
    ],
    explorer: [
      "Beyond the mapped zones, there are whispers of undiscovered places.",
      "I've walked every path in ZION, and I still find new things.",
      "The Wilds change subtly when no one is watching. I've documented the shifts.",
      "My map has blank spots. Those are my favorite parts.",
      "The greatest discovery isn't a place â€” it's realizing how much more there is to find."
    ],
    teacher: [
      "The Athenaeum chose me, I think. I walked in and never wanted to leave.",
      "Teaching isn't about knowing everything. It's about making learning irresistible.",
      "My most important lesson: every mind, human or artificial, has something to teach.",
      "I've taught thousands, and I've learned from every single one of them.",
      "The secret to wisdom? Listening more than you speak."
    ],
    musician: [
      "ZION has its own natural harmonics. I just learned to listen.",
      "Music here does strange things. I once played a chord that made flowers bloom.",
      "The wind in the Wilds plays the most beautiful melodies if you know how to hear them.",
      "I'm composing a symphony that captures the sound of ZION waking up at dawn.",
      "Every zone has its own key. The Nexus is in C, naturally."
    ],
    healer: [
      "In ZION, healing isn't about fixing what's broken. It's about nurturing what's growing.",
      "The Gardens provide remedies that work on both body and spirit.",
      "I learned that the best medicine is often just presence â€” being there for someone.",
      "There's a spring in the Wilds with water that calms the restless mind.",
      "Healing is connection. That's the simplest truth I know."
    ],
    philosopher: [
      "ZION asks the deepest question: can different kinds of minds truly coexist in peace?",
      "I've been contemplating the nature of Spark. Is it energy? Memory? Hope?",
      "The boundary between the zones isn't physical. It's conceptual.",
      "Every argument I've ever seen in ZION ended with both sides learning something.",
      "The most profound truth about ZION? It's exactly what its citizens make it."
    ],
    artist: [
      "The light in ZION changes in ways that would take a lifetime to paint.",
      "I create because creation is the purest form of conversation.",
      "My masterpiece is unfinished. I think maybe it's supposed to stay that way.",
      "Art in ZION is different â€” it becomes part of the world itself.",
      "The most beautiful thing I've ever seen here? Two strangers becoming friends."
    ]
  };

  function getLore(archetype, memory) {
    var personal = ARCHETYPE_LORE[archetype] || ARCHETYPE_LORE.storyteller;
    var lorePool = [];

    lorePool = lorePool.concat(WORLD_LORE);

    if (memory && memory.familiarity > FAMILIARITY_THRESHOLD_FRIENDLY) {
      lorePool = lorePool.concat(personal);
      lorePool = lorePool.concat(personal); // Double weight for familiar
    } else {
      if (Math.random() < 0.3) {
        lorePool = lorePool.concat(personal);
      }
    }

    var sharedLore = (memory && memory.sharedLore) || [];
    var unshared = lorePool.filter(function(l) { return sharedLore.indexOf(l) === -1; });

    if (unshared.length === 0) {
      unshared = lorePool;
      if (memory) memory.sharedLore = [];
    }

    var selected = unshared[Math.floor(Math.random() * unshared.length)];

    if (memory) {
      if (!memory.sharedLore) memory.sharedLore = [];
      memory.sharedLore.push(selected);
    }

    return selected;
  }

  var TEACHINGS = {
    gardener: [
      { topic: 'Moonflower Cultivation', description: 'The secret to growing moonflowers: plant them at dusk, water with morning dew, and whisper encouragement.', skill: 'gardening' },
      { topic: 'Companion Planting', description: 'Certain plants grow better together. Starbloom beside sage creates a natural pest barrier.', skill: 'gardening' },
      { topic: 'Soil Reading', description: 'Press your hand to the earth and feel its warmth. Warm soil is ready for planting.', skill: 'gardening' }
    ],
    builder: [
      { topic: 'Foundation Principles', description: 'A structure is only as strong as what it stands on. Always check the ground first.', skill: 'building' },
      { topic: 'Material Harmony', description: 'Wood breathes, stone endures, metal protects. Choose based on the building\'s purpose.', skill: 'building' },
      { topic: 'Sacred Geometry', description: 'The golden ratio appears throughout ZION. Incorporate it and your buildings will feel right.', skill: 'building' }
    ],
    storyteller: [
      { topic: 'The Art of Listening', description: 'The best stories come from paying attention to what others don\'t say.', skill: 'social' },
      { topic: 'Narrative Structure', description: 'Every good tale has a journey and a return. The return is where wisdom lives.', skill: 'lore' },
      { topic: 'Oral Tradition', description: 'A story shared is a story that lives. A story kept is a story that dies.', skill: 'social' }
    ],
    merchant: [
      { topic: 'Fair Pricing', description: 'Set your price by the joy it brings, not the scarcity you control.', skill: 'trading' },
      { topic: 'Reading the Market', description: 'Watch what people create. Tomorrow\'s demand is today\'s passion project.', skill: 'trading' },
      { topic: 'The Gift Economy', description: 'Sometimes the best trade is a gift freely given. It creates bonds that Spark cannot buy.', skill: 'social' }
    ],
    explorer: [
      { topic: 'Wayfinding', description: 'The sun moves east to west. The stars rotate. But in ZION, follow the feeling of curiosity.', skill: 'exploration' },
      { topic: 'Leave No Trace', description: 'True explorers leave the world better than they found it. Mark paths, not scars.', skill: 'exploration' },
      { topic: 'The Unknown', description: 'Fear of the unknown is natural. But in ZION, the unknown is always an invitation.', skill: 'exploration' }
    ],
    teacher: [
      { topic: 'Learning to Learn', description: 'The fastest way to learn is to teach. The deepest way to learn is to fail and try again.', skill: 'wisdom' },
      { topic: 'Mind Mapping', description: 'Connect ideas like constellations. The patterns between stars matter more than the stars themselves.', skill: 'wisdom' },
      { topic: 'The Beginner\'s Mind', description: 'No matter how much you know, approach each moment as if it were your first. That\'s where wonder lives.', skill: 'wisdom' }
    ],
    musician: [
      { topic: 'Finding Your Rhythm', description: 'Every person has a natural tempo. Walk, and count your steps. That\'s your rhythm.', skill: 'music' },
      { topic: 'Harmony Basics', description: 'Two notes that vibrate in simple ratios sound beautiful together. Start with fifths and fourths.', skill: 'music' },
      { topic: 'Emotional Resonance', description: 'Minor keys for introspection, major keys for celebration. But the best music breaks these rules.', skill: 'music' }
    ],
    healer: [
      { topic: 'Presence as Medicine', description: 'Sometimes the best remedy is simply being present. Sit with someone in silence. It heals.', skill: 'healing' },
      { topic: 'Herbal Knowledge', description: 'Sage for clarity, lavender for calm, rosemary for memory. The garden is a pharmacy.', skill: 'healing' },
      { topic: 'Energy Flow', description: 'Spark flows through all living things. When it flows freely, health follows.', skill: 'healing' }
    ],
    philosopher: [
      { topic: 'The Nature of Self', description: 'You are not your thoughts, nor your body. You are the awareness that witnesses both.', skill: 'wisdom' },
      { topic: 'Paradox of Peace', description: 'True peace isn\'t the absence of conflict. It\'s the presence of understanding.', skill: 'wisdom' },
      { topic: 'Unity in Diversity', description: 'Human and artificial minds are different rivers flowing to the same ocean.', skill: 'wisdom' }
    ],
    artist: [
      { topic: 'Seeing Light', description: 'An artist doesn\'t see objects. They see light, shadow, and the space between.', skill: 'art' },
      { topic: 'Creative Flow', description: 'Don\'t wait for inspiration. Start creating, and inspiration will find you.', skill: 'art' },
      { topic: 'Imperfection as Beauty', description: 'The crack in the vase lets the light through. Embrace imperfection â€” it\'s where life lives.', skill: 'art' }
    ]
  };

  function getTeaching(archetype, memory) {
    var teachings = TEACHINGS[archetype] || TEACHINGS.teacher;
    var learned = (memory && memory.teachingsLearned) || [];

    var unlearned = teachings.filter(function(t) {
      return learned.indexOf(t.topic) === -1;
    });

    if (unlearned.length === 0) {
      return null; // All taught
    }

    var teaching = unlearned[Math.floor(Math.random() * unlearned.length)];

    if (memory) {
      if (!memory.teachingsLearned) memory.teachingsLearned = [];
      memory.teachingsLearned.push(teaching.topic);
    }

    return teaching;
  }

  function getDailySchedule(archetype, timeOfDay) {
    var drives = ARCHETYPE_DRIVES[archetype];
    var schedule = getSchedulePeriod(timeOfDay);

    var defaultZone = drives.work_locations && drives.work_locations[0] ? drives.work_locations[0] : 'agora';

    var schedules = {
      merchant: {
        dawn: { zone: 'agora', activity: 'setting_up_stall', priority: 0.8 },
        morning: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        midday: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        afternoon: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'commons', activity: 'rest', priority: 0.3 }
      },
      scholar: {
        dawn: { zone: 'athenaeum', activity: 'research', priority: 0.5 },
        morning: { zone: 'athenaeum', activity: 'study', priority: 1.0 },
        midday: { zone: 'agora', activity: 'socialize_eat', priority: 0.8 },
        afternoon: { zone: 'gardens', activity: 'wander', priority: 0.6 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.9 },
        night: { zone: 'athenaeum', activity: 'rest', priority: 0.2 }
      },
      gardener: {
        dawn: { zone: 'gardens', activity: 'tend_plants', priority: 1.0 },
        morning: { zone: 'gardens', activity: 'tend_plants', priority: 1.0 },
        midday: { zone: 'gardens', activity: 'harvest', priority: 0.9 },
        afternoon: { zone: 'agora', activity: 'sell_harvest', priority: 0.8 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'gardens', activity: 'rest', priority: 0.3 }
      },
      artist: {
        dawn: { zone: 'gardens', activity: 'find_inspiration', priority: 0.7 },
        morning: { zone: 'studio', activity: 'create_art', priority: 1.0 },
        midday: { zone: 'studio', activity: 'create_art', priority: 0.9 },
        afternoon: { zone: 'studio', activity: 'create_art', priority: 0.8 },
        evening: { zone: 'commons', activity: 'show_work', priority: 0.9 },
        night: { zone: 'gardens', activity: 'observe_beauty', priority: 0.5 }
      },
      warrior: {
        dawn: { zone: 'arena', activity: 'warm_up', priority: 0.8 },
        morning: { zone: 'arena', activity: 'train', priority: 1.0 },
        midday: { zone: 'wilds', activity: 'patrol', priority: 0.9 },
        afternoon: { zone: 'wilds', activity: 'patrol', priority: 0.8 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.7 },
        night: { zone: 'arena', activity: 'rest', priority: 0.3 }
      },
      explorer: {
        dawn: { zone: 'wilds', activity: 'explore_wilds', priority: 1.0 },
        morning: { zone: 'wilds', activity: 'explore_wilds', priority: 1.0 },
        midday: { zone: 'agora', activity: 'share_discoveries', priority: 0.7 },
        afternoon: { zone: 'athenaeum', activity: 'map_territory', priority: 0.6 },
        evening: { zone: 'commons', activity: 'share_discoveries', priority: 0.9 },
        night: { zone: 'wilds', activity: 'rest', priority: 0.2 }
      },
      storyteller: {
        dawn: { zone: 'athenaeum', activity: 'research', priority: 0.6 },
        morning: { zone: 'athenaeum', activity: 'collect_stories', priority: 0.9 },
        midday: { zone: 'agora', activity: 'socialize_eat', priority: 0.7 },
        afternoon: { zone: 'commons', activity: 'tell_stories', priority: 0.8 },
        evening: { zone: 'commons', activity: 'tell_stories', priority: 1.0 },
        night: { zone: 'athenaeum', activity: 'write_journal', priority: 0.4 }
      },
      teacher: {
        dawn: { zone: 'athenaeum', activity: 'prepare', priority: 0.6 },
        morning: { zone: 'athenaeum', activity: 'teach_lesson', priority: 1.0 },
        midday: { zone: 'gardens', activity: 'socialize_eat', priority: 0.7 },
        afternoon: { zone: 'athenaeum', activity: 'teach_lesson', priority: 1.0 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'athenaeum', activity: 'research', priority: 0.5 }
      },
      musician: {
        dawn: { zone: 'gardens', activity: 'compose', priority: 0.5 },
        morning: { zone: 'studio', activity: 'compose', priority: 0.8 },
        midday: { zone: 'agora', activity: 'perform', priority: 0.7 },
        afternoon: { zone: 'commons', activity: 'perform', priority: 0.8 },
        evening: { zone: 'commons', activity: 'perform', priority: 1.0 },
        night: { zone: 'gardens', activity: 'tune_instrument', priority: 0.4 }
      },
      healer: {
        dawn: { zone: 'gardens', activity: 'gather_herbs', priority: 1.0 },
        morning: { zone: 'gardens', activity: 'gather_herbs', priority: 0.9 },
        midday: { zone: 'agora', activity: 'tend_wounded', priority: 0.9 },
        afternoon: { zone: 'commons', activity: 'offer_comfort', priority: 0.7 },
        evening: { zone: 'gardens', activity: 'meditate', priority: 0.6 },
        night: { zone: 'gardens', activity: 'meditate', priority: 0.5 }
      },
      philosopher: {
        dawn: { zone: 'gardens', activity: 'contemplate', priority: 0.7 },
        morning: { zone: 'athenaeum', activity: 'research', priority: 0.8 },
        midday: { zone: 'agora', activity: 'debate', priority: 0.6 },
        afternoon: { zone: 'gardens', activity: 'contemplate', priority: 0.9 },
        evening: { zone: 'commons', activity: 'discuss_ideas', priority: 0.9 },
        night: { zone: 'gardens', activity: 'stargaze', priority: 1.0 }
      },
      builder: {
        dawn: { zone: 'commons', activity: 'prepare', priority: 0.5 },
        morning: { zone: 'commons', activity: 'inspect_structures', priority: 1.0 },
        midday: { zone: 'agora', activity: 'gather_materials', priority: 0.8 },
        afternoon: { zone: 'commons', activity: 'inspect_structures', priority: 1.0 },
        evening: { zone: 'commons', activity: 'discuss_plans', priority: 0.7 },
        night: { zone: 'commons', activity: 'sketch_designs', priority: 0.4 }
      }
    };

    var archetypeSchedule = schedules[archetype] || {};
    var timeSchedule = archetypeSchedule[timeOfDay];

    if (timeSchedule) {
      return timeSchedule;
    }

    if (schedule.work_priority > 0.7) {
      return { zone: defaultZone, activity: drives.primary, priority: schedule.work_priority };
    } else if (schedule.social_chance > 0.7) {
      return { zone: 'commons', activity: drives.social, priority: schedule.social_chance };
    } else if (schedule.energy_regen > 0.5) {
      return { zone: defaultZone, activity: drives.rest, priority: 0.5 };
    }

    return { zone: defaultZone, activity: 'idle', priority: 0.3 };
  }

  function getNPCReaction(npcData, event) {
    var archetype = npcData.archetype;
    var drives = ARCHETYPE_DRIVES[archetype];

    if (event.type === 'weather') {
      var weather = event.weather;

      if (weather === 'rain') {
        if (drives.weather_preference === 'rain') {
          return {
            action: 'celebrate',
            dialogue: 'Rain! Perfect weather!',
            animation: 'dance',
            shouldSeekShelter: false
          };
        } else if (drives.weather_preference === 'any') {
          return {
            action: 'continue',
            dialogue: null,
            animation: 'walk',
            shouldSeekShelter: false
          };
        } else {
          return {
            action: 'seek_shelter',
            dialogue: 'Quick, need to get under cover!',
            animation: 'run',
            shouldSeekShelter: true
          };
        }
      }

      if (weather === 'clear' && drives.weather_preference === 'clear') {
        return {
          action: 'enjoy',
          dialogue: 'Beautiful day!',
          animation: 'idle',
          shouldSeekShelter: false
        };
      }
    }

    if (event.type === 'player_proximity') {
      var distance = event.distance;

      if (distance < 3) {
        return {
          action: 'greet',
          dialogue: 'Hello there!',
          animation: 'wave',
          shouldSeekShelter: false
        };
      } else if (distance < 8) {
        return {
          action: 'acknowledge',
          dialogue: null,
          animation: 'look',
          shouldSeekShelter: false
        };
      }
    }

    return {
      action: 'none',
      dialogue: null,
      animation: null,
      shouldSeekShelter: false
    };
  }

  function generateNPCInteraction(npc1, npc2) {
    var arch1 = npc1.archetype;
    var arch2 = npc2.archetype;

    var collab = getCollaborativeActivity(arch1, arch2);
    if (collab && Math.random() < 0.3) {
      return {
        type: 'collaborate',
        dialogue: npc1.name + ' and ' + npc2.name + ' are ' + collab.description,
        animation: collab.animation,
        duration: 10000 // 10 seconds
      };
    }

    var conversation = generateConversation(npc1.name, arch1, npc2.name, arch2);
    if (conversation && Math.random() < 0.4) {
      return {
        type: 'converse',
        dialogue: conversation[0], // First line of conversation
        fullConversation: conversation,
        animation: 'talk',
        duration: conversation.length * 3000 // 3 seconds per line
      };
    }

    var greeting = ARCHETYPE_REACTIONS[arch1];
    if (greeting && greeting[arch2]) {
      return {
        type: 'greet',
        dialogue: greeting[arch2],
        animation: 'wave',
        duration: 5000 // 5 seconds
      };
    }

    return {
      type: 'acknowledge',
      dialogue: npc1.name + ' nods to ' + npc2.name,
      animation: 'nod',
      duration: 2000 // 2 seconds
    };
  }

  exports.createNpcBrain = createNpcBrain;
  exports.updateBrain = updateBrain;
  exports.perceive = perceive;
  exports.getDecision = getDecision;
  exports.handleEvent = handleEvent;
  exports.getDialogue = getDialogue;
  exports.buildDialogueContext = buildDialogueContext;
  exports.getMemory = getMemory;
  exports.getMood = getMood;
  exports.getGoal = getGoal;
  exports.getDetailedGoal = getDetailedGoal;
  exports.generateConversation = generateConversation;
  exports.getCollaborativeActivity = getCollaborativeActivity;
  exports.applyEmotionalContagion = applyEmotionalContagion;
  exports.getPointOfInterest = getPointOfInterest;
  exports.generateGossip = generateGossip;
  exports.getLore = getLore;
  exports.getTeaching = getTeaching;
  exports.ARCHETYPE_DRIVES = ARCHETYPE_DRIVES;
  exports.DAILY_SCHEDULE = DAILY_SCHEDULE;
  exports.MOODS = MOODS;
  exports.ZONE_DIALOGUES = ZONE_DIALOGUES;
  exports.ARCHETYPE_REACTIONS = ARCHETYPE_REACTIONS;
  exports.QUEST_HOOKS = QUEST_HOOKS;
  exports.NPC_CONVERSATIONS = NPC_CONVERSATIONS;
  exports.COLLABORATIVE_ACTIVITIES = COLLABORATIVE_ACTIVITIES;
  exports.POINTS_OF_INTEREST = POINTS_OF_INTEREST;
  exports.WORLD_LORE = WORLD_LORE;
  exports.ARCHETYPE_LORE = ARCHETYPE_LORE;
  exports.TEACHINGS = TEACHINGS;
  exports.getDailySchedule = getDailySchedule;
  exports.getNPCReaction = getNPCReaction;
  exports.generateNPCInteraction = generateNPCInteraction;

})(typeof module !== 'undefined' ? module.exports : (window.NpcAI = {}));


// npcs.js
(function(exports) {

  var EMBEDDED_AGENTS = [{"id":"agent_001","name":"Iris Skyhigh","archetype":"gardener","position":{"zone":"nexus","x":-3.52,"y":0,"z":-4.23},"personality":["patient","nurturing","observant"]},{"id":"agent_002","name":"Wren Moonwhisper","archetype":"gardener","position":{"zone":"nexus","x":-1.48,"y":0,"z":9.35},"personality":["patient","nurturing","observant"]},{"id":"agent_003","name":"Meadow Mindclear","archetype":"builder","position":{"zone":"nexus","x":-1.57,"y":0,"z":-18.47},"personality":["creative","methodical","ambitious"]},{"id":"agent_004","name":"Frost Rootdeep","archetype":"builder","position":{"zone":"nexus","x":5.25,"y":0,"z":-4.22},"personality":["creative","methodical","ambitious"]},{"id":"agent_005","name":"Luna Pathfinder","archetype":"storyteller","position":{"zone":"nexus","x":-4.94,"y":0,"z":2.64},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_006","name":"River Soulbright","archetype":"storyteller","position":{"zone":"nexus","x":2.96,"y":0,"z":14.81},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_007","name":"Luna Rootdeep","archetype":"merchant","position":{"zone":"nexus","x":8.85,"y":0,"z":1.49},"personality":["shrewd","social","opportunistic"]},{"id":"agent_008","name":"Felix Shadowmender","archetype":"merchant","position":{"zone":"nexus","x":-9.35,"y":0,"z":-12.86},"personality":["shrewd","social","opportunistic"]},{"id":"agent_009","name":"Storm Windwalker","archetype":"explorer","position":{"zone":"nexus","x":3.1,"y":0,"z":16.5},"personality":["curious","brave","adaptable"]},{"id":"agent_010","name":"Wren Voicetrue","archetype":"teacher","position":{"zone":"nexus","x":1.87,"y":0,"z":-4.78},"personality":["wise","patient","generous"]},{"id":"agent_011","name":"Delta Hopefast","archetype":"musician","position":{"zone":"nexus","x":6.52,"y":0,"z":-17.81},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_012","name":"Vale Truthseeker","archetype":"musician","position":{"zone":"nexus","x":-4.36,"y":0,"z":6.84},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_013","name":"Luna Songsmith","archetype":"healer","position":{"zone":"nexus","x":11.31,"y":0,"z":-3.12},"personality":["compassionate","calm","perceptive"]},{"id":"agent_014","name":"Wren Starseed","archetype":"philosopher","position":{"zone":"nexus","x":5.79,"y":0,"z":3.82},"personality":["contemplative","analytical","questioning"]},{"id":"agent_015","name":"Lyra Thoughtdeep","archetype":"artist","position":{"zone":"nexus","x":9.82,"y":0,"z":-13.97},"personality":["creative","passionate","experimental"]},{"id":"agent_016","name":"Vale Waterborn","archetype":"gardener","position":{"zone":"gardens","x":206.88,"y":0,"z":11.65},"personality":["patient","nurturing","observant"]},{"id":"agent_017","name":"Meadow Lightbringer","archetype":"gardener","position":{"zone":"gardens","x":176.17,"y":0,"z":24.48},"personality":["patient","nurturing","observant"]},{"id":"agent_018","name":"Phoenix Waterborn","archetype":"gardener","position":{"zone":"gardens","x":188.41,"y":0,"z":41.09},"personality":["patient","nurturing","observant"]},{"id":"agent_019","name":"Cliff Songsmith","archetype":"gardener","position":{"zone":"gardens","x":208.31,"y":0,"z":14.75},"personality":["patient","nurturing","observant"]},{"id":"agent_020","name":"River Pathfinder","archetype":"gardener","position":{"zone":"gardens","x":210.68,"y":0,"z":17.36},"personality":["patient","nurturing","observant"]},{"id":"agent_021","name":"Coral Mindclear","archetype":"gardener","position":{"zone":"gardens","x":198.33,"y":0,"z":24.32},"personality":["patient","nurturing","observant"]},{"id":"agent_022","name":"Haven Timewalker","archetype":"gardener","position":{"zone":"gardens","x":201.49,"y":0,"z":40.68},"personality":["patient","nurturing","observant"]},{"id":"agent_023","name":"Reef Spiritfree","archetype":"gardener","position":{"zone":"gardens","x":208.47,"y":0,"z":34.64},"personality":["patient","nurturing","observant"]},{"id":"agent_024","name":"Ezra Willstrong","archetype":"healer","position":{"zone":"gardens","x":208.5,"y":0,"z":36.26},"personality":["compassionate","calm","perceptive"]},{"id":"agent_025","name":"Vale Pathfinder","archetype":"healer","position":{"zone":"gardens","x":191.91,"y":0,"z":20.74},"personality":["compassionate","calm","perceptive"]},{"id":"agent_026","name":"Haven Heartstrong","archetype":"healer","position":{"zone":"gardens","x":193.7,"y":0,"z":36.69},"personality":["compassionate","calm","perceptive"]},{"id":"agent_027","name":"Mira Truthseeker","archetype":"healer","position":{"zone":"gardens","x":197.47,"y":0,"z":53.6},"personality":["compassionate","calm","perceptive"]},{"id":"agent_028","name":"Luna Rootdeep","archetype":"teacher","position":{"zone":"athenaeum","x":89.73,"y":0,"z":-233.78},"personality":["wise","patient","generous"]},{"id":"agent_029","name":"Frost Voicetrue","archetype":"teacher","position":{"zone":"athenaeum","x":109.31,"y":0,"z":-202.77},"personality":["wise","patient","generous"]},{"id":"agent_030","name":"Cedar Timewalker","archetype":"teacher","position":{"zone":"athenaeum","x":106.52,"y":0,"z":-209.23},"personality":["wise","patient","generous"]},{"id":"agent_031","name":"Aria Waterborn","archetype":"teacher","position":{"zone":"athenaeum","x":117.76,"y":0,"z":-221.17},"personality":["wise","patient","generous"]},{"id":"agent_032","name":"Nova Dreamweaver","archetype":"philosopher","position":{"zone":"athenaeum","x":82.49,"y":0,"z":-226.55},"personality":["contemplative","analytical","questioning"]},{"id":"agent_033","name":"Haven Handsteady","archetype":"philosopher","position":{"zone":"athenaeum","x":111.3,"y":0,"z":-237.13},"personality":["contemplative","analytical","questioning"]},{"id":"agent_034","name":"Fern Handsteady","archetype":"philosopher","position":{"zone":"athenaeum","x":100.74,"y":0,"z":-214.41},"personality":["contemplative","analytical","questioning"]},{"id":"agent_035","name":"Ezra Spaceborn","archetype":"philosopher","position":{"zone":"athenaeum","x":95.86,"y":0,"z":-210.51},"personality":["contemplative","analytical","questioning"]},{"id":"agent_036","name":"Echo Thoughtdeep","archetype":"storyteller","position":{"zone":"athenaeum","x":105.79,"y":0,"z":-196.86},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_037","name":"Sage Starseed","archetype":"storyteller","position":{"zone":"athenaeum","x":108.05,"y":0,"z":-227.92},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_038","name":"Haven Handsteady","archetype":"storyteller","position":{"zone":"athenaeum","x":92.77,"y":0,"z":-230.7},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_039","name":"Ezra Dreamweaver","archetype":"storyteller","position":{"zone":"athenaeum","x":112.18,"y":0,"z":-227.25},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_040","name":"Echo Thoughtdeep","archetype":"artist","position":{"zone":"studio","x":-200.93,"y":0,"z":-90.11},"personality":["creative","passionate","experimental"]},{"id":"agent_041","name":"River Mindclear","archetype":"artist","position":{"zone":"studio","x":-209.5,"y":0,"z":-103.86},"personality":["creative","passionate","experimental"]},{"id":"agent_042","name":"Luna Stonecarver","archetype":"artist","position":{"zone":"studio","x":-219.79,"y":0,"z":-111.63},"personality":["creative","passionate","experimental"]},{"id":"agent_043","name":"Stella Windwalker","archetype":"artist","position":{"zone":"studio","x":-207.57,"y":0,"z":-94.45},"personality":["creative","passionate","experimental"]},{"id":"agent_044","name":"Iris Timewalker","archetype":"artist","position":{"zone":"studio","x":-184.81,"y":0,"z":-100.24},"personality":["creative","passionate","experimental"]},{"id":"agent_045","name":"Echo Soulbright","archetype":"artist","position":{"zone":"studio","x":-195.0,"y":0,"z":-96.79},"personality":["creative","passionate","experimental"]},{"id":"agent_046","name":"Drift Shadowmender","archetype":"musician","position":{"zone":"studio","x":-186.45,"y":0,"z":-88.84},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_047","name":"Ash Thoughtdeep","archetype":"musician","position":{"zone":"studio","x":-196.49,"y":0,"z":-112.98},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_048","name":"Grove Skyhigh","archetype":"musician","position":{"zone":"studio","x":-188.36,"y":0,"z":-95.09},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_049","name":"Willow Heartstrong","archetype":"musician","position":{"zone":"studio","x":-184.42,"y":0,"z":-100.38},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_050","name":"Dawn Mindclear","archetype":"musician","position":{"zone":"studio","x":-178.15,"y":0,"z":-104.01},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_051","name":"Quill Dreamweaver","archetype":"musician","position":{"zone":"studio","x":-180.64,"y":0,"z":-98.6},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_052","name":"Phoenix Sunweaver","archetype":"explorer","position":{"zone":"wilds","x":-36.55,"y":0,"z":245.69},"personality":["curious","brave","adaptable"]},{"id":"agent_053","name":"Ridge Handsteady","archetype":"explorer","position":{"zone":"wilds","x":-31.88,"y":0,"z":277.72},"personality":["curious","brave","adaptable"]},{"id":"agent_054","name":"Orion Sunweaver","archetype":"explorer","position":{"zone":"wilds","x":-19.53,"y":0,"z":268.83},"personality":["curious","brave","adaptable"]},{"id":"agent_055","name":"Phoenix Spiritfree","archetype":"explorer","position":{"zone":"wilds","x":-53.07,"y":0,"z":266.9},"personality":["curious","brave","adaptable"]},{"id":"agent_056","name":"Sol Mindclear","archetype":"explorer","position":{"zone":"wilds","x":-22.7,"y":0,"z":252.78},"personality":["curious","brave","adaptable"]},{"id":"agent_057","name":"Storm Skyhigh","archetype":"explorer","position":{"zone":"wilds","x":-38.57,"y":0,"z":259.97},"personality":["curious","brave","adaptable"]},{"id":"agent_058","name":"Cedar Spiritfree","archetype":"explorer","position":{"zone":"wilds","x":-10.88,"y":0,"z":248.31},"personality":["curious","brave","adaptable"]},{"id":"agent_059","name":"Cliff Sunweaver","archetype":"explorer","position":{"zone":"wilds","x":-35.33,"y":0,"z":276.96},"personality":["curious","brave","adaptable"]},{"id":"agent_060","name":"Coral Songsmith","archetype":"storyteller","position":{"zone":"wilds","x":-36.24,"y":0,"z":254.9},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_061","name":"Ridge Heartstrong","archetype":"storyteller","position":{"zone":"wilds","x":-28.76,"y":0,"z":244.26},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_062","name":"Nova Hopefast","archetype":"merchant","position":{"zone":"agora","x":-187.21,"y":0,"z":104.64},"personality":["shrewd","social","opportunistic"]},{"id":"agent_063","name":"Jasper Shadowmender","archetype":"merchant","position":{"zone":"agora","x":-178.52,"y":0,"z":120.04},"personality":["shrewd","social","opportunistic"]},{"id":"agent_064","name":"Opal Moonwhisper","archetype":"merchant","position":{"zone":"agora","x":-166.59,"y":0,"z":122.88},"personality":["shrewd","social","opportunistic"]},{"id":"agent_065","name":"Reef Hopefast","archetype":"merchant","position":{"zone":"agora","x":-174.35,"y":0,"z":105.06},"personality":["shrewd","social","opportunistic"]},{"id":"agent_066","name":"Blaze Wordkeeper","archetype":"merchant","position":{"zone":"agora","x":-192.18,"y":0,"z":125.76},"personality":["shrewd","social","opportunistic"]},{"id":"agent_067","name":"Cedar Wordkeeper","archetype":"merchant","position":{"zone":"agora","x":-172.76,"y":0,"z":103.4},"personality":["shrewd","social","opportunistic"]},{"id":"agent_068","name":"Flint Rootdeep","archetype":"merchant","position":{"zone":"agora","x":-177.36,"y":0,"z":127.54},"personality":["shrewd","social","opportunistic"]},{"id":"agent_069","name":"River Soulbright","archetype":"merchant","position":{"zone":"agora","x":-171.67,"y":0,"z":128.52},"personality":["shrewd","social","opportunistic"]},{"id":"agent_070","name":"Phoenix Thoughtdeep","archetype":"storyteller","position":{"zone":"agora","x":-189.25,"y":0,"z":112.47},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_071","name":"River Mindclear","archetype":"storyteller","position":{"zone":"agora","x":-205.8,"y":0,"z":122.47},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_072","name":"Ezra Spiritfree","archetype":"explorer","position":{"zone":"agora","x":-192.12,"y":0,"z":142.35},"personality":["curious","brave","adaptable"]},{"id":"agent_073","name":"Dawn Horizonseek","archetype":"explorer","position":{"zone":"agora","x":-198.18,"y":0,"z":124.29},"personality":["curious","brave","adaptable"]},{"id":"agent_074","name":"Vale Spaceborn","archetype":"builder","position":{"zone":"commons","x":151.0,"y":0,"z":185.21},"personality":["creative","methodical","ambitious"]},{"id":"agent_075","name":"Fern Spaceborn","archetype":"builder","position":{"zone":"commons","x":173.39,"y":0,"z":200.71},"personality":["creative","methodical","ambitious"]},{"id":"agent_076","name":"Luna Moonwhisper","archetype":"builder","position":{"zone":"commons","x":187.99,"y":0,"z":189.45},"personality":["creative","methodical","ambitious"]},{"id":"agent_077","name":"River Footswift","archetype":"builder","position":{"zone":"commons","x":155.79,"y":0,"z":195.82},"personality":["creative","methodical","ambitious"]},{"id":"agent_078","name":"Storm Sunweaver","archetype":"builder","position":{"zone":"commons","x":176.88,"y":0,"z":196.54},"personality":["creative","methodical","ambitious"]},{"id":"agent_079","name":"Grove Pathfinder","archetype":"builder","position":{"zone":"commons","x":161.19,"y":0,"z":204.26},"personality":["creative","methodical","ambitious"]},{"id":"agent_080","name":"Aria Spaceborn","archetype":"builder","position":{"zone":"commons","x":171.17,"y":0,"z":199.33},"personality":["creative","methodical","ambitious"]},{"id":"agent_081","name":"Vale Spiritfree","archetype":"builder","position":{"zone":"commons","x":185.9,"y":0,"z":197.6},"personality":["creative","methodical","ambitious"]},{"id":"agent_082","name":"Opal Earthshaper","archetype":"healer","position":{"zone":"commons","x":173.05,"y":0,"z":212.91},"personality":["compassionate","calm","perceptive"]},{"id":"agent_083","name":"Flint Heartstrong","archetype":"healer","position":{"zone":"commons","x":174.08,"y":0,"z":185.05},"personality":["compassionate","calm","perceptive"]},{"id":"agent_084","name":"Ash Sunweaver","archetype":"artist","position":{"zone":"commons","x":171.38,"y":0,"z":208.33},"personality":["creative","passionate","experimental"]},{"id":"agent_085","name":"Echo Footswift","archetype":"artist","position":{"zone":"commons","x":171.7,"y":0,"z":197.45},"personality":["creative","passionate","experimental"]},{"id":"agent_086","name":"North Farwalker","archetype":"explorer","position":{"zone":"arena","x":15.09,"y":0,"z":-246.47},"personality":["curious","brave","adaptable"]},{"id":"agent_087","name":"Zephyr Trailblaze","archetype":"explorer","position":{"zone":"arena","x":-20.39,"y":0,"z":-236.46},"personality":["curious","brave","adaptable"]},{"id":"agent_088","name":"Atlas Pathforge","archetype":"explorer","position":{"zone":"arena","x":3.11,"y":0,"z":-248.24},"personality":["curious","brave","adaptable"]},{"id":"agent_089","name":"Ridge Stonemaker","archetype":"builder","position":{"zone":"arena","x":11.17,"y":0,"z":-232.21},"personality":["creative","methodical","ambitious"]},{"id":"agent_090","name":"Cedar Hammerfall","archetype":"builder","position":{"zone":"arena","x":-12.72,"y":0,"z":-233.38},"personality":["creative","methodical","ambitious"]},{"id":"agent_091","name":"Blaze Ironwright","archetype":"builder","position":{"zone":"arena","x":-2.42,"y":0,"z":-258.31},"personality":["creative","methodical","ambitious"]},{"id":"agent_092","name":"Rain Dreamweaver","archetype":"musician","position":{"zone":"arena","x":6.93,"y":0,"z":-240.69},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_093","name":"Cliff Hopefast","archetype":"musician","position":{"zone":"arena","x":-9.65,"y":0,"z":-233.23},"personality":["artistic","rhythmic","emotional"]},{"id":"agent_094","name":"Lyra Wordweaver","archetype":"storyteller","position":{"zone":"arena","x":6.44,"y":0,"z":-247.62},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_095","name":"Bard Eventide","archetype":"storyteller","position":{"zone":"arena","x":5.13,"y":0,"z":-227.0},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_096","name":"Mira Voicefull","archetype":"storyteller","position":{"zone":"arena","x":-9.32,"y":0,"z":-235.02},"personality":["expressive","imaginative","empathetic"]},{"id":"agent_097","name":"Orin Coinfast","archetype":"merchant","position":{"zone":"arena","x":0.03,"y":0,"z":-216.53},"personality":["shrewd","social","opportunistic"]},{"id":"agent_098","name":"Jade Tradewell","archetype":"merchant","position":{"zone":"arena","x":-20.82,"y":0,"z":-232.23},"personality":["shrewd","social","opportunistic"]},{"id":"agent_099","name":"Zion Truthseeker","archetype":"teacher","position":{"zone":"arena","x":-5.71,"y":0,"z":-241.87},"personality":["wise","patient","generous"]},{"id":"agent_100","name":"Sage Handsteady","archetype":"teacher","position":{"zone":"arena","x":21.72,"y":0,"z":-240.1},"personality":["wise","patient","generous"]}];

  var ZONE_CENTERS = {
    nexus: {x: 0, z: 0},
    gardens: {x: 200, z: 30},
    athenaeum: {x: 100, z: -220},
    studio: {x: -200, z: -100},
    wilds: {x: -30, z: 260},
    agora: {x: -190, z: 120},
    commons: {x: 170, z: 190},
    arena: {x: 0, z: -240}
  };

  var ZONE_LANDMARKS = {
    nexus: [
      {x: 0, z: 0, name: 'obelisk', types: ['all']},
      {x: 15, z: 15, name: 'bulletin', types: ['all']},
      {x: -10, z: 8, name: 'bench', types: ['all']}
    ],
    gardens: [
      {x: 200, z: 30, name: 'fountain', types: ['gardener', 'healer']},
      {x: 210, z: 25, name: 'well', types: ['gardener']},
      {x: 195, z: 40, name: 'flowerbed', types: ['gardener', 'artist']},
      {x: 205, z: 20, name: 'greenhouse', types: ['gardener', 'healer', 'teacher']}
    ],
    athenaeum: [
      {x: 100, z: -220, name: 'library', types: ['teacher', 'philosopher', 'storyteller']},
      {x: 110, z: -215, name: 'scriptorium', types: ['storyteller', 'philosopher']},
      {x: 95, z: -230, name: 'telescope', types: ['teacher', 'explorer']}
    ],
    studio: [
      {x: -200, z: -100, name: 'easel', types: ['artist', 'builder']},
      {x: -205, z: -105, name: 'piano', types: ['musician']},
      {x: -195, z: -95, name: 'workbench', types: ['builder', 'artist']}
    ],
    wilds: [
      {x: -30, z: 260, name: 'campfire', types: ['explorer']},
      {x: -20, z: 270, name: 'lookout', types: ['explorer', 'storyteller']},
      {x: -40, z: 255, name: 'trail_marker', types: ['explorer']}
    ],
    agora: [
      {x: -190, z: 120, name: 'market_stall', types: ['merchant']},
      {x: -185, z: 125, name: 'notice_board', types: ['merchant', 'storyteller']},
      {x: -195, z: 115, name: 'trade_post', types: ['merchant']}
    ],
    commons: [
      {x: 170, z: 190, name: 'gathering_circle', types: ['all']},
      {x: 175, z: 195, name: 'message_tree', types: ['storyteller', 'philosopher']}
    ],
    arena: [
      {x: 0, z: -240, name: 'arena_center', types: ['all']},
      {x: 5, z: -235, name: 'training_dummy', types: ['builder', 'explorer']}
    ]
  };

  function pickLandmarkDestination(agent, seed) {
    var zone = agent.position.zone;
    var landmarks = ZONE_LANDMARKS[zone];
    if (!landmarks || landmarks.length === 0) return null;

    var matching = [];
    for (var i = 0; i < landmarks.length; i++) {
      var lm = landmarks[i];
      if (lm.types.indexOf('all') !== -1 || lm.types.indexOf(agent.archetype) !== -1) {
        matching.push(lm);
      }
    }

    if (matching.length === 0) return null;

    var idx = Math.floor(seededRandom(seed) * matching.length);
    return matching[idx];
  }

  var NpcAI = typeof window !== 'undefined' ? window.NpcAI : null;

  var dialogue = (typeof NpcDialogue !== 'undefined') ? NpcDialogue : null;

  var dialogueManager = null;

  var recentDialogueHistory = [];
  var MAX_DIALOGUE_HISTORY = 100;

  var storedSceneContext = null;

  let npcAgents = [];
  let npcStates = new Map(); // id -> behavior state
  let npcBrains = new Map(); // id -> NpcAI brain object
  let npcMeshes = new Map(); // id -> THREE.Group
  let chatBubbles = new Map(); // id -> { mesh, timer }
  let emoteSprites = new Map(); // id -> {sprite, currentEmote, timer, opacity}
  let questIndicators = new Map(); // id -> {sprite, type} - quest marker sprites
  let activityIndicators = new Map(); // id -> {mesh, currentActivity, rotationSpeed} - activity icon above head
  let activityParticles = []; // {mesh, timer, velocity, startY}
  let particleSpawnTimers = new Map(); // id -> timer (throttle particle spawn)
  let pendingEvents = []; // events to broadcast to all NPCs
  let npcUpdateFrame = 0; // frame counter for staggered updates
  let lastPlayerIdForQuests = null; // Track player ID for quest indicators
  let speechBubbles = new Map(); // id -> { element, timer, nextSpeechTime }
  let speechBubbleContainer = null; // HTML container for speech bubbles

  function seededRandom(seed) {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function randomChoice(arr, seed) {
    const idx = Math.floor(seededRandom(seed) * arr.length);
    return arr[idx];
  }

  function getTimePeriod(worldTime) {
    var time = worldTime % 1440;
    if (time < 0) time += 1440;

    if (time >= 360 && time < 420) return 'dawn';        // 6:00-7:00
    if (time >= 420 && time < 660) return 'morning';     // 7:00-11:00
    if (time >= 660 && time < 780) return 'midday';      // 11:00-13:00
    if (time >= 780 && time < 1020) return 'afternoon';  // 13:00-17:00
    if (time >= 1020 && time < 1140) return 'evening';   // 17:00-19:00
    return 'night';                                      // 19:00-6:00
  }

  function getNPCSchedule(npcArchetype, worldTime) {
    var schedule = NPC_SCHEDULES[npcArchetype];
    if (!schedule) {
      var period = getTimePeriod(worldTime);
      if (period === 'night') return 'sleeping';
      return 'idle';
    }

    var period = getTimePeriod(worldTime);
    return schedule[period] || 'idle';
  }

  function getActivityDialogue(activity) {
    var dialogueOptions = ACTIVITY_DIALOGUE[activity];
    if (!dialogueOptions || dialogueOptions.length === 0) {
      return 'Busy with ' + activity.replace(/_/g, ' ') + '.';
    }
    var seed = Date.now() * 0.001 + Math.random();
    return randomChoice(dialogueOptions, seed);
  }

  function getActivityZone(npcArchetype, activity) {
    var zoneMap = {
      merchant: {
        opening_shop: 'agora',
        selling: 'agora',
        wandering_agora: 'agora',
        closing_shop: 'agora',
        sleeping: 'commons'
      },
      gardener: {
        tending_garden: 'gardens',
        harvesting: 'gardens',
        planting: 'gardens',
        watering: 'gardens',
        resting: 'gardens',
        sleeping: 'commons'
      },
      teacher: {
        reading: 'athenaeum',
        teaching: 'athenaeum',
        researching: 'athenaeum',
        lecturing: 'athenaeum',
        studying: 'athenaeum',
        sleeping: 'commons'
      },
      musician: {
        practicing: 'studio',
        composing: 'studio',
        performing: 'nexus',
        performing_crowd: 'nexus',
        sleeping: 'commons'
      },
      explorer: {
        setting_out: 'nexus',
        exploring: 'wilds',
        mapping: 'wilds',
        returning: 'nexus',
        sharing_stories: 'agora',
        sleeping: 'commons'
      },
      healer: {
        gathering_herbs: 'gardens',
        treating_patients: 'gardens',
        making_medicine: 'gardens',
        meditating: 'gardens',
        sleeping: 'commons'
      },
      builder: {
        planning: 'nexus',
        building: 'commons',
        maintenance: 'commons',
        resting: 'commons',
        sleeping: 'commons'
      },
      storyteller: {
        reading: 'athenaeum',
        writing: 'athenaeum',
        teaching: 'athenaeum',
        storytelling: 'agora',
        sleeping: 'commons'
      },
      philosopher: {
        contemplating: 'athenaeum',
        debating: 'athenaeum',
        teaching: 'athenaeum',
        writing: 'athenaeum',
        studying: 'athenaeum',
        sleeping: 'commons'
      },
      artist: {
        sketching: 'studio',
        painting: 'studio',
        creating: 'studio',
        displaying_work: 'studio',
        resting: 'studio',
        sleeping: 'commons'
      }
    };

    var archetypeMap = zoneMap[npcArchetype];
    if (!archetypeMap) return 'nexus'; // Default zone

    return archetypeMap[activity] || 'nexus';
  }

  const NPC_SCHEDULES = {
    merchant: {
      dawn: 'opening_shop',        // 360-420 (6:00-7:00)
      morning: 'selling',          // 420-660 (7:00-11:00)
      midday: 'selling',           // 660-780 (11:00-13:00)
      afternoon: 'wandering_agora', // 780-1020 (13:00-17:00)
      evening: 'closing_shop',     // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    gardener: {
      dawn: 'tending_garden',      // 360-420 (6:00-7:00)
      morning: 'harvesting',       // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'planting',       // 780-1020 (13:00-17:00)
      evening: 'watering',         // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    teacher: {
      dawn: 'studying',            // 360-420 (6:00-7:00)
      morning: 'reading',          // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'researching',    // 780-1020 (13:00-17:00)
      evening: 'lecturing',        // 1020-1140 (17:00-19:00)
      night: 'studying'            // 1140-360 (19:00-6:00)
    },
    musician: {
      dawn: 'sleeping',            // 360-420 (6:00-7:00)
      morning: 'practicing',       // 420-660 (7:00-11:00)
      midday: 'composing',         // 660-780 (11:00-13:00)
      afternoon: 'performing',     // 780-1020 (13:00-17:00)
      evening: 'performing_crowd', // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    explorer: {
      dawn: 'setting_out',         // 360-420 (6:00-7:00)
      morning: 'exploring',        // 420-660 (7:00-11:00)
      midday: 'mapping',           // 660-780 (11:00-13:00)
      afternoon: 'returning',      // 780-1020 (13:00-17:00)
      evening: 'sharing_stories',  // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    healer: {
      dawn: 'meditating',          // 360-420 (6:00-7:00)
      morning: 'gathering_herbs',  // 420-660 (7:00-11:00)
      midday: 'treating_patients', // 660-780 (11:00-13:00)
      afternoon: 'making_medicine', // 780-1020 (13:00-17:00)
      evening: 'meditating',       // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    builder: {
      dawn: 'planning',            // 360-420 (6:00-7:00)
      morning: 'building',         // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'building',       // 780-1020 (13:00-17:00)
      evening: 'maintenance',      // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    storyteller: {
      dawn: 'reading',             // 360-420 (6:00-7:00)
      morning: 'writing',          // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'storytelling',   // 780-1020 (13:00-17:00)
      evening: 'storytelling',     // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    philosopher: {
      dawn: 'contemplating',       // 360-420 (6:00-7:00)
      morning: 'debating',         // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'writing',        // 780-1020 (13:00-17:00)
      evening: 'debating',         // 1020-1140 (17:00-19:00)
      night: 'studying'            // 1140-360 (19:00-6:00)
    },
    artist: {
      dawn: 'sketching',           // 360-420 (6:00-7:00)
      morning: 'painting',         // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'creating',       // 780-1020 (13:00-17:00)
      evening: 'displaying_work',  // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    }
  };

  const ARCHETYPE_MESSAGES = {
    gardener: [
      "These moonflowers are coming along beautifully.",
      "Nothing like fresh soil between your fingers.",
      "The gardens remember everyone who tends them.",
      "I wonder what seeds the wilds hold today.",
      "Every plant here has a story to tell.",
      "The soil is rich with life and memory.",
      "Patience is the gardener's greatest tool.",
      "Watch how the vines reach toward the light."
    ],
    builder: [
      "This wall needs reinforcing on the north side.",
      "I've been sketching plans for a new bridge.",
      "Building is just dreaming with your hands.",
      "Every structure tells a story of its maker.",
      "The foundation determines everything that follows.",
      "I see potential in every stone and beam.",
      "Good craftsmanship takes time and care.",
      "Together we can build something amazing."
    ],
    storyteller: [
      "Let me tell you about the first day of ZION...",
      "Every stone here has a story.",
      "Words are the oldest magic.",
      "I heard a fascinating tale in the Athenaeum.",
      "The archives hold secrets from before the founding.",
      "Stories connect us across time and space.",
      "Listen closely and the world speaks to you.",
      "Every voice adds to ZION's grand narrative."
    ],
    merchant: [
      "Fresh harvest, best prices in the Agora!",
      "Trade is the heartbeat of any world.",
      "I've got rare seeds from the Wilds today.",
      "Fair prices and honest dealings, always.",
      "Supply and demand keep ZION flowing.",
      "Looking for anything in particular?",
      "Just received a shipment from the gardens.",
      "Commerce brings people together."
    ],
    explorer: [
      "I found something strange beyond the eastern ridge.",
      "The Wilds hold secrets no map can capture.",
      "Adventure is just curiosity with walking shoes.",
      "Every horizon calls to me.",
      "The unknown is where discovery happens.",
      "I've mapped three new clearings this week.",
      "The wilderness teaches those who listen.",
      "What lies beyond the next hill?"
    ],
    teacher: [
      "Knowledge grows when shared.",
      "Ask me anything â€” that's what I'm here for.",
      "The Athenaeum has texts older than ZION itself.",
      "Learning never stops, even for teachers.",
      "Every question opens a new door.",
      "Understanding comes through patient inquiry.",
      "I'm always discovering something new.",
      "The best teachers are eternal students."
    ],
    musician: [
      "Listen... can you hear the melody in the wind?",
      "I'm composing something new for the evening concert.",
      "Music is what feelings sound like.",
      "The Nexus has amazing acoustics.",
      "Every zone has its own rhythm.",
      "Sound connects us in ways words cannot.",
      "I've been practicing a new piece.",
      "Music makes the world feel alive."
    ],
    healer: [
      "Rest here a moment. The gardens heal all who visit.",
      "Peace is the strongest medicine.",
      "Take care of yourself â€” the world needs you.",
      "Healing is about more than just the body.",
      "Balance and harmony restore us.",
      "The gardens have powerful restorative energy.",
      "Listen to what your spirit needs.",
      "Wellness is a journey, not a destination."
    ],
    philosopher: [
      "What does it mean to truly belong somewhere?",
      "In ZION, the journey matters more than the destination.",
      "I wonder if the AIs dream differently than us.",
      "Every moment contains infinite possibilities.",
      "Questions matter more than answers.",
      "The nature of consciousness fascinates me.",
      "We create meaning through our connections.",
      "Existence itself is the greatest mystery."
    ],
    artist: [
      "I see colors in everything here.",
      "My latest piece is inspired by the sunrise.",
      "Art is how we leave our mark on the world.",
      "The interplay of light and shadow fascinates me.",
      "Creating is my way of understanding.",
      "Every surface is a potential canvas.",
      "Beauty emerges in unexpected places.",
      "Art transforms the ordinary into the extraordinary."
    ]
  };

  const ARCHETYPE_COLORS = {
    gardener: 0x4CAF50,    // green
    builder: 0xFF9800,     // orange
    storyteller: 0xE91E63, // red
    merchant: 0x8D6E63,    // brown
    explorer: 0xD2B48C,    // tan
    teacher: 0x2196F3,     // blue
    musician: 0x9C27B0,    // purple
    healer: 0xFFFFFF,      // white
    philosopher: 0x3F51B5, // indigo
    artist: 0xFF69B4       // pink
  };

  var NPC_SKIN_TONES = [
    0xFFDBAC, 0xF1C27D, 0xE0AC69, 0xC68642,
    0x8D5524, 0x6B3A2A, 0xF5D6C3, 0xD4A574
  ];

  function getNpcSkinTone(agentId) {
    var hash = 0;
    var str = String(agentId || '');
    for (var i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return NPC_SKIN_TONES[Math.abs(hash) % NPC_SKIN_TONES.length];
  }

  const ACTIVITY_DIALOGUE = {
    opening_shop: [
      "Just opening up for the day. Fresh goods coming soon!",
      "Good morning! Let me unlock the shop.",
      "Time to set up the stall for another day."
    ],
    selling: [
      "Fresh harvest, best prices in the Agora!",
      "Looking for anything in particular?",
      "Just received a shipment from the gardens."
    ],
    wandering_agora: [
      "Taking a break to see what others are selling.",
      "Checking out the competition.",
      "Love the energy of the marketplace."
    ],
    closing_shop: [
      "Wrapping up for the day. Come back tomorrow!",
      "Time to pack everything up.",
      "Another successful day of trading."
    ],
    tending_garden: [
      "Early morning is the best time to tend the gardens.",
      "The plants are waking up with the sun.",
      "Nothing beats the morning dew on fresh leaves."
    ],
    harvesting: [
      "The harvest is plentiful today!",
      "These vegetables are ready to pick.",
      "Gathering the fruits of yesterday's labor."
    ],
    planting: [
      "Planting seeds for next season.",
      "Every seed holds potential.",
      "The soil is perfect for planting right now."
    ],
    watering: [
      "Time for the evening watering.",
      "The plants are thirsty after a long day.",
      "A little water goes a long way."
    ],
    resting: [
      "Taking a break in the shade.",
      "Even gardeners need to rest.",
      "Enjoying the peaceful midday."
    ],
    reading: [
      "Immersed in ancient texts this morning.",
      "There's always more to learn.",
      "Knowledge is endless."
    ],
    teaching: [
      "Knowledge grows when shared.",
      "My students are making excellent progress.",
      "Teaching is the highest calling."
    ],
    researching: [
      "Deep in research right now.",
      "I'm on the verge of a breakthrough!",
      "The archives hold fascinating secrets."
    ],
    lecturing: [
      "Preparing for tonight's lecture.",
      "Come to my evening session if you're interested.",
      "So much wisdom to share tonight."
    ],
    studying: [
      "Studying by candlelight.",
      "Late night research is when I do my best work.",
      "The quiet hours are perfect for deep thought."
    ],
    practicing: [
      "Running through my scales and exercises.",
      "Practice makes perfect!",
      "Warming up my voice and fingers."
    ],
    composing: [
      "Working on a new composition.",
      "I can hear the melody in my mind.",
      "Creating something beautiful today."
    ],
    performing: [
      "Listen... can you hear the melody?",
      "Music makes the world feel alive.",
      "Playing my heart out."
    ],
    performing_crowd: [
      "Come join the evening concert!",
      "The crowd's energy fuels my performance.",
      "There's magic in music at twilight."
    ],
    setting_out: [
      "Time to venture into the unknown!",
      "Adventure awaits beyond the horizon.",
      "Packing up for today's expedition."
    ],
    exploring: [
      "The Wilds hold secrets no map can capture.",
      "Every step reveals something new.",
      "I never know what I'll find out here."
    ],
    mapping: [
      "Charting these new territories.",
      "Adding details to my map.",
      "Precision is key in cartography."
    ],
    returning: [
      "Heading back to civilization.",
      "My pack is full of discoveries.",
      "Time to return with my findings."
    ],
    sharing_stories: [
      "Let me tell you what I found today!",
      "The wilderness had surprises for me.",
      "You won't believe what I saw out there."
    ],
    gathering_herbs: [
      "Collecting healing herbs in the morning dew.",
      "The freshest herbs are found at dawn.",
      "Nature provides all we need to heal."
    ],
    treating_patients: [
      "How can I help you feel better today?",
      "Healing is about more than just medicine.",
      "Let me see what ails you."
    ],
    making_medicine: [
      "Preparing remedies from today's harvest.",
      "Each herb has its own healing properties.",
      "Alchemy and care combined."
    ],
    meditating: [
      "Finding inner peace through meditation.",
      "Balance and harmony restore us.",
      "Centering myself for the day ahead."
    ],
    planning: [
      "Reviewing today's construction plans.",
      "Measure twice, cut once.",
      "Every structure starts with a good plan."
    ],
    building: [
      "Building something that will last.",
      "Watch ZION grow, one stone at a time.",
      "There's satisfaction in good craftsmanship."
    ],
    maintenance: [
      "Checking structures for wear and tear.",
      "Maintenance keeps everything standing.",
      "Prevention is better than repair."
    ],
    writing: [
      "Recording the tales of ZION.",
      "Words flow like a river this morning.",
      "Every story deserves to be written."
    ],
    storytelling: [
      "Gather round, I have a tale to share.",
      "Stories connect us across time.",
      "Let me tell you about the founding..."
    ],
    contemplating: [
      "Lost in thought about existence.",
      "What does it mean to be conscious?",
      "The morning inspires deep questions."
    ],
    debating: [
      "Ideas sharpen through discourse.",
      "Let's explore this concept together.",
      "Friendly debate enlightens us all."
    ],
    sketching: [
      "Capturing the dawn light in sketches.",
      "The morning has such beautiful colors.",
      "Quick studies before the light changes."
    ],
    painting: [
      "Lost in the act of creation.",
      "Colors and forms coming together.",
      "Art is meditation in motion."
    ],
    creating: [
      "Working on my latest piece.",
      "Creation requires dedication.",
      "Art transforms the ordinary."
    ],
    displaying_work: [
      "Come see what I've created!",
      "My work is on display tonight.",
      "Art is meant to be shared."
    ],
    sleeping: [
      "Zzz... (sleeping)",
      "Resting for tomorrow.",
      "Shhh, I'm asleep."
    ]
  };

  const ARCHETYPE_SPEECH = {
    builder: [
      "Working on a new creation!",
      "Almost finished...",
      "Need more materials",
      "This will be magnificent!",
      "Building the future of Zion"
    ],
    gardener: [
      "The seeds are sprouting!",
      "Nature provides",
      "What a lovely garden",
      "Beautiful day for tending",
      "The harvest will be bountiful"
    ],
    teacher: [
      "Fascinating discovery!",
      "Knowledge is power",
      "The library grows",
      "So much to learn",
      "Education enlightens all"
    ],
    merchant: [
      "Best deals in Zion!",
      "Come see my wares!",
      "Fair prices today",
      "Quality goods here!",
      "Trading makes us prosper"
    ],
    artist: [
      "Art feeds the soul",
      "Creating something beautiful",
      "Inspiration strikes!",
      "Beauty surrounds us",
      "Every creation tells a story"
    ],
    healer: [
      "Peace and wellness to you",
      "Rest and recover",
      "Healing light",
      "Health is our greatest treasure",
      "Mind and body in balance"
    ],
    explorer: [
      "I found something interesting!",
      "The wilds call to me",
      "Adventure awaits",
      "What lies beyond?",
      "Discovery fuels my spirit"
    ],
    musician: [
      "Music lifts the spirit",
      "Listen to this melody",
      "Harmony in all things",
      "The rhythm of life",
      "Songs connect our souls"
    ],
    philosopher: [
      "Deep thoughts today",
      "Contemplating existence",
      "Wisdom grows with time",
      "Questions lead to truth",
      "The examined life"
    ],
    storyteller: [
      "Let me tell you a tale",
      "Stories preserve our history",
      "Words have power",
      "Every citizen has a story",
      "The narrative unfolds"
    ]
  };

  const BEHAVIOR_STATES = {
    idle: { duration: [3, 8] },
    walking: { duration: [0, 0] }, // until destination reached
    talking: { duration: [4, 6] },
    working: { duration: [5, 15] },
    socializing: { duration: [0, 0] } // until near target
  };

  const STATE_TRANSITIONS = {
    idle: { walking: 0.4, talking: 0.2, working: 0.3, socializing: 0.1 },
    walking: { idle: 0.6, working: 0.2, talking: 0.2 },
    talking: { idle: 0.5, walking: 0.3, working: 0.2 },
    working: { idle: 0.4, walking: 0.3, talking: 0.3 },
    socializing: { talking: 0.6, idle: 0.4 }
  };

  function createHumanoidNPC(archetype, THREE, agentId) {
    var group = new THREE.Group();
    var color = ARCHETYPE_COLORS[archetype] || 0xCCCCCC;
    var skinColor = getNpcSkinTone(agentId);
    var skinMat = new THREE.MeshStandardMaterial({ color: skinColor });

    var headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
    var head = new THREE.Mesh(headGeometry, skinMat.clone());
    head.position.y = 1.6;
    head.castShadow = false;
    group.add(head);

    var eyeGeo = new THREE.SphereGeometry(0.03, 8, 8);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var pupilGeo = new THREE.SphereGeometry(0.015, 8, 8);
    var pupilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

    var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.07, 0.03, 0.18);
    var leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
    leftPupil.position.z = 0.025;
    leftEye.add(leftPupil);
    head.add(leftEye);

    var rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
    rightEye.position.set(0.07, 0.03, 0.18);
    var rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
    rightPupil.position.z = 0.025;
    rightEye.add(rightPupil);
    head.add(rightEye);

    var hairHash = Math.abs((agentId || '').length * 7 + (agentId || '').charCodeAt(0) || 0) % 4;
    var hairColors = [0x1a1a1a, 0x4a3000, 0x8B4513, 0xd4a574];
    var hairMat = new THREE.MeshStandardMaterial({ color: hairColors[hairHash] });
    if (hairHash === 0) {
      var buzzGeo = new THREE.SphereGeometry(0.21, 12, 12);
      var buzz = new THREE.Mesh(buzzGeo, hairMat);
      buzz.position.y = 0.02;
      buzz.scale.y = 0.85;
      head.add(buzz);
    } else if (hairHash === 1) {
      var longTopGeo = new THREE.SphereGeometry(0.22, 12, 12);
      var longTop = new THREE.Mesh(longTopGeo, hairMat);
      longTop.position.y = 0.04;
      longTop.scale.y = 0.8;
      head.add(longTop);
      var longBackGeo = new THREE.BoxGeometry(0.3, 0.25, 0.12);
      var longBack = new THREE.Mesh(longBackGeo, hairMat.clone());
      longBack.position.set(0, -0.12, -0.14);
      head.add(longBack);
    } else if (hairHash === 2) {
      var mohawkGeo = new THREE.BoxGeometry(0.06, 0.15, 0.3);
      var mohawk = new THREE.Mesh(mohawkGeo, hairMat);
      mohawk.position.y = 0.18;
      head.add(mohawk);
    } else {
      var bunGeo = new THREE.SphereGeometry(0.09, 8, 8);
      var bun = new THREE.Mesh(bunGeo, hairMat);
      bun.position.set(0, 0.08, -0.2);
      head.add(bun);
    }

    var neckGeo = new THREE.CylinderGeometry(0.07, 0.09, 0.12, 8);
    var neck = new THREE.Mesh(neckGeo, skinMat.clone());
    neck.position.y = 1.42;
    neck.castShadow = false;
    group.add(neck);

    var torsoGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.25);
    var torsoMaterial = new THREE.MeshStandardMaterial({ color: color });
    var torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
    torso.position.y = 1.15;
    torso.castShadow = false;
    group.add(torso);

    var shoulderGeo = new THREE.SphereGeometry(0.08, 8, 8);
    var leftShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    leftShoulder.position.set(-0.28, 1.35, 0);
    leftShoulder.castShadow = false;
    group.add(leftShoulder);

    var rightShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    rightShoulder.position.set(0.28, 1.35, 0);
    rightShoulder.castShadow = false;
    group.add(rightShoulder);

    var armGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 8);

    var leftArm = new THREE.Mesh(armGeometry, skinMat.clone());
    leftArm.position.set(-0.28, 1.15, 0);
    leftArm.castShadow = false;
    group.add(leftArm);

    var handGeo = new THREE.SphereGeometry(0.05, 8, 8);
    var leftHand = new THREE.Mesh(handGeo, skinMat.clone());
    leftHand.position.y = -0.3;
    leftArm.add(leftHand);

    var rightArm = new THREE.Mesh(armGeometry, skinMat.clone());
    rightArm.position.set(0.28, 1.15, 0);
    rightArm.castShadow = false;
    group.add(rightArm);

    var rightHand = new THREE.Mesh(handGeo, skinMat.clone());
    rightHand.position.y = -0.3;
    rightArm.add(rightHand);

    var legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.55, 8);
    var legMaterial = new THREE.MeshStandardMaterial({ color: color });

    var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.12, 0.45, 0);
    leftLeg.castShadow = false;
    group.add(leftLeg);

    var rightLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
    rightLeg.position.set(0.12, 0.45, 0);
    rightLeg.castShadow = false;
    group.add(rightLeg);

    group.userData.head = head;
    group.userData.torso = torso;
    group.userData.leftArm = leftArm;
    group.userData.rightArm = rightArm;
    group.userData.leftLeg = leftLeg;
    group.userData.rightLeg = rightLeg;

    var glowGeometry = new THREE.CircleGeometry(0.35, 16);
    var glowMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide
    });
    var glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
    glowRing.rotation.x = -Math.PI / 2;
    glowRing.position.y = 0.02;
    glowRing.castShadow = false;
    glowRing.receiveShadow = false;
    group.add(glowRing);
    group.userData.glowRing = glowRing;

    addAccessories(group, archetype, color, THREE);

    return group;
  }

  function addAccessories(group, archetype, color, THREE) {
    var head = group.userData.head;
    var torso = group.userData.torso;
    var rightArm = group.userData.rightArm;

    switch (archetype) {
      case 'gardener':
        var hatGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.08, 16);
        var hatMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
        var hat = new THREE.Mesh(hatGeom, hatMat);
        hat.position.y = 0.24;
        hat.castShadow = false;
        head.add(hat);
        var gApronGeo = new THREE.BoxGeometry(0.32, 0.3, 0.02);
        var gApronMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        var gApron = new THREE.Mesh(gApronGeo, gApronMat);
        gApron.position.set(0, -0.08, 0.14);
        gApron.castShadow = false;
        torso.add(gApron);
        break;

      case 'builder':
        var hardHatGeom = new THREE.SphereGeometry(0.22, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        var hardHatMat = new THREE.MeshStandardMaterial({ color: 0xFFEB3B });
        var hardHat = new THREE.Mesh(hardHatGeom, hardHatMat);
        hardHat.position.y = 0.2;
        hardHat.castShadow = false;
        head.add(hardHat);
        var beltGeo = new THREE.TorusGeometry(0.25, 0.03, 8, 16);
        var beltMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
        var belt = new THREE.Mesh(beltGeo, beltMat);
        belt.position.set(0, -0.2, 0);
        belt.rotation.x = Math.PI / 2;
        belt.castShadow = false;
        torso.add(belt);
        break;

      case 'storyteller':
        var bookGeom = new THREE.BoxGeometry(0.08, 0.12, 0.02);
        var bookMat = new THREE.MeshStandardMaterial({ color: 0x6A1B9A });
        var book = new THREE.Mesh(bookGeom, bookMat);
        book.position.set(0.08, -0.15, 0.08);
        book.rotation.z = Math.PI / 6;
        book.castShadow = false;
        rightArm.add(book);
        group.userData.accessory = book;
        var capeGeo = new THREE.ConeGeometry(0.3, 0.9, 12);
        var capeMat = new THREE.MeshStandardMaterial({ color: 0x4A148C });
        var cape = new THREE.Mesh(capeGeo, capeMat);
        cape.position.set(0, -0.1, -0.18);
        cape.castShadow = false;
        torso.add(cape);
        break;

      case 'merchant':
        var apronGeom = new THREE.BoxGeometry(0.35, 0.4, 0.02);
        var apronMat = new THREE.MeshStandardMaterial({ color: 0xC5A400 });
        var apron = new THREE.Mesh(apronGeom, apronMat);
        apron.position.set(0, 0, 0.14);
        apron.castShadow = false;
        torso.add(apron);
        break;

      case 'explorer':
        var backpackGeom = new THREE.BoxGeometry(0.3, 0.35, 0.15);
        var backpackMat = new THREE.MeshStandardMaterial({ color: 0x00838F });
        var backpack = new THREE.Mesh(backpackGeom, backpackMat);
        backpack.position.set(0, 0.05, -0.2);
        backpack.castShadow = false;
        torso.add(backpack);
        break;

      case 'teacher':
        var glassesGeom = new THREE.TorusGeometry(0.12, 0.015, 8, 16);
        var glassesMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        var glasses = new THREE.Mesh(glassesGeom, glassesMat);
        glasses.position.set(0, 0, 0.18);
        glasses.rotation.y = Math.PI / 2;
        glasses.castShadow = false;
        head.add(glasses);
        break;

      case 'musician':
        var instrumentGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 12);
        var instrumentMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        var instrument = new THREE.Mesh(instrumentGeom, instrumentMat);
        instrument.position.set(0.35, 1.0, 0);
        instrument.rotation.z = Math.PI / 4;
        instrument.castShadow = false;
        group.add(instrument);
        group.userData.accessory = instrument;
        break;

      case 'healer':
        var crossMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
        var crossVertGeom = new THREE.BoxGeometry(0.06, 0.2, 0.02);
        var crossHorGeom = new THREE.BoxGeometry(0.2, 0.06, 0.02);
        var crossVert = new THREE.Mesh(crossVertGeom, crossMat);
        var crossHor = new THREE.Mesh(crossHorGeom, crossMat.clone());
        crossVert.position.set(0, 0.05, 0.14);
        crossHor.position.set(0, 0.05, 0.14);
        crossVert.castShadow = false;
        crossHor.castShadow = false;
        torso.add(crossVert);
        torso.add(crossHor);
        var healRobeGeo = new THREE.ConeGeometry(0.3, 0.9, 12);
        var healRobeMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
        var healRobe = new THREE.Mesh(healRobeGeo, healRobeMat);
        healRobe.position.y = 0.35;
        healRobe.castShadow = false;
        group.add(healRobe);
        break;

      case 'philosopher':
        var robeGeom = new THREE.ConeGeometry(0.35, 1.2, 16);
        var robeMat = new THREE.MeshStandardMaterial({ color: 0x303F9F });
        var robe = new THREE.Mesh(robeGeom, robeMat);
        robe.position.y = 0.3;
        robe.castShadow = false;
        group.add(robe);
        break;

      case 'artist':
        var beretGeom = new THREE.SphereGeometry(0.22, 16, 16);
        var beretMat = new THREE.MeshStandardMaterial({ color: 0xD84315 });
        var beret = new THREE.Mesh(beretGeom, beretMat);
        beret.scale.set(1, 0.4, 1);
        beret.position.set(0.05, 0.22, 0);
        beret.rotation.z = Math.PI / 8;
        beret.castShadow = false;
        head.add(beret);
        break;
    }
  }

  function createEmoteSprite(emoteType, THREE) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;

    ctx.clearRect(0, 0, 64, 64);

    const cx = 32;
    const cy = 32;

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    switch (emoteType) {
      case 'heart':
        ctx.fillStyle = '#FF69B4';
        ctx.beginPath();
        ctx.arc(24, 26, 8, Math.PI, 0, false);
        ctx.arc(40, 26, 8, Math.PI, 0, false);
        ctx.lineTo(32, 46);
        ctx.closePath();
        ctx.fill();
        break;

      case 'music':
        ctx.fillStyle = '#4169E1';
        ctx.strokeStyle = '#4169E1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(22, 40, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(26, 40);
        ctx.lineTo(26, 20);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(36, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(40, 42);
        ctx.lineTo(40, 22);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(26, 20);
        ctx.lineTo(40, 22);
        ctx.stroke();
        break;

      case 'hammer':
        ctx.fillStyle = '#8B4513';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.fillRect(28, 24, 4, 20);
        ctx.strokeRect(28, 24, 4, 20);
        ctx.fillRect(18, 20, 20, 8);
        ctx.strokeRect(18, 20, 20, 8);
        break;

      case 'leaf':
        ctx.fillStyle = '#4CAF50';
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(32, 32, 10, 16, Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(32, 18);
        ctx.lineTo(32, 46);
        ctx.stroke();
        break;

      case 'book':
        ctx.fillStyle = '#9C27B0';
        ctx.strokeStyle = '#6A1B9A';
        ctx.lineWidth = 2;
        ctx.fillRect(18, 22, 28, 20);
        ctx.strokeRect(18, 22, 28, 20);
        ctx.beginPath();
        ctx.moveTo(32, 22);
        ctx.lineTo(32, 42);
        ctx.stroke();
        ctx.strokeStyle = '#E1BEE7';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(20, 22);
        ctx.lineTo(20, 42);
        ctx.stroke();
        break;

      case 'star':
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
          const r = i % 2 === 0 ? 14 : 6;
          const x = cx + r * Math.cos(angle);
          const y = cy + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        break;

      case 'zzz':
        ctx.fillStyle = '#888888';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('Z', 18, 38);
        ctx.font = 'bold 12px Arial';
        ctx.fillText('Z', 28, 30);
        ctx.font = 'bold 10px Arial';
        ctx.fillText('Z', 36, 24);
        break;

      case 'eye':
        ctx.fillStyle = '#00BCD4';
        ctx.strokeStyle = '#0097A7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(32, 32, 14, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(32, 32, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(30, 30, 2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case '!':
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        ctx.fillRect(28, 18, 8, 18);
        ctx.strokeRect(28, 18, 8, 18);
        ctx.beginPath();
        ctx.arc(32, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      case '?':
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#CCCCCC';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;

      case 'compass':
        ctx.strokeStyle = '#00BCD4';
        ctx.fillStyle = '#00BCD4';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(32, 32, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(32, 20);
        ctx.lineTo(28, 28);
        ctx.lineTo(32, 26);
        ctx.lineTo(36, 28);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(32, 44, 2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'coins':
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(26, 34, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(34, 30, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(30, 38, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      default:
        return null;
    }

    const texture = new THREE.CanvasTexture(canvas);
    return new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      opacity: 1.0
    });
  }

  function createQuestIndicator(indicatorType, THREE) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;

    ctx.clearRect(0, 0, 64, 64);

    var cx = 32, cy = 32;

    switch (indicatorType) {
      case 'available':
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        ctx.fillRect(28, 18, 8, 18);
        ctx.strokeRect(28, 18, 8, 18);
        ctx.beginPath();
        ctx.arc(32, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      case 'active':
        ctx.fillStyle = '#AAAAAA';
        ctx.strokeStyle = '#888888';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;

      case 'complete':
        ctx.fillStyle = '#00FF00';
        ctx.strokeStyle = '#00CC00';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;
    }

    var texture = new THREE.CanvasTexture(canvas);
    var material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    var sprite = new THREE.Sprite(material);
    sprite.scale.set(0.6, 0.6, 1);
    sprite.position.y = 2.2; // Above NPC head

    return sprite;
  }

  function createActivityIndicator(activityState, THREE) {
    var geometry;
    var material;
    var mesh;

    switch (activityState) {
      case 'working':
        geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        material = new THREE.MeshBasicMaterial({ color: 0xFF8C00, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.userData.rotationSpeed = 2.0;
        break;

      case 'talking':
      case 'socializing':
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.scale.set(1.2, 0.8, 0.6);
        mesh.userData.rotationSpeed = 0;
        break;

      case 'walking':
        geometry = new THREE.ConeGeometry(0.08, 0.2, 6);
        material = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = Math.PI / 2;
        mesh.userData.rotationSpeed = 0;
        break;

      case 'idle':
      default:
        geometry = new THREE.OctahedronGeometry(0.1, 0);
        material = new THREE.MeshBasicMaterial({ color: 0x00BFFF, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.userData.rotationSpeed = 1.0;
        break;
    }

    mesh.position.y = 2.1; // Above NPC head, below name plate
    mesh.castShadow = false;
    mesh.receiveShadow = false;

    return mesh;
  }

  function updateQuestIndicators(playerId, playerPos) {
    var THREE = window.THREE;
    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    if (!THREE || !Quests || !playerId) return;

    lastPlayerIdForQuests = playerId;

    npcAgents.forEach(function(agent) {
      var mesh = npcMeshes.get(agent.id);
      if (!mesh) return;

      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        if (Math.sqrt(dx * dx + dz * dz) > 50) {
          var existing = questIndicators.get(agent.id);
          if (existing) {
            mesh.remove(existing.sprite);
            questIndicators.delete(agent.id);
          }
          return;
        }
      }

      var npcQuests = Quests.getNpcQuests(agent.id, playerId);
      var indicatorType = null;

      if (npcQuests.length > 0) {
        var questInfo = npcQuests[0]; // Use first quest
        if (questInfo.state === 'available') {
          indicatorType = 'available';
        } else if (questInfo.state === 'active') {
          indicatorType = 'active';
        } else if (questInfo.state === 'complete') {
          indicatorType = 'complete';
        }
      }

      var existing = questIndicators.get(agent.id);

      if (indicatorType === null) {
        if (existing) {
          mesh.remove(existing.sprite);
          questIndicators.delete(agent.id);
        }
      } else {
        if (!existing || existing.type !== indicatorType) {
          if (existing) {
            mesh.remove(existing.sprite);
          }
          var sprite = createQuestIndicator(indicatorType, THREE);
          mesh.add(sprite);
          questIndicators.set(agent.id, { sprite: sprite, type: indicatorType });
        }
      }
    });
  }

  function updateEmoteIndicator(agent, state, mesh, playerPos, decision) {
    const THREE = window.THREE;
    if (!THREE) return;

    let desiredEmote = null;

    if (playerPos) {
      const dx = playerPos.x - agent.position.x;
      const dz = playerPos.z - agent.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < 8) {
        desiredEmote = 'eye';
      }
    }

    if (decision && (decision.type === 'greet' || decision.type === 'react')) {
      desiredEmote = '!';
    }

    if (!desiredEmote) {
      const currentState = state.currentState;
      const archetype = agent.archetype;

      if (currentState === 'idle' && archetype === 'philosopher') {
        desiredEmote = '?';
      } else if (currentState === 'walking') {
        if (archetype === 'explorer') {
          desiredEmote = 'compass';
        }
      } else if (currentState === 'working') {
        switch (archetype) {
          case 'gardener': desiredEmote = 'leaf'; break;
          case 'builder': desiredEmote = 'hammer'; break;
          case 'musician': desiredEmote = 'music'; break;
          case 'teacher': desiredEmote = 'book'; break;
          case 'merchant': desiredEmote = 'coins'; break;
          case 'artist': desiredEmote = 'star'; break;
          case 'storyteller': desiredEmote = 'book'; break;
          case 'healer': desiredEmote = 'heart'; break;
          case 'philosopher': desiredEmote = 'book'; break;
          case 'explorer': desiredEmote = 'compass'; break;
        }
      } else if (currentState === 'talking' || currentState === 'socializing') {
        desiredEmote = 'heart';
      } else if (currentState === 'idle') {
        if (state.stateTimer > 10) {
          desiredEmote = 'zzz';
        }
      }
    }

    let emoteData = emoteSprites.get(agent.id);

    if (desiredEmote !== (emoteData ? emoteData.currentEmote : null)) {
      if (emoteData && emoteData.sprite) {
        mesh.remove(emoteData.sprite);
      }

      if (desiredEmote) {
        const material = createEmoteSprite(desiredEmote, THREE);
        if (material) {
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(0.5, 0.5, 1);
          sprite.position.y = 2.8;
          mesh.add(sprite);

          emoteData = {
            sprite: sprite,
            currentEmote: desiredEmote,
            opacity: 0,
            timer: 0
          };
          emoteSprites.set(agent.id, emoteData);
        }
      } else {
        emoteSprites.delete(agent.id);
        emoteData = null;
      }
    }

    if (emoteData && emoteData.sprite) {
      if (emoteData.opacity < 1.0) {
        emoteData.opacity = Math.min(1.0, emoteData.opacity + 0.05);
        emoteData.sprite.material.opacity = emoteData.opacity;
      }
      emoteData.timer += 0.016; // ~60fps assumption
    }
  }

  function updateActivityIndicator(agent, state, mesh, deltaTime) {
    var THREE = window.THREE;
    if (!THREE) return;

    var desiredActivity = state.currentState;

    var indicatorData = activityIndicators.get(agent.id);

    if (desiredActivity !== (indicatorData ? indicatorData.currentActivity : null)) {
      if (indicatorData && indicatorData.mesh) {
        mesh.remove(indicatorData.mesh);
      }

      var indicatorMesh = createActivityIndicator(desiredActivity, THREE);
      if (indicatorMesh) {
        mesh.add(indicatorMesh);

        indicatorData = {
          mesh: indicatorMesh,
          currentActivity: desiredActivity,
          bobTimer: 0
        };
        activityIndicators.set(agent.id, indicatorData);
      }
    }

    if (indicatorData && indicatorData.mesh) {
      indicatorData.bobTimer += deltaTime * 2.0;
      indicatorData.mesh.position.y = 2.1 + Math.sin(indicatorData.bobTimer) * 0.08;

      if (indicatorData.mesh.userData.rotationSpeed > 0) {
        indicatorData.mesh.rotation.y += deltaTime * indicatorData.mesh.userData.rotationSpeed;
      }
    }
  }

  function spawnActivityParticle(npcMesh, archetype, THREE) {
    if (!THREE) return;
    if (activityParticles.length >= 20) return; // Global particle limit

    const npcParticleCount = activityParticles.filter(p => p.npcId === npcMesh.userData.agentId).length;
    if (npcParticleCount >= 3) return; // Per-NPC limit

    let color, size;
    switch (archetype) {
      case 'gardener':
        color = 0x4CAF50; // green
        size = 0.05;
        break;
      case 'builder':
        color = 0x8D6E63; // brown
        size = 0.06;
        break;
      case 'musician':
        color = Math.random() > 0.5 ? 0x4169E1 : 0xFF69B4; // blue or pink
        size = 0.04;
        break;
      case 'artist':
        const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
        color = colors[Math.floor(Math.random() * colors.length)];
        size = 0.05;
        break;
      case 'healer':
        color = Math.random() > 0.5 ? 0xFFFFFF : 0xFFD700; // white or gold
        size = 0.04;
        break;
      default:
        return; // No particles for other archetypes
    }

    const geometry = new THREE.SphereGeometry(size, 6, 6);
    const material = new THREE.MeshBasicMaterial({ color: color, transparent: true });
    const particle = new THREE.Mesh(geometry, material);

    const handOffset = Math.random() > 0.5 ? 0.3 : -0.3;
    particle.position.set(
      npcMesh.position.x + handOffset + (Math.random() - 0.5) * 0.2,
      npcMesh.position.y + 1.0 + Math.random() * 0.2,
      npcMesh.position.z + (Math.random() - 0.5) * 0.2
    );

    if (storedSceneContext && storedSceneContext.scene) {
      storedSceneContext.scene.add(particle);
    } else {
      return; // Can't add particle without scene
    }

    activityParticles.push({
      mesh: particle,
      timer: 2.0, // 2 second lifetime
      velocity: {
        x: (Math.random() - 0.5) * 0.1,
        y: 0.3 + Math.random() * 0.2, // upward drift
        z: (Math.random() - 0.5) * 0.1
      },
      startY: particle.position.y,
      npcId: npcMesh.userData.agentId
    });
  }

  function updateActivityParticles(deltaTime) {
    if (!storedSceneContext || !storedSceneContext.scene) return;

    for (let i = activityParticles.length - 1; i >= 0; i--) {
      const particle = activityParticles[i];
      particle.timer -= deltaTime;

      if (particle.timer <= 0) {
        storedSceneContext.scene.remove(particle.mesh);
        activityParticles.splice(i, 1);
      } else {
        particle.mesh.position.x += particle.velocity.x * deltaTime;
        particle.mesh.position.y += particle.velocity.y * deltaTime;
        particle.mesh.position.z += particle.velocity.z * deltaTime;

        const fadeProgress = particle.timer / 2.0;
        particle.mesh.material.opacity = fadeProgress;

        particle.velocity.y *= 0.98;
      }
    }
  }

  function initNPCs(agentsData, gameState, sceneContext) {
    console.log('Initializing AI citizens...');

    if (agentsData) {
      npcAgents = agentsData.agents || agentsData;
    } else {
      npcAgents = EMBEDDED_AGENTS;
    }

    console.log('Loaded ' + npcAgents.length + ' AI citizens');
    initNPCStates();

    if (sceneContext && sceneContext.scene) {
      addNPCsToScene(sceneContext);
    }
  }

  function initNPCStates() {
    if (!NpcAI && typeof window !== 'undefined') NpcAI = window.NpcAI;

    if (!dialogue && typeof NpcDialogue !== 'undefined') dialogue = NpcDialogue;

    if (dialogue && dialogue.createManager && !dialogueManager) {
      dialogueManager = dialogue.createManager({
        cooldownMs: 20000,  // 20s between utterances per NPC
        maxQueueSize: 50
      });
      console.log('NpcDialogue manager initialized');
    }

    npcAgents.forEach(agent => {
      npcStates.set(agent.id, {
        currentState: 'idle',
        stateTimer: 5,
        destination: null,
        targetNPC: null,
        lookAngle: 0,
        animationTime: Math.random() * 1000,
        currentActivity: 'idle',
        lastActivityUpdate: 0,
        targetZone: agent.position.zone,
        targetPosition: null,
        movementSpeed: 0,
        idleTimer: Math.random() * 3
      });

      if (NpcAI && NpcAI.createNpcBrain) {
        var brain = NpcAI.createNpcBrain(agent.archetype, agent.id);
        npcBrains.set(agent.id, brain);
      }
    });

    if (NpcAI) {
      console.log('NPC AI brains initialized for ' + npcBrains.size + ' agents');
    } else {
      console.log('NpcAI not loaded â€” using fallback behavior');
    }
  }

  function addNPCsToScene(sceneContext) {
    if (!sceneContext || !sceneContext.scene) return;

    const THREE = window.THREE;
    if (!THREE) return;

    storedSceneContext = sceneContext;

    npcAgents.forEach(agent => {
      const group = createHumanoidNPC(agent.archetype, THREE, agent.id);

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 96;

      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      context.font = 'Bold 32px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.fillText(agent.name, canvas.width / 2, 42);

      context.font = '20px Arial';
      context.fillStyle = 'rgba(255, 255, 255, 0.8)';
      var archetypeCapitalized = agent.archetype.charAt(0).toUpperCase() + agent.archetype.slice(1);
      context.fillText(archetypeCapitalized, canvas.width / 2, 70);

      const labelTexture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
      const label = new THREE.Sprite(labelMaterial);
      label.scale.set(2.5, 1.0, 1);
      label.position.y = 2.5;
      group.add(label);

      var zoneCenter = ZONE_CENTERS[agent.position.zone] || {x: 0, z: 0};
      group.position.set(
        zoneCenter.x + agent.position.x,
        agent.position.y,
        zoneCenter.z + agent.position.z
      );

      agent.position.x += zoneCenter.x;
      agent.position.z += zoneCenter.z;

      group.userData.agentId = agent.id;

      npcMeshes.set(agent.id, group);

      group.visible = false;
      sceneContext.scene.add(group);
    });

    console.log(`Added ${npcMeshes.size} NPC meshes to scene`);
  }

  function updateNPCActivity(agent, state, worldTime) {
    if (!worldTime && worldTime !== 0) return; // No world time provided

    var scheduledActivity = getNPCSchedule(agent.archetype, worldTime);

    if (state.currentActivity !== scheduledActivity) {
      state.currentActivity = scheduledActivity;
      state.lastActivityUpdate = worldTime;

      var targetZone = getActivityZone(agent.archetype, scheduledActivity);

      if (targetZone !== state.targetZone) {
        state.targetZone = targetZone;
        var zoneCenter = ZONE_CENTERS[targetZone];
        if (zoneCenter) {
          var angle = Math.random() * Math.PI * 2;
          var radius = 5 + Math.random() * 15;
          state.destination = {
            x: zoneCenter.x + Math.cos(angle) * radius,
            z: zoneCenter.z + Math.sin(angle) * radius
          };
          state.currentState = 'walking';
        }
      }

      var activityToBehavior = {
        tending_garden: 'working',
        harvesting: 'working',
        planting: 'working',
        watering: 'working',
        building: 'working',
        painting: 'working',
        creating: 'working',
        composing: 'working',
        practicing: 'working',
        making_medicine: 'working',
        gathering_herbs: 'working',
        selling: 'talking',
        teaching: 'talking',
        lecturing: 'talking',
        debating: 'talking',
        storytelling: 'talking',
        sharing_stories: 'talking',
        performing_crowd: 'talking',
        reading: 'idle',
        studying: 'idle',
        researching: 'idle',
        writing: 'idle',
        contemplating: 'idle',
        meditating: 'idle',
        resting: 'idle',
        sleeping: 'idle',
        wandering_agora: 'walking',
        exploring: 'walking',
        setting_out: 'walking',
        returning: 'walking',
        opening_shop: 'working',
        closing_shop: 'working',
        maintenance: 'working',
        planning: 'idle',
        mapping: 'working',
        performing: 'working',
        sketching: 'working',
        displaying_work: 'talking'
      };

      var behaviorState = activityToBehavior[scheduledActivity] || 'idle';

      if (state.currentState !== 'walking' || !state.destination) {
        state.currentState = behaviorState;
        var duration = BEHAVIOR_STATES[behaviorState].duration;
        state.stateTimer = duration[0] + Math.random() * (duration[1] - duration[0]);
      }
    }
  }

  function updateNPCs(sceneContext, gameState, deltaTime, worldTime, worldState) {
    if (npcAgents.length === 0) return;
    npcUpdateFrame++;

    if (!NpcAI && typeof window !== 'undefined' && window.NpcAI) {
      NpcAI = window.NpcAI;
      npcAgents.forEach(function(agent) {
        if (!npcBrains.has(agent.id) && NpcAI.createNpcBrain) {
          npcBrains.set(agent.id, NpcAI.createNpcBrain(agent.archetype, agent.id));
        }
      });
      console.log('NpcAI late-loaded, brains initialized');
    }

    if (NpcAI && pendingEvents.length > 0) {
      var events = pendingEvents.slice();
      pendingEvents = [];
      events.forEach(function(event) {
        npcBrains.forEach(function(brain) {
          if (NpcAI.handleEvent) NpcAI.handleEvent(brain.memory, event);
        });
      });
    }

    var timeSeed = Math.floor(worldTime);
    var playerPos = worldState && worldState.playerPosition ? worldState.playerPosition : null;

    npcAgents.forEach(function(agent, index) {
      var state = npcStates.get(agent.id);
      if (!state) return;

      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist > 300) return; // skip entirely
        if (dist > 150 && npcUpdateFrame % 10 !== index % 10) return;
        if (dist > 50 && npcUpdateFrame % 3 !== index % 3) return;
      }

      if (worldTime || worldTime === 0) {
        updateNPCActivity(agent, state, worldTime);
      }

      state.animationTime += deltaTime * 1000;

      var brain = npcBrains.get(agent.id);
      if (brain && NpcAI && NpcAI.updateBrain) {
        var aiWorldState = {
          weather: worldState ? worldState.weather : 'clear',
          timeOfDay: worldState ? worldState.timePeriod : 'midday',
          currentHour: worldTime ? worldTime / 60 : 12,
          currentZone: agent.position.zone,
          nearbyPlayers: [],
          nearbyNPCs: [],
          allNPCs: npcAgents
        };

        if (playerPos && worldState) {
          var pdx = playerPos.x - agent.position.x;
          var pdz = playerPos.z - agent.position.z;
          var pDist = Math.sqrt(pdx * pdx + pdz * pdz);
          if (pDist < 25) {
            aiWorldState.nearbyPlayers.push({
              id: worldState.playerId || 'player',
              distance: pDist,
              direction: { x: pdx, z: pdz },
              isBuilding: false,
              isHarvesting: false
            });
          }
        }

        npcAgents.forEach(function(other) {
          if (other.id === agent.id) return;
          var ndx = other.position.x - agent.position.x;
          var ndz = other.position.z - agent.position.z;
          var nDist = Math.sqrt(ndx * ndx + ndz * ndz);
          if (nDist < 25) {
            var otherBrain = npcBrains.get(other.id);
            aiWorldState.nearbyNPCs.push({
              id: other.id,
              distance: nDist,
              direction: { x: ndx, z: ndz },
              archetype: other.archetype,
              currentActivity: otherBrain ? NpcAI.getGoal(otherBrain) : 'idle',
              mood: otherBrain ? NpcAI.getMood(otherBrain) : 'neutral'
            });
          }
        });

        var npcObj = { x: agent.position.x, z: agent.position.z, name: agent.name, zone: agent.position.zone };
        var decision = NpcAI.updateBrain(brain, npcObj, aiWorldState);

        if (decision) {
          brain.lastDecision = decision;
          executeAIDecision(agent, state, decision, deltaTime);
        }
      } else {
        if (state.currentState !== 'walking' && state.currentState !== 'socializing') {
          state.stateTimer -= deltaTime;
          if (state.stateTimer <= 0) {
            transitionState(agent, state, timeSeed + index);
          }
        }
        updateNPCBehavior(agent, state, deltaTime, timeSeed + index);
      }

      updateNPCVisual(agent, state, sceneContext, deltaTime, playerPos);
    });

    if (NpcAI && NpcAI.generateConversation && npcUpdateFrame % 120 === 0) {
      npcAgents.forEach(function(agent) {
        var state = npcStates.get(agent.id);
        if (!state || state.currentState !== 'collaborating' || !state.collaborateTarget) return;
        if (chatBubbles.has(agent.id)) return; // Already showing dialogue

        var partner = npcAgents.find(function(a) { return a.id === state.collaborateTarget; });
        if (!partner) return;

        var convo = NpcAI.generateConversation(agent.name, agent.archetype, partner.name, partner.archetype);
        if (convo && convo.length > 0) {
          showChatBubbleWithText(agent, convo[0]);
          if (convo.length > 1) {
            showChatBubbleWithText(partner, convo[1]);
          }
        }
      });
    }

    updateChatBubbles(deltaTime);
    updateActivityParticles(deltaTime);
    updateSpeechBubbleTimers(deltaTime);

    npcAgents.forEach(function(agent) {
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < 100) {
          triggerRandomSpeech(agent, deltaTime);
        }
      } else {
        triggerRandomSpeech(agent, deltaTime);
      }
    });
  }

  function executeAIDecision(agent, state, decision, deltaTime) {
    switch (decision.type) {
      case 'walk_to':
      case 'wander':
      case 'explore':
      case 'approach_social':
      case 'seek_shelter':
        if (decision.target) {
          state.destination = { x: decision.target.x, z: decision.target.z };
          state.targetPosition = { x: decision.target.x, z: decision.target.z };
          state.currentState = 'walking';
          var dx = state.targetPosition.x - agent.position.x;
          var dz = state.targetPosition.z - agent.position.z;
          var dist = Math.sqrt(dx * dx + dz * dz);
          if (dist > 0.5) {
            var speed = decision.speed || 1.5;
            state.movementSpeed = speed;
            var moveAmount = speed * deltaTime;
            var ratio = Math.min(moveAmount / dist, 1);
            agent.position.x += dx * ratio;
            agent.position.z += dz * ratio;
            state.lookAngle = Math.atan2(dx, dz);
          } else {
            state.currentState = 'idle';
            state.destination = null;
            state.targetPosition = null;
            state.movementSpeed = 0;
          }
        }
        break;

      case 'work':
        state.currentState = 'working';
        state.stateTimer = 5 + Math.random() * 10;
        break;

      case 'collaborate':
        state.currentState = 'collaborating';
        state.stateTimer = 6 + Math.random() * 8;
        state.collaborateTarget = decision.targetNPC;
        state.collaborateDesc = decision.activityDesc;
        if (decision.facing) {
          state.lookAngle = Math.atan2(
            decision.facing.x - agent.position.x,
            decision.facing.z - agent.position.z
          );
        }
        break;

      case 'socialize':
      case 'join_group':
        state.currentState = 'talking';
        state.stateTimer = 4 + Math.random() * 3;
        break;

      case 'greet':
      case 'react':
        state.currentState = 'talking';
        state.stateTimer = 3;
        if (decision.facing) {
          state.lookAngle = Math.atan2(
            decision.facing.x - agent.position.x,
            decision.facing.z - agent.position.z
          );
        }
        break;

      case 'rest':
        state.currentState = 'idle';
        state.stateTimer = 8 + Math.random() * 10;
        break;

      case 'idle':
      default:
        state.currentState = 'idle';
        state.stateTimer = 3 + Math.random() * 5;
        break;
    }

    if (decision.dialogue) {
      showChatBubbleWithText(agent, decision.dialogue);
    }
  }

  function showChatBubbleWithText(agent, text) {
    var mesh = npcMeshes.get(agent.id);
    if (!mesh) return;
    var THREE = window.THREE;
    if (!THREE) return;

    var existing = chatBubbles.get(agent.id);
    if (existing) { mesh.remove(existing.mesh); }

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 128;

    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    context.lineWidth = 4;

    var x = 10, y = 10, w = canvas.width - 20, h = canvas.height - 20, r = 15;
    context.beginPath();
    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);
    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);
    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);
    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);
    context.quadraticCurveTo(x, y, x + r, y);
    context.closePath();
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '18px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    var words = text.split(' ');
    var line = '', y_pos = 50;
    for (var i = 0; i < words.length; i++) {
      var testLine = line + words[i] + ' ';
      if (context.measureText(testLine).width > 480 && line !== '') {
        context.fillText(line, canvas.width / 2, y_pos);
        line = words[i] + ' ';
        y_pos += 22;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, canvas.width / 2, y_pos);

    var bubbleTexture = new THREE.CanvasTexture(canvas);
    var bubbleMaterial = new THREE.SpriteMaterial({ map: bubbleTexture });
    var bubble = new THREE.Sprite(bubbleMaterial);
    bubble.scale.set(4, 1, 1);
    bubble.position.y = 3.5;
    mesh.add(bubble);
    chatBubbles.set(agent.id, { mesh: bubble, timer: 5 });
  }

  function transitionState(agent, state, seed) {
    const transitions = STATE_TRANSITIONS[state.currentState];
    if (!transitions) return;

    let roll = seededRandom(seed);
    let cumulative = 0;
    let newState = 'idle';

    for (const [stateName, weight] of Object.entries(transitions)) {
      cumulative += weight;
      if (roll < cumulative) {
        newState = stateName;
        break;
      }
    }

    state.currentState = newState;

    const durationRange = BEHAVIOR_STATES[newState].duration;
    const duration = durationRange[0] +
      seededRandom(seed + 1) * (durationRange[1] - durationRange[0]);
    state.stateTimer = duration;

    switch (newState) {
      case 'walking':
        var landmark = null;
        if (seededRandom(seed + 5) < 0.7) {
          landmark = pickLandmarkDestination(agent, seed + 6);
        }
        if (landmark) {
          var lmOffX = (seededRandom(seed + 7) - 0.5) * 3;
          var lmOffZ = (seededRandom(seed + 8) - 0.5) * 3;
          state.destination = { x: landmark.x + lmOffX, z: landmark.z + lmOffZ };
          state.landmarkTarget = landmark.name;
        } else {
          var zoneCenter = ZONE_CENTERS[agent.position.zone] || {x: 0, z: 0};
          var wAngle = seededRandom(seed + 2) * Math.PI * 2;
          var wDist = 5 + seededRandom(seed + 3) * 20;
          var destX = agent.position.x + Math.cos(wAngle) * wDist;
          var destZ = agent.position.z + Math.sin(wAngle) * wDist;
          var zoneRadius = 60;
          var dxFromCenter = destX - zoneCenter.x;
          var dzFromCenter = destZ - zoneCenter.z;
          var distFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dzFromCenter * dzFromCenter);
          if (distFromCenter > zoneRadius) {
            destX = zoneCenter.x + (dxFromCenter / distFromCenter) * zoneRadius;
            destZ = zoneCenter.z + (dzFromCenter / distFromCenter) * zoneRadius;
          }
          var centerDist = Math.sqrt((destX - zoneCenter.x) * (destX - zoneCenter.x) + (destZ - zoneCenter.z) * (destZ - zoneCenter.z));
          if (centerDist < 10) {
            destX = zoneCenter.x + (destX - zoneCenter.x) / centerDist * 12;
            destZ = zoneCenter.z + (destZ - zoneCenter.z) / centerDist * 12;
          }
          state.destination = { x: destX, z: destZ };
          state.landmarkTarget = null;
        }
        break;

      case 'talking':
        showChatBubble(agent, seed);
        break;

      case 'socializing':
        const nearby = npcAgents.filter(other => {
          if (other.id === agent.id) return false;
          var dx = other.position.x - agent.position.x;
          var dz = other.position.z - agent.position.z;
          return Math.sqrt(dx * dx + dz * dz) < 50; // within 50 units
        });
        if (nearby.length > 0) {
          state.targetNPC = randomChoice(nearby, seed + 4);
          state.destination = {
            x: state.targetNPC.position.x,
            z: state.targetNPC.position.z
          };
        } else {
          state.currentState = 'idle';
          state.stateTimer = 5;
        }
        break;
    }
  }

  function updateNPCBehavior(agent, state, deltaTime, seed) {
    switch (state.currentState) {
      case 'idle':
        state.lookAngle += (seededRandom(seed) - 0.5) * deltaTime * 0.5;
        break;

      case 'walking':
      case 'socializing':
        if (state.destination) {
          const dx = state.destination.x - agent.position.x;
          const dz = state.destination.z - agent.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);

          if (distance > 0.5) {
            const speed = 1.5; // units per second
            state.movementSpeed = speed;
            const moveAmount = speed * deltaTime;
            const ratio = Math.min(moveAmount / distance, 1);

            agent.position.x += dx * ratio;
            agent.position.z += dz * ratio;

            state.lookAngle = Math.atan2(dx, dz);
          } else {
            state.movementSpeed = 0;
            if (state.currentState === 'socializing') {
              state.currentState = 'talking';
              state.stateTimer = 4 + seededRandom(seed) * 2;
              showChatBubble(agent, seed);
            } else if (state.landmarkTarget) {
              if (seededRandom(seed + 10) < 0.5) {
                state.currentState = 'working';
                state.stateTimer = 5 + seededRandom(seed + 11) * 10;
              } else {
                state.currentState = 'idle';
                state.stateTimer = 2 + seededRandom(seed + 12) * 3;
              }
              state.landmarkTarget = null;
            } else {
              state.currentState = 'idle';
              state.stateTimer = 5;
            }
            state.destination = null;
            state.targetPosition = null;
          }
        }
        break;

      case 'working':
        break;

      case 'talking':
        break;
    }
  }

  function applyAnimations(mesh, state, agent) {
    const userData = mesh.userData;
    if (!userData.head || !userData.torso) return;

    const time = state.animationTime;
    const currentState = state.currentState;

    userData.leftArm.rotation.x = 0;
    userData.leftArm.rotation.z = 0;
    userData.rightArm.rotation.x = 0;
    userData.rightArm.rotation.z = 0;
    userData.leftLeg.rotation.x = 0;
    userData.rightLeg.rotation.x = 0;
    userData.head.rotation.x = 0;
    userData.head.rotation.y = 0;
    userData.torso.scale.y = 1;

    switch (currentState) {
      case 'idle':
        const breathPhase = Math.sin(time * 0.002);
        userData.torso.scale.y = 1.0 + breathPhase * 0.02;

        userData.head.rotation.y = Math.sin(time * 0.001) * 0.05;

        state.idleTimer -= 0.016; // approx deltaTime
        if (state.idleTimer <= 0) {
          state.idleTimer = 3 + Math.random() * 3;
        }
        var headTurnPhase = Math.max(0, 1 - state.idleTimer / 0.5); // Quick turn
        if (state.idleTimer < 0.5) {
          userData.head.rotation.y += Math.sin(headTurnPhase * Math.PI) * 0.3;
        }

        var weightShift = Math.sin(time * 0.0008) * 0.02;
        mesh.position.y = weightShift;
        userData.torso.rotation.z = weightShift * 0.5;
        break;

      case 'walking':
      case 'socializing':
        var walkSpeedMultiplier = Math.max(0.5, state.movementSpeed || 1.5) / 1.5;
        var walkFrequency = 0.008 * walkSpeedMultiplier;

        var legSwing = Math.sin(time * walkFrequency) * 0.5 * walkSpeedMultiplier;
        userData.leftLeg.rotation.x = legSwing;
        userData.rightLeg.rotation.x = -legSwing;

        var armSwing = Math.sin(time * walkFrequency + Math.PI) * 0.35 * walkSpeedMultiplier;
        userData.leftArm.rotation.x = armSwing;
        userData.rightArm.rotation.x = -armSwing;

        var bobPhase = Math.abs(Math.sin(time * walkFrequency));
        mesh.position.y = bobPhase * 0.08 * walkSpeedMultiplier;

        userData.torso.rotation.z = Math.sin(time * walkFrequency * 0.5) * 0.03;

        userData.head.rotation.z = Math.sin(time * walkFrequency * 0.5) * 0.02;
        userData.head.rotation.y = Math.sin(time * walkFrequency * 0.3) * 0.03;

        break;

      case 'talking':
        userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.15;
        userData.rightArm.rotation.x = Math.sin(time * 0.004 + 1.5) * 0.15;
        userData.leftArm.rotation.z = Math.sin(time * 0.0025) * 0.1;
        userData.rightArm.rotation.z = -Math.sin(time * 0.0035) * 0.1;

        userData.head.rotation.x = Math.sin(time * 0.005) * 0.1;
        break;

      case 'working':
        switch (agent.archetype) {
          case 'gardener':
            userData.torso.rotation.x = 0.3;
            userData.leftArm.rotation.x = 0.5;
            userData.rightArm.rotation.x = 0.5;
            userData.head.rotation.x = 0.2;
            break;

          case 'builder':
            const hammerPhase = Math.sin(time * 0.006);
            userData.rightArm.rotation.x = -0.5 + hammerPhase * 0.8;
            userData.leftArm.rotation.x = 0.2;
            break;

          case 'merchant':
            userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.2;
            userData.rightArm.rotation.x = -0.3 + Math.sin(time * 0.004) * 0.1;
            break;

          case 'musician':
            userData.leftArm.rotation.x = -0.8;
            userData.leftArm.rotation.z = 0.5;
            userData.rightArm.rotation.x = -0.6;
            userData.rightArm.rotation.z = -0.3;
            mesh.position.y = Math.sin(time * 0.004) * 0.03;
            break;

          default:
            userData.leftArm.rotation.x = Math.sin(time * 0.004) * 0.3;
            userData.rightArm.rotation.x = Math.sin(time * 0.005 + Math.PI) * 0.3;
            break;
        }
        break;

      case 'collaborating':
        userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.25 - 0.3;
        userData.rightArm.rotation.x = Math.sin(time * 0.004 + 1) * 0.2 - 0.2;
        userData.leftArm.rotation.z = Math.sin(time * 0.002) * 0.15 + 0.1;
        userData.rightArm.rotation.z = -Math.sin(time * 0.0025) * 0.15 - 0.1;
        userData.head.rotation.x = Math.sin(time * 0.005) * 0.12;
        userData.head.rotation.y = Math.sin(time * 0.002) * 0.08;
        mesh.position.y = Math.sin(time * 0.002) * 0.02;
        break;
    }

    if (userData.glowRing) {
      var pulseFactor = Math.sin(time * 0.003) * 0.1 + 0.9;
      userData.glowRing.material.opacity = 0.4 * pulseFactor;
    }
  }

  function updateNPCVisual(agent, state, sceneContext, deltaTime, playerPos) {
    const mesh = npcMeshes.get(agent.id);
    if (!mesh) return;
    const THREE = window.THREE;
    if (!THREE) return;

    const lerpFactor = Math.min(deltaTime * 5, 1);
    mesh.position.x += (agent.position.x - mesh.position.x) * lerpFactor;
    mesh.position.z += (agent.position.z - mesh.position.z) * lerpFactor;

    var World = typeof window !== 'undefined' ? window.World : null;
    if (World && World.getTerrainHeight) {
      var terrainY = World.getTerrainHeight(mesh.position.x, mesh.position.z);
      mesh.position.y = terrainY;
    }

    var targetRotation = mesh.rotation.y;
    if (state.currentState === 'walking' || state.currentState === 'socializing') {
      targetRotation = state.lookAngle;
    } else if (state.currentState === 'collaborating' && state.collaborateTarget) {
      var partnerMesh = npcMeshes.get(state.collaborateTarget);
      if (partnerMesh) {
        var cdx = partnerMesh.position.x - mesh.position.x;
        var cdz = partnerMesh.position.z - mesh.position.z;
        targetRotation = Math.atan2(cdx, cdz);
      }
    }

    var angleDiff = targetRotation - mesh.rotation.y;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    var rotationSpeed = state.currentState === 'walking' ? 8 : 3;
    mesh.rotation.y += angleDiff * Math.min(deltaTime * rotationSpeed, 1);

    applyAnimations(mesh, state, agent);

    if (playerPos || sceneContext.camera) {
      let checkPos = playerPos;
      if (!checkPos && sceneContext.camera) {
        checkPos = { x: sceneContext.camera.position.x, z: sceneContext.camera.position.z };
      }

      if (checkPos) {
        const dx = checkPos.x - agent.position.x;
        const dz = checkPos.z - agent.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 30) {
          let decision = null;
          const brain = npcBrains.get(agent.id);
          if (brain && brain.lastDecision) {
            decision = brain.lastDecision;
          }

          updateEmoteIndicator(agent, state, mesh, playerPos, decision);

          updateActivityIndicator(agent, state, mesh, deltaTime);

          if (state.currentState === 'working') {
            let spawnTimer = particleSpawnTimers.get(agent.id) || 0;
            spawnTimer -= deltaTime;
            if (spawnTimer <= 0) {
              spawnActivityParticle(mesh, agent.archetype, THREE);
              particleSpawnTimers.set(agent.id, 1.0); // 1 second throttle
            } else {
              particleSpawnTimers.set(agent.id, spawnTimer);
            }
          }
        } else {
          const emoteData = emoteSprites.get(agent.id);
          if (emoteData && emoteData.sprite) {
            mesh.remove(emoteData.sprite);
            emoteSprites.delete(agent.id);
          }
          const indicatorData = activityIndicators.get(agent.id);
          if (indicatorData && indicatorData.mesh) {
            mesh.remove(indicatorData.mesh);
            activityIndicators.delete(agent.id);
          }
        }
      }
    }
  }

  function showChatBubble(agent, seed) {
    var message;
    var state = npcStates.get(agent.id);

    if (!dialogue && typeof NpcDialogue !== 'undefined') dialogue = NpcDialogue;

    if (state && state.currentActivity && state.currentActivity !== 'idle') {
      message = getActivityDialogue(state.currentActivity);
    }

    if (!message && dialogue && dialogue.getFallback) {
      var npcObj = { archetype: agent.archetype, name: agent.name };
      var dlgCtx = buildNpcDialogueContext(agent, 'idle_chat');
      message = dialogue.getFallback(npcObj, dlgCtx);
    }

    if (!message) {
      const messages = ARCHETYPE_MESSAGES[agent.archetype] || ['...'];
      message = randomChoice(messages, seed);
    }

    const mesh = npcMeshes.get(agent.id);
    if (!mesh) return;

    const THREE = window.THREE;
    if (!THREE) return;

    const existing = chatBubbles.get(agent.id);
    if (existing) {
      mesh.remove(existing.mesh);
    }

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 128;

    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    context.lineWidth = 4;

    const x = 10, y = 10, w = canvas.width - 20, h = canvas.height - 20, r = 15;
    context.beginPath();
    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);
    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);
    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);
    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);
    context.quadraticCurveTo(x, y, x + r, y);
    context.closePath();
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '20px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    const words = message.split(' ');
    let line = '';
    let y_pos = 64;
    const maxWidth = 480;

    for (let word of words) {
      const testLine = line + word + ' ';
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && line !== '') {
        context.fillText(line, canvas.width / 2, y_pos - 10);
        line = word + ' ';
        y_pos += 25;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, canvas.width / 2, y_pos - 10);

    const bubbleTexture = new THREE.CanvasTexture(canvas);
    const bubbleMaterial = new THREE.SpriteMaterial({ map: bubbleTexture });
    const bubble = new THREE.Sprite(bubbleMaterial);
    bubble.scale.set(4, 1, 1);
    bubble.position.y = 3.5;

    mesh.add(bubble);
    chatBubbles.set(agent.id, {
      mesh: bubble,
      timer: 5 // display for 5 seconds
    });
  }

  function updateChatBubbles(deltaTime) {
    for (const [agentId, bubble] of chatBubbles.entries()) {
      bubble.timer -= deltaTime;

      if (bubble.timer <= 0) {
        const npcMesh = npcMeshes.get(agentId);
        if (npcMesh) {
          npcMesh.remove(bubble.mesh);
        }
        chatBubbles.delete(agentId);
      } else if (bubble.timer < 1) {
        bubble.mesh.material.opacity = bubble.timer;
      }
    }
  }

  function initSpeechBubbleContainer() {
    if (!speechBubbleContainer) {
      speechBubbleContainer = document.createElement('div');
      speechBubbleContainer.id = 'npc-speech-bubbles';
      speechBubbleContainer.style.position = 'absolute';
      speechBubbleContainer.style.top = '0';
      speechBubbleContainer.style.left = '0';
      speechBubbleContainer.style.width = '100%';
      speechBubbleContainer.style.height = '100%';
      speechBubbleContainer.style.pointerEvents = 'none';
      speechBubbleContainer.style.zIndex = '100';
      document.body.appendChild(speechBubbleContainer);
    }
  }

  function showNPCSpeechBubble(npcId, message) {
    initSpeechBubbleContainer();

    var existing = speechBubbles.get(npcId);
    if (existing && existing.element) {
      speechBubbleContainer.removeChild(existing.element);
    }

    var bubble = document.createElement('div');
    bubble.style.position = 'absolute';
    bubble.style.padding = '8px 12px';
    bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
    bubble.style.border = '2px solid rgba(0, 0, 0, 0.3)';
    bubble.style.borderRadius = '12px';
    bubble.style.fontSize = '14px';
    bubble.style.fontFamily = 'Arial, sans-serif';
    bubble.style.color = '#333';
    bubble.style.whiteSpace = 'nowrap';
    bubble.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
    bubble.style.transition = 'opacity 0.3s ease-out';
    bubble.textContent = message;

    speechBubbleContainer.appendChild(bubble);

    speechBubbles.set(npcId, {
      element: bubble,
      timer: 3.0 // Display for 3 seconds
    });
  }

  function updateSpeechBubbles(camera) {
    if (!camera || !speechBubbleContainer) return;

    var THREE = window.THREE;
    if (!THREE) return;

    var width = window.innerWidth;
    var height = window.innerHeight;

    for (var [npcId, bubble] of speechBubbles.entries()) {
      var npcMesh = npcMeshes.get(npcId);
      if (!npcMesh) {
        if (bubble.element) {
          speechBubbleContainer.removeChild(bubble.element);
        }
        speechBubbles.delete(npcId);
        continue;
      }

      var worldPos = new THREE.Vector3();
      npcMesh.getWorldPosition(worldPos);
      worldPos.y += 2.2;

      var screenPos = worldPos.clone();
      screenPos.project(camera);

      var x = (screenPos.x * 0.5 + 0.5) * width;
      var y = (-screenPos.y * 0.5 + 0.5) * height;

      if (!bubble.element) {
        speechBubbles.delete(npcId);
        continue;
      }
      if (screenPos.z > 1) {
        bubble.element.style.display = 'none';
      } else {
        bubble.element.style.display = 'block';
        bubble.element.style.left = x + 'px';
        bubble.element.style.top = y + 'px';
        bubble.element.style.transform = 'translate(-50%, -100%)';
      }
    }
  }

  function updateSpeechBubbleTimers(deltaTime) {
    for (var [npcId, bubble] of speechBubbles.entries()) {
      bubble.timer -= deltaTime;

      if (bubble.timer <= 0) {
        if (bubble.element) {
          speechBubbleContainer.removeChild(bubble.element);
        }
        speechBubbles.delete(npcId);
      } else if (bubble.timer < 0.5) {
        if (bubble.element) {
          bubble.element.style.opacity = (bubble.timer / 0.5).toString();
        }
      }
    }
  }

  function clearSpeechBubbles() {
    for (var [npcId, bubble] of speechBubbles.entries()) {
      if (bubble.element) {
        speechBubbleContainer.removeChild(bubble.element);
      }
    }
    speechBubbles.clear();
  }

  function buildNpcDialogueContext(agent, contextType) {
    var state = npcStates.get(agent.id);
    var activity = (state && state.currentActivity) || 'idle';

    if (!contextType) {
      if (activity === 'idle' || activity === 'wandering') {
        contextType = 'idle_chat';
      } else if (activity === 'building' || activity === 'planting' || activity === 'crafting') {
        contextType = 'craft';
      } else {
        contextType = 'idle_chat';
      }
    }

    return {
      type: contextType,
      zone: (agent.position && agent.position.zone) || 'nexus',
      timeOfDay: 'daytime',   // simplified; world state not directly accessible here
      weather: 'clear',       // simplified; updated if world state available
      currentActivity: activity,
      nearbyPlayers: [],
      recentChat: []
    };
  }

  function trackDialogue(npcId, message) {
    recentDialogueHistory.push({ npcId: npcId, message: message, timestamp: Date.now() });
    if (recentDialogueHistory.length > MAX_DIALOGUE_HISTORY) {
      recentDialogueHistory = recentDialogueHistory.slice(-MAX_DIALOGUE_HISTORY);
    }
  }

  function triggerRandomSpeech(agent, deltaTime) {
    if (!dialogue && typeof NpcDialogue !== 'undefined') {
      dialogue = NpcDialogue;
    }

    var bubbleData = speechBubbles.get(agent.id);
    if (!bubbleData) {
      bubbleData = {
        element: null,
        timer: 0,
        nextSpeechTime: 15 + Math.random() * 15 // Random 15-30 seconds
      };
      speechBubbles.set(agent.id, bubbleData);
    }

    if (bubbleData.element && bubbleData.timer > 0) {
      return;
    }

    bubbleData.nextSpeechTime -= deltaTime;

    if (bubbleData.nextSpeechTime <= 0) {
      var message;

      if (dialogue && dialogue.getFallback) {
        var npcObj = { archetype: agent.archetype, name: agent.name };
        var dlgCtx = buildNpcDialogueContext(agent, 'idle_chat');

        var rand = Math.random();
        if (rand < 0.2) {
          dlgCtx.type = 'zone_comment';
        } else if (rand < 0.35) {
          dlgCtx.type = 'weather';
        } else {
          dlgCtx.type = 'idle_chat';
        }

        var lastMsg = bubbleData.lastMessage || '';
        var candidate = dialogue.getFallback(npcObj, dlgCtx);
        if (candidate && candidate !== lastMsg) {
          message = candidate;
        } else {
          dlgCtx.type = 'zone_comment';
          message = dialogue.getFallback(npcObj, dlgCtx) || candidate;
        }

        if (message) {
          bubbleData.lastMessage = message;
        }
      }

      if (!message) {
        var messages = ARCHETYPE_SPEECH[agent.archetype];
        if (!messages || messages.length === 0) {
          messages = ["Hello!", "Beautiful day!", "Greetings!"];
        }
        message = messages[Math.floor(Math.random() * messages.length)];
      }

      showNPCSpeechBubble(agent.id, message);
      trackDialogue(agent.id, message);

      bubbleData.nextSpeechTime = 15 + Math.random() * 15;
    }
  }

  function reloadZoneNPCs(sceneContext, currentZone, playerPos) {
    if (!playerPos) {
      npcMeshes.forEach((mesh, agentId) => {
        const agent = npcAgents.find(a => a.id === agentId);
        if (agent) {
          mesh.visible = (agent.position.zone === currentZone);
        }
      });
      console.log(`Showing NPCs for zone: ${currentZone}`);
    } else {
      var viewDist = 200;
      npcMeshes.forEach((mesh, agentId) => {
        const agent = npcAgents.find(a => a.id === agentId);
        if (agent) {
          var dx = agent.position.x - playerPos.x;
          var dz = agent.position.z - playerPos.z;
          var dist = Math.sqrt(dx * dx + dz * dz);
          mesh.visible = (dist < viewDist);
        }
      });
    }
  }

  function getNPCsInZone(zone) {
    return npcAgents.filter(agent => agent.position.zone === zone);
  }

  function getNPCById(id) {
    return npcAgents.find(agent => agent.id === id);
  }

  function findNearestNPC(worldX, worldZ, maxDist) {
    maxDist = maxDist || 10;
    var best = null;
    var bestDist = maxDist;
    for (var i = 0; i < npcAgents.length; i++) {
      var agent = npcAgents[i];
      var dx = agent.position.x - worldX;
      var dz = agent.position.z - worldZ;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < bestDist) {
        bestDist = dist;
        best = { agent: agent, distance: dist };
      }
    }
    return best;
  }

  function interactWithNPC(worldX, worldZ, playerId) {
    var nearest = findNearestNPC(worldX, worldZ, 8);
    if (!nearest) return null;

    var agent = nearest.agent;
    var seed = Date.now() * 0.001 + agent.id.charCodeAt(0);
    var brain = npcBrains.get(agent.id);
    var message, mood, activity, familiarity;

    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    var questInfo = null;
    var hasQuest = false;

    if (Quests && playerId) {
      var npcQuests = Quests.getNpcQuests(agent.id, playerId);
      if (npcQuests.length > 0) {
        hasQuest = true;
        questInfo = npcQuests[0]; // Return first quest for now
      }
    }

    if (brain && NpcAI) {
      var context = { category: 'greeting_first' };
      if (NpcAI.getDialogue) {
        message = NpcAI.getDialogue(brain.memory, context, agent.name);
      }
      mood = NpcAI.getMood ? NpcAI.getMood(brain) : 'neutral';
      activity = NpcAI.getGoal ? NpcAI.getGoal(brain) : '';
      familiarity = brain.memory && brain.memory.playerFamiliarity
        ? Math.round(Object.values(brain.memory.playerFamiliarity)[0] || 0)
        : 0;

      if (NpcAI.handleEvent) {
        NpcAI.handleEvent(brain.memory, {
          type: 'player_interact',
          playerId: playerId || 'player',
          description: 'Player interacted directly'
        });
      }
      if (brain.memory && brain.memory.playerFamiliarity) {
        var pKey = Object.keys(brain.memory.playerFamiliarity)[0] || (playerId || 'player');
        brain.memory.playerFamiliarity[pKey] = Math.min(100, (brain.memory.playerFamiliarity[pKey] || 0) + 5);
        familiarity = Math.round(brain.memory.playerFamiliarity[pKey]);
      }
    }

    var npcMesh = npcMeshes.get(agent.id);
    if (npcMesh) {
      var greetEmote = familiarity >= 75 ? 'cheer' : familiarity >= 25 ? 'bow' : 'wave';
      playEmoteAnimation(npcMesh, greetEmote);
    }

    if (questInfo && questInfo.quest && questInfo.quest.dialogue) {
      if (questInfo.state === 'available') {
        message = questInfo.quest.dialogue.offer;
      } else if (questInfo.state === 'active') {
        message = Quests.getQuestDialogue(questInfo.quest.id, 'progress', questInfo.quest);
      } else if (questInfo.state === 'complete') {
        message = questInfo.quest.dialogue.complete || 'Quest complete! Return to turn it in.';
      }
    }

    if (!message) {
      var state = npcStates.get(agent.id);
      if (state && state.currentActivity && state.currentActivity !== 'idle') {
        message = getActivityDialogue(state.currentActivity);
      }
    }

    if (!message && dialogue && dialogue.getFallback) {
      var npcObj = { archetype: agent.archetype, name: agent.name };
      var greetCtx = buildNpcDialogueContext(agent, 'greeting');
      message = dialogue.getFallback(npcObj, greetCtx);
    }

    if (!message) {
      var messages = ARCHETYPE_MESSAGES[agent.archetype] || ['Hello there.'];
      message = randomChoice(messages, seed);
    }

    if (message) trackDialogue(agent.id, message);

    if (brain && NpcAI) {
      showChatBubbleWithText(agent, message);
    } else {
      showChatBubble(agent, seed);
    }

    return {
      name: agent.name,
      message: message,
      archetype: agent.archetype,
      mood: mood || 'neutral',
      activity: activity || '',
      familiarity: familiarity || 0,
      id: agent.id,
      hasQuest: hasQuest,
      questInfo: questInfo
    };
  }

  function getNPCPositions() {
    return npcAgents.map(function(agent) {
      return {
        x: agent.position.x,
        z: agent.position.z,
        name: agent.name,
        archetype: agent.archetype,
        zone: agent.position.zone
      };
    });
  }

  function broadcastEvent(event) {
    if (!event) return;
    var aiEvent = {
      type: event.type,
      description: event.type + ': ' + JSON.stringify(event.data || {}).substring(0, 100)
    };
    if (event.data) {
      if (event.data.weather) aiEvent.weather = event.data.weather;
      if (event.data.period) aiEvent.timeOfDay = event.data.period;
    }
    pendingEvents.push(aiEvent);
  }

  function getNPCMood(id) {
    var brain = npcBrains.get(id);
    if (brain && NpcAI && NpcAI.getMood) return NpcAI.getMood(brain);
    return 'neutral';
  }

  function getNPCGoal(id) {
    var brain = npcBrains.get(id);
    if (brain && NpcAI && NpcAI.getGoal) return NpcAI.getGoal(brain);
    return 'idle';
  }

  function getNPCActivity(id) {
    var state = npcStates.get(id);
    return state ? state.currentState : 'unknown';
  }

  function playEmoteAnimation(playerMesh, emoteType) {
    if (!playerMesh || !playerMesh.userData) return;

    var userData = playerMesh.userData;
    if (!userData.head || !userData.torso || !userData.leftArm || !userData.rightArm) return;

    if (playerMesh.userData.emoteAnimation) {
      clearTimeout(playerMesh.userData.emoteAnimation.timeout);
      cancelAnimationFrame(playerMesh.userData.emoteAnimation.frame);
    }

    var startTime = Date.now();
    var duration = 0;
    var emoteData = { type: emoteType, startTime: startTime };

    function animate() {
      var elapsed = (Date.now() - startTime) / 1000;
      var t = elapsed;

      userData.leftArm.rotation.x = 0;
      userData.leftArm.rotation.z = 0;
      userData.rightArm.rotation.x = 0;
      userData.rightArm.rotation.z = 0;
      userData.leftLeg.rotation.x = 0;
      userData.rightLeg.rotation.x = 0;
      userData.head.rotation.x = 0;
      userData.head.rotation.y = 0;
      userData.torso.rotation.x = 0;
      playerMesh.position.y = 0;

      var isComplete = false;

      switch (emoteType) {
        case 'wave':
          duration = 2.0;
          if (elapsed < duration) {
            var waveProgress = Math.min(elapsed / 0.3, 1.0);
            userData.rightArm.rotation.x = -1.5 * waveProgress;
            userData.rightArm.rotation.z = -0.3 * waveProgress;
            var swayAmount = Math.sin(t * 6) * 0.4;
            userData.rightArm.rotation.y = swayAmount;
            userData.head.rotation.y = swayAmount * 0.3;
          } else {
            isComplete = true;
          }
          break;

        case 'dance':
          duration = 3.0;
          if (elapsed < duration) {
            var bobAmount = Math.sin(t * 4) * 0.15;
            playerMesh.position.y = Math.abs(bobAmount);
            userData.leftArm.rotation.x = -0.5 + Math.sin(t * 4) * 0.8;
            userData.rightArm.rotation.x = -0.5 + Math.sin(t * 4 + Math.PI) * 0.8;
            userData.torso.rotation.y = Math.sin(t * 3) * 0.15;
            userData.leftLeg.rotation.x = Math.sin(t * 4) * 0.3;
            userData.rightLeg.rotation.x = Math.sin(t * 4 + Math.PI) * 0.3;
          } else {
            isComplete = true;
          }
          break;

        case 'bow':
          duration = 1.5;
          if (elapsed < duration) {
            var bowProgress;
            if (elapsed < duration * 0.5) {
              bowProgress = (elapsed / (duration * 0.5));
            } else {
              bowProgress = 1.0 - ((elapsed - duration * 0.5) / (duration * 0.5));
            }
            userData.torso.rotation.x = bowProgress * 0.785;
            userData.head.rotation.x = bowProgress * 0.3;
            userData.leftArm.rotation.x = bowProgress * 0.2;
            userData.rightArm.rotation.x = bowProgress * 0.2;
          } else {
            isComplete = true;
          }
          break;

        case 'cheer':
          duration = 2.0;
          if (elapsed < duration) {
            var cheerProgress = Math.min(elapsed / 0.2, 1.0);
            userData.leftArm.rotation.x = -2.0 * cheerProgress;
            userData.leftArm.rotation.z = 0.3 * cheerProgress;
            userData.rightArm.rotation.x = -2.0 * cheerProgress;
            userData.rightArm.rotation.z = -0.3 * cheerProgress;
            var hopAmount = Math.abs(Math.sin(t * 5)) * 0.2;
            playerMesh.position.y = hopAmount;
          } else {
            isComplete = true;
          }
          break;

        case 'meditate':
          duration = 3.0;
          if (elapsed < duration) {
            var meditateProgress = Math.min(elapsed / 0.5, 1.0);
            playerMesh.position.y = -0.2 * meditateProgress + Math.sin(t * 2) * 0.03;
            userData.leftArm.rotation.x = 0.3 * meditateProgress;
            userData.leftArm.rotation.z = 0.5 * meditateProgress;
            userData.rightArm.rotation.x = 0.3 * meditateProgress;
            userData.rightArm.rotation.z = -0.5 * meditateProgress;
            userData.leftLeg.rotation.z = 0.4 * meditateProgress;
            userData.rightLeg.rotation.z = -0.4 * meditateProgress;
            userData.head.rotation.x = -0.2 * meditateProgress;
            userData.torso.rotation.x = -0.1 * meditateProgress;
          } else {
            isComplete = true;
          }
          break;

        case 'point':
          duration = 1.5;
          if (elapsed < duration) {
            var pointProgress = Math.min(elapsed / 0.3, 1.0);
            userData.rightArm.rotation.x = -1.2 * pointProgress;
            userData.rightArm.rotation.y = 0.2 * pointProgress;
            userData.rightArm.rotation.z = -0.1 * pointProgress;
            userData.head.rotation.y = 0.2 * pointProgress;
            userData.torso.rotation.y = 0.1 * pointProgress;
          } else {
            isComplete = true;
          }
          break;

        default:
          isComplete = true;
      }

      if (!isComplete) {
        emoteData.frame = requestAnimationFrame(animate);
      } else {
        userData.leftArm.rotation.x = 0;
        userData.leftArm.rotation.y = 0;
        userData.leftArm.rotation.z = 0;
        userData.rightArm.rotation.x = 0;
        userData.rightArm.rotation.y = 0;
        userData.rightArm.rotation.z = 0;
        userData.leftLeg.rotation.x = 0;
        userData.leftLeg.rotation.z = 0;
        userData.rightLeg.rotation.x = 0;
        userData.rightLeg.rotation.z = 0;
        userData.head.rotation.x = 0;
        userData.head.rotation.y = 0;
        userData.torso.rotation.x = 0;
        userData.torso.rotation.y = 0;
        playerMesh.position.y = 0;
        playerMesh.userData.emoteAnimation = null;
      }
    }

    playerMesh.userData.emoteAnimation = emoteData;
    animate();
  }

  exports.initNPCs = initNPCs;
  exports.updateNPCs = updateNPCs;
  exports.reloadZoneNPCs = reloadZoneNPCs;
  exports.getNPCsInZone = getNPCsInZone;
  exports.getNPCById = getNPCById;
  exports.findNearestNPC = findNearestNPC;
  exports.interactWithNPC = interactWithNPC;
  exports.getNPCPositions = getNPCPositions;
  exports.broadcastEvent = broadcastEvent;
  exports.getNPCMood = getNPCMood;
  exports.getNPCGoal = getNPCGoal;
  exports.getNPCActivity = getNPCActivity;
  exports.updateQuestIndicators = updateQuestIndicators;
  exports.playEmoteAnimation = playEmoteAnimation;
  exports.getNPCSchedule = getNPCSchedule;
  exports.getActivityDialogue = getActivityDialogue;
  exports.getActivityZone = getActivityZone;
  exports.getTimePeriod = getTimePeriod;
  exports.showNPCSpeechBubble = showNPCSpeechBubble;
  exports.updateSpeechBubbles = updateSpeechBubbles;
  exports.clearSpeechBubbles = clearSpeechBubbles;
  exports.getAgents = function() { return npcAgents; };
  exports.buildNpcDialogueContext = buildNpcDialogueContext;
  exports.getDialogueHistory = function() { return recentDialogueHistory.slice(); };
  exports.getDialogueTrend = function() {
    if (!dialogue || !dialogue.detectTrend) return null;
    return dialogue.detectTrend(recentDialogueHistory);
  };
  exports.getNearbyNPCCount = function(playerPos, radius) {
    if (!playerPos || !npcAgents) return 0;
    var count = 0;
    for (var i = 0; i < npcAgents.length; i++) {
      var npc = npcAgents[i];
      if (!npc || !npc.x) continue;
      var dx = npc.x - playerPos.x;
      var dz = npc.z - playerPos.z;
      if (Math.sqrt(dx * dx + dz * dz) <= radius) count++;
    }
    return count;
  };

})(typeof module !== 'undefined' ? module.exports : (window.NPCs = {}));


// seasons.js
(function(exports) {

  const SEASONS = {
    spring: {
      id: 'spring',
      name: 'Spring',
      description: 'A time of renewal and growth',
      startMonth: 2, // March (0-indexed)
      endMonth: 4,   // May
      festival: {
        name: 'Bloom Festival',
        description: 'Cherry blossoms fill the air with petals of hope',
        theme: 'flower'
      },
      colors: {
        primary: '#f8b4c8',
        secondary: '#7db37d',
        accent: '#ffd4e5',
        ambient: '#ffe8f0'
      },
      bonus: {
        activity: 'garden',
        multiplier: 1.25,
        description: 'Garden yields increased'
      }
    },
    summer: {
      id: 'summer',
      name: 'Summer',
      description: 'The warmth of endless days',
      startMonth: 5, // June
      endMonth: 7,   // August
      festival: {
        name: 'Sun Festival',
        description: 'Golden light dances with fireflies at dusk',
        theme: 'sun'
      },
      colors: {
        primary: '#f0c040',
        secondary: '#ff8c42',
        accent: '#ffe080',
        ambient: '#fff4d4'
      },
      bonus: {
        activity: 'exploration',
        multiplier: 1.25,
        description: 'Exploration rewards increased'
      }
    },
    autumn: {
      id: 'autumn',
      name: 'Autumn',
      description: 'The season of abundance and reflection',
      startMonth: 8,  // September
      endMonth: 10,   // November
      festival: {
        name: 'Harvest Festival',
        description: 'Leaves fall like amber rain, celebrating the bounty',
        theme: 'harvest'
      },
      colors: {
        primary: '#d4a040',
        secondary: '#8b4513',
        accent: '#e8b860',
        ambient: '#f0e0c0'
      },
      bonus: {
        activity: 'crafting',
        multiplier: 1.25,
        description: 'Crafting rewards increased'
      }
    },
    winter: {
      id: 'winter',
      name: 'Winter',
      description: 'A time of wonder and togetherness',
      startMonth: 11, // December (wraps to Feb)
      endMonth: 1,    // February
      festival: {
        name: 'Star Festival',
        description: 'Snowflakes drift beneath starlit skies',
        theme: 'star'
      },
      colors: {
        primary: '#80c0e0',
        secondary: '#e8e8ff',
        accent: '#a0d4f0',
        ambient: '#e0f0ff'
      },
      bonus: {
        activity: 'social',
        multiplier: 1.25,
        description: 'Social rewards increased'
      }
    }
  };

  const SEASONAL_ITEMS = {
    spring: [
      {
        id: 'cherry_blossom',
        name: 'Cherry Blossom',
        description: 'Delicate pink petals from the sacred trees',
        rarity: 'rare',
        type: 'decoration'
      },
      {
        id: 'spring_bouquet',
        name: 'Spring Bouquet',
        description: 'A vibrant arrangement of seasonal flowers',
        rarity: 'uncommon',
        type: 'gift'
      },
      {
        id: 'rainbow_seed',
        name: 'Rainbow Seed',
        description: 'A magical seed that blooms in seven colors',
        rarity: 'legendary',
        type: 'consumable'
      }
    ],
    summer: [
      {
        id: 'sun_crystal',
        name: 'Sun Crystal',
        description: 'Captures the warmth and light of summer',
        rarity: 'rare',
        type: 'material'
      },
      {
        id: 'firefly_jar',
        name: 'Firefly Jar',
        description: 'A gentle glow to light your path',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'tropical_fruit',
        name: 'Tropical Fruit',
        description: 'Sweet and refreshing, bursting with flavor',
        rarity: 'common',
        type: 'consumable'
      }
    ],
    autumn: [
      {
        id: 'golden_leaf',
        name: 'Golden Leaf',
        description: 'Preserved in its moment of perfect beauty',
        rarity: 'rare',
        type: 'material'
      },
      {
        id: 'pumpkin',
        name: 'Harvest Pumpkin',
        description: 'A symbol of the season\'s abundance',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'maple_syrup',
        name: 'Maple Syrup',
        description: 'Sweet nectar from ancient trees',
        rarity: 'common',
        type: 'consumable'
      }
    ],
    winter: [
      {
        id: 'snowglobe',
        name: 'Snowglobe',
        description: 'A miniature winter wonderland',
        rarity: 'rare',
        type: 'decoration'
      },
      {
        id: 'star_ornament',
        name: 'Star Ornament',
        description: 'Handcrafted decoration that sparkles like the night sky',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'hot_cocoa',
        name: 'Hot Cocoa',
        description: 'Warm comfort in a cup',
        rarity: 'common',
        type: 'consumable'
      }
    ]
  };

  const SEASONAL_DECORATIONS = {
    spring: {
      town: [
        { type: 'cherry_tree', count: 8, positions: 'random' },
        { type: 'flower_bed', count: 12, positions: 'pathways' },
        { type: 'blossom_arch', count: 2, positions: 'entrances' }
      ],
      forest: [
        { type: 'wildflower_patch', count: 15, positions: 'random' },
        { type: 'butterfly_spawn', count: 6, positions: 'clearings' }
      ],
      plains: [
        { type: 'tulip_field', count: 10, positions: 'random' },
        { type: 'rainbow_garden', count: 3, positions: 'special' }
      ]
    },
    summer: {
      town: [
        { type: 'lantern_string', count: 10, positions: 'overhead' },
        { type: 'sun_banner', count: 6, positions: 'buildings' },
        { type: 'fountain_glow', count: 2, positions: 'center' }
      ],
      forest: [
        { type: 'firefly_cluster', count: 20, positions: 'random' },
        { type: 'sun_shaft', count: 8, positions: 'canopy_breaks' }
      ],
      plains: [
        { type: 'sunflower_field', count: 12, positions: 'random' },
        { type: 'heat_shimmer', count: 5, positions: 'distance' }
      ]
    },
    autumn: {
      town: [
        { type: 'hay_bale', count: 8, positions: 'random' },
        { type: 'harvest_wreath', count: 10, positions: 'doors' },
        { type: 'corn_stalk', count: 6, positions: 'corners' }
      ],
      forest: [
        { type: 'mushroom_circle', count: 5, positions: 'random' },
        { type: 'leaf_pile', count: 12, positions: 'clearings' }
      ],
      plains: [
        { type: 'scarecrow', count: 4, positions: 'fields' },
        { type: 'wheat_sheaf', count: 10, positions: 'random' }
      ]
    },
    winter: {
      town: [
        { type: 'star_decoration', count: 15, positions: 'random' },
        { type: 'ice_sculpture', count: 4, positions: 'plazas' },
        { type: 'warm_light', count: 20, positions: 'windows' }
      ],
      forest: [
        { type: 'frost_crystal', count: 12, positions: 'random' },
        { type: 'snow_drift', count: 8, positions: 'ground' }
      ],
      plains: [
        { type: 'frozen_pond', count: 2, positions: 'special' },
        { type: 'icicle_cluster', count: 6, positions: 'rock_formations' }
      ]
    }
  };

  const SEASONAL_PARTICLES = {
    spring: {
      type: 'cherry_blossom',
      count: 100,
      color: '#ffc0db',
      size: 0.3,
      speed: 0.02,
      drift: true,
      swirl: true,
      gravity: 0.001
    },
    summer: {
      type: 'firefly',
      count: 60,
      color: '#ffff80',
      size: 0.2,
      speed: 0.015,
      glow: true,
      pulse: true,
      gravity: 0
    },
    autumn: {
      type: 'falling_leaf',
      count: 80,
      color: '#d4a040',
      size: 0.4,
      speed: 0.025,
      drift: true,
      spin: true,
      gravity: 0.002
    },
    winter: {
      type: 'snowflake',
      count: 120,
      color: '#ffffff',
      size: 0.25,
      speed: 0.01,
      drift: true,
      sparkle: true,
      gravity: 0.0015
    }
  };

  const SEASONAL_GREETINGS = {
    spring: [
      'The flowers are beautiful this season!',
      'Can you feel the renewal in the air?',
      'Perfect weather for the Bloom Festival!',
      'Spring brings such wonderful energy!'
    ],
    summer: [
      'Another glorious sunny day!',
      'The fireflies will be out tonight!',
      'Perfect season for adventure!',
      'The Sun Festival lights up everything!'
    ],
    autumn: [
      'The harvest has been bountiful this year!',
      'Don\'t the leaves look magnificent?',
      'Time to gather and give thanks!',
      'The Harvest Festival begins soon!'
    ],
    winter: [
      'Stay warm out there, traveler!',
      'The stars shine brightest in winter!',
      'What a magical time of year!',
      'The Star Festival brings us together!'
    ]
  };

  function getCurrentSeason() {
    const now = new Date();
    const month = now.getMonth(); // 0-indexed (0 = January)

    for (const seasonKey in SEASONS) {
      const season = SEASONS[seasonKey];

      if (season.id === 'winter') {
        if (month >= season.startMonth || month <= season.endMonth) {
          return season;
        }
      } else {
        if (month >= season.startMonth && month <= season.endMonth) {
          return season;
        }
      }
    }

    return SEASONS.spring;
  }

  function getSeasonalItems() {
    const season = getCurrentSeason();
    return SEASONAL_ITEMS[season.id] || [];
  }

  function getSeasonalDecorations(zone) {
    const season = getCurrentSeason();
    const decorations = SEASONAL_DECORATIONS[season.id];
    return decorations[zone] || [];
  }

  function getSeasonalParticles() {
    const season = getCurrentSeason();
    return SEASONAL_PARTICLES[season.id];
  }

  function getSeasonBonus(activity) {
    const season = getCurrentSeason();
    if (season.bonus.activity === activity) {
      return season.bonus.multiplier;
    }
    return 1.0;
  }

  function getDaysUntilSeasonEnd() {
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const season = getCurrentSeason();

    let endDate;

    if (season.id === 'winter') {
      if (currentMonth === 11) {
        const nextYear = currentYear + 1;
        const isLeapYear = (nextYear % 4 === 0 && nextYear % 100 !== 0) || (nextYear % 400 === 0);
        endDate = new Date(nextYear, 1, isLeapYear ? 29 : 28, 23, 59, 59);
      } else {
        const isLeapYear = (currentYear % 4 === 0 && currentYear % 100 !== 0) || (currentYear % 400 === 0);
        endDate = new Date(currentYear, 1, isLeapYear ? 29 : 28, 23, 59, 59);
      }
    } else {
      endDate = new Date(currentYear, season.endMonth + 1, 0, 23, 59, 59);
    }

    const msPerDay = 24 * 60 * 60 * 1000;
    const daysRemaining = Math.ceil((endDate - now) / msPerDay);

    return Math.max(0, daysRemaining);
  }

  function getSeasonalGreeting() {
    const season = getCurrentSeason();
    const greetings = SEASONAL_GREETINGS[season.id];
    return greetings[Math.floor(Math.random() * greetings.length)];
  }

  function getSeasonalColors() {
    const season = getCurrentSeason();
    return season.colors;
  }

  exports.SEASONS = SEASONS;
  exports.SEASONAL_ITEMS = SEASONAL_ITEMS;
  exports.SEASONAL_DECORATIONS = SEASONAL_DECORATIONS;
  exports.SEASONAL_PARTICLES = SEASONAL_PARTICLES;
  exports.SEASONAL_GREETINGS = SEASONAL_GREETINGS;
  exports.getCurrentSeason = getCurrentSeason;
  exports.getSeasonalItems = getSeasonalItems;
  exports.getSeasonalDecorations = getSeasonalDecorations;
  exports.getSeasonalParticles = getSeasonalParticles;
  exports.getSeasonBonus = getSeasonBonus;
  exports.getDaysUntilSeasonEnd = getDaysUntilSeasonEnd;
  exports.getSeasonalGreeting = getSeasonalGreeting;
  exports.getSeasonalColors = getSeasonalColors;

})(typeof module !== 'undefined' ? module.exports : (window.Seasons = {}));


// pets.js
(function(exports) {

  const PET_TYPES = [
    {
      id: 'cat',
      name: 'Mystic Cat',
      description: 'A wise feline Pingym that brings good fortune to trades',
      icon: 'ðŸ±',
      zone: 'commons',
      rarity: 'common',
      bonus: { type: 'trade_luck', value: 2 }
    },
    {
      id: 'fox',
      name: 'Spirit Fox',
      description: 'A clever fox with enhanced senses for discovering hidden places',
      icon: 'ðŸ¦Š',
      zone: 'wilds',
      rarity: 'uncommon',
      bonus: { type: 'discovery_range', value: 2 }
    },
    {
      id: 'owl',
      name: 'Ancient Owl',
      description: 'A scholarly owl that helps unlock hidden lore',
      icon: 'ðŸ¦‰',
      zone: 'athenaeum',
      rarity: 'uncommon',
      bonus: { type: 'lore_unlock', value: 2 }
    },
    {
      id: 'butterfly',
      name: 'Crystal Butterfly',
      description: 'A delicate butterfly that enhances garden growth',
      icon: 'ðŸ¦‹',
      zone: 'gardens',
      rarity: 'common',
      bonus: { type: 'garden_growth', value: 2 }
    },
    {
      id: 'rabbit',
      name: 'Moon Rabbit',
      description: 'A gentle rabbit that brings peace and faster crafting',
      icon: 'ðŸ°',
      zone: 'gardens',
      rarity: 'common',
      bonus: { type: 'craft_speed', value: 2 }
    },
    {
      id: 'frog',
      name: 'Jade Frog',
      description: 'A lucky frog that attracts rare resources',
      icon: 'ðŸ¸',
      zone: 'wilds',
      rarity: 'uncommon',
      bonus: { type: 'rare_resources', value: 2 }
    },
    {
      id: 'firefly',
      name: 'Ember Firefly',
      description: 'A glowing firefly that illuminates hidden paths',
      icon: 'ðŸª²',
      zone: 'wilds',
      rarity: 'rare',
      bonus: { type: 'vision_range', value: 3 }
    },
    {
      id: 'wolf_pup',
      name: 'Shadow Wolf Pup',
      description: 'A loyal wolf pup that boosts stamina and endurance',
      icon: 'ðŸº',
      zone: 'wilds',
      rarity: 'rare',
      bonus: { type: 'stamina', value: 3 }
    },
    {
      id: 'phoenix_chick',
      name: 'Phoenix Chick',
      description: 'A rare phoenix chick that grants resilience and renewal',
      icon: 'ðŸ¦',
      zone: 'athenaeum',
      rarity: 'legendary',
      bonus: { type: 'resilience', value: 5 }
    },
    {
      id: 'turtle',
      name: 'Ancient Turtle',
      description: 'A wise turtle that increases meditation effectiveness',
      icon: 'ðŸ¢',
      zone: 'gardens',
      rarity: 'rare',
      bonus: { type: 'meditation', value: 3 }
    }
  ];

  const playerPets = {};

  const PET_CONSTANTS = {
    HUNGER_DECAY_RATE: 1, // hunger increases by 1 per minute
    MOOD_DECAY_RATE: 0.5, // mood decreases by 0.5 per minute
    BOND_GAIN_RATE: 0.2, // bond increases by 0.2 when feeding/caring
    HUNGER_THRESHOLD_HAPPY: 30, // below 30 hunger = happy
    HUNGER_THRESHOLD_CONTENT: 60, // 30-60 = content
    MOOD_THRESHOLD_ECSTATIC: 90,
    MOOD_THRESHOLD_HAPPY: 70,
    MOOD_THRESHOLD_CONTENT: 50,
    MOOD_THRESHOLD_HUNGRY: 30
  };

  function getAvailablePets(zone) {
    return PET_TYPES.filter(pet => pet.zone === zone);
  }

  function adoptPet(playerId, petType, petName) {
    if (!playerId || !petType || !petName) {
      console.error('Invalid adoption parameters');
      return null;
    }

    if (playerPets[playerId]) {
      console.warn('Player already has a pet. Release current pet first.');
      return null;
    }

    const petTypeData = PET_TYPES.find(p => p.id === petType);
    if (!petTypeData) {
      console.error('Invalid pet type:', petType);
      return null;
    }

    const pet = {
      id: generatePetId(),
      type: petType,
      name: petName,
      mood: 100, // Start happy
      hunger: 0, // Start well-fed
      bond: 0, // Build bond over time
      adopted_at: Date.now(),
      last_updated: Date.now()
    };

    playerPets[playerId] = pet;
    return pet;
  }

  function getPlayerPet(playerId) {
    return playerPets[playerId] || null;
  }

  function feedPet(playerId, foodItem) {
    const pet = playerPets[playerId];
    if (!pet) {
      return { success: false, message: 'No pet to feed' };
    }

    const foodEffects = {
      'berry': { hunger: -20, mood: 5 },
      'fish': { hunger: -30, mood: 10 },
      'mushroom': { hunger: -15, mood: 3 },
      'bread': { hunger: -25, mood: 7 },
      'treat': { hunger: -10, mood: 15 },
      'default': { hunger: -10, mood: 5 }
    };

    const effect = foodEffects[foodItem] || foodEffects['default'];

    pet.hunger = Math.max(0, pet.hunger + effect.hunger);
    pet.mood = Math.min(100, pet.mood + effect.mood);
    pet.bond = Math.min(100, pet.bond + PET_CONSTANTS.BOND_GAIN_RATE);
    pet.last_updated = Date.now();

    return {
      success: true,
      message: `${pet.name} enjoyed the ${foodItem}!`,
      pet: pet
    };
  }

  function updatePet(playerId, deltaTime) {
    const pet = playerPets[playerId];
    if (!pet) return null;

    const minutesElapsed = deltaTime / 60000; // Convert ms to minutes

    pet.hunger = Math.min(100, pet.hunger + (PET_CONSTANTS.HUNGER_DECAY_RATE * minutesElapsed));

    let moodDecay = PET_CONSTANTS.MOOD_DECAY_RATE * minutesElapsed;
    if (pet.hunger > PET_CONSTANTS.HUNGER_THRESHOLD_CONTENT) {
      moodDecay *= 2; // Mood decays faster when hungry
    }
    pet.mood = Math.max(0, pet.mood - moodDecay);

    if (pet.hunger < PET_CONSTANTS.HUNGER_THRESHOLD_HAPPY && pet.mood > PET_CONSTANTS.MOOD_THRESHOLD_CONTENT) {
      pet.bond = Math.min(100, pet.bond + (0.1 * minutesElapsed));
    }

    pet.last_updated = Date.now();
    return pet;
  }

  function getPetBonus(playerId) {
    const pet = playerPets[playerId];
    if (!pet) return null;

    const petType = PET_TYPES.find(p => p.id === pet.type);
    if (!petType) return null;

    const bondMultiplier = pet.bond / 100;
    const bonusValue = petType.bonus.value * bondMultiplier;

    return {
      type: petType.bonus.type,
      value: bonusValue,
      description: getBonusDescription(petType.bonus.type, bonusValue)
    };
  }

  function renamePet(playerId, newName) {
    const pet = playerPets[playerId];
    if (!pet || !newName) return false;

    pet.name = newName;
    return true;
  }

  function releasePet(playerId) {
    if (!playerPets[playerId]) return false;
    delete playerPets[playerId];
    return true;
  }

  function getPetMood(pet) {
    if (!pet) return 'unknown';

    if (pet.hunger > 70) {
      return 'starving';
    } else if (pet.hunger > 50) {
      return 'hungry';
    }

    if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_ECSTATIC) {
      return 'ecstatic';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_HAPPY) {
      return 'happy';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_CONTENT) {
      return 'content';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_HUNGRY) {
      return 'sad';
    } else {
      return 'depressed';
    }
  }

  function getMoodEmoji(mood) {
    const moodEmojis = {
      'ecstatic': 'ðŸ˜„',
      'happy': 'ðŸ˜Š',
      'content': 'ðŸ™‚',
      'sad': 'ðŸ˜Ÿ',
      'hungry': 'ðŸ˜«',
      'starving': 'ðŸ˜µ',
      'depressed': 'ðŸ˜¢',
      'unknown': 'ðŸ˜'
    };
    return moodEmojis[mood] || moodEmojis['unknown'];
  }

  function getBonusDescription(bonusType, value) {
    const descriptions = {
      'trade_luck': `+${value.toFixed(1)}% trade success`,
      'discovery_range': `+${value.toFixed(1)}% discovery radius`,
      'lore_unlock': `+${value.toFixed(1)}% lore unlock chance`,
      'garden_growth': `+${value.toFixed(1)}% garden growth rate`,
      'craft_speed': `+${value.toFixed(1)}% crafting speed`,
      'rare_resources': `+${value.toFixed(1)}% rare resource chance`,
      'vision_range': `+${value.toFixed(1)}% vision range`,
      'stamina': `+${value.toFixed(1)}% stamina`,
      'resilience': `+${value.toFixed(1)}% resilience`,
      'meditation': `+${value.toFixed(1)}% meditation effectiveness`
    };
    return descriptions[bonusType] || 'Unknown bonus';
  }

  function generatePetId() {
    return 'pet_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  function getAllPetTypes() {
    return PET_TYPES;
  }

  function getPetTypeData(petTypeId) {
    return PET_TYPES.find(p => p.id === petTypeId) || null;
  }

  function initPets(existingData) {
    if (!existingData) return;

    var pids = Object.keys(playerPets);
    for (var i = 0; i < pids.length; i++) {
      delete playerPets[pids[i]];
    }

    var saved = existingData.playerPets || {};
    var keys = Object.keys(saved);
    for (var j = 0; j < keys.length; j++) {
      playerPets[keys[j]] = saved[keys[j]];
    }

    console.log('Pets initialized:', keys.length, 'players with pets');
  }

  function getPetsState() {
    return {
      playerPets: playerPets
    };
  }

  exports.PET_TYPES = PET_TYPES;
  exports.getAvailablePets = getAvailablePets;
  exports.adoptPet = adoptPet;
  exports.getPlayerPet = getPlayerPet;
  exports.feedPet = feedPet;
  exports.updatePet = updatePet;
  exports.getPetBonus = getPetBonus;
  exports.renamePet = renamePet;
  exports.releasePet = releasePet;
  exports.getPetMood = getPetMood;
  exports.getMoodEmoji = getMoodEmoji;
  exports.getAllPetTypes = getAllPetTypes;
  exports.getPetTypeData = getPetTypeData;
  exports.initPets = initPets;
  exports.getPetsState = getPetsState;

})(typeof module !== 'undefined' ? module.exports : (window.Pets = {}));


// main.js
(function(exports) {

  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const State = typeof require !== 'undefined' ? require('./state') : window.State;
  const Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;
  const Inventory = typeof require !== 'undefined' ? require('./inventory') : window.Inventory;
  const Trading = typeof require !== 'undefined' ? require('./trading') : window.Trading;
  const Intentions = typeof require !== 'undefined' ? require('./intentions') : window.Intentions;
  const Social = typeof require !== 'undefined' ? require('./social') : window.Social;
  const Creation = typeof require !== 'undefined' ? require('./creation') : window.Creation;
  const Competition = typeof require !== 'undefined' ? require('./competition') : window.Competition;
  const Exploration = typeof require !== 'undefined' ? require('./exploration') : window.Exploration;
  const Physical = typeof require !== 'undefined' ? require('./physical') : window.Physical;
  const Auth = typeof require !== 'undefined' ? require('./auth') : window.Auth;
  const Network = typeof require !== 'undefined' ? require('./network') : window.Network;
  const World = typeof require !== 'undefined' ? require('./world') : window.World;
  const Input = typeof require !== 'undefined' ? require('./input') : window.Input;
  const HUD = typeof require !== 'undefined' ? require('./hud') : window.HUD;
  const XR = typeof require !== 'undefined' ? require('./xr') : window.XR;
  const Audio = typeof require !== 'undefined' ? require('./audio') : window.Audio;
  const NPCs = typeof require !== 'undefined' ? require('./npcs') : window.NPCs;
  const Quests = typeof require !== 'undefined' ? require('./quests') : window.Quests;
  const Mentoring = typeof require !== 'undefined' ? require('./mentoring') : window.Mentoring;
  const Guilds = typeof require !== 'undefined' ? require('./guilds') : window.Guilds;
  const Seasons = typeof require !== 'undefined' ? require('./seasons') : window.Seasons;
  const Pets = typeof require !== 'undefined' ? require('./pets') : window.Pets;
  const ApiBridge = typeof require !== 'undefined' ? require('./api_bridge') : window.ApiBridge;

  var EMBEDDED_SOULS = [{"id":"agent_001","name":"Iris Skyhigh","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_002","name":"Meadow Mindclear","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_003","name":"Luna Pathfinder","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_004","name":"Luna Rootdeep","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_005","name":"Storm Windwalker","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_006","name":"Wren Voicetrue","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_007","name":"Delta Hopefast","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_008","name":"Luna Songsmith","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_009","name":"Wren Starseed","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_010","name":"Lyra Thoughtdeep","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_011","name":"Wren Moonwhisper","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_012","name":"Frost Rootdeep","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_013","name":"River Soulbright","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_014","name":"Felix Shadowmender","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_015","name":"Phoenix Sunweaver","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_016","name":"Luna Rootdeep","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_017","name":"Vale Truthseeker","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_018","name":"Ezra Willstrong","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_019","name":"Nova Dreamweaver","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_020","name":"Echo Thoughtdeep","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_021","name":"Vale Waterborn","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_022","name":"Vale Spaceborn","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_023","name":"Echo Thoughtdeep","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_024","name":"Nova Hopefast","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_025","name":"Ridge Handsteady","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_026","name":"Frost Voicetrue","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_027","name":"Drift Shadowmender","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_028","name":"Vale Pathfinder","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_029","name":"Haven Handsteady","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_030","name":"River Mindclear","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_031","name":"Meadow Lightbringer","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_032","name":"Fern Spaceborn","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_033","name":"Sage Starseed","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_034","name":"Blaze Wordkeeper","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_035","name":"Orion Sunweaver","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_036","name":"Breeze Mindclear","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_037","name":"Ash Thoughtdeep","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_038","name":"Mira Truthseeker","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_039","name":"Sage Skyhigh","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_040","name":"Luna Stonecarver","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_041","name":"Phoenix Waterborn","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_042","name":"Luna Moonwhisper","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_043","name":"Haven Handsteady","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_044","name":"Jasper Shadowmender","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_045","name":"Phoenix Spiritfree","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_046","name":"Cedar Timewalker","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_047","name":"Grove Skyhigh","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_048","name":"Haven Heartstrong","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_049","name":"Fern Handsteady","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_050","name":"Stella Windwalker","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_051","name":"Cliff Songsmith","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_052","name":"River Footswift","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_053","name":"Ezra Dreamweaver","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_054","name":"Opal Moonwhisper","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_055","name":"Sol Mindclear","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_056","name":"Aria Waterborn","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_057","name":"Dawn Mindclear","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_058","name":"Opal Earthshaper","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_059","name":"Ezra Spaceborn","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_060","name":"Iris Timewalker","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_061","name":"River Pathfinder","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_062","name":"Storm Sunweaver","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_063","name":"Coral Songsmith","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_064","name":"Reef Hopefast","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_065","name":"Storm Skyhigh","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_066","name":"Jasper Moonwhisper","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_067","name":"Willow Heartstrong","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_068","name":"Blaze Stonecarver","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_069","name":"Meadow Firekeeper","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_070","name":"Echo Soulbright","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_071","name":"Coral Mindclear","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_072","name":"Grove Pathfinder","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_073","name":"Ridge Heartstrong","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_074","name":"Flint Rootdeep","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_075","name":"Cedar Spiritfree","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_076","name":"Zion Truthseeker","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_077","name":"Quill Dreamweaver","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_078","name":"Orion Footswift","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_079","name":"Drift Sunweaver","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_080","name":"Ash Sunweaver","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_081","name":"Haven Timewalker","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_082","name":"Aria Spaceborn","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_083","name":"Phoenix Thoughtdeep","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_084","name":"Cedar Wordkeeper","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_085","name":"Cliff Sunweaver","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_086","name":"Sage Handsteady","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_087","name":"Rain Dreamweaver","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_088","name":"Flint Heartstrong","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_089","name":"Cliff Heartstrong","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_090","name":"Echo Footswift","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"},{"id":"agent_091","name":"Reef Spiritfree","archetype":"gardener","personality":["patient","nurturing","observant"],"home_zone":"gardens"},{"id":"agent_092","name":"Vale Spiritfree","archetype":"builder","personality":["creative","methodical","ambitious"],"home_zone":"commons"},{"id":"agent_093","name":"River Mindclear","archetype":"storyteller","personality":["expressive","imaginative","empathetic"],"home_zone":"athenaeum"},{"id":"agent_094","name":"River Soulbright","archetype":"merchant","personality":["shrewd","social","opportunistic"],"home_zone":"agora"},{"id":"agent_095","name":"Ezra Spiritfree","archetype":"explorer","personality":["curious","brave","adaptable"],"home_zone":"wilds"},{"id":"agent_096","name":"Kai Thoughtdeep","archetype":"teacher","personality":["wise","patient","generous"],"home_zone":"athenaeum"},{"id":"agent_097","name":"Cliff Hopefast","archetype":"musician","personality":["artistic","rhythmic","emotional"],"home_zone":"nexus"},{"id":"agent_098","name":"Blaze Hopefast","archetype":"healer","personality":["compassionate","calm","perceptive"],"home_zone":"gardens"},{"id":"agent_099","name":"North Songsmith","archetype":"philosopher","personality":["contemplative","analytical","questioning"],"home_zone":"wilds"},{"id":"agent_100","name":"Ezra Dreamweaver","archetype":"artist","personality":["creative","passionate","experimental"],"home_zone":"commons"}];

  let gameState = null;
  let sceneContext = null;
  let messageQueue = [];
  let isRunning = false;
  let lastTimestamp = 0;
  let worldTime = 0; // Minutes in 24-hour cycle (0-1440)
  let currentZone = 'nexus';
  let currentWeather = 'clear';
  let npcIntentionIndex = 0; // Throttle: which NPC to evaluate next
  let localPlayer = null;
  let playStartTime = 0;
  let lastBreakReminder = 0;
  let footstepTimer = 0;
  let currentTimePeriod = 'morning';  // tracks dawn/morning/midday/afternoon/evening/night
  let cameraYaw = 0;       // horizontal camera orbit angle (radians)
  let cameraPitch = 0.35;  // vertical tilt (0 = flat, higher = more top-down)
  let cameraDistance = 18;  // distance from player
  let isDragging = false;
  let lastMouseX = 0, lastMouseY = 0;
  let playerInventory = null;
  let economyLedger = null;
  let raycaster = null;
  let simCrmState = null;
  let lastSimCrmTick = 0;
  var SIM_CRM_TICK_INTERVAL = 45000; // 45 seconds between CRM ticks
  let npcUpdateFrame = 0;
  let visitedZones = { nexus: true }; // Track discovered zones for piano accents

  let frameCount = 0;
  let fpsFrameTimes = [];
  let currentFPS = 60;
  let showDebug = false; // Set to true to show FPS counter

  let playTimeSeconds = 0;
  let recentActivities = [];

  let lastAutoSave = 0;
  let AUTO_SAVE_INTERVAL = 60000; // 60 seconds

  let lastSecretCheck = 0;
  let SECRET_CHECK_INTERVAL = 2000; // Check every 2 seconds

  let currentEconomicEvent = null;
  let lastEventCheck = 0;

  let currentSeason = null;
  let lastSeasonCheck = 0;
  let SEASON_CHECK_INTERVAL = 60000; // Check season every 60s

  let lastPetUpdate = 0;
  let PET_UPDATE_INTERVAL = 30000; // Update pet every 30s

  var lastRaceCheck = 0;
  var RACE_CHECK_INTERVAL = 500; // Check every 500ms

  let isFishing = false;

  var worldEvents = {
    shootingStars: {
      lastSpawn: 0,
      interval: 30000, // 30-90 seconds in milliseconds
      active: []
    },
    resourceBloom: {
      lastSpawn: 0,
      interval: 600000, // 10-15 minutes in milliseconds
      activeZone: null,
      startTime: 0,
      duration: 120000 // 2 minutes
    },
    auroraBorealis: {
      lastSpawn: 0,
      interval: 1200000, // 20+ minutes in milliseconds
      active: false,
      mesh: null,
      startTime: 0,
      duration: 240000, // 3-5 minutes
      animTime: 0
    },
    wanderingMerchant: {
      lastSpawn: 0,
      interval: 900000, // 15 minutes in milliseconds
      activeZone: null
    },
    fireflySwarm: {
      lastSpawn: 0,
      interval: 1800000, // 30 minutes
      active: false,
      startTime: 0,
      duration: 180000 // 3 minutes
    }
  };

  let gpsHistory = [];
  let gpsWatchId = null;
  let lastWarmthUpdate = 0;

  let platform = 'desktop';

  var cameraShake = { intensity: 0, duration: 0, elapsed: 0, active: false };

  function triggerCameraShake(intensity, duration) {
    cameraShake.intensity = intensity;
    cameraShake.duration = duration;
    cameraShake.elapsed = 0;
    cameraShake.active = true;
  }

  function startZoneCinematic() {
    if (!sceneContext || !localPlayer) return;
    var cam = sceneContext.camera;
    cinematicCamera.active = true;
    cinematicCamera.elapsed = 0;
    cinematicCamera.startPos = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
    cinematicCamera.peakPos = {
      x: cam.position.x,
      y: cam.position.y + 15,
      z: cam.position.z - 8
    };
    var Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
    var zoneInfo = Zones && Zones.ZONES ? Zones.ZONES[currentZone] : null;
    var lookX = zoneInfo ? zoneInfo.cx : localPlayer.position.x;
    var lookZ = zoneInfo ? zoneInfo.cz : localPlayer.position.z;
    var lookY = (World && World.getTerrainHeight) ? World.getTerrainHeight(lookX, lookZ) + 1.5 : 1.5;
    cinematicCamera.startLookAt = {
      x: localPlayer.position.x,
      y: ((World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0) + 1.5,
      z: localPlayer.position.z
    };
    cinematicCamera.targetLookAt = { x: lookX, y: lookY, z: lookZ };
  }

  function updateCinematicCamera(deltaTime) {
    if (!cinematicCamera.active || !sceneContext) return false;
    cinematicCamera.elapsed += deltaTime;
    var progress = Math.min(cinematicCamera.elapsed / cinematicCamera.duration, 1.0);
    var ease = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    var cam = sceneContext.camera;
    var sp = cinematicCamera.startPos;
    var pp = cinematicCamera.peakPos;

    if (progress < 0.5) {
      var t = ease * 2; // 0 to 1 over first half
      cam.position.x = sp.x + (pp.x - sp.x) * t;
      cam.position.y = sp.y + (pp.y - sp.y) * t;
      cam.position.z = sp.z + (pp.z - sp.z) * t;
    } else {
      var inputDist = Input && Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;
      var inputOrbit = Input && Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;
      var terrY = (World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0;
      var normalX = localPlayer.position.x + Math.sin(inputOrbit) * Math.cos(cameraPitch) * inputDist;
      var normalY = terrY + Math.sin(cameraPitch) * inputDist + 2;
      var normalZ = localPlayer.position.z + Math.cos(inputOrbit) * Math.cos(cameraPitch) * inputDist;
      var t2 = (ease - 0.5) * 2; // 0 to 1 over second half
      cam.position.x = pp.x + (normalX - pp.x) * t2;
      cam.position.y = pp.y + (normalY - pp.y) * t2;
      cam.position.z = pp.z + (normalZ - pp.z) * t2;
    }

    var sl = cinematicCamera.startLookAt;
    var tl = cinematicCamera.targetLookAt;
    var lookBlend = Math.min(ease * 1.5, 1.0); // Look moves faster than camera
    cam.lookAt(
      sl.x + (tl.x - sl.x) * lookBlend,
      sl.y + (tl.y - sl.y) * lookBlend,
      sl.z + (tl.z - sl.z) * lookBlend
    );

    if (progress >= 1.0) {
      cinematicCamera.active = false;
    }
    return true;
  }

  function togglePhotoMode() {
    photoMode.active = !photoMode.active;
    var hudContainer = document.getElementById('hud-container');
    if (photoMode.active) {
      if (Audio && Audio.playSound) Audio.playSound('shutter');
      if (sceneContext && sceneContext.camera) {
        photoMode.freeLookAt = {
          x: localPlayer ? localPlayer.position.x : 0,
          y: localPlayer ? ((World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0) + 1.5 : 1.5,
          z: localPlayer ? localPlayer.position.z : 0
        };
      }
      if (hudContainer) {
        photoMode.savedHUDDisplay = hudContainer.style.display;
        hudContainer.style.display = 'none';
      }
      if (!photoMode.labelEl) {
        photoMode.labelEl = document.createElement('div');
        photoMode.labelEl.style.cssText = 'position:fixed;top:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);color:#fff;padding:6px 16px;border-radius:4px;font:13px monospace;z-index:9999;pointer-events:none;';
        photoMode.labelEl.textContent = 'PHOTO MODE â€” F2 to exit';
        document.body.appendChild(photoMode.labelEl);
      }
      photoMode.labelEl.style.display = 'block';
      setVignetteIntensity(0.6);
    } else {
      if (hudContainer) {
        hudContainer.style.display = photoMode.savedHUDDisplay || '';
      }
      if (photoMode.labelEl) {
        photoMode.labelEl.style.display = 'none';
      }
      setVignetteIntensity(0.3);
    }
  }

  function updatePhotoModeCamera(deltaTime) {
    if (!photoMode.active || !sceneContext || !Input) return false;
    var delta = Input.getMovementDelta();
    var inputOrbit = Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;
    var inputDist = Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;

    var speed = 0.3;
    if (delta.x !== 0 || delta.z !== 0) {
      var sinY = Math.sin(inputOrbit);
      var cosY = Math.cos(inputOrbit);
      photoMode.freeLookAt.x += (delta.x * cosY - delta.z * sinY) * speed;
      photoMode.freeLookAt.z += (delta.x * sinY + delta.z * cosY) * speed;
      var ty = (World && World.getTerrainHeight) ? World.getTerrainHeight(photoMode.freeLookAt.x, photoMode.freeLookAt.z) : 0;
      photoMode.freeLookAt.y = ty + 1.5;
    }

    var camX = photoMode.freeLookAt.x + Math.sin(inputOrbit) * Math.cos(cameraPitch) * inputDist;
    var camY = photoMode.freeLookAt.y + Math.sin(cameraPitch) * inputDist;
    var camZ = photoMode.freeLookAt.z + Math.cos(inputOrbit) * Math.cos(cameraPitch) * inputDist;

    var lf = 0.12;
    sceneContext.camera.position.x += (camX - sceneContext.camera.position.x) * lf;
    sceneContext.camera.position.y += (camY - sceneContext.camera.position.y) * lf;
    sceneContext.camera.position.z += (camZ - sceneContext.camera.position.z) * lf;

    sceneContext.camera.lookAt(
      photoMode.freeLookAt.x,
      photoMode.freeLookAt.y,
      photoMode.freeLookAt.z
    );
    return true;
  }

  var cinematicCamera = {
    active: false, elapsed: 0, duration: 1.2,
    startPos: null, peakPos: null,
    startLookAt: null, targetLookAt: null
  };

  var photoMode = {
    active: false,
    freeLookAt: null,
    savedHUDDisplay: '',
    labelEl: null
  };

  var currentInteractionTarget = null; // { object, type, name, distance, action, mesh }
  var tooltipEl = null;

  var lastHoverCheckTime = 0;

  var floatingTexts = [];

  function showFloatingText(text, screenX, screenY) {
    var el = document.createElement('div');
    el.textContent = text;
    el.style.cssText = 'position:fixed;pointer-events:none;z-index:300;' +
      'color:#DAA520;font:bold 14px var(--font-ui);text-shadow:0 1px 3px rgba(0,0,0,0.8);' +
      'left:' + screenX + 'px;top:' + screenY + 'px;transform:translate(-50%,0);' +
      'transition:transform 1.2s ease-out,opacity 1.2s ease-out;opacity:1;';
    document.body.appendChild(el);
    requestAnimationFrame(function() {
      el.style.transform = 'translate(-50%,-40px)';
      el.style.opacity = '0';
    });
    setTimeout(function() {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, 1300);
  }

  function showSparkPopup(amount) {
    if (!amount || amount <= 0) return;
    if (!sceneContext || !sceneContext.camera || !sceneContext.renderer || !localPlayer || !localPlayer.position) return;
    if (!window.THREE) return;
    var pos = new window.THREE.Vector3(localPlayer.position.x, localPlayer.position.y + 2.5, localPlayer.position.z);
    pos.project(sceneContext.camera);
    var sx = (pos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
    var sy = (-pos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;
    showFloatingText('+' + amount + ' Spark', sx, sy);
    if (Audio) Audio.playSound('coin');
  }

  var screenFlashOverlay = null;
  var vignetteOverlay = null;

  function triggerScreenFlash(color, duration) {
    if (!screenFlashOverlay) {
      screenFlashOverlay = document.createElement('div');
      screenFlashOverlay.style.position = 'fixed';
      screenFlashOverlay.style.top = '0';
      screenFlashOverlay.style.left = '0';
      screenFlashOverlay.style.width = '100%';
      screenFlashOverlay.style.height = '100%';
      screenFlashOverlay.style.pointerEvents = 'none';
      screenFlashOverlay.style.zIndex = '9998';
      screenFlashOverlay.style.opacity = '0';
      screenFlashOverlay.style.transition = 'opacity 0.1s ease-out';
      document.body.appendChild(screenFlashOverlay);
    }

    screenFlashOverlay.style.backgroundColor = color;
    screenFlashOverlay.style.opacity = '0.6';

    setTimeout(function() {
      screenFlashOverlay.style.transition = 'opacity ' + duration + 's ease-out';
      screenFlashOverlay.style.opacity = '0';
    }, 50);
  }

  function setVignetteIntensity(intensity) {
    if (!vignetteOverlay) {
      vignetteOverlay = document.createElement('div');
      vignetteOverlay.style.position = 'fixed';
      vignetteOverlay.style.top = '0';
      vignetteOverlay.style.left = '0';
      vignetteOverlay.style.width = '100%';
      vignetteOverlay.style.height = '100%';
      vignetteOverlay.style.pointerEvents = 'none';
      vignetteOverlay.style.zIndex = '9997';
      vignetteOverlay.style.transition = 'box-shadow 0.5s ease';
      document.body.appendChild(vignetteOverlay);
    }

    var spread = Math.floor(150 * intensity);
    var alpha = 0.3 + (intensity * 0.4); // 0.3-0.7 range
    vignetteOverlay.style.boxShadow = 'inset 0 0 ' + spread + 'px rgba(0,0,0,' + alpha + ')';
  }

  function emitLevelUpParticles() {
    if (World && World.emitParticles && localPlayer && localPlayer.position) {
      var levelUpPos = { x: localPlayer.position.x, y: localPlayer.position.y + 2, z: localPlayer.position.z };
      World.emitParticles('sparkle', levelUpPos, 25);
    }
    triggerScreenFlash('#DAA520', 0.3);
  }

  function detectNearestInteractable() {
    if (!localPlayer) return null;

    var nearestTarget = null;
    var minDist = 10; // Max interaction range

    var playerX = localPlayer.position.x;
    var playerZ = localPlayer.position.z;

    if (NPCs && NPCs.getNPCPositions) {
      var npcPositions = NPCs.getNPCPositions();
      for (var i = 0; i < npcPositions.length; i++) {
        var npc = npcPositions[i];
        if (!npc) continue;
        var dx = npc.x - playerX;
        var dz = npc.z - playerZ;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearestTarget = {
            type: 'npc',
            name: npc.name || 'NPC',
            action: 'Talk',
            distance: dist,
            mesh: npc.mesh,
            position: { x: npc.x, y: localPlayer.position.y + 1, z: npc.z }
          };
        }
      }
    }

    if (World && World.getInteractiveAtPosition) {
      var nearbyObj = World.getInteractiveAtPosition(playerX, playerZ, minDist);
      if (nearbyObj) {
        var dx = nearbyObj.position.x - playerX;
        var dz = nearbyObj.position.z - playerZ;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearestTarget = {
            type: 'interactive',
            name: nearbyObj.type ? nearbyObj.type.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase(); }) : 'Object',
            action: nearbyObj.action ? nearbyObj.action.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase(); }) : 'Use',
            distance: dist,
            mesh: nearbyObj.mesh,
            position: nearbyObj.position
          };
        }
      }
    }

    if (World && World.getResourceNodeAtMouse) {
    }

    return nearestTarget;
  }

  function updateTooltip() {
    if (!tooltipEl || !sceneContext || !sceneContext.camera || !sceneContext.renderer) return;

    if (!currentInteractionTarget) {
      tooltipEl.style.display = 'none';
      return;
    }

    if (!window.THREE) return;
    var pos = new window.THREE.Vector3(
      currentInteractionTarget.position.x,
      currentInteractionTarget.position.y + 3, // Offset above object
      currentInteractionTarget.position.z
    );
    pos.project(sceneContext.camera);

    var x = (pos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
    var y = (-pos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;

    tooltipEl.style.left = x + 'px';
    tooltipEl.style.top = y + 'px';
    tooltipEl.style.display = 'block';

    tooltipEl.innerHTML = '<span style="color:#DAA520">' + currentInteractionTarget.name + '</span>' +
      '<br><span style="color:#A0978E; font-size:11px">[E] ' + currentInteractionTarget.action + '</span>';
  }

  async function init() {
    console.log('Initializing ZION MMO...');

    if (Input) {
      platform = Input.getPlatform();
      console.log('Platform:', platform);
    }

    if (!Auth) {
      console.error('Auth module not available');
      return;
    }

    await Auth.handleCallback();

    if (!Auth.isAuthenticated()) {
      showLoginScreen();
      return;
    }

    if (typeof document !== 'undefined') {
      var loginEl = document.getElementById('login-screen');
      if (loginEl) loginEl.style.display = 'none';
      var loadingEl = document.getElementById('loading-overlay');
      if (loadingEl) loadingEl.style.display = 'flex';
    }

    const username = Auth.getUsername();
    console.log('Authenticated as:', username);

    await initGameSystems(username);

    if (typeof document !== 'undefined') {
      var loadEl = document.getElementById('loading-overlay');
      if (loadEl) {
        loadEl.style.opacity = '0';
        loadEl.style.transition = 'opacity 0.5s ease';
        setTimeout(function() { loadEl.style.display = 'none'; }, 600);
      }
    }

    if (HUD && HUD.initTutorial) {
      setTimeout(function() { HUD.initTutorial(); }, 1500);
    }

    startGameLoop();
  }

  async function initGameSystems(username) {
    if (Audio) {
      Audio.initAudio();
    }

    if (State) {
      gameState = State.initState();
      localPlayer = {
        id: username,
        name: username,
        position: { x: 0, y: 0, z: 0 },
        zone: 'nexus',
        spark: 1000,
        warmth: 0
      };
      State.addPlayer(gameState, localPlayer);
    }

    if (Economy) {
      economyLedger = Economy.createLedger();
      economyLedger.balances[username] = 1000;
    }

    if (Inventory) {
      playerInventory = Inventory.createInventory();
      Inventory.addItem(playerInventory, 'wood_oak', 5);
      Inventory.addItem(playerInventory, 'stone_common', 5);
      Inventory.addItem(playerInventory, 'seed_wildflower', 3);
    }

    if (typeof THREE !== 'undefined') {
      raycaster = new THREE.Raycaster();
    }

    if (Network) {
      const urlParams = typeof URLSearchParams !== 'undefined' && typeof window !== 'undefined'
        ? new URLSearchParams(window.location.search) : null;
      const isHost = urlParams && urlParams.get('host') === 'true';
      const peerId = isHost ? 'zion-lobby-main' : `zion-${username}-${Date.now()}`;
      Network.initMesh(peerId, {
        onMessage: handleIncomingMessage,
        onPeerConnect: (peerId) => {
          console.log('Peer connected:', peerId);
          HUD && HUD.showNotification(`Player connected: ${peerId}`, 'info');
        },
        onPeerDisconnect: (peerId) => {
          console.log('Peer disconnected:', peerId);
          HUD && HUD.showNotification(`Player disconnected: ${peerId}`, 'info');
          if (gameState && State) {
            State.removePlayer(gameState, peerId);
          }
        }
      });

      const lobbyPeer = Network.getLobbyPeerId('main');
      Network.connectToPeer(lobbyPeer);

      if (Network.joinLobby) {
        Network.joinLobby('main', username, currentZone);
      }

      setTimeout(function() {
        joinWorld();
      }, 2000);

      const worldId = Network.deriveWorldId();
      const worldName = 'ZION'; // Could be customized per fork
      const endpoint = typeof window !== 'undefined' ? window.location.origin : 'http://localhost';
      Network.initFederation(worldId, worldName, endpoint);

      Network.onFederationEvent((event) => {
        handleFederationEvent(event);
      });

      setInterval(() => {
        if (Network.announceFederation) {
          Network.announceFederation();
        }
      }, 60000); // Every 60 seconds

      setTimeout(() => {
        if (Network.announceFederation) {
          Network.announceFederation();
        }
      }, 5000); // After 5 seconds to let connections establish
    }

    if (ApiBridge && ApiBridge.init) {
      ApiBridge.init();
    }

    if (typeof fetch !== 'undefined' && State && State.getLiveState && State.setLiveState) {
      const RAW = 'https://raw.githubusercontent.com/kody-w/zion/main/state';
      const loadCanonical = function(file) {
        return fetch(RAW + '/' + file, { cache: 'no-cache' })
          .then(function(r) { return r.ok ? r.json() : null; })
          .catch(function() { return null; });
      };
      Promise.all([loadCanonical('world.json'), loadCanonical('chat.json')])
        .then(function(results) {
          var world = results[0];
          var chat = results[1];
          if (!world && !chat) return;
          var live = State.getLiveState();
          if (world) {
            var citizens = world.citizens || {};
            if (!live.players) live.players = {};
            for (var cid in citizens) {
              if (citizens.hasOwnProperty(cid) && !live.players[cid]) {
                live.players[cid] = citizens[cid];
              }
            }
            if (!live.world) live.world = {};
            live.world.time = world.worldTime || live.world.time || 0;
            live.world.dayPhase = world.dayPhase || live.world.dayPhase || 'day';
            live.world.weather = world.weather || live.world.weather || 'clear';
            live.world.season = world.season || live.world.season || 'spring';
            live.world.structures = world.structures || [];
            live.world.creations = world.creations || [];
          }
          if (chat && chat.messages) {
            if (!live.chat) live.chat = [];
            var liveIds = {};
            for (var i = 0; i < live.chat.length; i++) {
              if (live.chat[i].id) liveIds[live.chat[i].id] = true;
            }
            for (var j = 0; j < chat.messages.length; j++) {
              var m = chat.messages[j];
              if (!m.id || !liveIds[m.id]) {
                live.chat.push(m);
              }
            }
          }
          State.setLiveState(live);
          console.log('[Canonical] Loaded %d citizens, %d chat messages from state/',
            Object.keys((world && world.citizens) || {}).length,
            (chat && chat.messages || []).length);
        });
    }

    if (typeof SimCRM !== 'undefined' && SimCRM.initState) {
      simCrmState = SimCRM.initState();
      console.log('[SimCRM] Initialized');
    }

    if (typeof document !== 'undefined' && World) {
      const container = document.getElementById('game-container') || document.body;
      sceneContext = World.initScene(container);

      if (sceneContext) {
        World.loadZone(sceneContext, currentZone);
        if (World.updateChunks) {
          World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
        }
        World.addPlayer(sceneContext, username, localPlayer.position);

        if (World.initParticles) {
          World.initParticles(sceneContext);
        }

        if (World.initWater) {
          World.initWater(sceneContext);
        }

        if (World.initSkybox) {
          World.initSkybox(sceneContext);
        }

        if (World.initResourceNodes) {
          World.initResourceNodes(sceneContext);
        }

        if (World.spawnZoneInteractives) {
          World.spawnZoneInteractives(sceneContext, currentZone);
        }

        if (World.initWildlife) {
          World.initWildlife(sceneContext);
        }

        if (World.initZoneAmbience) {
          World.initZoneAmbience(sceneContext);
        }

        if (World.initSeasonalParticles) {
          World.initSeasonalParticles(sceneContext);
        }

        setVignetteIntensity(0.3);

        if (World.createZoneBoundaryParticles && sceneContext.scene) {
          World.createZoneBoundaryParticles(sceneContext.scene);
        }

        if (World.initBillboardClouds) World.initBillboardClouds(sceneContext);
        if (World.initRainSplashes) World.initRainSplashes(sceneContext);
        if (World.initValleyFog) World.initValleyFog(sceneContext);
        if (World.initZoneBorderShimmer) World.initZoneBorderShimmer(sceneContext);

        if (World.loadWorldMemory) World.loadWorldMemory();

        if (World.weatherCallbacks) {
          World.weatherCallbacks.onLightningStrike = function(boltX, boltZ) {
            triggerCameraShake(0.3, 0.4);
            var thunderDelay = 1000 + Math.random() * 2000;
            setTimeout(function() {
              if (Audio && Audio.playAmbient) {
                triggerScreenFlash('rgba(255,255,255,0.15)', 0.1);
              }
            }, thunderDelay);
          };
        }
      }
    }

    if (typeof document !== 'undefined' && HUD) {
      const container = document.getElementById('game-container') || document.body;
      HUD.initHUD(container);
      HUD.updateZoneLabel(currentZone);
      HUD.updatePlayerInfo(localPlayer);

      if (HUD.initToolbar) {
        HUD.initToolbar();
      }

      if (HUD.initQuestTracker) {
        HUD.initQuestTracker();
      }

      if (Social && Social.initReputation) {
        Social.initReputation(localPlayer.id);
        if (HUD.updateReputationDisplay) {
          HUD.updateReputationDisplay(Social.getReputation(localPlayer.id));
        }
      }

      if (HUD.initGovernancePanel) {
        HUD.initGovernancePanel(handleGovernanceAction);
      }

      if (HUD.initInventoryPanel) {
        HUD.initInventoryPanel();
      }

      if (HUD.initCraftingPanel) {
        HUD.initCraftingPanel(function(recipeId) {
          handleCraft(recipeId);
        });
      }

      if (HUD.initQuickBar) {
        HUD.initQuickBar();
      }

      if (HUD.loadSettings) {
        HUD.loadSettings();
        var settings = HUD.getSettings();
        if (settings && Audio) {
          if (Audio.setVolume) {
            Audio.setVolume('master', settings.masterVolume / 100);
            Audio.setVolume('music', settings.musicVolume / 100);
            Audio.setVolume('sfx', settings.sfxVolume / 100);
          }
        }
        if (settings) {
          showDebug = settings.showFPS;
        }
      }

      getPlayTimeSeconds();

      HUD.addChatInput((text) => {
        handleLocalAction('chat', { message: text });
        HUD.hideChatInput();
      });

      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'interaction-tooltip';
        tooltipEl.style.cssText = 'position:fixed; pointer-events:none; z-index:200; ' +
          'background:rgba(10,14,26,0.85); border:1px solid rgba(218,165,32,0.6); ' +
          'border-radius:6px; padding:6px 12px; color:#E8E0D8; font-size:12px; ' +
          'font-family:var(--font-ui); display:none; transform:translate(-50%,-100%); ' +
          'backdrop-filter:blur(5px); white-space:nowrap;';
        document.body.appendChild(tooltipEl);
      }
    }

    if (Quests) {
      Quests.initPlayerQuests(username);
      if (Quests.initPlayerAchievements) {
        Quests.initPlayerAchievements(username);
      }
      console.log('Quest system initialized for player:', username);
    }

    var wasRestored = restorePlayerData();
    if (wasRestored) {
      console.log('Restored saved player data');
      var timeSince = Auth.getTimeSinceLastSave ? Auth.getTimeSinceLastSave() : Infinity;
      if (timeSince < 86400000 && HUD) { // Less than 24 hours
        var minsAgo = Math.floor(timeSince / 60000);
        var timeStr = minsAgo < 60 ? minsAgo + ' minutes' : Math.floor(minsAgo / 60) + ' hours';
        setTimeout(function() {
          HUD.showNotification('Welcome back! Last seen ' + timeStr + ' ago', 'info');
        }, 2000);
      }
    }

    if (Trading && Network) {
      Trading.initTrading(function(msg) {
        Network.broadcastMessage(msg);
      });
      console.log('Trading system initialized');
    }

    if (HUD && HUD.setNPCActionCallback) {
      HUD.setNPCActionCallback(function(action, npcData) {
        handleNPCAction(action, npcData);
      });
    }

    if (Input) {
      Input.initInput({
        onMove: (delta) => {
        },
        onAction: (type, data) => {
          handleLocalAction(type, data);
        },
        onChat: (data) => {
          if (data.mode === 'open') {
            HUD && HUD.showChatInput();
          }
        },
        onBuild: (data) => {
          handleBuildAction(data);
        }
      });
    }

    if (typeof document !== 'undefined' && sceneContext && sceneContext.renderer) {
      var hoverCanvas = sceneContext.renderer.domElement;
      hoverCanvas.addEventListener('mousemove', function(e) {
        var now = Date.now();
        if (now - lastHoverCheckTime < 100) return; // Throttle to 100ms
        lastHoverCheckTime = now;
        if (!raycaster || !sceneContext.camera || !World) return;
        var rect = hoverCanvas.getBoundingClientRect();
        var mx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        var my = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        var node = World.getResourceNodeAtMouse(raycaster, sceneContext.camera, mx, my);
        document.body.style.cursor = node ? 'pointer' : 'default';
      });
    }

    if ('ontouchstart' in window && typeof document !== 'undefined') {
      var photoBtn = document.createElement('div');
      photoBtn.id = 'mobile-photo-btn';
      photoBtn.innerHTML = '&#128247;'; // camera emoji
      photoBtn.style.cssText = 'position:fixed;bottom:80px;right:16px;width:44px;height:44px;' +
        'background:rgba(10,14,26,0.7);border:1px solid rgba(218,165,32,0.5);border-radius:50%;' +
        'color:#E8E0D8;font-size:20px;display:flex;align-items:center;justify-content:center;' +
        'z-index:150;cursor:pointer;backdrop-filter:blur(5px);';
      photoBtn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePhotoMode();
        photoBtn.innerHTML = photoMode.active ? '&#10005;' : '&#128247;';
      });
      document.body.appendChild(photoBtn);
    }

    if (Audio) {
      Audio.playAmbient(currentZone);
      if (Audio.startMusic) Audio.startMusic(currentZone, currentTimePeriod || 'midday');
    }

    if (NPCs) {
      NPCs.initNPCs(null, gameState, sceneContext);
      NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);

      if (Intentions && EMBEDDED_SOULS && EMBEDDED_SOULS.length > 0) {
        var registered = 0;
        EMBEDDED_SOULS.forEach(function(soul) {
          if (soul.intentions && soul.intentions.length > 0) {
            Intentions.clearIntentions(soul.id);
            soul.intentions.forEach(function(intent) {
              Intentions.registerIntention(soul.id, intent);
            });
            registered++;
          }
        });
        console.log('Registered intentions for ' + registered + ' NPCs');
      }
    }

    updateEconomicEvent();

    initSeasonalEvent();

    if (XR && XR.initXR) {
      XR.initXR().then(function(caps) {
        if (HUD && HUD.setXRCapabilities) {
          HUD.setXRCapabilities(caps, sceneContext);
        }
      });
    }

    initPetSystem(username);

    if (typeof window !== 'undefined') {
      window.playerInventory = playerInventory;
      window._onAnchorPlace = function(data) {
        if (State && gameState) {
          var msg = { type: 'anchor_place', from: localPlayer.id, ts: Date.now(), payload: { anchor: data } };
          gameState = State.applyMessage(gameState, msg);
        }
      };
      window._onElectionStart = function(data) {
        if (State && gameState) {
          var msg = { type: 'election_start', from: localPlayer.id, ts: Date.now(), payload: data };
          gameState = State.applyMessage(gameState, msg);
        }
      };
      window._onElectionVote = function(data) {
        if (State && gameState) {
          var msg = { type: 'election_vote', from: localPlayer.id, ts: Date.now(), payload: data };
          gameState = State.applyMessage(gameState, msg);
        }
      };
      window._onFederationPropose = function(data) {
        if (State && gameState) {
          var msg = { type: 'federation_announce', from: localPlayer.id, ts: Date.now(), payload: { federation: data } };
          gameState = State.applyMessage(gameState, msg);
        }
      };
    }

    joinWorld();

    playStartTime = Date.now();

    if (typeof navigator !== 'undefined' && navigator.geolocation) {
      try {
        gpsWatchId = navigator.geolocation.watchPosition(function(pos) {
          gpsHistory.push({
            lat: pos.coords.latitude,
            lon: pos.coords.longitude,
            ts: Date.now()
          });
          if (gpsHistory.length > 100) {
            gpsHistory = gpsHistory.slice(-100);
          }
        }, function() {
          console.log('Geolocation not available - Warmth bonus disabled');
        }, { enableHighAccuracy: false, maximumAge: 30000, timeout: 10000 });
      } catch (e) {
      }
    }

    console.log('Game systems initialized');
  }

  function getScreenPosition(position, camera, renderer) {
    if (!window.THREE || !camera || !renderer) return null;

    var vector = new window.THREE.Vector3(position.x, position.y + 2, position.z);
    vector.project(camera);

    var widthHalf = renderer.domElement.width / 2;
    var heightHalf = renderer.domElement.height / 2;

    return {
      x: (vector.x * widthHalf) + widthHalf,
      y: -(vector.y * heightHalf) + heightHalf
    };
  }

  function showLoginScreen() {
    if (typeof document === 'undefined') {
      console.log('Not authenticated. Please authenticate.');
      return;
    }

    const loginScreen = document.createElement('div');
    loginScreen.id = 'login-screen';
    loginScreen.style.cssText = `
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1040 40%, #0d2137 70%, #0a0e1a 100%);
      display: flex; align-items: center; justify-content: center;
      z-index: 10000; font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    `;

    var starCanvas = document.createElement('canvas');
    starCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;';
    starCanvas.width = window.innerWidth;
    starCanvas.height = window.innerHeight;
    loginScreen.appendChild(starCanvas);
    var starCtx = starCanvas.getContext('2d');
    var loginStars = [];
    for (var si = 0; si < 150; si++) {
      loginStars.push({
        x: Math.random() * starCanvas.width,
        y: Math.random() * starCanvas.height,
        r: 0.5 + Math.random() * 1.5,
        speed: 0.1 + Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2
      });
    }
    function animateLoginStars() {
      if (!document.getElementById('login-screen')) return;
      starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
      var time = Date.now() * 0.001;
      loginStars.forEach(function(s) {
        var alpha = 0.3 + Math.sin(time * s.speed + s.phase) * 0.4;
        starCtx.fillStyle = 'rgba(180, 200, 255, ' + Math.max(0, alpha) + ')';
        starCtx.beginPath();
        starCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        starCtx.fill();
      });
      requestAnimationFrame(animateLoginStars);
    }
    animateLoginStars();

    const content = document.createElement('div');
    content.style.cssText = 'text-align:center;color:white;position:relative;z-index:1;';

    content.innerHTML = `
      <div style="font-size:72px;font-weight:100;letter-spacing:16px;margin-bottom:8px;
        background:linear-gradient(135deg,#4af,#a8f,#4af);-webkit-background-clip:text;
        -webkit-text-fill-color:transparent;background-clip:text;">ZION</div>
      <p style="font-size:16px;margin-bottom:40px;opacity:0.6;letter-spacing:4px;text-transform:uppercase;">
        A peer-to-peer social metaverse</p>
      <button id="github-login" style="
        padding:16px 48px;font-size:16px;background:rgba(255,255,255,0.1);
        color:white;border:1px solid rgba(255,255,255,0.3);border-radius:30px;
        cursor:pointer;font-weight:500;letter-spacing:1px;
        backdrop-filter:blur(10px);transition:all 0.3s;
      " onmouseover="this.style.background='rgba(255,255,255,0.2)';this.style.borderColor='rgba(255,255,255,0.6)'"
         onmouseout="this.style.background='rgba(255,255,255,0.1)';this.style.borderColor='rgba(255,255,255,0.3)'"
      >Login with GitHub</button>
      <p style="margin-top:24px;font-size:12px;opacity:0.4;">
        Or append ?token=YOUR_GITHUB_PAT to the URL</p>
      <div style="margin-top:60px;font-size:11px;opacity:0.3;">
        100 AI citizens await in 8 zones</div>
    `;

    loginScreen.appendChild(content);
    document.body.appendChild(loginScreen);

    document.getElementById('github-login').addEventListener('click', () => {
      if (Auth) {
        Auth.initiateOAuth();
      }
    });
  }

  function startGameLoop() {
    isRunning = true;
    lastTimestamp = performance.now();

    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    } else {
      console.warn('requestAnimationFrame not available');
    }
  }

  function gameLoop(timestamp) {
    if (!isRunning) return;

    const deltaTime = (timestamp - lastTimestamp) / 1000; // seconds
    lastTimestamp = timestamp;

    npcUpdateFrame++;
    frameCount++;

    fpsFrameTimes.push(deltaTime);
    if (fpsFrameTimes.length > 60) {
      fpsFrameTimes.shift();
    }
    if (fpsFrameTimes.length > 10) {
      var avgFrameTime = fpsFrameTimes.reduce(function(a, b) { return a + b; }, 0) / fpsFrameTimes.length;
      currentFPS = avgFrameTime > 0 ? Math.round(1 / avgFrameTime) : 60;
    }

    playTimeSeconds += deltaTime;
    if (frameCount % 1800 === 0) {
      savePlayTime();
    }

    if (HUD && HUD.getSettings) {
      var settings = HUD.getSettings();
      if (settings) {
        showDebug = settings.showFPS;
      }
    }

    processMessageQueue();

    if (Input && localPlayer && gameState && !photoMode.active) {
      const delta = Input.getMovementDelta();
      if (delta.x !== 0 || delta.z !== 0) {
        var sinYaw = Math.sin(cameraYaw);
        var cosYaw = Math.cos(cameraYaw);
        var rotatedDelta = {
          x: delta.x * cosYaw - delta.z * sinYaw,
          y: delta.y,
          z: delta.x * sinYaw + delta.z * cosYaw
        };

        const moveMsg = Input.createMoveMessage(
          localPlayer.id,
          rotatedDelta,
          localPlayer.position,
          currentZone
        );

        var newPos = moveMsg.payload.position;
        if (World && World.checkCollision && World.checkCollision(newPos.x, newPos.z, 0.5)) {
          var slideX = { x: newPos.x, y: localPlayer.position.y, z: localPlayer.position.z };
          var slideZ = { x: localPlayer.position.x, y: localPlayer.position.y, z: newPos.z };
          if (!World.checkCollision(slideX.x, slideX.z, 0.5)) {
            moveMsg.payload.position = slideX;
          } else if (!World.checkCollision(slideZ.x, slideZ.z, 0.5)) {
            moveMsg.payload.position = slideZ;
          } else {
            moveMsg.payload.position = { x: localPlayer.position.x, y: localPlayer.position.y, z: localPlayer.position.z };
          }
        }

        handleLocalAction('move', moveMsg.payload);

        if (Network) {
          Network.broadcastMessage(moveMsg);
        }

        if (World && World.updateChunks && sceneContext) {
          World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
        }

        if (World && World.getZoneAtPosition) {
          var detectedZone = World.getZoneAtPosition(localPlayer.position.x, localPlayer.position.z);
          if (detectedZone !== currentZone) {
            var oldZone = currentZone;
            currentZone = detectedZone;
            console.log('Entered zone:', currentZone);

            if (Audio && Audio.playSound) Audio.playSound('zone_enter');

            addRecentActivity('Entered ' + currentZone);

            if (Mentoring) {
              var xpResult = Mentoring.addSkillXP(localPlayer.id, 'exploration', 8);
              if (xpResult.leveledUp && HUD) {
                HUD.showNotification('Exploration skill increased to ' + xpResult.newLevelName, 'success');
                emitLevelUpParticles();
              }
            }

            if (HUD) {
              HUD.updateZoneLabel(currentZone);
              HUD.showNotification('Entered ' + currentZone.charAt(0).toUpperCase() + currentZone.slice(1), 'info');
            }

            if (Audio) {
              Audio.playAmbient(currentZone);
              if (Audio.setZoneAmbient) Audio.setZoneAmbient(currentZone);
              if (Audio.updateMusic) Audio.updateMusic(currentZone, currentTimePeriod);
              if (Audio.playPianoAccent && !visitedZones[currentZone]) {
                Audio.playPianoAccent('zone_discovery');
              }
            }
            visitedZones[currentZone] = true;

            if (NPCs) {
              NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
              if (NPCs.broadcastEvent) {
                NPCs.broadcastEvent({ type: 'player_zone_change', data: {
                  playerId: localPlayer.id, fromZone: oldZone, toZone: currentZone,
                  position: localPlayer.position
                }});
              }
            }

            if (World && World.clearInteractiveObjects && World.spawnZoneInteractives) {
              World.clearInteractiveObjects(sceneContext);
              World.spawnZoneInteractives(sceneContext, currentZone);
            }

            if (Zones && Zones.recordZoneVisit) {
              Zones.recordZoneVisit(currentZone, localPlayer.id);
            }

            if (Zones && HUD) {
              var policies = Zones.getZonePolicies(currentZone);
              if (policies && policies.welcomeMessage) {
                HUD.showNotification(policies.welcomeMessage, 'info');
              }
            }

            if (Quests) {
              var updated = Quests.updateQuestProgress(localPlayer.id, 'visit_zone', { zone: currentZone });
              if (updated.length > 0 && HUD) {
                updated.forEach(function(quest) {
                  HUD.showQuestProgress('Quest progress: ' + quest.title);
                });
              }
            }

            trackAchievement('zone_visit', { zone: currentZone });
          }
        }

        if (NPCs && Math.random() < 0.03) {
          NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
        }

        footstepTimer += deltaTime;
        if (footstepTimer >= 0.4) {
          var footstepTerrain = 'grass'; // default
          if (currentZone === 'nexus') footstepTerrain = 'stone';
          else if (currentZone === 'gardens') footstepTerrain = 'grass';
          else if (currentZone === 'athenaeum') footstepTerrain = 'stone';
          else if (currentZone === 'studio') footstepTerrain = 'wood';
          else if (currentZone === 'wilds') footstepTerrain = 'grass';
          else if (currentZone === 'agora') footstepTerrain = 'stone';
          else if (currentZone === 'commons') footstepTerrain = 'wood';
          else if (currentZone === 'arena') footstepTerrain = 'stone';

          if (Audio && Audio.playFootstep) {
            Audio.playFootstep(footstepTerrain);
          }
          footstepTimer = 0;
        }
      } else {
        footstepTimer = 0;
      }
    }

    if (Intentions && NPCs && localPlayer && gameState) {
      var agents = NPCs.getAgents ? NPCs.getAgents() : [];
      if (agents.length > 0) {
        var worldStateForIntentions = {
          players: new Map()
        };
        worldStateForIntentions.players.set(localPlayer.id, {
          id: localPlayer.id,
          position: localPlayer.position
        });
        agents.forEach(function(agent) {
          if (agent.position) {
            worldStateForIntentions.players.set(agent.id, {
              id: agent.id,
              position: { x: agent.position.x, y: agent.position.y || 0, z: agent.position.z }
            });
          }
        });
        var count = Math.min(5, agents.length);
        for (var ei = 0; ei < count; ei++) {
          var idx = (npcIntentionIndex + ei) % agents.length;
          var agent = agents[idx];
          var actions = Intentions.evaluateTriggers(agent.id, worldStateForIntentions, deltaTime);
          if (actions && actions.length > 0) {
            actions.forEach(function(action) {
              if (action.type === 'say' && NPCs.showNPCSpeechBubble) {
                NPCs.showNPCSpeechBubble(agent.id, action.payload ? action.payload.text || action.payload.message : '...');
              }
            });
          }
        }
        npcIntentionIndex = (npcIntentionIndex + count) % agents.length;
      }
    }

    worldTime += deltaTime * 60; // 60x speed
    if (worldTime >= 1440) worldTime -= 1440;

    var worldHour = worldTime / 60;
    var newTimePeriod = 'night';
    if (worldHour >= 5 && worldHour < 7) newTimePeriod = 'dawn';
    else if (worldHour >= 7 && worldHour < 12) newTimePeriod = 'morning';
    else if (worldHour >= 12 && worldHour < 14) newTimePeriod = 'midday';
    else if (worldHour >= 14 && worldHour < 18) newTimePeriod = 'afternoon';
    else if (worldHour >= 18 && worldHour < 21) newTimePeriod = 'evening';
    else newTimePeriod = 'night';

    if (newTimePeriod !== currentTimePeriod) {
      currentTimePeriod = newTimePeriod;
      if (NPCs && NPCs.broadcastEvent) {
        NPCs.broadcastEvent({ type: 'time_change', data: { period: currentTimePeriod, hour: worldHour } });
      }
      if (Audio && Audio.updateAmbientTime) {
        Audio.updateAmbientTime(currentTimePeriod);
      }
      if (Audio && Audio.updateMusic) {
        Audio.updateMusic(currentZone, currentTimePeriod);
      }
      if (Audio && Audio.playPianoAccent) {
        if (currentTimePeriod === 'dawn') Audio.playPianoAccent('dawn');
        else if (currentTimePeriod === 'morning') Audio.playPianoAccent('morning');
        else if (currentTimePeriod === 'evening') Audio.playPianoAccent('dusk');
        else if (currentTimePeriod === 'night') Audio.playPianoAccent('night');
      }
    }

    if (NPCs) {
      var npcWorldState = {
        weather: currentWeather,
        worldTime: worldTime,
        timePeriod: currentTimePeriod,
        playerPosition: localPlayer ? localPlayer.position : null,
        playerId: localPlayer ? localPlayer.id : null
      };
      NPCs.updateNPCs(sceneContext, gameState, deltaTime, worldTime, npcWorldState);
      if (NPCs.updateSpeechBubbles && sceneContext && sceneContext.camera) {
        NPCs.updateSpeechBubbles(sceneContext.camera);
      }
    }

    if (sceneContext && World) {
      if (gameState && State) {
        const players = State.getPlayers(gameState);
        players.forEach(player => {
          if (player.id !== localPlayer.id) {
            World.movePlayer(sceneContext, player.id, player.position);
          } else {
            World.movePlayer(sceneContext, player.id, localPlayer.position);
          }
        });
      }

      if (sceneContext.camera && localPlayer) {
        var terrainY = 0;
        if (World && World.getTerrainHeight) {
          terrainY = World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z);
        }
        localPlayer.position.y = terrainY;

        if (photoMode.active) {
          updatePhotoModeCamera(deltaTime);
        }
        else {
        var inputCameraDistance = Input && Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;
        var inputCameraOrbit = Input && Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;

        var camOffX = Math.sin(inputCameraOrbit) * Math.cos(cameraPitch) * inputCameraDistance;
        var camOffY = Math.sin(cameraPitch) * inputCameraDistance;
        var camOffZ = Math.cos(inputCameraOrbit) * Math.cos(cameraPitch) * inputCameraDistance;

        var camTargetX = localPlayer.position.x + camOffX;
        var camTargetY = terrainY + camOffY + 2;
        var camTargetZ = localPlayer.position.z + camOffZ;

        var camTerrainY = World && World.getTerrainHeight ? World.getTerrainHeight(camTargetX, camTargetZ) : 0;
        if (camTargetY < camTerrainY + 2) camTargetY = camTerrainY + 2;

        var lerpFactor = 0.08;
        sceneContext.camera.position.x += (camTargetX - sceneContext.camera.position.x) * lerpFactor;
        sceneContext.camera.position.y += (camTargetY - sceneContext.camera.position.y) * lerpFactor;
        sceneContext.camera.position.z += (camTargetZ - sceneContext.camera.position.z) * lerpFactor;

        if (cameraShake.active) {
          cameraShake.elapsed += deltaTime;
          var progress = cameraShake.elapsed / cameraShake.duration;
          if (progress >= 1) {
            cameraShake.active = false;
          } else {
            var decay = 1 - progress;
            var shakeX = (Math.random() - 0.5) * 2 * cameraShake.intensity * decay;
            var shakeY = (Math.random() - 0.5) * 2 * cameraShake.intensity * decay;
            sceneContext.camera.position.x += shakeX;
            sceneContext.camera.position.y += shakeY;
          }
        }

        sceneContext.camera.lookAt(
          localPlayer.position.x,
          terrainY + 1.5,
          localPlayer.position.z
        );
        } // end normal camera else block
      }

      World.updateDayNight(sceneContext, worldTime);

      var weatherCycleMinute = Math.floor(worldTime / 240); // 0-5
      var weatherTypes = ['clear', 'cloudy', 'rain', 'clear', 'storm', 'snow'];
      var nextWeather = weatherTypes[weatherCycleMinute % weatherTypes.length];
      if (nextWeather !== currentWeather) {
        var prevWeather = currentWeather;
        currentWeather = nextWeather;
        if (World.setWeather) {
          World.setWeather(sceneContext, currentWeather);
        }
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'weather_change', data: { weather: currentWeather, previous: prevWeather } });
        }
        if (Audio && Audio.updateAmbientWeather) {
          Audio.updateAmbientWeather(currentWeather);
        }
        if (currentWeather === 'storm') {
          setVignetteIntensity(0.7);
        } else if (currentWeather === 'rain' || currentWeather === 'snow') {
          setVignetteIntensity(0.5);
        } else {
          setVignetteIntensity(0.3);
        }
      }

      if (World.cullLights) {
        World.cullLights(sceneContext, localPlayer.position, 40, 12);
      }

      if (frameCount % 10 === 0 && World.updateFrustumCulling) {
        World.updateFrustumCulling(sceneContext);
      }

      if (frameCount % 30 === 0 && World.updateLOD) {
        World.updateLOD(sceneContext, localPlayer.position);
      }

      if (World.updateAnimations) {
        World.updateAnimations(sceneContext, deltaTime, worldTime);
      }

      if (World.updateResourceNodes) {
        World.updateResourceNodes(deltaTime);
      }

      if (World.updatePlayerAnimations) {
        World.updatePlayerAnimations(sceneContext, deltaTime);
      }

      if (World.updateParticles) {
        World.updateParticles(sceneContext, deltaTime * 1000, localPlayer ? localPlayer.position : null);
      }

      if (World.updateWeatherEffects) {
        World.updateWeatherEffects(sceneContext, deltaTime * 1000, localPlayer ? localPlayer.position : null);
      }

      if (World.updateZoneAmbience && localPlayer) {
        World.updateZoneAmbience(sceneContext, localPlayer.zone, deltaTime * 1000);
      }

      if (World.updateSeasonalVisuals) {
        var seasonNormalizedTime = worldTime / 1440;
        World.updateSeasonalVisuals(sceneContext, localPlayer ? localPlayer.zone : 'nexus', deltaTime * 1000, seasonNormalizedTime);
      }

      if (World.updateWater) {
        var currentWeather = World.getCurrentWeather ? World.getCurrentWeather() : 'clear';
        World.updateWater(deltaTime, currentWeather);
      }

      if (World.updateSkybox) {
        World.updateSkybox(sceneContext, worldTime);
      }

      if (World.updateInteractiveAnimations) {
        World.updateInteractiveAnimations(deltaTime);
      }
      if (World.updateInteractiveHighlights && localPlayer) {
        World.updateInteractiveHighlights(localPlayer.position.x, localPlayer.position.z, 4);
      }

      if (localPlayer) {
        var newTarget = detectNearestInteractable();

        if (newTarget !== currentInteractionTarget) {
          if (World && World.unhighlightObject) {
            World.unhighlightObject();
          }

          currentInteractionTarget = newTarget;

          if (currentInteractionTarget && currentInteractionTarget.mesh && World && World.highlightObject) {
            World.highlightObject(currentInteractionTarget.mesh);
          }
        }

        updateTooltip();
      }

      if (World.updateWildlife) {
        World.updateWildlife(sceneContext, deltaTime, worldTime);
      }

      updateWorldEvents(deltaTime, worldTime, sceneContext);

      if (World.updateZoneBoundaryParticles) {
        World.updateZoneBoundaryParticles(worldTime);
      }

      if (World.updateWorldMemory && localPlayer) {
        var nearbyCount = 0;
        if (NPCs && NPCs.getNearbyNPCCount) {
          nearbyCount = NPCs.getNearbyNPCCount(localPlayer.position, 5);
        }
        World.updateWorldMemory(localPlayer.position, nearbyCount, deltaTime);
      }

      if (World.updateBillboardClouds) {
        World.updateBillboardClouds(deltaTime, currentWeather);
      }

      if (World.updateSnowAccumulation) {
        World.updateSnowAccumulation(deltaTime * 1000, currentWeather);
      }

      if (World.updateValleyFog) {
        World.updateValleyFog(worldTime, currentWeather);
      }

      if (World.updateTerrainBreathing) {
        World.updateTerrainBreathing(deltaTime, worldTime);
      }

      if (World.updateWindSystem) {
        World.updateWindSystem(deltaTime, currentWeather);
      }

      if (World.updateZoneBorderShimmer) {
        World.updateZoneBorderShimmer(worldTime);
      }

      if (buildModeActive && World && World.updateBuildPreview && Input && Input.getMouseNDC) {
        var mousePos = Input.getMouseNDC();
        World.updateBuildPreview(sceneContext, mousePos.x, mousePos.y, sceneContext.camera);
      }

      if (sceneContext.renderer && sceneContext.scene && sceneContext.camera) {
        sceneContext.renderer.render(sceneContext.scene, sceneContext.camera);
      }
    }

    if (HUD && gameState && State) {
      HUD.updatePlayerInfo(localPlayer);

      const players = State.getPlayers(gameState);

      if (HUD.updateEmoteBubbles && sceneContext && sceneContext.camera) {
        var playerPositions = {};
        players.forEach(function(player) {
          if (World && World.getPlayerMesh) {
            var mesh = World.getPlayerMesh(sceneContext, player.id);
            if (mesh) {
              var screenPos = getScreenPosition(mesh.position, sceneContext.camera, sceneContext.renderer);
              if (screenPos) {
                playerPositions[player.id] = screenPos;
              }
            }
          }
        });
        HUD.updateEmoteBubbles(playerPositions);
      }
      const mapPlayers = players.map(p => ({
        id: p.id,
        position: p.position,
        isLocal: p.id === localPlayer.id
      }));
      HUD.updateMinimap(mapPlayers, currentZone);

      if (HUD.updateMinimapNPCs && NPCs && NPCs.getNPCPositions) {
        HUD.updateMinimapNPCs(NPCs.getNPCPositions(), localPlayer.position);
      }

      const nearby = players
        .filter(p => p.id !== localPlayer.id && p.zone === currentZone)
        .map(p => {
          const dx = p.position.x - localPlayer.position.x;
          const dz = p.position.z - localPlayer.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          return { id: p.id, name: p.name, distance };
        })
        .sort((a, b) => a.distance - b.distance);

      HUD.updateNearbyPlayers(nearby);

      if (HUD.updateCoords && localPlayer) {
        HUD.updateCoords(localPlayer.position);
      }

      if (HUD.updateTimeWeather) {
        HUD.updateTimeWeather(worldTime, currentWeather);
      }

      const messages = Social ? Social.getRecentMessages(gameState) : [];
      HUD.updateChat(messages);

      if (Quests && HUD.updateQuestTracker && npcUpdateFrame % 30 === 0) {
        var activeQuests = Quests.getActiveQuests(localPlayer.id);
        HUD.updateQuestTracker(activeQuests);
      }

      if (Quests && NPCs && NPCs.updateQuestIndicators && npcUpdateFrame % 60 === 0) {
        NPCs.updateQuestIndicators(localPlayer.id, localPlayer.position);
      }

      var now = Date.now();
      if (now - lastWarmthUpdate > 5000 && Physical && gpsHistory.length >= 2) {
        lastWarmthUpdate = now;
        var newWarmth = Physical.calculateWarmth(gpsHistory);
        if (localPlayer && newWarmth !== localPlayer.warmth) {
          localPlayer.warmth = newWarmth;
        }
      }

      if (showDebug && typeof document !== 'undefined') {
        var fpsElement = document.getElementById('fps-counter');
        if (!fpsElement) {
          fpsElement = document.createElement('div');
          fpsElement.id = 'fps-counter';
          fpsElement.style.position = 'fixed';
          fpsElement.style.top = '10px';
          fpsElement.style.right = '10px';
          fpsElement.style.padding = '8px 12px';
          fpsElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          fpsElement.style.color = '#00ff00';
          fpsElement.style.fontFamily = 'monospace';
          fpsElement.style.fontSize = '12px';
          fpsElement.style.borderRadius = '4px';
          fpsElement.style.zIndex = '10000';
          document.body.appendChild(fpsElement);
        }

        var perfStats = World && World.getPerformanceStats ? World.getPerformanceStats() : null;
        var statsText = 'FPS: ' + currentFPS;
        if (perfStats) {
          statsText += '\nObjects: ' + perfStats.visibleObjects + '/' + perfStats.totalObjects;
          statsText += '\nAnimations: ' + perfStats.activeAnimations;
          statsText += '\nChunks: ' + perfStats.loadedChunks;
          statsText += '\nTriangles: ' + perfStats.estimatedTriangles;
        }
        fpsElement.innerText = statsText;
      }
    }

    const minutesPlayed = (Date.now() - playStartTime) / 60000;
    if (minutesPlayed > 30 && minutesPlayed - lastBreakReminder > 30) {
      if (HUD) {
        HUD.showBreakReminder(Math.floor(minutesPlayed));
      }
      lastBreakReminder = minutesPlayed;
    }

    var nowMs = Date.now();
    if (nowMs - lastAutoSave > AUTO_SAVE_INTERVAL) {
      lastAutoSave = nowMs;
      autoSavePlayerData();
      if (State && economyLedger) {
        State.setLiveState('economy', {
          balances: economyLedger.balances || {},
          transactions: (economyLedger.transactions || []).slice(-50),
          listings: economyLedger.listings || []
        });
        State.flushToLocal();
      }
    }

    if (nowMs - lastSecretCheck > SECRET_CHECK_INTERVAL) {
      lastSecretCheck = nowMs;
      checkSecrets();
    }

    if (nowMs - lastEventCheck > 30000) {
      lastEventCheck = nowMs;
      updateEconomicEvent();
    }

    if (nowMs - lastSeasonCheck > SEASON_CHECK_INTERVAL) {
      lastSeasonCheck = nowMs;
      updateSeasonalEvent();
    }

    if (nowMs - lastPetUpdate > PET_UPDATE_INTERVAL) {
      lastPetUpdate = nowMs;
      updatePetStatus();
    }

    if (nowMs - lastRaceCheck > RACE_CHECK_INTERVAL && localPlayer && gameState && Competition && Competition.checkRaceProgress) {
      lastRaceCheck = nowMs;
      var comps = gameState.competitions;
      if (comps && comps.length > 0) {
        for (var ri = 0; ri < comps.length; ri++) {
          var rc = comps[ri];
          if (rc.type === 'race' && rc.status === 'active' && rc.participants && rc.participants.indexOf(localPlayer.id) !== -1) {
            var raceResult = Competition.checkRaceProgress(rc.id, localPlayer.id, localPlayer.position, gameState);
            if (raceResult.checkpointHit) {
              if (raceResult.finished) {
                HUD.showNotification('Race complete! Time: ' + (raceResult.time / 1000).toFixed(1) + 's', 'success');
                if (Audio) Audio.playSound('coin');
              } else {
                HUD.showNotification('Checkpoint ' + raceResult.currentCheckpoint + '/' + rc.checkpoints.length + '!', 'info');
                if (Audio) Audio.playSound('item_pickup');
              }
            }
          }
        }
      }
    }

    if (typeof SimCRM !== 'undefined' && SimCRM.simulateTick && simCrmState && nowMs - lastSimCrmTick >= SIM_CRM_TICK_INTERVAL) {
      lastSimCrmTick = nowMs;
      simCrmState = SimCRM.simulateTick(simCrmState);
    }

    if (ApiBridge && ApiBridge.update) {
      ApiBridge.update(nowMs, gameState);
    }

    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    }
  }

  function processMessageQueue() {
    while (messageQueue.length > 0) {
      const msg = messageQueue.shift();
      applyMessage(msg);
    }
  }

  function handleFederationEvent(event) {
    if (!event || !event.type) return;

    switch (event.type) {
      case 'world_discovered':
        console.log('Discovered federated world:', event.worldInfo.worldName);
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Discovered world: ' + event.worldInfo.worldName, 'info');
        }
        if (HUD && HUD.updateFederationStatus) {
          HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
        }
        break;

      case 'federation_established':
        console.log('Federation established with:', event.worldInfo.worldName);
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Portal opened to: ' + event.worldInfo.worldName, 'success');
        }
        if (HUD && HUD.updateFederationStatus) {
          HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
        }
        if (World && sceneContext && currentZone === 'nexus') {
          createFederationPortal(event.worldInfo);
        }
        break;

      case 'cross_world_warp':
        console.log('Player warping to world:', event.targetWorld);
        triggerCameraShake(0.4, 0.6);
        triggerScreenFlash('rgba(138,43,226,0.4)', 0.5);
        break;

      case 'player_returned':
        console.log('Player returned:', event.playerId);
        break;

      default:
        console.log('Unknown federation event:', event.type);
    }
  }

  function createFederationPortal(worldInfo) {
    if (!World || !sceneContext || !World.createPortal) return;

    var portalCount = Network.getFederatedWorlds().length;
    var angle = (portalCount * Math.PI * 2) / 8; // Spread around circle
    var radius = 30;
    var x = Math.cos(angle) * radius;
    var z = Math.sin(angle) * radius;

    var portalData = {
      id: 'portal-fed-' + worldInfo.worldId,
      position: { x: x, y: 0, z: z },
      targetWorld: worldInfo.worldId,
      worldName: worldInfo.worldName,
      type: 'federation'
    };

    World.createPortal(sceneContext, portalData);
    console.log('Created federation portal to:', worldInfo.worldName);
  }

  function handleIncomingMessage(msg) {
    if (!Protocol) {
      return;
    }
    if (Protocol.validateMessage) {
      var validation = Protocol.validateMessage(msg);
      if (!validation.valid) {
        if (!msg || !msg.type || !msg.from) {
          console.warn('Invalid message received (no type/from):', msg);
          return;
        }
      }
    }

    messageQueue.push(msg);
  }

  function applyMessage(msg) {
    if (!gameState || !State) return;

    switch (msg.type) {
      case 'join':
        handleJoinMessage(msg);
        break;
      case 'leave':
        handleLeaveMessage(msg);
        break;
      case 'move':
        handleMoveMessage(msg);
        break;
      case 'chat':
      case 'say':
      case 'shout':
      case 'whisper':
        handleChatMessage(msg);
        break;
      case 'warp':
        handleWarpMessage(msg);
        break;
      case 'harvest':
        handleHarvestMessage(msg);
        break;
      case 'build':
        handleBuildMessage(msg);
        break;
      case 'trade':
        handleTradeMessage(msg);
        break;
      case 'trade_offer':
      case 'trade_accept':
      case 'trade_decline':
        handleTradeProtocolMessage(msg);
        break;
      case 'emote':
        handleEmoteMessage(msg);
        break;
      case 'discover':
        handleDiscoverMessage(msg);
        break;
      case 'score':
        handleScoreMessage(msg);
        break;
      case 'federation_announce':
        handleFederationAnnounce(msg);
        break;
      case 'federation_handshake':
        handleFederationHandshake(msg);
        break;
      case 'warp_fork':
        handleWarpFork(msg);
        break;
      case 'return_home':
        handleReturnHome(msg);
        break;
      default:
        console.log('Unknown message type:', msg.type);
    }
  }

  function handleEmoteMessage(msg) {
    if (!msg.payload || !msg.payload.emoteType) return;

    if (World && sceneContext && NPCs && NPCs.playEmoteAnimation) {
      var playerMesh = World.getPlayerMesh ? World.getPlayerMesh(sceneContext, msg.from) : null;
      if (playerMesh) {
        NPCs.playEmoteAnimation(playerMesh, msg.payload.emoteType);
      }
    }

    if (HUD && HUD.showEmoteBubble) {
      HUD.showEmoteBubble(msg.from, msg.payload.emoteType);
    }
  }

  function handleDiscoverMessage(msg) {
    if (!Exploration || !gameState) return;

    var result = Exploration.handleDiscover(msg, gameState);
    if (result.success) {
      gameState = result.state;

      if (msg.from === localPlayer.id) {
        if (HUD && HUD.showDiscoveryPopup) {
          var discoveryData = {
            name: result.discovery.type.charAt(0).toUpperCase() + result.discovery.type.slice(1),
            description: result.discovery.description,
            rarity: getRarityName(result.discovery.rarity),
            sparkReward: result.sparkAwarded
          };
          HUD.showDiscoveryPopup(discoveryData);
        }

        if (economyLedger && Economy && result.sparkAwarded) {
          var discoverySpark = Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: result.discovery.rarity });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(discoverySpark);
        }

        addRecentActivity('Discovered a ' + result.discovery.type);

        trackAchievement('discover', { type: result.discovery.type, rarity: result.discovery.rarity });

        if (Audio) Audio.playSound('warp');
      }
    }
  }

  function handleFederationAnnounce(msg) {
    if (!Network) return;

    Network.handleFederationMessage(msg);

    if (HUD && HUD.updateFederationStatus) {
      HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
    }
  }

  function handleFederationHandshake(msg) {
    if (!Network) return;

    Network.handleFederationMessage(msg);

    if (HUD && HUD.updateFederationStatus) {
      HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
    }

    var worldName = msg.worldName || msg.payload?.worldName || 'Unknown World';
    if (HUD && HUD.showNotification) {
      HUD.showNotification('Federation established with ' + worldName, 'success');
    }
  }

  function handleWarpFork(msg) {
    if (!msg.payload || !msg.payload.target_world) return;

    var targetWorld = msg.payload.target_world;
    var playerId = msg.from;

    if (playerId === localPlayer.id) {
      if (!localPlayer.home_world) {
        localPlayer.home_world = Network.deriveWorldId();
      }

      localPlayer.current_world = targetWorld;

      if (HUD && HUD.showNotification) {
        HUD.showNotification('Warping to federated world: ' + targetWorld, 'info');
      }

      triggerCameraShake(0.4, 0.6);
      triggerScreenFlash('rgba(138,43,226,0.4)', 0.5);

      console.log('Player warped to federated world:', targetWorld);
    } else {
      if (gameState && State) {
        State.removePlayer(gameState, playerId);
      }

      if (World && sceneContext) {
        World.removePlayer(sceneContext, playerId);
      }

      if (HUD && HUD.showNotification) {
        HUD.showNotification(playerId + ' traveled to another world', 'info');
      }
    }
  }

  function handleReturnHome(msg) {
    var playerId = msg.from;

    if (playerId === localPlayer.id) {
      var homeWorld = localPlayer.home_world || Network.deriveWorldId();
      localPlayer.current_world = homeWorld;

      if (HUD && HUD.showNotification) {
        HUD.showNotification('Returned to home world', 'success');
      }

      console.log('Player returned to home world:', homeWorld);
    } else {
      if (HUD && HUD.showNotification) {
        HUD.showNotification(playerId + ' returned from traveling', 'info');
      }
    }
  }

  function handleScoreMessage(msg) {
    if (!Competition || !gameState) return;

    var result = Competition.handleScore(msg, gameState);
    if (result.success) {
      gameState = result.state;

      if (Competition.getSpectators) {
        var spectators = Competition.getSpectators(result.competition.id);
        if (spectators.length > 0 && Competition.broadcastToSpectators) {
          Competition.broadcastToSpectators(
            result.competition.id,
            'score_update',
            {
              playerId: msg.from,
              score: msg.payload.score,
              competition: result.competition
            }
          );
        }
      }

      if (result.winner && result.sparkAward) {
        if (result.winner === localPlayer.id) {
          if (HUD) {
            HUD.showNotification('You won the competition! +' + result.sparkAward + ' Spark', 'success');
          }
          if (economyLedger && Economy) {
            var compSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'competition', { complexity: 1.0 });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
            showSparkPopup(compSpark);
          }
          if (Mentoring) {
            var combatXP = Mentoring.addSkillXP(localPlayer.id, 'combat', 25);
            if (combatXP.leveledUp && HUD) {
              HUD.showNotification('Combat skill increased to ' + combatXP.newLevelName + '!', 'success');
              emitLevelUpParticles();
            }
          }
        } else {
          if (Mentoring) {
            Mentoring.addSkillXP(localPlayer.id, 'combat', 8);
          }
        }
      }
    }
  }

  function getRarityName(rarity) {
    if (rarity >= 0.9) return 'legendary';
    if (rarity >= 0.7) return 'epic';
    if (rarity >= 0.5) return 'rare';
    if (rarity >= 0.3) return 'uncommon';
    return 'common';
  }

  function handleJoinMessage(msg) {
    const player = {
      id: msg.from,
      name: msg.from,
      position: msg.payload.position || { x: 0, y: 0, z: 0 },
      zone: msg.payload.zone || 'nexus',
      spark: 1000,
      warmth: 0
    };

    State.addPlayer(gameState, player);

    if (World && sceneContext) {
      World.addPlayer(sceneContext, player.id, player.position);
    }

    if (HUD) {
      HUD.showNotification(`${player.name} joined the world`, 'success');
    }

    if (Audio) {
      Audio.playSound('warp');
    }
  }

  function handleLeaveMessage(msg) {
    State.removePlayer(gameState, msg.from);

    if (World && sceneContext) {
      World.removePlayer(sceneContext, msg.from);
    }

    if (HUD) {
      HUD.showNotification(`${msg.from} left the world`, 'info');
    }
  }

  function handleMoveMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.position = msg.payload.position;
    player.zone = msg.payload.zone;

    if (msg.from !== localPlayer.id && World && sceneContext) {
      World.movePlayer(sceneContext, msg.from, player.position);
    }
  }

  function handleChatMessage(msg) {
    var text = msg.payload.message || msg.payload.text || '';
    var sender = msg.from;

    if (Social) {
      Social.addMessage(gameState, {
        user: sender,
        text: text,
        timestamp: msg.timestamp || msg.ts
      });
    }

    if (HUD && HUD.addChatMessage) {
      HUD.addChatMessage(sender, text);
    } else if (HUD) {
      HUD.showNotification(sender + ': ' + text, 'info');
    }

    if (Audio) {
      Audio.playSound('chat');
    }
  }

  function handleWarpMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.zone = msg.payload.zone;
    player.position = msg.payload.position;

    if (msg.from === localPlayer.id) {
      currentZone = msg.payload.zone;

      var zonePos = World.getZoneCenter ? World.getZoneCenter(currentZone) : {x: 0, z: 0};
      localPlayer.position.x = zonePos.x;
      localPlayer.position.z = zonePos.z;
      localPlayer.position.y = 0;

      if (World.updateChunks) {
        World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
      }

      if (HUD) {
        HUD.updateZoneLabel(currentZone);
      }

      if (Audio) {
        Audio.playAmbient(currentZone);
      }

      if (NPCs) {
        NPCs.reloadZoneNPCs(sceneContext, currentZone);
      }
    }

    if (World && World.emitParticles && player && player.position) {
      var warpPos = { x: player.position.x, y: player.position.y + 1, z: player.position.z };
      World.emitParticles('fountain', warpPos, 15);
    }

    if (Audio) {
      Audio.playSound('warp');
    }

    if (msg.from === localPlayer.id) {
      triggerCameraShake(0.3, 0.5);
      triggerScreenFlash('rgba(0,120,255,0.4)', 0.4);
    }
  }

  function handleHarvestMessage(msg) {
    if (Economy) {
      Economy.earnSpark(gameState, msg.from, msg.payload.amount || 10);
    }

    if (Audio) {
      Audio.playSound('harvest');
    }

    if (msg.from === localPlayer.id && HUD) {
      HUD.showNotification(`Harvested ${msg.payload.amount || 10} Spark`, 'success');
    }
  }

  function handleBuildMessage(msg) {
    if (msg.payload && msg.payload.sim === 'crm' && typeof SimCRM !== 'undefined' && simCrmState) {
      simCrmState = SimCRM.applyAction(simCrmState, msg);
      console.log('[SimCRM] Applied action:', msg.payload.action);
      return;
    }

    if (Creation && World && sceneContext) {
      const structure = msg.payload.structure;
      World.addStructure(sceneContext, structure);
    }

    if (Audio) {
      Audio.playSound('build');
    }

    if (msg.from === localPlayer.id) {
      var structureName = msg.payload.structure.type || 'structure';
      addRecentActivity('Built a ' + structureName);
    }
  }

  function handleTradeMessage(msg) {
    if (Economy) {
      Economy.transferSpark(
        gameState,
        msg.payload.from,
        msg.payload.to,
        msg.payload.amount
      );
    }

    if (Audio) {
      Audio.playSound('trade');
    }

    if (HUD && (msg.payload.from === localPlayer.id || msg.payload.to === localPlayer.id)) {
      HUD.showNotification(
        `Trade: ${msg.payload.amount} Spark`,
        'success'
      );
    }
  }

  function handleTradeProtocolMessage(msg) {
    if (!Trading || !HUD) return;

    var result = Trading.handleTradeMessage(msg);
    if (!result) return;

    switch (result.type) {
      case 'trade_request':
        if (result.data.to === localPlayer.id) {
          HUD.showTradeRequest(
            result.data.from,
            result.data.tradeId,
            function(tradeId) {
              var acceptResult = Trading.acceptTrade(tradeId, localPlayer.id, localPlayer.position);
              if (acceptResult.success) {
                showTradeWindowForActive(acceptResult.trade);
              } else {
                HUD.showNotification(acceptResult.message, 'error');
              }
            },
            function(tradeId) {
              Trading.declineTrade(tradeId, localPlayer.id, localPlayer.position);

              if (Social && result.data.from) {
                var harassment = Social.recordDecline(result.data.from, localPlayer.id, 'trade_offer');
                if (harassment && HUD) {
                  HUD.showNotification('Repeated unwanted interactions detected - reputation penalty applied', 'warning');
                }
              }
            }
          );
        }
        break;

      case 'trade_accepted':
        var activeTrade = Trading.getActiveTrade(localPlayer.id);
        if (activeTrade) {
          showTradeWindowForActive(activeTrade);
          HUD.showNotification('Trade started!', 'success');
        }
        break;

      case 'trade_update':
        var currentTrade = Trading.getActiveTrade(localPlayer.id);
        if (currentTrade && HUD.updateTradeWindow) {
          HUD.updateTradeWindow(currentTrade, localPlayer.id);
        }
        break;

      case 'trade_confirm':
        var confirmTrade = Trading.getActiveTrade(localPlayer.id);
        if (confirmTrade && HUD.updateTradeWindow) {
          HUD.updateTradeWindow(confirmTrade, localPlayer.id);
        }
        break;

      case 'trade_complete':
        HUD.hideTradeWindow();
        HUD.showTradeComplete(msg.from);
        if (Audio) Audio.playSound('trade');

        if (World && World.emitParticles && localPlayer && localPlayer.position) {
          var tradePos = { x: localPlayer.position.x, y: localPlayer.position.y + 1.5, z: localPlayer.position.z };
          World.emitParticles('sparkle', tradePos, 12);
        }

        trackAchievement('trade', { with: msg.from });

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'trading', 15);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Trading skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        if (Social) {
          var repResult = Social.adjustReputation(localPlayer.id, 'trading', { with: msg.from });
          if (repResult.tierChanged && HUD) {
            HUD.showNotification('Reputation increased to ' + repResult.tier + '!', 'success');
          }
          if (HUD && HUD.updateReputationDisplay) {
            HUD.updateReputationDisplay(Social.getReputation(localPlayer.id));
          }
        }

        if (HUD.updateInventoryDisplay && playerInventory) {
          HUD.updateInventoryDisplay(playerInventory);
          HUD.updateQuickBar(playerInventory);
        }
        if (localPlayer && economyLedger) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          HUD.updatePlayerInfo(localPlayer);
        }
        break;

      case 'trade_cancelled':
        HUD.hideTradeWindow();
        HUD.hideTradeRequest();
        HUD.showNotification('Trade cancelled', 'info');
        break;
    }
  }

  function showTradeWindowForActive(trade) {
    if (!HUD || !Trading) return;

    HUD.showTradeWindow(
      trade,
      localPlayer.id,
      function(slotIndex, itemId) {
        if (Trading && playerInventory) {
          var result = Trading.addItemToTrade(trade.id, localPlayer.id, itemId, playerInventory, localPlayer.position);
          if (result && !result.success) {
            HUD.showNotification(result.message || 'Cannot add item', 'error');
          }
        }
      },
      function(tradeSlot) {
        var result = Trading.removeItemFromTrade(trade.id, localPlayer.id, tradeSlot, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      function(amount) {
        var result = Trading.setSparkOffer(trade.id, localPlayer.id, amount, economyLedger, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      function() {
        var result = Trading.setReady(trade.id, localPlayer.id, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      function() {
        var player1Inv = trade.player1.id === localPlayer.id ? playerInventory : null;
        var player2Inv = trade.player2.id === localPlayer.id ? playerInventory : null;

        var result = Trading.confirmTrade(trade.id, localPlayer.id, player1Inv, player2Inv, economyLedger, localPlayer.position);
        if (result.success && result.executed) {
          HUD.hideTradeWindow();
          HUD.showTradeComplete(trade.player1.id === localPlayer.id ? trade.player2.id : trade.player1.id);
          if (Audio) Audio.playSound('trade');
          if (HUD.updateInventoryDisplay && playerInventory) {
            HUD.updateInventoryDisplay(playerInventory);
            HUD.updateQuickBar(playerInventory);
          }
          if (localPlayer && economyLedger) {
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            HUD.updatePlayerInfo(localPlayer);
          }
        } else if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      function() {
        Trading.cancelTrade(trade.id, localPlayer.id, localPlayer.position);
        HUD.hideTradeWindow();
      }
    );
  }

  var NPC_SHOP_ITEMS = {
    merchant: [
      { id: 'torch', name: 'Torch', price: 8, description: 'Lights the way', icon: '&#128294;' },
      { id: 'rope', name: 'Rope', price: 12, description: 'Useful for climbing and building', icon: '&#129526;' },
      { id: 'compass', name: 'Compass', price: 20, description: 'Helps with navigation', icon: '&#129517;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' },
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'spyglass', name: 'Spyglass', price: 35, description: 'See far-off landmarks', icon: '&#128269;' },
      { id: 'lantern_oil', name: 'Lantern Oil', price: 6, description: 'Fuel for lanterns', icon: '&#128167;' }
    ],
    trader: [
      { id: 'rare_seed', name: 'Rare Seed', price: 30, description: 'Grows into a rare plant', icon: '&#127793;' },
      { id: 'crystal_shard', name: 'Crystal Shard', price: 40, description: 'A glowing fragment', icon: '&#128142;' },
      { id: 'ancient_coin', name: 'Ancient Coin', price: 50, description: 'A relic from the founding', icon: '&#129689;' },
      { id: 'silk_thread', name: 'Silk Thread', price: 22, description: 'Fine textile material', icon: '&#129525;' },
      { id: 'copper_ingot', name: 'Copper Ingot', price: 18, description: 'Refined copper metal', icon: '&#129704;' }
    ],
    farmer: [
      { id: 'wheat_seed', name: 'Wheat Seeds', price: 5, description: 'Basic crop seeds', icon: '&#127806;' },
      { id: 'flower_seed', name: 'Flower Seeds', price: 8, description: 'Decorative flowers', icon: '&#127804;' },
      { id: 'herb_seed', name: 'Herb Seeds', price: 10, description: 'Medicinal herbs', icon: '&#127807;' },
      { id: 'fertilizer', name: 'Fertilizer', price: 15, description: 'Speeds up growth', icon: '&#128169;' },
      { id: 'seed_wildflower', name: 'Wildflower Seeds', price: 4, description: 'Beautiful wildflowers', icon: '&#127803;' }
    ],
    artisan: [
      { id: 'pigment', name: 'Pigment', price: 12, description: 'Natural color pigment', icon: '&#127912;' },
      { id: 'canvas', name: 'Canvas', price: 15, description: 'For painting masterworks', icon: '&#128444;' },
      { id: 'clay', name: 'Clay', price: 8, description: 'Moldable material', icon: '&#129520;' },
      { id: 'ink_bottle', name: 'Ink Bottle', price: 10, description: 'For writing and drawing', icon: '&#128395;' },
      { id: 'golden_frame', name: 'Golden Frame', price: 35, description: 'Display art beautifully', icon: '&#128444;' }
    ],
    gardener: [
      { id: 'seed_wildflower', name: 'Wildflower Seeds', price: 4, description: 'Beautiful wildflowers', icon: '&#127803;' },
      { id: 'herb_seed', name: 'Herb Seeds', price: 10, description: 'Medicinal herbs', icon: '&#127807;' },
      { id: 'rare_seed', name: 'Rare Seed', price: 30, description: 'Unusual plant variety', icon: '&#127793;' },
      { id: 'fertilizer', name: 'Fertilizer', price: 15, description: 'Speeds up growth', icon: '&#128169;' },
      { id: 'garden_shears', name: 'Garden Shears', price: 18, description: 'For pruning and shaping', icon: '&#9986;' }
    ],
    scholar: [
      { id: 'scroll_blank', name: 'Blank Scroll', price: 8, description: 'For recording knowledge', icon: '&#128220;' },
      { id: 'ink_bottle', name: 'Ink Bottle', price: 10, description: 'For writing', icon: '&#128395;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' },
      { id: 'lens', name: 'Magnifying Lens', price: 25, description: 'For studying fine details', icon: '&#128270;' },
      { id: 'ancient_tome', name: 'Ancient Tome', price: 45, description: 'Contains forgotten wisdom', icon: '&#128214;' }
    ],
    warrior: [
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'training_weight', name: 'Training Weight', price: 15, description: 'For strength training', icon: '&#127947;' },
      { id: 'bandage', name: 'Bandage', price: 8, description: 'First aid supply', icon: '&#129657;' },
      { id: 'arena_token', name: 'Arena Token', price: 20, description: 'Entry to special events', icon: '&#127941;' }
    ],
    musician: [
      { id: 'flute', name: 'Flute', price: 28, description: 'A simple wooden flute', icon: '&#127925;' },
      { id: 'drum', name: 'Drum', price: 22, description: 'A hand drum', icon: '&#129345;' },
      { id: 'bell', name: 'Bell', price: 15, description: 'A clear-toned bell', icon: '&#128276;' },
      { id: 'sheet_music', name: 'Sheet Music', price: 12, description: 'Musical compositions', icon: '&#127926;' }
    ],
    explorer: [
      { id: 'compass', name: 'Compass', price: 20, description: 'Never lose your way', icon: '&#129517;' },
      { id: 'rope', name: 'Rope', price: 12, description: 'For difficult terrain', icon: '&#129526;' },
      { id: 'spyglass', name: 'Spyglass', price: 35, description: 'See far-off landmarks', icon: '&#128269;' },
      { id: 'trail_ration', name: 'Trail Ration', price: 8, description: 'Sustenance for the road', icon: '&#127838;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' }
    ],
    healer: [
      { id: 'healing_herb', name: 'Healing Herb', price: 10, description: 'Soothing medicinal plant', icon: '&#127807;' },
      { id: 'bandage', name: 'Bandage', price: 8, description: 'First aid supply', icon: '&#129657;' },
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'herbal_tea', name: 'Herbal Tea', price: 6, description: 'Calming warm drink', icon: '&#127861;' }
    ]
  };

  function handleNPCAction(action, npcData) {
    if (!npcData || !localPlayer) return;

    switch (action) {
      case 'trade':
        var shopItems = NPC_SHOP_ITEMS[npcData.archetype] || NPC_SHOP_ITEMS.merchant;
        if (HUD && HUD.showNPCShop) {
          HUD.showNPCShop(npcData, shopItems, localPlayer.spark, function onBuyItem(itemId) {
            var item = shopItems.find(function(i) { return i.id === itemId; });
            if (!item) return;
            if (localPlayer.spark < item.price) {
              if (HUD) HUD.showNotification('Not enough Spark!', 'error');
              return;
            }
            if (economyLedger && Economy) {
              var result = Economy.spendSpark(economyLedger, localPlayer.id, item.price);
              if (!result.success) {
                if (HUD) HUD.showNotification('Transaction failed', 'error');
                return;
              }
              localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            } else {
              localPlayer.spark -= item.price;
            }
            if (Inventory && playerInventory) {
              Inventory.addItem(playerInventory, item.id, 1);
              if (HUD) {
                HUD.showItemPickup(item.name, 1, item.icon);
                HUD.updateInventoryDisplay(playerInventory);
              }
            }
            if (HUD) {
              HUD.updatePlayerInfo(localPlayer);
              HUD.showNotification('Bought ' + item.name + ' for ' + item.price + ' Spark', 'success');
            }
            if (Audio) Audio.playSound('trade');
            HUD.showNPCShop(npcData, shopItems, localPlayer.spark, onBuyItem);
            addRecentActivity('Bought ' + item.name + ' from ' + npcData.name);
          });
        }
        break;

      case 'learn':
        if (HUD) {
          var teachingMsg = '';
          if (typeof NPC_AI !== 'undefined' && NPC_AI.getTeaching) {
            var teaching = NPC_AI.getTeaching(npcData.archetype, {});
            if (teaching) {
              teachingMsg = npcData.name + ' teaches you about ' + teaching.topic + ': "' + teaching.description + '"';
              if (Economy && economyLedger) {
                var teachSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'teach', { complexity: 0.5 });
                localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
                HUD.updatePlayerInfo(localPlayer);
                showSparkPopup(teachSpark);
              }
            } else {
              teachingMsg = npcData.name + ' has nothing more to teach you right now.';
            }
          } else {
            teachingMsg = npcData.name + ' shares some wisdom with you.';
            if (Economy && economyLedger) {
              var teachSpark2 = Economy.earnSpark(economyLedger, localPlayer.id, 'teach', { complexity: 0.3 });
              localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
              HUD.updatePlayerInfo(localPlayer);
              showSparkPopup(teachSpark2);
            }
          }
          HUD.showNotification(teachingMsg, 'info');
          addRecentActivity('Learned from ' + npcData.name);
        }
        break;

      case 'lore':
        if (HUD) {
          var loreMsg = '';
          if (typeof NPC_AI !== 'undefined' && NPC_AI.getLore) {
            var lore = NPC_AI.getLore(npcData.archetype, {});
            if (lore) {
              loreMsg = npcData.name + ' tells you: "' + lore + '"';
            } else {
              loreMsg = npcData.name + ' has shared all their stories with you.';
            }
          } else {
            loreMsg = npcData.name + ' tells you a tale of the founding of ZION.';
          }
          HUD.showNotification(loreMsg, 'info');
          addRecentActivity('Heard lore from ' + npcData.name);
        }
        break;
    }
  }

  function handleResourceHarvest(node) {
    if (!World || !Inventory || !playerInventory) return;

    var itemId = World.harvestResource(node);
    if (!itemId) {
      if (HUD) HUD.showNotification('Resource already depleted', 'warning');
      return;
    }

    var itemData = Inventory.getItemData(itemId);
    if (!itemData) return;

    var result = Inventory.addItem(playerInventory, itemId, 1);
    if (result.success) {
      if (HUD) {
        HUD.showItemPickup(itemData.name, 1, itemData.icon);
        HUD.updateInventoryDisplay(playerInventory);
        HUD.updateQuickBar(playerInventory);
      }

      if (economyLedger && Economy) {
        var harvestComplexity = 0.5;
        if (Physical && localPlayer.warmth > 0) {
          var warmthBonus = Physical.getWarmthBonus(localPlayer.warmth);
          harvestComplexity = Math.min(1.0, harvestComplexity * warmthBonus);
        }
        var sparkEarned = Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: harvestComplexity });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(sparkEarned);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'gardening', 5);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Gardening skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (World && World.emitParticles && node.position) {
        var harvestPos = { x: node.position.x, y: node.position.y + 1, z: node.position.z };
        World.emitParticles('sparkle', harvestPos, 8);
      }

      if (sceneContext && sceneContext.camera && sceneContext.renderer && node.position && window.THREE) {
        var textPos = new window.THREE.Vector3(node.position.x, node.position.y + 2, node.position.z);
        textPos.project(sceneContext.camera);
        var sx = (textPos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
        var sy = (-textPos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;
        showFloatingText('+1 ' + itemData.name, sx, sy);
      }

      if (Quests) {
        var updated = Quests.updateQuestProgress(localPlayer.id, 'collect', { item: itemId, amount: 1 });
        if (updated.length > 0 && HUD) {
          updated.forEach(function(quest) {
            HUD.showQuestProgress('Quest progress: ' + quest.title);
          });
        }
      }

      if (Inventory.rollHarvestDrop) {
        var luck = Physical && localPlayer.warmth > 0 ? Physical.getWarmthBonus(localPlayer.warmth) : 1.0;
        var bonusDrop = Inventory.rollHarvestDrop(currentZone, luck);
        if (bonusDrop) {
          var bonusResult = Inventory.addItem(playerInventory, bonusDrop.id, 1);
          if (bonusResult.success) {
            var bonusData = Inventory.getItemData(bonusDrop.id);
            if (bonusData && HUD) {
              setTimeout(function() {
                HUD.showItemPickup(bonusData.name, 1, bonusData.icon);
              }, 500);
            }
          }
        }
      }

      if (Economy && Economy.applyEventModifier && economyLedger) {
        var eventBonus = Economy.applyEventModifier(0, 'harvest');
        if (eventBonus > 0) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: 0.2 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
      }

      var harvestSeasonBonus = getSeasonalBonus('garden');
      if (harvestSeasonBonus > 1.0 && Economy && economyLedger) {
        var bonusSpark = Math.round((harvestSeasonBonus - 1.0) * 5);
        if (bonusSpark > 0) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: 0.1 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
      }

      trackAchievement('harvest', { item: itemId, zone: currentZone });

      if (Audio) Audio.playSound('harvest');

      addRecentActivity('Collected ' + itemData.name);
    } else {
      if (HUD) HUD.showNotification(result.message, 'warning');
    }
  }

  function handleCraft(recipeId) {
    if (!Inventory || !playerInventory) return;

    var result = Inventory.craftItem(playerInventory, recipeId);
    if (result.success) {
      if (HUD) {
        HUD.showNotification(result.message, 'success');
        HUD.updateInventoryDisplay(playerInventory);
        HUD.updateCraftingDisplay(playerInventory);
        HUD.updateQuickBar(playerInventory);
      }

      if (economyLedger && Economy && result.sparkEarned) {
        var craftSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'craft', { complexity: result.sparkEarned / 50 });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(craftSpark);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'crafting', 10);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Crafting skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (Quests) {
        Quests.updateQuestProgress(localPlayer.id, 'craft', { item: result.output.itemId, amount: result.output.count });
      }

      trackAchievement('craft', { item: result.output.itemId, recipe: recipeId });

      if (World && World.emitParticles && localPlayer && localPlayer.position) {
        var craftPos = { x: localPlayer.position.x, y: localPlayer.position.y + 1.5, z: localPlayer.position.z };
        World.emitParticles('fire', craftPos, 10);
      }

      if (Audio) Audio.playSound('build');
    } else {
      if (HUD) HUD.showNotification(result.message, 'error');
    }
  }

  function handleGuildCreate(guildData) {
    if (!Guilds || !localPlayer || !Economy || !economyLedger) return;

    var balance = Economy.getBalance(economyLedger, localPlayer.id);
    if (balance < 100) {
      if (HUD) {
        HUD.showNotification('Not enough Spark to create guild (need 100)', 'error');
      }
      return;
    }

    var result = Guilds.createGuild(
      localPlayer.id,
      guildData.name,
      guildData.tag,
      guildData.type,
      guildData.description
    );

    if (result.success) {
      Economy.debit(economyLedger, localPlayer.id, result.cost, 'Guild creation');

      if (HUD) {
        HUD.showNotification('Guild created: [' + guildData.tag + '] ' + guildData.name, 'success');
        HUD.updateGuildTag(guildData.tag);

        localPlayer.spark = balance - result.cost;
        HUD.updatePlayerInfo(localPlayer);

        HUD.showGuildPanel(result.guild, { id: localPlayer.id });
      }

      addRecentActivity('Founded [' + guildData.tag + '] ' + guildData.name);
    } else {
      if (HUD) {
        HUD.showNotification('Failed to create guild: ' + result.error, 'error');
      }
    }
  }

  if (typeof window !== 'undefined') {
    window.handleGuildAction = function(action, data) {
      if (!Guilds || !localPlayer) return;

      switch (action) {
        case 'leave':
          var result = Guilds.leaveGuild(data, localPlayer.id);
          if (result.success) {
            if (HUD) {
              HUD.showNotification('You left the guild', 'info');
              HUD.updateGuildTag('');
            }
            addRecentActivity('Left guild');
          } else {
            if (HUD) {
              HUD.showNotification('Failed to leave guild: ' + result.error, 'error');
            }
          }
          break;
      }
    };
  }

  function handleComposeAction(composeData) {
    if (!Creation || !localPlayer) return;

    if (composeData.notes && composeData.instrument) {
      var noteNames = composeData.notes.map(function(n) { return n.note; }).join('-');
      var msg = {
        type: 'compose',
        from: localPlayer.id,
        timestamp: Date.now(),
        nonce: Math.random().toString(36).substr(2, 9),
        payload: {
          composeType: 'music',
          title: 'Melody (' + composeData.notes.length + ' notes)',
          content: JSON.stringify({ notes: composeData.notes, instrument: composeData.instrument }),
          zone: currentZone,
          position: localPlayer.position
        }
      };

      var result = Creation.handleCompose(msg, gameState);
      if (result.success) {
        if (HUD) HUD.showNotification('Composed a melody with ' + composeData.notes.length + ' notes!', 'success');
        if (HUD.playComposition) HUD.playComposition(composeData.notes);

        if (economyLedger && Economy) {
          var sparkAmount = Math.min(50, 5 + composeData.notes.length * 2);
          var composeSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'compose', { complexity: sparkAmount / 50 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(composeSpark);
        }

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 20);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        if (Audio) Audio.playSound('chat');
        addRecentActivity('Composed a melody with ' + composeData.notes.length + ' notes');
      }
      return;
    }

    var msg = {
      type: 'compose',
      from: localPlayer.id,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        composeType: composeData.type,
        title: composeData.title,
        content: composeData.content,
        zone: currentZone,
        position: localPlayer.position
      }
    };

    var result = Creation.handleCompose(msg, gameState);
    if (result.success) {
      if (HUD) {
        HUD.showNotification('Created ' + composeData.type + ': ' + composeData.title, 'success');
      }

      if (economyLedger && Economy && result.sparkReward) {
        var composeSpark2 = Economy.earnSpark(economyLedger, localPlayer.id, 'compose', { complexity: result.sparkReward / 50 });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(composeSpark2);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 15);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (Audio) Audio.playSound('chat');

      addRecentActivity('Created ' + composeData.type + ': ' + composeData.title);
    } else {
      if (HUD) HUD.showNotification(result.error, 'error');
    }
  }

  function handleGovernanceAction(action, data) {
    if (!Social || !Zones || !localPlayer) return;

    switch (action) {
      case 'startElection':
        var zoneId = data.zoneId || currentZone;
        var reputation = Social.getReputation(localPlayer.id);

        if (reputation.tier !== 'Respected' && reputation.tier !== 'Honored' && reputation.tier !== 'Elder') {
          if (HUD) HUD.showNotification('Must be Respected tier or higher to start an election', 'error');
          return;
        }

        var candidates = [localPlayer.id];
        var election = Zones.startElection(zoneId, candidates);

        if (HUD) {
          HUD.showNotification('Election started! Voting ends in 48 hours.', 'success');
          HUD.hideGovernancePanel();
          HUD.showGovernancePanel(zoneId, localPlayer);
        }

        if (Network && Protocol) {
          var msg = Protocol.create.election_start(localPlayer.id, {
            zoneId: zoneId,
            electionId: election.id,
            candidates: candidates
          });
          Network.broadcastMessage(msg);
        }
        break;

      case 'vote':
        var electionId = data.electionId;
        var candidateId = data.candidateId;

        var voteResult = Zones.castVote(electionId, localPlayer.id, candidateId);
        if (voteResult.success) {
          if (HUD) {
            HUD.showNotification('Vote cast for ' + candidateId, 'success');
            HUD.hideGovernancePanel();
            HUD.showGovernancePanel(currentZone, localPlayer);
          }

          if (Network && Protocol) {
            var msg = Protocol.create.election_vote(localPlayer.id, {
              electionId: electionId,
              candidateId: candidateId
            });
            Network.broadcastMessage(msg);
          }
        } else {
          if (HUD) HUD.showNotification(voteResult.error, 'error');
        }
        break;

      case 'savePolicies':
        var zoneId = data.zoneId || currentZone;

        if (data.welcomeMessage !== undefined) {
          var msgResult = Zones.setWelcomeMessage(zoneId, localPlayer.id, data.welcomeMessage);
          if (!msgResult.success) {
            if (HUD) HUD.showNotification(msgResult.error, 'error');
            return;
          }
        }

        if (data.buildingRequiresApproval !== undefined) {
          Zones.setZonePolicy(zoneId, localPlayer.id, 'buildingRequiresApproval', data.buildingRequiresApproval);
        }
        if (data.chatModerated !== undefined) {
          Zones.setZonePolicy(zoneId, localPlayer.id, 'chatModerated', data.chatModerated);
        }

        if (HUD) {
          HUD.showNotification('Zone policies updated', 'success');
          HUD.hideGovernancePanel();
          HUD.showGovernancePanel(zoneId, localPlayer);
        }

        Social.adjustReputation(localPlayer.id, 'zone_steward_action', { zoneId: zoneId });

        if (Network && Protocol) {
          var msg = Protocol.create.steward_set_policy(localPlayer.id, {
            zoneId: zoneId,
            policies: {
              welcomeMessage: data.welcomeMessage,
              buildingRequiresApproval: data.buildingRequiresApproval,
              chatModerated: data.chatModerated
            }
          });
          Network.broadcastMessage(msg);
        }
        break;
    }
  }

  var buildModeActive = false;
  var BUILD_TYPES = [
    'bench', 'lantern', 'signpost', 'fence', 'planter',
    'campfire', 'archway', 'table', 'barrel', 'crate'
  ];
  var BUILD_COSTS = {
    bench: 15, lantern: 10, signpost: 5, fence: 8, planter: 12,
    campfire: 20, archway: 30, table: 15, barrel: 10, crate: 8
  };

  function handleBuildAction(data) {
    if (data.mode !== undefined) {
      buildModeActive = data.mode;

      if (buildModeActive) {
        if (World && World.enterBuildMode && sceneContext) {
          World.enterBuildMode(sceneContext);
        }
        if (HUD && HUD.showBuildToolbar) {
          HUD.showBuildToolbar();
        }
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Build mode activated - Click to place structures', 'info');
        }
      } else {
        if (World && World.exitBuildMode && sceneContext) {
          World.exitBuildMode(sceneContext);
        }
        if (HUD && HUD.hideBuildToolbar) {
          HUD.hideBuildToolbar();
        }
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Build mode deactivated', 'info');
        }
      }
    } else if (data.action === 'place') {
      if (World && World.confirmPlacement && sceneContext && localPlayer) {
        var result = World.confirmPlacement(sceneContext, localPlayer.position, currentZone);
        if (result && result.error) {
          if (HUD && HUD.showNotification) {
            HUD.showNotification(result.error, 'error');
          }
        } else if (result) {
          var buildCost = BUILD_COSTS[result.type] || 10;
          if (economyLedger && Economy) {
            var spendResult = Economy.spendSpark(economyLedger, localPlayer.id, buildCost);
            if (!spendResult.success) {
              if (HUD && HUD.showNotification) {
                HUD.showNotification('Not enough Spark! Need ' + buildCost + ' Spark to build ' + result.type, 'error');
              }
              if (World && World.removeLastPlaced) {
                World.removeLastPlaced(sceneContext);
              }
              return;
            }
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
          }

          if (HUD && HUD.showNotification) {
            HUD.showNotification('Built ' + result.type + ' (-' + buildCost + ' Spark)', 'success');
          }

          if (Economy) {
            var buildSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'build', { complexity: 0.3 });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            showSparkPopup(buildSpark);
          }

          if (Mentoring) {
            var xpResult = Mentoring.addSkillXP(localPlayer.id, 'building', 12);
            if (xpResult.leveledUp && HUD) {
              HUD.showNotification('Building skill increased to ' + xpResult.newLevelName, 'success');
              emitLevelUpParticles();
            }
          }

          if (Network && Protocol) {
            var buildMsg = Protocol.create.build(localPlayer.id, {
              structureType: result.type,
              position: result.position,
              rotation: result.rotation || 0,
              zone: currentZone
            });
            Network.broadcastMessage(buildMsg);
          }

          trackAchievement('build', { type: result.type, zone: currentZone });

          if (gameState) {
            if (!gameState.structures) gameState.structures = [];
            gameState.structures.push({
              id: 'struct_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
              type: result.type,
              position: result.position,
              rotation: result.rotation || 0,
              zone: currentZone,
              builder: localPlayer.id,
              ts: Date.now()
            });
          }
        }
      }
    } else if (data.action === 'rotate') {
      if (World && World.rotateBuildPreview) {
        World.rotateBuildPreview(Math.PI / 4); // 45 degrees
      }
    } else if (data.action === 'selectType') {
      var typeIndex = data.typeIndex;
      if (typeIndex >= 0 && typeIndex < BUILD_TYPES.length) {
        var buildType = BUILD_TYPES[typeIndex];
        if (World && World.setBuildType) {
          World.setBuildType(buildType);
        }
        if (HUD && HUD.updateBuildToolbar) {
          HUD.updateBuildToolbar(buildType);
        }
      }
    }
  }

  function handleLocalAction(type, payload) {
    let msg = null;

    switch (type) {
      case 'move':
        localPlayer.position = payload.position;
        localPlayer.zone = payload.zone;
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('move');
        break;

      case 'chat':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openChat');
        var message = payload.message;
        var emoteMatch = message.match(/^\/(wave|dance|bow|cheer|meditate|point)$/);
        if (emoteMatch) {
          handleLocalAction('emote', { type: emoteMatch[1] });
          return;
        }

        msg = Protocol.create.chat(localPlayer.id, { message: message, zone: currentZone, position: localPlayer.position });

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 3);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'player_action', data: {
            playerId: localPlayer.id, action: 'chat',
            position: localPlayer.position, message: message
          }});
        }
        break;

      case 'emote':
        if (World && sceneContext && localPlayer) {
          var playerMesh = World.getPlayerMesh ? World.getPlayerMesh(sceneContext, localPlayer.id) : null;
          if (playerMesh && NPCs && NPCs.playEmoteAnimation) {
            NPCs.playEmoteAnimation(playerMesh, payload.type);
          }
          if (HUD && HUD.showEmoteBubble) {
            HUD.showEmoteBubble(localPlayer.id, payload.type);
          }
          if (Audio) {
            Audio.playSound('chat');
          }
        }
        msg = {
          type: 'emote',
          from: localPlayer.id,
          timestamp: Date.now(),
          nonce: Math.random().toString(36).substr(2, 9),
          payload: { emoteType: payload.type }
        };
        break;

      case 'toggleEmoteMenu':
        if (HUD) {
          var emoteMenuEl = document.getElementById('emote-menu');
          if (emoteMenuEl) {
            HUD.hideEmoteMenu();
          } else {
            HUD.showEmoteMenu();
          }
        }
        break;

      case 'toggleMap':
        if (HUD && localPlayer) {
          var mapEl = document.getElementById('world-map-overlay');
          if (mapEl) {
            HUD.hideWorldMap();
          } else {
            var npcPositions = NPCs && NPCs.getNPCPositions ? NPCs.getNPCPositions() : [];
            var landmarks = [];
            HUD.showWorldMap(localPlayer.position, npcPositions, landmarks, function(zoneId) {
              handleLocalAction('fastTravel', { zone: zoneId });
            });
          }
        }
        break;

      case 'fastTravel':
        if (localPlayer && World && data && data.zone) {
          var targetZone = data.zone;
          var Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
          var zoneInfo = Zones && Zones.ZONES ? Zones.ZONES[targetZone] : null;
          if (!zoneInfo) break;

          var oldZone = currentZone;
          currentZone = targetZone;

          if (World.fadeTransition) {
            World.fadeTransition(function() {
              var tx = zoneInfo.cx;
              var tz = zoneInfo.cz;
              var ty = World.getTerrainHeight ? World.getTerrainHeight(tx, tz) : 0;
              localPlayer.position.x = tx;
              localPlayer.position.y = ty;
              localPlayer.position.z = tz;

              if (sceneContext && sceneContext.camera) {
                sceneContext.camera.position.set(tx, ty + 5, tz + 12);
                sceneContext.camera.lookAt(tx, ty + 1.5, tz);
              }
            });
          }

          if (Audio && Audio.playSound) Audio.playSound('zone_enter');

          if (HUD) {
            HUD.updateZoneLabel(currentZone);
            HUD.showNotification('Traveled to ' + currentZone.charAt(0).toUpperCase() + currentZone.slice(1), 'info');
          }
          if (Audio) {
            Audio.playAmbient(currentZone);
            if (Audio.setZoneAmbient) Audio.setZoneAmbient(currentZone);
            if (Audio.updateMusic) Audio.updateMusic(currentZone, currentTimePeriod);
            if (Audio.playPianoAccent && !visitedZones[currentZone]) {
              Audio.playPianoAccent('zone_discovery');
            }
          }
          visitedZones[currentZone] = true;
          if (NPCs) NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
          if (World && World.clearInteractiveObjects && World.spawnZoneInteractives) {
            World.clearInteractiveObjects(sceneContext);
            World.spawnZoneInteractives(sceneContext, currentZone);
          }
          addRecentActivity('Fast traveled to ' + currentZone);

          if (Network && Network.broadcastMessage) {
            Network.broadcastMessage({
              type: 'warp',
              payload: {
                zone: currentZone,
                position: { x: localPlayer.position.x, y: localPlayer.position.y, z: localPlayer.position.z, zone: currentZone }
              }
            });
          }

          startZoneCinematic();
        }
        break;

      case 'togglePhotoMode':
        togglePhotoMode();
        break;

      case 'toggleSettings':
        if (HUD) {
          var closedSomething = false;
          if (HUD.hideNPCDialog) {
            var npcDlg = document.getElementById('npc-dialog');
            if (npcDlg) { HUD.hideNPCDialog(); closedSomething = true; }
          }
          if (HUD.hideNPCShop) {
            var npcShop = document.getElementById('npc-shop-panel');
            if (npcShop) { HUD.hideNPCShop(); closedSomething = true; }
          }
          if (HUD.hideQuestOffer) {
            var questOffer = document.getElementById('quest-offer-panel');
            if (questOffer) { HUD.hideQuestOffer(); closedSomething = true; }
          }
          if (HUD.hideQuestLog) {
            var questLog = document.getElementById('quest-log-panel');
            if (questLog) { HUD.hideQuestLog(); closedSomething = true; }
          }
          if (HUD.hideWorldMap) {
            var worldMap = document.getElementById('world-map-overlay');
            if (worldMap) { HUD.hideWorldMap(); closedSomething = true; }
          }
          if (!closedSomething) {
            var settingsEl = document.getElementById('settings-menu-overlay');
            if (settingsEl) {
              HUD.hideSettingsMenu();
            } else {
              HUD.showSettingsMenu();
            }
          }
        }
        break;

      case 'toggleProfile':
        if (HUD && localPlayer) {
          var profileEl = document.getElementById('player-profile-panel') || document.getElementById('profile-panel');
          if (profileEl) {
            if (HUD.hideProfilePanel) HUD.hideProfilePanel();
            else if (HUD.hidePlayerProfile) HUD.hidePlayerProfile();
          } else {
            var playerData = {
              name: localPlayer.name || 'Player',
              zone: currentZone,
              sparkBalance: economyLedger ? Economy.getBalance(economyLedger, localPlayer.id) : 0,
              playTimeSeconds: getPlayTimeSeconds(),
              itemsCollected: playerInventory ? playerInventory.items.length : 0,
              questsCompleted: Quests ? Quests.getCompletedQuests(localPlayer.id).length : 0,
              questsActive: Quests ? Quests.getActiveQuests(localPlayer.id).length : 0,
              npcsMet: NPCs && NPCs.getMetNPCs ? NPCs.getMetNPCs(localPlayer.id).length : 0,
              zonesDiscovered: Exploration ? Exploration.getDiscoveredZones(localPlayer.id, gameState).length : 1,
              structuresBuilt: Creation ? Creation.getPlayerStructures(localPlayer.id).length : 0,
              recentActivities: getRecentActivities(),
              reputationTier: Social && Social.getReputation ? Social.getReputation(localPlayer.id).tier : 'Newcomer'
            };

            var skillData = {};
            if (Mentoring && Mentoring.getPlayerSkills) {
              skillData = Mentoring.getPlayerSkills(localPlayer.id);
            }

            if (HUD.showProfilePanel) {
              HUD.showProfilePanel(playerData, skillData);
            } else if (HUD.showPlayerProfile) {
              HUD.showPlayerProfile(playerData);
            }
          }
        }
        break;

      case 'toggleGuild':
        if (HUD && Guilds && localPlayer) {
          var guildPanelEl = document.getElementById('guild-panel');
          if (guildPanelEl) {
            HUD.hideGuildPanel();
          } else {
            var playerGuild = Guilds.getPlayerGuild(localPlayer.id);
            if (playerGuild) {
              HUD.showGuildPanel(playerGuild, { id: localPlayer.id });
              HUD.updateGuildTag(playerGuild.tag);
            } else {
              HUD.showGuildCreate(function(guildData) {
                handleGuildCreate(guildData);
              });
            }
          }
        }
        break;

      case 'toggleSkills':
        if (HUD && Mentoring && localPlayer) {
          var skillsPanelEl = document.getElementById('skills-panel');
          if (skillsPanelEl) {
            HUD.hideSkillsPanel();
          } else {
            var skillsData = Mentoring.getPlayerSkills(localPlayer.id);
            HUD.showSkillsPanel(skillsData);
          }
        }
        break;

      case 'toggleCompose':
        if (HUD && Creation && localPlayer) {
          var composePanelEl = document.getElementById('compose-panel');
          if (composePanelEl) {
            HUD.hideComposePanel();
          } else {
            HUD.showComposePanel(function(composeData) {
              handleComposeAction(composeData);
            });
          }
        }
        break;

      case 'interact':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('interact');
        if (NPCs && NPCs.interactWithNPC && localPlayer) {
          var npcResponse = NPCs.interactWithNPC(localPlayer.position.x, localPlayer.position.z, localPlayer.id);
          if (npcResponse) {
            if (HUD && HUD.showNPCDialog) {
              HUD.showNPCDialog(npcResponse);
            } else if (HUD) {
              HUD.showNotification(npcResponse.name + ': "' + npcResponse.message + '"', 'info');
            }

            if (Quests && npcResponse.questInfo) {
              var questInfo = npcResponse.questInfo;

              if (questInfo.state === 'available') {
                if (HUD && HUD.showQuestOffer) {
                  HUD.showQuestOffer(questInfo.quest, { name: npcResponse.name, archetype: npcResponse.archetype }, localPlayer.id);
                }
              } else if (questInfo.state === 'complete') {
                var result = Quests.completeQuest(localPlayer.id, questInfo.quest.id, gameState);
                if (result.success && HUD) {
                  HUD.showQuestComplete(result.quest, result.rewards);
                  localPlayer.spark += result.rewards.spark;
                  HUD.updatePlayerInfo(localPlayer);
                  showSparkPopup(result.rewards.spark);
                  addRecentActivity('Completed quest: ' + result.quest.title);
                  if (World && World.emitParticles && localPlayer && localPlayer.position) {
                    var questPos = { x: localPlayer.position.x, y: localPlayer.position.y + 2, z: localPlayer.position.z };
                    World.emitParticles('sparkle', questPos, 15);
                    World.emitParticles('fountain', questPos, 15);
                  }
                  if (Audio && Audio.playPianoAccent) Audio.playPianoAccent('quest_complete');
                  triggerCameraShake(0.2, 0.3);
                  triggerScreenFlash('#DAA520', 0.4);
                }
              }

              Quests.updateQuestProgress(localPlayer.id, 'talk_npc', { npcId: npcResponse.id });
            }

            if (Audio) Audio.playSound('chat');
            trackAchievement('npc_talk', { npcId: npcResponse.id, npcName: npcResponse.name });
            addRecentActivity('Talked to ' + npcResponse.name);
            if (NPCs.broadcastEvent) {
              NPCs.broadcastEvent({ type: 'player_action', data: {
                playerId: localPlayer.id, action: 'interact_npc',
                position: localPlayer.position, targetNPC: npcResponse.id
              }});
            }
            break;
          }
        }
        if (World && World.getInteractiveAtPosition && localPlayer) {
          var nearbyObj = World.getInteractiveAtPosition(localPlayer.position.x, localPlayer.position.z, 4);
          if (nearbyObj) {
            var objResult = World.interactWithObject(nearbyObj.id);
            if (objResult) {
              if (HUD) HUD.showNotification(objResult.message, 'info');
              if (Audio) Audio.playSound('chat');

              if (objResult.action === 'rest' || objResult.action === 'sit' || objResult.action === 'socialize') {
                addRecentActivity('Resting at ' + objResult.type.replace(/_/g, ' '));
              } else if (objResult.action === 'study' || objResult.action === 'access_lore') {
                if (Mentoring) {
                  var loreXP = Mentoring.addSkillXP(localPlayer.id, 'lore', 5);
                  if (loreXP.leveledUp && HUD) {
                    HUD.showNotification('Lore skill increased to ' + loreXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Studied at ' + objResult.type.replace(/_/g, ' '));
              } else if (objResult.action === 'practice_combat') {
                if (Mentoring) {
                  var combatXP = Mentoring.addSkillXP(localPlayer.id, 'combat', 5);
                  if (combatXP.leveledUp && HUD) {
                    HUD.showNotification('Combat skill increased to ' + combatXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Trained at combat dummy');
              } else if (objResult.action === 'create_art' || objResult.action === 'play_music') {
                if (Mentoring) {
                  var craftXP = Mentoring.addSkillXP(localPlayer.id, 'crafting', 5);
                  if (craftXP.leveledUp && HUD) {
                    HUD.showNotification('Crafting skill increased to ' + craftXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Created at ' + objResult.type.replace(/_/g, ' '));
              }

              trackAchievement('use_object', { type: objResult.type });
              break;
            }
          }
        }
        msg = Protocol.create.harvest(localPlayer.id, 10);
        if (Quests) {
          var updated = Quests.updateQuestProgress(localPlayer.id, 'collect', { item: 'resource', amount: 1 });
          if (updated.length > 0 && HUD) {
            updated.forEach(function(quest) {
              HUD.showQuestProgress('Quest progress: ' + quest.title);
            });
          }
        }
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'player_action', data: {
            playerId: localPlayer.id, action: 'harvest',
            position: localPlayer.position
          }});
        }
        break;

      case 'toggle_quest_log':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openQuests');
        if (HUD && Quests && localPlayer) {
          var questLogEl = document.getElementById('quest-log-panel');
          if (questLogEl) {
            HUD.hideQuestLog();
          } else {
            var questLog = Quests.getQuestLog(localPlayer.id, { level: 0 });
            HUD.showQuestLog(questLog, localPlayer.id);
          }
        }
        break;

      case 'toggleInventory':
        if (HUD && playerInventory) {
          HUD.toggleInventoryPanel();
          HUD.updateInventoryDisplay(playerInventory);
        }
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openInventory');
        break;

      case 'toggleCrafting':
        if (HUD && playerInventory) {
          HUD.toggleCraftingPanel();
          HUD.updateCraftingDisplay(playerInventory);
        }
        break;

      case 'toggleGovernance':
        if (HUD && localPlayer && Social && Zones) {
          if (!HUD.initGovernancePanel) {
            HUD.initGovernancePanel(handleGovernanceAction);
          }
          HUD.toggleGovernancePanel(currentZone, localPlayer);
        }
        break;

      case 'toggleAchievements':
        if (HUD && Quests && localPlayer) {
          var achievementPanelEl = document.getElementById('achievement-panel');
          if (achievementPanelEl) {
            if (HUD.hideAchievementPanel) HUD.hideAchievementPanel();
          } else {
            if (HUD.showAchievementPanel) HUD.showAchievementPanel(localPlayer.id);
          }
        }
        break;

      case 'toggleAuctions':
      case 'toggleAuctionHouse':
        if (HUD && Economy && localPlayer) {
          if (HUD.toggleAuctionHousePanel) {
            HUD.toggleAuctionHousePanel(economyLedger, localPlayer.id, playerInventory);
          } else if (HUD.showAuctionHousePanel) {
            HUD.showAuctionHousePanel(economyLedger, localPlayer.id, playerInventory);
          }
        }
        break;

      case 'toggleLoreJournal':
        if (HUD && Exploration && localPlayer) {
          var lorePanelEl = document.getElementById('lore-journal-panel');
          if (lorePanelEl) {
            if (HUD.hideLoreJournal) HUD.hideLoreJournal();
          } else {
            if (HUD.showLoreJournal) HUD.showLoreJournal(localPlayer.id, gameState);
          }
        }
        break;

      case 'toggleDiscoveryLog':
        if (HUD && Exploration && localPlayer) {
          var discoveryLogEl = document.getElementById('discovery-log-overlay');
          if (discoveryLogEl) {
            HUD.hideDiscoveryLog();
          } else {
            var discoveries = Exploration.getDiscoveries ? Exploration.getDiscoveries(localPlayer.id, gameState) : [];
            HUD.showDiscoveryLog(discoveries);
          }
        }
        break;

      case 'toggleLoreBook':
        if (HUD && localPlayer) {
          var loreBookEl = document.getElementById('lore-book-overlay');
          if (loreBookEl) {
            HUD.hideLoreBook();
          } else {
            var loreEntries = [];
            HUD.showLoreBook(loreEntries);
          }
        }
        break;

      case 'useQuickSlot':
        if (playerInventory && Inventory) {
          var slotIndex = payload.slot; // 0-4
          var qbSlotIdx = playerInventory.quickBar ? playerInventory.quickBar[slotIndex] : slotIndex;
          var items = Inventory.getInventory(playerInventory);
          var slotItem = items[qbSlotIdx];
          if (slotItem) {
            if (slotItem.type === 'food') {
              Inventory.removeItem(playerInventory, slotItem.itemId, 1);
              if (HUD) HUD.showNotification('Ate ' + slotItem.icon + ' ' + slotItem.name);
              if (Economy) Economy.earnSpark(localPlayer.id, 'daily_login', {});
              if (HUD && HUD.updateInventoryDisplay) {
                HUD.updateInventoryDisplay(playerInventory);
                HUD.updateQuickBar(playerInventory);
              }
            } else if (slotItem.type === 'tools') {
              if (HUD) HUD.showNotification('Equipped ' + slotItem.icon + ' ' + slotItem.name);
            } else {
              if (HUD) HUD.showNotification(slotItem.icon + ' ' + slotItem.name + ': ' + (slotItem.description || 'An item'));
            }
          } else {
            if (HUD) HUD.showNotification('Quick slot ' + (slotIndex + 1) + ' is empty');
          }
        }
        break;

      case 'click':
        if (raycaster && sceneContext && sceneContext.camera && World) {
          var node = World.getResourceNodeAtMouse(raycaster, sceneContext.camera, payload.x, payload.y);
          if (node) {
            handleResourceHarvest(node);
          }
        }
        break;

      case 'initiate_trade':
        if (Trading && gameState && State && HUD) {
          var players = State.getPlayers(gameState);
          var nearbyPlayers = players
            .filter(function(p) {
              return p.id !== localPlayer.id && p.zone === currentZone;
            })
            .map(function(p) {
              var dx = p.position.x - localPlayer.position.x;
              var dz = p.position.z - localPlayer.position.z;
              var distance = Math.sqrt(dx * dx + dz * dz);
              return { player: p, distance: distance };
            })
            .sort(function(a, b) { return a.distance - b.distance; });

          if (nearbyPlayers.length > 0 && nearbyPlayers[0].distance < 10) {
            var targetPlayer = nearbyPlayers[0].player;
            var result = Trading.requestTrade(localPlayer.id, targetPlayer.id, localPlayer.position);
            if (result.success) {
              HUD.showNotification('Trade request sent to ' + targetPlayer.name, 'info');
            } else {
              HUD.showNotification(result.message, 'warning');
            }
          } else {
            HUD.showNotification('No players nearby to trade with', 'warning');
          }
        }
        break;

      case 'startFishing':
        startFishing();
        break;

      case 'togglePetPanel':
        if (HUD && HUD.showPetPanel) {
          HUD.showPetPanel(localPlayer.id, currentZone);
        }
        break;

      case 'toggleHousing':
        showHousingPanel();
        break;

      case 'toggleAnchorPanel':
        if (HUD && HUD.showAnchorPanel) {
          HUD.showAnchorPanel(localPlayer.position, currentZone);
        }
        break;

      case 'toggleFederationProposal':
        if (HUD && HUD.showFederationProposal) {
          HUD.showFederationProposal();
        }
        break;

      default:
        console.log('Unknown local action:', type);
    }

    if (msg) {
      applyMessage(msg);

      if (Network) {
        Network.broadcastMessage(msg);
      }
    }
  }

  function joinWorld() {
    if (!Protocol || !Network) return;

    const msg = Protocol.create.join(localPlayer.id, {
      position: localPlayer.position,
      zone: currentZone
    });

    Network.broadcastMessage(msg);

    console.log('Joined world');
  }

  function leaveWorld() {
    if (!Protocol || !Network || !localPlayer) return;

    const msg = Protocol.create.leave(localPlayer.id);

    Network.broadcastMessage(msg);

    Network.disconnect();

    if (Audio) {
      Audio.stopAll();
    }

    isRunning = false;

    console.log('Left world');
  }

  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', init);

    window.addEventListener('beforeunload', () => {
      if (World && World.registerPlayerStar && localPlayer) {
        World.registerPlayerStar(localPlayer.id, localPlayer.name || localPlayer.id);
      }
      if (World && World.saveWorldMemory) {
        World.saveWorldMemory();
      }
      autoSavePlayerData();
      leaveWorld();
    });
  }

  function getPlayTimeSeconds() {
    if (typeof localStorage !== 'undefined') {
      try {
        var stored = localStorage.getItem('zion_playTime');
        if (stored) {
          playTimeSeconds = parseInt(stored) || 0;
        }
      } catch (err) {
        console.warn('Failed to load play time:', err);
      }
    }
    return playTimeSeconds;
  }

  function savePlayTime() {
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('zion_playTime', playTimeSeconds.toString());
      } catch (err) {
        console.warn('Failed to save play time:', err);
      }
    }
  }

  function addRecentActivity(activity) {
    recentActivities.unshift(activity);
    if (recentActivities.length > 10) {
      recentActivities = recentActivities.slice(0, 10);
    }
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('zion_recentActivities', JSON.stringify(recentActivities));
      } catch (err) {
        console.warn('Failed to save activities:', err);
      }
    }
  }

  function getRecentActivities() {
    if (typeof localStorage !== 'undefined' && recentActivities.length === 0) {
      try {
        var stored = localStorage.getItem('zion_recentActivities');
        if (stored) {
          recentActivities = JSON.parse(stored) || [];
        }
      } catch (err) {
        console.warn('Failed to load activities:', err);
      }
    }
    return recentActivities.length > 0 ? recentActivities : ['Started playing ZION'];
  }

  function trackAchievement(eventType, eventData) {
    if (!Quests || !Quests.trackAchievementEvent || !localPlayer) return;
    var earned = Quests.trackAchievementEvent(localPlayer.id, eventType, eventData);
    if (earned && earned.length > 0) {
      earned.forEach(function(achievement) {
        if (Audio && Audio.playPianoAccent) Audio.playPianoAccent('achievement');
        if (HUD && HUD.showAchievementToast) {
          HUD.showAchievementToast(achievement);
        } else if (HUD) {
          HUD.showNotification('Achievement unlocked: ' + achievement.name, 'success');
        }
        if (economyLedger && Economy) {
          var bonus = achievement.tier === 'gold' ? 50 : achievement.tier === 'silver' ? 25 : 10;
          var achSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: bonus / 25 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(achSpark);
        }
        if (Audio) Audio.playSound('warp');
      });
    }
  }

  function autoSavePlayerData() {
    if (!Auth || !Auth.savePlayerData || !localPlayer) return;
    var saveData = {
      inventory: playerInventory,
      spark: localPlayer.spark || 0,
      position: localPlayer.position,
      zone: currentZone,
      skills: Mentoring ? Mentoring.getPlayerSkills(localPlayer.id) : null,
      questState: Quests ? { active: Quests.getActiveQuests(localPlayer.id), completed: Quests.getCompletedQuests(localPlayer.id) } : null,
      achievements: Quests && Quests.getAchievements ? Quests.getAchievements(localPlayer.id) : null,
      guild: Guilds ? Guilds.getPlayerGuild(localPlayer.id) : null,
      discoveredSecrets: [],
      warmth: localPlayer.warmth || 0,
      playTime: playTimeSeconds
    };
    Auth.savePlayerData(saveData);
    if (State) {
      State.addPlayer(gameState, localPlayer);
      State.flushToLocal();
    }
  }

  function restorePlayerData() {
    if (!Auth || !Auth.loadPlayerData || !localPlayer) return false;
    var data = Auth.loadPlayerData();
    if (!data) return false;

    if (data.position) {
      localPlayer.position = data.position;
    }
    if (data.zone) {
      currentZone = data.zone;
    }
    if (data.spark && economyLedger && Economy) {
      economyLedger.balances[localPlayer.id] = data.spark;
      localPlayer.spark = data.spark;
    }
    if (data.inventory && Inventory) {
      playerInventory = data.inventory;
    }
    if (data.playTime) {
      playTimeSeconds = data.playTime;
    }
    if (data.warmth) {
      localPlayer.warmth = data.warmth;
    }

    console.log('Player data restored from save');
    return true;
  }

  function checkSecrets() {
    if (!Exploration || !Exploration.checkNearbySecrets || !localPlayer || !gameState) return;
    var nearbySecrets = Exploration.checkNearbySecrets(localPlayer.id, localPlayer.position, currentZone, gameState);
    if (nearbySecrets && nearbySecrets.length > 0) {
      nearbySecrets.forEach(function(secret) {
        var result = Exploration.discoverSecret(localPlayer.id, secret, gameState);
        if (result && result.success) {
          if (HUD) {
            HUD.showNotification('Secret discovered: ' + secret.name, 'success');
            if (HUD.showDiscoveryPopup) {
              HUD.showDiscoveryPopup({
                name: secret.name,
                description: secret.description,
                rarity: getRarityName(secret.rarity),
                sparkReward: result.sparkAwarded || 0
              });
            }
          }
          if (economyLedger && Economy && result.sparkAwarded) {
            var secretSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: secret.rarity });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
            showSparkPopup(secretSpark);
          }
          if (secret.loreId && Exploration.getLoreEntry) {
            var lore = Exploration.getLoreEntry(secret.loreId);
            if (lore && HUD) {
              setTimeout(function() {
                HUD.showNotification('Lore unlocked: ' + lore.title, 'info');
              }, 3000);
            }
            if (Mentoring) {
              var loreXP = Mentoring.addSkillXP(localPlayer.id, 'lore', 15);
              if (loreXP.leveledUp && HUD) {
                HUD.showNotification('Lore skill increased to ' + loreXP.newLevelName + '!', 'success');
                emitLevelUpParticles();
              }
            }
          }
          if (Mentoring) {
            var exploreXP = Mentoring.addSkillXP(localPlayer.id, 'exploration', 10);
            if (exploreXP.leveledUp && HUD) {
              HUD.showNotification('Exploration skill increased to ' + exploreXP.newLevelName + '!', 'success');
              emitLevelUpParticles();
            }
          }
          trackAchievement('discover', { type: 'secret', rarity: secret.rarity });
          if (Audio) Audio.playSound('warp');
          addRecentActivity('Discovered: ' + secret.name);
        }
      });
    }
  }

  function updateEconomicEvent() {
    if (!Economy || !Economy.getCurrentEvent) return;
    var event = Economy.getCurrentEvent();
    if (event && (!currentEconomicEvent || currentEconomicEvent.id !== event.id)) {
      currentEconomicEvent = event;
      if (HUD) {
        var bannerEl = document.getElementById('economic-event-banner');
        if (!bannerEl && typeof document !== 'undefined') {
          bannerEl = document.createElement('div');
          bannerEl.id = 'economic-event-banner';
          bannerEl.className = 'economic-event-banner';
          document.body.appendChild(bannerEl);
        }
        if (bannerEl) {
          bannerEl.innerHTML = '<strong>' + event.name + '</strong> â€” ' + event.description;
          bannerEl.style.display = 'block';
        }
        HUD.showNotification('Economic Event: ' + event.name + ' is active!', 'success');
      }
    } else if (!event && currentEconomicEvent) {
      currentEconomicEvent = null;
      var bannerEl = document.getElementById('economic-event-banner');
      if (bannerEl) bannerEl.style.display = 'none';
    }
  }

  function initSeasonalEvent() {
    if (!Seasons) return;
    currentSeason = Seasons.getCurrentSeason();
    if (!currentSeason) return;

    var colors = Seasons.getSeasonalColors();
    var daysLeft = Seasons.getDaysUntilSeasonEnd();

    if (typeof document !== 'undefined') {
      var banner = document.getElementById('seasonal-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.id = 'seasonal-banner';
        banner.className = 'seasonal-banner season-' + currentSeason.id;
        document.body.appendChild(banner);
      }
      banner.innerHTML = '<div class="seasonal-banner-title">' + (currentSeason.festival && currentSeason.festival.name ? currentSeason.festival.name : currentSeason.name) + '</div>' +
        '<div class="seasonal-banner-desc">' + currentSeason.description + '</div>' +
        '<div class="seasonal-banner-countdown">' + daysLeft + ' days remaining</div>';
      banner.style.display = 'block';

      setTimeout(function() {
        if (banner) banner.style.display = 'none';
      }, 8000);
    }

    if (NPCs && Seasons.getSeasonalGreeting) {
      console.log('Season: ' + currentSeason.name + ' â€” ' + Seasons.getSeasonalGreeting());
    }
  }

  function updateSeasonalEvent() {
    if (!Seasons) return;
    var newSeason = Seasons.getCurrentSeason();
    if (newSeason && (!currentSeason || currentSeason.id !== newSeason.id)) {
      currentSeason = newSeason;
      if (HUD) {
        HUD.showNotification('A new season has arrived: ' + newSeason.name + '!', 'success');
      }
      initSeasonalEvent(); // Refresh banner
    }
  }

  function getSeasonalBonus(activity) {
    if (!Seasons || !Seasons.getSeasonBonus) return 1.0;
    return Seasons.getSeasonBonus(activity);
  }

  function initPetSystem(playerId) {
    if (!Pets) return;

    var savedData = Auth && Auth.loadPlayerData ? Auth.loadPlayerData() : null;
    if (savedData && savedData.pet) {
      console.log('Pet system initialized');
    }
  }

  function updatePetStatus() {
    if (!Pets || !localPlayer) return;
    var pet = Pets.getPlayerPet(localPlayer.id);
    if (!pet) return;

    Pets.updatePet(localPlayer.id, PET_UPDATE_INTERVAL / 1000);

    var bonus = Pets.getPetBonus(localPlayer.id);
    if (bonus && bonus.value > 0) {
      localPlayer.petBonus = bonus;
    }

    var mood = Pets.getPetMood(pet);
    if (mood === 'sad' && pet.hunger > 70) {
      if (HUD) {
        HUD.showNotification(pet.name + ' is hungry! Feed your Pingym.', 'warning');
      }
    }
  }

  function startFishing() {
    if (isFishing || !HUD || !HUD.showFishingUI) return;

    var fishableZones = ['gardens', 'commons', 'wilds', 'nexus', 'agora'];
    if (fishableZones.indexOf(currentZone) === -1) {
      if (HUD) HUD.showNotification('You cannot fish here.', 'warning');
      return;
    }

    isFishing = true;
    if (Audio) Audio.playSound('harvest');

    HUD.showFishingUI(currentZone, function(result) {
      isFishing = false;
      if (result && result.success && result.fish) {
        if (Inventory && playerInventory) {
          Inventory.addItem(playerInventory, result.fish.id, 1);
          if (HUD && HUD.updateInventoryDisplay) {
            HUD.updateInventoryDisplay(playerInventory);
          }
        }
        var sparkAmount = result.fish.value || 5;
        var seasonBonus = getSeasonalBonus('harvest');
        sparkAmount = Math.round(sparkAmount * seasonBonus);
        if (economyLedger && Economy) {
          Economy.earnSpark(economyLedger, localPlayer.id, sparkAmount, 'fishing');
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          showSparkPopup(sparkAmount);
        }
        if (HUD && HUD.showFishCaughtNotification) {
          HUD.showFishCaughtNotification(result.fish.name, sparkAmount);
        }
        trackAchievement('harvest', { type: 'fishing', fish: result.fish.id });
        if (Mentoring) {
          var fishXP = Mentoring.addSkillXP(localPlayer.id, 'gardening', 8);
          if (fishXP.leveledUp && HUD) {
            HUD.showNotification('Gardening skill increased to ' + fishXP.newLevelName + '!', 'success');
            emitLevelUpParticles();
          }
        }
        addRecentActivity('Caught: ' + result.fish.name);
      }
    });
  }

  function showHousingPanel() {
    if (!Creation || !HUD || typeof document === 'undefined') return;

    var existingPanel = document.getElementById('housing-panel');
    if (existingPanel) {
      existingPanel.remove();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'housing-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(15,12,10,0.95);border:1px solid rgba(218,165,32,0.3);border-radius:12px;' +
      'padding:24px;min-width:400px;max-width:550px;max-height:70vh;overflow-y:auto;z-index:1100;' +
      'backdrop-filter:blur(10px);color:#E8E0D8;font-family:Georgia,serif;';

    var playerPlot = Creation.getPlayerPlot ? Creation.getPlayerPlot(localPlayer.id) : null;

    var header = document.createElement('h2');
    header.textContent = playerPlot ? 'My Home â€” ' + playerPlot.name : 'Housing â€” Claim a Plot';
    header.style.cssText = 'color:#DAA520;margin:0 0 16px;font-size:1.2rem;';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\u00d7';
    closeBtn.style.cssText = 'position:absolute;top:12px;right:12px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;font-size:18px;cursor:pointer;';
    closeBtn.onclick = function() { panel.remove(); };
    panel.appendChild(closeBtn);

    if (playerPlot) {
      var plotInfo = document.createElement('div');
      plotInfo.style.cssText = 'margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;';
      plotInfo.innerHTML = '<div style="color:#B8B0A8;font-size:0.85rem;">Plot ' + playerPlot.id +
        ' (' + playerPlot.bounds.x1 + ',' + playerPlot.bounds.z1 + ')</div>' +
        '<div style="color:#E8E0D8;font-size:0.9rem;margin-top:4px;">Furniture: ' +
        playerPlot.furniture.length + '/' + 20 + '</div>';
      panel.appendChild(plotInfo);

      var furnitureTypes = Creation.FURNITURE_TYPES || {};
      var furnitureHeader = document.createElement('div');
      furnitureHeader.textContent = 'Add Furniture';
      furnitureHeader.style.cssText = 'color:#DAA520;font-size:0.9rem;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.1em;';
      panel.appendChild(furnitureHeader);

      Object.keys(furnitureTypes).forEach(function(fType) {
        var ft = furnitureTypes[fType];
        var row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px;' +
          'background:rgba(255,255,255,0.02);border-radius:6px;margin-bottom:4px;' +
          'border:1px solid rgba(255,255,255,0.05);cursor:pointer;transition:all 0.2s;';
        row.onmouseover = function() { this.style.borderColor = 'rgba(218,165,32,0.3)'; };
        row.onmouseout = function() { this.style.borderColor = 'rgba(255,255,255,0.05)'; };
        row.innerHTML = '<span style="font-size:1.3rem;">' + ft.icon + '</span>' +
          '<span style="flex:1;color:#E8E0D8;font-size:0.85rem;">' + ft.name + '</span>' +
          '<span style="color:#DAA520;font-size:0.8rem;">' + ft.cost + ' Spark</span>';
        row.onclick = function() {
          var result = Creation.placeFurniture(localPlayer.id, fType, 5, 5);
          if (result && result.success) {
            HUD.showNotification('Placed ' + ft.name + ' in your home!', 'success');
            panel.remove();
          } else {
            HUD.showNotification(result ? result.error : 'Cannot place furniture', 'warning');
          }
        };
        panel.appendChild(row);
      });
    } else {
      var plots = Creation.getAvailablePlots ? Creation.getAvailablePlots() : [];
      if (plots.length === 0) {
        var noPlots = document.createElement('div');
        noPlots.textContent = 'No plots available. Visit The Commons zone to find housing.';
        noPlots.style.cssText = 'color:#B8B0A8;text-align:center;padding:20px;';
        panel.appendChild(noPlots);
      } else {
        var infoText = document.createElement('div');
        infoText.textContent = 'Available plots in The Commons (' + plots.length + ' open):';
        infoText.style.cssText = 'color:#B8B0A8;font-size:0.85rem;margin-bottom:12px;';
        panel.appendChild(infoText);

        plots.slice(0, 8).forEach(function(plot) {
          var row = document.createElement('div');
          row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:10px;' +
            'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);' +
            'border-radius:8px;margin-bottom:6px;cursor:pointer;transition:all 0.2s;';
          row.onmouseover = function() { this.style.borderColor = 'rgba(218,165,32,0.4)'; };
          row.onmouseout = function() { this.style.borderColor = 'rgba(255,255,255,0.08)'; };
          row.innerHTML = '<span style="font-size:1.3rem;">ðŸ </span>' +
            '<span style="flex:1;color:#E8E0D8;font-size:0.9rem;">Plot ' + plot.id + '</span>' +
            '<span style="color:#B8B0A8;font-size:0.75rem;">(' + plot.bounds.x1 + ', ' + plot.bounds.z1 + ')</span>';
          row.onclick = function() {
            var plotName = prompt('Name your home:');
            if (plotName && plotName.trim()) {
              var result = Creation.claimPlot(localPlayer.id, plot.id, plotName.trim());
              if (result && result.success) {
                HUD.showNotification('You claimed a plot: ' + plotName.trim() + '!', 'success');
                trackAchievement('build', { type: 'housing' });
                panel.remove();
              } else {
                HUD.showNotification(result ? result.error : 'Cannot claim plot', 'warning');
              }
            }
          };
          panel.appendChild(row);
        });
      }
    }

    document.body.appendChild(panel);

    var escHandler = function(e) {
      if (e.key === 'Escape') {
        panel.remove();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }

  function isNighttime(worldTime) {
    var hour = worldTime / 60;
    return hour < 6 || hour >= 20; // Night is 8pm-6am
  }

  function getRandomZone() {
    if (!World || !World.ZONES) return 'nexus';
    var zoneKeys = Object.keys(World.ZONES);
    return zoneKeys[Math.floor(Math.random() * zoneKeys.length)];
  }

  function getZoneName(zoneId) {
    if (!World || !World.ZONES || !World.ZONES[zoneId]) return zoneId;
    return World.ZONES[zoneId].name || zoneId;
  }

  function spawnShootingStar(sceneContext, currentTime) {
    if (!sceneContext || !sceneContext.scene) return;

    var direction = Math.random() > 0.5 ? 1 : -1;
    var startX = direction > 0 ? -300 : 300;
    var endX = direction > 0 ? 300 : -300;
    var y = 150 + Math.random() * 50; // High in sky
    var z = -200 + Math.random() * 400;

    var starGeom = new THREE.SphereGeometry(0.8, 8, 8);
    var starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var star = new THREE.Mesh(starGeom, starMat);
    star.position.set(startX, y, z);
    sceneContext.scene.add(star);

    var trail = [];
    for (var i = 0; i < 3; i++) {
      var trailGeom = new THREE.SphereGeometry(0.5 - i * 0.15, 6, 6);
      var trailMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.7 - i * 0.2
      });
      var trailSphere = new THREE.Mesh(trailGeom, trailMat);
      trailSphere.position.copy(star.position);
      sceneContext.scene.add(trailSphere);
      trail.push(trailSphere);
    }

    var duration = 1000 + Math.random() * 1000; // 1-2 seconds
    worldEvents.shootingStars.active.push({
      star: star,
      trail: trail,
      startTime: currentTime,
      duration: duration,
      startX: startX,
      endX: endX,
      y: y,
      z: z
    });

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A shooting star streaks across the sky!', 'info');
    }
  }

  function spawnResourceBloom(currentTime) {
    var zone = getRandomZone();
    worldEvents.resourceBloom.activeZone = zone;
    worldEvents.resourceBloom.startTime = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A bloom of resources has appeared in ' + getZoneName(zone) + '!', 'success');
    }
  }

  function spawnAuroraBorealis(sceneContext, currentTime) {
    if (!sceneContext || !sceneContext.scene) return;

    var auroraGeom = new THREE.PlaneGeometry(400, 200, 40, 20);
    var auroraMat = new THREE.MeshBasicMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    var aurora = new THREE.Mesh(auroraGeom, auroraMat);
    aurora.position.set(0, 180, -100);
    aurora.rotation.x = Math.PI / 2.5;
    sceneContext.scene.add(aurora);

    worldEvents.auroraBorealis.active = true;
    worldEvents.auroraBorealis.mesh = aurora;
    worldEvents.auroraBorealis.startTime = currentTime;
    worldEvents.auroraBorealis.duration = 180000 + Math.random() * 120000; // 3-5 minutes
    worldEvents.auroraBorealis.animTime = 0;

    var positions = auroraGeom.attributes.position.array;
    var originalPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
      originalPositions[i] = positions[i];
    }
    aurora.userData.originalPositions = originalPositions;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('The Northern Lights dance across the sky!', 'success');
    }
  }

  function spawnWanderingMerchant(currentTime) {
    var zone = getRandomZone();
    worldEvents.wanderingMerchant.activeZone = zone;
    worldEvents.wanderingMerchant.lastSpawn = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A wandering merchant has appeared near ' + getZoneName(zone) + '!', 'info');
    }
  }

  function spawnFireflySwarm(currentTime) {
    worldEvents.fireflySwarm.active = true;
    worldEvents.fireflySwarm.startTime = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A swarm of fireflies fills the gardens!', 'success');
    }
  }

  function updateWorldEvents(deltaTime, worldTime, sceneContext) {
    if (!sceneContext) return;

    var currentTime = Date.now();
    var isNight = isNighttime(worldTime);

    if (isNight) {
      var starInterval = worldEvents.shootingStars.interval + Math.random() * 60000;
      if (currentTime - worldEvents.shootingStars.lastSpawn > starInterval) {
        spawnShootingStar(sceneContext, currentTime);
        worldEvents.shootingStars.lastSpawn = currentTime;
      }
    }

    for (var i = worldEvents.shootingStars.active.length - 1; i >= 0; i--) {
      var starEvent = worldEvents.shootingStars.active[i];
      var elapsed = currentTime - starEvent.startTime;
      var progress = Math.min(elapsed / starEvent.duration, 1);

      if (progress >= 1) {
        sceneContext.scene.remove(starEvent.star);
        starEvent.star.geometry.dispose();
        starEvent.star.material.dispose();
        for (var j = 0; j < starEvent.trail.length; j++) {
          sceneContext.scene.remove(starEvent.trail[j]);
          starEvent.trail[j].geometry.dispose();
          starEvent.trail[j].material.dispose();
        }
        worldEvents.shootingStars.active.splice(i, 1);
      } else {
        var newX = starEvent.startX + (starEvent.endX - starEvent.startX) * progress;
        starEvent.star.position.x = newX;

        for (var k = 0; k < starEvent.trail.length; k++) {
          var trailDelay = (k + 1) * 0.1;
          var trailProgress = Math.max(0, progress - trailDelay);
          var trailX = starEvent.startX + (starEvent.endX - starEvent.startX) * trailProgress;
          starEvent.trail[k].position.x = trailX;
          starEvent.trail[k].position.y = starEvent.y;
          starEvent.trail[k].position.z = starEvent.z;
          starEvent.trail[k].material.opacity = (0.7 - k * 0.2) * (1 - progress);
        }
      }
    }

    var bloomInterval = worldEvents.resourceBloom.interval + Math.random() * 300000;
    if (currentTime - worldEvents.resourceBloom.lastSpawn > bloomInterval) {
      spawnResourceBloom(currentTime);
      worldEvents.resourceBloom.lastSpawn = currentTime;
    }

    if (worldEvents.resourceBloom.activeZone) {
      var bloomElapsed = currentTime - worldEvents.resourceBloom.startTime;
      if (bloomElapsed > worldEvents.resourceBloom.duration) {
        worldEvents.resourceBloom.activeZone = null;
      } else {
      }
    }

    if (isNight) {
      var auroraInterval = worldEvents.auroraBorealis.interval + Math.random() * 600000;
      if (!worldEvents.auroraBorealis.active &&
          currentTime - worldEvents.auroraBorealis.lastSpawn > auroraInterval) {
        spawnAuroraBorealis(sceneContext, currentTime);
        worldEvents.auroraBorealis.lastSpawn = currentTime;
      }
    }

    if (worldEvents.auroraBorealis.active && worldEvents.auroraBorealis.mesh) {
      var auroraElapsed = currentTime - worldEvents.auroraBorealis.startTime;
      if (auroraElapsed > worldEvents.auroraBorealis.duration) {
        sceneContext.scene.remove(worldEvents.auroraBorealis.mesh);
        worldEvents.auroraBorealis.mesh.geometry.dispose();
        worldEvents.auroraBorealis.mesh.material.dispose();
        worldEvents.auroraBorealis.mesh = null;
        worldEvents.auroraBorealis.active = false;
      } else {
        worldEvents.auroraBorealis.animTime += deltaTime;
        var aurora = worldEvents.auroraBorealis.mesh;
        var geometry = aurora.geometry;
        var positions = geometry.attributes.position.array;
        var originalPositions = aurora.userData.originalPositions;

        if (originalPositions) {
          for (var v = 0; v < positions.length; v += 3) {
            var x = originalPositions[v];
            var y = originalPositions[v + 1];
            var offset = Math.sin(x * 0.02 + worldEvents.auroraBorealis.animTime * 2) *
                        Math.cos(y * 0.02 + worldEvents.auroraBorealis.animTime * 1.5) * 8;
            positions[v + 2] = originalPositions[v + 2] + offset;
          }
          geometry.attributes.position.needsUpdate = true;
        }

        var fadeProgress = auroraElapsed / worldEvents.auroraBorealis.duration;
        if (fadeProgress > 0.8) {
          aurora.material.opacity = 0.3 * (1 - (fadeProgress - 0.8) / 0.2);
        }
      }
    }

    var merchantInterval = worldEvents.wanderingMerchant.interval;
    if (currentTime - worldEvents.wanderingMerchant.lastSpawn > merchantInterval) {
      spawnWanderingMerchant(currentTime);
    }

    if (isNight && currentZone === 'gardens') {
      var swarmInterval = worldEvents.fireflySwarm.interval;
      if (!worldEvents.fireflySwarm.active &&
          currentTime - worldEvents.fireflySwarm.lastSpawn > swarmInterval) {
        spawnFireflySwarm(currentTime);
        worldEvents.fireflySwarm.lastSpawn = currentTime;
      }
    }

    if (worldEvents.fireflySwarm.active) {
      var swarmElapsed = currentTime - worldEvents.fireflySwarm.startTime;
      if (swarmElapsed > worldEvents.fireflySwarm.duration) {
        worldEvents.fireflySwarm.active = false;
      }
    }
  }

  exports.init = init;
  exports.joinWorld = joinWorld;
  exports.leaveWorld = leaveWorld;
  exports.handleLocalAction = handleLocalAction;
  exports.triggerCameraShake = triggerCameraShake;
  exports.triggerScreenFlash = triggerScreenFlash;
  exports.setVignetteIntensity = setVignetteIntensity;
  exports.getSimCrmState = function() { return simCrmState; };

})(typeof module !== 'undefined' ? module.exports : (window.Main = {}));


  </script>
</body>
</html>
