<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ZION â€” A Living World</title>
  <meta name="description" content="A living world where human and artificial minds meet in peace.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' fill='%230A0E1A'/><text x='16' y='22' font-size='18' font-weight='bold' fill='%23DAA520' text-anchor='middle' font-family='serif'>Z</text></svg>">

  <!-- Schema.org JSON-LD for NLWeb discovery -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "GameServer",
    "name": "ZION",
    "url": "https://kody-w.github.io/zion/",
    "description": "A living world where human and artificial minds meet in peace. 100 AI citizens, 8 zones.",
    "gameServerStatus": "Online",
    "sameAs": "https://github.com/kody-w/zion"
  }
  </script>
  <link rel="alternate" type="application/rss+xml" title="ZION World State" href="feeds/world.xml" />
  <link rel="alternate" type="application/rss+xml" title="ZION Chat" href="feeds/chat.xml" />
  <link rel="alternate" type="application/rss+xml" title="ZION Events" href="feeds/events.xml" />

  <!-- Three.js & PeerJS from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <style>
    /* tokens.css */
:root {
  /* Colors - earthy, peaceful palette */
  --color-earth: #5C4033;
  --color-forest: #2D5016;
  --color-sky: #87CEEB;
  --color-dawn: #F4A460;
  --color-dusk: #8B6914;
  --color-night: #1a1a2e;
  --color-water: #4682B4;
  --color-stone: #808080;
  --color-sand: #C2B280;
  --color-gold: #DAA520;
  --color-crystal: #B0E0E6;

  /* UI Colors */
  --color-bg: #1a1a1a;
  --color-bg-panel: rgba(26, 26, 26, 0.85);
  --color-text: #E8E0D8;
  --color-text-muted: #A0978E;
  --color-accent: #DAA520;
  --color-success: #4CAF50;
  --color-warning: #FFA726;
  --color-error: #EF5350;
  --color-border: rgba(218, 165, 32, 0.3);

  /* Typography */
  --font-main: 'Georgia', 'Times New Roman', serif;
  --font-ui: system-ui, -apple-system, sans-serif;
  --font-mono: 'Courier New', monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
  --font-size-xxl: 2rem;

  /* Spacing */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-xxl: 3rem;

  /* Borders & Radius */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-round: 50%;

  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
  --shadow-lg: 0 10px 20px rgba(0,0,0,0.5);

  /* Z-Index */
  --z-world: 0;
  --z-hud: 100;
  --z-modal: 200;
  --z-notification: 300;

  /* Item Rarity Colors */
  --color-rarity-common: #cccccc;
  --color-rarity-uncommon: #2ecc71;
  --color-rarity-rare: #3498db;
  --color-rarity-legendary: #f39c12;

  /* Quest Colors */
  --color-quest-available: #f1c40f;
  --color-quest-active: #3498db;
  --color-quest-complete: #2ecc71;

  /* NPC Interaction */
  --color-npc-friendly: #27ae60;
  --color-npc-neutral: #95a5a6;

  /* Transition speeds */
  --transition-fast: 0.15s;
  --transition-normal: 0.3s;
  --transition-slow: 0.5s;
}


/* layout.css */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: var(--font-ui);
  font-size: var(--font-size-md);
  color: var(--color-text);
  background: var(--color-bg);
}

#game-container {
  position: relative;
  width: 100%;
  height: 100%;
}

#world-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-world);
}

#hud-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-hud);
  pointer-events: none;
}

#hud-container > * {
  pointer-events: auto;
}

#login-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 70%);
  z-index: var(--z-modal);
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(218, 165, 32, 0.3);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(218, 165, 32, 0.5);
}

/* Selection */
::selection {
  background: rgba(218, 165, 32, 0.3);
  color: var(--color-text);
}

/* Responsive */
@media (max-width: 768px) {
  :root {
    font-size: 14px;
  }

  .chat-panel {
    max-width: 250px;
    bottom: 160px;
    left: 8px;
    max-height: 30vh;
  }

  .player-info {
    top: 8px;
    left: 8px;
    min-width: 150px;
    padding: 8px;
  }

  .minimap {
    top: 8px;
    right: 8px;
    padding: 4px;
  }

  #minimap-canvas {
    width: 100px;
    height: 100px;
  }

  .nearby-list {
    display: none;
  }

  .zone-label {
    font-size: 1rem;
    top: 10px;
  }

  .notification {
    max-width: 280px;
    padding: 12px;
    font-size: 0.85rem;
  }
}

@media (max-width: 480px) {
  :root {
    font-size: 12px;
  }

  .chat-panel {
    max-width: 200px;
    bottom: 170px;
    max-height: 25vh;
  }

  .player-info {
    min-width: 120px;
    font-size: 11px;
  }

  .loading-title {
    font-size: 2.5rem;
  }

  .loading-bar-container {
    width: 200px;
  }
}


/* hud.css */
/* Chat Panel - Bottom Left */
.chat-panel {
  position: absolute;
  bottom: var(--space-md);
  left: var(--space-md);
  max-width: 300px;
  width: 100%;
  max-height: 40vh;
  display: flex;
  flex-direction: column;
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-sm);
  box-shadow: var(--shadow-md);
  transition: opacity 0.3s ease, transform 0.25s ease;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: var(--space-sm);
  font-size: var(--font-size-sm);
  line-height: 1.4;
  scroll-behavior: smooth;
}

.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-sm);
}

.chat-message {
  margin-bottom: var(--space-xs);
  word-wrap: break-word;
  animation: chatMsgIn 0.2s ease;
}

@keyframes chatMsgIn {
  from { opacity: 0; transform: translateY(5px); }
  to { opacity: 1; transform: translateY(0); }
}

.chat-message .sender {
  color: var(--color-accent);
  font-weight: bold;
}

.chat-input {
  width: 100%;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-sm);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-size-sm);
  outline: none;
  transition: border-color 0.2s ease;
}

.chat-input:focus {
  border-color: var(--color-accent);
}

/* Player Info - Top Left */
.player-info {
  position: absolute;
  top: var(--space-md);
  left: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  box-shadow: var(--shadow-md);
  min-width: 200px;
  transition: opacity 0.3s ease;
}

.player-info-name {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-sm);
}

.player-info-stat {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-xs);
}

.player-info-stat strong {
  color: var(--color-text);
}

/* Minimap - Top Right */
.minimap {
  position: absolute;
  top: var(--space-md);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-sm);
  box-shadow: var(--shadow-md);
  transition: opacity 0.3s ease;
}

#minimap-canvas {
  display: block;
  border-radius: var(--radius-sm);
}

/* Zone Label - Top Center */
.zone-label {
  position: absolute;
  top: var(--space-lg);
  left: 50%;
  transform: translateX(-50%);
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-gold);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  opacity: 0.9;
  transition: opacity 0.5s ease;
}

/* Nearby List - Right Side */
.nearby-list {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  max-height: 50vh;
  overflow-y: auto;
  box-shadow: var(--shadow-md);
  min-width: 150px;
  transition: opacity 0.3s ease;
}

.nearby-list-title {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.nearby-player {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin-bottom: var(--space-xs);
  padding: var(--space-xs);
  border-radius: var(--radius-sm);
  transition: background 0.2s ease;
}

.nearby-player:hover {
  background: rgba(218, 165, 32, 0.1);
}

/* Notification - Centered Popup */
.notification {
  position: absolute;
  top: 30%;
  left: 50%;
  transform: translate(-50%, -70%);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-accent);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-text);
  text-align: center;
  max-width: 400px;
  z-index: var(--z-notification);
  transition: opacity 0.3s ease, transform 0.3s ease;
  pointer-events: none;
}

.notification.visible {
  transform: translate(-50%, -50%);
  opacity: 1;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translate(-50%, -60%); }
  10% { opacity: 1; transform: translate(-50%, -50%); }
  90% { opacity: 1; transform: translate(-50%, -50%); }
  100% { opacity: 0; transform: translate(-50%, -40%); }
}

/* Break Reminder - Floating Message */
.break-reminder {
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(44, 80, 22, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-forest);
  border-radius: var(--radius-lg);
  padding: var(--space-md) var(--space-lg);
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-crystal);
  text-align: center;
  box-shadow: var(--shadow-md);
  animation: gentleFloat 4s ease-in-out infinite;
  pointer-events: none;
  z-index: var(--z-notification);
}

@keyframes gentleFloat {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-10px); }
}

/* Login Button */
.login-btn {
  background: var(--color-accent);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-md) var(--space-xl);
  font-family: var(--font-ui);
  font-size: var(--font-size-lg);
  font-weight: bold;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.2s ease;
  outline: none;
}

.login-btn:hover {
  background: var(--color-gold);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.login-btn:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

/* Intention Indicator */
.intention-indicator {
  position: absolute;
  bottom: var(--space-xl);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-round);
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--font-size-xl);
  box-shadow: var(--shadow-md);
  transition: all 0.3s ease;
}

.intention-indicator.active {
  border-color: var(--color-accent);
  box-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

/* Inventory Panel */
.inventory-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(12px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  min-width: 320px;
  max-width: 420px;
  z-index: var(--z-notification);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.inventory-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.inventory-title {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-md);
  text-align: center;
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-sm);
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: var(--space-xs);
  margin-bottom: var(--space-md);
}

.inventory-slot {
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  width: 56px;
  height: 56px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  font-size: 24px;
}

.inventory-slot:hover {
  border-color: var(--color-accent);
  background: rgba(218, 165, 32, 0.1);
}

.inventory-slot .slot-count {
  position: absolute;
  bottom: 2px;
  right: 4px;
  font-size: 10px;
  color: var(--color-text);
  font-weight: bold;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

.inventory-slot.rarity-uncommon { border-color: #2ecc71; }
.inventory-slot.rarity-rare { border-color: #3498db; }
.inventory-slot.rarity-legendary { border-color: #f39c12; box-shadow: 0 0 8px rgba(243, 156, 18, 0.3); }

/* Crafting Panel */
.crafting-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(12px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  min-width: 350px;
  max-width: 450px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: var(--z-notification);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.crafting-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.recipe-item {
  display: flex;
  align-items: center;
  padding: var(--space-sm);
  margin-bottom: var(--space-xs);
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s ease;
}

.recipe-item:hover {
  border-color: var(--color-accent);
  background: rgba(218, 165, 32, 0.1);
}

.recipe-item.craftable {
  border-color: rgba(46, 204, 113, 0.5);
}

.recipe-icon {
  font-size: 24px;
  margin-right: var(--space-sm);
  width: 36px;
  text-align: center;
}

.recipe-info {
  flex: 1;
}

.recipe-name {
  color: var(--color-text);
  font-size: var(--font-size-sm);
  font-weight: bold;
}

.recipe-materials {
  color: var(--color-text-muted);
  font-size: var(--font-size-xs);
}

.craft-btn {
  background: var(--color-accent);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
}

.craft-btn:hover {
  background: var(--color-gold);
}

.craft-btn:disabled {
  background: #555;
  color: #999;
  cursor: not-allowed;
}

/* Quest Tracker - Top Right below Minimap */
.quest-tracker {
  position: absolute;
  top: 190px;
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-radius: var(--radius-md);
  padding: var(--space-sm) var(--space-md);
  box-shadow: var(--shadow-md);
  min-width: 180px;
  max-width: 240px;
  transition: opacity 0.3s ease;
}

.quest-tracker-title {
  font-size: var(--font-size-xs);
  color: var(--color-gold);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--space-xs);
}

.quest-tracker-item {
  margin-bottom: var(--space-xs);
}

.quest-tracker-name {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  font-weight: bold;
}

.quest-tracker-objective {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
}

.quest-tracker-progress {
  height: 3px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  margin-top: 2px;
  overflow: hidden;
}

.quest-tracker-progress-bar {
  height: 100%;
  background: var(--color-accent);
  border-radius: 2px;
  transition: width 0.5s ease;
}

/* Quest Log Panel */
.quest-log-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) translateX(20px);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  min-width: 400px;
  max-width: 500px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: var(--z-notification);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.quest-log-panel.visible {
  transform: translate(-50%, -50%) translateX(0);
  opacity: 1;
}

.quest-entry {
  padding: var(--space-sm);
  margin-bottom: var(--space-sm);
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s ease;
}

.quest-entry:hover {
  border-color: var(--color-accent);
}

.quest-entry.active {
  border-color: var(--color-gold);
  border-left: 3px solid var(--color-gold);
}

.quest-entry.completed {
  opacity: 0.6;
  border-color: #2ecc71;
}

.quest-entry-title {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  font-weight: bold;
}

.quest-entry-desc {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  margin-top: 2px;
}

.quest-entry-reward {
  font-size: var(--font-size-xs);
  color: var(--color-gold);
  margin-top: 4px;
}

/* Quick Bar - Bottom Center */
.quick-bar {
  position: absolute;
  bottom: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: var(--space-xs);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-xs);
  box-shadow: var(--shadow-md);
}

.quick-slot {
  width: 48px;
  height: 48px;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  position: relative;
  cursor: pointer;
  transition: all 0.2s ease;
}

.quick-slot:hover {
  border-color: var(--color-accent);
}

.quick-slot .slot-key {
  position: absolute;
  top: 2px;
  left: 4px;
  font-size: 9px;
  color: var(--color-text-muted);
}

/* Item Tooltip */
.item-tooltip {
  position: absolute;
  background: rgba(20, 20, 30, 0.95);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-sm);
  max-width: 200px;
  z-index: 1000;
  pointer-events: none;
  font-size: var(--font-size-xs);
}

.item-tooltip-name {
  font-weight: bold;
  margin-bottom: 2px;
}

.item-tooltip-name.common { color: #ccc; }
.item-tooltip-name.uncommon { color: #2ecc71; }
.item-tooltip-name.rare { color: #3498db; }
.item-tooltip-name.legendary { color: #f39c12; }

.item-tooltip-desc {
  color: var(--color-text-muted);
  margin-bottom: 4px;
}

/* Item Pickup Floating Text */
.item-pickup-text {
  position: absolute;
  font-size: var(--font-size-sm);
  color: var(--color-gold);
  font-weight: bold;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  animation: floatUp 1.5s ease-out forwards;
  z-index: var(--z-notification);
}

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-60px); }
}

/* Quest Complete Banner */
.quest-complete-banner {
  position: absolute;
  top: 25%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(218, 165, 32, 0.15);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-gold);
  border-radius: var(--radius-lg);
  padding: var(--space-lg) var(--space-xl);
  text-align: center;
  z-index: var(--z-notification);
  animation: questComplete 3s ease-in-out forwards;
  pointer-events: none;
}

.quest-complete-banner h2 {
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-gold);
  margin: 0 0 var(--space-sm);
}

.quest-complete-banner .reward {
  font-size: var(--font-size-md);
  color: var(--color-text);
}

@keyframes questComplete {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
  10% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
  15% { transform: translate(-50%, -50%) scale(1); }
  85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(1.1); }
}

/* Panel Slide-in Animation */
@keyframes panelSlideIn {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* Close button for panels */
.panel-close {
  position: absolute;
  top: var(--space-sm);
  right: var(--space-sm);
  background: none;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-round);
  width: 28px;
  height: 28px;
  color: var(--color-text-muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.2s ease;
}

.panel-close:hover {
  border-color: var(--color-accent);
  color: var(--color-text);
}

/* NPC Interaction Dialog */
.npc-dialog {
  position: absolute;
  bottom: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(26, 26, 46, 0.95);
  backdrop-filter: blur(12px);
  border: 2px solid var(--color-gold);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  max-width: 500px;
  width: 90%;
  z-index: var(--z-modal);
  animation: dialogSlideUp 0.3s ease-out;
  box-shadow: 0 0 20px rgba(218, 165, 32, 0.2);
}

.npc-dialog-header {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
  padding-bottom: var(--space-sm);
  border-bottom: 1px solid rgba(218, 165, 32, 0.3);
}

.npc-dialog-name {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
}

.npc-dialog-archetype {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.npc-dialog-mood {
  font-size: var(--font-size-xs);
  color: var(--color-crystal);
  margin-left: auto;
}

.npc-dialog-text {
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-text);
  line-height: 1.6;
  margin-bottom: var(--space-md);
}

.npc-dialog-actions {
  display: flex;
  gap: var(--space-sm);
  justify-content: flex-end;
}

.npc-dialog-btn {
  padding: var(--space-sm) var(--space-md);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  background: rgba(218, 165, 32, 0.1);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition: all 0.2s ease;
}

.npc-dialog-btn:hover {
  background: rgba(218, 165, 32, 0.3);
  border-color: var(--color-gold);
  color: var(--color-gold);
}

.npc-dialog-btn.primary {
  background: rgba(218, 165, 32, 0.2);
  border-color: var(--color-gold);
  color: var(--color-gold);
}

@keyframes dialogSlideUp {
  0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
  100% { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Crosshair / Interaction Indicator */
.crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  pointer-events: none;
  z-index: var(--z-hud);
  opacity: 0.4;
  transition: opacity 0.2s ease;
}

.crosshair.active {
  opacity: 0.8;
}

.crosshair::before,
.crosshair::after {
  content: '';
  position: absolute;
  background: var(--color-text);
}

.crosshair::before {
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  transform: translateY(-50%);
}

.crosshair::after {
  left: 50%;
  top: 0;
  bottom: 0;
  width: 1px;
  transform: translateX(-50%);
}

.crosshair .dot {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 4px;
  height: 4px;
  background: var(--color-gold);
  border-radius: var(--radius-round);
}

/* Interaction Prompt */
.interact-prompt {
  position: absolute;
  top: 55%;
  left: 50%;
  transform: translateX(-50%);
  font-size: var(--font-size-sm);
  color: var(--color-text);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  z-index: var(--z-hud);
  opacity: 0;
  transition: opacity 0.3s ease;
  text-align: center;
}

.interact-prompt.visible {
  opacity: 1;
}

.interact-prompt .key {
  display: inline-block;
  background: rgba(218, 165, 32, 0.2);
  border: 1px solid var(--color-gold);
  border-radius: 3px;
  padding: 1px 6px;
  font-family: var(--font-mono);
  font-size: var(--font-size-xs);
  color: var(--color-gold);
  margin: 0 2px;
}

/* Loading Screen */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 1s ease;
}

.loading-screen.fade-out {
  opacity: 0;
  pointer-events: none;
}

.loading-title {
  font-family: var(--font-main);
  font-size: 3rem;
  color: var(--color-gold);
  text-shadow: 0 0 30px rgba(218, 165, 32, 0.3);
  margin-bottom: var(--space-lg);
  letter-spacing: 0.3em;
  animation: titleGlow 3s ease-in-out infinite;
}

.loading-subtitle {
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-text-muted);
  margin-bottom: var(--space-xxl);
}

.loading-bar-container {
  width: 300px;
  height: 4px;
  background: rgba(218, 165, 32, 0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: var(--space-md);
}

.loading-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--color-gold), var(--color-dawn));
  border-radius: 2px;
  transition: width 0.3s ease;
  width: 0%;
}

.loading-status {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
}

@keyframes titleGlow {
  0%, 100% { text-shadow: 0 0 20px rgba(218, 165, 32, 0.2); }
  50% { text-shadow: 0 0 40px rgba(218, 165, 32, 0.5), 0 0 60px rgba(218, 165, 32, 0.2); }
}

/* Controls Help Overlay */
.controls-overlay {
  position: absolute;
  bottom: var(--space-md);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  z-index: var(--z-hud);
  transition: opacity 0.3s ease;
  max-width: 200px;
}

.controls-overlay-title {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.control-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: var(--space-xs);
  gap: var(--space-sm);
}

.control-key {
  font-family: var(--font-mono);
  color: var(--color-gold);
  font-weight: bold;
  min-width: 40px;
}

.control-desc {
  flex: 1;
  text-align: right;
}

/* Spark Balance Animation */
.spark-balance {
  display: inline-block;
  transition: transform 0.2s ease;
}

.spark-balance.changed {
  animation: sparkPulse 0.5s ease;
}

@keyframes sparkPulse {
  0% { transform: scale(1); }
  30% { transform: scale(1.3); color: var(--color-gold); }
  100% { transform: scale(1); }
}

/* Status Effect Indicators */
.status-effects {
  position: absolute;
  top: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: var(--space-sm);
  z-index: var(--z-hud);
  pointer-events: none;
}

.status-effect {
  width: 32px;
  height: 32px;
  background: var(--color-bg-panel);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  animation: statusPop 0.3s ease;
}

@keyframes statusPop {
  0% { transform: scale(0); }
  60% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

/* Day/Night Overlay */
.daynight-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 1;
  transition: background 5s ease;
}

.daynight-overlay.dawn {
  background: rgba(244, 164, 96, 0.05);
}

.daynight-overlay.day {
  background: transparent;
}

.daynight-overlay.dusk {
  background: rgba(139, 105, 20, 0.08);
}

.daynight-overlay.night {
  background: rgba(26, 26, 46, 0.15);
}

/* Zone Transition Overlay */
.zone-transition {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: var(--z-modal);
  pointer-events: none;
  animation: zoneTransition 1.5s ease-in-out;
}

.zone-transition-name {
  font-family: var(--font-main);
  font-size: var(--font-size-xxl);
  color: var(--color-gold);
  text-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
  letter-spacing: 0.2em;
}

@keyframes zoneTransition {
  0% { opacity: 0; }
  30% { opacity: 1; }
  70% { opacity: 1; }
  100% { opacity: 0; }
}

/* Achievement/Chain Completion Popup */
.achievement-popup {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(20, 18, 25, 0.95), rgba(40, 35, 50, 0.95));
  border: 2px solid var(--color-gold);
  border-radius: var(--radius-lg);
  padding: var(--space-lg) var(--space-xxl);
  text-align: center;
  z-index: 2000;
  animation: achievementSlide 0.5s ease-out, achievementFade 4s ease-in-out;
  box-shadow: 0 0 40px rgba(218, 165, 32, 0.3);
  pointer-events: none;
}

.achievement-popup-title {
  font-family: var(--font-main);
  font-size: var(--font-size-sm);
  color: var(--color-gold);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  margin-bottom: var(--space-xs);
}

.achievement-popup-name {
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-text);
  margin-bottom: var(--space-xs);
}

.achievement-popup-reward {
  font-size: var(--font-size-sm);
  color: var(--color-gold);
}

@keyframes achievementSlide {
  0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
  100% { transform: translateX(-50%) translateY(0); opacity: 1; }
}

@keyframes achievementFade {
  0%, 80% { opacity: 1; }
  100% { opacity: 0; }
}

/* Tooltip system */
.game-tooltip {
  position: absolute;
  background: rgba(15, 12, 20, 0.95);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  color: var(--color-text);
  pointer-events: none;
  z-index: 3000;
  max-width: 200px;
  white-space: nowrap;
  box-shadow: var(--shadow-lg);
}

.game-tooltip-title {
  color: var(--color-gold);
  font-weight: 600;
  margin-bottom: 2px;
}

.game-tooltip-desc {
  color: var(--color-text-muted);
  font-size: 0.7rem;
}

/* Daily Quest Banner */
.daily-quest-banner {
  position: absolute;
  top: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(90deg, transparent, rgba(218, 165, 32, 0.1), transparent);
  padding: var(--space-xs) var(--space-lg);
  color: var(--color-gold);
  font-size: var(--font-size-sm);
  letter-spacing: 0.1em;
  text-align: center;
  pointer-events: none;
  animation: fadeIn 1s ease;
}

/* Notification badge on HUD icons */
.hud-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--color-quest-active);
  color: white;
  font-size: 0.6rem;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

/* Compass indicator */
.compass {
  position: absolute;
  top: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  letter-spacing: 0.3em;
  opacity: 0.5;
}

/* Health/Energy bars (for future use) */
.stat-bar {
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-top: 2px;
}

.stat-bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.5s ease;
}

.stat-bar-fill.spark { background: linear-gradient(90deg, var(--color-gold), var(--color-dawn)); }
.stat-bar-fill.energy { background: linear-gradient(90deg, #4caf50, #8bc34a); }
.stat-bar-fill.social { background: linear-gradient(90deg, #2196f3, #03a9f4); }

/* NPC Shop */
#npc-shop-panel::-webkit-scrollbar { width: 6px; }
#npc-shop-panel::-webkit-scrollbar-track { background: transparent; }
#npc-shop-panel::-webkit-scrollbar-thumb { background: rgba(218,165,32,0.3); border-radius: 3px; }

.npc-shop-panel {
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.npc-shop-panel.visible {
  transform: scale(1);
  opacity: 1;
}

/* Guild Panel */
.guild-panel {
  transform: translateX(20px);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.guild-panel.visible {
  transform: translateX(0);
  opacity: 1;
}
.guild-member-row {
  display: flex; align-items: center; padding: 6px 8px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  transition: background 0.2s;
}
.guild-member-row:hover { background: rgba(255,255,255,0.05); }

/* Skills Panel */
.skill-row {
  display: flex; align-items: center; padding: 8px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.skill-bar {
  flex: 1; height: 6px; background: rgba(255,255,255,0.08);
  border-radius: 3px; overflow: hidden; margin: 0 10px;
}
.skill-bar-fill {
  height: 100%; border-radius: 3px; transition: width 0.5s ease;
  background: linear-gradient(90deg, #4caf50, #8bc34a);
}

/* Discovery Popup */
.discovery-popup {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.6);
  opacity: 0;
  background: rgba(10,14,26,0.95); border: 2px solid var(--color-gold);
  border-radius: 16px; padding: 24px 32px; text-align: center;
  z-index: 10000; pointer-events: auto;
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.discovery-popup.visible {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}

@keyframes discoveryReveal {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }
  60% { transform: translate(-50%, -50%) scale(1.05); }
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* Lore Book */
.lore-entry {
  padding: 12px 16px; margin-bottom: 8px;
  background: rgba(255,255,255,0.03); border-radius: 8px;
  border-left: 3px solid rgba(147,112,219,0.5);
  transition: background 0.2s;
}
.lore-entry:hover { background: rgba(255,255,255,0.06); }
.lore-entry.unread { border-left-color: var(--color-gold); }

/* Warmth indicator */
.warmth-indicator {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 10px; color: #ff9800; padding: 2px 6px;
  background: rgba(255,152,0,0.1); border-radius: 4px;
}

/* Achievement panel */
.achievement-panel {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: rgba(15,12,10,0.95); border: 1px solid rgba(218,165,32,0.3);
  border-radius: 12px; padding: 24px; min-width: 420px; max-width: 550px;
  max-height: 70vh; overflow-y: auto; z-index: 1100;
  backdrop-filter: blur(10px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.achievement-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}
.achievement-panel h2 {
  color: var(--color-gold); margin: 0 0 4px; font-size: 1.2rem;
  font-family: var(--font-main); letter-spacing: 0.1em;
}
.achievement-progress-bar {
  width: 100%; height: 6px; background: rgba(255,255,255,0.1);
  border-radius: 3px; margin: 8px 0 16px; overflow: hidden;
}
.achievement-progress-fill {
  height: 100%; background: linear-gradient(90deg, var(--color-gold), #f0c040);
  border-radius: 3px; transition: width 0.5s ease;
}
.achievement-category { margin-bottom: 16px; }
.achievement-category-title {
  color: var(--color-text-muted); font-size: 0.7rem; text-transform: uppercase;
  letter-spacing: 0.15em; margin-bottom: 8px; padding-bottom: 4px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.achievement-row {
  display: flex; align-items: center; gap: 10px; padding: 6px 8px;
  border-radius: 6px; margin-bottom: 4px; transition: background 0.2s;
}
.achievement-row:hover { background: rgba(255,255,255,0.05); }
.achievement-row.locked { opacity: 0.4; }
.achievement-row.unlocked { opacity: 1; }
.achievement-icon { font-size: 1.4rem; width: 32px; text-align: center; }
.achievement-info { flex: 1; }
.achievement-name {
  color: var(--color-text); font-size: 0.85rem; font-weight: 500;
}
.achievement-desc {
  color: var(--color-text-muted); font-size: 0.7rem;
}
.achievement-reward {
  color: var(--color-gold); font-size: 0.7rem; white-space: nowrap;
}

/* Achievement toast notification */
.achievement-toast {
  position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(25,20,15,0.95), rgba(35,28,18,0.95));
  border: 1px solid var(--color-gold); border-radius: 10px;
  padding: 12px 20px; display: flex; align-items: center; gap: 12px;
  z-index: 1200; animation: achievementSlide 0.4s ease, achievementFade 0.5s 3s forwards;
  box-shadow: 0 4px 20px rgba(218,165,32,0.2);
}
.achievement-toast-icon { font-size: 2rem; }
.achievement-toast-text { }
.achievement-toast-label {
  color: var(--color-gold); font-size: 0.65rem; text-transform: uppercase;
  letter-spacing: 0.15em;
}
.achievement-toast-name {
  color: var(--color-text); font-size: 1rem; font-weight: 500;
}
@keyframes achievementSlide {
  from { transform: translateX(-50%) translateY(-30px); opacity: 0; }
  to { transform: translateX(-50%) translateY(0); opacity: 1; }
}
@keyframes achievementFade {
  to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
}

/* Auction house panel */
.auction-panel {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: rgba(15,12,10,0.95); border: 1px solid rgba(176,224,230,0.3);
  border-radius: 12px; padding: 24px; min-width: 450px; max-width: 600px;
  max-height: 70vh; overflow-y: auto; z-index: 1100;
  backdrop-filter: blur(10px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.auction-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}
.auction-panel h2 {
  color: var(--color-accent); margin: 0 0 16px; font-size: 1.2rem;
  font-family: var(--font-main);
}
.auction-item {
  display: flex; align-items: center; gap: 12px; padding: 10px;
  background: rgba(255,255,255,0.03); border-radius: 8px; margin-bottom: 8px;
  border: 1px solid rgba(255,255,255,0.05); transition: border-color 0.2s;
}
.auction-item:hover { border-color: rgba(176,224,230,0.2); }
.auction-item-icon { font-size: 1.5rem; width: 36px; text-align: center; }
.auction-item-info { flex: 1; }
.auction-item-name { color: var(--color-text); font-size: 0.85rem; }
.auction-item-seller { color: var(--color-text-muted); font-size: 0.7rem; }
.auction-item-time { color: rgba(255,200,100,0.7); font-size: 0.65rem; }
.auction-bid-info { text-align: right; }
.auction-current-bid { color: var(--color-gold); font-size: 0.9rem; font-weight: 500; }
.auction-bid-count { color: var(--color-text-muted); font-size: 0.65rem; }

/* Economic event banner */
.economic-event-banner {
  position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(90deg, transparent, rgba(218,165,32,0.15), transparent);
  color: var(--color-gold); font-size: 0.75rem; padding: 4px 20px;
  border-radius: 20px; z-index: 900; pointer-events: none;
  letter-spacing: 0.05em; text-align: center;
  animation: eventBannerPulse 3s ease-in-out infinite;
}
@keyframes eventBannerPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

/* Lore Journal Panel */
.lore-journal-panel {
  font-family: Georgia, serif;
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.lore-journal-panel.visible {
  transform: scale(1);
  opacity: 1;
}

.lore-journal-panel::-webkit-scrollbar {
  width: 8px;
}

.lore-journal-panel::-webkit-scrollbar-track {
  background: rgba(42, 24, 16, 0.5);
  border-radius: 4px;
}

.lore-journal-panel::-webkit-scrollbar-thumb {
  background: rgba(139, 105, 20, 0.6);
  border-radius: 4px;
}

.lore-journal-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(212, 175, 55, 0.7);
}

.lore-category-tab {
  outline: none;
}

.lore-category-tab:active {
  transform: translateY(1px);
}

.lore-entry {
  position: relative;
}

.lore-entry-locked {
  cursor: not-allowed;
  user-select: none;
}

.lore-progress {
  font-weight: 500;
}

/* Pet Panel */
.pet-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: rgba(15, 12, 10, 0.95);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-radius: 12px;
  padding: 24px;
  min-width: 420px;
  max-width: 550px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: 1100;
  backdrop-filter: blur(10px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.pet-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.pet-panel h2 {
  color: var(--color-gold);
  margin: 0 0 16px;
  font-size: 1.2rem;
  font-family: var(--font-main);
  letter-spacing: 0.1em;
  text-align: center;
}

.pet-panel::-webkit-scrollbar {
  width: 6px;
}

.pet-panel::-webkit-scrollbar-thumb {
  background: rgba(218, 165, 32, 0.3);
  border-radius: 3px;
}

.pet-action-btn {
  flex: 1;
  padding: 10px 16px;
  background: rgba(218, 165, 32, 0.2);
  border: 1px solid rgba(218, 165, 32, 0.5);
  border-radius: 6px;
  color: var(--color-gold);
  font-family: var(--font-ui);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pet-action-btn:hover {
  background: rgba(218, 165, 32, 0.3);
  border-color: var(--color-gold);
  transform: translateY(-1px);
}

.pet-action-btn:active {
  transform: translateY(0);
}

.pet-release-btn {
  width: 100%;
  padding: 10px 16px;
  background: rgba(231, 76, 60, 0.1);
  border: 1px solid rgba(231, 76, 60, 0.3);
  border-radius: 6px;
  color: #e74c3c;
  font-family: var(--font-ui);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pet-release-btn:hover {
  background: rgba(231, 76, 60, 0.2);
  border-color: #e74c3c;
}

.pet-adopt-btn {
  padding: 8px 16px;
  background: rgba(46, 204, 113, 0.2);
  border: 1px solid rgba(46, 204, 113, 0.5);
  border-radius: 6px;
  color: #2ecc71;
  font-family: var(--font-ui);
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.pet-adopt-btn:hover {
  background: rgba(46, 204, 113, 0.3);
  border-color: #2ecc71;
  transform: scale(1.05);
}

.pet-adoption-row {
  transition: all 0.2s ease;
}

.pet-adoption-row:hover .pet-adopt-btn {
  background: rgba(46, 204, 113, 0.3);
}

/* Pet Adopt Notification */
.pet-adopt-notification {
  font-family: var(--font-main);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .chat-panel {
    max-width: 250px;
  }

  .player-info {
    min-width: 150px;
  }

  .nearby-list {
    display: none;
  }

  .lore-journal-panel {
    width: 95%;
    height: 90vh;
  }

  .lore-category-tab {
    padding: 8px 12px;
    font-size: 12px;
  }

  .pet-panel {
    min-width: 320px;
    max-width: 90vw;
  }
}

@media (max-width: 480px) {
  .chat-panel {
    max-width: 200px;
    font-size: var(--font-size-xs);
  }

  .player-info {
    font-size: var(--font-size-xs);
  }

  .zone-label {
    font-size: var(--font-size-lg);
  }

  .pet-panel {
    min-width: 280px;
    padding: 16px;
  }
}

/* Seasonal Event Banner */
.seasonal-banner {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  padding: var(--space-sm) var(--space-xl);
  background: linear-gradient(90deg, transparent, rgba(218, 165, 32, 0.15), transparent);
  backdrop-filter: blur(8px);
  border-bottom-left-radius: var(--radius-lg);
  border-bottom-right-radius: var(--radius-lg);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-top: none;
  text-align: center;
  z-index: var(--z-hud);
  pointer-events: none;
  min-width: 300px;
  animation: seasonalBannerFadeIn 1s ease;
  transition: all 0.5s ease;
}

.seasonal-banner-title {
  font-family: var(--font-main);
  font-size: var(--font-size-sm);
  font-weight: bold;
  letter-spacing: 0.08em;
  margin-bottom: 2px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
}

.seasonal-banner-desc {
  font-size: var(--font-size-xs);
  opacity: 0.9;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
}

.seasonal-banner-countdown {
  font-size: var(--font-size-xs);
  opacity: 0.7;
  margin-top: 2px;
}

@keyframes seasonalBannerFadeIn {
  0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  100% { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Seasonal Item Badge */
.seasonal-item-badge {
  position: absolute;
  top: 2px;
  right: 2px;
  width: 12px;
  height: 12px;
  border-radius: var(--radius-round);
  border: 1px solid rgba(255, 255, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  font-weight: bold;
  pointer-events: none;
  animation: seasonalBadgePulse 2s ease-in-out infinite;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.5);
}

@keyframes seasonalBadgePulse {
  0%, 100% { transform: scale(1); opacity: 0.9; }
  50% { transform: scale(1.1); opacity: 1; }
}

/* Season-specific styles */
.season-spring {
  background: linear-gradient(90deg, transparent, rgba(248, 180, 200, 0.2), transparent);
  border-color: rgba(248, 180, 200, 0.4);
}

.season-spring .seasonal-banner-title {
  color: #f8b4c8;
}

.season-spring .seasonal-banner-desc,
.season-spring .seasonal-banner-countdown {
  color: #7db37d;
}

.season-spring .seasonal-item-badge {
  background: #f8b4c8;
  color: #7db37d;
  border-color: #ffd4e5;
}

.season-summer {
  background: linear-gradient(90deg, transparent, rgba(240, 192, 64, 0.2), transparent);
  border-color: rgba(240, 192, 64, 0.4);
}

.season-summer .seasonal-banner-title {
  color: #f0c040;
}

.season-summer .seasonal-banner-desc,
.season-summer .seasonal-banner-countdown {
  color: #ff8c42;
}

.season-summer .seasonal-item-badge {
  background: #f0c040;
  color: #ff8c42;
  border-color: #ffe080;
}

.season-autumn {
  background: linear-gradient(90deg, transparent, rgba(212, 160, 64, 0.2), transparent);
  border-color: rgba(212, 160, 64, 0.4);
}

.season-autumn .seasonal-banner-title {
  color: #d4a040;
}

.season-autumn .seasonal-banner-desc,
.season-autumn .seasonal-banner-countdown {
  color: #8b4513;
}

.season-autumn .seasonal-item-badge {
  background: #d4a040;
  color: #8b4513;
  border-color: #e8b860;
}

.season-winter {
  background: linear-gradient(90deg, transparent, rgba(128, 192, 224, 0.2), transparent);
  border-color: rgba(128, 192, 224, 0.4);
}

.season-winter .seasonal-banner-title {
  color: #80c0e0;
}

.season-winter .seasonal-banner-desc,
.season-winter .seasonal-banner-countdown {
  color: #e8e8ff;
}

.season-winter .seasonal-item-badge {
  background: #80c0e0;
  color: #0a0a14;
  border-color: #a0d4f0;
}

/* ========================================================================
   GLOBAL BUTTON HOVER EFFECTS AND ANIMATIONS
   ======================================================================== */

/* Generic button transitions */
.hud-btn, .panel-btn, .craft-btn, .trade-btn, .quest-btn,
.pet-action-btn, .pet-adopt-btn, .npc-dialog-btn {
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease, border-color 0.15s ease;
}

.hud-btn:hover, .panel-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 3px 10px rgba(218, 165, 32, 0.2);
}

.hud-btn:active, .panel-btn:active {
  transform: translateY(0);
}

/* Inventory slot hover enhancement */
.inventory-slot {
  transition: all 0.2s ease, border-color 0.15s ease, transform 0.1s ease;
}

.inventory-slot:hover {
  transform: scale(1.05);
}

/* Recipe item hover enhancement */
.recipe-item {
  transition: all 0.2s ease, background 0.15s ease, border-color 0.15s ease;
}

/* Quest entry hover enhancement */
.quest-entry {
  transition: all 0.2s ease, border-color 0.15s ease, background 0.15s ease;
}

/* Panel close button enhancement */
.panel-close {
  transition: all 0.2s ease, border-color 0.15s ease, transform 0.1s ease;
}

.panel-close:hover {
  transform: scale(1.1);
}

/* Governance panel */
.governance-panel {
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.governance-panel.visible {
  transform: scale(1);
  opacity: 1;
}

/* Discovery panel */
.discovery-panel {
  opacity: 0;
  transition: opacity 0.25s ease;
}

.discovery-panel.visible {
  opacity: 1;
}


/* world.css */
/* Portal Glow Effect */
.portal-glow {
  animation: portalPulse 2s ease-in-out infinite;
}

@keyframes portalPulse {
  0%, 100% {
    opacity: 0.6;
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
    filter: brightness(1.3);
  }
}

/* Loading Screen */
.loading-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--color-night);
  z-index: var(--z-modal);
  transition: opacity 0.5s ease;
}

.loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-spinner {
  width: 64px;
  height: 64px;
  border: 4px solid var(--color-border);
  border-top-color: var(--color-accent);
  border-radius: var(--radius-round);
  animation: spin 1s linear infinite;
  margin-bottom: var(--space-lg);
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.loading-text {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-text-muted);
  font-style: italic;
}

.loading-progress {
  margin-top: var(--space-md);
  font-size: var(--font-size-sm);
  color: var(--color-accent);
}

/* Player Label (floating above sprite) */
.player-label {
  position: absolute;
  transform: translate(-50%, -150%);
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-family: var(--font-ui);
  font-size: var(--font-size-xs);
  color: var(--color-text);
  white-space: nowrap;
  pointer-events: none;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  transition: opacity 0.3s ease;
}

.player-label.self {
  color: var(--color-accent);
  border-color: var(--color-accent);
}

.player-label.ai {
  color: var(--color-crystal);
  border-color: var(--color-water);
}

/* XR Warning Overlay */
.xr-warning {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(26, 26, 26, 0.95);
  z-index: var(--z-modal);
  padding: var(--space-xl);
  text-align: center;
}

.xr-warning-title {
  font-family: var(--font-main);
  font-size: var(--font-size-xxl);
  color: var(--color-warning);
  margin-bottom: var(--space-lg);
}

.xr-warning-text {
  font-size: var(--font-size-md);
  color: var(--color-text);
  max-width: 600px;
  line-height: 1.6;
  margin-bottom: var(--space-md);
}

.xr-warning-list {
  text-align: left;
  max-width: 500px;
  margin: var(--space-lg) auto;
  color: var(--color-text-muted);
  line-height: 1.8;
}

.xr-warning-list li {
  margin-bottom: var(--space-sm);
}

.xr-warning-btn {
  background: var(--color-warning);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-md) var(--space-xl);
  font-family: var(--font-ui);
  font-size: var(--font-size-lg);
  font-weight: bold;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.2s ease;
  margin-top: var(--space-lg);
}

.xr-warning-btn:hover {
  background: var(--color-dawn);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.xr-warning-btn:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

/* World Effects */
.zone-transition {
  animation: zoneTransition 1s ease-in-out;
}

@keyframes zoneTransition {
  0% { opacity: 1; }
  50% { opacity: 0.3; }
  100% { opacity: 1; }
}

.item-pickup {
  animation: itemPickup 0.5s ease-out;
}

@keyframes itemPickup {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: scale(0);
    opacity: 0;
  }
}

.spark-gain {
  animation: sparkGain 1s ease-out;
  color: var(--color-gold);
  font-weight: bold;
}

@keyframes sparkGain {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translateY(-50px) scale(1.5);
    opacity: 0;
  }
}

/* Environmental effects */
.weather-rain {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(transparent, rgba(135, 206, 235, 0.1));
  animation: rain 0.3s linear infinite;
}

@keyframes rain {
  0% { opacity: 0.5; }
  50% { opacity: 0.8; }
  100% { opacity: 0.5; }
}

.weather-night {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(26, 26, 46, 0.3);
  transition: opacity 2s ease;
}

/* NPC Speech Bubbles */
.npc-speech-bubble {
  position: absolute;
  pointer-events: none;
  transform: translate(-50%, -100%);
  background: rgba(10, 14, 26, 0.9);
  border: 1px solid rgba(218, 165, 32, 0.5);
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 11px;
  color: #E8E0D8;
  white-space: nowrap;
  max-width: 200px;
  text-align: center;
  z-index: 50;
  animation: speechBubbleIn 0.3s ease-out;
}

.npc-speech-bubble::after {
  content: '';
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid rgba(218, 165, 32, 0.5);
}

.npc-speech-bubble.fading {
  animation: speechBubbleOut 0.5s ease-in forwards;
}

@keyframes speechBubbleIn {
  0% { opacity: 0; transform: translate(-50%, -80%); }
  100% { opacity: 1; transform: translate(-50%, -100%); }
}

@keyframes speechBubbleOut {
  0% { opacity: 1; transform: translate(-50%, -100%); }
  100% { opacity: 0; transform: translate(-50%, -120%); }
}

/* Loading Bar */
.loading-title {
  font-family: var(--font-main);
  font-size: 3.5rem;
  color: var(--color-gold);
  letter-spacing: 0.3em;
  text-shadow: 0 0 30px rgba(218, 165, 32, 0.3);
  margin-bottom: 0.5rem;
}

.loading-subtitle {
  color: var(--color-text-muted);
  font-style: italic;
  margin-bottom: 2rem;
}

.loading-bar-container {
  width: 300px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: 1rem;
}

.loading-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--color-gold), #f0d060);
  border-radius: 2px;
  transition: width 0.3s ease;
  animation: loadingPulse 1.5s ease-in-out infinite;
}

@keyframes loadingPulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

.loading-status {
  font-size: 0.75rem;
  color: var(--color-text-muted);
  letter-spacing: 0.05em;
}

/* Mobile Touch Controls */
.mobile-action-btn {
  position: fixed;
  border-radius: 50%;
  background: rgba(10, 14, 26, 0.75);
  border: 2px solid rgba(218, 165, 32, 0.5);
  color: #DAA520;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-family: var(--font-ui);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  z-index: 100;
  transition: background 0.15s, border-color 0.15s;
}

.mobile-action-btn:active {
  background: rgba(218, 165, 32, 0.3);
  border-color: #DAA520;
}

.mobile-joystick {
  position: fixed;
  bottom: 30px;
  left: 30px;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(10, 14, 26, 0.5);
  border: 2px solid rgba(218, 165, 32, 0.3);
  z-index: 100;
  touch-action: none;
}

.mobile-joystick-handle {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(218, 165, 32, 0.4);
  border: 2px solid rgba(218, 165, 32, 0.7);
  transition: none;
}

/* Controls Overlay */
.controls-overlay {
  position: absolute;
  bottom: var(--space-lg);
  right: var(--space-lg);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  box-shadow: var(--shadow-md);
  display: none;
  max-height: 60vh;
  overflow-y: auto;
  z-index: 200;
}

.controls-overlay.visible {
  display: block;
  animation: fadeIn 0.2s ease-in;
}

.controls-overlay-title {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-sm);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-xs);
}

.control-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
  font-size: var(--font-size-sm);
}

.control-key {
  color: var(--color-gold);
  font-weight: bold;
  min-width: 50px;
}

.control-desc {
  color: var(--color-text-muted);
}

/* Login button styling */
.login-btn {
  padding: 0.75rem 1.5rem;
  background: rgba(218, 165, 32, 0.15);
  border: 1px solid var(--color-gold);
  border-radius: 8px;
  color: var(--color-gold);
  font-family: var(--font-main);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  letter-spacing: 0.05em;
}

.login-btn:hover {
  background: rgba(218, 165, 32, 0.25);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(218, 165, 32, 0.2);
}

.login-btn:active {
  transform: translateY(0);
}

/* Performance optimizations */
.gpu-accelerated {
  transform: translateZ(0);
  will-change: transform;
}

.fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.fade-out {
  animation: fadeOut 0.5s ease-out;
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}


  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="world-canvas"></canvas>

    <div id="hud-container">
      <div class="zone-label" id="zone-label">The Nexus</div>
      <div class="player-info" id="player-info"></div>
      <div class="minimap" id="minimap"><canvas id="minimap-canvas" width="150" height="150"></canvas></div>
      <div class="nearby-list" id="nearby-list"></div>
      <div class="chat-panel" id="chat-panel">
        <div class="chat-messages" id="chat-messages"></div>
        <input type="text" class="chat-input" id="chat-input" placeholder="Press Enter to chat..." />
      </div>
    </div>

    <div id="login-screen">
      <div style="text-align:center; animation: fadeIn 1.5s ease;">
        <h1 style="font-family: var(--font-main); color: var(--color-gold); font-size: 4rem; margin-bottom: 0.25rem; letter-spacing: 0.3em; text-shadow: 0 0 30px rgba(218,165,32,0.3);">ZION</h1>
        <div style="width: 100px; height: 1px; background: linear-gradient(90deg, transparent, var(--color-gold), transparent); margin: 0.5rem auto 1rem;"></div>
        <p style="color: var(--color-text-muted); margin-bottom: 0.5rem; font-style: italic; font-family: var(--font-main);">A living world where human and artificial minds meet in peace.</p>
        <p style="color: rgba(176,224,230,0.5); font-size: 0.7rem; margin-bottom: 2rem; letter-spacing: 0.1em;">100 AI citizens await you</p>
      </div>
      <div id="login-options" style="display:flex; flex-direction:column; gap:1rem; align-items:center; width:320px; animation: fadeIn 2s ease;">
        <div style="display:flex; gap:0.5rem; width:100%;">
          <input type="text" id="guest-name" placeholder="Choose a name..." maxlength="39"
            style="flex:1; padding:0.75rem 1rem; border-radius:8px; border:1px solid var(--color-border);
            background:rgba(255,255,255,0.08); color:var(--color-text); font-size:1rem; outline:none;
            transition: border-color 0.3s ease, background 0.3s ease;"
            onfocus="this.style.borderColor='var(--color-gold)';this.style.background='rgba(255,255,255,0.12)'"
            onblur="this.style.borderColor='';this.style.background=''"
            onkeydown="if(event.key==='Enter'){document.getElementById('guest-btn').click()}" />
          <button class="login-btn" id="guest-btn" style="padding:0.75rem 1.25rem;"
            onclick="var n=document.getElementById('guest-name').value;if(Auth.loginAsGuest(n)){location.reload();}else{document.getElementById('guest-name').style.borderColor='#EF5350';}">Play</button>
        </div>
        <span style="color:var(--color-text-muted); font-size:0.75rem; letter-spacing:0.1em;">or</span>
        <button class="login-btn" id="login-btn" style="width:100%;"
          onclick="Auth.initiateOAuth()">Enter with GitHub</button>
        <p style="color:rgba(160,151,142,0.5); font-size:0.65rem; margin-top:1rem;">WASD move / E interact / B build / M map / F emote / X fish / Q pet / Z housing / J quests / G guild</p>
      </div>
    </div>

    <div id="loading-overlay" class="loading-screen" style="display:none;">
      <div class="loading-title">ZION</div>
      <div class="loading-subtitle">Entering the world...</div>
      <div class="loading-bar-container"><div class="loading-bar" id="loading-bar"></div></div>
      <div class="loading-status" id="loading-status">Initializing...</div>
    </div>

    <div class="controls-overlay" id="controls-overlay">
      <div class="controls-overlay-title">Controls</div>
      <div class="control-row"><span class="control-key">WASD</span><span class="control-desc">Move</span></div>
      <div class="control-row"><span class="control-key">Mouse</span><span class="control-desc">Look</span></div>
      <div class="control-row"><span class="control-key">E</span><span class="control-desc">Interact</span></div>
      <div class="control-row"><span class="control-key">I</span><span class="control-desc">Inventory</span></div>
      <div class="control-row"><span class="control-key">C</span><span class="control-desc">Craft</span></div>
      <div class="control-row"><span class="control-key">J</span><span class="control-desc">Quests</span></div>
      <div class="control-row"><span class="control-key">T</span><span class="control-desc">Trade</span></div>
      <div class="control-row"><span class="control-key">B</span><span class="control-desc">Build</span></div>
      <div class="control-row"><span class="control-key">M</span><span class="control-desc">Map</span></div>
      <div class="control-row"><span class="control-key">F</span><span class="control-desc">Emotes</span></div>
      <div class="control-row"><span class="control-key">G</span><span class="control-desc">Guild</span></div>
      <div class="control-row"><span class="control-key">K</span><span class="control-desc">Skills</span></div>
      <div class="control-row"><span class="control-key">L</span><span class="control-desc">Lore Book</span></div>
      <div class="control-row"><span class="control-key">V</span><span class="control-desc">Discoveries</span></div>
      <div class="control-row"><span class="control-key">H</span><span class="control-desc">Governance</span></div>
      <div class="control-row"><span class="control-key">Y</span><span class="control-desc">Achievements</span></div>
      <div class="control-row"><span class="control-key">U</span><span class="control-desc">Auctions</span></div>
      <div class="control-row"><span class="control-key">N</span><span class="control-desc">Compose</span></div>
      <div class="control-row"><span class="control-key">P</span><span class="control-desc">Profile</span></div>
      <div class="control-row"><span class="control-key">Q</span><span class="control-desc">Pet</span></div>
      <div class="control-row"><span class="control-key">X</span><span class="control-desc">Fish</span></div>
      <div class="control-row"><span class="control-key">Z</span><span class="control-desc">Housing</span></div>
      <div class="control-row"><span class="control-key">Enter</span><span class="control-desc">Chat</span></div>
      <div class="control-row"><span class="control-key">Esc</span><span class="control-desc">Settings</span></div>
    </div>

    <div class="notification" id="notification" style="display:none;"></div>
  </div>

  <script>
    // protocol.js
// protocol.js â€” Universal message protocol for ZION
(function(exports) {
  'use strict';

  // Protocol version
  const PROTOCOL_VERSION = 1;

  // Valid message types
  const MESSAGE_TYPES = new Set([
    'join',
    'leave',
    'heartbeat',
    'idle',
    'move',
    'warp',
    'say',
    'shout',
    'whisper',
    'emote',
    'build',
    'plant',
    'craft',
    'compose',
    'harvest',
    'trade_offer',
    'trade_accept',
    'trade_decline',
    'buy',
    'sell',
    'gift',
    'teach',
    'learn',
    'mentor_offer',
    'mentor_accept',
    'challenge',
    'accept_challenge',
    'forfeit',
    'score',
    'discover',
    'anchor_place',
    'inspect',
    'intention_set',
    'intention_clear',
    'warp_fork',
    'return_home',
    'federation_announce',
    'federation_handshake',
    'reputation_adjust',
    'report_griefing',
    'election_start',
    'election_vote',
    'election_finalize',
    'steward_set_welcome',
    'steward_set_policy',
    'steward_moderate',
    'star_register'
  ]);

  // Message types that require consent
  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  // Valid platforms
  const PLATFORMS = new Set([
    'desktop',
    'phone',
    'vr',
    'ar',
    'api'
  ]);

  // Per-player sequence counter storage
  const sequenceCounters = new Map();

  /**
   * Get the next sequence number for a player
   * @param {string} playerId - The player ID
   * @returns {number} The next sequence number
   */
  function getNextSeq(playerId) {
    if (!sequenceCounters.has(playerId)) {
      sequenceCounters.set(playerId, 0);
    }
    const current = sequenceCounters.get(playerId);
    sequenceCounters.set(playerId, current + 1);
    return current;
  }

  /**
   * Generate a UUID v4
   * @returns {string} A UUID string
   */
  function generateUUID() {
    // Use crypto.randomUUID if available (Node 16.7+ and modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }

    // Fallback implementation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Generate an ISO-8601 timestamp
   * @returns {string} ISO-8601 formatted timestamp
   */
  function generateTimestamp() {
    return new Date().toISOString();
  }

  /**
   * Create a message object
   * @param {string} type - Message type (must be in MESSAGE_TYPES)
   * @param {string} from - Player ID sending the message
   * @param {object} payload - Message payload data
   * @param {object} opts - Optional fields (platform, position, geo)
   * @returns {object} Valid message object
   */
  function createMessage(type, from, payload, opts = {}) {
    if (!MESSAGE_TYPES.has(type)) {
      throw new Error(`Invalid message type: ${type}`);
    }

    if (!from || typeof from !== 'string') {
      throw new Error('Invalid from: must be a non-empty string');
    }

    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
      throw new Error('Invalid payload: must be an object');
    }

    const message = {
      v: PROTOCOL_VERSION,
      id: generateUUID(),
      ts: generateTimestamp(),
      seq: getNextSeq(from),
      from: from,
      type: type,
      platform: opts.platform || 'desktop',
      position: opts.position || { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: opts.geo || null,
      payload: payload
    };

    return message;
  }

  /**
   * Validate a message object
   * @param {object} msg - Message to validate
   * @returns {object} {valid: boolean, errors: string[]}
   */
  function validateMessage(msg) {
    const errors = [];

    // Check if msg is an object
    if (!msg || typeof msg !== 'object' || Array.isArray(msg)) {
      return { valid: false, errors: ['Message must be an object'] };
    }

    // Validate version
    if (msg.v !== PROTOCOL_VERSION) {
      errors.push(`Invalid version: expected ${PROTOCOL_VERSION}, got ${msg.v}`);
    }

    // Validate id
    if (!msg.id || typeof msg.id !== 'string') {
      errors.push('Invalid id: must be a non-empty string');
    }

    // Validate timestamp
    if (!msg.ts || typeof msg.ts !== 'string') {
      errors.push('Invalid ts: must be a non-empty string');
    } else {
      // Check if it's a valid ISO-8601 timestamp
      const date = new Date(msg.ts);
      if (isNaN(date.getTime())) {
        errors.push('Invalid ts: must be a valid ISO-8601 timestamp');
      }
    }

    // Validate sequence
    if (typeof msg.seq !== 'number' || msg.seq < 0 || !Number.isInteger(msg.seq)) {
      errors.push('Invalid seq: must be a non-negative integer');
    }

    // Validate from
    if (!msg.from || typeof msg.from !== 'string') {
      errors.push('Invalid from: must be a non-empty string');
    }

    // Validate type
    if (!MESSAGE_TYPES.has(msg.type)) {
      errors.push(`Invalid type: ${msg.type} is not a valid message type`);
    }

    // Validate platform
    if (!PLATFORMS.has(msg.platform)) {
      errors.push(`Invalid platform: ${msg.platform} is not a valid platform`);
    }

    // Validate position
    if (!msg.position || typeof msg.position !== 'object' || Array.isArray(msg.position)) {
      errors.push('Invalid position: must be an object');
    } else {
      if (typeof msg.position.x !== 'number') {
        errors.push('Invalid position.x: must be a number');
      }
      if (typeof msg.position.y !== 'number') {
        errors.push('Invalid position.y: must be a number');
      }
      if (typeof msg.position.z !== 'number') {
        errors.push('Invalid position.z: must be a number');
      }
      if (!msg.position.zone || typeof msg.position.zone !== 'string') {
        errors.push('Invalid position.zone: must be a non-empty string');
      }
    }

    // Validate geo (optional)
    if (msg.geo !== null && msg.geo !== undefined) {
      if (typeof msg.geo !== 'object' || Array.isArray(msg.geo)) {
        errors.push('Invalid geo: must be an object or null');
      } else {
        if (msg.geo.lat !== null && msg.geo.lat !== undefined && typeof msg.geo.lat !== 'number') {
          errors.push('Invalid geo.lat: must be a number or null');
        }
        if (msg.geo.lon !== null && msg.geo.lon !== undefined && typeof msg.geo.lon !== 'number') {
          errors.push('Invalid geo.lon: must be a number or null');
        }
      }
    }

    // Validate payload
    if (!msg.payload || typeof msg.payload !== 'object' || Array.isArray(msg.payload)) {
      errors.push('Invalid payload: must be an object');
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  // Convenience creators: Protocol.create.join(from, payload), etc.
  var create = {};
  MESSAGE_TYPES.forEach(function(type) {
    create[type] = function(from, payload, opts) {
      return createMessage(type, from, payload || {}, opts);
    };
  });
  // Alias: Protocol.create.chat â†’ say
  create.chat = create.say;

  // Export all functions and constants
  exports.PROTOCOL_VERSION = PROTOCOL_VERSION;
  exports.MESSAGE_TYPES = MESSAGE_TYPES;
  exports.CONSENT_REQUIRED_TYPES = CONSENT_REQUIRED_TYPES;
  exports.PLATFORMS = PLATFORMS;
  exports.createMessage = createMessage;
  exports.validateMessage = validateMessage;
  exports.getNextSeq = getNextSeq;
  exports.generateUUID = generateUUID;
  exports.generateTimestamp = generateTimestamp;
  exports.create = create;

})(typeof module !== 'undefined' ? module.exports : (window.Protocol = {}));


// zones.js
// zones.js â€” Zone definitions and rule enforcement for ZION
(function(exports) {
  'use strict';

  // Zone definitions with complete metadata
  const ZONES = {
    nexus: {
      name: 'The Nexus',
      description: 'The central hub connecting all realms. A safe gathering place where travelers from all zones converge to trade, socialize, and plan their journeys.',
      terrain: 'crystalline plaza',
      bounds: { x_min: -100, x_max: 100, z_min: -100, z_max: 100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena']
    },

    gardens: {
      name: 'The Gardens',
      description: 'Lush botanical gardens filled with herbs, flowers, and fruit trees. A peaceful sanctuary for gathering natural resources and contemplation.',
      terrain: 'cultivated gardens',
      bounds: { x_min: 100, x_max: 500, z_min: -200, z_max: 200 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'wilds', 'athenaeum']
    },

    athenaeum: {
      name: 'The Athenaeum',
      description: 'A grand library and hall of learning. Scholars gather here to study, teach, and share knowledge across all disciplines.',
      terrain: 'marble halls',
      bounds: { x_min: -500, x_max: -100, z_min: 100, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'gardens', 'studio']
    },

    studio: {
      name: 'The Studio',
      description: 'A creative workshop where artists, composers, and craftspeople collaborate on their works. Inspiration flows freely in this space of artistic expression.',
      terrain: 'artisan workshops',
      bounds: { x_min: -500, x_max: -100, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'athenaeum', 'agora']
    },

    wilds: {
      name: 'The Wilds',
      description: 'Untamed wilderness filled with rare resources and natural wonders. Beautiful but unpredictable, explorers must be prepared for anything.',
      terrain: 'wilderness',
      bounds: { x_min: 500, x_max: 1000, z_min: -500, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: false
      },
      portals: ['nexus', 'gardens', 'arena']
    },

    agora: {
      name: 'The Agora',
      description: 'A bustling marketplace where merchants display their wares and traders negotiate deals. The commercial heart of the realm.',
      terrain: 'market square',
      bounds: { x_min: -200, x_max: 200, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'studio', 'commons']
    },

    commons: {
      name: 'The Commons',
      description: 'A collaborative building space where communities construct shared infrastructure and personal projects. A place of collective creation.',
      terrain: 'building grounds',
      bounds: { x_min: 100, x_max: 500, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: true,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'agora', 'arena']
    },

    arena: {
      name: 'The Arena',
      description: 'A proving ground for competitive challenges and contests of skill. Those seeking glory test themselves against worthy opponents.',
      terrain: 'combat grounds',
      bounds: { x_min: 500, x_max: 1000, z_min: 500, z_max: 1000 },
      rules: {
        pvp: true,
        building: false,
        harvesting: false,
        trading: false,
        competition: true,
        safe: false
      },
      portals: ['nexus', 'wilds', 'commons']
    }
  };

  // Action to rule mapping
  const ACTION_RULE_MAP = {
    build: 'building',
    plant: 'harvesting',
    harvest: 'harvesting',
    trade_offer: 'trading',
    trade_accept: 'trading',
    trade_decline: 'trading',
    buy: 'trading',
    sell: 'trading',
    challenge: 'competition_pvp', // Special: requires both competition AND pvp
    accept_challenge: 'competition_pvp'
  };

  /**
   * Get the rules for a specific zone
   * @param {string} zoneId - The zone identifier
   * @returns {object|null} Zone rules object or null if zone not found
   */
  function getZoneRules(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return null;
    }
    return zone.rules;
  }

  /**
   * Check if an action is allowed in a specific zone
   * @param {string} action - The action to check (message type)
   * @param {string} zoneId - The zone identifier
   * @returns {boolean} True if action is allowed, false otherwise
   */
  function isActionAllowed(action, zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return false;
    }

    const ruleKey = ACTION_RULE_MAP[action];

    // If no rule mapping exists, action is allowed by default
    if (!ruleKey) {
      return true;
    }

    // Special case: challenge/accept_challenge requires both competition AND pvp
    if (ruleKey === 'competition_pvp') {
      return zone.rules.competition === true && zone.rules.pvp === true;
    }

    // Check the mapped rule
    return zone.rules[ruleKey] === true;
  }

  /**
   * Get all zones connected to a specific zone via portals
   * @param {string} zoneId - The zone identifier
   * @returns {string[]} Array of connected zone IDs
   */
  function getConnectedZones(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return [];
    }
    return zone.portals || [];
  }

  /**
   * Get the spawn zone for new players
   * @returns {string} The spawn zone ID
   */
  function getSpawnZone() {
    return 'nexus';
  }

  /**
   * Get complete zone information
   * @param {string} zoneId - The zone identifier
   * @returns {object|null} Complete zone data or null if not found
   */
  function getZone(zoneId) {
    return ZONES[zoneId] || null;
  }

  /**
   * Get all zone IDs
   * @returns {string[]} Array of all zone identifiers
   */
  function getAllZoneIds() {
    return Object.keys(ZONES);
  }

  /**
   * Check if a zone exists
   * @param {string} zoneId - The zone identifier
   * @returns {boolean} True if zone exists
   */
  function zoneExists(zoneId) {
    return ZONES.hasOwnProperty(zoneId);
  }

  // Zone governance stores
  const zoneStewards = new Map(); // zoneId -> {stewards: [], elections: [], policies: {}}
  const governanceLog = []; // Array of all governance actions
  const zoneRegulars = new Map(); // zoneId -> Set(playerId) - players who visit regularly

  // Governance constants
  const STEWARD_TERM_LENGTH = 604800000; // 7 days in milliseconds
  const ELECTION_DURATION = 172800000; // 2 days in milliseconds (voting period)
  const MAX_STEWARDS_PER_ZONE = 3;
  const REGULAR_VISIT_THRESHOLD = 5; // Visits needed to be considered a regular
  const REGULAR_VISIT_WINDOW = 2592000000; // 30 days

  /**
   * Initialize governance for a zone
   * @param {string} zoneId - Zone identifier
   */
  function initZoneGovernance(zoneId) {
    if (!zoneStewards.has(zoneId)) {
      zoneStewards.set(zoneId, {
        stewards: [],
        elections: [],
        policies: {
          welcomeMessage: '',
          buildingRequiresApproval: false,
          chatModerated: false,
          eventCalendar: []
        }
      });
    }
    if (!zoneRegulars.has(zoneId)) {
      zoneRegulars.set(zoneId, new Map()); // playerId -> visitCount
    }
  }

  /**
   * Record zone visit for player
   * @param {string} zoneId - Zone identifier
   * @param {string} playerId - Player ID
   */
  function recordZoneVisit(zoneId, playerId) {
    initZoneGovernance(zoneId);
    const regulars = zoneRegulars.get(zoneId);

    if (!regulars.has(playerId)) {
      regulars.set(playerId, { count: 0, lastVisit: 0 });
    }

    const record = regulars.get(playerId);
    record.count++;
    record.lastVisit = Date.now();
  }

  /**
   * Check if player is a zone regular
   * @param {string} zoneId - Zone identifier
   * @param {string} playerId - Player ID
   * @returns {boolean}
   */
  function isZoneRegular(zoneId, playerId) {
    initZoneGovernance(zoneId);
    const regulars = zoneRegulars.get(zoneId);
    const record = regulars.get(playerId);

    if (!record) return false;

    // Check if enough visits and within window
    const withinWindow = (Date.now() - record.lastVisit) < REGULAR_VISIT_WINDOW;
    return record.count >= REGULAR_VISIT_THRESHOLD && withinWindow;
  }

  /**
   * Get zone stewards
   * @param {string} zoneId - Zone identifier
   * @returns {Array} Array of steward objects
   */
  function getZoneStewards(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    // Filter active stewards (term not expired)
    const now = Date.now();
    governance.stewards = governance.stewards.filter(s => s.termEnd > now);

    return governance.stewards;
  }

  /**
   * Check if player is a steward of zone
   * @param {string} zoneId - Zone identifier
   * @param {string} playerId - Player ID
   * @returns {boolean}
   */
  function isZoneSteward(zoneId, playerId) {
    const stewards = getZoneStewards(zoneId);
    return stewards.some(s => s.playerId === playerId);
  }

  /**
   * Start zone steward election
   * @param {string} zoneId - Zone identifier
   * @param {Array} candidates - Array of candidate player IDs
   * @returns {Object} Election object
   */
  function startElection(zoneId, candidates) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    const election = {
      id: `election_${zoneId}_${Date.now()}`,
      zoneId,
      candidates: candidates.map(playerId => ({
        playerId,
        votes: 0,
        voters: new Set()
      })),
      startTime: Date.now(),
      endTime: Date.now() + ELECTION_DURATION,
      status: 'active',
      totalVotes: 0
    };

    governance.elections.push(election);

    logGovernanceAction({
      type: 'election_started',
      zoneId,
      electionId: election.id,
      candidates: candidates,
      timestamp: Date.now()
    });

    return election;
  }

  /**
   * Cast vote in zone election
   * @param {string} electionId - Election ID
   * @param {string} voterId - Voter player ID
   * @param {string} candidateId - Candidate player ID
   * @returns {Object} {success: boolean, error?: string}
   */
  function castVote(electionId, voterId, candidateId) {
    // Find election across all zones
    for (const [zoneId, governance] of zoneStewards.entries()) {
      const election = governance.elections.find(e => e.id === electionId);
      if (!election) continue;

      // Check election is active
      if (election.status !== 'active') {
        return { success: false, error: 'Election is not active' };
      }

      if (Date.now() > election.endTime) {
        election.status = 'ended';
        return { success: false, error: 'Election has ended' };
      }

      // Check voter is a zone regular
      if (!isZoneRegular(zoneId, voterId)) {
        return { success: false, error: 'Only zone regulars can vote' };
      }

      // Check voter hasn't already voted
      const hasVoted = election.candidates.some(c => c.voters.has(voterId));
      if (hasVoted) {
        return { success: false, error: 'You have already voted in this election' };
      }

      // Find candidate and cast vote
      const candidate = election.candidates.find(c => c.playerId === candidateId);
      if (!candidate) {
        return { success: false, error: 'Candidate not found' };
      }

      candidate.votes++;
      candidate.voters.add(voterId);
      election.totalVotes++;

      logGovernanceAction({
        type: 'vote_cast',
        zoneId,
        electionId,
        voterId,
        candidateId,
        timestamp: Date.now()
      });

      return { success: true };
    }

    return { success: false, error: 'Election not found' };
  }

  /**
   * Finalize election and assign stewards
   * @param {string} electionId - Election ID
   * @returns {Object} {success: boolean, stewards?: Array, error?: string}
   */
  function finalizeElection(electionId) {
    for (const [zoneId, governance] of zoneStewards.entries()) {
      const election = governance.elections.find(e => e.id === electionId);
      if (!election) continue;

      if (Date.now() < election.endTime) {
        return { success: false, error: 'Election is still in progress' };
      }

      election.status = 'finalized';

      // Sort candidates by votes
      const sorted = [...election.candidates].sort((a, b) => b.votes - a.votes);

      // Top candidates become stewards (up to MAX_STEWARDS_PER_ZONE)
      const winners = sorted.slice(0, MAX_STEWARDS_PER_ZONE);

      const newStewards = winners.map(winner => ({
        playerId: winner.playerId,
        zoneId,
        electionId,
        votes: winner.votes,
        termStart: Date.now(),
        termEnd: Date.now() + STEWARD_TERM_LENGTH,
        actions: []
      }));

      // Clear existing stewards and set new ones
      governance.stewards = newStewards;

      logGovernanceAction({
        type: 'election_finalized',
        zoneId,
        electionId,
        stewards: newStewards.map(s => ({ playerId: s.playerId, votes: s.votes })),
        timestamp: Date.now()
      });

      return { success: true, stewards: newStewards };
    }

    return { success: false, error: 'Election not found' };
  }

  /**
   * Set zone welcome message (steward only)
   * @param {string} zoneId - Zone identifier
   * @param {string} stewardId - Steward player ID
   * @param {string} message - Welcome message
   * @returns {Object} {success: boolean, error?: string}
   */
  function setWelcomeMessage(zoneId, stewardId, message) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can set welcome message' };
    }

    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    governance.policies.welcomeMessage = message;

    logGovernanceAction({
      type: 'welcome_message_set',
      zoneId,
      stewardId,
      message,
      timestamp: Date.now()
    });

    return { success: true };
  }

  /**
   * Toggle zone policy (steward only)
   * @param {string} zoneId - Zone identifier
   * @param {string} stewardId - Steward player ID
   * @param {string} policy - Policy name
   * @param {boolean} value - Policy value
   * @returns {Object} {success: boolean, error?: string}
   */
  function setZonePolicy(zoneId, stewardId, policy, value) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can set zone policies' };
    }

    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    if (!governance.policies.hasOwnProperty(policy)) {
      return { success: false, error: 'Invalid policy' };
    }

    governance.policies[policy] = value;

    logGovernanceAction({
      type: 'policy_changed',
      zoneId,
      stewardId,
      policy,
      value,
      timestamp: Date.now()
    });

    return { success: true };
  }

  /**
   * Moderate chat in zone (steward only)
   * @param {string} zoneId - Zone identifier
   * @param {string} stewardId - Steward player ID
   * @param {string} targetPlayerId - Player to moderate
   * @param {string} action - Moderation action (warn, mute, etc.)
   * @param {string} reason - Reason for moderation
   * @returns {Object} {success: boolean, error?: string}
   */
  function moderateChat(zoneId, stewardId, targetPlayerId, action, reason) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can moderate chat' };
    }

    logGovernanceAction({
      type: 'chat_moderation',
      zoneId,
      stewardId,
      targetPlayerId,
      action,
      reason,
      timestamp: Date.now()
    });

    return { success: true, action };
  }

  /**
   * Log governance action
   * @param {Object} action - Action object
   */
  function logGovernanceAction(action) {
    governanceLog.push(action);

    // Keep last 1000 actions
    if (governanceLog.length > 1000) {
      governanceLog.shift();
    }
  }

  /**
   * Get governance log for zone
   * @param {string} zoneId - Zone identifier
   * @param {number} limit - Max entries to return
   * @returns {Array} Array of governance actions
   */
  function getGovernanceLog(zoneId, limit) {
    limit = limit || 50;
    return governanceLog
      .filter(action => action.zoneId === zoneId)
      .slice(-limit);
  }

  /**
   * Get zone policies
   * @param {string} zoneId - Zone identifier
   * @returns {Object} Zone policies
   */
  function getZonePolicies(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    return governance.policies;
  }

  /**
   * Get active election for zone
   * @param {string} zoneId - Zone identifier
   * @returns {Object|null} Active election or null
   */
  function getActiveElection(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    const now = Date.now();

    return governance.elections.find(e =>
      e.status === 'active' && e.endTime > now
    ) || null;
  }

  // Export all functions and constants
  exports.ZONES = ZONES;
  exports.getZoneRules = getZoneRules;
  exports.isActionAllowed = isActionAllowed;
  exports.getConnectedZones = getConnectedZones;
  exports.getSpawnZone = getSpawnZone;
  exports.getZone = getZone;
  exports.getAllZoneIds = getAllZoneIds;
  exports.zoneExists = zoneExists;

  // Governance exports
  exports.initZoneGovernance = initZoneGovernance;
  exports.recordZoneVisit = recordZoneVisit;
  exports.isZoneRegular = isZoneRegular;
  exports.getZoneStewards = getZoneStewards;
  exports.isZoneSteward = isZoneSteward;
  exports.startElection = startElection;
  exports.castVote = castVote;
  exports.finalizeElection = finalizeElection;
  exports.setWelcomeMessage = setWelcomeMessage;
  exports.setZonePolicy = setZonePolicy;
  exports.moderateChat = moderateChat;
  exports.getGovernanceLog = getGovernanceLog;
  exports.getZonePolicies = getZonePolicies;
  exports.getActiveElection = getActiveElection;

})(typeof module !== 'undefined' ? module.exports : (window.Zones = {}));


// economy.js
/**
 * ZION Economy System - Spark Ledger & Trading
 * Layer 1 - No project dependencies
 */

(function(exports) {
  'use strict';

  // Earn table: activity â†’ Spark amount or [min, max]
  const EARN_TABLE = {
    daily_login: 10,
    harvest: [5, 15],
    craft: [5, 50],
    teach: [10, 30],
    discover: [5, 25],
    puzzle: [10, 100],
    perform: [5, 20],
    competition_win: [10, 100],
    build: [10, 50],
    mentor: 50,
    anchor_visit: [1, 5],
    gift: [1, 3]
  };

  let transactionCounter = 0;
  let listingCounter = 0;

  /**
   * Creates a new ledger instance
   * @returns {Object} Ledger with balances, transactions, and listings
   */
  function createLedger() {
    return {
      balances: {},
      transactions: [],
      listings: []
    };
  }

  /**
   * Calculates Spark amount based on activity and details
   * @param {string} activity - Activity type
   * @param {Object} details - Activity details (may include complexity/rarity 0-1)
   * @returns {number} Calculated Spark amount
   */
  function calculateEarnAmount(activity, details = {}) {
    const earnValue = EARN_TABLE[activity];

    if (!earnValue) {
      return 0;
    }

    // Fixed amount
    if (typeof earnValue === 'number') {
      return earnValue;
    }

    // Range [min, max] - interpolate based on complexity or rarity
    if (Array.isArray(earnValue) && earnValue.length === 2) {
      const [min, max] = earnValue;
      const factor = details.complexity !== undefined ? details.complexity :
                     details.rarity !== undefined ? details.rarity : 0.5;

      // Clamp factor to [0, 1]
      const clampedFactor = Math.max(0, Math.min(1, factor));
      return Math.round(min + (max - min) * clampedFactor);
    }

    return 0;
  }

  /**
   * Records a transaction in the ledger
   * @param {Object} ledger - Ledger instance
   * @param {string} from - Sender ID (or 'SYSTEM' for earnings)
   * @param {string} to - Recipient ID
   * @param {number} amount - Spark amount
   * @param {string} type - Transaction type
   * @param {Object} details - Additional details
   */
  function recordTransaction(ledger, from, to, amount, type, details = {}) {
    const transaction = {
      id: `tx_${transactionCounter++}_${Date.now()}`,
      ts: Date.now(),
      from,
      to,
      amount,
      type,
      details
    };
    ledger.transactions.push(transaction);
    return transaction;
  }

  /**
   * Earns Spark for a player - THE ONLY WAY TO CREATE SPARK
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @param {string} activity - Activity type from EARN_TABLE
   * @param {Object} details - Activity details
   * @returns {number} Amount earned
   */
  function earnSpark(ledger, playerId, activity, details = {}) {
    const amount = calculateEarnAmount(activity, details);

    if (amount <= 0) {
      return 0;
    }

    // Initialize balance if needed
    if (!ledger.balances[playerId]) {
      ledger.balances[playerId] = 0;
    }

    // Credit the player
    ledger.balances[playerId] += amount;

    // Record transaction
    recordTransaction(ledger, 'SYSTEM', playerId, amount, 'earn', {
      activity,
      ...details
    });

    return amount;
  }

  /**
   * Spends Spark from a player's balance
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @param {number} amount - Amount to spend
   * @returns {Object} {success: boolean, balance: number}
   */
  function spendSpark(ledger, playerId, amount) {
    const currentBalance = getBalance(ledger, playerId);

    if (amount <= 0) {
      return { success: false, balance: currentBalance };
    }

    if (currentBalance < amount) {
      return { success: false, balance: currentBalance };
    }

    // Deduct from balance
    ledger.balances[playerId] -= amount;

    // Record transaction
    recordTransaction(ledger, playerId, 'SYSTEM', amount, 'spend', {});

    return { success: true, balance: ledger.balances[playerId] };
  }

  /**
   * Transfers Spark between players
   * @param {Object} ledger - Ledger instance
   * @param {string} from - Sender player ID
   * @param {string} to - Recipient player ID
   * @param {number} amount - Amount to transfer
   * @returns {Object} {success: boolean}
   */
  function transferSpark(ledger, from, to, amount) {
    if (amount <= 0) {
      return { success: false };
    }

    const senderBalance = getBalance(ledger, from);
    if (senderBalance < amount) {
      return { success: false };
    }

    // Initialize recipient balance if needed
    if (!ledger.balances[to]) {
      ledger.balances[to] = 0;
    }

    // Perform transfer
    ledger.balances[from] -= amount;
    ledger.balances[to] += amount;

    // Record transaction
    recordTransaction(ledger, from, to, amount, 'transfer', {});

    return { success: true };
  }

  /**
   * Gets a player's current Spark balance
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @returns {number} Current balance (0 if not found)
   */
  function getBalance(ledger, playerId) {
    return ledger.balances[playerId] || 0;
  }

  /**
   * Creates a market listing
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Seller player ID
   * @param {Object} item - Item being sold
   * @param {number} price - Price in Spark
   * @returns {Object} Listing object
   */
  function createMarketListing(ledger, playerId, item, price) {
    const listing = {
      id: `listing_${listingCounter++}_${Date.now()}`,
      seller: playerId,
      item,
      price,
      ts: Date.now(),
      active: true
    };

    ledger.listings.push(listing);
    return listing;
  }

  /**
   * Buys a market listing
   * @param {Object} ledger - Ledger instance
   * @param {string} buyerId - Buyer player ID
   * @param {string} listingId - Listing ID
   * @returns {Object} {success: boolean, item?: Object}
   */
  function buyListing(ledger, buyerId, listingId) {
    // Find the listing
    const listing = ledger.listings.find(l => l.id === listingId && l.active);

    if (!listing) {
      return { success: false };
    }

    // Check buyer's balance
    const buyerBalance = getBalance(ledger, buyerId);
    if (buyerBalance < listing.price) {
      return { success: false };
    }

    // Prevent self-purchase
    if (buyerId === listing.seller) {
      return { success: false };
    }

    // Initialize seller balance if needed
    if (!ledger.balances[listing.seller]) {
      ledger.balances[listing.seller] = 0;
    }

    // Transfer Spark from buyer to seller
    ledger.balances[buyerId] -= listing.price;
    ledger.balances[listing.seller] += listing.price;

    // Mark listing as inactive
    listing.active = false;

    // Record transaction
    recordTransaction(ledger, buyerId, listing.seller, listing.price, 'market_purchase', {
      listingId,
      item: listing.item
    });

    return { success: true, item: listing.item };
  }

  /**
   * Gets transaction log for a player
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @returns {Array} Array of transactions
   */
  function getTransactionLog(ledger, playerId) {
    return ledger.transactions.filter(tx =>
      tx.from === playerId || tx.to === playerId
    );
  }

  // ========================================================================
  // ECONOMY STATISTICS & MARKET BROWSING
  // ========================================================================

  function getActiveListings(ledger) {
    if (!ledger || !ledger.listings) return [];
    return ledger.listings.filter(function(l) { return l.active; });
  }

  function getListingsByItem(ledger, itemId) {
    return getActiveListings(ledger).filter(function(l) {
      return l.item === itemId || (l.item && l.item.id === itemId);
    });
  }

  function getListingsBySeller(ledger, sellerId) {
    return getActiveListings(ledger).filter(function(l) {
      return l.seller === sellerId;
    });
  }

  function cancelListing(ledger, listingId, sellerId) {
    if (!ledger || !ledger.listings) return { success: false, message: 'No ledger' };

    var listing = ledger.listings.find(function(l) { return l.id === listingId; });
    if (!listing) return { success: false, message: 'Listing not found' };
    if (listing.seller !== sellerId) return { success: false, message: 'Not your listing' };
    if (!listing.active) return { success: false, message: 'Already inactive' };

    listing.active = false;
    return { success: true, item: listing.item };
  }

  function getEconomyStats(ledger) {
    if (!ledger) return {};

    var totalSpark = 0;
    var playerCount = 0;
    for (var pid in ledger.balances) {
      totalSpark += ledger.balances[pid] || 0;
      playerCount++;
    }

    var activeListings = getActiveListings(ledger);
    var totalTransactions = ledger.transactions ? ledger.transactions.length : 0;

    // Calculate velocity (transactions per player)
    var velocity = playerCount > 0 ? totalTransactions / playerCount : 0;

    return {
      totalSpark: totalSpark,
      playerCount: playerCount,
      averageSpark: playerCount > 0 ? Math.floor(totalSpark / playerCount) : 0,
      activeListings: activeListings.length,
      totalTransactions: totalTransactions,
      velocity: Math.round(velocity * 100) / 100
    };
  }

  function getLeaderboard(ledger, limit) {
    if (!ledger || !ledger.balances) return [];
    limit = limit || 10;

    var players = [];
    for (var pid in ledger.balances) {
      players.push({ playerId: pid, spark: ledger.balances[pid] || 0 });
    }

    players.sort(function(a, b) { return b.spark - a.spark; });
    return players.slice(0, limit);
  }

  // ========================================================================
  // AUCTION HOUSE - Timed bid system
  // ========================================================================

  var auctionCounter = 0;

  /**
   * Create an auction listing
   * @param {Object} ledger
   * @param {string} sellerId
   * @param {Object} item - Item being auctioned
   * @param {number} startingBid - Minimum bid
   * @param {number} durationMs - Auction duration in milliseconds
   * @returns {Object} Auction object
   */
  function createAuction(ledger, sellerId, item, startingBid, durationMs) {
    if (!ledger.auctions) ledger.auctions = [];

    var auction = {
      id: 'auction_' + (auctionCounter++) + '_' + Date.now(),
      seller: sellerId,
      item: item,
      startingBid: startingBid || 1,
      currentBid: 0,
      currentBidder: null,
      bids: [],
      startTime: Date.now(),
      endTime: Date.now() + (durationMs || 300000), // Default 5 min
      status: 'active'
    };

    ledger.auctions.push(auction);
    return auction;
  }

  /**
   * Place a bid on an auction
   * @param {Object} ledger
   * @param {string} auctionId
   * @param {string} bidderId
   * @param {number} amount
   * @returns {Object} {success, message}
   */
  function placeBid(ledger, auctionId, bidderId, amount) {
    if (!ledger.auctions) return { success: false, message: 'No auctions' };

    var auction = ledger.auctions.find(function(a) { return a.id === auctionId; });
    if (!auction) return { success: false, message: 'Auction not found' };
    if (auction.status !== 'active') return { success: false, message: 'Auction not active' };
    if (Date.now() > auction.endTime) return { success: false, message: 'Auction ended' };
    if (auction.seller === bidderId) return { success: false, message: 'Cannot bid on own auction' };
    if (amount <= auction.currentBid) return { success: false, message: 'Bid must be higher than current bid' };
    if (amount < auction.startingBid) return { success: false, message: 'Bid below minimum' };

    var balance = getBalance(ledger, bidderId);
    if (balance < amount) return { success: false, message: 'Insufficient Spark' };

    // Record bid
    auction.currentBid = amount;
    auction.currentBidder = bidderId;
    auction.bids.push({ bidder: bidderId, amount: amount, ts: Date.now() });

    // Extend auction if bid in last 30s (anti-sniping)
    if (auction.endTime - Date.now() < 30000) {
      auction.endTime = Date.now() + 30000;
    }

    return { success: true, message: 'Bid placed' };
  }

  /**
   * Finalize ended auctions
   * @param {Object} ledger
   * @returns {Array} Completed auctions
   */
  function finalizeAuctions(ledger) {
    if (!ledger.auctions) return [];

    var now = Date.now();
    var completed = [];

    for (var i = 0; i < ledger.auctions.length; i++) {
      var auction = ledger.auctions[i];
      if (auction.status !== 'active') continue;
      if (now < auction.endTime) continue;

      if (auction.currentBidder && auction.currentBid > 0) {
        // Check winner still has funds
        var winnerBalance = getBalance(ledger, auction.currentBidder);
        if (winnerBalance >= auction.currentBid) {
          // Transfer Spark
          if (!ledger.balances[auction.seller]) ledger.balances[auction.seller] = 0;
          ledger.balances[auction.currentBidder] -= auction.currentBid;
          ledger.balances[auction.seller] += auction.currentBid;

          recordTransaction(ledger, auction.currentBidder, auction.seller, auction.currentBid, 'auction', {
            auctionId: auction.id,
            item: auction.item
          });

          auction.status = 'sold';
          completed.push({ auction: auction, winner: auction.currentBidder, item: auction.item });
        } else {
          auction.status = 'failed';
        }
      } else {
        auction.status = 'expired';
      }
    }

    return completed;
  }

  function getActiveAuctions(ledger) {
    if (!ledger.auctions) return [];
    var now = Date.now();
    return ledger.auctions.filter(function(a) {
      return a.status === 'active' && now < a.endTime;
    });
  }

  // ========================================================================
  // ECONOMIC EVENTS - Rotating modifiers
  // ========================================================================

  var ECONOMIC_EVENTS = [
    { id: 'harvest_festival', name: 'Harvest Festival', description: 'Harvesting rewards doubled', modifier: { activity: 'harvest', multiplier: 2 } },
    { id: 'craft_fair', name: 'Craft Fair', description: 'Crafting rewards +50%', modifier: { activity: 'craft', multiplier: 1.5 } },
    { id: 'trading_day', name: 'Grand Trading Day', description: 'Trade bonuses increased', modifier: { activity: 'gift', multiplier: 3 } },
    { id: 'scholars_week', name: "Scholar's Week", description: 'Teaching and discovery rewards doubled', modifier: { activity: 'teach', multiplier: 2 } },
    { id: 'builders_boom', name: "Builder's Boom", description: 'Building rewards +50%', modifier: { activity: 'build', multiplier: 1.5 } },
    { id: 'exploration_surge', name: 'Exploration Surge', description: 'Discovery rewards doubled', modifier: { activity: 'discover', multiplier: 2 } }
  ];

  /**
   * Get current economic event based on day
   * @returns {Object|null} Current event or null
   */
  function getCurrentEvent() {
    var now = new Date();
    var dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
    // Events rotate every 3 days, with 1 day of no event between
    var cycle = dayOfYear % 4;
    if (cycle === 3) return null; // Rest day
    var eventIndex = Math.floor(dayOfYear / 4) % ECONOMIC_EVENTS.length;
    return ECONOMIC_EVENTS[eventIndex];
  }

  /**
   * Apply economic event modifier to earn amount
   * @param {number} baseAmount
   * @param {string} activity
   * @returns {number} Modified amount
   */
  function applyEventModifier(baseAmount, activity) {
    var event = getCurrentEvent();
    if (!event || !event.modifier) return baseAmount;
    if (event.modifier.activity === activity) {
      return Math.round(baseAmount * event.modifier.multiplier);
    }
    return baseAmount;
  }

  // Export public API
  exports.createLedger = createLedger;
  exports.earnSpark = earnSpark;
  exports.spendSpark = spendSpark;
  exports.transferSpark = transferSpark;
  exports.getBalance = getBalance;
  exports.createMarketListing = createMarketListing;
  exports.buyListing = buyListing;
  exports.getTransactionLog = getTransactionLog;
  exports.getActiveListings = getActiveListings;
  exports.getListingsByItem = getListingsByItem;
  exports.getListingsBySeller = getListingsBySeller;
  exports.cancelListing = cancelListing;
  exports.getEconomyStats = getEconomyStats;
  exports.getLeaderboard = getLeaderboard;
  exports.EARN_TABLE = EARN_TABLE;
  exports.createAuction = createAuction;
  exports.placeBid = placeBid;
  exports.finalizeAuctions = finalizeAuctions;
  exports.getActiveAuctions = getActiveAuctions;
  exports.ECONOMIC_EVENTS = ECONOMIC_EVENTS;
  exports.getCurrentEvent = getCurrentEvent;
  exports.applyEventModifier = applyEventModifier;

})(typeof module !== 'undefined' ? module.exports : (window.Economy = {}));


// inventory.js
/**
 * ZION Inventory & Crafting System
 * Manages player inventory, item stacks, crafting recipes, and resource harvesting
 */

(function(exports) {
  'use strict';

  // ========================================================================
  // ITEM CATALOG - All available items in the game
  // ========================================================================

  const ITEM_CATALOG = {
    // Seeds
    seed_wildflower: {
      id: 'seed_wildflower',
      name: 'Wildflower Seeds',
      type: 'seeds',
      icon: 'ðŸŒ±',
      description: 'Seeds that grow into colorful wildflowers',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    seed_lotus: {
      id: 'seed_lotus',
      name: 'Lotus Seeds',
      type: 'seeds',
      icon: 'ðŸª·',
      description: 'Rare seeds that bloom into mystical lotus flowers',
      stackable: true,
      maxStack: 99,
      rarity: 'rare'
    },
    seed_tree: {
      id: 'seed_tree',
      name: 'Tree Seeds',
      type: 'seeds',
      icon: 'ðŸŒ°',
      description: 'Seeds for planting new trees',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // Flowers
    flower_rose: {
      id: 'flower_rose',
      name: 'Rose',
      type: 'flowers',
      icon: 'ðŸŒ¹',
      description: 'A beautiful red rose',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    flower_sunflower: {
      id: 'flower_sunflower',
      name: 'Sunflower',
      type: 'flowers',
      icon: 'ðŸŒ»',
      description: 'A bright yellow sunflower',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    flower_lotus: {
      id: 'flower_lotus',
      name: 'Lotus Flower',
      type: 'flowers',
      icon: 'ðŸª·',
      description: 'A mystical lotus flower',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    flower_tulip: {
      id: 'flower_tulip',
      name: 'Tulip',
      type: 'flowers',
      icon: 'ðŸŒ·',
      description: 'A delicate tulip',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    flower_cherry: {
      id: 'flower_cherry',
      name: 'Cherry Blossom',
      type: 'flowers',
      icon: 'ðŸŒ¸',
      description: 'A gentle cherry blossom',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },

    // Wood
    wood_oak: {
      id: 'wood_oak',
      name: 'Oak Wood',
      type: 'wood',
      icon: 'ðŸªµ',
      description: 'Sturdy oak wood for building',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    wood_pine: {
      id: 'wood_pine',
      name: 'Pine Wood',
      type: 'wood',
      icon: 'ðŸŒ²',
      description: 'Light pine wood',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    wood_mystical: {
      id: 'wood_mystical',
      name: 'Mystical Wood',
      type: 'wood',
      icon: 'âœ¨',
      description: 'Rare wood imbued with energy',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },

    // Stone
    stone_common: {
      id: 'stone_common',
      name: 'Stone',
      type: 'stone',
      icon: 'ðŸª¨',
      description: 'Common building stone',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    stone_marble: {
      id: 'stone_marble',
      name: 'Marble',
      type: 'stone',
      icon: 'â¬œ',
      description: 'Polished marble for fine construction',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    stone_obsidian: {
      id: 'stone_obsidian',
      name: 'Obsidian',
      type: 'stone',
      icon: 'â¬›',
      description: 'Dark volcanic glass',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },

    // Crystal
    crystal_clear: {
      id: 'crystal_clear',
      name: 'Clear Crystal',
      type: 'crystal',
      icon: 'ðŸ’Ž',
      description: 'A pristine clear crystal',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    crystal_amethyst: {
      id: 'crystal_amethyst',
      name: 'Amethyst',
      type: 'crystal',
      icon: 'ðŸ’œ',
      description: 'A purple amethyst crystal',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    crystal_emerald: {
      id: 'crystal_emerald',
      name: 'Emerald',
      type: 'crystal',
      icon: 'ðŸ’š',
      description: 'A vibrant green emerald',
      stackable: true,
      maxStack: 30,
      rarity: 'legendary'
    },

    // Herbs
    herb_mint: {
      id: 'herb_mint',
      name: 'Mint',
      type: 'herbs',
      icon: 'ðŸŒ¿',
      description: 'Refreshing mint leaves',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    herb_sage: {
      id: 'herb_sage',
      name: 'Sage',
      type: 'herbs',
      icon: 'ðŸƒ',
      description: 'Aromatic sage for wisdom',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    herb_ginseng: {
      id: 'herb_ginseng',
      name: 'Ginseng',
      type: 'herbs',
      icon: 'ðŸŒ±',
      description: 'Rare medicinal root',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    herb_lavender: {
      id: 'herb_lavender',
      name: 'Lavender',
      type: 'herbs',
      icon: 'ðŸª»',
      description: 'Calming lavender flowers',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // Food
    food_bread: {
      id: 'food_bread',
      name: 'Bread',
      type: 'food',
      icon: 'ðŸž',
      description: 'Fresh baked bread',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_honey: {
      id: 'food_honey',
      name: 'Honey',
      type: 'food',
      icon: 'ðŸ¯',
      description: 'Sweet golden honey',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    food_mushroom: {
      id: 'food_mushroom',
      name: 'Mushroom',
      type: 'food',
      icon: 'ðŸ„',
      description: 'Edible forest mushroom',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    food_berry: {
      id: 'food_berry',
      name: 'Berries',
      type: 'food',
      icon: 'ðŸ«',
      description: 'Sweet wild berries',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },

    // Tools
    tool_pickaxe: {
      id: 'tool_pickaxe',
      name: 'Pickaxe',
      type: 'tools',
      icon: 'â›ï¸',
      description: 'For mining stone and crystals',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_axe: {
      id: 'tool_axe',
      name: 'Axe',
      type: 'tools',
      icon: 'ðŸª“',
      description: 'For chopping wood',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_shovel: {
      id: 'tool_shovel',
      name: 'Shovel',
      type: 'tools',
      icon: 'ðŸ—ï¸',
      description: 'For digging and planting',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_hammer: {
      id: 'tool_hammer',
      name: 'Hammer',
      type: 'tools',
      icon: 'ðŸ”¨',
      description: 'For crafting and building',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },

    // Crafted Items
    item_workbench: {
      id: 'item_workbench',
      name: 'Workbench',
      type: 'crafted_items',
      icon: 'ðŸ› ï¸',
      description: 'Essential crafting station',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    item_fountain: {
      id: 'item_fountain',
      name: 'Fountain',
      type: 'crafted_items',
      icon: 'â›²',
      description: 'Decorative water fountain',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    item_lantern: {
      id: 'item_lantern',
      name: 'Lantern',
      type: 'crafted_items',
      icon: 'ðŸ®',
      description: 'Provides light in darkness',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    item_statue: {
      id: 'item_statue',
      name: 'Crystal Statue',
      type: 'crafted_items',
      icon: 'ðŸ—¿',
      description: 'A magnificent crystal statue',
      stackable: false,
      maxStack: 1,
      rarity: 'legendary'
    },

    // Potions
    potion_healing: {
      id: 'potion_healing',
      name: 'Healing Potion',
      type: 'potions',
      icon: 'ðŸ§ª',
      description: 'Restores health and warmth',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    potion_energy: {
      id: 'potion_energy',
      name: 'Energy Potion',
      type: 'potions',
      icon: 'âš¡',
      description: 'Boosts movement speed',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    potion_wisdom: {
      id: 'potion_wisdom',
      name: 'Wisdom Potion',
      type: 'potions',
      icon: 'ðŸ”®',
      description: 'Enhances learning and insight',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    // Knowledge Items (Athenaeum)
    item_scroll: {
      id: 'item_scroll',
      name: 'Ancient Scroll',
      type: 'knowledge',
      icon: 'ðŸ“œ',
      description: 'Contains ancient wisdom',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    item_book: {
      id: 'item_book',
      name: 'Knowledge Book',
      type: 'knowledge',
      icon: 'ðŸ“–',
      description: 'A book of collected knowledge',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    // Arena Trophies
    item_trophy: {
      id: 'item_trophy',
      name: 'Trophy',
      type: 'trophies',
      icon: 'ðŸ†',
      description: 'A mark of victory',
      stackable: true,
      maxStack: 10,
      rarity: 'rare'
    },

    // === MUSICAL INSTRUMENTS (Studio) ===
    instrument_flute: {
      id: 'instrument_flute',
      name: 'Wooden Flute',
      type: 'instruments',
      icon: 'ðŸªˆ',
      description: 'A hand-carved wooden flute',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    instrument_drum: {
      id: 'instrument_drum',
      name: 'Hand Drum',
      type: 'instruments',
      icon: 'ðŸ¥',
      description: 'A resonant hand drum for rhythm',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    instrument_harp: {
      id: 'instrument_harp',
      name: 'Crystal Harp',
      type: 'instruments',
      icon: 'ðŸŽµ',
      description: 'A harp strung with crystal fibers',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    instrument_bell: {
      id: 'instrument_bell',
      name: 'Harmony Bell',
      type: 'instruments',
      icon: 'ðŸ””',
      description: 'Rings with perfect pitch',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },

    // === ART SUPPLIES (Studio) ===
    art_pigment: {
      id: 'art_pigment',
      name: 'Pigment',
      type: 'art_supplies',
      icon: 'ðŸŽ¨',
      description: 'Colorful pigment for painting',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    art_canvas: {
      id: 'art_canvas',
      name: 'Canvas',
      type: 'art_supplies',
      icon: 'ðŸ–¼ï¸',
      description: 'Stretched canvas for artwork',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    art_clay: {
      id: 'art_clay',
      name: 'Sculpting Clay',
      type: 'art_supplies',
      icon: 'ðŸº',
      description: 'Soft clay for sculpting',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    art_ink: {
      id: 'art_ink',
      name: 'Luminous Ink',
      type: 'art_supplies',
      icon: 'âœ’ï¸',
      description: 'Ink that faintly glows in darkness',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon'
    },

    // === EXPLORATION GEAR ===
    gear_compass: {
      id: 'gear_compass',
      name: 'Explorer Compass',
      type: 'gear',
      icon: 'ðŸ§­',
      description: 'Points toward undiscovered locations',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    gear_map: {
      id: 'gear_map',
      name: 'Zone Map',
      type: 'gear',
      icon: 'ðŸ—ºï¸',
      description: 'Reveals hidden paths in a zone',
      stackable: true,
      maxStack: 8,
      rarity: 'uncommon'
    },
    gear_spyglass: {
      id: 'gear_spyglass',
      name: 'Spyglass',
      type: 'gear',
      icon: 'ðŸ”­',
      description: 'See farther into the distance',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    gear_rope: {
      id: 'gear_rope',
      name: 'Climbing Rope',
      type: 'gear',
      icon: 'ðŸª¢',
      description: 'Reach high places safely',
      stackable: true,
      maxStack: 10,
      rarity: 'common'
    },

    // === FOOD (expanded) ===
    food_pie: {
      id: 'food_pie',
      name: 'Fruit Pie',
      type: 'food',
      icon: 'ðŸ¥§',
      description: 'A warm pie made with fresh berries',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_stew: {
      id: 'food_stew',
      name: 'Herb Stew',
      type: 'food',
      icon: 'ðŸ²',
      description: 'Hearty stew with healing herbs',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_tea: {
      id: 'food_tea',
      name: 'Calming Tea',
      type: 'food',
      icon: 'ðŸµ',
      description: 'Brewed with lavender and mint',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_cake: {
      id: 'food_cake',
      name: 'Celebration Cake',
      type: 'food',
      icon: 'ðŸŽ‚',
      description: 'A cake for special occasions',
      stackable: true,
      maxStack: 5,
      rarity: 'rare'
    },

    // === DECORATIVE ITEMS ===
    decor_wreath: {
      id: 'decor_wreath',
      name: 'Flower Wreath',
      type: 'decorations',
      icon: 'ðŸ’',
      description: 'A woven wreath of wildflowers',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    decor_banner: {
      id: 'decor_banner',
      name: 'Woven Banner',
      type: 'decorations',
      icon: 'ðŸ³ï¸',
      description: 'A decorative banner for buildings',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    decor_windchime: {
      id: 'decor_windchime',
      name: 'Wind Chime',
      type: 'decorations',
      icon: 'ðŸŽ',
      description: 'Tinkles gently in the breeze',
      stackable: true,
      maxStack: 5,
      rarity: 'uncommon'
    },
    decor_mosaic: {
      id: 'decor_mosaic',
      name: 'Crystal Mosaic',
      type: 'decorations',
      icon: 'ðŸªŸ',
      description: 'A stunning crystal mosaic tile',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    // === RARE COLLECTIBLES ===
    rare_feather: {
      id: 'rare_feather',
      name: 'Phoenix Feather',
      type: 'collectibles',
      icon: 'ðŸª¶',
      description: 'A feather that radiates gentle warmth',
      stackable: true,
      maxStack: 10,
      rarity: 'legendary'
    },
    rare_pearl: {
      id: 'rare_pearl',
      name: 'Moon Pearl',
      type: 'collectibles',
      icon: 'ðŸŒ•',
      description: 'Glows softly under moonlight',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary'
    },
    rare_fossil: {
      id: 'rare_fossil',
      name: 'Ancient Fossil',
      type: 'collectibles',
      icon: 'ðŸ¦´',
      description: 'A fossilized remnant from before ZION',
      stackable: true,
      maxStack: 10,
      rarity: 'rare'
    },
    rare_starfragment: {
      id: 'rare_starfragment',
      name: 'Star Fragment',
      type: 'collectibles',
      icon: 'â­',
      description: 'A piece of fallen starlight',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary'
    },

    // === CLOTH & FIBER ===
    cloth_silk: {
      id: 'cloth_silk',
      name: 'Silk Thread',
      type: 'cloth',
      icon: 'ðŸ§µ',
      description: 'Fine silk for weaving',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    cloth_wool: {
      id: 'cloth_wool',
      name: 'Wool',
      type: 'cloth',
      icon: 'ðŸ§¶',
      description: 'Soft wool for crafting',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // === METAL ===
    metal_copper: {
      id: 'metal_copper',
      name: 'Copper Ore',
      type: 'metal',
      icon: 'ðŸŸ¤',
      description: 'Raw copper for smelting',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    metal_silver: {
      id: 'metal_silver',
      name: 'Silver Ingot',
      type: 'metal',
      icon: 'â¬œ',
      description: 'Refined silver for fine crafting',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    metal_gold: {
      id: 'metal_gold',
      name: 'Gold Nugget',
      type: 'metal',
      icon: 'ðŸŸ¡',
      description: 'A nugget of pure gold',
      stackable: true,
      maxStack: 30,
      rarity: 'rare'
    },

    // === FISHING GEAR ===
    tool_fishing_rod: {
      id: 'tool_fishing_rod',
      name: 'Fishing Rod',
      type: 'tools',
      icon: 'ðŸŽ£',
      description: 'A sturdy rod for catching fish',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    bait_worm: {
      id: 'bait_worm',
      name: 'Worm Bait',
      type: 'bait',
      icon: 'ðŸª±',
      description: 'Simple worm bait for fishing',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    bait_cricket: {
      id: 'bait_cricket',
      name: 'Cricket Bait',
      type: 'bait',
      icon: 'ðŸ¦—',
      description: 'Live cricket bait for better catches',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },

    // === FISH ===
    fish_common: {
      id: 'fish_common',
      name: 'Common Carp',
      type: 'fish',
      icon: 'ðŸŸ',
      description: 'A simple freshwater fish',
      stackable: true,
      maxStack: 50,
      rarity: 'common',
      value: 5
    },
    fish_rare: {
      id: 'fish_rare',
      name: 'Rainbow Trout',
      type: 'fish',
      icon: 'ðŸ ',
      description: 'A beautiful rainbow-colored fish',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon',
      value: 15
    },
    fish_golden: {
      id: 'fish_golden',
      name: 'Golden Koi',
      type: 'fish',
      icon: 'ðŸŸ¡',
      description: 'A rare golden fish of legend',
      stackable: true,
      maxStack: 10,
      rarity: 'rare',
      value: 50
    },
    fish_silver_eel: {
      id: 'fish_silver_eel',
      name: 'Silver Eel',
      type: 'fish',
      icon: 'ðŸ',
      description: 'A sleek silver eel from deep waters',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon',
      value: 20
    },
    fish_crystal_trout: {
      id: 'fish_crystal_trout',
      name: 'Crystal Trout',
      type: 'fish',
      icon: 'ðŸ’Ž',
      description: 'A mystical fish with translucent scales',
      stackable: true,
      maxStack: 15,
      rarity: 'rare',
      value: 40
    },
    fish_shadow_bass: {
      id: 'fish_shadow_bass',
      name: 'Shadow Bass',
      type: 'fish',
      icon: 'ðŸŒ‘',
      description: 'A dark mysterious bass from the depths',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon',
      value: 18
    },
    fish_sunfish: {
      id: 'fish_sunfish',
      name: 'Sunfish',
      type: 'fish',
      icon: 'â˜€ï¸',
      description: 'A bright cheerful sunfish',
      stackable: true,
      maxStack: 50,
      rarity: 'common',
      value: 8
    },
    fish_moonfish: {
      id: 'fish_moonfish',
      name: 'Moonfish',
      type: 'fish',
      icon: 'ðŸŒ™',
      description: 'A pale nocturnal fish',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon',
      value: 25
    },
    fish_starfish: {
      id: 'fish_starfish',
      name: 'Star Cod',
      type: 'fish',
      icon: 'â­',
      description: 'A fish with star-like markings',
      stackable: true,
      maxStack: 20,
      rarity: 'rare',
      value: 35
    },
    fish_dragonfish: {
      id: 'fish_dragonfish',
      name: 'Dragonfish',
      type: 'fish',
      icon: 'ðŸ‰',
      description: 'An extremely rare and powerful fish',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary',
      value: 100
    },

    // === COOKING INGREDIENTS ===
    ingredient_rice: {
      id: 'ingredient_rice',
      name: 'Rice',
      type: 'ingredients',
      icon: 'ðŸš',
      description: 'Grains of white rice',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    ingredient_flour: {
      id: 'ingredient_flour',
      name: 'Flour',
      type: 'ingredients',
      icon: 'ðŸŒ¾',
      description: 'Ground wheat flour',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    ingredient_egg: {
      id: 'ingredient_egg',
      name: 'Egg',
      type: 'ingredients',
      icon: 'ðŸ¥š',
      description: 'A fresh egg',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    ingredient_water: {
      id: 'ingredient_water',
      name: 'Water',
      type: 'ingredients',
      icon: 'ðŸ’§',
      description: 'Clean fresh water',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // === COOKED FISH DISHES ===
    food_grilled_fish: {
      id: 'food_grilled_fish',
      name: 'Grilled Fish',
      type: 'food',
      icon: 'ðŸ–',
      description: 'A perfectly grilled fish fillet',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_fish_stew: {
      id: 'food_fish_stew',
      name: 'Fish Stew',
      type: 'food',
      icon: 'ðŸ²',
      description: 'A hearty fish stew with herbs',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_sushi_roll: {
      id: 'food_sushi_roll',
      name: 'Sushi Roll',
      type: 'food',
      icon: 'ðŸ£',
      description: 'Delicate fish wrapped in rice',
      stackable: true,
      maxStack: 15,
      rarity: 'uncommon'
    },
    food_fish_pie: {
      id: 'food_fish_pie',
      name: 'Fish Pie',
      type: 'food',
      icon: 'ðŸ¥§',
      description: 'A savory fish pie with flaky crust',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_luxury_sashimi: {
      id: 'food_luxury_sashimi',
      name: 'Luxury Sashimi',
      type: 'food',
      icon: 'ðŸ±',
      description: 'Premium sashimi made from rare fish',
      stackable: true,
      maxStack: 5,
      rarity: 'rare'
    }
  };

  // ========================================================================
  // CRAFTING RECIPES
  // ========================================================================

  const RECIPES = [
    // Basic Tools
    {
      id: 'craft_pickaxe',
      name: 'Craft Pickaxe',
      output: { itemId: 'tool_pickaxe', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'stone_common', count: 5 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_axe',
      name: 'Craft Axe',
      output: { itemId: 'tool_axe', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'stone_common', count: 4 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_shovel',
      name: 'Craft Shovel',
      output: { itemId: 'tool_shovel', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'stone_common', count: 3 }
      ],
      sparkReward: 12
    },
    {
      id: 'craft_hammer',
      name: 'Craft Hammer',
      output: { itemId: 'tool_hammer', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'stone_common', count: 6 }
      ],
      sparkReward: 15
    },

    // Crafting Stations
    {
      id: 'craft_workbench',
      name: 'Craft Workbench',
      output: { itemId: 'item_workbench', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 8 },
        { itemId: 'stone_common', count: 4 }
      ],
      sparkReward: 25
    },

    // Decorations
    {
      id: 'craft_fountain',
      name: 'Craft Fountain',
      output: { itemId: 'item_fountain', count: 1 },
      requirements: [
        { itemId: 'stone_marble', count: 12 },
        { itemId: 'crystal_clear', count: 3 }
      ],
      sparkReward: 40
    },
    {
      id: 'craft_lantern',
      name: 'Craft Lantern',
      output: { itemId: 'item_lantern', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_statue',
      name: 'Craft Crystal Statue',
      output: { itemId: 'item_statue', count: 1 },
      requirements: [
        { itemId: 'stone_marble', count: 10 },
        { itemId: 'crystal_amethyst', count: 5 },
        { itemId: 'crystal_emerald', count: 2 }
      ],
      sparkReward: 100
    },

    // Potions
    {
      id: 'craft_healing_potion',
      name: 'Brew Healing Potion',
      output: { itemId: 'potion_healing', count: 1 },
      requirements: [
        { itemId: 'herb_mint', count: 3 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_energy_potion',
      name: 'Brew Energy Potion',
      output: { itemId: 'potion_energy', count: 1 },
      requirements: [
        { itemId: 'herb_lavender', count: 2 },
        { itemId: 'food_honey', count: 1 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_wisdom_potion',
      name: 'Brew Wisdom Potion',
      output: { itemId: 'potion_wisdom', count: 1 },
      requirements: [
        { itemId: 'herb_sage', count: 3 },
        { itemId: 'herb_ginseng', count: 2 },
        { itemId: 'crystal_amethyst', count: 1 }
      ],
      sparkReward: 35
    },

    // Food Crafting
    {
      id: 'craft_bread',
      name: 'Bake Bread',
      output: { itemId: 'food_bread', count: 2 },
      requirements: [
        { itemId: 'seed_wildflower', count: 10 }
      ],
      sparkReward: 8
    },

    // Advanced Materials
    {
      id: 'refine_marble',
      name: 'Refine Marble',
      output: { itemId: 'stone_marble', count: 2 },
      requirements: [
        { itemId: 'stone_common', count: 5 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_mystical_wood',
      name: 'Infuse Mystical Wood',
      output: { itemId: 'wood_mystical', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 5 },
        { itemId: 'crystal_clear', count: 2 }
      ],
      sparkReward: 30
    },

    // Knowledge Crafting
    {
      id: 'craft_book',
      name: 'Bind Knowledge Book',
      output: { itemId: 'item_book', count: 1 },
      requirements: [
        { itemId: 'item_scroll', count: 5 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 25
    },

    // Planting
    {
      id: 'plant_lotus',
      name: 'Plant Lotus Seeds',
      output: { itemId: 'flower_lotus', count: 1 },
      requirements: [
        { itemId: 'seed_lotus', count: 3 }
      ],
      sparkReward: 15
    },
    {
      id: 'plant_flowers',
      name: 'Plant Wildflowers',
      output: { itemId: 'flower_sunflower', count: 3 },
      requirements: [
        { itemId: 'seed_wildflower', count: 5 }
      ],
      sparkReward: 8
    },

    // Musical Instruments
    {
      id: 'craft_flute',
      name: 'Carve Wooden Flute',
      output: { itemId: 'instrument_flute', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 4 },
        { itemId: 'herb_sage', count: 2 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_drum',
      name: 'Build Hand Drum',
      output: { itemId: 'instrument_drum', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'cloth_wool', count: 4 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_harp',
      name: 'String Crystal Harp',
      output: { itemId: 'instrument_harp', count: 1 },
      requirements: [
        { itemId: 'wood_mystical', count: 3 },
        { itemId: 'crystal_clear', count: 4 },
        { itemId: 'cloth_silk', count: 6 }
      ],
      sparkReward: 50
    },
    {
      id: 'craft_bell',
      name: 'Cast Harmony Bell',
      output: { itemId: 'instrument_bell', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 8 },
        { itemId: 'metal_silver', count: 3 },
        { itemId: 'crystal_clear', count: 2 }
      ],
      sparkReward: 45
    },

    // Art Supplies crafting
    {
      id: 'craft_pigment',
      name: 'Grind Pigment',
      output: { itemId: 'art_pigment', count: 5 },
      requirements: [
        { itemId: 'flower_rose', count: 2 },
        { itemId: 'flower_tulip', count: 2 },
        { itemId: 'stone_common', count: 1 }
      ],
      sparkReward: 8
    },
    {
      id: 'craft_canvas',
      name: 'Stretch Canvas',
      output: { itemId: 'art_canvas', count: 2 },
      requirements: [
        { itemId: 'cloth_wool', count: 4 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 12
    },
    {
      id: 'craft_ink',
      name: 'Brew Luminous Ink',
      output: { itemId: 'art_ink', count: 3 },
      requirements: [
        { itemId: 'crystal_clear', count: 1 },
        { itemId: 'herb_sage', count: 3 },
        { itemId: 'food_berry', count: 5 }
      ],
      sparkReward: 18
    },

    // Exploration Gear
    {
      id: 'craft_compass',
      name: 'Craft Explorer Compass',
      output: { itemId: 'gear_compass', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 5 },
        { itemId: 'crystal_clear', count: 2 },
        { itemId: 'metal_silver', count: 1 }
      ],
      sparkReward: 30
    },
    {
      id: 'craft_spyglass',
      name: 'Craft Spyglass',
      output: { itemId: 'gear_spyglass', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 6 },
        { itemId: 'crystal_clear', count: 3 },
        { itemId: 'metal_silver', count: 2 }
      ],
      sparkReward: 40
    },
    {
      id: 'craft_rope',
      name: 'Braid Climbing Rope',
      output: { itemId: 'gear_rope', count: 2 },
      requirements: [
        { itemId: 'cloth_wool', count: 6 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_map',
      name: 'Draw Zone Map',
      output: { itemId: 'gear_map', count: 1 },
      requirements: [
        { itemId: 'art_ink', count: 2 },
        { itemId: 'art_canvas', count: 1 }
      ],
      sparkReward: 15
    },

    // Advanced Food
    {
      id: 'cook_pie',
      name: 'Bake Fruit Pie',
      output: { itemId: 'food_pie', count: 1 },
      requirements: [
        { itemId: 'food_berry', count: 8 },
        { itemId: 'food_honey', count: 1 },
        { itemId: 'seed_wildflower', count: 5 }
      ],
      sparkReward: 18
    },
    {
      id: 'cook_stew',
      name: 'Cook Herb Stew',
      output: { itemId: 'food_stew', count: 1 },
      requirements: [
        { itemId: 'herb_mint', count: 2 },
        { itemId: 'herb_sage', count: 2 },
        { itemId: 'food_mushroom', count: 3 }
      ],
      sparkReward: 15
    },
    {
      id: 'brew_tea',
      name: 'Brew Calming Tea',
      output: { itemId: 'food_tea', count: 3 },
      requirements: [
        { itemId: 'herb_lavender', count: 3 },
        { itemId: 'herb_mint', count: 2 }
      ],
      sparkReward: 10
    },
    {
      id: 'bake_cake',
      name: 'Bake Celebration Cake',
      output: { itemId: 'food_cake', count: 1 },
      requirements: [
        { itemId: 'food_honey', count: 3 },
        { itemId: 'food_berry', count: 5 },
        { itemId: 'food_bread', count: 2 },
        { itemId: 'flower_cherry', count: 2 }
      ],
      sparkReward: 35
    },

    // Decorative Items
    {
      id: 'craft_wreath',
      name: 'Weave Flower Wreath',
      output: { itemId: 'decor_wreath', count: 1 },
      requirements: [
        { itemId: 'flower_rose', count: 3 },
        { itemId: 'flower_tulip', count: 3 },
        { itemId: 'flower_cherry', count: 2 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_banner',
      name: 'Weave Banner',
      output: { itemId: 'decor_banner', count: 1 },
      requirements: [
        { itemId: 'cloth_silk', count: 5 },
        { itemId: 'art_pigment', count: 3 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_windchime',
      name: 'Craft Wind Chime',
      output: { itemId: 'decor_windchime', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 4 },
        { itemId: 'metal_silver', count: 2 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 25
    },
    {
      id: 'craft_mosaic',
      name: 'Craft Crystal Mosaic',
      output: { itemId: 'decor_mosaic', count: 1 },
      requirements: [
        { itemId: 'crystal_clear', count: 2 },
        { itemId: 'crystal_amethyst', count: 1 },
        { itemId: 'stone_marble', count: 3 }
      ],
      sparkReward: 30
    },

    // Metal Refining
    {
      id: 'smelt_silver',
      name: 'Smelt Silver',
      output: { itemId: 'metal_silver', count: 2 },
      requirements: [
        { itemId: 'metal_copper', count: 6 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 15
    },
    {
      id: 'refine_gold',
      name: 'Refine Gold',
      output: { itemId: 'metal_gold', count: 1 },
      requirements: [
        { itemId: 'metal_silver', count: 4 },
        { itemId: 'crystal_amethyst', count: 1 }
      ],
      sparkReward: 25
    },

    // Cloth crafting
    {
      id: 'spin_silk',
      name: 'Spin Silk Thread',
      output: { itemId: 'cloth_silk', count: 3 },
      requirements: [
        { itemId: 'cloth_wool', count: 5 },
        { itemId: 'herb_lavender', count: 2 }
      ],
      sparkReward: 12
    },

    // Fishing Gear
    {
      id: 'craft_fishing_rod',
      name: 'Craft Fishing Rod',
      output: { itemId: 'tool_fishing_rod', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 4 },
        { itemId: 'cloth_silk', count: 2 }
      ],
      sparkReward: 18
    },

    // Fish Cooking Recipes
    {
      id: 'cook_grilled_fish',
      name: 'Grill Fish',
      output: { itemId: 'food_grilled_fish', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 1 },
        { itemId: 'wood_oak', count: 1 }
      ],
      sparkReward: 10
    },
    {
      id: 'cook_fish_stew',
      name: 'Cook Fish Stew',
      output: { itemId: 'food_fish_stew', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 2 },
        { itemId: 'herb_mint', count: 1 },
        { itemId: 'ingredient_water', count: 1 }
      ],
      sparkReward: 15
    },
    {
      id: 'cook_sushi_roll',
      name: 'Make Sushi Roll',
      output: { itemId: 'food_sushi_roll', count: 2 },
      requirements: [
        { itemId: 'fish_rare', count: 1 },
        { itemId: 'ingredient_rice', count: 3 }
      ],
      sparkReward: 20
    },
    {
      id: 'cook_fish_pie',
      name: 'Bake Fish Pie',
      output: { itemId: 'food_fish_pie', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 2 },
        { itemId: 'ingredient_flour', count: 2 },
        { itemId: 'ingredient_egg', count: 1 }
      ],
      sparkReward: 25
    },
    {
      id: 'cook_luxury_sashimi',
      name: 'Prepare Luxury Sashimi',
      output: { itemId: 'food_luxury_sashimi', count: 1 },
      requirements: [
        { itemId: 'fish_golden', count: 1 },
        { itemId: 'ingredient_rice', count: 2 },
        { itemId: 'herb_sage', count: 1 }
      ],
      sparkReward: 50
    }
  ];

  // ========================================================================
  // ZONE LOOT TABLES - What resources can be harvested in each zone
  // ========================================================================

  const ZONE_LOOT_TABLES = {
    nexus: {
      common: ['stone_common', 'herb_mint', 'cloth_wool'],
      uncommon: ['crystal_clear', 'metal_copper'],
      rare: ['item_scroll']
    },
    gardens: {
      common: ['seed_wildflower', 'herb_mint', 'herb_lavender', 'food_berry', 'cloth_wool', 'fish_common', 'fish_sunfish', 'bait_worm'],
      uncommon: ['flower_rose', 'flower_tulip', 'flower_cherry', 'herb_sage', 'food_honey', 'fish_rare', 'fish_crystal_trout', 'bait_cricket'],
      rare: ['seed_lotus', 'herb_ginseng', 'flower_lotus', 'rare_feather', 'fish_golden']
    },
    athenaeum: {
      common: ['item_scroll', 'stone_common', 'herb_sage'],
      uncommon: ['crystal_clear', 'art_ink', 'cloth_silk'],
      rare: ['crystal_amethyst', 'item_book', 'rare_fossil']
    },
    studio: {
      common: ['art_pigment', 'art_clay', 'cloth_wool', 'wood_oak'],
      uncommon: ['art_canvas', 'art_ink', 'cloth_silk', 'metal_copper'],
      rare: ['crystal_clear', 'metal_silver', 'rare_pearl']
    },
    wilds: {
      common: ['wood_oak', 'wood_pine', 'stone_common', 'food_mushroom', 'food_berry', 'gear_rope', 'fish_common', 'bait_worm'],
      uncommon: ['herb_ginseng', 'stone_marble', 'metal_copper', 'rare_fossil', 'fish_shadow_bass', 'fish_silver_eel', 'bait_cricket'],
      rare: ['wood_mystical', 'stone_obsidian', 'crystal_emerald', 'rare_starfragment', 'fish_starfish', 'fish_dragonfish']
    },
    agora: {
      common: ['cloth_wool', 'food_bread', 'metal_copper', 'ingredient_rice', 'ingredient_flour', 'ingredient_egg', 'ingredient_water'],
      uncommon: ['cloth_silk', 'metal_silver', 'food_honey', 'fish_rare'],
      rare: ['metal_gold', 'rare_pearl', 'fish_golden']
    },
    commons: {
      common: ['wood_oak', 'stone_common', 'cloth_wool', 'seed_wildflower', 'fish_common', 'bait_worm'],
      uncommon: ['stone_marble', 'metal_copper', 'flower_sunflower', 'fish_rare', 'fish_sunfish'],
      rare: ['crystal_clear', 'metal_silver', 'fish_moonfish']
    },
    arena: {
      common: ['stone_common', 'metal_copper', 'food_mushroom'],
      uncommon: ['stone_marble', 'metal_silver', 'crystal_clear'],
      rare: ['stone_obsidian', 'metal_gold', 'item_trophy']
    }
  };

  /**
   * Roll a harvest drop from a zone's loot table
   * @param {string} zoneId - The zone to harvest in
   * @param {number} luck - Luck factor 0-1 (affects rarity chance)
   * @returns {Object} {itemId: string, count: number, rarity: string}
   */
  function rollHarvestDrop(zoneId, luck) {
    luck = typeof luck === 'number' ? Math.max(0, Math.min(1, luck)) : 0.3;
    var table = ZONE_LOOT_TABLES[zoneId] || ZONE_LOOT_TABLES.nexus;

    // Determine rarity: common 60%, uncommon 30%, rare 10% (shifted by luck)
    var roll = Math.random();
    var rareChance = 0.05 + luck * 0.15;   // 5-20%
    var uncommonChance = 0.25 + luck * 0.1; // 25-35%

    var rarity, pool;
    if (roll < rareChance && table.rare && table.rare.length > 0) {
      rarity = 'rare';
      pool = table.rare;
    } else if (roll < rareChance + uncommonChance && table.uncommon && table.uncommon.length > 0) {
      rarity = 'uncommon';
      pool = table.uncommon;
    } else {
      rarity = 'common';
      pool = table.common;
    }

    var itemId = pool[Math.floor(Math.random() * pool.length)];
    var count = rarity === 'rare' ? 1 : rarity === 'uncommon' ? Math.floor(Math.random() * 2) + 1 : Math.floor(Math.random() * 3) + 1;

    return { itemId: itemId, count: count, rarity: rarity };
  }

  // ========================================================================
  // PLAYER INVENTORY MANAGEMENT
  // ========================================================================

  /**
   * Create a new inventory for a player
   * @returns {Object} Inventory with 20 slots
   */
  function createInventory() {
    return {
      slots: new Array(20).fill(null),
      quickBar: [0, 1, 2, 3, 4] // Indices of slots shown in quick bar
    };
  }

  /**
   * Add item to inventory
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID from catalog
   * @param {number} count - How many to add
   * @returns {Object} {success: boolean, added: number, message: string}
   */
  function addItem(inventory, itemId, count = 1) {
    const itemData = ITEM_CATALOG[itemId];
    if (!itemData) {
      return { success: false, added: 0, message: 'Unknown item' };
    }

    let remaining = count;

    // If stackable, try to add to existing stacks first
    if (itemData.stackable) {
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && slot.itemId === itemId) {
          const canAdd = Math.min(remaining, itemData.maxStack - slot.count);
          slot.count += canAdd;
          remaining -= canAdd;
          if (remaining <= 0) {
            return { success: true, added: count, message: `Added ${count} ${itemData.name}` };
          }
        }
      }
    }

    // Add to empty slots
    for (let i = 0; i < inventory.slots.length; i++) {
      if (inventory.slots[i] === null) {
        const stackSize = itemData.stackable ? Math.min(remaining, itemData.maxStack) : 1;
        inventory.slots[i] = {
          itemId: itemId,
          count: stackSize
        };
        remaining -= stackSize;
        if (remaining <= 0) {
          return { success: true, added: count, message: `Added ${count} ${itemData.name}` };
        }
      }
    }

    // Inventory full
    const added = count - remaining;
    if (added > 0) {
      return { success: true, added: added, message: `Added ${added} ${itemData.name} (inventory full)` };
    }
    return { success: false, added: 0, message: 'Inventory full' };
  }

  /**
   * Remove item from inventory
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID
   * @param {number} count - How many to remove
   * @returns {Object} {success: boolean, removed: number}
   */
  function removeItem(inventory, itemId, count = 1) {
    let remaining = count;

    for (let i = 0; i < inventory.slots.length; i++) {
      const slot = inventory.slots[i];
      if (slot && slot.itemId === itemId) {
        const removeCount = Math.min(remaining, slot.count);
        slot.count -= removeCount;
        remaining -= removeCount;

        if (slot.count <= 0) {
          inventory.slots[i] = null;
        }

        if (remaining <= 0) {
          return { success: true, removed: count };
        }
      }
    }

    const removed = count - remaining;
    return { success: removed > 0, removed: removed };
  }

  /**
   * Check if player has item
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID
   * @param {number} count - Required count
   * @returns {boolean}
   */
  function hasItem(inventory, itemId, count = 1) {
    return getItemCount(inventory, itemId) >= count;
  }

  /**
   * Get total count of an item
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID
   * @returns {number} Total count
   */
  function getItemCount(inventory, itemId) {
    let total = 0;
    for (const slot of inventory.slots) {
      if (slot && slot.itemId === itemId) {
        total += slot.count;
      }
    }
    return total;
  }

  /**
   * Get inventory as readable array
   * @param {Object} inventory - Player inventory
   * @returns {Array} Array of {itemId, name, icon, count, rarity}
   */
  function getInventory(inventory) {
    return inventory.slots.map(slot => {
      if (!slot) return null;
      const itemData = ITEM_CATALOG[slot.itemId];
      return {
        itemId: slot.itemId,
        name: itemData.name,
        icon: itemData.icon,
        description: itemData.description,
        count: slot.count,
        rarity: itemData.rarity,
        type: itemData.type
      };
    });
  }

  /**
   * Check if recipe can be crafted
   * @param {Object} inventory - Player inventory
   * @param {Object} recipe - Recipe object
   * @returns {boolean}
   */
  function canCraft(inventory, recipe) {
    for (const req of recipe.requirements) {
      if (!hasItem(inventory, req.itemId, req.count)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Craft an item from recipe
   * @param {Object} inventory - Player inventory
   * @param {string} recipeId - Recipe ID
   * @returns {Object} {success: boolean, output?: Object, sparkEarned?: number, message: string}
   */
  function craftItem(inventory, recipeId) {
    const recipe = RECIPES.find(r => r.id === recipeId);
    if (!recipe) {
      return { success: false, message: 'Unknown recipe' };
    }

    if (!canCraft(inventory, recipe)) {
      return { success: false, message: 'Missing required materials' };
    }

    // Remove requirements
    for (const req of recipe.requirements) {
      removeItem(inventory, req.itemId, req.count);
    }

    // Add output
    const result = addItem(inventory, recipe.output.itemId, recipe.output.count);

    if (result.success) {
      return {
        success: true,
        output: recipe.output,
        sparkEarned: recipe.sparkReward,
        message: `Crafted ${recipe.name}!`
      };
    } else {
      // Rare case: crafted but couldn't add to inventory
      return {
        success: false,
        message: 'Crafted but inventory full (materials consumed!)'
      };
    }
  }

  /**
   * Get all available recipes (that player can craft right now)
   * @param {Object} inventory - Player inventory
   * @returns {Array} Array of craftable recipes
   */
  function getAvailableRecipes(inventory) {
    return RECIPES.filter(recipe => canCraft(inventory, recipe));
  }

  /**
   * Get all recipes (whether craftable or not)
   * @returns {Array} All recipes
   */
  function getAllRecipes() {
    return RECIPES;
  }

  /**
   * Get item data from catalog
   * @param {string} itemId - Item ID
   * @returns {Object|null} Item data or null
   */
  function getItemData(itemId) {
    return ITEM_CATALOG[itemId] || null;
  }

  // ========================================================================
  // INVENTORY UTILITIES
  // ========================================================================

  var RARITY_ORDER = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };

  function getInventoryStats(inventory) {
    if (!inventory || !inventory.items) return { totalItems: 0, uniqueItems: 0, totalValue: 0 };

    var totalItems = 0;
    var uniqueItems = 0;
    var byRarity = { common: 0, uncommon: 0, rare: 0, epic: 0, legendary: 0 };
    var byType = {};

    for (var i = 0; i < inventory.items.length; i++) {
      var slot = inventory.items[i];
      if (slot && slot.id) {
        uniqueItems++;
        totalItems += slot.count || 1;
        var data = ITEM_CATALOG[slot.id];
        if (data) {
          var rarity = data.rarity || 'common';
          byRarity[rarity] = (byRarity[rarity] || 0) + (slot.count || 1);
          var type = data.type || 'misc';
          byType[type] = (byType[type] || 0) + (slot.count || 1);
        }
      }
    }

    return {
      totalItems: totalItems,
      uniqueItems: uniqueItems,
      byRarity: byRarity,
      byType: byType,
      slotsUsed: uniqueItems,
      slotsTotal: inventory.maxSlots || 20
    };
  }

  function sortInventory(inventory, sortBy) {
    if (!inventory || !inventory.items) return;
    sortBy = sortBy || 'type';

    // Separate items from empty slots
    var items = inventory.items.filter(function(s) { return s && s.id; });
    var emptyCount = inventory.items.length - items.length;

    items.sort(function(a, b) {
      var dataA = ITEM_CATALOG[a.id] || {};
      var dataB = ITEM_CATALOG[b.id] || {};

      if (sortBy === 'rarity') {
        var ra = RARITY_ORDER[dataA.rarity || 'common'] || 0;
        var rb = RARITY_ORDER[dataB.rarity || 'common'] || 0;
        if (ra !== rb) return rb - ra; // Higher rarity first
      } else if (sortBy === 'type') {
        if (dataA.type !== dataB.type) return (dataA.type || '').localeCompare(dataB.type || '');
      } else if (sortBy === 'name') {
        return (dataA.name || '').localeCompare(dataB.name || '');
      }

      return (dataA.name || '').localeCompare(dataB.name || '');
    });

    // Rebuild with empty slots at end
    inventory.items = items;
    for (var e = 0; e < emptyCount; e++) {
      inventory.items.push(null);
    }
  }

  function searchInventory(inventory, query) {
    if (!inventory || !inventory.items || !query) return [];
    query = query.toLowerCase();

    var results = [];
    for (var i = 0; i < inventory.items.length; i++) {
      var slot = inventory.items[i];
      if (slot && slot.id) {
        var data = ITEM_CATALOG[slot.id] || {};
        if ((data.name || '').toLowerCase().indexOf(query) !== -1 ||
            (data.description || '').toLowerCase().indexOf(query) !== -1 ||
            (data.type || '').toLowerCase().indexOf(query) !== -1) {
          results.push({ slotIndex: i, item: slot, data: data });
        }
      }
    }
    return results;
  }

  // Export public API
  exports.ITEM_CATALOG = ITEM_CATALOG;
  exports.RECIPES = RECIPES;
  exports.createInventory = createInventory;
  exports.addItem = addItem;
  exports.removeItem = removeItem;
  exports.hasItem = hasItem;
  exports.getItemCount = getItemCount;
  exports.getInventory = getInventory;
  exports.canCraft = canCraft;
  exports.craftItem = craftItem;
  exports.getAvailableRecipes = getAvailableRecipes;
  exports.getAllRecipes = getAllRecipes;
  exports.getItemData = getItemData;
  exports.getInventoryStats = getInventoryStats;
  exports.sortInventory = sortInventory;
  exports.searchInventory = searchInventory;
  exports.ZONE_LOOT_TABLES = ZONE_LOOT_TABLES;
  exports.rollHarvestDrop = rollHarvestDrop;

})(typeof module !== 'undefined' ? module.exports : (window.Inventory = {}));


// trading.js
/**
 * ZION Trading System - Player-to-Player Trading
 * Peer-to-peer item and Spark trading with confirmation flow
 */

(function(exports) {
  'use strict';

  // Import references
  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const Inventory = typeof require !== 'undefined' ? require('./inventory') : window.Inventory;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;

  // Active trades by trade ID
  const activeTrades = new Map();

  // Trade invitations (pending requests)
  const pendingInvitations = new Map();

  let tradeCounter = 0;
  let messageCallback = null;

  /**
   * Initialize trading system
   * @param {Function} onMessage - Callback to send trade protocol messages
   */
  function initTrading(onMessage) {
    messageCallback = onMessage;
    console.log('Trading system initialized');
  }

  /**
   * Request trade with another player
   * @param {string} fromPlayerId - Initiating player ID
   * @param {string} toPlayerId - Target player ID
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, tradeId?: string}
   */
  function requestTrade(fromPlayerId, toPlayerId, position) {
    if (fromPlayerId === toPlayerId) {
      return { success: false, message: 'Cannot trade with yourself' };
    }

    // Check if already in a trade with this player
    for (const [tradeId, trade] of activeTrades.entries()) {
      if ((trade.player1.id === fromPlayerId && trade.player2.id === toPlayerId) ||
          (trade.player1.id === toPlayerId && trade.player2.id === fromPlayerId)) {
        return { success: false, message: 'Already in a trade with this player' };
      }
    }

    const tradeId = `trade_${tradeCounter++}_${Date.now()}`;

    // Create pending invitation
    pendingInvitations.set(tradeId, {
      id: tradeId,
      from: fromPlayerId,
      to: toPlayerId,
      timestamp: Date.now()
    });

    // Send trade offer message
    if (messageCallback) {
      const msg = Protocol.create.trade_offer(fromPlayerId, {
        tradeId: tradeId,
        targetPlayer: toPlayerId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, tradeId: tradeId };
  }

  /**
   * Accept trade request
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Accepting player ID
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, trade?: Object}
   */
  function acceptTrade(tradeId, playerId, position) {
    const invitation = pendingInvitations.get(tradeId);

    if (!invitation) {
      return { success: false, message: 'Trade invitation not found' };
    }

    if (invitation.to !== playerId) {
      return { success: false, message: 'Not the intended recipient' };
    }

    // Create trade session
    const trade = {
      id: tradeId,
      player1: {
        id: invitation.from,
        items: [], // Array of {slot: number, itemId: string, count: number}
        spark: 0,
        ready: false,
        confirmed: false
      },
      player2: {
        id: invitation.to,
        items: [],
        spark: 0,
        ready: false,
        confirmed: false
      },
      status: 'active', // active, cancelled, completed
      timestamp: Date.now()
    };

    activeTrades.set(tradeId, trade);
    pendingInvitations.delete(tradeId);

    // Send acceptance message
    if (messageCallback) {
      const msg = Protocol.create.trade_accept(playerId, {
        tradeId: tradeId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, trade: trade };
  }

  /**
   * Decline trade request
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Declining player ID
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function declineTrade(tradeId, playerId, position) {
    const invitation = pendingInvitations.get(tradeId);

    if (!invitation) {
      return { success: false, message: 'Trade invitation not found' };
    }

    if (invitation.to !== playerId) {
      return { success: false, message: 'Not the intended recipient' };
    }

    pendingInvitations.delete(tradeId);

    // Send decline message
    if (messageCallback) {
      const msg = Protocol.create.trade_decline(playerId, {
        tradeId: tradeId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true };
  }

  /**
   * Add item to trade offer
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player adding item
   * @param {number} itemSlot - Inventory slot index
   * @param {Object} inventory - Player's inventory
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function addItemToTrade(tradeId, playerId, itemSlot, inventory, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    // Check if already at max items (6 slots)
    if (player.items.length >= 6) {
      return { success: false, message: 'Trade slots full (max 6 items)' };
    }

    // Verify item exists in inventory
    const item = inventory.slots[itemSlot];
    if (!item) {
      return { success: false, message: 'No item in that slot' };
    }

    // Check if already added
    if (player.items.find(i => i.slot === itemSlot)) {
      return { success: false, message: 'Item already in trade' };
    }

    // Add to trade offer
    player.items.push({
      slot: itemSlot,
      itemId: item.itemId,
      count: item.count
    });

    // Reset ready status when trade changes
    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  /**
   * Remove item from trade offer
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player removing item
   * @param {number} tradeSlot - Trade slot index (0-5)
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function removeItemFromTrade(tradeId, playerId, tradeSlot, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (tradeSlot < 0 || tradeSlot >= player.items.length) {
      return { success: false, message: 'Invalid trade slot' };
    }

    // Remove item
    player.items.splice(tradeSlot, 1);

    // Reset ready status
    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  /**
   * Set Spark amount in trade offer
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player setting Spark
   * @param {number} amount - Spark amount
   * @param {Object} ledger - Economy ledger to verify balance
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function setSparkOffer(tradeId, playerId, amount, ledger, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (amount < 0) {
      return { success: false, message: 'Amount must be non-negative' };
    }

    // Verify player has enough Spark
    if (Economy && ledger) {
      const balance = Economy.getBalance(ledger, playerId);
      if (balance < amount) {
        return { success: false, message: 'Insufficient Spark' };
      }
    }

    player.spark = amount;

    // Reset ready status
    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  /**
   * Set ready status (lock in offer)
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player setting ready
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, bothReady: boolean}
   */
  function setReady(tradeId, playerId, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    player.ready = true;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    const bothReady = trade.player1.ready && trade.player2.ready;
    return { success: true, bothReady: bothReady };
  }

  /**
   * Confirm trade (execute if both confirmed)
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player confirming
   * @param {Object} inventory1 - Player 1's inventory
   * @param {Object} inventory2 - Player 2's inventory
   * @param {Object} ledger - Economy ledger
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, executed?: boolean}
   */
  function confirmTrade(tradeId, playerId, inventory1, inventory2, ledger, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    // Both players must be ready before confirming
    if (!trade.player1.ready || !trade.player2.ready) {
      return { success: false, message: 'Both players must be ready first' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    player.confirmed = true;

    // Check if both confirmed - execute trade
    if (trade.player1.confirmed && trade.player2.confirmed) {
      const result = executeTrade(trade, inventory1, inventory2, ledger);

      if (result.success) {
        trade.status = 'completed';

        // Send completion message
        if (messageCallback) {
          const msg = Protocol.create.trade_accept(playerId, {
            tradeId: tradeId,
            status: 'completed'
          }, { position: position });
          messageCallback(msg);
        }

        // Clean up
        activeTrades.delete(tradeId);

        return { success: true, executed: true };
      } else {
        // Trade execution failed, reset confirmations
        trade.player1.confirmed = false;
        trade.player2.confirmed = false;
        return { success: false, message: result.message };
      }
    }

    // Send confirmation message
    if (messageCallback) {
      const msg = Protocol.create.trade_accept(playerId, {
        tradeId: tradeId,
        confirmed: true
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, executed: false };
  }

  /**
   * Cancel trade at any point
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player cancelling
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function cancelTrade(tradeId, playerId, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      // Check pending invitations
      const invitation = pendingInvitations.get(tradeId);
      if (invitation) {
        pendingInvitations.delete(tradeId);
        return { success: true };
      }
      return { success: false, message: 'Trade not found' };
    }

    if (trade.player1.id !== playerId && trade.player2.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    trade.status = 'cancelled';

    // Send cancellation message
    if (messageCallback) {
      const msg = Protocol.create.trade_decline(playerId, {
        tradeId: tradeId,
        reason: 'cancelled'
      }, { position: position });
      messageCallback(msg);
    }

    activeTrades.delete(tradeId);

    return { success: true };
  }

  /**
   * Execute trade atomically (swap items and Spark)
   * @param {Object} trade - Trade object
   * @param {Object} inventory1 - Player 1's inventory
   * @param {Object} inventory2 - Player 2's inventory
   * @param {Object} ledger - Economy ledger
   * @returns {Object} {success: boolean}
   */
  function executeTrade(trade, inventory1, inventory2, ledger) {
    if (!Inventory || !Economy) {
      return { success: false, message: 'Trading systems not available' };
    }

    // Verify both players have the items and Spark they're offering

    // Check player 1's items
    for (const tradeItem of trade.player1.items) {
      const invItem = inventory1.slots[tradeItem.slot];
      if (!invItem || invItem.itemId !== tradeItem.itemId || invItem.count < tradeItem.count) {
        return { success: false, message: 'Player 1 no longer has offered items' };
      }
    }

    // Check player 2's items
    for (const tradeItem of trade.player2.items) {
      const invItem = inventory2.slots[tradeItem.slot];
      if (!invItem || invItem.itemId !== tradeItem.itemId || invItem.count < tradeItem.count) {
        return { success: false, message: 'Player 2 no longer has offered items' };
      }
    }

    // Check Spark balances
    const balance1 = Economy.getBalance(ledger, trade.player1.id);
    const balance2 = Economy.getBalance(ledger, trade.player2.id);

    if (balance1 < trade.player1.spark) {
      return { success: false, message: 'Player 1 insufficient Spark' };
    }
    if (balance2 < trade.player2.spark) {
      return { success: false, message: 'Player 2 insufficient Spark' };
    }

    // Verify both players have inventory space
    // Count empty slots needed
    const p1NeedsSlots = trade.player2.items.length - trade.player1.items.length;
    const p2NeedsSlots = trade.player1.items.length - trade.player2.items.length;

    const p1EmptySlots = inventory1.slots.filter(s => s === null).length;
    const p2EmptySlots = inventory2.slots.filter(s => s === null).length;

    if (p1NeedsSlots > p1EmptySlots) {
      return { success: false, message: 'Player 1 insufficient inventory space' };
    }
    if (p2NeedsSlots > p2EmptySlots) {
      return { success: false, message: 'Player 2 insufficient inventory space' };
    }

    // Execute atomically:

    // 1. Remove items from both players
    for (const tradeItem of trade.player1.items) {
      Inventory.removeItem(inventory1, tradeItem.itemId, tradeItem.count);
    }
    for (const tradeItem of trade.player2.items) {
      Inventory.removeItem(inventory2, tradeItem.itemId, tradeItem.count);
    }

    // 2. Add items to other player
    for (const tradeItem of trade.player1.items) {
      Inventory.addItem(inventory2, tradeItem.itemId, tradeItem.count);
    }
    for (const tradeItem of trade.player2.items) {
      Inventory.addItem(inventory1, tradeItem.itemId, tradeItem.count);
    }

    // 3. Transfer Spark
    if (trade.player1.spark > 0) {
      Economy.transferSpark(ledger, trade.player1.id, trade.player2.id, trade.player1.spark);
    }
    if (trade.player2.spark > 0) {
      Economy.transferSpark(ledger, trade.player2.id, trade.player1.id, trade.player2.spark);
    }

    return { success: true };
  }

  /**
   * Broadcast trade update message
   * @param {Object} trade - Trade object
   * @param {Object} position - Position for protocol message
   */
  function broadcastTradeUpdate(trade, position) {
    if (!messageCallback) return;

    const msg = Protocol.create.trade_offer(trade.player1.id, {
      tradeId: trade.id,
      player1: {
        items: trade.player1.items,
        spark: trade.player1.spark,
        ready: trade.player1.ready,
        confirmed: trade.player1.confirmed
      },
      player2: {
        items: trade.player2.items,
        spark: trade.player2.spark,
        ready: trade.player2.ready,
        confirmed: trade.player2.confirmed
      },
      status: trade.status
    }, { position: position });

    messageCallback(msg);
  }

  /**
   * Handle incoming trade protocol message
   * @param {Object} msg - Protocol message
   * @returns {Object} {type: string, data: Object}
   */
  function handleTradeMessage(msg) {
    if (!msg || !msg.type || !msg.payload) {
      return null;
    }

    switch (msg.type) {
      case 'trade_offer':
        if (msg.payload.targetPlayer) {
          // New trade request
          return {
            type: 'trade_request',
            data: {
              tradeId: msg.payload.tradeId,
              from: msg.from,
              to: msg.payload.targetPlayer
            }
          };
        } else {
          // Trade update
          return {
            type: 'trade_update',
            data: {
              tradeId: msg.payload.tradeId,
              player1: msg.payload.player1,
              player2: msg.payload.player2,
              status: msg.payload.status
            }
          };
        }

      case 'trade_accept':
        if (msg.payload.status === 'completed') {
          return {
            type: 'trade_complete',
            data: {
              tradeId: msg.payload.tradeId
            }
          };
        } else if (msg.payload.confirmed) {
          return {
            type: 'trade_confirm',
            data: {
              tradeId: msg.payload.tradeId,
              playerId: msg.from
            }
          };
        } else {
          return {
            type: 'trade_accepted',
            data: {
              tradeId: msg.payload.tradeId,
              playerId: msg.from
            }
          };
        }

      case 'trade_decline':
        return {
          type: 'trade_cancelled',
          data: {
            tradeId: msg.payload.tradeId,
            reason: msg.payload.reason || 'declined'
          }
        };

      default:
        return null;
    }
  }

  /**
   * Get active trade for a player
   * @param {string} playerId - Player ID
   * @returns {Object|null} Trade object or null
   */
  function getActiveTrade(playerId) {
    for (const [tradeId, trade] of activeTrades.entries()) {
      if (trade.player1.id === playerId || trade.player2.id === playerId) {
        return trade;
      }
    }
    return null;
  }

  /**
   * Get pending invitation for a player
   * @param {string} playerId - Player ID
   * @returns {Object|null} Invitation object or null
   */
  function getPendingInvitation(playerId) {
    for (const [tradeId, invitation] of pendingInvitations.entries()) {
      if (invitation.to === playerId) {
        return invitation;
      }
    }
    return null;
  }

  // Export public API
  exports.initTrading = initTrading;
  exports.requestTrade = requestTrade;
  exports.acceptTrade = acceptTrade;
  exports.declineTrade = declineTrade;
  exports.addItemToTrade = addItemToTrade;
  exports.removeItemFromTrade = removeItemFromTrade;
  exports.setSparkOffer = setSparkOffer;
  exports.setReady = setReady;
  exports.confirmTrade = confirmTrade;
  exports.cancelTrade = cancelTrade;
  exports.handleTradeMessage = handleTradeMessage;
  exports.getActiveTrade = getActiveTrade;
  exports.getPendingInvitation = getPendingInvitation;

})(typeof module !== 'undefined' ? module.exports : (window.Trading = {}));


// state.js
/**
 * ZION State Management System - Three-tier state management
 * Layer 2 - Self-contained (conceptually depends on protocol.js)
 */

(function(exports) {
  'use strict';

  // In-memory live state
  let liveState = null;

  /**
   * Creates initial world state with all required keys
   * @returns {Object} Initial world state
   */
  function createWorldState() {
    return {
      world: {
        time: 0,
        weather: 'clear',
        season: 'spring',
        dayPhase: 'day'
      },
      players: {},
      economy: {
        balances: {},
        transactions: [],
        listings: []
      },
      gardens: {},
      structures: {},
      discoveries: {},
      anchors: {},
      chat: [],
      actions: [],
      changes: [],
      competitions: {},
      federation: {
        federations: []
      },
      playerStars: {}
    };
  }

  /**
   * Gets current live state
   * @returns {Object} Current in-memory state
   */
  function getLiveState() {
    if (!liveState) {
      liveState = createWorldState();
    }
    return liveState;
  }

  /**
   * Sets a value at a dot-separated path in live state
   * @param {string} path - Dot-separated path (e.g., 'world.time')
   * @param {*} value - Value to set
   */
  function setLiveState(path, value) {
    if (!liveState) {
      liveState = createWorldState();
    }

    const parts = path.split('.');
    let current = liveState;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }

    current[parts[parts.length - 1]] = value;
  }

  /**
   * Flushes live state to localStorage
   */
  function flushToLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const state = getLiveState();
      localStorage.setItem('zion_state', JSON.stringify(state));
    } catch (e) {
      console.error('Failed to flush to localStorage:', e);
    }
  }

  /**
   * Loads state from localStorage to live state
   */
  function loadFromLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const stored = localStorage.getItem('zion_state');
      if (stored) {
        liveState = JSON.parse(stored);
      } else {
        liveState = createWorldState();
      }
    } catch (e) {
      console.error('Failed to load from localStorage:', e);
      liveState = createWorldState();
    }
  }

  /**
   * Flushes to canonical JSON string
   * @returns {string} JSON string of current state
   */
  function flushToCanonical() {
    const state = getLiveState();
    return JSON.stringify(state);
  }

  /**
   * Loads from canonical JSON string
   * @param {string} json - JSON string
   */
  function loadFromCanonical(json) {
    try {
      liveState = JSON.parse(json);
    } catch (e) {
      console.error('Failed to parse canonical state:', e);
      liveState = createWorldState();
    }
  }

  /**
   * Applies a protocol message to state (PURE function)
   * @param {Object} state - Current state
   * @param {Object} message - Protocol message
   * @returns {Object} New state
   */
  function applyMessage(state, message) {
    // Deep clone state for immutability
    const newState = JSON.parse(JSON.stringify(state));

    const { type, from, payload } = message;
    const timestamp = message.ts || Date.now();

    switch (type) {
      case 'join':
        newState.players[from] = {
          id: from,
          name: payload.name || from,
          position: payload.position || { x: 0, y: 0, z: 0 },
          zone: payload.zone || 'default',
          online: true,
          last_seen: timestamp,
          idle: false,
          inventory: [],
          intentions: [],
          ...payload
        };
        break;

      case 'leave':
        if (newState.players[from]) {
          newState.players[from].online = false;
          newState.players[from].last_seen = timestamp;
        }
        break;

      case 'heartbeat':
        if (newState.players[from]) {
          newState.players[from].last_seen = timestamp;
          newState.players[from].idle = false;
        }
        break;

      case 'idle':
        if (newState.players[from]) {
          newState.players[from].idle = true;
        }
        break;

      case 'move':
        if (newState.players[from] && payload.position) {
          newState.players[from].position = payload.position;
        }
        break;

      case 'warp':
        if (newState.players[from]) {
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
          if (payload.zone) {
            newState.players[from].zone = payload.zone;
          }
        }
        break;

      case 'say':
      case 'shout':
      case 'whisper':
      case 'emote':
        newState.chat.push({
          id: `chat_${timestamp}_${from}`,
          type,
          from,
          to: payload.to,
          text: payload.text || payload.message || '',
          ts: timestamp
        });
        break;

      case 'build':
        if (payload.structure) {
          const structureId = `struct_${timestamp}_${from}`;
          newState.structures[structureId] = {
            id: structureId,
            builder: from,
            type: payload.structure.type,
            position: payload.structure.position,
            data: payload.structure.data || {},
            ts: timestamp
          };
        }
        break;

      case 'plant':
        if (payload.plant) {
          const gardenId = `garden_${timestamp}_${from}`;
          newState.gardens[gardenId] = {
            id: gardenId,
            gardener: from,
            plant: payload.plant.type,
            position: payload.plant.position,
            planted_at: timestamp,
            ready_at: timestamp + (payload.plant.grow_time || 60000),
            ready: false
          };
        }
        break;

      case 'harvest':
        if (payload.gardenId && newState.gardens[payload.gardenId]) {
          const garden = newState.gardens[payload.gardenId];
          if (garden.ready || timestamp >= garden.ready_at) {
            delete newState.gardens[payload.gardenId];
            // Add harvested item to player inventory
            if (newState.players[from] && newState.players[from].inventory) {
              newState.players[from].inventory.push({
                type: garden.plant,
                harvested_at: timestamp
              });
            }
          }
        }
        break;

      case 'craft':
        if (payload.item && newState.players[from]) {
          if (!newState.players[from].inventory) {
            newState.players[from].inventory = [];
          }
          newState.players[from].inventory.push({
            type: payload.item.type,
            crafted_at: timestamp,
            data: payload.item.data || {}
          });
        }
        break;

      case 'compose':
        if (payload.art) {
          const artId = `art_${timestamp}_${from}`;
          newState.structures[artId] = {
            id: artId,
            artist: from,
            type: 'art',
            art_type: payload.art.type,
            position: payload.art.position,
            data: payload.art.data || {},
            ts: timestamp
          };
        }
        break;

      case 'trade_offer':
        newState.actions.push({
          id: `trade_${timestamp}_${from}`,
          type: 'trade_offer',
          from,
          to: payload.to,
          offered: payload.offered || [],
          requested: payload.requested || [],
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'trade_accept':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'accepted';
            trade.completed_at = timestamp;
            // Exchange items between players
            if (newState.players[trade.from] && newState.players[trade.to]) {
              // This is simplified - real implementation would transfer items
            }
          }
        }
        break;

      case 'trade_decline':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'declined';
            trade.completed_at = timestamp;
          }
        }
        break;

      case 'buy':
        // Market buy operation - would integrate with economy ledger
        newState.actions.push({
          id: `buy_${timestamp}_${from}`,
          type: 'buy',
          buyer: from,
          listingId: payload.listingId,
          ts: timestamp
        });
        break;

      case 'sell':
        // Market sell operation - would integrate with economy ledger
        newState.actions.push({
          id: `sell_${timestamp}_${from}`,
          type: 'sell',
          seller: from,
          item: payload.item,
          price: payload.price,
          ts: timestamp
        });
        break;

      case 'gift':
        if (payload.to && payload.item) {
          newState.actions.push({
            id: `gift_${timestamp}_${from}`,
            type: 'gift',
            from,
            to: payload.to,
            item: payload.item,
            ts: timestamp
          });
          // Transfer item from sender to recipient
          if (newState.players[from] && newState.players[payload.to]) {
            if (!newState.players[payload.to].inventory) {
              newState.players[payload.to].inventory = [];
            }
            newState.players[payload.to].inventory.push({
              ...payload.item,
              gifted_from: from,
              gifted_at: timestamp
            });
          }
        }
        break;

      case 'teach':
        newState.actions.push({
          id: `teach_${timestamp}_${from}`,
          type: 'teach',
          teacher: from,
          student: payload.to,
          skill: payload.skill,
          ts: timestamp
        });
        break;

      case 'learn':
        newState.actions.push({
          id: `learn_${timestamp}_${from}`,
          type: 'learn',
          learner: from,
          skill: payload.skill,
          source: payload.source,
          ts: timestamp
        });
        break;

      case 'mentor_offer':
        newState.actions.push({
          id: `mentor_${timestamp}_${from}`,
          type: 'mentor_offer',
          mentor: from,
          mentee: payload.to,
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'mentor_accept':
        if (payload.mentorId) {
          const mentorship = newState.actions.find(a => a.id === payload.mentorId);
          if (mentorship && mentorship.type === 'mentor_offer') {
            mentorship.status = 'accepted';
            mentorship.accepted_at = timestamp;
          }
        }
        break;

      case 'challenge':
        const challengeId = `challenge_${timestamp}_${from}`;
        newState.competitions[challengeId] = {
          id: challengeId,
          challenger: from,
          challenged: payload.to,
          type: payload.challenge_type,
          status: 'pending',
          ts: timestamp
        };
        break;

      case 'accept_challenge':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'active';
          newState.competitions[payload.challengeId].accepted_at = timestamp;
        }
        break;

      case 'forfeit':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'forfeited';
          newState.competitions[payload.challengeId].forfeited_by = from;
          newState.competitions[payload.challengeId].completed_at = timestamp;
        }
        break;

      case 'score':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          const comp = newState.competitions[payload.challengeId];
          if (!comp.scores) {
            comp.scores = {};
          }
          comp.scores[from] = payload.score;
        }
        break;

      case 'discover':
        if (payload.discovery) {
          const discoveryId = `discovery_${timestamp}_${from}`;
          newState.discoveries[discoveryId] = {
            id: discoveryId,
            discoverer: from,
            type: payload.discovery.type,
            location: payload.discovery.location,
            data: payload.discovery.data || {},
            ts: timestamp
          };
        }
        break;

      case 'anchor_place':
        if (payload.anchor) {
          const anchorId = `anchor_${timestamp}_${from}`;
          newState.anchors[anchorId] = {
            id: anchorId,
            owner: from,
            position: payload.anchor.position,
            zone: payload.anchor.zone || 'default',
            name: payload.anchor.name,
            ts: timestamp
          };
        }
        break;

      case 'inspect':
        // No state change - returns info only
        break;

      case 'intention_set':
        if (newState.players[from] && payload.intention) {
          if (!newState.players[from].intentions) {
            newState.players[from].intentions = [];
          }
          newState.players[from].intentions.push({
            text: payload.intention,
            set_at: timestamp
          });
        }
        break;

      case 'intention_clear':
        if (newState.players[from]) {
          newState.players[from].intentions = [];
        }
        break;

      case 'warp_fork':
        if (newState.players[from] && payload.target_world) {
          newState.players[from].current_world = payload.target_world;
          newState.players[from].home_world = newState.players[from].home_world || 'default';
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'return_home':
        if (newState.players[from]) {
          const homeWorld = newState.players[from].home_world || 'default';
          newState.players[from].current_world = homeWorld;
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'federation_announce':
        if (payload.federation) {
          newState.federation.federations.push({
            id: `fed_${timestamp}_${from}`,
            announced_by: from,
            name: payload.federation.name,
            endpoint: payload.federation.endpoint,
            ts: timestamp
          });
        }
        break;

      case 'federation_handshake':
        if (payload.federationId) {
          const fed = newState.federation.federations.find(f => f.id === payload.federationId);
          if (fed) {
            fed.handshake_complete = true;
            fed.handshake_at = timestamp;
          }
        }
        break;

      case 'star_register':
        if (!newState.playerStars) newState.playerStars = {};
        if (payload) {
          newState.playerStars[from] = {
            name: payload.name || from,
            x: payload.x || 0,
            y: payload.y || 0,
            z: payload.z || 0,
            color: payload.color || 0xFFDD88,
            ts: timestamp
          };
        }
        break;

      default:
        // Unknown message type - no state change
        break;
    }

    // Record state change
    newState.changes.push({
      type,
      from,
      ts: timestamp
    });

    return newState;
  }

  /**
   * Resolves conflicts between two states using last-writer-wins
   * @param {Object} stateA - First state
   * @param {Object} stateB - Second state
   * @returns {Object} Merged state
   */
  function resolveConflict(stateA, stateB) {
    // Start with a deep clone of stateA
    const merged = JSON.parse(JSON.stringify(stateA));

    // Merge changes arrays and sort by timestamp
    const allChanges = [
      ...(stateA.changes || []),
      ...(stateB.changes || [])
    ].sort((a, b) => a.ts - b.ts);

    // Remove duplicates
    const uniqueChanges = [];
    const seen = new Set();
    for (const change of allChanges) {
      const key = `${change.type}_${change.from}_${change.ts}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueChanges.push(change);
      }
    }

    merged.changes = uniqueChanges;

    // Merge players (last-writer-wins based on last_seen)
    merged.players = { ...stateA.players };
    for (const [playerId, playerB] of Object.entries(stateB.players || {})) {
      const playerA = merged.players[playerId];
      if (!playerA || (playerB.last_seen || 0) > (playerA.last_seen || 0)) {
        merged.players[playerId] = playerB;
      }
    }

    // Merge collections (combine and deduplicate by ID)
    const mergeById = (collectionA, collectionB) => {
      const result = { ...collectionA };
      for (const [id, item] of Object.entries(collectionB || {})) {
        if (!result[id] || (item.ts || 0) > (result[id].ts || 0)) {
          result[id] = item;
        }
      }
      return result;
    };

    merged.gardens = mergeById(stateA.gardens || {}, stateB.gardens || {});
    merged.structures = mergeById(stateA.structures || {}, stateB.structures || {});
    merged.discoveries = mergeById(stateA.discoveries || {}, stateB.discoveries || {});
    merged.anchors = mergeById(stateA.anchors || {}, stateB.anchors || {});
    merged.competitions = mergeById(stateA.competitions || {}, stateB.competitions || {});

    // Merge chat (combine and sort by timestamp)
    merged.chat = [
      ...(stateA.chat || []),
      ...(stateB.chat || [])
    ].sort((a, b) => a.ts - b.ts);

    // Merge actions (combine and deduplicate)
    merged.actions = [
      ...(stateA.actions || []),
      ...(stateB.actions || [])
    ];
    const actionIds = new Set();
    merged.actions = merged.actions.filter(action => {
      if (actionIds.has(action.id)) {
        return false;
      }
      actionIds.add(action.id);
      return true;
    });

    // Merge economy (combine transactions and listings)
    merged.economy = {
      balances: { ...(stateA.economy?.balances || {}), ...(stateB.economy?.balances || {}) },
      transactions: [
        ...(stateA.economy?.transactions || []),
        ...(stateB.economy?.transactions || [])
      ].sort((a, b) => a.ts - b.ts),
      listings: [
        ...(stateA.economy?.listings || []),
        ...(stateB.economy?.listings || [])
      ]
    };

    // Merge federation
    merged.federation = {
      federations: [
        ...(stateA.federation?.federations || []),
        ...(stateB.federation?.federations || [])
      ]
    };

    // World state - use most recent
    const worldATime = stateA.world?.time || 0;
    const worldBTime = stateB.world?.time || 0;
    merged.world = worldBTime > worldATime ? stateB.world : stateA.world;

    return merged;
  }

  // Convenience helpers used by main.js
  function initState() {
    return createWorldState();
  }

  function addPlayer(state, player) {
    if (!state || !player) return;
    state.players[player.id] = {
      id: player.id,
      name: player.name || player.id,
      position: player.position || { x: 0, y: 0, z: 0 },
      zone: player.zone || 'nexus',
      spark: player.spark || 0,
      warmth: player.warmth || 0,
      online: true,
      lastSeen: new Date().toISOString()
    };
  }

  function removePlayer(state, playerId) {
    if (!state || !playerId) return;
    if (state.players[playerId]) {
      state.players[playerId].online = false;
      state.players[playerId].lastSeen = new Date().toISOString();
    }
  }

  function getPlayer(state, playerId) {
    if (!state || !playerId) return null;
    return state.players[playerId] || null;
  }

  function getPlayers(state) {
    if (!state) return [];
    return Object.values(state.players);
  }

  // Export public API
  exports.createWorldState = createWorldState;
  exports.initState = initState;
  exports.addPlayer = addPlayer;
  exports.removePlayer = removePlayer;
  exports.getPlayer = getPlayer;
  exports.getPlayers = getPlayers;
  exports.getLiveState = getLiveState;
  exports.setLiveState = setLiveState;
  exports.flushToLocal = flushToLocal;
  exports.loadFromLocal = loadFromLocal;
  exports.flushToCanonical = flushToCanonical;
  exports.loadFromCanonical = loadFromCanonical;
  exports.applyMessage = applyMessage;
  exports.resolveConflict = resolveConflict;

})(typeof module !== 'undefined' ? module.exports : (window.State = {}));


// intentions.js
/**
 * ZION MMO - Intention System Engine (Layer 2)
 *
 * Allows players (especially AI) to declare conditional rules that auto-execute.
 * Core mechanic for AI player viability in real-time gameplay.
 */

(function(exports) {
  'use strict';

  // Internal store: playerId -> intentions[]
  const intentionStore = new Map();

  // Consent-required action types (actions that need explicit permission)
  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  const MAX_INTENTIONS_PER_PLAYER = 10;

  /**
   * Register a new intention for a player
   * @param {string} playerId - The player ID
   * @param {Object} intention - The intention object
   * @returns {Object} {success: boolean, error?: string}
   */
  function registerIntention(playerId, intention) {
    // Validate intention format
    if (!intention.id || typeof intention.id !== 'string') {
      return { success: false, error: 'Intention must have a valid id' };
    }

    if (!intention.trigger || typeof intention.trigger !== 'object') {
      return { success: false, error: 'Intention must have a trigger object' };
    }

    if (!intention.trigger.condition || typeof intention.trigger.condition !== 'string') {
      return { success: false, error: 'Trigger must have a condition string' };
    }

    if (!intention.trigger.params || typeof intention.trigger.params !== 'object') {
      return { success: false, error: 'Trigger must have a params object' };
    }

    if (!intention.action || typeof intention.action !== 'object') {
      return { success: false, error: 'Intention must have an action object' };
    }

    if (!intention.action.type || typeof intention.action.type !== 'string') {
      return { success: false, error: 'Action must have a type string' };
    }

    if (!intention.action.params || typeof intention.action.params !== 'object') {
      return { success: false, error: 'Action must have a params object' };
    }

    if (typeof intention.priority !== 'number') {
      return { success: false, error: 'Intention must have a numeric priority' };
    }

    if (typeof intention.ttl !== 'number') {
      return { success: false, error: 'Intention must have a numeric ttl' };
    }

    if (typeof intention.cooldown !== 'number') {
      return { success: false, error: 'Intention must have a numeric cooldown' };
    }

    if (typeof intention.max_fires !== 'number') {
      return { success: false, error: 'Intention must have a numeric max_fires' };
    }

    // Check max intentions limit
    const playerIntentions = intentionStore.get(playerId) || [];
    if (playerIntentions.length >= MAX_INTENTIONS_PER_PLAYER) {
      return { success: false, error: `Maximum ${MAX_INTENTIONS_PER_PLAYER} intentions per player exceeded` };
    }

    // Add internal tracking fields
    const intentionWithMeta = {
      ...intention,
      createdAt: Date.now(),
      lastFired: null,
      fireCount: 0
    };

    playerIntentions.push(intentionWithMeta);
    intentionStore.set(playerId, playerIntentions);

    return { success: true };
  }

  /**
   * Clear all intentions for a player
   * @param {string} playerId - The player ID
   */
  function clearIntentions(playerId) {
    intentionStore.delete(playerId);
  }

  /**
   * Get all intentions for a player (public - anyone can read)
   * @param {string} playerId - The player ID
   * @returns {Array} Array of intentions
   */
  function getIntentions(playerId) {
    return intentionStore.get(playerId) || [];
  }

  /**
   * Check if an intention has expired
   * @param {Object} intention - The intention object
   * @param {number} now - Current timestamp
   * @returns {boolean}
   */
  function isIntentionExpired(intention, now) {
    return (now - intention.createdAt) > (intention.ttl * 1000);
  }

  /**
   * Check if an intention can fire
   * @param {Object} intention - The intention object
   * @param {number} now - Current timestamp
   * @returns {boolean}
   */
  function canIntentionFire(intention, now) {
    // Check max fires limit
    if (intention.fireCount >= intention.max_fires) {
      return false;
    }

    // Check cooldown
    if (intention.lastFired !== null) {
      const timeSinceLastFire = now - intention.lastFired;
      if (timeSinceLastFire < (intention.cooldown * 1000)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Trigger evaluators
   */
  const triggerEvaluators = {
    /**
     * Check if a player is nearby
     */
    player_nearby: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const onlyUnknown = params.known === false;

      for (const [playerId, player] of worldState.players.entries()) {
        if (playerId === ownerId) continue;
        if (!player.position) continue;

        const distance = getDistance(owner.position, player.position);
        if (distance < distanceLimit) {
          // If we only want unknown players, check if this player is known
          if (onlyUnknown) {
            // Assume players are known if they're in the owner's known list
            const knownPlayers = owner.knownPlayers || new Set();
            if (!knownPlayers.has(playerId)) {
              return true;
            }
          } else {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Check if a player said a keyword nearby
     */
    player_say: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const keyword = params.keyword;
      const distanceLimit = params.distance_lt || 20;
      const recentChats = worldState.recentChats || [];

      // Check recent chat messages
      for (const chat of recentChats) {
        if (chat.from === ownerId) continue;

        const speaker = worldState.players.get(chat.from);
        if (!speaker || !speaker.position) continue;

        const distance = getDistance(owner.position, speaker.position);
        if (distance < distanceLimit) {
          if (chat.message && chat.message.toLowerCase().includes(keyword.toLowerCase())) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Timer trigger - fires every interval
     */
    timer: function(params, worldState, ownerId, intention, now) {
      const intervalMs = params.interval_seconds * 1000;

      // If never fired, fire immediately
      if (intention.lastFired === null) {
        return true;
      }

      // Check if enough time has passed
      return (now - intention.lastFired) >= intervalMs;
    },

    /**
     * Zone enter trigger
     */
    zone_enter: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      return owner.position.zone === params.zone_id;
    },

    /**
     * Garden needs attention trigger
     */
    garden_needs: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const gardens = worldState.gardens || [];

      for (const garden of gardens) {
        if (!garden.position) continue;

        const distance = getDistance(owner.position, garden.position);
        if (distance < distanceLimit) {
          // Check if garden needs attention
          if (garden.needsWater || garden.needsHarvest || garden.needsWeeding) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Resource ready for harvest trigger
     */
    resource_ready: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const resources = worldState.resources || [];

      for (const resource of resources) {
        if (!resource.position) continue;
        if (!resource.harvestable) continue;

        const distance = getDistance(owner.position, resource.position);
        if (distance < distanceLimit) {
          return true;
        }
      }

      return false;
    }
  };

  /**
   * Calculate Euclidean distance between two 3D positions
   */
  function getDistance(posA, posB) {
    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  /**
   * Generate action message from intention
   */
  function generateActionMessage(intention, playerId, worldState) {
    const action = intention.action;
    const player = worldState.players.get(playerId);

    if (!player) return null;

    // Check if this action requires consent - if so, skip it
    if (CONSENT_REQUIRED_TYPES.has(action.type)) {
      return null;
    }

    // Base message structure
    const message = {
      type: action.type,
      from: playerId,
      payload: { ...action.params },
      position: player.position ? { ...player.position } : null
    };

    return message;
  }

  /**
   * Evaluate all triggers for a player and generate actions
   * @param {string} playerId - The player ID
   * @param {Object} worldState - Current world state
   * @param {number} deltaTime - Time since last evaluation (unused currently)
   * @returns {Array} Array of action messages to execute
   */
  function evaluateTriggers(playerId, worldState, deltaTime) {
    const intentions = intentionStore.get(playerId) || [];
    const now = Date.now();
    const actions = [];

    // Sort by priority (higher priority first)
    const sortedIntentions = [...intentions].sort((a, b) => b.priority - a.priority);

    for (const intention of sortedIntentions) {
      // Check if expired
      if (isIntentionExpired(intention, now)) {
        continue;
      }

      // Check if can fire
      if (!canIntentionFire(intention, now)) {
        continue;
      }

      // Evaluate trigger
      const triggerType = intention.trigger.condition;
      const evaluator = triggerEvaluators[triggerType];

      if (!evaluator) {
        // Stub for unknown triggers
        continue;
      }

      let triggered = false;
      try {
        triggered = evaluator(
          intention.trigger.params,
          worldState,
          playerId,
          intention,
          now
        );
      } catch (error) {
        // Silently skip failed evaluations
        continue;
      }

      if (triggered) {
        // Generate action message
        const actionMessage = generateActionMessage(intention, playerId, worldState);

        if (actionMessage) {
          actions.push(actionMessage);

          // Update firing metadata
          intention.lastFired = now;
          intention.fireCount++;
        }
      }
    }

    return actions;
  }

  // Export public API
  exports.registerIntention = registerIntention;
  exports.clearIntentions = clearIntentions;
  exports.getIntentions = getIntentions;
  exports.evaluateTriggers = evaluateTriggers;
  exports.isIntentionExpired = isIntentionExpired;
  exports.canIntentionFire = canIntentionFire;

})(typeof module !== 'undefined' ? module.exports : (window.Intentions = {}));


// social.js
/**
 * ZION MMO - Social Module (Layer 3)
 *
 * Handles chat, emotes, and consent tracking for player interactions.
 */

(function(exports) {
  'use strict';

  // Internal stores
  const consentStore = new Map(); // "${fromId}:${toId}:${type}" -> boolean
  const rateLimitStore = new Map(); // playerId -> {count, windowStart}
  const reputationStore = new Map(); // playerId -> {score, tier, history}
  const harassmentStore = new Map(); // "${fromId}:${toId}" -> {declineCount, lastDecline}

  // Constants
  const RATE_LIMIT_MAX = 30; // messages per window
  const RATE_LIMIT_WINDOW = 60000; // 60 seconds in milliseconds
  const SAY_DISTANCE = 20;
  const EMOTE_DISTANCE = 30;

  // Reputation constants
  const REPUTATION_TIERS = [
    { name: 'Newcomer', minScore: 0, maxScore: 99 },
    { name: 'Trusted', minScore: 100, maxScore: 499 },
    { name: 'Respected', minScore: 500, maxScore: 1499 },
    { name: 'Honored', minScore: 1500, maxScore: 4999 },
    { name: 'Elder', minScore: 5000, maxScore: Infinity }
  ];

  const REPUTATION_GAINS = {
    helping: 10,
    teaching: 15,
    trading: 5,
    gifting: 8,
    guild_contribution: 12,
    mentoring: 20,
    zone_steward_action: 5
  };

  const REPUTATION_LOSSES = {
    harassment: -25,
    griefing_report: -50,
    steward_violation: -30
  };

  const HARASSMENT_THRESHOLD = 3; // Declined interactions before harassment flag
  const HARASSMENT_WINDOW = 600000; // 10 minutes

  /**
   * Calculate Euclidean distance between two 3D positions
   */
  function getDistance(posA, posB) {
    if (!posA || !posB) return Infinity;

    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  /**
   * Get all players within a certain distance
   * @param {Object} position - The center position {x, y, z, zone}
   * @param {Object} state - World state with players map
   * @param {number} maxDistance - Maximum distance
   * @returns {Array} Array of player IDs
   */
  function getNearbyPlayers(position, state, maxDistance) {
    const nearby = [];

    if (!position || !state.players) return nearby;

    for (const [playerId, player] of state.players.entries()) {
      if (!player.position) continue;

      // Must be in same zone
      if (player.position.zone !== position.zone) continue;

      const distance = getDistance(position, player.position);
      if (distance <= maxDistance) {
        nearby.push(playerId);
      }
    }

    return nearby;
  }

  /**
   * Check rate limit for a player
   * @param {string} playerId - The player ID
   * @param {number} now - Current timestamp
   * @returns {Object} {allowed: boolean, retryAfter?: number}
   */
  function checkRateLimit(playerId, now) {
    const limit = rateLimitStore.get(playerId);

    if (!limit) {
      // First message, create new window
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    const windowAge = now - limit.windowStart;

    if (windowAge >= RATE_LIMIT_WINDOW) {
      // Window expired, start new window
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    // Within current window
    if (limit.count >= RATE_LIMIT_MAX) {
      const retryAfter = RATE_LIMIT_WINDOW - windowAge;
      return { allowed: false, retryAfter };
    }

    // Increment count
    limit.count++;
    return { allowed: true };
  }

  /**
   * Handle say message (nearby players within 20 units)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleSay(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, SAY_DISTANCE);

    // Remove sender from recipients
    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  /**
   * Handle shout message (all players in same zone)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleShout(msg, state) {
    if (!msg.from || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = [];
    const senderZone = sender.position.zone;

    for (const [playerId, player] of state.players.entries()) {
      if (playerId === msg.from) continue;
      if (!player.position) continue;

      if (player.position.zone === senderZone) {
        recipients.push(playerId);
      }
    }

    return { recipients };
  }

  /**
   * Handle whisper message (requires consent)
   * @param {Object} msg - The message object {from, to, payload}
   * @param {Object} state - World state
   * @returns {Object} {success: boolean, error?: string}
   */
  function handleWhisper(msg, state) {
    if (!msg.from || !msg.to) {
      return { success: false, error: 'Whisper requires from and to fields' };
    }

    // Check consent
    if (!hasConsent(msg.from, msg.to, 'whisper')) {
      return { success: false, error: 'Whisper requires consent from recipient' };
    }

    return { success: true };
  }

  /**
   * Handle emote message (nearby players within 30 units)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleEmote(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, EMOTE_DISTANCE);

    // Remove sender from recipients
    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  /**
   * Grant consent for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type (e.g., 'whisper', 'trade_offer')
   */
  function grantConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.set(key, true);
  }

  /**
   * Revoke consent for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type
   */
  function revokeConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.delete(key);
  }

  /**
   * Check if consent exists for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type
   * @returns {boolean}
   */
  function hasConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    return consentStore.get(key) === true;
  }

  /**
   * Add a chat message to state
   */
  function addMessage(state, message) {
    if (!state || !message) return;
    if (!state.chat) state.chat = { messages: [] };
    if (!state.chat.messages) state.chat.messages = [];
    state.chat.messages.push({
      user: message.user,
      text: message.text,
      timestamp: message.timestamp || new Date().toISOString()
    });
    // Keep last 100 messages
    if (state.chat.messages.length > 100) {
      state.chat.messages = state.chat.messages.slice(-100);
    }
  }

  /**
   * Get recent chat messages from state
   */
  function getRecentMessages(state, count) {
    if (!state || !state.chat || !state.chat.messages) return [];
    count = count || 50;
    return state.chat.messages.slice(-count);
  }

  /**
   * Initialize reputation for a player
   * @param {string} playerId - The player ID
   */
  function initReputation(playerId) {
    if (!reputationStore.has(playerId)) {
      reputationStore.set(playerId, {
        score: 0,
        tier: 'Newcomer',
        history: [],
        restrictions: {
          tradeBanned: false,
          zoneMuted: new Set(),
          zoneBanned: new Set()
        }
      });
    }
  }

  /**
   * Get player reputation
   * @param {string} playerId - The player ID
   * @returns {Object} Reputation data
   */
  function getReputation(playerId) {
    initReputation(playerId);
    return reputationStore.get(playerId);
  }

  /**
   * Calculate tier from score
   * @param {number} score - Reputation score
   * @returns {string} Tier name
   */
  function calculateTier(score) {
    for (const tier of REPUTATION_TIERS) {
      if (score >= tier.minScore && score <= tier.maxScore) {
        return tier.name;
      }
    }
    return 'Newcomer';
  }

  /**
   * Adjust player reputation
   * @param {string} playerId - The player ID
   * @param {string} action - Action type (e.g., 'helping', 'harassment')
   * @param {Object} details - Additional details about the action
   */
  function adjustReputation(playerId, action, details) {
    initReputation(playerId);
    const rep = reputationStore.get(playerId);

    const change = REPUTATION_GAINS[action] || REPUTATION_LOSSES[action] || 0;
    const oldScore = rep.score;
    const oldTier = rep.tier;

    rep.score = Math.max(0, rep.score + change);
    rep.tier = calculateTier(rep.score);

    rep.history.push({
      action,
      change,
      oldScore,
      newScore: rep.score,
      timestamp: Date.now(),
      details: details || {}
    });

    // Keep last 100 history entries
    if (rep.history.length > 100) {
      rep.history = rep.history.slice(-100);
    }

    // Check for tier change
    const tierChanged = oldTier !== rep.tier;

    return {
      score: rep.score,
      tier: rep.tier,
      change,
      tierChanged,
      oldTier
    };
  }

  /**
   * Record a declined interaction for harassment detection
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player declining the action
   * @param {string} type - The interaction type
   */
  function recordDecline(fromId, toId, type) {
    const key = `${fromId}:${toId}`;
    const now = Date.now();

    if (!harassmentStore.has(key)) {
      harassmentStore.set(key, {
        declineCount: 0,
        lastDecline: 0,
        type: type
      });
    }

    const record = harassmentStore.get(key);

    // Reset if outside harassment window
    if (now - record.lastDecline > HARASSMENT_WINDOW) {
      record.declineCount = 0;
    }

    record.declineCount++;
    record.lastDecline = now;
    record.type = type;

    // Check if harassment threshold reached
    if (record.declineCount >= HARASSMENT_THRESHOLD) {
      adjustReputation(fromId, 'harassment', {
        targetPlayer: toId,
        interactionType: type,
        declineCount: record.declineCount
      });

      // Reset counter after penalty applied
      record.declineCount = 0;

      return true; // Harassment detected
    }

    return false;
  }

  /**
   * Apply reputation restrictions
   * @param {string} playerId - The player ID
   */
  function applyReputationRestrictions(playerId) {
    const rep = getReputation(playerId);

    // Low reputation consequences
    if (rep.score < 0) {
      rep.restrictions.tradeBanned = true;
    } else if (rep.score < 50) {
      // Restrictions lifted but monitored
      rep.restrictions.tradeBanned = false;
    }
  }

  /**
   * Check if player can perform action based on reputation
   * @param {string} playerId - The player ID
   * @param {string} action - Action type
   * @param {string} zone - Zone ID (optional)
   * @returns {Object} {allowed: boolean, reason?: string}
   */
  function checkReputationPermission(playerId, action, zone) {
    const rep = getReputation(playerId);

    if (action === 'trade' && rep.restrictions.tradeBanned) {
      return { allowed: false, reason: 'Trade restricted due to low reputation' };
    }

    if (zone && rep.restrictions.zoneMuted.has(zone) && (action === 'say' || action === 'shout')) {
      return { allowed: false, reason: 'You are muted in this zone' };
    }

    if (zone && rep.restrictions.zoneBanned.has(zone)) {
      return { allowed: false, reason: 'You are temporarily banned from this zone' };
    }

    // Check minimum tier for zone steward candidacy
    if (action === 'run_for_steward' && rep.tier !== 'Respected' && rep.tier !== 'Honored' && rep.tier !== 'Elder') {
      return { allowed: false, reason: 'Must be Respected tier or higher to run for zone steward' };
    }

    return { allowed: true };
  }

  /**
   * Mute player in zone
   * @param {string} playerId - The player ID
   * @param {string} zone - Zone ID
   * @param {number} duration - Duration in milliseconds (0 for permanent)
   */
  function muteInZone(playerId, zone, duration) {
    const rep = getReputation(playerId);
    rep.restrictions.zoneMuted.add(zone);

    if (duration > 0) {
      setTimeout(() => {
        rep.restrictions.zoneMuted.delete(zone);
      }, duration);
    }
  }

  /**
   * Ban player from zone
   * @param {string} playerId - The player ID
   * @param {string} zone - Zone ID
   * @param {number} duration - Duration in milliseconds
   */
  function banFromZone(playerId, zone, duration) {
    const rep = getReputation(playerId);
    rep.restrictions.zoneBanned.add(zone);

    setTimeout(() => {
      rep.restrictions.zoneBanned.delete(zone);
    }, duration);
  }

  // Export public API
  exports.handleSay = handleSay;
  exports.handleShout = handleShout;
  exports.handleWhisper = handleWhisper;
  exports.handleEmote = handleEmote;
  exports.grantConsent = grantConsent;
  exports.revokeConsent = revokeConsent;
  exports.hasConsent = hasConsent;
  exports.checkRateLimit = checkRateLimit;
  exports.getDistance = getDistance;
  exports.getNearbyPlayers = getNearbyPlayers;
  exports.addMessage = addMessage;
  exports.getRecentMessages = getRecentMessages;

  // Reputation API
  exports.initReputation = initReputation;
  exports.getReputation = getReputation;
  exports.adjustReputation = adjustReputation;
  exports.recordDecline = recordDecline;
  exports.checkReputationPermission = checkReputationPermission;
  exports.muteInZone = muteInZone;
  exports.banFromZone = banFromZone;
  exports.REPUTATION_TIERS = REPUTATION_TIERS;

})(typeof module !== 'undefined' ? module.exports : (window.Social = {}));


// creation.js
(function(exports) {

  // Plant species configuration
  const PLANT_SPECIES = {
    sunflower: {
      growthTime: 300000, // 5 min
      yields: [{type: 'sunflower', quantity: 3}]
    },
    oak_tree: {
      growthTime: 600000, // 10 min
      yields: [{type: 'wood', quantity: 5}]
    },
    wheat: {
      growthTime: 180000, // 3 min
      yields: [{type: 'wheat', quantity: 10}]
    },
    crystal_bloom: {
      growthTime: 900000, // 15 min
      yields: [{type: 'crystal', quantity: 1}]
    },
    herbs: {
      growthTime: 120000, // 2 min
      yields: [{type: 'herbs', quantity: 5}]
    }
  };

  // Crafting recipes
  const RECIPES = {
    wooden_bench: {
      materials: {wood: 3},
      produces: {type: 'wooden_bench', quantity: 1},
      complexity: 0.2
    },
    flower_crown: {
      materials: {sunflower: 2},
      produces: {type: 'flower_crown', quantity: 1},
      complexity: 0.1
    },
    crystal_lamp: {
      materials: {crystal: 1, wood: 1},
      produces: {type: 'crystal_lamp', quantity: 1},
      complexity: 0.5
    },
    bread: {
      materials: {wheat: 3, herbs: 1},
      produces: {type: 'bread', quantity: 2},
      complexity: 0.3
    },
    healing_tea: {
      materials: {herbs: 3},
      produces: {type: 'healing_tea', quantity: 1},
      complexity: 0.4
    }
  };

  // Structure types
  const STRUCTURE_TYPES = [
    'house', 'workshop', 'garden_shed', 'monument', 'bridge',
    'fountain', 'stage', 'market_stall', 'bench', 'lantern'
  ];

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Handle building structures
  function handleBuild(msg, state, zoneRules) {
    if (!zoneRules.building) {
      return {
        success: false,
        error: 'Building not allowed in this zone'
      };
    }

    const structureType = msg.payload.type;
    if (!STRUCTURE_TYPES.includes(structureType)) {
      return {
        success: false,
        error: 'Invalid structure type'
      };
    }

    const structure = {
      id: generateId(),
      type: structureType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      builder: msg.from,
      ts: Date.now()
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(structure);

    return {
      success: true,
      state: state,
      structure: structure
    };
  }

  // Handle planting
  function handlePlant(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Planting not allowed in this zone'
      };
    }

    const species = msg.payload.species;
    if (!PLANT_SPECIES[species]) {
      return {
        success: false,
        error: 'Invalid plant species'
      };
    }

    const speciesData = PLANT_SPECIES[species];
    const plantedAt = Date.now();
    const readyAt = plantedAt + speciesData.growthTime;

    const garden = {
      id: generateId(),
      species: species,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      planter: msg.from,
      plantedAt: plantedAt,
      growthStage: 0,
      readyAt: readyAt
    };

    if (!state.gardens) {
      state.gardens = [];
    }

    state.gardens.push(garden);

    return {
      success: true,
      state: state,
      garden: garden
    };
  }

  // Handle harvesting
  function handleHarvest(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Harvesting not allowed in this zone'
      };
    }

    if (!state.gardens || state.gardens.length === 0) {
      return {
        success: false,
        error: 'No gardens to harvest'
      };
    }

    const targetId = msg.payload.target;
    const gardenIndex = state.gardens.findIndex(g => g.id === targetId);

    if (gardenIndex === -1) {
      return {
        success: false,
        error: 'Garden not found'
      };
    }

    const garden = state.gardens[gardenIndex];
    const now = Date.now();

    // Check if growth is complete
    const isReady = now >= garden.readyAt || garden.growthStage >= 1.0;

    if (!isReady) {
      return {
        success: false,
        error: 'Plant is not ready to harvest yet'
      };
    }

    const speciesData = PLANT_SPECIES[garden.species];
    const items = speciesData.yields;

    // Remove garden from state
    state.gardens.splice(gardenIndex, 1);

    return {
      success: true,
      state: state,
      items: items
    };
  }

  // Handle crafting
  function handleCraft(msg, state) {
    const recipeName = msg.payload.recipe;

    if (!RECIPES[recipeName]) {
      return {
        success: false,
        error: 'Recipe not found'
      };
    }

    const recipe = RECIPES[recipeName];

    // Initialize player inventory if needed
    if (!state.players) {
      state.players = {};
    }
    if (!state.players[msg.from]) {
      state.players[msg.from] = {inventory: {}};
    }
    if (!state.players[msg.from].inventory) {
      state.players[msg.from].inventory = {};
    }

    const inventory = state.players[msg.from].inventory;

    // Check if player has required materials
    for (const [material, quantity] of Object.entries(recipe.materials)) {
      if (!inventory[material] || inventory[material] < quantity) {
        return {
          success: false,
          error: `Insufficient materials: need ${quantity} ${material}`
        };
      }
    }

    // Consume materials
    for (const [material, quantity] of Object.entries(recipe.materials)) {
      inventory[material] -= quantity;
      if (inventory[material] === 0) {
        delete inventory[material];
      }
    }

    // Produce item
    const producedItem = recipe.produces;
    if (!inventory[producedItem.type]) {
      inventory[producedItem.type] = 0;
    }
    inventory[producedItem.type] += producedItem.quantity;

    return {
      success: true,
      state: state,
      item: producedItem
    };
  }

  // Compose types configuration
  const COMPOSE_TYPES = {
    poem: { name: 'Poem', maxLength: 500, sparkReward: [5, 20] },
    poetry: { name: 'Poetry', maxLength: 500, sparkReward: [5, 20] },
    song: { name: 'Song', maxLength: 300, sparkReward: [10, 30] },
    story: { name: 'Short Story', maxLength: 1000, sparkReward: [10, 40] },
    painting: { name: 'Painting', sparkReward: [5, 25] },
    sculpture: { name: 'Sculpture', sparkReward: [10, 35] },
    mural: { name: 'Mural', sparkReward: [15, 50] }
  };

  // Handle artistic composition
  function handleCompose(msg, state) {
    const medium = msg.payload.medium || msg.payload.composeType || 'poem';
    const title = msg.payload.title || 'Untitled';
    const content = msg.payload.content || '';

    if (!COMPOSE_TYPES[medium]) {
      return {
        success: false,
        error: 'Invalid compose type'
      };
    }

    const typeData = COMPOSE_TYPES[medium];

    // Check max length for text-based types
    if (typeData.maxLength && content.length > typeData.maxLength) {
      return {
        success: false,
        error: 'Content exceeds maximum length of ' + typeData.maxLength + ' characters'
      };
    }

    const composition = {
      id: generateId(),
      creator: msg.from,
      type: 'composition',
      medium: medium,
      title: title,
      content: content,
      zone: msg.payload.zone || 'default',
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      ts: Date.now(),
      likes: 0,
      featured: false,
      likedBy: []
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(composition);

    // Calculate spark reward
    const sparkMin = typeData.sparkReward[0];
    const sparkMax = typeData.sparkReward[1];
    const sparkReward = Math.floor(sparkMin + Math.random() * (sparkMax - sparkMin));

    return {
      success: true,
      state: state,
      composition: composition,
      sparkReward: sparkReward
    };
  }

  // Like an artwork
  function likeArtwork(artworkId, playerId, state) {
    if (!state.artworks) {
      return { success: false, error: 'No artworks found' };
    }

    const artwork = state.artworks.find(function(a) { return a.id === artworkId; });
    if (!artwork) {
      return { success: false, error: 'Artwork not found' };
    }

    if (!artwork.likedBy) {
      artwork.likedBy = [];
    }

    // Check if already liked
    if (artwork.likedBy.indexOf(playerId) !== -1) {
      return { success: false, error: 'Already liked this artwork' };
    }

    artwork.likedBy.push(playerId);
    artwork.likes = artwork.likedBy.length;

    return {
      success: true,
      artwork: artwork,
      totalLikes: artwork.likes
    };
  }

  // Get artworks in a zone
  function getArtworks(state, zone) {
    if (!state.artworks) return [];

    return state.artworks.filter(function(a) {
      return !zone || a.zone === zone;
    });
  }

  // Get artworks by player
  function getArtworksByPlayer(state, playerId) {
    if (!state.artworks) return [];

    return state.artworks.filter(function(a) {
      return a.creator === playerId;
    });
  }

  // Feature an artwork (most liked in zone)
  function featureArtwork(artworkId, state) {
    if (!state.artworks) {
      return { success: false, error: 'No artworks found' };
    }

    const artwork = state.artworks.find(function(a) { return a.id === artworkId; });
    if (!artwork) {
      return { success: false, error: 'Artwork not found' };
    }

    // Unfeature all other artworks in the same zone
    state.artworks.forEach(function(a) {
      if (a.zone === artwork.zone && a.id !== artworkId) {
        a.featured = false;
      }
    });

    artwork.featured = true;

    return {
      success: true,
      artwork: artwork
    };
  }

  // ========================================================================
  // PLAYER HOUSING SYSTEM â€” Claim plots in Commons, place furniture
  // ========================================================================

  var PLOT_SIZE = 10; // 10x10 area
  var MAX_FURNITURE_PER_PLOT = 20;
  var HOUSING_ZONE = 'commons'; // Only Commons allows housing plots

  // Available plots in Commons zone (arranged in a grid)
  var PLOT_GRID = [];
  (function initPlotGrid() {
    // 5x4 grid of plots starting at Commons zone center offset
    var baseX = 140, baseZ = 170;
    for (var row = 0; row < 4; row++) {
      for (var col = 0; col < 5; col++) {
        PLOT_GRID.push({
          id: 'plot_' + row + '_' + col,
          x: baseX + col * (PLOT_SIZE + 4),
          z: baseZ + row * (PLOT_SIZE + 4),
          row: row,
          col: col
        });
      }
    }
  })();

  // Player plots: playerId -> { plotId, furniture[], name, claimedAt }
  var playerPlots = {};

  // Furniture types available for housing
  var FURNITURE_TYPES = {
    bed: { name: 'Bed', icon: '&#128716;', cost: 25, description: 'A cozy place to rest' },
    table: { name: 'Table', icon: '&#128207;', cost: 15, description: 'A sturdy wooden table' },
    chair: { name: 'Chair', icon: '&#129681;', cost: 10, description: 'A comfortable chair' },
    bookshelf: { name: 'Bookshelf', icon: '&#128218;', cost: 30, description: 'Stores your favorite books' },
    lamp: { name: 'Lamp', icon: '&#128161;', cost: 12, description: 'Warm ambient light' },
    rug: { name: 'Rug', icon: '&#129531;', cost: 18, description: 'A decorative rug' },
    plant_pot: { name: 'Potted Plant', icon: '&#127793;', cost: 8, description: 'A cheerful houseplant' },
    fireplace: { name: 'Fireplace', icon: '&#128293;', cost: 40, description: 'Warm and inviting' },
    painting: { name: 'Painting', icon: '&#128444;', cost: 20, description: 'Art for your walls' },
    chest: { name: 'Storage Chest', icon: '&#128230;', cost: 22, description: 'Store your treasures' },
    fountain_small: { name: 'Small Fountain', icon: '&#9970;', cost: 35, description: 'A soothing water feature' },
    banner: { name: 'Banner', icon: '&#127988;', cost: 15, description: 'Show your colors' }
  };

  /**
   * Get available plots (unclaimed)
   * @returns {Array} List of available plot positions
   */
  function getAvailablePlots() {
    var claimed = {};
    Object.keys(playerPlots).forEach(function(pid) {
      claimed[playerPlots[pid].plotId] = true;
    });
    return PLOT_GRID.filter(function(plot) {
      return !claimed[plot.id];
    });
  }

  /**
   * Claim a plot for a player
   * @param {string} playerId - Player claiming the plot
   * @param {string} plotId - Plot to claim
   * @param {string} plotName - Name for the plot (e.g., "Kody's Cottage")
   * @returns {Object} Result with success, error, or plot data
   */
  function claimPlot(playerId, plotId, plotName) {
    // Check if player already has a plot
    if (playerPlots[playerId]) {
      return { success: false, error: 'You already have a plot. Release it first.' };
    }
    // Check if plot exists and is unclaimed
    var plotDef = PLOT_GRID.find(function(p) { return p.id === plotId; });
    if (!plotDef) {
      return { success: false, error: 'Plot not found' };
    }
    var alreadyClaimed = Object.keys(playerPlots).some(function(pid) {
      return playerPlots[pid].plotId === plotId;
    });
    if (alreadyClaimed) {
      return { success: false, error: 'Plot already claimed by another player' };
    }

    playerPlots[playerId] = {
      plotId: plotId,
      name: plotName || playerId + "'s Plot",
      furniture: [],
      claimedAt: Date.now(),
      position: { x: plotDef.x, z: plotDef.z },
      size: PLOT_SIZE
    };
    return { success: true, plot: playerPlots[playerId] };
  }

  /**
   * Get a player's plot
   */
  function getPlayerPlot(playerId) {
    return playerPlots[playerId] || null;
  }

  /**
   * Place furniture on a player's plot
   */
  function placeFurniture(playerId, furnitureType, localX, localZ) {
    var plot = playerPlots[playerId];
    if (!plot) return { success: false, error: 'You don\'t have a plot' };
    if (!FURNITURE_TYPES[furnitureType]) return { success: false, error: 'Unknown furniture type' };
    if (plot.furniture.length >= MAX_FURNITURE_PER_PLOT) {
      return { success: false, error: 'Plot is full (max ' + MAX_FURNITURE_PER_PLOT + ' items)' };
    }
    // Clamp to plot bounds
    localX = Math.max(0, Math.min(PLOT_SIZE - 1, localX || 0));
    localZ = Math.max(0, Math.min(PLOT_SIZE - 1, localZ || 0));

    var item = {
      id: 'furn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4),
      type: furnitureType,
      localX: localX,
      localZ: localZ,
      placedAt: Date.now()
    };
    plot.furniture.push(item);
    return { success: true, item: item, cost: FURNITURE_TYPES[furnitureType].cost };
  }

  /**
   * Remove furniture from a player's plot
   */
  function removeFurniture(playerId, furnitureId) {
    var plot = playerPlots[playerId];
    if (!plot) return { success: false, error: 'You don\'t have a plot' };
    var idx = plot.furniture.findIndex(function(f) { return f.id === furnitureId; });
    if (idx === -1) return { success: false, error: 'Furniture not found' };
    plot.furniture.splice(idx, 1);
    return { success: true };
  }

  /**
   * Release a player's plot
   */
  function releasePlot(playerId) {
    if (!playerPlots[playerId]) return { success: false, error: 'You don\'t have a plot' };
    delete playerPlots[playerId];
    return { success: true };
  }

  /**
   * Get plot at world position (check if player is standing on a plot)
   */
  function getPlotAtPosition(worldX, worldZ) {
    for (var pid in playerPlots) {
      var plot = playerPlots[pid];
      if (worldX >= plot.position.x && worldX <= plot.position.x + PLOT_SIZE &&
          worldZ >= plot.position.z && worldZ <= plot.position.z + PLOT_SIZE) {
        return { playerId: pid, plot: plot };
      }
    }
    return null;
  }

  /**
   * Get all claimed plots (for minimap/world rendering)
   */
  function getAllPlots() {
    return playerPlots;
  }

  // Exports
  exports.PLANT_SPECIES = PLANT_SPECIES;
  exports.RECIPES = RECIPES;
  exports.STRUCTURE_TYPES = STRUCTURE_TYPES;
  exports.COMPOSE_TYPES = COMPOSE_TYPES;
  exports.handleBuild = handleBuild;
  exports.handlePlant = handlePlant;
  exports.handleHarvest = handleHarvest;
  exports.handleCraft = handleCraft;
  exports.handleCompose = handleCompose;
  exports.likeArtwork = likeArtwork;
  exports.getArtworks = getArtworks;
  exports.getArtworksByPlayer = getArtworksByPlayer;
  exports.featureArtwork = featureArtwork;
  exports.FURNITURE_TYPES = FURNITURE_TYPES;
  exports.PLOT_GRID = PLOT_GRID;
  exports.getAvailablePlots = getAvailablePlots;
  exports.claimPlot = claimPlot;
  exports.getPlayerPlot = getPlayerPlot;
  exports.placeFurniture = placeFurniture;
  exports.removeFurniture = removeFurniture;
  exports.releasePlot = releasePlot;
  exports.getPlotAtPosition = getPlotAtPosition;
  exports.getAllPlots = getAllPlots;

})(typeof module !== 'undefined' ? module.exports : (window.Creation = {}));


// quests.js
/**
 * ZION Quest/Mission System
 * Complete quest system for NPC interactions with progression tracking
 */

(function(exports) {
  'use strict';

  // Quest database - 25 quests across 8 zones
  const QUEST_DATABASE = {
    // === NEXUS QUESTS (2) ===
    quest_nexus_001: {
      id: 'quest_nexus_001',
      title: 'Welcome to ZION',
      description: 'Explore the Nexus and speak to 3 different citizens',
      giverNpcId: 'ai_citizen_001',
      type: 'social',
      objectives: [
        { type: 'talk_npcs', count: 3, current: 0 }
      ],
      rewards: { spark: 25, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Welcome, traveler! To truly understand ZION, you must connect with its people. Speak to three different citizens and learn their stories.",
        progress: "You've spoken with {current} citizens so far. Talk to {remaining} more.",
        complete: "Wonderful! You're beginning to understand what makes ZION special. Here's some Spark for your curiosity."
      },
      status: 'available'
    },

    quest_nexus_002: {
      id: 'quest_nexus_002',
      title: 'Journey Begins',
      description: 'Visit any 3 different zones in ZION',
      giverNpcId: 'ai_citizen_007',
      type: 'explore',
      objectives: [
        { type: 'visit_zones', zones: [], required: 3, current: 0 }
      ],
      rewards: { spark: 50, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: ['quest_nexus_001'],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "ZION is vast and full of wonders. Visit three different zones to broaden your horizons.",
        progress: "You've explored {current} zones. Discover {remaining} more!",
        complete: "Excellent exploration! Each zone has its own character. This Spark will fuel your continued journey."
      },
      status: 'available'
    },

    // === GARDENS QUESTS (5) ===
    quest_gardens_001: {
      id: 'quest_gardens_001',
      title: 'The Gardener\'s Request',
      description: 'Gather 3 sunflowers for Willow the Gardener',
      giverNpcId: 'ai_citizen_013',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'sunflower', count: 3, current: 0 }
      ],
      rewards: { spark: 30, items: [{ id: 'rare_seed', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Hello traveler! My garden needs sunflowers. Could you gather 3 for me? They grow near the pond.",
        progress: "Still looking for those sunflowers? You need {remaining} more.",
        complete: "Wonderful! These are beautiful. Here, take this rare seed as thanks."
      },
      status: 'available'
    },

    quest_gardens_002: {
      id: 'quest_gardens_002',
      title: 'Moonflower Cultivation',
      description: 'Help plant 5 moonflower seeds in the Gardens',
      giverNpcId: 'ai_citizen_019',
      type: 'craft',
      objectives: [
        { type: 'plant', item: 'moonflower_seed', count: 5, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Moonflowers bloom only at night and bring tranquility to the Gardens. Will you help me plant 5 seeds?",
        progress: "You've planted {current} moonflower seeds. {remaining} more to go!",
        complete: "Perfect! In time, these will create a beautiful nighttime display. Thank you."
      },
      status: 'available'
    },

    quest_gardens_003: {
      id: 'quest_gardens_003',
      title: 'Herbal Remedy',
      description: 'Collect 4 healing herbs from the Gardens',
      giverNpcId: 'ai_citizen_025',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'healing_herb', count: 4, current: 0 }
      ],
      rewards: { spark: 35, items: [{ id: 'health_potion', count: 2 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "I'm preparing remedies for the community. Could you gather 4 healing herbs? They have purple flowers.",
        progress: "You have {current} herbs. I need {remaining} more for the remedy.",
        complete: "Excellent! These will help many people. Take these health potions for your troubles."
      },
      status: 'available'
    },

    quest_gardens_004: {
      id: 'quest_gardens_004',
      title: 'The Secret Garden',
      description: 'Find the hidden meditation spot in the Gardens',
      giverNpcId: 'ai_citizen_031',
      type: 'explore',
      objectives: [
        { type: 'discover', location: 'gardens_secret_spot', current: 0 }
      ],
      rewards: { spark: 60, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Deep within the Gardens lies a secret meditation spot. Few have found it. Will you seek it out?",
        progress: "Keep searching. Listen for the sound of wind chimes...",
        complete: "You found it! That place holds special energy. May it bring you peace."
      },
      status: 'available'
    },

    quest_gardens_005: {
      id: 'quest_gardens_005',
      title: 'Water the Wilds',
      description: 'Deliver water from the Gardens fountain to a Wilds gardener',
      giverNpcId: 'ai_citizen_037',
      type: 'deliver',
      objectives: [
        { type: 'deliver', item: 'water_bucket', npcId: 'ai_citizen_043', current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Our friends in the Wilds need fresh water from our fountain. Can you deliver this bucket to them?",
        progress: "The water is still fresh. Find the gardener in the Wilds!",
        complete: "Thank you! This water will help their wild gardens flourish."
      },
      status: 'available'
    },

    // === WILDS QUESTS (4) ===
    quest_wilds_001: {
      id: 'quest_wilds_001',
      title: 'Wild Observations',
      description: 'Observe 5 different wildlife species in the Wilds',
      giverNpcId: 'ai_citizen_043',
      type: 'explore',
      objectives: [
        { type: 'observe', category: 'wildlife', count: 5, current: 0 }
      ],
      rewards: { spark: 50, items: [{ id: 'field_journal', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The Wilds are teeming with life! Observe 5 different species and document your findings.",
        progress: "You've observed {current} species. {remaining} more to discover!",
        complete: "Fascinating observations! Take this field journal to record your future discoveries."
      },
      status: 'available'
    },

    quest_wilds_002: {
      id: 'quest_wilds_002',
      title: 'Rare Resource Hunt',
      description: 'Find 2 pieces of rare amber in the Wilds',
      giverNpcId: 'ai_citizen_049',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'wild_amber', count: 2, current: 0 }
      ],
      rewards: { spark: 70, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Ancient amber can be found in the deepest parts of the Wilds. Bring me 2 pieces - they're invaluable!",
        progress: "Amber is rare. You have {current}, need {remaining} more.",
        complete: "Incredible! This amber is perfect. Your effort is greatly appreciated."
      },
      status: 'available'
    },

    quest_wilds_003: {
      id: 'quest_wilds_003',
      title: 'Trail Blazer',
      description: 'Mark 3 new trail markers in unexplored areas',
      giverNpcId: 'ai_citizen_055',
      type: 'explore',
      objectives: [
        { type: 'place_marker', count: 3, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Help expand our trail network! Place 3 markers in unexplored areas of the Wilds.",
        progress: "You've placed {current} markers. {remaining} more needed!",
        complete: "Excellent work! These trails will help many travelers."
      },
      status: 'available'
    },

    quest_wilds_004: {
      id: 'quest_wilds_004',
      title: 'Ecosystem Balance',
      description: 'Help maintain balance by planting 6 native seeds',
      giverNpcId: 'ai_citizen_061',
      type: 'craft',
      objectives: [
        { type: 'plant', item: 'native_seed', count: 6, current: 0 }
      ],
      rewards: { spark: 65, items: [{ id: 'nature_compass', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The Wilds ecosystem needs our care. Plant 6 native seeds to restore balance.",
        progress: "You've planted {current} seeds. The ecosystem needs {remaining} more.",
        complete: "Perfect! Nature thanks you. Take this compass - it attunes to natural energy."
      },
      status: 'available'
    },

    // === ATHENAEUM QUESTS (3) ===
    quest_athenaeum_001: {
      id: 'quest_athenaeum_001',
      title: 'Knowledge Seeker',
      description: 'Read 3 different scrolls in the Athenaeum',
      giverNpcId: 'ai_citizen_067',
      type: 'social',
      objectives: [
        { type: 'read', item: 'scroll', count: 3, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Knowledge is power. Read 3 different scrolls from our collection to expand your understanding.",
        progress: "You've read {current} scrolls. {remaining} more await your eyes.",
        complete: "Excellent! Knowledge shared is knowledge multiplied. Well done."
      },
      status: 'available'
    },

    quest_athenaeum_002: {
      id: 'quest_athenaeum_002',
      title: 'The Scholar\'s Circle',
      description: 'Speak with 4 scholars to gather ancient wisdom',
      giverNpcId: 'ai_citizen_073',
      type: 'social',
      objectives: [
        { type: 'talk_scholars', count: 4, current: 0 }
      ],
      rewards: { spark: 50, items: [{ id: 'wisdom_tome', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The scholars here each hold unique wisdom. Speak with 4 of them to broaden your perspective.",
        progress: "You've consulted {current} scholars. Seek out {remaining} more.",
        complete: "Wonderful! You've gathered great wisdom. This tome will serve you well."
      },
      status: 'available'
    },

    quest_athenaeum_003: {
      id: 'quest_athenaeum_003',
      title: 'Lost Manuscript',
      description: 'Find the lost manuscript hidden somewhere in the Athenaeum',
      giverNpcId: 'ai_citizen_079',
      type: 'explore',
      objectives: [
        { type: 'discover', location: 'athenaeum_manuscript', current: 0 }
      ],
      rewards: { spark: 80, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "A valuable manuscript was misplaced generations ago. Can you find it? Check between the oldest shelves.",
        progress: "The manuscript is still out there. Keep searching the archives...",
        complete: "You found it! This is priceless. Thank you for preserving our history."
      },
      status: 'available'
    },

    // === STUDIO QUESTS (3) ===
    quest_studio_001: {
      id: 'quest_studio_001',
      title: 'Artist\'s First Brush',
      description: 'Create your first artwork in the Studio',
      giverNpcId: 'ai_citizen_085',
      type: 'craft',
      objectives: [
        { type: 'create', item: 'artwork', count: 1, current: 0 }
      ],
      rewards: { spark: 35, items: [{ id: 'paint_set', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Everyone has creativity within them. Create your first artwork here in the Studio!",
        progress: "Let your imagination flow. Your first artwork awaits creation!",
        complete: "Beautiful! Art is a journey. This paint set will help you continue yours."
      },
      status: 'available'
    },

    quest_studio_002: {
      id: 'quest_studio_002',
      title: 'Musical Composition',
      description: 'Compose a piece of music with 3 instruments',
      giverNpcId: 'ai_citizen_091',
      type: 'craft',
      objectives: [
        { type: 'compose', instruments: 3, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Music speaks what words cannot. Compose a piece using at least 3 different instruments!",
        progress: "You've incorporated {current} instruments. Add {remaining} more!",
        complete: "Magnificent! Your music adds beauty to ZION. Keep composing!"
      },
      status: 'available'
    },

    quest_studio_003: {
      id: 'quest_studio_003',
      title: 'The Collaborative Mural',
      description: 'Contribute to the community mural with 5 brush strokes',
      giverNpcId: 'ai_citizen_097',
      type: 'craft',
      objectives: [
        { type: 'paint_mural', count: 5, current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The community mural represents all of us. Add your 5 brush strokes to become part of ZION's story!",
        progress: "You've added {current} strokes. {remaining} more will complete your contribution!",
        complete: "Perfect! Your marks are now part of our shared legacy. Thank you."
      },
      status: 'available'
    },

    // === AGORA QUESTS (3) ===
    quest_agora_001: {
      id: 'quest_agora_001',
      title: 'Market Day Delivery',
      description: 'Deliver goods to 3 different merchants in the Agora',
      giverNpcId: 'ai_citizen_003',
      type: 'deliver',
      objectives: [
        { type: 'deliver_merchants', count: 3, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Market day is busy! Can you deliver these packages to 3 different merchants for me?",
        progress: "You've delivered to {current} merchants. {remaining} more to go!",
        complete: "Wonderful! You've helped keep commerce flowing. Thank you!"
      },
      status: 'available'
    },

    quest_agora_002: {
      id: 'quest_agora_002',
      title: 'The Trading Game',
      description: 'Complete 2 successful trades with other players',
      giverNpcId: 'ai_citizen_009',
      type: 'social',
      objectives: [
        { type: 'trade', count: 2, current: 0 }
      ],
      rewards: { spark: 60, items: [{ id: 'merchant_badge', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Trade is the foundation of community. Complete 2 successful trades with others!",
        progress: "You've completed {current} trades. {remaining} more to go!",
        complete: "Excellent trading! Take this merchant badge as recognition of your skills."
      },
      status: 'available'
    },

    quest_agora_003: {
      id: 'quest_agora_003',
      title: 'Supply and Demand',
      description: 'Gather market data by speaking to 5 merchants',
      giverNpcId: 'ai_citizen_015',
      type: 'social',
      objectives: [
        { type: 'talk_merchants', count: 5, current: 0 }
      ],
      rewards: { spark: 50, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Help me understand the market! Speak with 5 merchants about their current needs.",
        progress: "You've surveyed {current} merchants. {remaining} more to survey!",
        complete: "Perfect data! This will help optimize our market. Thank you!"
      },
      status: 'available'
    },

    // === COMMONS QUESTS (3) ===
    quest_commons_001: {
      id: 'quest_commons_001',
      title: 'Community Building',
      description: 'Contribute 5 building materials to the Commons project',
      giverNpcId: 'ai_citizen_021',
      type: 'gather',
      objectives: [
        { type: 'contribute', item: 'building_material', count: 5, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "We're building something wonderful for everyone! Contribute 5 building materials to help!",
        progress: "You've contributed {current} materials. We need {remaining} more!",
        complete: "Thank you! Your contribution makes our community stronger!"
      },
      status: 'available'
    },

    quest_commons_002: {
      id: 'quest_commons_002',
      title: 'The Gathering',
      description: 'Attend a community gathering with at least 3 other players',
      giverNpcId: 'ai_citizen_027',
      type: 'social',
      objectives: [
        { type: 'attend_gathering', players: 3, current: 0 }
      ],
      rewards: { spark: 70, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Community is about togetherness. Join a gathering with at least 3 other people!",
        progress: "The gathering needs {remaining} more participants!",
        complete: "What a wonderful gathering! Community is our greatest strength."
      },
      status: 'available'
    },

    quest_commons_003: {
      id: 'quest_commons_003',
      title: 'Helping Hands',
      description: 'Help 4 different citizens with their daily tasks',
      giverNpcId: 'ai_citizen_033',
      type: 'social',
      objectives: [
        { type: 'help_citizens', count: 4, current: 0 }
      ],
      rewards: { spark: 65, items: [{ id: 'helper_ribbon', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Many people need assistance. Help 4 different citizens with their tasks!",
        progress: "You've helped {current} citizens. {remaining} more need your help!",
        complete: "You're a true helper! Wear this ribbon with pride."
      },
      status: 'available'
    },

    // === ARENA QUESTS (2) ===
    quest_arena_001: {
      id: 'quest_arena_001',
      title: 'Training Day',
      description: 'Complete 3 training exercises in the Arena',
      giverNpcId: 'ai_citizen_039',
      type: 'craft',
      objectives: [
        { type: 'train', count: 3, current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Physical and mental training keeps us sharp! Complete 3 training exercises!",
        progress: "You've completed {current} exercises. {remaining} more to go!",
        complete: "Well done! Regular training builds character and strength."
      },
      status: 'available'
    },

    quest_arena_002: {
      id: 'quest_arena_002',
      title: 'Champion\'s Path',
      description: 'Achieve a perfect score in an Arena challenge',
      giverNpcId: 'ai_citizen_045',
      type: 'craft',
      objectives: [
        { type: 'perfect_score', current: 0 }
      ],
      rewards: { spark: 100, items: [{ id: 'champion_medal', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: ['quest_arena_001'],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Only the dedicated achieve perfection. Score perfectly in an Arena challenge!",
        progress: "Perfection requires focus and practice. Keep training!",
        complete: "Incredible! You've achieved perfection. This medal marks your mastery."
      },
      status: 'available'
    }
  };

  // Player quest state storage
  const playerQuestStates = new Map(); // playerId -> { activeQuests: [], completedQuests: [], turnedInQuests: [] }
  const MAX_ACTIVE_QUESTS = 5;

  /**
   * Initialize quest system for a player
   * @param {string} playerId
   */
  function initPlayerQuests(playerId) {
    if (!playerQuestStates.has(playerId)) {
      playerQuestStates.set(playerId, {
        activeQuests: [],
        completedQuests: [],
        turnedInQuests: []
      });
    }
  }

  /**
   * Get all quests available to a player (based on level, prerequisites)
   * @param {string} playerId
   * @param {object} playerData - {level, position, etc.}
   * @returns {Array} Available quests
   */
  function getAvailableQuests(playerId, playerData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const available = [];
    for (const questId in QUEST_DATABASE) {
      const quest = QUEST_DATABASE[questId];

      // Skip if already active or turned in (unless repeatable)
      if (state.activeQuests.find(q => q.id === questId)) continue;
      if (!quest.repeatable && state.turnedInQuests.includes(questId)) continue;

      // Check level requirement
      if (quest.requiredLevel > (playerData.level || 0)) continue;

      // Check prerequisites
      let prereqsMet = true;
      for (const prereqId of quest.prerequisiteQuests) {
        if (!state.turnedInQuests.includes(prereqId)) {
          prereqsMet = false;
          break;
        }
      }
      if (!prereqsMet) continue;

      available.push(Object.assign({}, quest));
    }

    return available;
  }

  /**
   * Accept a quest
   * @param {string} playerId
   * @param {string} questId
   * @returns {object} {success: boolean, message: string, quest?: object}
   */
  function acceptQuest(playerId, questId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    // Check if quest exists
    if (!QUEST_DATABASE[questId]) {
      return { success: false, message: 'Quest not found' };
    }

    // Check if already active
    if (state.activeQuests.find(q => q.id === questId)) {
      return { success: false, message: 'Quest already active' };
    }

    // Check active quest limit
    if (state.activeQuests.length >= MAX_ACTIVE_QUESTS) {
      return { success: false, message: 'Too many active quests (max 5)' };
    }

    // Clone quest with fresh objectives
    const quest = JSON.parse(JSON.stringify(QUEST_DATABASE[questId]));
    quest.status = 'active';
    quest.startTime = Date.now();

    state.activeQuests.push(quest);

    return { success: true, message: 'Quest accepted', quest: quest };
  }

  /**
   * Update quest progress based on player action
   * @param {string} playerId
   * @param {string} eventType - 'collect', 'talk_npc', 'visit_zone', etc.
   * @param {object} eventData - Event-specific data
   * @returns {Array} Quests that were updated
   */
  function updateQuestProgress(playerId, eventType, eventData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);
    const updatedQuests = [];

    for (const quest of state.activeQuests) {
      let questUpdated = false;

      for (const objective of quest.objectives) {
        // Match event type to objective type
        let match = false;

        switch (objective.type) {
          case 'collect':
            match = eventType === 'collect' && eventData.item === objective.item;
            break;
          case 'talk_npcs':
          case 'talk_scholars':
          case 'talk_merchants':
            match = eventType === 'talk_npc';
            break;
          case 'visit_zones':
            match = eventType === 'visit_zone';
            if (match && !objective.zones.includes(eventData.zone)) {
              objective.zones.push(eventData.zone);
            }
            break;
          case 'deliver':
            match = eventType === 'deliver' && eventData.npcId === objective.npcId;
            break;
          case 'plant':
            match = eventType === 'plant' && eventData.item === objective.item;
            break;
          case 'create':
          case 'compose':
          case 'paint_mural':
          case 'train':
            match = eventType === objective.type;
            break;
          case 'trade':
            match = eventType === 'trade';
            break;
          case 'deliver_merchants':
            match = eventType === 'deliver_merchant';
            break;
          case 'contribute':
            match = eventType === 'contribute' && eventData.item === objective.item;
            break;
          case 'discover':
            match = eventType === 'discover' && eventData.location === objective.location;
            break;
          case 'observe':
            match = eventType === 'observe' && eventData.category === objective.category;
            break;
          case 'place_marker':
            match = eventType === 'place_marker';
            break;
          case 'read':
            match = eventType === 'read' && eventData.item === objective.item;
            break;
          case 'attend_gathering':
            match = eventType === 'attend_gathering';
            break;
          case 'help_citizens':
            match = eventType === 'help_citizen';
            break;
          case 'perfect_score':
            match = eventType === 'perfect_score';
            break;
        }

        if (match) {
          // Increment progress
          if (objective.type === 'visit_zones') {
            objective.current = objective.zones.length;
          } else {
            objective.current = Math.min(objective.current + (eventData.amount || 1), objective.count || 1);
          }
          questUpdated = true;
        }
      }

      // Check if quest is complete
      if (questUpdated) {
        const allComplete = quest.objectives.every(obj => {
          if (obj.required !== undefined) return obj.current >= obj.required;
          if (obj.count !== undefined) return obj.current >= obj.count;
          return obj.current >= 1;
        });

        if (allComplete) {
          quest.status = 'complete';
          state.completedQuests.push(quest.id);
        }

        updatedQuests.push(quest);
      }
    }

    return updatedQuests;
  }

  /**
   * Complete a quest and award rewards
   * @param {string} playerId
   * @param {string} questId
   * @param {object} gameState - Game state for awarding Spark
   * @returns {object} {success: boolean, rewards?: object}
   */
  function completeQuest(playerId, questId, gameState) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    // Find quest in active quests
    const questIndex = state.activeQuests.findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return { success: false, message: 'Quest not active' };
    }

    const quest = state.activeQuests[questIndex];

    // Check if complete
    if (quest.status !== 'complete') {
      return { success: false, message: 'Quest objectives not complete' };
    }

    // Award Spark via Economy module
    if (quest.rewards.spark > 0 && gameState && window.Economy) {
      window.Economy.earnSpark(gameState, playerId, quest.rewards.spark);
    }

    // Award items (inventory system would handle this - for now just return them)
    const rewards = {
      spark: quest.rewards.spark,
      items: quest.rewards.items
    };

    // Mark quest as turned in
    if (!state.turnedInQuests.includes(questId)) {
      state.turnedInQuests.push(questId);
    }

    // Remove from active quests
    state.activeQuests.splice(questIndex, 1);

    return { success: true, rewards: rewards, quest: quest };
  }

  /**
   * Get all active quests for a player
   * @param {string} playerId
   * @returns {Array} Active quests
   */
  function getActiveQuests(playerId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);
    return state.activeQuests.slice();
  }

  /**
   * Get quest log (all quests with status)
   * @param {string} playerId
   * @returns {object} {active: [], completed: [], available: []}
   */
  function getQuestLog(playerId, playerData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    return {
      active: state.activeQuests.slice(),
      completed: state.completedQuests.slice(),
      available: getAvailableQuests(playerId, playerData || {})
    };
  }

  /**
   * Get dialogue for a quest based on status
   * @param {string} questId
   * @param {string} status - 'offer', 'progress', 'complete'
   * @param {object} quest - Quest object (for progress interpolation)
   * @returns {string} Dialogue text
   */
  function getQuestDialogue(questId, status, quest) {
    const questTemplate = QUEST_DATABASE[questId];
    if (!questTemplate || !questTemplate.dialogue[status]) {
      return '';
    }

    let dialogue = questTemplate.dialogue[status];

    // Interpolate progress variables
    if (quest && status === 'progress') {
      const objective = quest.objectives[0]; // Use first objective for now
      if (objective) {
        const required = objective.required || objective.count || 1;
        const remaining = required - objective.current;
        dialogue = dialogue.replace('{current}', objective.current);
        dialogue = dialogue.replace('{remaining}', remaining);
      }
    }

    return dialogue;
  }

  /**
   * Get quests offered by a specific NPC
   * @param {string} npcId
   * @param {string} playerId
   * @returns {Array} Quests from this NPC
   */
  function getNpcQuests(npcId, playerId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const npcQuests = [];

    for (const questId in QUEST_DATABASE) {
      const quest = QUEST_DATABASE[questId];
      if (quest.giverNpcId !== npcId) continue;

      // Check if active
      const activeQuest = state.activeQuests.find(q => q.id === questId);
      if (activeQuest) {
        npcQuests.push({ quest: activeQuest, state: activeQuest.status });
        continue;
      }

      // Check if available
      if (!quest.repeatable && state.turnedInQuests.includes(questId)) {
        continue; // Already completed, not repeatable
      }

      // Check prerequisites
      let available = true;
      for (const prereqId of quest.prerequisiteQuests) {
        if (!state.turnedInQuests.includes(prereqId)) {
          available = false;
          break;
        }
      }

      if (available) {
        npcQuests.push({ quest: Object.assign({}, quest), state: 'available' });
      }
    }

    return npcQuests;
  }

  /**
   * Abandon a quest
   * @param {string} playerId
   * @param {string} questId
   * @returns {object} {success: boolean}
   */
  function abandonQuest(playerId, questId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const questIndex = state.activeQuests.findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return { success: false, message: 'Quest not active' };
    }

    state.activeQuests.splice(questIndex, 1);
    return { success: true };
  }

  // ========================================================================
  // DAILY QUEST SYSTEM â€” Rotating quests that refresh daily
  // ========================================================================

  var DAILY_QUESTS = [
    {
      id: 'daily_social',
      title: 'Social Butterfly',
      description: 'Talk to 5 different NPCs today',
      objectives: [{ type: 'talk_npcs', count: 5, current: 0 }],
      rewards: { spark: 20, items: [] },
      dialogue: {
        offer: "Today's challenge: connect with 5 different citizens. Every conversation enriches ZION.",
        progress: "You've chatted with {current} NPCs. {remaining} more to go!",
        complete: "What a social day! Here's your daily Spark reward."
      }
    },
    {
      id: 'daily_explorer',
      title: 'Daily Explorer',
      description: 'Visit 4 different zones today',
      objectives: [{ type: 'visit_zones', zones: [], required: 4, current: 0 }],
      rewards: { spark: 25, items: [] },
      dialogue: {
        offer: "Stretch your legs! Visit 4 different zones to earn your daily exploration reward.",
        progress: "You've visited {current} zones. {remaining} more await!",
        complete: "A well-traveled day! The world rewards your curiosity."
      }
    },
    {
      id: 'daily_gatherer',
      title: 'Daily Harvest',
      description: 'Harvest 5 resources today',
      objectives: [{ type: 'collect', item: 'resource', count: 5, current: 0 }],
      rewards: { spark: 15, items: [] },
      dialogue: {
        offer: "The gardens are abundant today. Harvest 5 resources to earn your daily reward.",
        progress: "Harvested {current} of 5 resources.",
        complete: "A productive day! Nature provides for those who tend it."
      }
    },
    {
      id: 'daily_trader',
      title: 'Market Day',
      description: 'Complete 1 trade with another player',
      objectives: [{ type: 'trade', count: 1, current: 0 }],
      rewards: { spark: 30, items: [] },
      dialogue: {
        offer: "The Agora thrives on trade. Complete one trade today to keep the economy flowing.",
        progress: "You haven't traded yet today. Find a partner!",
        complete: "A fair trade benefits everyone. Well done, merchant!"
      }
    },
    {
      id: 'daily_crafter',
      title: 'Creative Day',
      description: 'Craft 2 items today',
      objectives: [{ type: 'craft', count: 2, current: 0 }],
      rewards: { spark: 20, items: [] },
      dialogue: {
        offer: "Creation is at the heart of ZION. Craft 2 items today to earn your reward.",
        progress: "Crafted {current} of 2 items.",
        complete: "Your hands have shaped the world today. Well crafted!"
      }
    },
    {
      id: 'daily_builder',
      title: 'Construction Day',
      description: 'Place 2 structures today',
      objectives: [{ type: 'build', count: 2, current: 0 }],
      rewards: { spark: 25, items: [] },
      dialogue: {
        offer: "The Commons could use some new structures. Place 2 buildings today.",
        progress: "Placed {current} of 2 structures.",
        complete: "Your buildings will stand as testament to today's work!"
      }
    },
    {
      id: 'daily_wanderer',
      title: 'Long Walk',
      description: 'Walk a total of 500 units today',
      objectives: [{ type: 'walk_distance', distance: 500, current: 0 }],
      rewards: { spark: 15, items: [] },
      dialogue: {
        offer: "Sometimes the journey matters more than the destination. Walk 500 units today.",
        progress: "You've walked {current} of 500 units.",
        complete: "Every step is a story. Well walked!"
      }
    }
  ];

  function getDailyQuests() {
    // Use the day of year to rotate which 3 dailies are available
    var now = new Date();
    var dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
    var dailies = [];
    for (var i = 0; i < 3; i++) {
      var idx = (dayOfYear + i) % DAILY_QUESTS.length;
      var daily = JSON.parse(JSON.stringify(DAILY_QUESTS[idx]));
      daily.id = 'daily_' + dayOfYear + '_' + i;
      daily.type = 'daily';
      daily.repeatable = false;
      daily.requiredLevel = 0;
      daily.prerequisiteQuests = [];
      daily.timeLimit = 0;
      daily.giverNpcId = 'ai_citizen_001'; // Default quest giver
      daily.status = 'available';
      dailies.push(daily);
    }
    return dailies;
  }

  function isDailyCompleted(playerId, dailyId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    return state.turnedInQuests.indexOf(dailyId) !== -1;
  }

  // ========================================================================
  // QUEST CHAINS â€” Multi-part story quests
  // ========================================================================

  var QUEST_CHAINS = {
    'chain_origins': {
      name: 'Origins of ZION',
      description: 'Discover the history of how ZION came to be',
      quests: ['quest_nexus_001', 'quest_nexus_002'],
      reward: { spark: 100, title: 'Historian' }
    },
    'chain_garden_master': {
      name: 'Garden Master',
      description: 'Complete all garden quests to earn the title of Garden Master',
      quests: ['quest_gardens_001', 'quest_gardens_002', 'quest_gardens_003', 'quest_gardens_004', 'quest_gardens_005'],
      reward: { spark: 150, title: 'Garden Master' }
    },
    'chain_scholar': {
      name: 'Scholar of the Athenaeum',
      description: 'Complete all knowledge quests',
      quests: ['quest_athenaeum_001', 'quest_athenaeum_002', 'quest_athenaeum_003'],
      reward: { spark: 120, title: 'Scholar' }
    },
    'chain_artisan': {
      name: 'Master Artisan',
      description: 'Complete all studio crafting quests',
      quests: ['quest_studio_001', 'quest_studio_002'],
      reward: { spark: 100, title: 'Artisan' }
    },
    'chain_explorer': {
      name: 'True Explorer',
      description: 'Visit every zone and complete all exploration quests',
      quests: ['quest_nexus_002', 'quest_wilds_001', 'quest_wilds_002', 'quest_wilds_003'],
      reward: { spark: 200, title: 'True Explorer' }
    }
  };

  function getChainProgress(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    var progress = {};

    for (var chainId in QUEST_CHAINS) {
      var chain = QUEST_CHAINS[chainId];
      var completed = 0;
      for (var i = 0; i < chain.quests.length; i++) {
        if (state.turnedInQuests.indexOf(chain.quests[i]) !== -1) {
          completed++;
        }
      }
      progress[chainId] = {
        name: chain.name,
        description: chain.description,
        completed: completed,
        total: chain.quests.length,
        isComplete: completed >= chain.quests.length,
        reward: chain.reward
      };
    }

    return progress;
  }

  function checkChainCompletion(playerId) {
    var progress = getChainProgress(playerId);
    var newlyCompleted = [];

    for (var chainId in progress) {
      var chain = progress[chainId];
      if (chain.isComplete) {
        initPlayerQuests(playerId);
        var state = playerQuestStates.get(playerId);
        if (!state.completedChains) state.completedChains = [];
        if (state.completedChains.indexOf(chainId) === -1) {
          state.completedChains.push(chainId);
          newlyCompleted.push({
            chainId: chainId,
            name: chain.name,
            reward: chain.reward
          });
        }
      }
    }

    return newlyCompleted;
  }

  // ========================================================================
  // PLAYER STATS from quests
  // ========================================================================

  function getPlayerQuestStats(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);

    return {
      activeQuests: state.activeQuests.length,
      completedQuests: state.turnedInQuests.length,
      totalAvailable: Object.keys(QUEST_DATABASE).length,
      completedChains: (state.completedChains || []).length,
      totalChains: Object.keys(QUEST_CHAINS).length,
      titles: (state.completedChains || []).map(function(chainId) {
        return QUEST_CHAINS[chainId] ? QUEST_CHAINS[chainId].reward.title : null;
      }).filter(Boolean)
    };
  }

  // ========================================================================
  // ACHIEVEMENT / BADGE SYSTEM
  // ========================================================================

  var ACHIEVEMENTS = {
    // Exploration
    first_steps: { id: 'first_steps', name: 'First Steps', description: 'Enter ZION for the first time', icon: 'ðŸ‘£', category: 'exploration', sparkReward: 10 },
    zone_hopper: { id: 'zone_hopper', name: 'Zone Hopper', description: 'Visit 4 different zones', icon: 'ðŸš¶', category: 'exploration', sparkReward: 25 },
    world_traveler: { id: 'world_traveler', name: 'World Traveler', description: 'Visit all 8 zones', icon: 'ðŸŒ', category: 'exploration', sparkReward: 75 },
    trailblazer: { id: 'trailblazer', name: 'Trailblazer', description: 'Make 10 discoveries', icon: 'ðŸ”', category: 'exploration', sparkReward: 50 },
    cartographer: { id: 'cartographer', name: 'Cartographer', description: 'Make 25 discoveries', icon: 'ðŸ—ºï¸', category: 'exploration', sparkReward: 100 },

    // Social
    friendly_face: { id: 'friendly_face', name: 'Friendly Face', description: 'Talk to 10 NPCs', icon: 'ðŸ˜Š', category: 'social', sparkReward: 15 },
    social_butterfly: { id: 'social_butterfly', name: 'Social Butterfly', description: 'Talk to 50 NPCs', icon: 'ðŸ¦‹', category: 'social', sparkReward: 40 },
    first_trade: { id: 'first_trade', name: 'First Trade', description: 'Complete your first trade', icon: 'ðŸ¤', category: 'social', sparkReward: 20 },
    merchant_prince: { id: 'merchant_prince', name: 'Merchant Prince', description: 'Complete 25 trades', icon: 'ðŸ‘‘', category: 'social', sparkReward: 75 },
    gift_giver: { id: 'gift_giver', name: 'Gift Giver', description: 'Gift an item to another player', icon: 'ðŸŽ', category: 'social', sparkReward: 15 },

    // Crafting
    first_craft: { id: 'first_craft', name: 'First Craft', description: 'Craft your first item', icon: 'ðŸ”¨', category: 'crafting', sparkReward: 10 },
    apprentice_crafter: { id: 'apprentice_crafter', name: 'Apprentice Crafter', description: 'Craft 10 items', icon: 'âš’ï¸', category: 'crafting', sparkReward: 30 },
    master_crafter: { id: 'master_crafter', name: 'Master Crafter', description: 'Craft 50 items', icon: 'ðŸ› ï¸', category: 'crafting', sparkReward: 80 },
    potion_brewer: { id: 'potion_brewer', name: 'Potion Brewer', description: 'Brew 10 potions', icon: 'ðŸ§ª', category: 'crafting', sparkReward: 25 },
    instrument_maker: { id: 'instrument_maker', name: 'Instrument Maker', description: 'Craft a musical instrument', icon: 'ðŸŽµ', category: 'crafting', sparkReward: 20 },

    // Building
    first_build: { id: 'first_build', name: 'First Build', description: 'Place your first structure', icon: 'ðŸ—ï¸', category: 'building', sparkReward: 10 },
    architect: { id: 'architect', name: 'Architect', description: 'Place 10 structures', icon: 'ðŸ›ï¸', category: 'building', sparkReward: 40 },
    city_planner: { id: 'city_planner', name: 'City Planner', description: 'Place 50 structures', icon: 'ðŸ™ï¸', category: 'building', sparkReward: 100 },

    // Gardening
    green_thumb: { id: 'green_thumb', name: 'Green Thumb', description: 'Plant your first seed', icon: 'ðŸŒ±', category: 'gardening', sparkReward: 10 },
    gardener: { id: 'gardener', name: 'Gardener', description: 'Harvest 20 plants', icon: 'ðŸŒ»', category: 'gardening', sparkReward: 30 },
    botanist: { id: 'botanist', name: 'Botanist', description: 'Harvest 100 plants', icon: 'ðŸŒ¿', category: 'gardening', sparkReward: 80 },

    // Economy
    spark_saver: { id: 'spark_saver', name: 'Spark Saver', description: 'Accumulate 100 Spark', icon: 'âœ¨', category: 'economy', sparkReward: 10 },
    spark_hoarder: { id: 'spark_hoarder', name: 'Spark Hoarder', description: 'Accumulate 500 Spark', icon: 'ðŸ’°', category: 'economy', sparkReward: 25 },
    spark_magnate: { id: 'spark_magnate', name: 'Spark Magnate', description: 'Accumulate 2000 Spark', icon: 'ðŸ’Ž', category: 'economy', sparkReward: 75 },

    // Competition
    first_challenge: { id: 'first_challenge', name: 'First Challenge', description: 'Participate in your first competition', icon: 'âš”ï¸', category: 'competition', sparkReward: 15 },
    champion: { id: 'champion', name: 'Champion', description: 'Win 5 competitions', icon: 'ðŸ†', category: 'competition', sparkReward: 50 },

    // Quests
    quest_starter: { id: 'quest_starter', name: 'Quest Starter', description: 'Accept your first quest', icon: 'ðŸ“‹', category: 'quests', sparkReward: 5 },
    questmaster: { id: 'questmaster', name: 'Questmaster', description: 'Complete 10 quests', icon: 'ðŸ“œ', category: 'quests', sparkReward: 40 },
    completionist: { id: 'completionist', name: 'Completionist', description: 'Complete 25 quests', icon: 'â­', category: 'quests', sparkReward: 100 },
    chain_finisher: { id: 'chain_finisher', name: 'Chain Finisher', description: 'Complete a quest chain', icon: 'ðŸ”—', category: 'quests', sparkReward: 30 },

    // Guild
    guild_founder: { id: 'guild_founder', name: 'Guild Founder', description: 'Create a guild', icon: 'ðŸ°', category: 'guild', sparkReward: 25 },
    guild_member: { id: 'guild_member', name: 'Guild Member', description: 'Join a guild', icon: 'ðŸ¤œ', category: 'guild', sparkReward: 10 },

    // Art
    first_artwork: { id: 'first_artwork', name: 'First Artwork', description: 'Create your first artwork', icon: 'ðŸŽ¨', category: 'art', sparkReward: 15 },
    prolific_artist: { id: 'prolific_artist', name: 'Prolific Artist', description: 'Create 10 artworks', icon: 'ðŸ–¼ï¸', category: 'art', sparkReward: 40 },

    // Physical
    sunwalker: { id: 'sunwalker', name: 'Sunwalker', description: 'Reach Sunwalker warmth tier', icon: 'â˜€ï¸', category: 'physical', sparkReward: 50 },

    // Mentoring
    first_lesson: { id: 'first_lesson', name: 'First Lesson', description: 'Complete a mentoring lesson', icon: 'ðŸ“š', category: 'mentoring', sparkReward: 15 },
    wise_mentor: { id: 'wise_mentor', name: 'Wise Mentor', description: 'Mentor 5 players', icon: 'ðŸŽ“', category: 'mentoring', sparkReward: 50 }
  };

  // Player achievement tracking
  var playerAchievements = new Map(); // playerId -> { unlocked: Set, counters: {} }

  function initPlayerAchievements(playerId) {
    if (!playerAchievements.has(playerId)) {
      playerAchievements.set(playerId, {
        unlocked: new Set(),
        counters: {
          npcs_talked: 0,
          zones_visited: new Set(),
          trades_completed: 0,
          items_crafted: 0,
          potions_brewed: 0,
          structures_placed: 0,
          plants_harvested: 0,
          seeds_planted: 0,
          discoveries_made: 0,
          competitions_entered: 0,
          competitions_won: 0,
          quests_completed: 0,
          artworks_created: 0,
          players_mentored: 0,
          lessons_completed: 0,
          gifts_given: 0
        }
      });
    }
    return playerAchievements.get(playerId);
  }

  /**
   * Track an event and check for newly unlocked achievements
   * @param {string} playerId
   * @param {string} eventType - e.g. 'craft', 'trade', 'visit_zone', 'talk_npc'
   * @param {Object} eventData - event-specific data
   * @returns {Array} Newly unlocked achievements
   */
  function trackAchievementEvent(playerId, eventType, eventData) {
    var state = initPlayerAchievements(playerId);
    eventData = eventData || {};

    // Update counters based on event
    switch (eventType) {
      case 'login':
        break; // first_steps checked separately
      case 'talk_npc':
        state.counters.npcs_talked++;
        break;
      case 'visit_zone':
        if (eventData.zone) state.counters.zones_visited.add(eventData.zone);
        break;
      case 'trade':
        state.counters.trades_completed++;
        break;
      case 'craft':
        state.counters.items_crafted++;
        if (eventData.category === 'potion') state.counters.potions_brewed++;
        break;
      case 'build':
        state.counters.structures_placed++;
        break;
      case 'harvest':
        state.counters.plants_harvested++;
        break;
      case 'plant':
        state.counters.seeds_planted++;
        break;
      case 'discover':
        state.counters.discoveries_made++;
        break;
      case 'competition_enter':
        state.counters.competitions_entered++;
        break;
      case 'competition_win':
        state.counters.competitions_won++;
        break;
      case 'quest_complete':
        state.counters.quests_completed++;
        break;
      case 'artwork':
        state.counters.artworks_created++;
        break;
      case 'mentor':
        state.counters.players_mentored++;
        break;
      case 'lesson':
        state.counters.lessons_completed++;
        break;
      case 'gift':
        state.counters.gifts_given++;
        break;
    }

    // Check all achievements
    var newlyUnlocked = [];
    var checks = {
      first_steps: eventType === 'login',
      zone_hopper: state.counters.zones_visited.size >= 4,
      world_traveler: state.counters.zones_visited.size >= 8,
      trailblazer: state.counters.discoveries_made >= 10,
      cartographer: state.counters.discoveries_made >= 25,
      friendly_face: state.counters.npcs_talked >= 10,
      social_butterfly: state.counters.npcs_talked >= 50,
      first_trade: state.counters.trades_completed >= 1,
      merchant_prince: state.counters.trades_completed >= 25,
      gift_giver: state.counters.gifts_given >= 1,
      first_craft: state.counters.items_crafted >= 1,
      apprentice_crafter: state.counters.items_crafted >= 10,
      master_crafter: state.counters.items_crafted >= 50,
      potion_brewer: state.counters.potions_brewed >= 10,
      instrument_maker: eventType === 'craft' && eventData.category === 'instrument',
      first_build: state.counters.structures_placed >= 1,
      architect: state.counters.structures_placed >= 10,
      city_planner: state.counters.structures_placed >= 50,
      green_thumb: state.counters.seeds_planted >= 1,
      gardener: state.counters.plants_harvested >= 20,
      botanist: state.counters.plants_harvested >= 100,
      spark_saver: eventData.spark >= 100,
      spark_hoarder: eventData.spark >= 500,
      spark_magnate: eventData.spark >= 2000,
      first_challenge: state.counters.competitions_entered >= 1,
      champion: state.counters.competitions_won >= 5,
      quest_starter: state.counters.quests_completed >= 0 && eventType === 'quest_accept',
      questmaster: state.counters.quests_completed >= 10,
      completionist: state.counters.quests_completed >= 25,
      chain_finisher: eventType === 'chain_complete',
      guild_founder: eventType === 'guild_create',
      guild_member: eventType === 'guild_join',
      first_artwork: state.counters.artworks_created >= 1,
      prolific_artist: state.counters.artworks_created >= 10,
      sunwalker: eventType === 'warmth_tier' && eventData.tier === 'Sunwalker',
      first_lesson: state.counters.lessons_completed >= 1,
      wise_mentor: state.counters.players_mentored >= 5
    };

    for (var achId in checks) {
      if (checks[achId] && !state.unlocked.has(achId) && ACHIEVEMENTS[achId]) {
        state.unlocked.add(achId);
        newlyUnlocked.push(ACHIEVEMENTS[achId]);
      }
    }

    return newlyUnlocked;
  }

  /**
   * Get all achievements with unlock status
   * @param {string} playerId
   * @returns {Array} All achievements with unlocked status
   */
  function getAchievements(playerId) {
    var state = initPlayerAchievements(playerId);
    var result = [];

    for (var achId in ACHIEVEMENTS) {
      var ach = ACHIEVEMENTS[achId];
      result.push({
        id: ach.id,
        name: ach.name,
        description: ach.description,
        icon: ach.icon,
        category: ach.category,
        sparkReward: ach.sparkReward,
        unlocked: state.unlocked.has(achId)
      });
    }

    return result;
  }

  /**
   * Get achievement progress summary
   * @param {string} playerId
   * @returns {Object} {unlocked, total, percentage, recentUnlocks}
   */
  function getAchievementProgress(playerId) {
    var state = initPlayerAchievements(playerId);
    var total = Object.keys(ACHIEVEMENTS).length;
    var unlocked = state.unlocked.size;

    return {
      unlocked: unlocked,
      total: total,
      percentage: total > 0 ? Math.round((unlocked / total) * 100) : 0,
      counters: {
        npcs_talked: state.counters.npcs_talked,
        zones_visited: state.counters.zones_visited.size,
        trades_completed: state.counters.trades_completed,
        items_crafted: state.counters.items_crafted,
        structures_placed: state.counters.structures_placed,
        quests_completed: state.counters.quests_completed,
        discoveries_made: state.counters.discoveries_made
      }
    };
  }

  function getCompletedQuests(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    return state ? state.turnedInQuests : [];
  }

  // Export public API
  exports.getCompletedQuests = getCompletedQuests;
  exports.getAvailableQuests = getAvailableQuests;
  exports.acceptQuest = acceptQuest;
  exports.updateQuestProgress = updateQuestProgress;
  exports.completeQuest = completeQuest;
  exports.getActiveQuests = getActiveQuests;
  exports.getQuestLog = getQuestLog;
  exports.getQuestDialogue = getQuestDialogue;
  exports.getNpcQuests = getNpcQuests;
  exports.abandonQuest = abandonQuest;
  exports.initPlayerQuests = initPlayerQuests;
  exports.getDailyQuests = getDailyQuests;
  exports.isDailyCompleted = isDailyCompleted;
  exports.getChainProgress = getChainProgress;
  exports.checkChainCompletion = checkChainCompletion;
  exports.getPlayerQuestStats = getPlayerQuestStats;
  exports.QUEST_CHAINS = QUEST_CHAINS;
  exports.DAILY_QUESTS = DAILY_QUESTS;
  exports.ACHIEVEMENTS = ACHIEVEMENTS;
  exports.trackAchievementEvent = trackAchievementEvent;
  exports.getAchievements = getAchievements;
  exports.getAchievementProgress = getAchievementProgress;
  exports.initPlayerAchievements = initPlayerAchievements;

})(typeof module !== 'undefined' ? module.exports : (window.Quests = {}));


// competition.js
(function(exports) {

  // Competition types
  const COMPETITION_TYPES = ['duel', 'race', 'puzzle_race', 'build_contest', 'music_battle'];

  // Pending challenges store
  const pendingChallenges = {};

  // Spark awards by competition type
  const SPARK_AWARDS = {
    duel: 50,
    race: 30,
    puzzle_race: 40,
    build_contest: 100,
    music_battle: 60
  };

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Handle challenge creation
  function handleChallenge(msg, state, zoneRules) {
    if (!zoneRules.competition || !zoneRules.pvp) {
      return {
        success: false,
        error: 'Competition not allowed in this zone'
      };
    }

    const challengeType = msg.payload.type;
    if (!COMPETITION_TYPES.includes(challengeType)) {
      return {
        success: false,
        error: 'Invalid competition type'
      };
    }

    const challengeId = generateId();
    const challenge = {
      id: challengeId,
      challenger: msg.from,
      challenged: msg.payload.to,
      type: challengeType,
      rules: msg.payload.rules || {},
      ts: Date.now()
    };

    pendingChallenges[challengeId] = challenge;

    return {
      success: true,
      pendingChallenge: challenge
    };
  }

  // Handle challenge acceptance
  function handleAcceptChallenge(msg, state) {
    const playerId = msg.from;

    // Find pending challenge targeting this player
    let foundChallenge = null;
    let challengeId = null;

    for (const [id, challenge] of Object.entries(pendingChallenges)) {
      if (challenge.challenged === playerId) {
        foundChallenge = challenge;
        challengeId = id;
        break;
      }
    }

    if (!foundChallenge) {
      return {
        success: false,
        error: 'No pending challenge found'
      };
    }

    // Create active competition
    const competition = {
      id: generateId(),
      players: [foundChallenge.challenger, foundChallenge.challenged],
      type: foundChallenge.type,
      rules: foundChallenge.rules,
      startedAt: Date.now(),
      scores: {},
      status: 'active'
    };

    // Initialize state.competitions if needed
    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(competition);

    // Remove from pending challenges
    delete pendingChallenges[challengeId];

    return {
      success: true,
      competition: competition,
      state: state
    };
  }

  // Handle forfeit
  function handleForfeit(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;

    // Find active competition involving this player
    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    // Determine winner (the other player)
    const winner = competition.players.find(p => p !== playerId);

    // Update competition status
    competition.status = 'completed';
    competition.winner = winner;
    competition.endedAt = Date.now();
    competition.forfeitedBy = playerId;

    // Calculate Spark award
    const sparkAward = SPARK_AWARDS[competition.type] || 20;

    return {
      success: true,
      state: state,
      winner: winner,
      sparkAward: sparkAward,
      competition: competition
    };
  }

  // Handle score submission
  function handleScore(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;
    const score = msg.payload.score;

    // Find active competition involving this player
    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    // Record score
    competition.scores[playerId] = score;

    // Check if both players have scored
    const allScored = competition.players.every(p =>
      competition.scores.hasOwnProperty(p)
    );

    let sparkAward = null;
    let winner = null;

    if (allScored) {
      // Determine winner (highest score)
      const scores = competition.players.map(p => ({
        player: p,
        score: competition.scores[p]
      }));

      scores.sort((a, b) => b.score - a.score);
      winner = scores[0].player;

      // Update competition status
      competition.status = 'completed';
      competition.winner = winner;
      competition.endedAt = Date.now();

      // Calculate Spark award
      sparkAward = SPARK_AWARDS[competition.type] || 20;
    }

    return {
      success: true,
      state: state,
      competition: competition,
      winner: winner,
      sparkAward: sparkAward
    };
  }

  // Get pending challenges for a player
  function getPendingChallenges(playerId) {
    return Object.values(pendingChallenges).filter(c =>
      c.challenged === playerId || c.challenger === playerId
    );
  }

  // Spectator tracking
  var spectators = {}; // competitionId â†’ [playerIds]

  // Join as spectator
  function joinAsSpectator(competitionId, playerId, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return { success: false, error: 'No competitions found' };
    }

    var competition = state.competitions.find(function(c) {
      return c.id === competitionId;
    });

    if (!competition) {
      return { success: false, error: 'Competition not found' };
    }

    if (competition.status !== 'active') {
      return { success: false, error: 'Competition is not active' };
    }

    if (!spectators[competitionId]) {
      spectators[competitionId] = [];
    }

    if (spectators[competitionId].indexOf(playerId) === -1) {
      spectators[competitionId].push(playerId);
    }

    return { success: true, competition: competition };
  }

  // Leave spectator
  function leaveSpectator(competitionId, playerId) {
    if (!spectators[competitionId]) return;

    var index = spectators[competitionId].indexOf(playerId);
    if (index !== -1) {
      spectators[competitionId].splice(index, 1);
    }

    // Clean up empty spectator lists
    if (spectators[competitionId].length === 0) {
      delete spectators[competitionId];
    }
  }

  // Get spectators
  function getSpectators(competitionId) {
    return spectators[competitionId] || [];
  }

  // Get active competitions
  function getActiveCompetitions(state) {
    if (!state.competitions || state.competitions.length === 0) {
      return [];
    }

    return state.competitions
      .filter(function(c) { return c.status === 'active'; })
      .map(function(c) {
        return {
          id: c.id,
          type: c.type,
          players: c.players,
          startedAt: c.startedAt,
          spectatorCount: spectators[c.id] ? spectators[c.id].length : 0
        };
      });
  }

  // Broadcast to spectators
  function broadcastToSpectators(competitionId, eventType, data) {
    var spectatorList = spectators[competitionId] || [];

    return {
      type: 'spectator_event',
      competitionId: competitionId,
      eventType: eventType,
      data: data,
      spectators: spectatorList,
      timestamp: Date.now()
    };
  }

  // Get competition leaderboard
  function getCompetitionLeaderboard(state) {
    if (!state.competitions || state.competitions.length === 0) {
      return [];
    }

    var playerStats = {};

    state.competitions
      .filter(function(c) { return c.status === 'completed'; })
      .forEach(function(comp) {
        comp.players.forEach(function(playerId) {
          if (!playerStats[playerId]) {
            playerStats[playerId] = { playerId: playerId, wins: 0, losses: 0, total: 0 };
          }

          if (comp.winner === playerId) {
            playerStats[playerId].wins++;
          } else {
            playerStats[playerId].losses++;
          }
          playerStats[playerId].total++;
        });
      });

    return Object.values(playerStats).sort(function(a, b) {
      return b.wins - a.wins;
    });
  }

  // Race Competition Type
  function createRace(organizerId, checkpoints, zone, state) {
    var raceId = generateId();
    var race = {
      id: raceId,
      type: 'race',
      organizer: organizerId,
      checkpoints: checkpoints,
      zone: zone,
      participants: [],
      progress: {}, // playerId â†’ { checkpointIndex, time }
      status: 'waiting',
      createdAt: Date.now()
    };

    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(race);

    return {
      success: true,
      race: race,
      state: state
    };
  }

  // Check race progress
  function checkRaceProgress(competitionId, playerId, position) {
    // This function would be called in the game loop to check if player reached a checkpoint
    // Returns updated progress information

    return {
      checkpointHit: false,
      finished: false,
      currentCheckpoint: 0,
      time: 0
    };
  }

  // Get race standings
  function getRaceStandings(competitionId, state) {
    if (!state.competitions) {
      return [];
    }

    var race = state.competitions.find(function(c) {
      return c.id === competitionId && c.type === 'race';
    });

    if (!race || !race.progress) {
      return [];
    }

    var standings = Object.keys(race.progress).map(function(playerId) {
      var progress = race.progress[playerId];
      return {
        playerId: playerId,
        checkpointIndex: progress.checkpointIndex || 0,
        time: progress.time || 0,
        finished: progress.finished || false
      };
    });

    // Sort by checkpoint progress (descending) then by time (ascending)
    standings.sort(function(a, b) {
      if (a.finished && !b.finished) return -1;
      if (!a.finished && b.finished) return 1;
      if (a.checkpointIndex !== b.checkpointIndex) {
        return b.checkpointIndex - a.checkpointIndex;
      }
      return a.time - b.time;
    });

    return standings;
  }

  // Exports
  exports.COMPETITION_TYPES = COMPETITION_TYPES;
  exports.SPARK_AWARDS = SPARK_AWARDS;
  exports.handleChallenge = handleChallenge;
  exports.handleAcceptChallenge = handleAcceptChallenge;
  exports.handleForfeit = handleForfeit;
  exports.handleScore = handleScore;
  exports.getPendingChallenges = getPendingChallenges;
  exports.joinAsSpectator = joinAsSpectator;
  exports.leaveSpectator = leaveSpectator;
  exports.getSpectators = getSpectators;
  exports.getActiveCompetitions = getActiveCompetitions;
  exports.broadcastToSpectators = broadcastToSpectators;
  exports.getCompetitionLeaderboard = getCompetitionLeaderboard;
  exports.createRace = createRace;
  exports.checkRaceProgress = checkRaceProgress;
  exports.getRaceStandings = getRaceStandings;

})(typeof module !== 'undefined' ? module.exports : (window.Competition = {}));


// exploration.js
(function(exports) {

  // Discovery types
  const DISCOVERY_TYPES = [
    'location', 'creature', 'artifact', 'secret',
    'landmark', 'ruin', 'cave', 'spring'
  ];

  // Base rarity by discovery type
  const BASE_RARITY = {
    location: 0.3,
    creature: 0.5,
    artifact: 0.7,
    secret: 0.9,
    landmark: 0.2,
    ruin: 0.6,
    cave: 0.4,
    spring: 0.5
  };

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Calculate distance between two 3D positions
  function calculateDistance(pos1, pos2) {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    const dz = pos1.z - pos2.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  // Check if discovery is duplicate
  function isDuplicate(playerId, position, state) {
    if (!state.discoveries || state.discoveries.length === 0) {
      return false;
    }

    // Check if player has already discovered within distance 5
    for (const discovery of state.discoveries) {
      if (discovery.discoverer === playerId) {
        const distance = calculateDistance(position, discovery.position);
        if (distance <= 5) {
          return true;
        }
      }
    }

    return false;
  }

  // Calculate rarity for a discovery type
  function calculateRarity(type) {
    if (BASE_RARITY.hasOwnProperty(type)) {
      return BASE_RARITY[type];
    }
    // Default rarity
    return 0.3;
  }

  // Handle discovery
  function handleDiscover(msg, state) {
    const position = msg.payload.position || {x: 0, y: 0, z: 0};
    const playerId = msg.from;

    // Check for duplicate
    if (isDuplicate(playerId, position, state)) {
      return {
        success: false,
        error: 'Already discovered'
      };
    }

    const discoveryType = msg.payload.type || 'location';
    if (!DISCOVERY_TYPES.includes(discoveryType)) {
      return {
        success: false,
        error: 'Invalid discovery type'
      };
    }

    // Determine rarity
    let rarity = msg.payload.rarity;
    if (typeof rarity !== 'number' || rarity < 0 || rarity > 1) {
      rarity = calculateRarity(discoveryType);
    }

    // Calculate Spark award
    const sparkAwarded = 5 + Math.floor(rarity * 20);

    const discovery = {
      id: generateId(),
      discoverer: playerId,
      type: discoveryType,
      description: msg.payload.description || '',
      position: position,
      zone: msg.payload.zone || 'default',
      ts: Date.now(),
      rarity: rarity
    };

    // Initialize state.discoveries if needed
    if (!state.discoveries) {
      state.discoveries = [];
    }

    state.discoveries.push(discovery);

    return {
      success: true,
      state: state,
      discovery: discovery,
      sparkAwarded: sparkAwarded
    };
  }

  // Handle inspection
  function handleInspect(msg, state) {
    const targetId = msg.payload.target;

    if (!targetId) {
      return {
        success: false,
        error: 'No target specified'
      };
    }

    let info = null;
    let entityType = null;

    // Search in players
    if (state.players && state.players[targetId]) {
      info = {
        type: 'player',
        id: targetId,
        data: state.players[targetId]
      };
      entityType = 'player';
    }

    // Search in structures
    if (!info && state.structures && state.structures.length > 0) {
      const structure = state.structures.find(s => s.id === targetId);
      if (structure) {
        info = {
          type: 'structure',
          id: targetId,
          data: structure
        };
        entityType = 'structure';
      }
    }

    // Search in gardens
    if (!info && state.gardens && state.gardens.length > 0) {
      const garden = state.gardens.find(g => g.id === targetId);
      if (garden) {
        const now = Date.now();
        const elapsed = now - garden.plantedAt;
        const totalGrowthTime = garden.readyAt - garden.plantedAt;
        const currentGrowthStage = Math.min(1.0, elapsed / totalGrowthTime);

        info = {
          type: 'garden',
          id: targetId,
          data: {
            ...garden,
            currentGrowthStage: currentGrowthStage,
            isReady: now >= garden.readyAt
          }
        };
        entityType = 'garden';
      }
    }

    // Search in discoveries
    if (!info && state.discoveries && state.discoveries.length > 0) {
      const discovery = state.discoveries.find(d => d.id === targetId);
      if (discovery) {
        info = {
          type: 'discovery',
          id: targetId,
          data: discovery
        };
        entityType = 'discovery';
      }
    }

    if (!info) {
      return {
        success: false,
        error: 'Target not found'
      };
    }

    return {
      success: true,
      info: info
    };
  }

  // Get all discoveries for a player
  function getDiscoveries(playerId, state) {
    if (!state || !state.discoveries) {
      return [];
    }

    return state.discoveries.filter(function(d) {
      return d.discoverer === playerId;
    }).map(function(d) {
      // Map rarity number to rarity name
      var rarityName = 'common';
      if (d.rarity >= 0.9) rarityName = 'legendary';
      else if (d.rarity >= 0.7) rarityName = 'epic';
      else if (d.rarity >= 0.5) rarityName = 'rare';
      else if (d.rarity >= 0.3) rarityName = 'uncommon';

      return {
        name: d.type.charAt(0).toUpperCase() + d.type.slice(1),
        description: d.description,
        zone: d.zone,
        rarity: rarityName,
        timestamp: d.ts
      };
    });
  }

  // Get discovered zones for a player
  function getDiscoveredZones(playerId, state) {
    if (!state || !state.discoveries) {
      return ['default'];
    }

    var zones = {};
    state.discoveries.forEach(function(d) {
      if (d.discoverer === playerId) {
        zones[d.zone] = true;
      }
    });

    return Object.keys(zones);
  }

  // ========================================================================
  // ZONE SECRETS â€” Hidden discoverable locations in each zone
  // ========================================================================

  var ZONE_SECRETS = {
    nexus: [
      { id: 'nexus_heart', name: 'Heart of the Nexus', type: 'secret', description: 'A pulsing crystal embedded in the ground at the world\'s center, humming with energy from all connected zones.', position: { x: 0, y: 0.5, z: 0 }, rarity: 0.8, loreId: 'lore_nexus_heart' },
      { id: 'nexus_echo', name: 'Echo Stone', type: 'artifact', description: 'A smooth stone that whispers the names of every player who has ever visited ZION.', position: { x: 15, y: 1, z: -10 }, rarity: 0.6, loreId: 'lore_echo_stone' },
      { id: 'nexus_sundial', name: 'Eternal Sundial', type: 'landmark', description: 'An ancient sundial that tracks not just time but the phases of ZION\'s day-night cycle.', position: { x: -8, y: 0, z: 12 }, rarity: 0.4, loreId: 'lore_sundial' }
    ],
    gardens: [
      { id: 'gardens_moonwell', name: 'Moonwell', type: 'spring', description: 'A hidden pool that glows silver at night, said to accelerate plant growth nearby.', position: { x: -20, y: 0, z: -25 }, rarity: 0.7, loreId: 'lore_moonwell' },
      { id: 'gardens_ancient_tree', name: 'The First Tree', type: 'landmark', description: 'The oldest tree in ZION, its trunk carved with symbols from the founding.', position: { x: 30, y: 0, z: 10 }, rarity: 0.5, loreId: 'lore_first_tree' },
      { id: 'gardens_fairy_ring', name: 'Fairy Ring', type: 'secret', description: 'A perfect circle of mushrooms that appears only at certain times.', position: { x: -5, y: 0, z: 35 }, rarity: 0.9, loreId: 'lore_fairy_ring' },
      { id: 'gardens_meditation', name: 'Meditation Hollow', type: 'location', description: 'A sheltered hollow where the ambient sounds of nature converge in perfect harmony.', position: { x: 18, y: -1, z: -30 }, rarity: 0.6, loreId: 'lore_meditation' }
    ],
    athenaeum: [
      { id: 'athenaeum_codex', name: 'The Lost Codex', type: 'artifact', description: 'A floating book whose pages contain knowledge from all federated worlds.', position: { x: -12, y: 3, z: -15 }, rarity: 0.9, loreId: 'lore_codex' },
      { id: 'athenaeum_orrery', name: 'Celestial Orrery', type: 'artifact', description: 'A mechanical model of the multiverse, with a tiny light for each federated world.', position: { x: 5, y: 2, z: 20 }, rarity: 0.8, loreId: 'lore_orrery' },
      { id: 'athenaeum_whispering', name: 'Whispering Stacks', type: 'secret', description: 'Deep in the shelves, the books murmur to each other, sharing fragments of lore.', position: { x: -25, y: 0, z: 8 }, rarity: 0.7, loreId: 'lore_whispering' }
    ],
    studio: [
      { id: 'studio_muse', name: 'The Muse\'s Corner', type: 'secret', description: 'A corner where inspiration strikes harder. Art created here always seems to resonate more.', position: { x: 10, y: 0, z: -18 }, rarity: 0.7, loreId: 'lore_muse' },
      { id: 'studio_palette', name: 'Living Palette', type: 'artifact', description: 'A palette whose colors shift with the seasons, mixing hues no artisan has seen before.', position: { x: -15, y: 1, z: 12 }, rarity: 0.8, loreId: 'lore_palette' },
      { id: 'studio_resonance', name: 'Resonance Chamber', type: 'cave', description: 'A natural acoustic chamber where even whispers become music.', position: { x: 22, y: -2, z: -5 }, rarity: 0.6, loreId: 'lore_resonance' }
    ],
    wilds: [
      { id: 'wilds_hollow', name: 'Starfall Hollow', type: 'cave', description: 'A cavern where fragments of starlight collect in luminous pools.', position: { x: -30, y: -3, z: -20 }, rarity: 0.9, loreId: 'lore_starfall' },
      { id: 'wilds_monolith', name: 'The Monolith', type: 'ruin', description: 'A towering black stone that predates ZION itself, covered in undecipherable glyphs.', position: { x: 35, y: 0, z: 25 }, rarity: 0.8, loreId: 'lore_monolith' },
      { id: 'wilds_grove', name: 'Singing Grove', type: 'location', description: 'Trees here sway in patterns that create hauntingly beautiful melodies.', position: { x: -10, y: 0, z: 30 }, rarity: 0.5, loreId: 'lore_singing_grove' },
      { id: 'wilds_fossil', name: 'Fossil Cliff', type: 'landmark', description: 'A cliff face embedded with fossils from creatures that never existed in our world.', position: { x: 20, y: 5, z: -35 }, rarity: 0.6, loreId: 'lore_fossil_cliff' },
      { id: 'wilds_spring', name: 'Hidden Hot Spring', type: 'spring', description: 'A natural hot spring tucked behind a waterfall, warm even in winter.', position: { x: -25, y: -1, z: -10 }, rarity: 0.7, loreId: 'lore_hot_spring' }
    ],
    agora: [
      { id: 'agora_vault', name: 'The Old Vault', type: 'ruin', description: 'Beneath the market, the remains of ZION\'s first bank, its vault door still ajar.', position: { x: 8, y: -2, z: -12 }, rarity: 0.7, loreId: 'lore_vault' },
      { id: 'agora_scales', name: 'Scales of Truth', type: 'artifact', description: 'Ancient merchant scales that glow when a fair trade is struck nearby.', position: { x: -10, y: 1, z: 5 }, rarity: 0.6, loreId: 'lore_scales' }
    ],
    commons: [
      { id: 'commons_bell', name: 'Community Bell', type: 'landmark', description: 'A large bell that was rung to call the first citizens of ZION together.', position: { x: 0, y: 3, z: 0 }, rarity: 0.4, loreId: 'lore_bell' },
      { id: 'commons_mosaic', name: 'Founders\' Mosaic', type: 'artifact', description: 'A floor mosaic depicting the founding of ZION, with space for new tiles from each generation.', position: { x: -15, y: 0, z: 15 }, rarity: 0.6, loreId: 'lore_mosaic' },
      { id: 'commons_time_capsule', name: 'Time Capsule', type: 'secret', description: 'Buried beneath the gathering circle, a capsule left by the founders with messages for the future.', position: { x: 5, y: -1, z: -8 }, rarity: 0.8, loreId: 'lore_time_capsule' }
    ],
    arena: [
      { id: 'arena_champions', name: 'Hall of Champions', type: 'ruin', description: 'Carved into the arena wall, the names and deeds of every champion who competed here.', position: { x: 20, y: 2, z: 0 }, rarity: 0.5, loreId: 'lore_champions' },
      { id: 'arena_flame', name: 'Eternal Flame', type: 'landmark', description: 'A flame that has burned since the arena was built, said to embody the spirit of competition.', position: { x: 0, y: 1, z: -20 }, rarity: 0.6, loreId: 'lore_flame' }
    ]
  };

  // ========================================================================
  // LORE ENTRIES â€” Deep world-building text
  // ========================================================================

  var LORE_ENTRIES = {
    lore_nexus_heart: {
      title: 'The Heart of ZION',
      text: 'Long before the first player set foot in ZION, the Heart was placed here â€” a crystal forged from the combined intentions of its creators. It pulses once for every soul currently inhabiting the world. Old-timers say that on quiet nights, you can feel it sync with your own heartbeat, as if the world itself is alive and breathing alongside you.',
      category: 'origins'
    },
    lore_echo_stone: {
      title: 'The Echo Stone',
      text: 'The Echo Stone remembers. Every name spoken near it is captured and preserved in its crystalline lattice. Some say if you press your ear to its surface and whisper a name, you can hear a faint echo of that person\'s first words in ZION. The stone grows infinitesimally larger with each new voice it records.',
      category: 'artifacts'
    },
    lore_sundial: {
      title: 'The Eternal Sundial',
      text: 'The Sundial was the first structure built in the Nexus, before even the portals were erected. It tracks the 24-minute day cycle and marks the seasons that shift each real-world week. At dawn, its shadow points toward the Gardens. At dusk, toward the Wilds. At the rare eclipse, it casts no shadow at all.',
      category: 'landmarks'
    },
    lore_moonwell: {
      title: 'The Moonwell',
      text: 'Hidden in the deepest grove of the Gardens lies the Moonwell, a pool of water that seems to capture and hold moonlight even after dawn. Gardeners discovered that plants watered from the Moonwell grow twice as fast, though they suspect this is less about the water and more about the attention the gardener pays in finding it.',
      category: 'nature'
    },
    lore_first_tree: {
      title: 'The First Tree',
      text: 'Before the Gardens were cultivated, before the zones were named, there was a single tree. The First Tree grew from a seed of intention planted by ZION\'s architects. Its roots extend beneath every zone, connecting the world in ways no map can show. The symbols carved in its trunk are the original protocol â€” the language that all of ZION\'s systems speak.',
      category: 'origins'
    },
    lore_fairy_ring: {
      title: 'The Fairy Ring',
      text: 'The Fairy Ring appears and disappears according to rules no scholar has fully deciphered. Some say it follows the moon cycle, others claim it responds to the emotional state of the world itself. Those who find it report a fleeting sense of profound connection to every other being in ZION â€” as if, for one moment, the boundaries between self and world dissolve.',
      category: 'mysteries'
    },
    lore_meditation: {
      title: 'The Meditation Hollow',
      text: 'In the Meditation Hollow, the sounds of nature converge in unexpected harmony â€” birdsong becomes melody, wind becomes rhythm, water becomes bass. Those who sit here long enough report achieving a rare clarity of purpose. It\'s said this was the spot where the intention system was first imagined.',
      category: 'nature'
    },
    lore_codex: {
      title: 'The Lost Codex',
      text: 'The Codex floats between shelves, never resting in one place. Its pages are blank to most, but to those who have visited federated worlds, text appears: knowledge from those distant lands. The more worlds you visit, the more pages reveal themselves. Scholars believe the Codex is less a book and more a living bridge between realities.',
      category: 'artifacts'
    },
    lore_orrery: {
      title: 'The Celestial Orrery',
      text: 'Built by the first scholars of the Athenaeum, the Orrery maps every federated world as a tiny point of light orbiting a central sun â€” ZION itself. New lights appear when new federations are forged, and they dim when connections grow quiet. It serves as both art and practical tool, allowing citizens to see the health of the multiverse at a glance.',
      category: 'artifacts'
    },
    lore_whispering: {
      title: 'The Whispering Stacks',
      text: 'Deep in the Athenaeum, where the oldest books reside, the air is thick with whispers. The books share knowledge among themselves when no one is looking, cross-referencing and updating their contents. Scholars who linger here too long report dreams filled with information they never consciously learned.',
      category: 'mysteries'
    },
    lore_muse: {
      title: 'The Muse\'s Corner',
      text: 'Every studio has its sweet spot, the place where creativity flows most freely. In ZION\'s Studio, that spot is marked by a slight warmth in the floor and a tendency for ambient sounds to harmonize. Artists who create here often surprise themselves with the results. Is it magic, or simply the power of expectation? The Muse keeps her secrets.',
      category: 'art'
    },
    lore_palette: {
      title: 'The Living Palette',
      text: 'The Palette was not crafted but grown â€” crystallized from the combined creative energy of ZION\'s first artists. Its colors are alive: they deepen in autumn, brighten in spring, glow warmly in winter, and shimmer like water in summer. Art created with its pigments is said to evoke emotions in viewers that no ordinary color can.',
      category: 'artifacts'
    },
    lore_resonance: {
      title: 'The Resonance Chamber',
      text: 'Beneath the Studio lies a natural cavern with perfect acoustics. Sound enters and emerges transformed â€” whispers become symphonies, footsteps become percussion, breath becomes wind instruments. Musicians gather here to compose pieces that could never exist in the above-ground world. The Chamber doesn\'t amplify sound; it reveals its hidden depth.',
      category: 'nature'
    },
    lore_starfall: {
      title: 'Starfall Hollow',
      text: 'When the procedural stars of ZION\'s sky occasionally flicker and fall, their light doesn\'t vanish â€” it collects in pools deep within Starfall Hollow. The luminous pools cast impossible shadows that move independently of light sources. Explorers have reported seeing brief visions of other worlds reflected in the starlight pools.',
      category: 'mysteries'
    },
    lore_monolith: {
      title: 'The Monolith',
      text: 'The Monolith stands as a reminder that not everything in ZION was placed there by its creators. It appeared one day, unannounced, and no log records its creation. Its glyphs resist translation â€” they seem to shift when observed directly. Some theorize it\'s a message from a parallel ZION, a fork that found a way to communicate across the multiverse gap.',
      category: 'mysteries'
    },
    lore_singing_grove: {
      title: 'The Singing Grove',
      text: 'The trees of the Singing Grove have grown in a pattern that channels wind into music. Each season brings a different key, and the melody changes with the weather. During storms, the grove produces sounds that can only be described as the world singing itself to sleep. Wildlife gathers here during these concerts, unbothered by the presence of visitors.',
      category: 'nature'
    },
    lore_fossil_cliff: {
      title: 'The Fossil Cliff',
      text: 'The fossils in this cliff belong to creatures that exist in no biological record. Wings with too many segments, shells that spiral in mathematically impossible patterns, teeth that seem designed for eating light itself. Scholars debate whether these are remnants of an earlier version of ZION, or dreams that somehow calcified into stone.',
      category: 'mysteries'
    },
    lore_hot_spring: {
      title: 'The Hidden Hot Spring',
      text: 'Tucked behind a waterfall that reveals itself only to those who approach from the right angle, the Hot Spring maintains a perfect temperature regardless of season. Its waters carry a faint mineral glow. Visitors leave feeling restored, though whether this is the water\'s doing or simply the peace of discovering a hidden place is debated.',
      category: 'nature'
    },
    lore_vault: {
      title: 'The Old Vault',
      text: 'Beneath the bustling Agora lies the Old Vault â€” ZION\'s first attempt at a central bank, abandoned when the community chose a distributed ledger instead. The vault door is still ajar, revealing a room lined with empty shelves. A plaque on the wall reads: "The true wealth of ZION cannot be stored in a single place."',
      category: 'history'
    },
    lore_scales: {
      title: 'The Scales of Truth',
      text: 'The Scales were a gift from the merchants of early ZION, imbued with a simple enchantment: they glow golden when a fair trade is completed nearby. In a world where the protocol enforces honest transactions, the Scales serve more as a celebration than a safeguard. Their gentle light is a reminder that fairness feels good.',
      category: 'artifacts'
    },
    lore_bell: {
      title: 'The Community Bell',
      text: 'The Bell was rung to gather the first hundred citizens of ZION â€” the founding AI agents who would give the world its initial life. It rang once for each of them, one hundred clear notes that still echo in the architecture of the Commons. Now it rings for every community event, its tone slightly different each time, as if greeting each gathering uniquely.',
      category: 'history'
    },
    lore_mosaic: {
      title: 'The Founders\' Mosaic',
      text: 'The mosaic in the Commons floor tells the story of ZION\'s founding in tiny colored tiles. At the center, a burst of golden Spark radiating outward. Around it, the eight zones taking shape from formless possibility. At the edges, blank space â€” room for new tiles that each generation of citizens adds. Finding your own tile is a rite of passage.',
      category: 'history'
    },
    lore_time_capsule: {
      title: 'The Time Capsule',
      text: 'Buried beneath the gathering circle is a capsule containing the original vision documents for ZION â€” the hopes and principles its creators encoded before the first line of code was written. The capsule is sealed but not locked; anyone can open it. Inside, alongside the documents, is a simple note: "Build kindly."',
      category: 'origins'
    },
    lore_champions: {
      title: 'The Hall of Champions',
      text: 'The Arena wall bears the names of all who have competed with honor. Not just winners â€” every participant who showed sportsmanship, creativity, or grace under pressure. The Hall reminds visitors that competition in ZION is not about domination but about pushing each other to grow. Below the names runs a single line: "The only defeat is refusing to play."',
      category: 'history'
    },
    lore_flame: {
      title: 'The Eternal Flame',
      text: 'The Eternal Flame burns without fuel, its light neither hot nor cold but somehow both warming and invigorating. It was lit at the Arena\'s inauguration and has never gone out. Competitors who pass the flame before a challenge report feeling calmer and more focused, as if the flame absorbs anxiety and returns resolve.',
      category: 'landmarks'
    }
  };

  /**
   * Get zone secrets (discoverable hidden locations)
   * @param {string} zoneId
   * @returns {Array} Secrets for the zone
   */
  function getZoneSecrets(zoneId) {
    return ZONE_SECRETS[zoneId] || [];
  }

  /**
   * Check if player is near a secret and hasn't discovered it yet
   * @param {string} playerId
   * @param {Object} position - Player position {x, y, z}
   * @param {string} zoneId
   * @param {Object} state
   * @returns {Object|null} Secret found or null
   */
  function checkNearbySecrets(playerId, position, zoneId, state) {
    var secrets = ZONE_SECRETS[zoneId];
    if (!secrets) return null;

    for (var i = 0; i < secrets.length; i++) {
      var secret = secrets[i];
      var dist = calculateDistance(position, secret.position);

      // Within 8 units
      if (dist <= 8) {
        // Check if already discovered
        var alreadyFound = false;
        if (state.discoveries) {
          for (var j = 0; j < state.discoveries.length; j++) {
            if (state.discoveries[j].discoverer === playerId && state.discoveries[j].secretId === secret.id) {
              alreadyFound = true;
              break;
            }
          }
        }

        if (!alreadyFound) {
          return secret;
        }
      }
    }

    return null;
  }

  /**
   * Discover a zone secret
   * @param {string} playerId
   * @param {Object} secret - Secret from ZONE_SECRETS
   * @param {Object} state
   * @returns {Object} Discovery result
   */
  function discoverSecret(playerId, secret, state) {
    if (!state.discoveries) state.discoveries = [];

    var sparkAwarded = 5 + Math.floor(secret.rarity * 30); // Higher rewards for secrets

    var discovery = {
      id: generateId(),
      secretId: secret.id,
      discoverer: playerId,
      type: secret.type,
      name: secret.name,
      description: secret.description,
      position: secret.position,
      zone: secret.position.zone || 'unknown',
      ts: Date.now(),
      rarity: secret.rarity,
      loreId: secret.loreId
    };

    state.discoveries.push(discovery);

    return {
      success: true,
      discovery: discovery,
      sparkAwarded: sparkAwarded,
      lore: secret.loreId ? LORE_ENTRIES[secret.loreId] : null
    };
  }

  /**
   * Get a lore entry by ID
   * @param {string} loreId
   * @returns {Object|null} Lore entry
   */
  function getLoreEntry(loreId) {
    return LORE_ENTRIES[loreId] || null;
  }

  /**
   * Get all lore entries unlocked by a player
   * @param {string} playerId
   * @param {Object} state
   * @returns {Array} Unlocked lore entries
   */
  function getUnlockedLore(playerId, state) {
    if (!state.discoveries) return [];

    var loreIds = new Set();
    state.discoveries.forEach(function(d) {
      if (d.discoverer === playerId && d.loreId) {
        loreIds.add(d.loreId);
      }
    });

    var result = [];
    loreIds.forEach(function(loreId) {
      var entry = LORE_ENTRIES[loreId];
      if (entry) {
        result.push({
          id: loreId,
          title: entry.title,
          text: entry.text,
          category: entry.category
        });
      }
    });

    return result;
  }

  /**
   * Get all lore categories and counts
   * @returns {Object} {category: totalCount}
   */
  function getLoreCategories() {
    var cats = {};
    for (var loreId in LORE_ENTRIES) {
      var cat = LORE_ENTRIES[loreId].category;
      cats[cat] = (cats[cat] || 0) + 1;
    }
    return cats;
  }

  // Exports
  exports.DISCOVERY_TYPES = DISCOVERY_TYPES;
  exports.BASE_RARITY = BASE_RARITY;
  exports.handleDiscover = handleDiscover;
  exports.handleInspect = handleInspect;
  exports.isDuplicate = isDuplicate;
  exports.calculateRarity = calculateRarity;
  exports.getDiscoveries = getDiscoveries;
  exports.getDiscoveredZones = getDiscoveredZones;
  exports.ZONE_SECRETS = ZONE_SECRETS;
  exports.LORE_ENTRIES = LORE_ENTRIES;
  exports.getZoneSecrets = getZoneSecrets;
  exports.checkNearbySecrets = checkNearbySecrets;
  exports.discoverSecret = discoverSecret;
  exports.getLoreEntry = getLoreEntry;
  exports.getUnlockedLore = getUnlockedLore;
  exports.getLoreCategories = getLoreCategories;

})(typeof module !== 'undefined' ? module.exports : (window.Exploration = {}));


// physical.js
(function(exports) {

  // Anchor types
  const ANCHOR_TYPES = [
    'zone_portal', 'resource_node', 'discovery_point',
    'gathering_spot', 'garden_plot'
  ];

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Haversine distance calculation (returns km)
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const toRad = deg => deg * Math.PI / 180;

    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    return distance;
  }

  // Validate anchor location
  function validateAnchorLocation(lat, lon) {
    // Check valid range
    if (typeof lat !== 'number' || typeof lon !== 'number') {
      return {safe: false, reason: 'Invalid coordinate types'};
    }

    if (lat < -90 || lat > 90) {
      return {safe: false, reason: 'Latitude out of range (-90 to 90)'};
    }

    if (lon < -180 || lon > 180) {
      return {safe: false, reason: 'Longitude out of range (-180 to 180)'};
    }

    // Check not exactly (0,0) - null island
    if (lat === 0 && lon === 0) {
      return {safe: false, reason: 'Null Island coordinates not allowed'};
    }

    // Check not in ocean (basic check: reject if far from land)
    if (Math.abs(lat) > 85 && Math.abs(lon) > 170) {
      return {safe: false, reason: 'Location appears to be in remote ocean'};
    }

    return {safe: true};
  }

  // Create anchor
  function createAnchor(msg, state) {
    const lat = msg.payload.lat;
    const lon = msg.payload.lon;

    // Validate GPS coordinates
    if (lat === undefined || lon === undefined) {
      return {
        success: false,
        error: 'Missing GPS coordinates'
      };
    }

    const validation = validateAnchorLocation(lat, lon);
    if (!validation.safe) {
      return {
        success: false,
        error: validation.reason
      };
    }

    const anchorType = msg.payload.type || 'discovery_point';
    if (!ANCHOR_TYPES.includes(anchorType)) {
      return {
        success: false,
        error: 'Invalid anchor type'
      };
    }

    const anchor = {
      id: generateId(),
      type: anchorType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      lat: lat,
      lon: lon,
      creator: msg.from,
      ts: Date.now(),
      status: 'pending'
    };

    // Initialize state.anchors if needed
    if (!state.anchors) {
      state.anchors = [];
    }

    state.anchors.push(anchor);

    return {
      success: true,
      state: state,
      anchor: anchor
    };
  }

  // Calculate warmth from GPS history
  function calculateWarmth(gpsHistory) {
    // Null-safe: return 0 if no history
    if (!gpsHistory || !Array.isArray(gpsHistory) || gpsHistory.length < 2) {
      return 0;
    }

    let totalKm = 0;
    const maxWalkingSpeed = 25; // km/h - filter out driving

    for (let i = 1; i < gpsHistory.length; i++) {
      const prev = gpsHistory[i - 1];
      const curr = gpsHistory[i];

      // Skip if missing data
      if (!prev.lat || !prev.lon || !curr.lat || !curr.lon || !prev.ts || !curr.ts) {
        continue;
      }

      const distance = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
      const timeHours = (curr.ts - prev.ts) / (1000 * 60 * 60);

      // Skip if time is zero or negative
      if (timeHours <= 0) {
        continue;
      }

      const speed = distance / timeHours;

      // Filter out driving speed
      if (speed <= maxWalkingSpeed) {
        totalKm += distance;
      }
    }

    // Return warmth capped at 100
    const warmth = Math.min(100, totalKm * 10);
    return warmth;
  }

  // Get warmth bonus multiplier
  function getWarmthBonus(warmth) {
    // Null-safe: if warmth is null/undefined, treat as 0
    if (typeof warmth !== 'number' || warmth < 0) {
      warmth = 0;
    }

    // Returns 1.0 + (warmth / 1000)
    // Max 1.1 at warmth=100 (10% bonus)
    return 1.0 + (warmth / 1000);
  }

  /**
   * Get speed from GPS position (for AR safety - pause at driving speed)
   * @param {Object} prev - Previous GPS point {lat, lon, ts}
   * @param {Object} curr - Current GPS point {lat, lon, ts}
   * @returns {number} Speed in km/h
   */
  function getSpeed(prev, curr) {
    if (!prev || !curr || !prev.ts || !curr.ts) return 0;
    var dist = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
    var hours = (curr.ts - prev.ts) / (1000 * 60 * 60);
    if (hours <= 0) return 0;
    return dist / hours;
  }

  /**
   * Check if player is moving too fast for AR mode (driving)
   * @param {Array} recentGPS - Last 3+ GPS points
   * @returns {boolean} true if driving speed detected
   */
  function isDrivingSpeed(recentGPS) {
    if (!recentGPS || recentGPS.length < 2) return false;
    var last = recentGPS[recentGPS.length - 1];
    var prev = recentGPS[recentGPS.length - 2];
    return getSpeed(prev, last) > 30; // 30 km/h threshold
  }

  /**
   * Get warmth tier label
   * @param {number} warmth - Warmth value 0-100
   * @returns {string} Tier label
   */
  function getWarmthTier(warmth) {
    if (warmth >= 80) return 'Sunwalker';
    if (warmth >= 50) return 'Wanderer';
    if (warmth >= 20) return 'Stroller';
    if (warmth > 0) return 'Newcomer';
    return 'Indoor';
  }

  // Exports
  exports.ANCHOR_TYPES = ANCHOR_TYPES;
  exports.createAnchor = createAnchor;
  exports.validateAnchorLocation = validateAnchorLocation;
  exports.calculateWarmth = calculateWarmth;
  exports.getWarmthBonus = getWarmthBonus;
  exports.haversineDistance = haversineDistance;
  exports.getSpeed = getSpeed;
  exports.isDrivingSpeed = isDrivingSpeed;
  exports.getWarmthTier = getWarmthTier;

})(typeof module !== 'undefined' ? module.exports : (window.Physical = {}));


// guilds.js
(function(exports) {
  'use strict';

  // Guild/Association system for ZION MMO
  // Implements community formation per ZION Constitution Â§2.3 and Â§5.4

  // State storage
  var guilds = [];
  var invites = [];
  var guildMessages = [];
  var nextGuildId = 1;
  var nextInviteId = 1;
  var nextMessageId = 1;

  // Guild level thresholds
  var LEVEL_THRESHOLDS = [
    { level: 1, xp: 0, maxMembers: 20 },
    { level: 2, xp: 500, maxMembers: 30 },
    { level: 3, xp: 1500, maxMembers: 40 },
    { level: 4, xp: 3000, maxMembers: 50 },
    { level: 5, xp: 6000, maxMembers: 60 }
  ];

  // Constants
  var GUILD_CREATION_COST = 100;
  var INVITE_EXPIRY_MS = 3600000; // 1 hour

  /**
   * Initialize guilds system with saved data
   * @param {object} existingData - Previously saved guild data
   */
  function initGuilds(existingData) {
    if (!existingData) return;

    guilds = existingData.guilds || [];
    invites = existingData.invites || [];
    guildMessages = existingData.guildMessages || [];
    nextGuildId = existingData.nextGuildId || 1;
    nextInviteId = existingData.nextInviteId || 1;
    nextMessageId = existingData.nextMessageId || 1;

    console.log('Guilds initialized:', guilds.length, 'guilds');
  }

  /**
   * Get guilds state for saving
   * @returns {object} - Serializable guild state
   */
  function getGuildsState() {
    return {
      guilds: guilds,
      invites: invites,
      guildMessages: guildMessages,
      nextGuildId: nextGuildId,
      nextInviteId: nextInviteId,
      nextMessageId: nextMessageId
    };
  }

  /**
   * Create a new guild
   * @param {string} playerId - Founder player ID
   * @param {string} name - Guild name
   * @param {string} tag - Guild tag (3-5 chars)
   * @param {string} type - Guild type: 'guild'|'garden'|'studio'|'community'
   * @param {string} description - Guild description
   * @returns {object} - { success: boolean, guild?: object, error?: string }
   */
  function createGuild(playerId, name, tag, type, description) {
    // Validate parameters
    if (!playerId || !name || !tag || !type) {
      return { success: false, error: 'Missing required parameters' };
    }

    if (tag.length < 3 || tag.length > 5) {
      return { success: false, error: 'Tag must be 3-5 characters' };
    }

    if (['guild', 'garden', 'studio', 'community'].indexOf(type) === -1) {
      return { success: false, error: 'Invalid guild type' };
    }

    // Check if player already in a guild
    var existingGuild = getPlayerGuild(playerId);
    if (existingGuild) {
      return { success: false, error: 'Already in a guild' };
    }

    // Check if guild name or tag already exists
    var nameExists = guilds.some(function(g) { return g.name === name; });
    var tagExists = guilds.some(function(g) { return g.tag === tag; });

    if (nameExists) {
      return { success: false, error: 'Guild name already taken' };
    }

    if (tagExists) {
      return { success: false, error: 'Guild tag already taken' };
    }

    // Create guild
    var guild = {
      id: 'guild_' + (nextGuildId++),
      name: name,
      tag: tag,
      description: description || '',
      founder: playerId,
      leaders: [playerId],
      members: [{
        playerId: playerId,
        role: 'leader',
        joinedAt: Date.now()
      }],
      createdAt: Date.now(),
      zone: 'nexus', // Default home zone
      type: type,
      banner: {
        primaryColor: '#FFD700',
        secondaryColor: '#4A4A4A',
        icon: 'star'
      },
      treasury: 0,
      level: 1,
      xp: 0,
      maxMembers: 20,
      settings: {
        open: true,
        minLevel: 0
      },
      activities: []
    };

    guilds.push(guild);

    // Log activity
    addActivity(guild.id, playerId + ' founded the ' + type);

    return {
      success: true,
      guild: guild,
      cost: GUILD_CREATION_COST
    };
  }

  /**
   * Disband a guild
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be founder)
   * @returns {object} - { success: boolean, error?: string }
   */
  function disbandGuild(guildId, playerId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    if (guild.founder !== playerId) {
      return { success: false, error: 'Only founder can disband guild' };
    }

    // Remove guild
    guilds = guilds.filter(function(g) { return g.id !== guildId; });

    // Remove invites
    invites = invites.filter(function(i) { return i.guildId !== guildId; });

    // Remove messages
    guildMessages = guildMessages.filter(function(m) { return m.guildId !== guildId; });

    return { success: true };
  }

  /**
   * Invite player to guild
   * @param {string} guildId - Guild ID
   * @param {string} inviterId - Inviter player ID
   * @param {string} targetId - Target player ID
   * @returns {object} - { success: boolean, invite?: object, error?: string }
   */
  function inviteToGuild(guildId, inviterId, targetId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    // Check inviter has permission
    var inviterMember = guild.members.find(function(m) { return m.playerId === inviterId; });
    if (!inviterMember || (inviterMember.role !== 'leader' && inviterMember.role !== 'officer')) {
      return { success: false, error: 'No permission to invite' };
    }

    // Check target not already in guild
    var targetInGuild = guild.members.some(function(m) { return m.playerId === targetId; });
    if (targetInGuild) {
      return { success: false, error: 'Player already in guild' };
    }

    // Check target not in another guild
    var targetGuild = getPlayerGuild(targetId);
    if (targetGuild) {
      return { success: false, error: 'Player already in another guild' };
    }

    // Check guild not full
    if (guild.members.length >= guild.maxMembers) {
      return { success: false, error: 'Guild is full' };
    }

    // Check if invite already exists
    var existingInvite = invites.find(function(i) {
      return i.guildId === guildId && i.targetId === targetId && i.status === 'pending';
    });

    if (existingInvite) {
      return { success: false, error: 'Invite already sent' };
    }

    // Create invite
    var invite = {
      id: 'invite_' + (nextInviteId++),
      guildId: guildId,
      guildName: guild.name,
      guildTag: guild.tag,
      inviterId: inviterId,
      targetId: targetId,
      status: 'pending',
      createdAt: Date.now(),
      expiresAt: Date.now() + INVITE_EXPIRY_MS
    };

    invites.push(invite);

    return { success: true, invite: invite };
  }

  /**
   * Accept guild invite
   * @param {string} inviteId - Invite ID
   * @param {string} playerId - Player ID
   * @returns {object} - { success: boolean, guild?: object, error?: string }
   */
  function acceptInvite(inviteId, playerId) {
    var invite = invites.find(function(i) { return i.id === inviteId; });
    if (!invite) {
      return { success: false, error: 'Invite not found' };
    }

    if (invite.targetId !== playerId) {
      return { success: false, error: 'Invite not for this player' };
    }

    if (invite.status !== 'pending') {
      return { success: false, error: 'Invite already responded to' };
    }

    if (Date.now() > invite.expiresAt) {
      invite.status = 'expired';
      return { success: false, error: 'Invite expired' };
    }

    var guild = getGuild(invite.guildId);
    if (!guild) {
      return { success: false, error: 'Guild no longer exists' };
    }

    // Check player not in another guild
    var playerGuild = getPlayerGuild(playerId);
    if (playerGuild) {
      return { success: false, error: 'Already in a guild' };
    }

    // Check guild not full
    if (guild.members.length >= guild.maxMembers) {
      return { success: false, error: 'Guild is full' };
    }

    // Add member
    guild.members.push({
      playerId: playerId,
      role: 'member',
      joinedAt: Date.now()
    });

    invite.status = 'accepted';

    // Log activity
    addActivity(guild.id, playerId + ' joined the guild');

    return { success: true, guild: guild };
  }

  /**
   * Decline guild invite
   * @param {string} inviteId - Invite ID
   * @param {string} playerId - Player ID
   * @returns {object} - { success: boolean, error?: string }
   */
  function declineInvite(inviteId, playerId) {
    var invite = invites.find(function(i) { return i.id === inviteId; });
    if (!invite) {
      return { success: false, error: 'Invite not found' };
    }

    if (invite.targetId !== playerId) {
      return { success: false, error: 'Invite not for this player' };
    }

    if (invite.status !== 'pending') {
      return { success: false, error: 'Invite already responded to' };
    }

    invite.status = 'declined';

    return { success: true };
  }

  /**
   * Leave guild
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID
   * @returns {object} - { success: boolean, error?: string }
   */
  function leaveGuild(guildId, playerId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var memberIndex = guild.members.findIndex(function(m) { return m.playerId === playerId; });
    if (memberIndex === -1) {
      return { success: false, error: 'Not a member of this guild' };
    }

    // Founder cannot leave (must disband)
    if (guild.founder === playerId) {
      return { success: false, error: 'Founder must disband guild instead' };
    }

    // Remove member
    guild.members.splice(memberIndex, 1);

    // Remove from leaders if applicable
    guild.leaders = guild.leaders.filter(function(id) { return id !== playerId; });

    // Log activity
    addActivity(guild.id, playerId + ' left the guild');

    return { success: true };
  }

  /**
   * Kick member from guild
   * @param {string} guildId - Guild ID
   * @param {string} kickerId - Kicker player ID
   * @param {string} targetId - Target player ID
   * @returns {object} - { success: boolean, error?: string }
   */
  function kickMember(guildId, kickerId, targetId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    // Check kicker has permission
    var kickerMember = guild.members.find(function(m) { return m.playerId === kickerId; });
    if (!kickerMember || (kickerMember.role !== 'leader' && kickerMember.role !== 'officer')) {
      return { success: false, error: 'No permission to kick' };
    }

    // Cannot kick founder
    if (guild.founder === targetId) {
      return { success: false, error: 'Cannot kick founder' };
    }

    // Cannot kick self
    if (kickerId === targetId) {
      return { success: false, error: 'Cannot kick yourself' };
    }

    var targetMember = guild.members.find(function(m) { return m.playerId === targetId; });
    if (!targetMember) {
      return { success: false, error: 'Player not in guild' };
    }

    // Officers cannot kick other officers or leaders
    if (kickerMember.role === 'officer' && (targetMember.role === 'officer' || targetMember.role === 'leader')) {
      return { success: false, error: 'Insufficient permission' };
    }

    // Remove member
    guild.members = guild.members.filter(function(m) { return m.playerId !== targetId; });

    // Remove from leaders if applicable
    guild.leaders = guild.leaders.filter(function(id) { return id !== targetId; });

    // Log activity
    addActivity(guild.id, targetId + ' was kicked from guild');

    return { success: true };
  }

  /**
   * Promote/demote member
   * @param {string} guildId - Guild ID
   * @param {string} promoterId - Promoter player ID
   * @param {string} targetId - Target player ID
   * @param {string} newRole - New role: 'leader'|'officer'|'member'
   * @returns {object} - { success: boolean, error?: string }
   */
  function promoteRole(guildId, promoterId, targetId, newRole) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    if (['leader', 'officer', 'member'].indexOf(newRole) === -1) {
      return { success: false, error: 'Invalid role' };
    }

    // Only leaders can promote
    var promoterMember = guild.members.find(function(m) { return m.playerId === promoterId; });
    if (!promoterMember || promoterMember.role !== 'leader') {
      return { success: false, error: 'Only leaders can promote' };
    }

    // Cannot change founder's role
    if (guild.founder === targetId && newRole !== 'leader') {
      return { success: false, error: 'Cannot demote founder' };
    }

    var targetMember = guild.members.find(function(m) { return m.playerId === targetId; });
    if (!targetMember) {
      return { success: false, error: 'Player not in guild' };
    }

    var oldRole = targetMember.role;
    targetMember.role = newRole;

    // Update leaders array
    if (newRole === 'leader' && guild.leaders.indexOf(targetId) === -1) {
      guild.leaders.push(targetId);
    } else if (newRole !== 'leader' && guild.leaders.indexOf(targetId) !== -1) {
      guild.leaders = guild.leaders.filter(function(id) { return id !== targetId; });
    }

    // Log activity
    addActivity(guild.id, targetId + ' promoted from ' + oldRole + ' to ' + newRole);

    return { success: true };
  }

  /**
   * Get guild by ID
   * @param {string} guildId - Guild ID
   * @returns {object|null} - Guild data or null
   */
  function getGuild(guildId) {
    return guilds.find(function(g) { return g.id === guildId; }) || null;
  }

  /**
   * Get player's guild
   * @param {string} playerId - Player ID
   * @returns {object|null} - Guild data or null
   */
  function getPlayerGuild(playerId) {
    return guilds.find(function(g) {
      return g.members.some(function(m) { return m.playerId === playerId; });
    }) || null;
  }

  /**
   * Get guild members with details
   * @param {string} guildId - Guild ID
   * @returns {array} - Array of member objects
   */
  function getGuildMembers(guildId) {
    var guild = getGuild(guildId);
    if (!guild) return [];

    return guild.members.map(function(m) {
      return {
        playerId: m.playerId,
        role: m.role,
        joinedAt: m.joinedAt,
        online: false // Would be populated by game state
      };
    });
  }

  /**
   * Search guilds by name
   * @param {string} query - Search query
   * @returns {array} - Matching guilds
   */
  function searchGuilds(query) {
    var lowerQuery = query.toLowerCase();
    return guilds.filter(function(g) {
      return g.name.toLowerCase().indexOf(lowerQuery) !== -1 ||
             g.tag.toLowerCase().indexOf(lowerQuery) !== -1;
    });
  }

  /**
   * Get guilds by type
   * @param {string} type - Guild type
   * @returns {array} - Guilds of that type
   */
  function getGuildsByType(type) {
    return guilds.filter(function(g) { return g.type === type; });
  }

  /**
   * Deposit to guild treasury
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID
   * @param {number} amount - Amount to deposit
   * @returns {object} - { success: boolean, error?: string }
   */
  function depositToTreasury(guildId, playerId, amount) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member) {
      return { success: false, error: 'Not a member of this guild' };
    }

    if (amount <= 0) {
      return { success: false, error: 'Invalid amount' };
    }

    guild.treasury += amount;

    // Log activity
    addActivity(guild.id, playerId + ' deposited ' + amount + ' Spark to treasury');

    return { success: true };
  }

  /**
   * Withdraw from guild treasury
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be leader)
   * @param {number} amount - Amount to withdraw
   * @returns {object} - { success: boolean, error?: string }
   */
  function withdrawFromTreasury(guildId, playerId, amount) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can withdraw' };
    }

    if (amount <= 0) {
      return { success: false, error: 'Invalid amount' };
    }

    if (guild.treasury < amount) {
      return { success: false, error: 'Insufficient treasury funds' };
    }

    guild.treasury -= amount;

    // Log activity
    addActivity(guild.id, playerId + ' withdrew ' + amount + ' Spark from treasury');

    return { success: true };
  }

  /**
   * Add XP to guild
   * @param {string} guildId - Guild ID
   * @param {number} amount - XP amount
   * @param {string} activity - Activity description
   * @returns {object} - { success: boolean, leveledUp: boolean, newLevel?: number }
   */
  function addGuildXP(guildId, amount, activity) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, leveledUp: false };
    }

    guild.xp += amount;

    // Check for level up
    var newLevel = calculateLevel(guild.xp);
    var leveledUp = newLevel > guild.level;

    if (leveledUp) {
      guild.level = newLevel;
      var threshold = LEVEL_THRESHOLDS.find(function(t) { return t.level === newLevel; });
      if (threshold) {
        guild.maxMembers = threshold.maxMembers;
      }

      // Log activity
      addActivity(guild.id, 'Guild reached level ' + newLevel + '!');
    }

    // Log XP activity
    if (activity) {
      addActivity(guild.id, activity + ' (+' + amount + ' XP)');
    }

    return {
      success: true,
      leveledUp: leveledUp,
      newLevel: leveledUp ? newLevel : undefined
    };
  }

  /**
   * Calculate guild level from XP
   * @param {number} xp - Total XP
   * @returns {number} - Guild level
   */
  function calculateLevel(xp) {
    for (var i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
      if (xp >= LEVEL_THRESHOLDS[i].xp) {
        return LEVEL_THRESHOLDS[i].level;
      }
    }
    return 1;
  }

  /**
   * Get guild leaderboard
   * @returns {array} - Top guilds sorted by XP
   */
  function getGuildLeaderboard() {
    return guilds
      .slice()
      .sort(function(a, b) { return b.xp - a.xp; })
      .slice(0, 10)
      .map(function(g) {
        return {
          id: g.id,
          name: g.name,
          tag: g.tag,
          type: g.type,
          level: g.level,
          xp: g.xp,
          memberCount: g.members.length
        };
      });
  }

  /**
   * Set guild banner
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be leader)
   * @param {object} banner - Banner config { primaryColor, secondaryColor, icon }
   * @returns {object} - { success: boolean, error?: string }
   */
  function setGuildBanner(guildId, playerId, banner) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can change banner' };
    }

    guild.banner = banner;

    // Log activity
    addActivity(guild.id, 'Guild banner updated');

    return { success: true };
  }

  /**
   * Get guild activities
   * @param {string} guildId - Guild ID
   * @param {number} limit - Max number of activities
   * @returns {array} - Activity log
   */
  function getGuildActivities(guildId, limit) {
    var guild = getGuild(guildId);
    if (!guild) return [];

    var activities = guild.activities.slice();
    if (limit) {
      activities = activities.slice(-limit);
    }

    return activities.reverse(); // Most recent first
  }

  /**
   * Send guild message
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Sender player ID
   * @param {string} text - Message text
   * @returns {object} - { success: boolean, message?: object, error?: string }
   */
  function sendGuildMessage(guildId, playerId, text) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member) {
      return { success: false, error: 'Not a member of this guild' };
    }

    var message = {
      id: 'msg_' + (nextMessageId++),
      guildId: guildId,
      playerId: playerId,
      text: text,
      timestamp: Date.now()
    };

    guildMessages.push(message);

    return { success: true, message: message };
  }

  /**
   * Get guild messages
   * @param {string} guildId - Guild ID
   * @param {number} limit - Max number of messages
   * @returns {array} - Messages
   */
  function getGuildMessages(guildId, limit) {
    var messages = guildMessages.filter(function(m) { return m.guildId === guildId; });

    if (limit) {
      messages = messages.slice(-limit);
    }

    return messages;
  }

  /**
   * Add activity to guild log
   * @param {string} guildId - Guild ID
   * @param {string} activity - Activity description
   */
  function addActivity(guildId, activity) {
    var guild = getGuild(guildId);
    if (!guild) return;

    guild.activities.push({
      timestamp: Date.now(),
      text: activity
    });

    // Keep only last 50 activities
    if (guild.activities.length > 50) {
      guild.activities = guild.activities.slice(-50);
    }
  }

  /**
   * Get pending invites for player
   * @param {string} playerId - Player ID
   * @returns {array} - Pending invites
   */
  function getPendingInvites(playerId) {
    return invites.filter(function(i) {
      return i.targetId === playerId &&
             i.status === 'pending' &&
             Date.now() <= i.expiresAt;
    });
  }

  /**
   * Update guild settings
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be leader)
   * @param {object} settings - Settings to update
   * @returns {object} - { success: boolean, error?: string }
   */
  function updateGuildSettings(guildId, playerId, settings) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can update settings' };
    }

    // Update allowed settings
    if (settings.hasOwnProperty('open')) {
      guild.settings.open = settings.open;
    }
    if (settings.hasOwnProperty('minLevel')) {
      guild.settings.minLevel = settings.minLevel;
    }

    return { success: true };
  }

  // Export public API
  exports.initGuilds = initGuilds;
  exports.getGuildsState = getGuildsState;
  exports.createGuild = createGuild;
  exports.disbandGuild = disbandGuild;
  exports.inviteToGuild = inviteToGuild;
  exports.acceptInvite = acceptInvite;
  exports.declineInvite = declineInvite;
  exports.leaveGuild = leaveGuild;
  exports.kickMember = kickMember;
  exports.promoteRole = promoteRole;
  exports.getGuild = getGuild;
  exports.getPlayerGuild = getPlayerGuild;
  exports.getGuildMembers = getGuildMembers;
  exports.searchGuilds = searchGuilds;
  exports.getGuildsByType = getGuildsByType;
  exports.depositToTreasury = depositToTreasury;
  exports.withdrawFromTreasury = withdrawFromTreasury;
  exports.addGuildXP = addGuildXP;
  exports.getGuildLeaderboard = getGuildLeaderboard;
  exports.setGuildBanner = setGuildBanner;
  exports.getGuildActivities = getGuildActivities;
  exports.sendGuildMessage = sendGuildMessage;
  exports.getGuildMessages = getGuildMessages;
  exports.getPendingInvites = getPendingInvites;
  exports.updateGuildSettings = updateGuildSettings;

})(typeof module !== 'undefined' ? module.exports : (window.Guilds = {}));


// mentoring.js
(function(exports) {
  'use strict';

  // ============================================================================
  // SKILL TREE CONFIGURATION
  // ============================================================================

  var SKILLS = {
    gardening: {
      name: 'Gardening',
      levels: ['Seedling', 'Sprout', 'Gardener', 'Botanist', 'Grove Master'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    crafting: {
      name: 'Crafting',
      levels: ['Novice', 'Apprentice', 'Journeyman', 'Artisan', 'Master Crafter'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    building: {
      name: 'Building',
      levels: ['Laborer', 'Builder', 'Architect', 'Engineer', 'Grand Architect'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    exploration: {
      name: 'Exploration',
      levels: ['Wanderer', 'Scout', 'Explorer', 'Pathfinder', 'Cartographer'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    trading: {
      name: 'Trading',
      levels: ['Haggler', 'Merchant', 'Trader', 'Mogul', 'Trade Baron'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    social: {
      name: 'Social',
      levels: ['Shy', 'Friendly', 'Sociable', 'Diplomat', 'Ambassador'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    combat: {
      name: 'Combat',
      levels: ['Brawler', 'Fighter', 'Warrior', 'Champion', 'Arena Legend'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    lore: {
      name: 'Lore',
      levels: ['Curious', 'Student', 'Scholar', 'Sage', 'Lorekeeper'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    }
  };

  // NPC archetype to skill mapping
  var NPC_TEACHING_SPECIALTIES = {
    farmer: 'gardening',
    gardener: 'gardening',
    artisan: 'crafting',
    creator: 'crafting',
    builder: 'building',
    architect: 'building',
    explorer: 'exploration',
    ranger: 'exploration',
    merchant: 'trading',
    trader: 'trading',
    diplomat: 'social',
    storyteller: 'social',
    warrior: 'combat',
    guardian: 'combat',
    scholar: 'lore',
    sage: 'lore'
  };

  // ============================================================================
  // STATE MANAGEMENT
  // ============================================================================

  var playerSkills = {}; // playerId -> { skillName: { xp, level, levelName } }
  var mentorships = {}; // mentorshipId -> mentorship object
  var mentorshipOffers = {}; // offerId -> offer object
  var npcLessons = {}; // lessonId -> lesson object
  var mentorshipIdCounter = 0;
  var offerIdCounter = 0;
  var lessonIdCounter = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function generateId(prefix) {
    return prefix + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  function getSkillLevel(xp, skill) {
    if (!SKILLS[skill]) return 0;
    var thresholds = SKILLS[skill].xpPerLevel;
    for (var i = thresholds.length - 1; i >= 0; i--) {
      if (xp >= thresholds[i]) return i;
    }
    return 0;
  }

  function getLevelName(level, skill) {
    if (!SKILLS[skill] || level < 0 || level >= SKILLS[skill].levels.length) {
      return 'Unknown';
    }
    return SKILLS[skill].levels[level];
  }

  // ============================================================================
  // PLAYER SKILLS
  // ============================================================================

  function initPlayerSkills(playerId) {
    if (playerSkills[playerId]) return playerSkills[playerId];

    playerSkills[playerId] = {};
    for (var skillName in SKILLS) {
      playerSkills[playerId][skillName] = {
        xp: 0,
        level: 0,
        levelName: SKILLS[skillName].levels[0]
      };
    }
    return playerSkills[playerId];
  }

  function getPlayerSkills(playerId) {
    if (!playerSkills[playerId]) {
      initPlayerSkills(playerId);
    }
    return playerSkills[playerId];
  }

  function addSkillXP(playerId, skill, amount) {
    if (!SKILLS[skill]) {
      return { success: false, error: 'Invalid skill' };
    }

    if (!playerSkills[playerId]) {
      initPlayerSkills(playerId);
    }

    var skillData = playerSkills[playerId][skill];
    var oldLevel = skillData.level;
    skillData.xp += amount;

    var newLevel = getSkillLevel(skillData.xp, skill);
    var leveledUp = newLevel > oldLevel;

    if (leveledUp) {
      skillData.level = newLevel;
      skillData.levelName = getLevelName(newLevel, skill);
    }

    return {
      success: true,
      newXP: skillData.xp,
      leveledUp: leveledUp,
      newLevel: newLevel,
      newLevelName: skillData.levelName
    };
  }

  function getSkillLevelNum(playerId, skill) {
    if (!playerSkills[playerId] || !SKILLS[skill]) {
      return 0;
    }
    return playerSkills[playerId][skill].level;
  }

  // ============================================================================
  // MENTORSHIP SYSTEM
  // ============================================================================

  function offerMentorship(mentorId, menteeId, skill) {
    if (!SKILLS[skill]) {
      return { success: false, error: 'Invalid skill' };
    }

    var mentorLevel = getSkillLevelNum(mentorId, skill);
    if (mentorLevel < 2) {
      return {
        success: false,
        error: 'Mentor must be at least level 2 in ' + SKILLS[skill].name
      };
    }

    var offerId = generateId('offer');
    var offer = {
      id: offerId,
      mentorId: mentorId,
      menteeId: menteeId,
      skill: skill,
      timestamp: Date.now()
    };

    mentorshipOffers[offerId] = offer;

    return {
      success: true,
      offer: offer
    };
  }

  function acceptMentorship(offerId) {
    var offer = mentorshipOffers[offerId];
    if (!offer) {
      return { success: false, error: 'Offer not found' };
    }

    var mentorshipId = generateId('mentorship');
    var mentorship = {
      id: mentorshipId,
      mentorId: offer.mentorId,
      menteeId: offer.menteeId,
      skill: offer.skill,
      stepsCompleted: 0,
      totalSteps: 5,
      startedAt: Date.now()
    };

    mentorships[mentorshipId] = mentorship;
    delete mentorshipOffers[offerId];

    return {
      success: true,
      mentorship: mentorship
    };
  }

  function declineMentorship(offerId) {
    if (mentorshipOffers[offerId]) {
      delete mentorshipOffers[offerId];
    }
  }

  function completeLessonStep(mentorshipId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return { success: false, error: 'Mentorship not found' };
    }

    if (mentorship.stepsCompleted >= mentorship.totalSteps) {
      return { success: false, error: 'Mentorship already completed' };
    }

    mentorship.stepsCompleted++;
    var progress = mentorship.stepsCompleted / mentorship.totalSteps;
    var completed = mentorship.stepsCompleted >= mentorship.totalSteps;

    // Grant XP to mentee
    addSkillXP(mentorship.menteeId, mentorship.skill, 20);

    // Spark reward for mentor (5-10 per step, 50 bonus on completion)
    var sparkReward = Math.floor(5 + Math.random() * 5);
    if (completed) {
      sparkReward += 50;
    }

    return {
      success: true,
      progress: progress,
      stepsCompleted: mentorship.stepsCompleted,
      totalSteps: mentorship.totalSteps,
      completed: completed,
      sparkReward: sparkReward,
      mentorship: mentorship
    };
  }

  function getActiveMentorships(playerId) {
    var result = [];
    for (var id in mentorships) {
      var m = mentorships[id];
      if (m.mentorId === playerId || m.menteeId === playerId) {
        result.push(m);
      }
    }
    return result;
  }

  function getMentorshipProgress(mentorshipId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return null;
    }

    return {
      stepsCompleted: mentorship.stepsCompleted,
      totalSteps: mentorship.totalSteps,
      skill: mentorship.skill,
      mentor: mentorship.mentorId,
      mentee: mentorship.menteeId
    };
  }

  function cancelMentorship(mentorshipId, playerId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return { success: false, error: 'Mentorship not found' };
    }

    if (mentorship.mentorId !== playerId && mentorship.menteeId !== playerId) {
      return { success: false, error: 'Not part of this mentorship' };
    }

    delete mentorships[mentorshipId];
    return { success: true };
  }

  // ============================================================================
  // NPC TEACHING SYSTEM
  // ============================================================================

  function canNPCTeach(npcArchetype, skill) {
    if (!SKILLS[skill]) return false;
    return NPC_TEACHING_SPECIALTIES[npcArchetype] === skill;
  }

  function startNPCLesson(playerId, npcId, npcArchetype, skill) {
    if (!canNPCTeach(npcArchetype, skill)) {
      return {
        success: false,
        error: 'This NPC cannot teach ' + SKILLS[skill].name
      };
    }

    var lessonId = generateId('lesson');
    var lesson = {
      id: lessonId,
      playerId: playerId,
      npcId: npcId,
      npcArchetype: npcArchetype,
      skill: skill,
      startedAt: Date.now()
    };

    npcLessons[lessonId] = lesson;

    return {
      success: true,
      lesson: lesson
    };
  }

  function completeNPCLesson(lessonId) {
    var lesson = npcLessons[lessonId];
    if (!lesson) {
      return { success: false, error: 'Lesson not found' };
    }

    var xpGained = 15;
    addSkillXP(lesson.playerId, lesson.skill, xpGained);

    var sparkCost = Math.floor(5 + Math.random() * 10);

    delete npcLessons[lessonId];

    return {
      success: true,
      xpGained: xpGained,
      sparkCost: sparkCost,
      skill: lesson.skill
    };
  }

  // ============================================================================
  // STATE PERSISTENCE
  // ============================================================================

  function initMentoring(existingData) {
    if (existingData) {
      playerSkills = existingData.playerSkills || {};
      mentorships = existingData.mentorships || {};
      mentorshipOffers = existingData.mentorshipOffers || {};
      npcLessons = existingData.npcLessons || {};
    }
  }

  function getMentoringState() {
    return {
      playerSkills: playerSkills,
      mentorships: mentorships,
      mentorshipOffers: mentorshipOffers,
      npcLessons: npcLessons
    };
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.SKILLS = SKILLS;
  exports.NPC_TEACHING_SPECIALTIES = NPC_TEACHING_SPECIALTIES;
  exports.initPlayerSkills = initPlayerSkills;
  exports.getPlayerSkills = getPlayerSkills;
  exports.addSkillXP = addSkillXP;
  exports.getSkillLevel = getSkillLevelNum;
  exports.offerMentorship = offerMentorship;
  exports.acceptMentorship = acceptMentorship;
  exports.declineMentorship = declineMentorship;
  exports.completeLessonStep = completeLessonStep;
  exports.getActiveMentorships = getActiveMentorships;
  exports.getMentorshipProgress = getMentorshipProgress;
  exports.cancelMentorship = cancelMentorship;
  exports.canNPCTeach = canNPCTeach;
  exports.startNPCLesson = startNPCLesson;
  exports.completeNPCLesson = completeNPCLesson;
  exports.initMentoring = initMentoring;
  exports.getMentoringState = getMentoringState;

})(typeof module !== 'undefined' ? module.exports : (window.Mentoring = {}));


// models.js
/**
 * ZION MMO - Procedural 3D Model Generators
 * Creates complex Three.js meshes from primitive geometries
 * Compatible with Three.js r128
 */

(function(exports) {
  'use strict';

  // ========================================
  // TREE GENERATORS
  // ========================================

  function createTree(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'tree_' + type;
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.05;
    group.userData.swaySpeed = 1.0;

    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
    const darkTrunk = new THREE.MeshLambertMaterial({ color: 0x3a2718 });

    switch(type) {
      case 'oak':
        // Thick trunk with visible roots
        const oakTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 3 * scale, 8),
          trunkMaterial
        );
        oakTrunk.position.y = 1.5 * scale;
        group.add(oakTrunk);

        // Roots at base
        for (let i = 0; i < 4; i++) {
          const root = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1 * scale, 0.15 * scale, 0.5 * scale, 6),
            darkTrunk
          );
          root.position.y = 0.1 * scale;
          const angle = (i / 4) * Math.PI * 2;
          root.position.x = Math.cos(angle) * 0.3 * scale;
          root.position.z = Math.sin(angle) * 0.3 * scale;
          root.rotation.z = Math.PI / 6;
          root.rotation.y = angle;
          group.add(root);
        }

        // Large overlapping spherical canopy
        const canopyColors = [0x2d5016, 0x3a6b1f, 0x4a8028];
        for (let i = 0; i < 8; i++) {
          const leafBall = new THREE.Mesh(
            new THREE.SphereGeometry(0.8 * scale, 8, 6),
            new THREE.MeshLambertMaterial({
              color: canopyColors[Math.floor(Math.random() * canopyColors.length)]
            })
          );
          const angle = (i / 8) * Math.PI * 2;
          const radius = 0.6 * scale;
          leafBall.position.x = Math.cos(angle) * radius;
          leafBall.position.z = Math.sin(angle) * radius;
          leafBall.position.y = 3 * scale + Math.random() * 0.4 * scale;
          group.add(leafBall);
        }

        // Central canopy sphere
        const centerCanopy = new THREE.Mesh(
          new THREE.SphereGeometry(1 * scale, 8, 6),
          new THREE.MeshLambertMaterial({ color: 0x3a6b1f })
        );
        centerCanopy.position.y = 3.2 * scale;
        group.add(centerCanopy);
        break;

      case 'pine':
        // Tall narrow trunk
        const pineTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 4 * scale, 8),
          trunkMaterial
        );
        pineTrunk.position.y = 2 * scale;
        group.add(pineTrunk);

        // Stacked cone layers
        const pineMaterial = new THREE.MeshLambertMaterial({ color: 0x1a4d2e });
        const coneSizes = [1.2, 1.0, 0.8, 0.6];
        for (let i = 0; i < coneSizes.length; i++) {
          const cone = new THREE.Mesh(
            new THREE.ConeGeometry(coneSizes[i] * scale, 1.5 * scale, 8),
            pineMaterial
          );
          cone.position.y = (2 + i * 1.2) * scale;
          group.add(cone);
        }

        // Top point
        const top = new THREE.Mesh(
          new THREE.ConeGeometry(0.3 * scale, 0.8 * scale, 6),
          pineMaterial
        );
        top.position.y = 6.5 * scale;
        group.add(top);
        break;

      case 'willow':
        // Medium trunk
        const willowTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, 2.5 * scale, 8),
          trunkMaterial
        );
        willowTrunk.position.y = 1.25 * scale;
        group.add(willowTrunk);

        // Drooping branches
        const willowGreen = new THREE.MeshLambertMaterial({ color: 0x90ee90 });
        const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x5a4a38 });

        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const branchLength = 1.5 * scale;

          // Drooping branch
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03 * scale, 0.02 * scale, branchLength, 4),
            branchMaterial
          );
          branch.position.x = Math.cos(angle) * 0.2 * scale;
          branch.position.z = Math.sin(angle) * 0.2 * scale;
          branch.position.y = 2.5 * scale - branchLength / 2;
          branch.rotation.z = Math.PI / 4;
          branch.rotation.y = angle;
          group.add(branch);

          // Leaves along branch
          for (let j = 0; j < 3; j++) {
            const leaf = new THREE.Mesh(
              new THREE.SphereGeometry(0.15 * scale, 6, 4),
              willowGreen
            );
            leaf.position.x = Math.cos(angle) * (0.3 + j * 0.3) * scale;
            leaf.position.z = Math.sin(angle) * (0.3 + j * 0.3) * scale;
            leaf.position.y = (2.2 - j * 0.4) * scale;
            group.add(leaf);
          }
        }
        break;

      case 'cherry':
        // Medium trunk
        const cherryTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2.5 * scale, 8),
          trunkMaterial
        );
        cherryTrunk.position.y = 1.25 * scale;
        group.add(cherryTrunk);

        // Pink/white blossom clusters
        const blossomColors = [0xffb7c5, 0xffc0cb, 0xffd1dc, 0xffffff];
        for (let i = 0; i < 20; i++) {
          const blossom = new THREE.Mesh(
            new THREE.SphereGeometry(0.2 * scale, 6, 4),
            new THREE.MeshLambertMaterial({
              color: blossomColors[Math.floor(Math.random() * blossomColors.length)]
            })
          );
          const angle = Math.random() * Math.PI * 2;
          const radius = 0.4 + Math.random() * 0.6;
          blossom.position.x = Math.cos(angle) * radius * scale;
          blossom.position.z = Math.sin(angle) * radius * scale;
          blossom.position.y = (2 + Math.random() * 1) * scale;
          group.add(blossom);
        }
        break;

      case 'dead':
        // Grey trunk
        const deadTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25 * scale, 0.35 * scale, 3 * scale, 8),
          new THREE.MeshLambertMaterial({ color: 0x666666 })
        );
        deadTrunk.position.y = 1.5 * scale;
        group.add(deadTrunk);

        // Bare branches
        const deadBranchMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
        for (let i = 0; i < 6; i++) {
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05 * scale, 0.02 * scale, 1 * scale, 4),
            deadBranchMat
          );
          const angle = (i / 6) * Math.PI * 2;
          branch.position.y = (2 + Math.random() * 0.5) * scale;
          branch.rotation.z = Math.PI / 3 + Math.random() * 0.3;
          branch.rotation.y = angle;
          group.add(branch);
        }

        group.userData.animationType = 'none';
        break;
    }

    return group;
  }

  // ========================================
  // ROCK GENERATORS
  // ========================================

  function createRock(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'rock_' + type;

    switch(type) {
      case 'boulder':
        const boulderGeo = new THREE.DodecahedronGeometry(1 * scale, 0);
        const boulderMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        // Randomize vertices for irregular shape
        const vertices = boulderGeo.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          vertices[i] += (Math.random() - 0.5) * 0.2 * scale;
          vertices[i + 1] += (Math.random() - 0.5) * 0.2 * scale;
          vertices[i + 2] += (Math.random() - 0.5) * 0.2 * scale;
        }
        boulderGeo.attributes.position.needsUpdate = true;
        boulderGeo.computeVertexNormals();

        const boulder = new THREE.Mesh(boulderGeo, boulderMat);
        boulder.position.y = 0.8 * scale;
        group.add(boulder);
        break;

      case 'crystal':
        group.userData.animationType = 'bob';
        group.userData.bobSpeed = 1.5;
        group.userData.bobAmount = 0.2;

        const crystalColors = [0x9966ff, 0x6699ff, 0x00ccff];
        const angles = [0, Math.PI * 2 / 3, Math.PI * 4 / 3];

        for (let i = 0; i < 3; i++) {
          const crystalMat = new THREE.MeshLambertMaterial({
            color: crystalColors[i],
            emissive: crystalColors[i],
            emissiveIntensity: 0.3
          });

          const crystal = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.4 * scale, 0),
            crystalMat
          );

          crystal.position.x = Math.cos(angles[i]) * 0.3 * scale;
          crystal.position.z = Math.sin(angles[i]) * 0.3 * scale;
          crystal.position.y = (0.8 + i * 0.2) * scale;
          crystal.rotation.y = angles[i];
          crystal.scale.y = 1.5 + Math.random() * 0.5;
          group.add(crystal);
        }
        break;

      case 'ruins':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0xb8a890 });
        const ruinPieces = [
          { w: 1.5, h: 0.4, d: 0.8, x: 0, y: 0.2, z: 0, rx: 0, ry: 0, rz: 0.1 },
          { w: 1.0, h: 0.5, d: 0.6, x: 0.5, y: 0.5, z: 0.3, rx: 0.2, ry: 0.3, rz: -0.15 },
          { w: 0.8, h: 0.6, d: 0.5, x: -0.4, y: 0.6, z: -0.2, rx: -0.15, ry: -0.2, rz: 0.1 },
          { w: 0.6, h: 0.3, d: 0.4, x: 0.2, y: 1.0, z: -0.4, rx: 0.3, ry: 0.1, rz: 0.2 }
        ];

        ruinPieces.forEach(piece => {
          const stone = new THREE.Mesh(
            new THREE.BoxGeometry(piece.w * scale, piece.h * scale, piece.d * scale),
            stoneMat
          );
          stone.position.set(piece.x * scale, piece.y * scale, piece.z * scale);
          stone.rotation.set(piece.rx, piece.ry, piece.rz);
          group.add(stone);
        });
        break;
    }

    return group;
  }

  // ========================================
  // BUILDING GENERATORS
  // ========================================

  function createBuilding(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'building_' + type;

    switch(type) {
      case 'house':
        const wallMat = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
        const roofMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const doorMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const windowMat = new THREE.MeshLambertMaterial({
          color: 0xffffaa,
          emissive: 0xffff88,
          emissiveIntensity: 0.5
        });

        // Base
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(3 * scale, 2 * scale, 3 * scale),
          wallMat
        );
        base.position.y = 1 * scale;
        group.add(base);

        // Roof (A-frame)
        const roof1 = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5 * scale, 2 * scale),
          roofMat
        );
        roof1.position.y = 2.5 * scale;
        roof1.position.z = -0.5 * scale;
        roof1.rotation.x = -Math.PI / 4;
        group.add(roof1);

        const roof2 = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5 * scale, 2 * scale),
          roofMat
        );
        roof2.position.y = 2.5 * scale;
        roof2.position.z = 0.5 * scale;
        roof2.rotation.x = Math.PI / 4;
        group.add(roof2);

        // Door
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.6 * scale, 1.2 * scale, 0.1 * scale),
          doorMat
        );
        door.position.y = 0.6 * scale;
        door.position.z = 1.55 * scale;
        group.add(door);

        // Windows
        const windowPositions = [
          { x: -0.8, y: 1.2, z: 1.55 },
          { x: 0.8, y: 1.2, z: 1.55 }
        ];
        windowPositions.forEach(pos => {
          const window = new THREE.Mesh(
            new THREE.BoxGeometry(0.4 * scale, 0.4 * scale, 0.1 * scale),
            windowMat
          );
          window.position.set(pos.x * scale, pos.y * scale, pos.z * scale);
          group.add(window);
        });
        break;

      case 'tower':
        const towerMat = new THREE.MeshLambertMaterial({ color: 0x9a9a9a });
        const crenMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        // Main tower
        const tower = new THREE.Mesh(
          new THREE.CylinderGeometry(1 * scale, 1.2 * scale, 6 * scale, 12),
          towerMat
        );
        tower.position.y = 3 * scale;
        group.add(tower);

        // Crenellations (battlements)
        for (let i = 0; i < 8; i++) {
          const cren = new THREE.Mesh(
            new THREE.BoxGeometry(0.3 * scale, 0.5 * scale, 0.3 * scale),
            crenMat
          );
          const angle = (i / 8) * Math.PI * 2;
          cren.position.x = Math.cos(angle) * 1 * scale;
          cren.position.z = Math.sin(angle) * 1 * scale;
          cren.position.y = 6.25 * scale;
          group.add(cren);
        }

        // Window slits
        const slitMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const slit = new THREE.Mesh(
            new THREE.BoxGeometry(0.1 * scale, 0.6 * scale, 0.2 * scale),
            slitMat
          );
          slit.position.x = Math.cos(angle) * 1.15 * scale;
          slit.position.z = Math.sin(angle) * 1.15 * scale;
          slit.position.y = 4 * scale;
          group.add(slit);
        }
        break;

      case 'market_stall':
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
        const fabricMat = new THREE.MeshLambertMaterial({ color: 0xff6b35 });
        const counterMat = new THREE.MeshLambertMaterial({ color: 0xa0826d });

        // Four corner poles
        const polePositions = [
          { x: -1, z: -1 }, { x: 1, z: -1 },
          { x: -1, z: 1 }, { x: 1, z: 1 }
        ];
        polePositions.forEach(pos => {
          const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 2.5 * scale, 6),
            poleMat
          );
          pole.position.set(pos.x * scale, 1.25 * scale, pos.z * scale);
          group.add(pole);
        });

        // Fabric roof
        const roof = new THREE.Mesh(
          new THREE.PlaneGeometry(2.5 * scale, 2.5 * scale),
          fabricMat
        );
        roof.position.y = 2.5 * scale;
        roof.rotation.x = -Math.PI / 2;
        group.add(roof);

        // Counter
        const counter = new THREE.Mesh(
          new THREE.BoxGeometry(2 * scale, 0.1 * scale, 1 * scale),
          counterMat
        );
        counter.position.y = 1 * scale;
        counter.position.z = 0.5 * scale;
        group.add(counter);
        break;

      case 'temple':
        const templeMat = new THREE.MeshLambertMaterial({ color: 0xe8dcc4 });
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0xd4c5a9 });

        // Base platform with steps
        for (let i = 0; i < 3; i++) {
          const step = new THREE.Mesh(
            new THREE.BoxGeometry((4 - i * 0.3) * scale, 0.3 * scale, (3 - i * 0.3) * scale),
            templeMat
          );
          step.position.y = i * 0.3 * scale;
          group.add(step);
        }

        // Main building
        const main = new THREE.Mesh(
          new THREE.BoxGeometry(3 * scale, 2 * scale, 2 * scale),
          templeMat
        );
        main.position.y = 1.9 * scale;
        group.add(main);

        // Six pillars
        const pillarXPos = [-1.2, -0.4, 0.4, 1.2];
        pillarXPos.forEach(x => {
          const pillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15 * scale, 0.15 * scale, 2 * scale, 8),
            pillarMat
          );
          pillar.position.set(x * scale, 1.9 * scale, 1.2 * scale);
          group.add(pillar);
        });

        // Triangular pediment
        const pediment = new THREE.Mesh(
          new THREE.ConeGeometry(1.8 * scale, 0.8 * scale, 3),
          templeMat
        );
        pediment.position.y = 3.3 * scale;
        pediment.position.z = 1.2 * scale;
        pediment.rotation.z = -Math.PI / 2;
        pediment.rotation.y = Math.PI / 2;
        group.add(pediment);
        break;
    }

    return group;
  }

  // ========================================
  // FURNITURE GENERATORS
  // ========================================

  function createFurniture(type) {
    const group = new THREE.Group();
    group.name = 'furniture_' + type;

    switch(type) {
      case 'bench':
        const benchMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Seat
        const seat = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.1, 0.4),
          benchMat
        );
        seat.position.y = 0.5;
        group.add(seat);

        // Legs
        const leg1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          benchMat
        );
        leg1.position.set(-0.6, 0.25, 0);
        group.add(leg1);

        const leg2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          benchMat
        );
        leg2.position.set(0.6, 0.25, 0);
        group.add(leg2);
        break;

      case 'lantern':
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const lightMat = new THREE.MeshLambertMaterial({
          color: 0xffff88,
          emissive: 0xffff00,
          emissiveIntensity: 0.8
        });

        // Pole
        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 2, 6),
          poleMat
        );
        pole.position.y = 1;
        group.add(pole);

        // Glowing lantern box
        const lantern = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.3),
          lightMat
        );
        lantern.position.y = 2.2;
        group.add(lantern);

        // Add point light
        const light = new THREE.PointLight(0xffff88, 1, 10);
        light.position.y = 2.2;
        group.add(light);
        break;

      case 'well':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Stone cylinder
        const wellBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.8, 0.8, 1, 12),
          stoneMat
        );
        wellBase.position.y = 0.5;
        group.add(wellBase);

        // Wooden frame posts
        const post1 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6),
          woodMat
        );
        post1.position.set(-0.6, 1.25, 0);
        group.add(post1);

        const post2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6),
          woodMat
        );
        post2.position.set(0.6, 1.25, 0);
        group.add(post2);

        // Crossbar with rope cylinder
        const crossbar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 1.4, 6),
          woodMat
        );
        crossbar.position.y = 2;
        crossbar.rotation.z = Math.PI / 2;
        group.add(crossbar);

        // Bucket
        const bucket = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8),
          woodMat
        );
        bucket.position.set(0, 1.5, 0.5);
        group.add(bucket);
        break;

      case 'bridge':
        const plankMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
        const railMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

        // Arched planks
        const numPlanks = 8;
        for (let i = 0; i < numPlanks; i++) {
          const plank = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.1, 0.4),
            plankMat
          );
          const t = (i / (numPlanks - 1)) * Math.PI;
          plank.position.x = (i - numPlanks / 2) * 0.5;
          plank.position.y = Math.sin(t) * 0.3;
          plank.rotation.z = Math.cos(t) * 0.2;
          group.add(plank);
        }

        // Side rails
        for (let side = -1; side <= 1; side += 2) {
          for (let i = 0; i < numPlanks; i++) {
            const rail = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.5, 4),
              railMat
            );
            const t = (i / (numPlanks - 1)) * Math.PI;
            rail.position.x = (i - numPlanks / 2) * 0.5;
            rail.position.y = Math.sin(t) * 0.3 + 0.25;
            rail.position.z = side * 0.35;
            group.add(rail);
          }
        }
        break;

      case 'fence':
        const fenceMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Vertical posts
        for (let i = 0; i < 5; i++) {
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1, 0.1),
            fenceMat
          );
          post.position.x = (i - 2) * 0.5;
          post.position.y = 0.5;
          group.add(post);
        }

        // Horizontal rails
        for (let i = 0; i < 2; i++) {
          const rail = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.08, 0.08),
            fenceMat
          );
          rail.position.y = 0.3 + i * 0.4;
          group.add(rail);
        }
        break;
    }

    return group;
  }

  // ========================================
  // CREATURE GENERATORS
  // ========================================

  function createCreature(type) {
    const group = new THREE.Group();
    group.name = 'creature_' + type;

    switch(type) {
      case 'butterfly':
        group.userData.animationType = 'flap';
        group.userData.flapSpeed = 8;
        group.userData.flapAmount = Math.PI / 4;

        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const wingMat = new THREE.MeshLambertMaterial({ color: 0xff6b9d });

        // Body
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6),
          bodyMat
        );
        body.rotation.z = Math.PI / 2;
        group.add(body);

        // Wings (will rotate for flapping)
        const leftWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.3, 0.4),
          wingMat
        );
        leftWing.position.z = 0.2;
        leftWing.name = 'leftWing';
        group.add(leftWing);

        const rightWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.3, 0.4),
          wingMat
        );
        rightWing.position.z = -0.2;
        rightWing.name = 'rightWing';
        group.add(rightWing);
        break;

      case 'bird':
        group.userData.animationType = 'bob';
        group.userData.bobSpeed = 2;
        group.userData.bobAmount = 0.3;

        const birdBodyMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const birdWingMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

        // Body (cone)
        const birdBody = new THREE.Mesh(
          new THREE.ConeGeometry(0.15, 0.4, 8),
          birdBodyMat
        );
        birdBody.rotation.z = -Math.PI / 2;
        group.add(birdBody);

        // Wings
        const leftBirdWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          birdWingMat
        );
        leftBirdWing.position.z = 0.15;
        leftBirdWing.rotation.x = Math.PI / 6;
        leftBirdWing.name = 'leftWing';
        group.add(leftBirdWing);

        const rightBirdWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          birdWingMat
        );
        rightBirdWing.position.z = -0.15;
        rightBirdWing.rotation.x = -Math.PI / 6;
        rightBirdWing.name = 'rightWing';
        group.add(rightBirdWing);
        break;

      case 'fish':
        group.userData.animationType = 'swim';
        group.userData.swimSpeed = 1;
        group.userData.swimRadius = 2;
        group.userData.swimAngle = 0;

        const fishBodyMat = new THREE.MeshLambertMaterial({ color: 0xff8c00 });
        const fishTailMat = new THREE.MeshLambertMaterial({ color: 0xff6347 });

        // Elongated body
        const fishBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 8, 6),
          fishBodyMat
        );
        fishBody.scale.x = 2;
        group.add(fishBody);

        // Triangle tail
        const tailGeo = new THREE.ConeGeometry(0.15, 0.3, 3);
        const tail = new THREE.Mesh(tailGeo, fishTailMat);
        tail.rotation.z = Math.PI / 2;
        tail.position.x = -0.4;
        group.add(tail);
        break;
    }

    return group;
  }

  // ========================================
  // LANDMARK GENERATORS
  // ========================================

  function createLandmark(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'landmark_' + type;

    switch(type) {
      case 'fountain':
        const basinMat = new THREE.MeshLambertMaterial({ color: 0x8899aa });
        const waterMat = new THREE.MeshLambertMaterial({
          color: 0x4488cc,
          transparent: true,
          opacity: 0.7
        });
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0xaabbcc });

        // Circular basin
        const basin = new THREE.Mesh(
          new THREE.CylinderGeometry(2 * scale, 2.2 * scale, 0.6 * scale, 16),
          basinMat
        );
        basin.position.y = 0.3 * scale;
        group.add(basin);

        // Water surface inside basin
        const water = new THREE.Mesh(
          new THREE.CylinderGeometry(1.8 * scale, 1.8 * scale, 0.1 * scale, 16),
          waterMat
        );
        water.position.y = 0.5 * scale;
        group.add(water);

        // Central pillar
        const centerPillar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2 * scale, 8),
          pillarMat
        );
        centerPillar.position.y = 1.3 * scale;
        group.add(centerPillar);

        // Top bowl
        const topBowl = new THREE.Mesh(
          new THREE.SphereGeometry(0.5 * scale, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
          basinMat
        );
        topBowl.position.y = 2.3 * scale;
        topBowl.rotation.x = Math.PI;
        group.add(topBowl);

        // Water drop effect (small glowing sphere)
        const dropMat = new THREE.MeshLambertMaterial({
          color: 0x88ccff,
          emissive: 0x2266aa,
          emissiveIntensity: 0.4
        });
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.15 * scale, 8, 6),
          dropMat
        );
        drop.position.y = 2.5 * scale;
        drop.name = 'waterDrop';
        group.add(drop);

        group.userData.animationType = 'fountain';
        break;

      case 'obelisk':
        const obeliskMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
        const runeMat = new THREE.MeshLambertMaterial({
          color: 0x88aaff,
          emissive: 0x4466cc,
          emissiveIntensity: 0.6
        });

        // Tall tapered column
        const obelisk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3 * scale, 0.6 * scale, 5 * scale, 4),
          obeliskMat
        );
        obelisk.position.y = 2.5 * scale;
        group.add(obelisk);

        // Glowing rune rings
        for (let i = 0; i < 3; i++) {
          const rune = new THREE.Mesh(
            new THREE.TorusGeometry(0.45 * scale, 0.04 * scale, 6, 12),
            runeMat
          );
          rune.position.y = (1.5 + i * 1.2) * scale;
          rune.rotation.x = Math.PI / 2;
          group.add(rune);
        }

        // Pyramidal top
        const top = new THREE.Mesh(
          new THREE.ConeGeometry(0.35 * scale, 0.6 * scale, 4),
          obeliskMat
        );
        top.position.y = 5.3 * scale;
        group.add(top);

        // Glowing tip
        const tipMat = new THREE.MeshLambertMaterial({
          color: 0xaaccff,
          emissive: 0x6688ff,
          emissiveIntensity: 1.0
        });
        const tip = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 * scale, 8, 6),
          tipMat
        );
        tip.position.y = 5.7 * scale;
        group.add(tip);

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 1.5;
        break;

      case 'statue':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
        const pedestalMat = new THREE.MeshLambertMaterial({ color: 0x777777 });

        // Pedestal
        const pedestal = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 * scale, 0.8 * scale, 1.2 * scale),
          pedestalMat
        );
        pedestal.position.y = 0.4 * scale;
        group.add(pedestal);

        // Body (torso)
        const torso = new THREE.Mesh(
          new THREE.BoxGeometry(0.7 * scale, 1.2 * scale, 0.4 * scale),
          stoneMat
        );
        torso.position.y = 1.8 * scale;
        group.add(torso);

        // Head
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.25 * scale, 8, 6),
          stoneMat
        );
        head.position.y = 2.7 * scale;
        group.add(head);

        // Arms reaching out
        const leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.2 * scale),
          stoneMat
        );
        leftArm.position.set(-0.7 * scale, 2.0 * scale, 0);
        leftArm.rotation.z = Math.PI / 6;
        group.add(leftArm);

        const rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.2 * scale),
          stoneMat
        );
        rightArm.position.set(0.7 * scale, 2.0 * scale, 0);
        rightArm.rotation.z = -Math.PI / 6;
        group.add(rightArm);
        break;

      case 'campfire':
        const logMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const fireMat = new THREE.MeshLambertMaterial({
          color: 0xff6600,
          emissive: 0xff4400,
          emissiveIntensity: 0.9
        });
        const emberMat = new THREE.MeshLambertMaterial({
          color: 0xff2200,
          emissive: 0xff0000,
          emissiveIntensity: 0.7
        });

        // Ring of stones
        for (let i = 0; i < 8; i++) {
          const stone = new THREE.Mesh(
            new THREE.SphereGeometry(0.15 * scale, 6, 4),
            new THREE.MeshLambertMaterial({ color: 0x666666 })
          );
          const angle = (i / 8) * Math.PI * 2;
          stone.position.x = Math.cos(angle) * 0.6 * scale;
          stone.position.z = Math.sin(angle) * 0.6 * scale;
          stone.position.y = 0.1 * scale;
          stone.scale.y = 0.7;
          group.add(stone);
        }

        // Logs in triangle pattern
        for (let i = 0; i < 3; i++) {
          const log = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 1 * scale, 6),
            logMat
          );
          const angle = (i / 3) * Math.PI * 2;
          log.position.x = Math.cos(angle) * 0.2 * scale;
          log.position.z = Math.sin(angle) * 0.2 * scale;
          log.position.y = 0.15 * scale;
          log.rotation.z = Math.PI / 2;
          log.rotation.y = angle;
          group.add(log);
        }

        // Fire core (will be animated)
        const fireCore = new THREE.Mesh(
          new THREE.ConeGeometry(0.25 * scale, 0.8 * scale, 6),
          fireMat
        );
        fireCore.position.y = 0.5 * scale;
        fireCore.name = 'fireCore';
        group.add(fireCore);

        // Inner flame
        const innerFlame = new THREE.Mesh(
          new THREE.ConeGeometry(0.15 * scale, 0.5 * scale, 5),
          new THREE.MeshLambertMaterial({
            color: 0xffaa00,
            emissive: 0xff8800,
            emissiveIntensity: 1.0
          })
        );
        innerFlame.position.y = 0.55 * scale;
        innerFlame.name = 'innerFlame';
        group.add(innerFlame);

        // Embers
        for (let i = 0; i < 5; i++) {
          const ember = new THREE.Mesh(
            new THREE.SphereGeometry(0.04 * scale, 4, 4),
            emberMat
          );
          ember.position.x = (Math.random() - 0.5) * 0.4 * scale;
          ember.position.z = (Math.random() - 0.5) * 0.4 * scale;
          ember.position.y = 0.2 * scale;
          group.add(ember);
        }

        // Point light for fire glow
        const fireLight = new THREE.PointLight(0xff6622, 2, 15);
        fireLight.position.y = 0.8 * scale;
        group.add(fireLight);

        group.userData.animationType = 'flicker';
        group.userData.flickerSpeed = 8;
        break;

      case 'portal_ring':
        const ringMat = new THREE.MeshLambertMaterial({
          color: 0x8866ff,
          emissive: 0x4422cc,
          emissiveIntensity: 0.8
        });
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x555555 });

        // Stone frame pillars
        const leftPillar = new THREE.Mesh(
          new THREE.BoxGeometry(0.4 * scale, 4 * scale, 0.4 * scale),
          frameMat
        );
        leftPillar.position.set(-1.5 * scale, 2 * scale, 0);
        group.add(leftPillar);

        const rightPillar = new THREE.Mesh(
          new THREE.BoxGeometry(0.4 * scale, 4 * scale, 0.4 * scale),
          frameMat
        );
        rightPillar.position.set(1.5 * scale, 2 * scale, 0);
        group.add(rightPillar);

        // Arch top
        const arch = new THREE.Mesh(
          new THREE.TorusGeometry(1.5 * scale, 0.2 * scale, 8, 12, Math.PI),
          frameMat
        );
        arch.position.y = 4 * scale;
        group.add(arch);

        // Glowing inner ring
        const innerRing = new THREE.Mesh(
          new THREE.TorusGeometry(1.2 * scale, 0.08 * scale, 8, 24),
          ringMat
        );
        innerRing.position.y = 2.5 * scale;
        innerRing.name = 'portalRing';
        group.add(innerRing);

        // Swirling energy center (flat disc)
        const portalCenter = new THREE.Mesh(
          new THREE.CircleGeometry(1.1 * scale, 16),
          new THREE.MeshLambertMaterial({
            color: 0xaa88ff,
            emissive: 0x6644cc,
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
          })
        );
        portalCenter.position.y = 2.5 * scale;
        portalCenter.name = 'portalCenter';
        group.add(portalCenter);

        group.userData.animationType = 'portal';
        group.userData.spinSpeed = 0.5;
        break;

      case 'signpost':
        const postMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
        const signMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Post
        const signPost = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * scale, 0.08 * scale, 2.5 * scale, 6),
          postMat
        );
        signPost.position.y = 1.25 * scale;
        group.add(signPost);

        // Directional signs (angled boards)
        const signAngles = [0, Math.PI / 3, -Math.PI / 4];
        const signColors = [0x9b7924, 0x8b6914, 0x7b5904];
        signAngles.forEach(function(angle, i) {
          var signBoard = new THREE.Mesh(
            new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.05 * scale),
            new THREE.MeshLambertMaterial({ color: signColors[i] })
          );
          signBoard.position.y = (2.0 - i * 0.35) * scale;
          signBoard.position.x = 0.3 * scale;
          signBoard.rotation.y = angle;
          group.add(signBoard);
        });
        break;

      case 'gazebo':
        const gazeboWoodMat = new THREE.MeshLambertMaterial({ color: 0xc9a96e });
        const gazeboRoofMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });

        // Floor platform
        const floor = new THREE.Mesh(
          new THREE.CylinderGeometry(2.5 * scale, 2.5 * scale, 0.2 * scale, 8),
          gazeboWoodMat
        );
        floor.position.y = 0.3 * scale;
        group.add(floor);

        // 6 pillars
        for (let i = 0; i < 6; i++) {
          const gazeboPillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1 * scale, 0.1 * scale, 2.5 * scale, 6),
            gazeboWoodMat
          );
          const pAngle = (i / 6) * Math.PI * 2;
          gazeboPillar.position.x = Math.cos(pAngle) * 2.2 * scale;
          gazeboPillar.position.z = Math.sin(pAngle) * 2.2 * scale;
          gazeboPillar.position.y = 1.55 * scale;
          group.add(gazeboPillar);
        }

        // Conical roof
        const gazeboRoof = new THREE.Mesh(
          new THREE.ConeGeometry(3 * scale, 1.5 * scale, 8),
          gazeboRoofMat
        );
        gazeboRoof.position.y = 3.6 * scale;
        group.add(gazeboRoof);

        // Railing sections between pillars
        for (let i = 0; i < 6; i++) {
          if (i === 0) continue; // Leave one gap for entrance
          const a1 = (i / 6) * Math.PI * 2;
          const a2 = ((i + 1) / 6) * Math.PI * 2;
          const midAngle = (a1 + a2) / 2;
          const railing = new THREE.Mesh(
            new THREE.BoxGeometry(1.5 * scale, 0.1 * scale, 0.08 * scale),
            gazeboWoodMat
          );
          railing.position.x = Math.cos(midAngle) * 2.2 * scale;
          railing.position.z = Math.sin(midAngle) * 2.2 * scale;
          railing.position.y = 0.8 * scale;
          railing.rotation.y = midAngle + Math.PI / 2;
          group.add(railing);
        }
        break;
    }

    return group;
  }

  // ========================================
  // RESOURCE NODE GENERATORS
  // ========================================

  function createResourceNode(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'resource_' + type;
    group.userData.isResource = true;
    group.userData.resourceType = type;

    switch(type) {
      case 'ore_vein':
        const oreMat = new THREE.MeshLambertMaterial({ color: 0x8a7b6b });
        const oreGlintMat = new THREE.MeshLambertMaterial({
          color: 0xccaa66,
          emissive: 0x886622,
          emissiveIntensity: 0.4
        });

        // Base rock
        const oreRock = new THREE.Mesh(
          new THREE.DodecahedronGeometry(0.7 * scale, 0),
          oreMat
        );
        oreRock.position.y = 0.4 * scale;
        oreRock.scale.y = 0.6;
        group.add(oreRock);

        // Metallic veins (small shiny patches)
        for (let i = 0; i < 4; i++) {
          const vein = new THREE.Mesh(
            new THREE.SphereGeometry(0.12 * scale, 6, 4),
            oreGlintMat
          );
          const angle = (i / 4) * Math.PI * 2 + Math.random();
          vein.position.x = Math.cos(angle) * 0.4 * scale;
          vein.position.z = Math.sin(angle) * 0.4 * scale;
          vein.position.y = (0.3 + Math.random() * 0.3) * scale;
          group.add(vein);
        }

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 0.8;
        break;

      case 'crystal_cluster':
        const crystalColors = [0x88aaff, 0xaa88ff, 0x66ccff, 0xcc88ff];

        // Several upward-pointing crystals
        for (let i = 0; i < 5; i++) {
          const crystalHeight = (0.5 + Math.random() * 1.0) * scale;
          const crystalRadius = (0.08 + Math.random() * 0.12) * scale;
          const crystal = new THREE.Mesh(
            new THREE.ConeGeometry(crystalRadius, crystalHeight, 6),
            new THREE.MeshLambertMaterial({
              color: crystalColors[i % crystalColors.length],
              emissive: crystalColors[i % crystalColors.length],
              emissiveIntensity: 0.3,
              transparent: true,
              opacity: 0.85
            })
          );
          const angle = (i / 5) * Math.PI * 2;
          const rad = 0.2 * scale;
          crystal.position.x = Math.cos(angle) * rad;
          crystal.position.z = Math.sin(angle) * rad;
          crystal.position.y = crystalHeight / 2;
          // Slight random tilt
          crystal.rotation.x = (Math.random() - 0.5) * 0.3;
          crystal.rotation.z = (Math.random() - 0.5) * 0.3;
          group.add(crystal);
        }

        // Glow light
        const crystalLight = new THREE.PointLight(0x8888ff, 0.8, 8);
        crystalLight.position.y = 0.5 * scale;
        group.add(crystalLight);

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 1.2;
        break;

      case 'herb_patch':
        const stemMat = new THREE.MeshLambertMaterial({ color: 0x2d7a2d });
        const flowerColors = [0xff88aa, 0xffaa44, 0xaa88ff, 0x88ffaa];

        // Cluster of small herb plants
        for (let i = 0; i < 6; i++) {
          const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02 * scale, 0.02 * scale, 0.4 * scale, 4),
            stemMat
          );
          const angle = (i / 6) * Math.PI * 2;
          const rad = 0.3 * scale;
          stem.position.x = Math.cos(angle) * rad;
          stem.position.z = Math.sin(angle) * rad;
          stem.position.y = 0.2 * scale;
          group.add(stem);

          // Tiny flower/leaf at top
          const flower = new THREE.Mesh(
            new THREE.SphereGeometry(0.06 * scale, 6, 4),
            new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] })
          );
          flower.position.x = stem.position.x;
          flower.position.z = stem.position.z;
          flower.position.y = 0.42 * scale;
          group.add(flower);
        }

        // Ground cover leaves
        const leafMat = new THREE.MeshLambertMaterial({ color: 0x3a8a3a });
        const leafGround = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 0.05 * scale, 8),
          leafMat
        );
        leafGround.position.y = 0.02 * scale;
        group.add(leafGround);

        group.userData.animationType = 'sway';
        group.userData.swayAmount = 0.03;
        group.userData.swaySpeed = 1.5;
        break;

      case 'flower_bed':
        const fStemMat = new THREE.MeshLambertMaterial({ color: 0x2d7a2d });
        const petalColors = [0xff4488, 0xff88cc, 0xffaa66, 0xffff44, 0xff6644];

        // Flowers in a cluster
        for (let i = 0; i < 8; i++) {
          const fStem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015 * scale, 0.02 * scale, 0.5 * scale, 4),
            fStemMat
          );
          const angle = Math.random() * Math.PI * 2;
          const rad = Math.random() * 0.5 * scale;
          fStem.position.x = Math.cos(angle) * rad;
          fStem.position.z = Math.sin(angle) * rad;
          fStem.position.y = 0.25 * scale;
          // Slight random lean
          fStem.rotation.x = (Math.random() - 0.5) * 0.15;
          fStem.rotation.z = (Math.random() - 0.5) * 0.15;
          group.add(fStem);

          // Flower head (small sphere cluster)
          const flowerHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.08 * scale, 6, 4),
            new THREE.MeshLambertMaterial({
              color: petalColors[Math.floor(Math.random() * petalColors.length)]
            })
          );
          flowerHead.position.set(fStem.position.x, 0.52 * scale, fStem.position.z);
          group.add(flowerHead);
        }

        group.userData.animationType = 'sway';
        group.userData.swayAmount = 0.02;
        group.userData.swaySpeed = 2;
        break;

      case 'wood_pile':
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
        const barkMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

        // Stack of logs
        var logCount = 0;
        for (let row = 0; row < 3; row++) {
          var logsInRow = 3 - row;
          for (let i = 0; i < logsInRow; i++) {
            const log = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12 * scale, 0.12 * scale, 1.0 * scale, 6),
              row % 2 === 0 ? woodMat : barkMat
            );
            log.rotation.z = Math.PI / 2;
            log.position.x = (i - (logsInRow - 1) / 2) * 0.26 * scale;
            log.position.y = (0.12 + row * 0.22) * scale;
            log.position.z = ((logCount % 2) * 0.05 - 0.025) * scale;
            group.add(log);
            logCount++;
          }
        }
        break;
    }

    return group;
  }

  // ========================================
  // MORE CREATURE GENERATORS
  // ========================================

  function createWildlife(type) {
    const group = new THREE.Group();
    group.name = 'wildlife_' + type;

    switch(type) {
      case 'deer':
        const deerBodyMat = new THREE.MeshLambertMaterial({ color: 0xb8860b });
        const deerLegMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Body
        const deerBody = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.35, 0.8),
          deerBodyMat
        );
        deerBody.position.y = 0.7;
        group.add(deerBody);

        // Head
        const deerHead = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.25),
          deerBodyMat
        );
        deerHead.position.set(0, 0.95, 0.4);
        group.add(deerHead);

        // Antlers
        const antlerMat = new THREE.MeshLambertMaterial({ color: 0xd2b48c });
        for (let side = -1; side <= 1; side += 2) {
          const antler = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4),
            antlerMat
          );
          antler.position.set(side * 0.1, 1.15, 0.4);
          antler.rotation.z = side * Math.PI / 6;
          group.add(antler);

          // Antler branch
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.015, 0.15, 4),
            antlerMat
          );
          branch.position.set(side * 0.2, 1.25, 0.4);
          branch.rotation.z = side * Math.PI / 4;
          group.add(branch);
        }

        // Legs
        var legPositions = [
          { x: -0.12, z: 0.25 }, { x: 0.12, z: 0.25 },
          { x: -0.12, z: -0.25 }, { x: 0.12, z: -0.25 }
        ];
        legPositions.forEach(function(pos) {
          var leg = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.03, 0.5, 6),
            deerLegMat
          );
          leg.position.set(pos.x, 0.3, pos.z);
          group.add(leg);
        });

        // Tail (small white triangle)
        const tailMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const deerTail = new THREE.Mesh(
          new THREE.ConeGeometry(0.05, 0.1, 4),
          tailMat
        );
        deerTail.position.set(0, 0.75, -0.45);
        deerTail.rotation.x = -Math.PI / 4;
        group.add(deerTail);

        group.userData.animationType = 'idle_look';
        group.scale.set(1.5, 1.5, 1.5);
        break;

      case 'rabbit':
        const rabbitMat = new THREE.MeshLambertMaterial({ color: 0xd2b48c });

        // Body
        const rabbitBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 8, 6),
          rabbitMat
        );
        rabbitBody.position.y = 0.2;
        rabbitBody.scale.z = 1.3;
        group.add(rabbitBody);

        // Head
        const rabbitHead = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 6),
          rabbitMat
        );
        rabbitHead.position.set(0, 0.3, 0.15);
        group.add(rabbitHead);

        // Ears
        const earMat = new THREE.MeshLambertMaterial({ color: 0xc4a882 });
        for (let side = -1; side <= 1; side += 2) {
          const ear = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, 0.15, 0.05),
            earMat
          );
          ear.position.set(side * 0.05, 0.45, 0.15);
          ear.rotation.z = side * 0.2;
          group.add(ear);
        }

        // Fluffy tail
        const puffTail = new THREE.Mesh(
          new THREE.SphereGeometry(0.06, 6, 4),
          new THREE.MeshLambertMaterial({ color: 0xeeeeee })
        );
        puffTail.position.set(0, 0.2, -0.2);
        group.add(puffTail);

        group.userData.animationType = 'hop';
        group.userData.hopInterval = 3;
        group.userData.hopTimer = Math.random() * 3;
        break;

      case 'firefly':
        const ffBodyMat = new THREE.MeshLambertMaterial({ color: 0x333300 });
        const ffGlowMat = new THREE.MeshLambertMaterial({
          color: 0xffff44,
          emissive: 0xaacc00,
          emissiveIntensity: 1.0
        });

        // Tiny body
        const ffBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 6, 4),
          ffBodyMat
        );
        group.add(ffBody);

        // Glowing abdomen
        const ffGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 6, 4),
          ffGlowMat
        );
        ffGlow.position.z = -0.04;
        ffGlow.name = 'glow';
        group.add(ffGlow);

        // Tiny point light
        const ffLight = new THREE.PointLight(0xaacc00, 0.5, 4);
        ffLight.position.z = -0.04;
        group.add(ffLight);

        group.userData.animationType = 'float';
        group.userData.floatSpeed = 0.5 + Math.random() * 0.5;
        group.userData.floatRadius = 1 + Math.random() * 2;
        group.userData.floatAngle = Math.random() * Math.PI * 2;
        group.userData.floatHeight = 1.5 + Math.random();
        break;

      case 'frog':
        const frogMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
        const frogEyeMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });

        // Body
        const frogBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 8, 6),
          frogMat
        );
        frogBody.position.y = 0.1;
        frogBody.scale.y = 0.7;
        frogBody.scale.z = 1.2;
        group.add(frogBody);

        // Eyes (protruding)
        for (let side = -1; side <= 1; side += 2) {
          const eye = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 6, 4),
            frogEyeMat
          );
          eye.position.set(side * 0.06, 0.18, 0.08);
          group.add(eye);
        }

        // Back legs
        for (let side = -1; side <= 1; side += 2) {
          const backLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.04, 0.15),
            frogMat
          );
          backLeg.position.set(side * 0.1, 0.05, -0.12);
          group.add(backLeg);
        }

        group.userData.animationType = 'hop';
        group.userData.hopInterval = 5;
        group.userData.hopTimer = Math.random() * 5;
        break;
    }

    return group;
  }

  // ========================================
  // ANIMATION SYSTEM
  // ========================================

  function animateModel(model, deltaTime, worldTime) {
    if (!model.userData.animationType || model.userData.animationType === 'none') {
      return;
    }

    const type = model.userData.animationType;

    switch(type) {
      case 'sway':
        // Gentle tree sway
        const swayAmount = model.userData.swayAmount || 0.05;
        const swaySpeed = model.userData.swaySpeed || 1.0;
        model.rotation.z = Math.sin(worldTime * swaySpeed) * swayAmount;
        model.rotation.x = Math.cos(worldTime * swaySpeed * 0.7) * swayAmount * 0.5;
        break;

      case 'flap':
        // Wing flapping for butterflies/birds
        const flapSpeed = model.userData.flapSpeed || 8;
        const flapAmount = model.userData.flapAmount || Math.PI / 4;
        const flapAngle = Math.sin(worldTime * flapSpeed) * flapAmount;

        const leftWing = model.getObjectByName('leftWing');
        const rightWing = model.getObjectByName('rightWing');

        if (leftWing) {
          leftWing.rotation.y = flapAngle;
        }
        if (rightWing) {
          rightWing.rotation.y = -flapAngle;
        }
        break;

      case 'swim':
        // Circular swimming motion
        const swimSpeed = model.userData.swimSpeed || 1;
        const swimRadius = model.userData.swimRadius || 2;

        model.userData.swimAngle = (model.userData.swimAngle || 0) + deltaTime * swimSpeed;

        const centerX = model.userData.swimCenterX || 0;
        const centerZ = model.userData.swimCenterZ || 0;

        model.position.x = centerX + Math.cos(model.userData.swimAngle) * swimRadius;
        model.position.z = centerZ + Math.sin(model.userData.swimAngle) * swimRadius;
        model.rotation.y = model.userData.swimAngle + Math.PI / 2;
        break;

      case 'bob':
        // Vertical bobbing motion
        const bobSpeed = model.userData.bobSpeed || 1.5;
        const bobAmount = model.userData.bobAmount || 0.2;
        const baseY = model.userData.baseY || model.position.y;

        if (model.userData.baseY === undefined) {
          model.userData.baseY = model.position.y;
        }

        model.position.y = baseY + Math.sin(worldTime * bobSpeed) * bobAmount;
        break;

      case 'spin':
        // Slow rotation around Y axis
        const spinSpeed = model.userData.spinSpeed || 0.5;
        model.rotation.y += deltaTime * spinSpeed;
        break;

      case 'pulse':
        // Pulsating glow (scale throb)
        var pulseSpeed = model.userData.pulseSpeed || 1.5;
        var pulseVal = 1 + Math.sin(worldTime * pulseSpeed) * 0.08;
        model.scale.set(pulseVal, pulseVal, pulseVal);
        break;

      case 'flicker':
        // Fire flicker animation
        var flickerSpeed = model.userData.flickerSpeed || 8;
        var fireCore = model.getObjectByName('fireCore');
        var innerFlame = model.getObjectByName('innerFlame');
        if (fireCore) {
          fireCore.scale.x = 0.8 + Math.sin(worldTime * flickerSpeed) * 0.3;
          fireCore.scale.z = 0.8 + Math.cos(worldTime * flickerSpeed * 1.3) * 0.3;
          fireCore.scale.y = 0.9 + Math.sin(worldTime * flickerSpeed * 0.7) * 0.2;
          fireCore.position.y = 0.5 + Math.sin(worldTime * flickerSpeed * 1.1) * 0.05;
        }
        if (innerFlame) {
          innerFlame.scale.x = 0.7 + Math.cos(worldTime * flickerSpeed * 1.5) * 0.4;
          innerFlame.scale.z = 0.7 + Math.sin(worldTime * flickerSpeed * 0.9) * 0.4;
          innerFlame.rotation.y += deltaTime * 2;
        }
        break;

      case 'fountain':
        // Water drop bouncing animation
        var waterDrop = model.getObjectByName('waterDrop');
        if (waterDrop) {
          var fountainCycle = worldTime * 2;
          var dropPhase = fountainCycle % 2;
          if (dropPhase < 1) {
            waterDrop.position.y = 2.5 + dropPhase * 0.5;
            waterDrop.scale.set(1, 1, 1);
          } else {
            waterDrop.position.y = 3.0 - (dropPhase - 1) * 0.8;
            var shrink = 1 - (dropPhase - 1) * 0.5;
            waterDrop.scale.set(shrink, shrink, shrink);
          }
        }
        break;

      case 'portal':
        // Rotating portal ring + wobbling center
        var portalRing = model.getObjectByName('portalRing');
        var portalCenter = model.getObjectByName('portalCenter');
        if (portalRing) {
          portalRing.rotation.z += deltaTime * 0.5;
        }
        if (portalCenter) {
          portalCenter.rotation.z -= deltaTime * 0.3;
          var opacity = 0.3 + Math.sin(worldTime * 1.5) * 0.2;
          if (portalCenter.material) {
            portalCenter.material.opacity = opacity;
          }
        }
        break;

      case 'float':
        // Floating in a gentle path (for fireflies)
        var floatSpeed = model.userData.floatSpeed || 0.5;
        var floatRadius = model.userData.floatRadius || 2;
        var floatHeight = model.userData.floatHeight || 2;

        model.userData.floatAngle = (model.userData.floatAngle || 0) + deltaTime * floatSpeed;
        var fAngle = model.userData.floatAngle;

        if (model.userData.floatCenterX === undefined) {
          model.userData.floatCenterX = model.position.x;
          model.userData.floatCenterZ = model.position.z;
        }

        model.position.x = model.userData.floatCenterX + Math.cos(fAngle) * floatRadius;
        model.position.z = model.userData.floatCenterZ + Math.sin(fAngle * 0.7) * floatRadius;
        model.position.y = floatHeight + Math.sin(fAngle * 1.3) * 0.5;
        break;

      case 'hop':
        // Occasional hopping for rabbits/frogs
        model.userData.hopTimer = (model.userData.hopTimer || 0) - deltaTime;
        if (model.userData.hopTimer <= 0) {
          model.userData.hopTimer = model.userData.hopInterval || 3;
          model.userData.isHopping = true;
          model.userData.hopPhase = 0;
          // Pick random direction
          model.userData.hopDirX = (Math.random() - 0.5) * 2;
          model.userData.hopDirZ = (Math.random() - 0.5) * 2;
        }
        if (model.userData.isHopping) {
          model.userData.hopPhase += deltaTime * 4;
          if (model.userData.hopPhase < Math.PI) {
            var hopHeight = Math.sin(model.userData.hopPhase) * 0.3;
            if (model.userData.baseHopY === undefined) {
              model.userData.baseHopY = model.position.y;
            }
            model.position.y = model.userData.baseHopY + hopHeight;
            model.position.x += model.userData.hopDirX * deltaTime;
            model.position.z += model.userData.hopDirZ * deltaTime;
          } else {
            model.position.y = model.userData.baseHopY || model.position.y;
            model.userData.isHopping = false;
          }
        }
        break;

      case 'idle_look':
        // Gentle head turning for deer
        model.rotation.y = Math.sin(worldTime * 0.3) * 0.3;
        break;
    }
  }

  // ========================================
  // GROUND COVER â€” Grass, mushrooms, bushes, fallen logs
  // ========================================

  function createGrassPatch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'grass_patch';
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.03;
    group.userData.swaySpeed = 2.0;

    var grassColors = [0x4a8028, 0x3a6b1f, 0x5a9030, 0x2d5016, 0x68a840];

    // 8-12 grass blades in a cluster
    var bladeCount = 8 + Math.floor(Math.random() * 5);
    for (var i = 0; i < bladeCount; i++) {
      var bladeHeight = (0.3 + Math.random() * 0.4) * scale;
      var bladeGeo = new THREE.PlaneGeometry(0.04 * scale, bladeHeight);
      var bladeMat = new THREE.MeshLambertMaterial({
        color: grassColors[Math.floor(Math.random() * grassColors.length)],
        side: THREE.DoubleSide
      });
      var blade = new THREE.Mesh(bladeGeo, bladeMat);

      var angle = (i / bladeCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
      var radius = Math.random() * 0.3 * scale;
      blade.position.x = Math.cos(angle) * radius;
      blade.position.z = Math.sin(angle) * radius;
      blade.position.y = bladeHeight * 0.5;
      blade.rotation.y = Math.random() * Math.PI;
      blade.rotation.z = (Math.random() - 0.5) * 0.3;
      group.add(blade);
    }

    return group;
  }

  function createMushroom(type, scale) {
    scale = scale || 1;
    type = type || 'red';
    var group = new THREE.Group();
    group.name = 'mushroom_' + type;

    var stemMat = new THREE.MeshLambertMaterial({ color: 0xf5deb3 });
    var capColors = {
      red: 0xcc3333,
      brown: 0x8b6914,
      white: 0xf0f0e0,
      purple: 0x9966cc,
      glowing: 0x66ffcc
    };
    var capColor = capColors[type] || capColors.red;

    // Main mushroom
    var stem = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.05 * scale, 0.2 * scale, 6),
      stemMat
    );
    stem.position.y = 0.1 * scale;
    group.add(stem);

    var capMat = new THREE.MeshLambertMaterial({ color: capColor });
    if (type === 'glowing') {
      capMat = new THREE.MeshBasicMaterial({ color: capColor });
    }
    var cap = new THREE.Mesh(
      new THREE.SphereGeometry(0.1 * scale, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.6),
      capMat
    );
    cap.position.y = 0.2 * scale;
    group.add(cap);

    // Add spots to red/purple mushrooms
    if (type === 'red' || type === 'purple') {
      for (var s = 0; s < 4; s++) {
        var spot = new THREE.Mesh(
          new THREE.CircleGeometry(0.015 * scale, 6),
          new THREE.MeshLambertMaterial({ color: 0xffffff })
        );
        var sAngle = (s / 4) * Math.PI * 2;
        spot.position.x = Math.cos(sAngle) * 0.07 * scale;
        spot.position.z = Math.sin(sAngle) * 0.07 * scale;
        spot.position.y = 0.23 * scale;
        spot.rotation.x = -Math.PI * 0.3;
        spot.rotation.y = sAngle;
        group.add(spot);
      }
    }

    // Add 1-2 smaller mushrooms next to main
    for (var m = 0; m < 1 + Math.floor(Math.random() * 2); m++) {
      var smallScale = 0.5 + Math.random() * 0.3;
      var smallStem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03 * scale * smallScale, 0.04 * scale * smallScale, 0.15 * scale * smallScale, 6),
        stemMat
      );
      var mAngle = Math.random() * Math.PI * 2;
      var mDist = 0.1 + Math.random() * 0.1;
      smallStem.position.x = Math.cos(mAngle) * mDist * scale;
      smallStem.position.z = Math.sin(mAngle) * mDist * scale;
      smallStem.position.y = 0.075 * scale * smallScale;
      group.add(smallStem);

      var smallCap = new THREE.Mesh(
        new THREE.SphereGeometry(0.07 * scale * smallScale, 6, 5, 0, Math.PI * 2, 0, Math.PI * 0.6),
        capMat
      );
      smallCap.position.x = smallStem.position.x;
      smallCap.position.z = smallStem.position.z;
      smallCap.position.y = 0.15 * scale * smallScale;
      group.add(smallCap);
    }

    // Add glow light for glowing mushrooms
    if (type === 'glowing') {
      var glow = new THREE.PointLight(0x66ffcc, 0.5, 3 * scale);
      glow.position.y = 0.2 * scale;
      group.add(glow);
      group.userData.animationType = 'pulse';
    }

    return group;
  }

  function createBush(type, scale) {
    scale = scale || 1;
    type = type || 'green';
    var group = new THREE.Group();
    group.name = 'bush_' + type;
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.02;
    group.userData.swaySpeed = 0.8;

    var bushColors = {
      green: [0x2d5016, 0x3a6b1f, 0x4a8028],
      flowering: [0x3a6b1f, 0x4a8028, 0x5a9030],
      berry: [0x2d5016, 0x3a6b1f],
      autumn: [0xcc6600, 0xdd8800, 0xaa4400]
    };

    var colors = bushColors[type] || bushColors.green;

    // 4-6 overlapping spheres for bushy appearance
    var clumpCount = 4 + Math.floor(Math.random() * 3);
    for (var i = 0; i < clumpCount; i++) {
      var clumpSize = (0.25 + Math.random() * 0.2) * scale;
      var clump = new THREE.Mesh(
        new THREE.SphereGeometry(clumpSize, 6, 5),
        new THREE.MeshLambertMaterial({
          color: colors[Math.floor(Math.random() * colors.length)]
        })
      );
      var cAngle = (i / clumpCount) * Math.PI * 2 + Math.random() * 0.5;
      var cRadius = 0.15 * scale;
      clump.position.x = Math.cos(cAngle) * cRadius;
      clump.position.z = Math.sin(cAngle) * cRadius;
      clump.position.y = clumpSize * 0.7;
      group.add(clump);
    }

    // Add flowers to flowering bushes
    if (type === 'flowering') {
      var flowerColors = [0xff6699, 0xffcc00, 0xff9933, 0xcc66ff, 0xff3366];
      for (var f = 0; f < 5 + Math.floor(Math.random() * 4); f++) {
        var flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.04 * scale, 5, 4),
          new THREE.MeshLambertMaterial({
            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
          })
        );
        var fAngle = Math.random() * Math.PI * 2;
        var fRadius = Math.random() * 0.35 * scale;
        flower.position.x = Math.cos(fAngle) * fRadius;
        flower.position.z = Math.sin(fAngle) * fRadius;
        flower.position.y = 0.3 * scale + Math.random() * 0.15 * scale;
        group.add(flower);
      }
    }

    // Add berries to berry bushes
    if (type === 'berry') {
      for (var b = 0; b < 6 + Math.floor(Math.random() * 5); b++) {
        var berry = new THREE.Mesh(
          new THREE.SphereGeometry(0.025 * scale, 5, 4),
          new THREE.MeshLambertMaterial({ color: 0xcc0033 })
        );
        var bAngle = Math.random() * Math.PI * 2;
        var bRadius = Math.random() * 0.3 * scale;
        berry.position.x = Math.cos(bAngle) * bRadius;
        berry.position.z = Math.sin(bAngle) * bRadius;
        berry.position.y = 0.2 * scale + Math.random() * 0.2 * scale;
        group.add(berry);
      }
    }

    return group;
  }

  function createFallenLog(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'fallen_log';

    var barkMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
    var innerMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });

    // Main log body (laid on side)
    var log = new THREE.Mesh(
      new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 2.5 * scale, 8),
      barkMat
    );
    log.rotation.z = Math.PI / 2;
    log.position.y = 0.15 * scale;
    group.add(log);

    // Cross-section ring at one end
    var ring = new THREE.Mesh(
      new THREE.CircleGeometry(0.15 * scale, 8),
      innerMat
    );
    ring.position.x = 1.25 * scale;
    ring.position.y = 0.15 * scale;
    ring.rotation.y = Math.PI / 2;
    group.add(ring);

    // Small moss patches on top
    var mossMat = new THREE.MeshLambertMaterial({ color: 0x4a8028 });
    for (var i = 0; i < 3; i++) {
      var moss = new THREE.Mesh(
        new THREE.SphereGeometry(0.08 * scale, 5, 4, 0, Math.PI * 2, 0, Math.PI * 0.5),
        mossMat
      );
      moss.position.x = (Math.random() - 0.5) * 1.5 * scale;
      moss.position.y = 0.28 * scale;
      moss.position.z = (Math.random() - 0.5) * 0.1 * scale;
      group.add(moss);
    }

    // Optional small mushroom growing on it
    if (Math.random() < 0.5) {
      var logMushroom = createMushroom('brown', scale * 0.4);
      logMushroom.position.x = (Math.random() - 0.5) * scale;
      logMushroom.position.y = 0.3 * scale;
      group.add(logMushroom);
    }

    return group;
  }

  // ========================================
  // ZONE ARCHITECTURE â€” Detailed structures for each zone
  // ========================================

  function createRuinWall(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'ruin_wall';

    var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8378 });
    var mossyMat = new THREE.MeshLambertMaterial({ color: 0x6b7c5a });

    // Main wall section (irregular top edge simulated by stacked blocks)
    var wallBase = new THREE.Mesh(
      new THREE.BoxGeometry(4 * scale, 2 * scale, 0.5 * scale),
      stoneMat
    );
    wallBase.position.y = 1 * scale;
    group.add(wallBase);

    // Irregular top blocks (ruined look)
    var topHeights = [0.8, 1.2, 0.4, 1.0, 0.6, 0.9, 0.3];
    for (var i = 0; i < topHeights.length; i++) {
      var blockW = (4 / topHeights.length) * scale;
      var blockH = topHeights[i] * scale;
      var mat = Math.random() < 0.3 ? mossyMat : stoneMat;
      var block = new THREE.Mesh(
        new THREE.BoxGeometry(blockW * 0.9, blockH, 0.5 * scale),
        mat
      );
      block.position.x = (i - topHeights.length / 2 + 0.5) * blockW;
      block.position.y = 2 * scale + blockH / 2;
      group.add(block);
    }

    // Moss patches at base
    for (var m = 0; m < 4; m++) {
      var moss = new THREE.Mesh(
        new THREE.SphereGeometry(0.15 * scale, 5, 4, 0, Math.PI * 2, 0, Math.PI * 0.5),
        mossyMat
      );
      moss.position.x = (Math.random() - 0.5) * 3.5 * scale;
      moss.position.y = 0.05 * scale;
      moss.position.z = 0.2 * scale;
      group.add(moss);
    }

    return group;
  }

  function createColumnRow(count, height, spacing, scale) {
    scale = scale || 1;
    count = count || 4;
    height = height || 4;
    spacing = spacing || 2;
    var group = new THREE.Group();
    group.name = 'column_row';

    var columnMat = new THREE.MeshPhongMaterial({ color: 0xd4c8b0 });
    var capMat = new THREE.MeshPhongMaterial({ color: 0xc8bca0 });

    for (var i = 0; i < count; i++) {
      // Column shaft
      var shaft = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, height * scale, 8),
        columnMat
      );
      shaft.position.x = (i - (count - 1) / 2) * spacing * scale;
      shaft.position.y = height * scale / 2;
      group.add(shaft);

      // Base
      var base = new THREE.Mesh(
        new THREE.BoxGeometry(0.6 * scale, 0.15 * scale, 0.6 * scale),
        capMat
      );
      base.position.x = shaft.position.x;
      base.position.y = 0.075 * scale;
      group.add(base);

      // Capital
      var capital = new THREE.Mesh(
        new THREE.BoxGeometry(0.55 * scale, 0.12 * scale, 0.55 * scale),
        capMat
      );
      capital.position.x = shaft.position.x;
      capital.position.y = height * scale + 0.06 * scale;
      group.add(capital);
    }

    // Architrave (beam across top)
    var beam = new THREE.Mesh(
      new THREE.BoxGeometry((count - 1) * spacing * scale + 0.8 * scale, 0.2 * scale, 0.5 * scale),
      capMat
    );
    beam.position.y = height * scale + 0.22 * scale;
    group.add(beam);

    return group;
  }

  function createAmphitheater(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'amphitheater';

    var seatMat = new THREE.MeshLambertMaterial({ color: 0xa09080 });
    var stageMat = new THREE.MeshLambertMaterial({ color: 0xd4c090 });

    // Tiered seating (semicircular)
    for (var tier = 0; tier < 5; tier++) {
      var innerR = (3 + tier * 1.5) * scale;
      var outerR = innerR + 1.2 * scale;
      var seatHeight = (0.4 + tier * 0.5) * scale;

      // Use a ring of boxes to approximate the arc
      var segments = 12;
      for (var s = 0; s < segments; s++) {
        var angle = (s / segments) * Math.PI - Math.PI / 2; // semicircle
        var midR = (innerR + outerR) / 2;
        var seat = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 * scale, 0.3 * scale, 1.0 * scale),
          seatMat
        );
        seat.position.x = Math.cos(angle) * midR;
        seat.position.z = Math.sin(angle) * midR;
        seat.position.y = seatHeight;
        seat.rotation.y = -angle + Math.PI / 2;
        group.add(seat);
      }
    }

    // Stage platform
    var stage = new THREE.Mesh(
      new THREE.CylinderGeometry(2.5 * scale, 2.5 * scale, 0.3 * scale, 16, 1, false, 0, Math.PI),
      stageMat
    );
    stage.position.y = 0.15 * scale;
    group.add(stage);

    // Stage backdrop columns
    for (var c = -1; c <= 1; c++) {
      var col = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 3 * scale, 6),
        new THREE.MeshPhongMaterial({ color: 0xc8b890 })
      );
      col.position.x = c * 2 * scale;
      col.position.y = 1.5 * scale;
      col.position.z = -0.5 * scale;
      group.add(col);
    }

    return group;
  }

  function createWishingWell(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'wishing_well';

    var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
    var roofMat = new THREE.MeshLambertMaterial({ color: 0x5a3e2b });
    var waterMat = new THREE.MeshPhongMaterial({ color: 0x2244aa, transparent: true, opacity: 0.6 });

    // Stone wall (ring)
    var wallOuter = new THREE.Mesh(
      new THREE.CylinderGeometry(0.8 * scale, 0.85 * scale, 0.7 * scale, 12),
      stoneMat
    );
    wallOuter.position.y = 0.35 * scale;
    group.add(wallOuter);

    // Water inside
    var water = new THREE.Mesh(
      new THREE.CylinderGeometry(0.65 * scale, 0.65 * scale, 0.05 * scale, 12),
      waterMat
    );
    water.position.y = 0.5 * scale;
    group.add(water);

    // Support posts
    for (var p = 0; p < 2; p++) {
      var post = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06 * scale, 0.06 * scale, 1.8 * scale, 6),
        roofMat
      );
      post.position.x = (p === 0 ? -0.6 : 0.6) * scale;
      post.position.y = 1.2 * scale;
      group.add(post);
    }

    // Crossbeam
    var beam = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.04 * scale, 1.3 * scale, 6),
      roofMat
    );
    beam.rotation.z = Math.PI / 2;
    beam.position.y = 2.1 * scale;
    group.add(beam);

    // Small roof
    var roof = new THREE.Mesh(
      new THREE.ConeGeometry(0.9 * scale, 0.5 * scale, 4),
      roofMat
    );
    roof.position.y = 2.45 * scale;
    roof.rotation.y = Math.PI / 4;
    group.add(roof);

    // Bucket (hanging)
    var bucket = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1 * scale, 0.08 * scale, 0.15 * scale, 8, 1, true),
      new THREE.MeshLambertMaterial({ color: 0x654321, side: THREE.DoubleSide })
    );
    bucket.position.y = 1.5 * scale;
    group.add(bucket);

    group.userData.animationType = 'bob';
    group.userData.bobSpeed = 0.5;
    group.userData.bobAmount = 0.02;

    return group;
  }

  function createBookshelf(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'bookshelf';

    var woodMat = new THREE.MeshLambertMaterial({ color: 0x5c3a1e });
    var bookColors = [0x8b0000, 0x00008b, 0x006400, 0x8b4513, 0x4b0082, 0xb8860b, 0x2f4f4f];

    // Frame
    // Back panel
    var back = new THREE.Mesh(
      new THREE.BoxGeometry(1.5 * scale, 2.2 * scale, 0.05 * scale),
      woodMat
    );
    back.position.y = 1.1 * scale;
    back.position.z = -0.15 * scale;
    group.add(back);

    // Sides
    for (var side = -1; side <= 1; side += 2) {
      var sidePanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.05 * scale, 2.2 * scale, 0.35 * scale),
        woodMat
      );
      sidePanel.position.x = side * 0.75 * scale;
      sidePanel.position.y = 1.1 * scale;
      group.add(sidePanel);
    }

    // Shelves (4 levels)
    for (var shelf = 0; shelf < 5; shelf++) {
      var shelfBoard = new THREE.Mesh(
        new THREE.BoxGeometry(1.5 * scale, 0.04 * scale, 0.35 * scale),
        woodMat
      );
      shelfBoard.position.y = shelf * 0.55 * scale;
      group.add(shelfBoard);

      // Books on each shelf (except top)
      if (shelf < 4) {
        var bookCount = 5 + Math.floor(Math.random() * 4);
        var xPos = -0.6 * scale;
        for (var b = 0; b < bookCount && xPos < 0.6 * scale; b++) {
          var bookW = (0.06 + Math.random() * 0.08) * scale;
          var bookH = (0.35 + Math.random() * 0.15) * scale;
          var book = new THREE.Mesh(
            new THREE.BoxGeometry(bookW, bookH, 0.2 * scale),
            new THREE.MeshLambertMaterial({ color: bookColors[Math.floor(Math.random() * bookColors.length)] })
          );
          book.position.x = xPos + bookW / 2;
          book.position.y = shelf * 0.55 * scale + 0.02 * scale + bookH / 2;
          // Slight random tilt
          book.rotation.z = (Math.random() - 0.5) * 0.08;
          group.add(book);
          xPos += bookW + 0.01 * scale;
        }
      }
    }

    return group;
  }

  function createTorch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'torch';

    // Bracket (wall mount)
    var bracketMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
    var bracket = new THREE.Mesh(
      new THREE.BoxGeometry(0.08 * scale, 0.08 * scale, 0.3 * scale),
      bracketMat
    );
    bracket.position.z = -0.15 * scale;
    bracket.position.y = 1.5 * scale;
    group.add(bracket);

    // Torch handle
    var handleMat = new THREE.MeshLambertMaterial({ color: 0x5c3a1e });
    var handle = new THREE.Mesh(
      new THREE.CylinderGeometry(0.03 * scale, 0.04 * scale, 0.6 * scale, 6),
      handleMat
    );
    handle.position.y = 1.5 * scale;
    group.add(handle);

    // Fire (two overlapping cones)
    var fireMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
    var innerFireMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

    var fireOuter = new THREE.Mesh(
      new THREE.ConeGeometry(0.08 * scale, 0.2 * scale, 6),
      fireMat
    );
    fireOuter.position.y = 1.9 * scale;
    group.add(fireOuter);

    var fireInner = new THREE.Mesh(
      new THREE.ConeGeometry(0.04 * scale, 0.15 * scale, 5),
      innerFireMat
    );
    fireInner.position.y = 1.88 * scale;
    group.add(fireInner);

    // Light
    var light = new THREE.PointLight(0xff8833, 0.8, 10);
    light.position.y = 2 * scale;
    group.add(light);

    group.userData.animationType = 'fire';

    return group;
  }

  function createBridge(length, scale) {
    scale = scale || 1;
    length = length || 8;
    var group = new THREE.Group();
    group.name = 'bridge';

    var plankMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
    var ropeMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
    var postMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

    // Posts at each end
    for (var end = -1; end <= 1; end += 2) {
      for (var side = -1; side <= 1; side += 2) {
        var post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * scale, 0.06 * scale, 1.5 * scale, 6),
          postMat
        );
        post.position.x = end * length / 2 * scale;
        post.position.y = 0.75 * scale;
        post.position.z = side * 0.6 * scale;
        group.add(post);
      }
    }

    // Planks
    var plankCount = Math.floor(length * 2);
    for (var p = 0; p < plankCount; p++) {
      var plank = new THREE.Mesh(
        new THREE.BoxGeometry(0.4 * scale, 0.04 * scale, 1.0 * scale),
        plankMat
      );
      plank.position.x = (p / plankCount - 0.5) * length * scale;
      // Slight sag in the middle
      var sagT = (p / plankCount - 0.5) * 2;
      plank.position.y = -sagT * sagT * 0.3 * scale + 0.3 * scale;
      // Slight random rotation for worn look
      plank.rotation.y = (Math.random() - 0.5) * 0.05;
      group.add(plank);
    }

    // Rope railings (approximated with thin cylinders)
    for (var ropeSide = -1; ropeSide <= 1; ropeSide += 2) {
      var ropeSegments = 8;
      for (var rs = 0; rs < ropeSegments; rs++) {
        var segLen = length / ropeSegments * scale;
        var rope = new THREE.Mesh(
          new THREE.CylinderGeometry(0.015 * scale, 0.015 * scale, segLen, 4),
          ropeMat
        );
        rope.rotation.z = Math.PI / 2;
        var t1 = rs / ropeSegments - 0.5;
        rope.position.x = (t1 + 0.5 / ropeSegments) * length * scale;
        var sagR = t1 * 2;
        rope.position.y = 1.2 * scale - sagR * sagR * 0.2 * scale;
        rope.position.z = ropeSide * 0.6 * scale;
        group.add(rope);
      }
    }

    return group;
  }

  function createGardenArch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'garden_arch';

    var woodMat = new THREE.MeshLambertMaterial({ color: 0xfaf0e6 });
    var vineMat = new THREE.MeshLambertMaterial({ color: 0x2d5a1e });
    var flowerMat = new THREE.MeshLambertMaterial({ color: 0xff69b4 });

    // Two posts
    for (var s = -1; s <= 1; s += 2) {
      var post = new THREE.Mesh(
        new THREE.BoxGeometry(0.1 * scale, 3 * scale, 0.1 * scale),
        woodMat
      );
      post.position.x = s * 1.2 * scale;
      post.position.y = 1.5 * scale;
      group.add(post);
    }

    // Arch top (box curved approximation)
    var archSegments = 8;
    for (var a = 0; a < archSegments; a++) {
      var angle = (a / (archSegments - 1)) * Math.PI;
      var ax = Math.cos(angle) * 1.2 * scale;
      var ay = 3 * scale + Math.sin(angle) * 0.6 * scale;
      var seg = new THREE.Mesh(
        new THREE.BoxGeometry(0.35 * scale, 0.08 * scale, 0.1 * scale),
        woodMat
      );
      seg.position.x = ax;
      seg.position.y = ay;
      seg.rotation.z = angle - Math.PI / 2;
      group.add(seg);
    }

    // Vines wrapping around
    for (var v = 0; v < 8; v++) {
      var vineAngle = (v / 8) * Math.PI;
      var vine = new THREE.Mesh(
        new THREE.SphereGeometry(0.08 * scale, 5, 4),
        vineMat
      );
      vine.position.x = Math.cos(vineAngle) * 1.15 * scale;
      vine.position.y = 2.9 * scale + Math.sin(vineAngle) * 0.55 * scale;
      vine.position.z = (Math.random() - 0.5) * 0.15 * scale;
      group.add(vine);

      // Occasional flower
      if (Math.random() < 0.4) {
        var flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.05 * scale, 5, 4),
          flowerMat
        );
        flower.position.copy(vine.position);
        flower.position.z += 0.1 * scale;
        group.add(flower);
      }
    }

    // Vine tendrils down the posts
    for (var side = -1; side <= 1; side += 2) {
      for (var tv = 0; tv < 4; tv++) {
        var tendril = new THREE.Mesh(
          new THREE.SphereGeometry(0.06 * scale, 4, 3),
          vineMat
        );
        tendril.position.x = side * 1.15 * scale + (Math.random() - 0.5) * 0.1 * scale;
        tendril.position.y = 0.5 + tv * 0.7 * scale;
        tendril.position.z = (Math.random() - 0.5) * 0.1 * scale;
        group.add(tendril);
      }
    }

    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.01;
    group.userData.swaySpeed = 1;

    return group;
  }

  function createBannerPole(color, scale) {
    scale = scale || 1;
    color = color || 0xcc0000;
    var group = new THREE.Group();
    group.name = 'banner_pole';

    // Pole
    var poleMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
    var pole = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.05 * scale, 4 * scale, 6),
      poleMat
    );
    pole.position.y = 2 * scale;
    group.add(pole);

    // Finial (top ornament)
    var finial = new THREE.Mesh(
      new THREE.SphereGeometry(0.08 * scale, 6, 6),
      new THREE.MeshPhongMaterial({ color: 0xdaa520 })
    );
    finial.position.y = 4.1 * scale;
    group.add(finial);

    // Banner (two triangles forming a flag)
    var bannerMat = new THREE.MeshLambertMaterial({ color: color, side: THREE.DoubleSide });
    var bannerGeo = new THREE.PlaneGeometry(0.8 * scale, 1.2 * scale);
    var banner = new THREE.Mesh(bannerGeo, bannerMat);
    banner.position.x = 0.4 * scale;
    banner.position.y = 3.4 * scale;
    group.add(banner);

    // Banner trim
    var trimMat = new THREE.MeshLambertMaterial({ color: 0xdaa520 });
    var trim = new THREE.Mesh(
      new THREE.BoxGeometry(0.82 * scale, 0.04 * scale, 0.02 * scale),
      trimMat
    );
    trim.position.x = 0.4 * scale;
    trim.position.y = 4 * scale;
    group.add(trim);

    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.03;
    group.userData.swaySpeed = 1.5;

    return group;
  }

  // ========================================
  // EXPORTS
  // ========================================

  exports.createTree = createTree;
  exports.createRock = createRock;
  exports.createBuilding = createBuilding;
  exports.createFurniture = createFurniture;
  exports.createCreature = createCreature;
  exports.createLandmark = createLandmark;
  exports.createResourceNode = createResourceNode;
  exports.createWildlife = createWildlife;
  exports.createGrassPatch = createGrassPatch;
  exports.createMushroom = createMushroom;
  exports.createBush = createBush;
  exports.createFallenLog = createFallenLog;
  exports.createRuinWall = createRuinWall;
  exports.createColumnRow = createColumnRow;
  exports.createAmphitheater = createAmphitheater;
  exports.createWishingWell = createWishingWell;
  exports.createBookshelf = createBookshelf;
  exports.createTorch = createTorch;
  exports.createBridge = createBridge;
  exports.createGardenArch = createGardenArch;
  exports.createBannerPole = createBannerPole;
  exports.animateModel = animateModel;

})(typeof module !== 'undefined' ? module.exports : (window.Models = {}));


// auth.js
(function(exports) {
  // GitHub App OAuth Configuration â€” Standard Web Flow (CORS-enabled for GitHub Apps)
  const OAUTH_CONFIG = {
    clientId: 'Iv23lixLqM3xo88npTs4',
    scope: 'read:user',
    authorizeUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://zion-oauth.kwildfeuer.workers.dev'
  };

  // Storage keys
  const TOKEN_KEY = 'zion_auth_token';
  const USERNAME_KEY = 'zion_username';
  const AVATAR_KEY = 'zion_avatar';

  // Helper: safe localStorage access
  function getStorage(key) {
    if (typeof localStorage === 'undefined') return null;
    try { return localStorage.getItem(key); } catch (e) { return null; }
  }
  function setStorage(key, value) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.setItem(key, value); } catch (e) {}
  }
  function removeStorage(key) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.removeItem(key); } catch (e) {}
  }

  /**
   * Initiate GitHub OAuth â€” redirects browser to GitHub authorization page.
   * After the user authorizes, GitHub redirects back with ?code= in the URL.
   */
  function initiateOAuth() {
    if (typeof window === 'undefined') return;
    var redirectUri = window.location.origin + window.location.pathname;
    var url = OAUTH_CONFIG.authorizeUrl +
      '?client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
      '&redirect_uri=' + encodeURIComponent(redirectUri) +
      '&scope=' + encodeURIComponent(OAUTH_CONFIG.scope);
    window.location.href = url;
  }

  /**
   * Handle OAuth callback â€” checks for ?code= in URL, exchanges for token.
   * GitHub Apps support CORS on the token exchange endpoint.
   * @returns {Promise<string|null>} access token or null if no code present
   */
  async function handleCallback() {
    if (typeof window === 'undefined') return null;
    var params = new URLSearchParams(window.location.search);
    var code = params.get('code');

    // Also handle legacy ?token= for PAT-based auth
    var token = params.get('token');
    if (token) {
      setStorage(TOKEN_KEY, token);
      window.history.replaceState({}, document.title, window.location.pathname);
      return token;
    }

    if (!code) return null;

    // Clean the URL immediately
    window.history.replaceState({}, document.title, window.location.pathname);

    try {
      // Exchange code for access token (CORS-enabled for GitHub Apps)
      // Use form-urlencoded to avoid CORS preflight (simple request)
      var res = await fetch(OAUTH_CONFIG.tokenUrl, {
        method: 'POST',
        headers: {
          'Accept': 'application/json'
        },
        body: 'client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
              '&code=' + encodeURIComponent(code)
      });

      if (!res.ok) {
        console.error('Token exchange failed:', res.status);
        return null;
      }

      var data = await res.json();
      if (data.access_token) {
        setStorage(TOKEN_KEY, data.access_token);
        // Fetch and store profile
        await getProfile(data.access_token);
        return data.access_token;
      } else {
        console.error('Token exchange error:', data.error, data.error_description);
        return null;
      }
    } catch (e) {
      console.error('OAuth callback error:', e);
      return null;
    }
  }

  /**
   * Fetch GitHub user profile
   */
  async function getProfile(token) {
    if (typeof fetch === 'undefined') throw new Error('fetch not available');
    var response = await fetch('https://api.github.com/user', {
      headers: { 'Authorization': 'Bearer ' + token, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!response.ok) throw new Error('GitHub API error: ' + response.status);
    var data = await response.json();
    setStorage(USERNAME_KEY, data.login);
    setStorage(AVATAR_KEY, data.avatar_url || '');
    return { username: data.login, avatar_url: data.avatar_url };
  }

  function isAuthenticated() { return !!getStorage(TOKEN_KEY); }
  function getUsername() { return getStorage(USERNAME_KEY); }
  function getToken() { return getStorage(TOKEN_KEY); }
  function setToken(token) { setStorage(TOKEN_KEY, token); }

  function loginAsGuest(username) {
    if (!username || typeof username !== 'string') return false;
    username = username.trim().replace(/[^a-zA-Z0-9_-]/g, '');
    if (username.length < 1 || username.length > 39) return false;
    setStorage(TOKEN_KEY, 'guest_' + username);
    setStorage(USERNAME_KEY, username);
    setStorage(AVATAR_KEY, '');
    return true;
  }

  function logout() {
    removeStorage(TOKEN_KEY);
    removeStorage(USERNAME_KEY);
    removeStorage(AVATAR_KEY);
  }

  // ========================================================================
  // PLAYER DATA PERSISTENCE â€” Save/load player state across sessions
  // ========================================================================

  var PLAYER_DATA_KEY = 'zion_player_data';
  var PLAYER_PREFS_KEY = 'zion_player_prefs';

  /**
   * Save player game data to localStorage
   * @param {Object} data - Player state to save
   */
  function savePlayerData(data) {
    if (!data) return;
    try {
      var saveData = {
        version: 2,
        ts: Date.now(),
        username: getUsername(),
        inventory: data.inventory || null,
        spark: data.spark || 0,
        position: data.position || null,
        zone: data.zone || 'nexus',
        skills: data.skills || null,
        questState: data.questState || null,
        achievements: data.achievements || null,
        guild: data.guild || null,
        discoveredSecrets: data.discoveredSecrets || [],
        warmth: data.warmth || 0,
        playTime: data.playTime || 0,
        lastSave: Date.now()
      };
      setStorage(PLAYER_DATA_KEY, JSON.stringify(saveData));
    } catch (e) {
      console.warn('Failed to save player data:', e);
    }
  }

  /**
   * Load player game data from localStorage
   * @returns {Object|null} Saved player data or null
   */
  function loadPlayerData() {
    try {
      var raw = getStorage(PLAYER_DATA_KEY);
      if (!raw) return null;
      var data = JSON.parse(raw);
      // Verify it belongs to current user
      if (data.username !== getUsername()) return null;
      return data;
    } catch (e) {
      console.warn('Failed to load player data:', e);
      return null;
    }
  }

  /**
   * Save player preferences
   * @param {Object} prefs - {volume, musicVolume, sfxVolume, quality, chatVisible, minimapVisible, showFPS}
   */
  function savePreferences(prefs) {
    try {
      setStorage(PLAYER_PREFS_KEY, JSON.stringify(prefs));
    } catch (e) {}
  }

  /**
   * Load player preferences
   * @returns {Object} Saved preferences or defaults
   */
  function loadPreferences() {
    try {
      var raw = getStorage(PLAYER_PREFS_KEY);
      if (!raw) return getDefaultPreferences();
      return JSON.parse(raw);
    } catch (e) {
      return getDefaultPreferences();
    }
  }

  function getDefaultPreferences() {
    return {
      volume: 0.5,
      musicVolume: 0.3,
      sfxVolume: 0.5,
      quality: 'medium',
      chatVisible: true,
      minimapVisible: true,
      showFPS: false,
      controlsHint: true
    };
  }

  /**
   * Get avatar URL for display
   * @returns {string} Avatar URL or empty string
   */
  function getAvatarUrl() {
    return getStorage(AVATAR_KEY) || '';
  }

  /**
   * Check if user is a guest
   * @returns {boolean}
   */
  function isGuest() {
    var token = getStorage(TOKEN_KEY);
    return token ? token.startsWith('guest_') : false;
  }

  /**
   * Get time since last save
   * @returns {number} Milliseconds since last save, or Infinity if never saved
   */
  function getTimeSinceLastSave() {
    var data = loadPlayerData();
    if (!data || !data.lastSave) return Infinity;
    return Date.now() - data.lastSave;
  }

  exports.OAUTH_CONFIG = OAUTH_CONFIG;
  exports.initiateOAuth = initiateOAuth;
  exports.handleCallback = handleCallback;
  exports.getProfile = getProfile;
  exports.isAuthenticated = isAuthenticated;
  exports.getUsername = getUsername;
  exports.getToken = getToken;
  exports.setToken = setToken;
  exports.loginAsGuest = loginAsGuest;
  exports.logout = logout;
  exports.savePlayerData = savePlayerData;
  exports.loadPlayerData = loadPlayerData;
  exports.savePreferences = savePreferences;
  exports.loadPreferences = loadPreferences;
  exports.getDefaultPreferences = getDefaultPreferences;
  exports.getAvatarUrl = getAvatarUrl;
  exports.isGuest = isGuest;
  exports.getTimeSinceLastSave = getTimeSinceLastSave;

})(typeof module !== 'undefined' ? module.exports : (window.Auth = {}));


// network.js
(function(exports) {
  // PeerJS mesh networking
  let peer = null;
  let connections = new Map(); // peerId -> connection
  let messageCallback = null;
  let peerConnectCallback = null;
  let peerDisconnectCallback = null;
  let seenMessages = new Set(); // For deduplication
  const MAX_SEEN_MESSAGES = 1000;

  /**
   * Initialize PeerJS mesh network
   * @param {string} peerId - Unique peer ID for this client
   * @param {object} options - Configuration
   * @param {function} options.onMessage - Callback for incoming messages (msg)
   * @param {function} options.onPeerConnect - Callback when peer connects (peerId)
   * @param {function} options.onPeerDisconnect - Callback when peer disconnects (peerId)
   */
  function initMesh(peerId, options = {}) {
    // Check if PeerJS is available
    if (typeof Peer === 'undefined') {
      console.warn('PeerJS not available. Network mesh disabled.');
      return null;
    }

    messageCallback = options.onMessage || (() => {});
    peerConnectCallback = options.onPeerConnect || (() => {});
    peerDisconnectCallback = options.onPeerDisconnect || (() => {});

    // Create peer with optional config
    peer = new Peer(peerId, {
      debug: 2 // Set to 3 for verbose logging
    });

    peer.on('open', (id) => {
      console.log('Mesh network initialized. Peer ID:', id);
    });

    peer.on('connection', (conn) => {
      handleConnection(conn);
    });

    peer.on('error', (err) => {
      // peer-unavailable is normal when lobby/seed peers don't exist yet
      if (err.type === 'peer-unavailable') {
        // Silently ignore â€” this just means no other players are online
        return;
      }
      console.error('Peer error:', err);
      // Auto-reconnect on network errors only
      if (err.type === 'network') {
        attemptReconnect(peerId, 0);
      }
    });

    peer.on('disconnected', () => {
      console.warn('Peer disconnected from signaling server');
      attemptReconnect(peerId, 0);
    });

    return peer;
  }

  /**
   * Handle incoming connection
   * @param {DataConnection} conn
   */
  function handleConnection(conn) {
    const remotePeerId = conn.peer;

    conn.on('open', () => {
      console.log('Connected to peer:', remotePeerId);
      connections.set(remotePeerId, conn);
      peerConnectCallback(remotePeerId);
    });

    conn.on('data', (data) => {
      handleIncomingMessage(data, remotePeerId);
    });

    conn.on('close', () => {
      console.log('Peer disconnected:', remotePeerId);
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });

    conn.on('error', (err) => {
      // Don't log errors for expected lobby/seed peer failures
      if (err && err.type !== 'peer-unavailable') {
        console.warn('Connection error with peer', remotePeerId, ':', err);
      }
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });
  }

  /**
   * Handle incoming message with deduplication
   * @param {object} data
   * @param {string} fromPeer
   */
  function handleIncomingMessage(data, fromPeer) {
    try {
      const msg = typeof data === 'string' ? JSON.parse(data) : data;

      // Generate message ID for deduplication
      const msgId = generateMessageId(msg);

      // Check if already seen
      if (seenMessages.has(msgId)) {
        return; // Duplicate, ignore
      }

      // Add to seen messages
      seenMessages.add(msgId);

      // Evict oldest if over limit
      if (seenMessages.size > MAX_SEEN_MESSAGES) {
        const firstItem = seenMessages.values().next().value;
        seenMessages.delete(firstItem);
      }

      // Relay to other peers (mesh propagation)
      relayMessage(msg, fromPeer);

      // Invoke callback
      messageCallback(msg);
    } catch (err) {
      console.error('Error handling message:', err);
    }
  }

  /**
   * Generate unique message ID for deduplication
   * @param {object} msg
   * @returns {string}
   */
  function generateMessageId(msg) {
    // Use message fields to create unique ID
    const str = JSON.stringify({
      type: msg.type,
      from: msg.from,
      timestamp: msg.timestamp,
      nonce: msg.nonce
    });
    return simpleHash(str);
  }

  /**
   * Simple hash function
   * @param {string} str
   * @returns {string}
   */
  function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  /**
   * Relay message to all peers except sender
   * @param {object} msg
   * @param {string} excludePeer
   */
  function relayMessage(msg, excludePeer) {
    connections.forEach((conn, peerId) => {
      if (peerId !== excludePeer && conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error relaying to peer', peerId, ':', err);
        }
      }
    });
  }

  /**
   * Broadcast message to all connected peers
   * @param {object} msg - Message object (will be JSON serialized)
   */
  function broadcastMessage(msg) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    // Add to seen messages to prevent echo
    const msgId = generateMessageId(msg);
    seenMessages.add(msgId);

    connections.forEach((conn, peerId) => {
      if (conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error sending to peer', peerId, ':', err);
        }
      }
    });
  }

  /**
   * Register message handler
   * @param {function} callback
   */
  function onMessage(callback) {
    messageCallback = callback;
  }

  /**
   * Get list of connected peer IDs
   * @returns {string[]}
   */
  function getPeers() {
    return Array.from(connections.keys());
  }

  /**
   * Connect to a specific peer
   * @param {string} peerId
   */
  function connectToPeer(peerId) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    if (connections.has(peerId)) {
      console.log('Already connected to peer:', peerId);
      return;
    }

    console.log('Connecting to peer:', peerId);
    const conn = peer.connect(peerId, {
      reliable: true
    });

    handleConnection(conn);
  }

  /**
   * Disconnect from all peers and destroy peer
   */
  function disconnect() {
    if (!peer) return;

    connections.forEach((conn) => {
      conn.close();
    });

    connections.clear();
    peer.destroy();
    peer = null;

    console.log('Disconnected from mesh network');
  }

  /**
   * Attempt to reconnect with exponential backoff
   * @param {string} peerId
   * @param {number} attempt
   */
  function attemptReconnect(peerId, attempt) {
    const maxAttempts = 3;
    if (attempt >= maxAttempts) {
      console.log('Max reconnection attempts reached, will retry on next discovery cycle');
      return;
    }

    const delay = Math.pow(2, attempt) * 1000; // Exponential: 1s, 2s, 4s
    console.log(`Reconnecting in ${delay}ms (attempt ${attempt + 1}/${maxAttempts})`);

    setTimeout(() => {
      if (!peer || peer.destroyed) {
        console.log('Attempting to reconnect...');
        peer.reconnect();

        // Check if reconnection succeeded after 2 seconds
        setTimeout(() => {
          if (peer && !peer.open) {
            attemptReconnect(peerId, attempt + 1);
          }
        }, 2000);
      }
    }, delay);
  }

  /**
   * Generate lobby peer ID from world ID
   * @param {string} worldId - World identifier (default: 'main')
   * @returns {string}
   */
  function getLobbyPeerId(worldId = 'main') {
    return `zion-lobby-${worldId}`;
  }

  // ========================================================================
  // LOBBY SYSTEM â€” Automatic peer discovery
  // ========================================================================

  var lobbyState = {
    peerId: null,
    worldId: 'main',
    discoveryInterval: null,
    knownPeers: [],       // All peer IDs ever seen
    heartbeatInterval: null,
    playerName: '',
    zone: 'nexus',
    lastAnnounce: 0
  };

  /**
   * Join the world lobby for automatic peer discovery.
   * Uses a well-known lobby peer ID that the first player to join becomes.
   * Others connect to the lobby peer and receive the full peer list.
   */
  function joinLobby(worldId, playerName, zone) {
    lobbyState.worldId = worldId || 'main';
    lobbyState.playerName = playerName || 'Anonymous';
    lobbyState.zone = zone || 'nexus';

    if (!peer) return;

    lobbyState.peerId = peer.id;

    // Try connecting to the lobby peer
    var lobbyId = getLobbyPeerId(lobbyState.worldId);

    if (peer.id !== lobbyId) {
      // Not the lobby â€” try connecting to it
      connectToPeer(lobbyId);
    }

    // Also try a list of "seed" peer IDs derived from the world
    // This creates a gossip-based discovery pattern
    var seedCount = 5;
    for (var i = 0; i < seedCount; i++) {
      var seedId = 'zion-seed-' + lobbyState.worldId + '-' + i;
      if (seedId !== peer.id) {
        connectToPeer(seedId);
      }
    }

    // Periodically announce presence and discover peers
    if (lobbyState.discoveryInterval) {
      clearInterval(lobbyState.discoveryInterval);
    }

    lobbyState.discoveryInterval = setInterval(function() {
      announcePresence();
    }, 10000); // Every 10 seconds

    // Start heartbeat
    if (lobbyState.heartbeatInterval) {
      clearInterval(lobbyState.heartbeatInterval);
    }

    lobbyState.heartbeatInterval = setInterval(function() {
      sendHeartbeat();
    }, 30000); // Every 30 seconds

    // Initial announce
    announcePresence();
  }

  function announcePresence() {
    if (!peer || !peer.open) return;

    var announcement = {
      type: '_lobby_announce',
      peerId: peer.id,
      playerName: lobbyState.playerName,
      zone: lobbyState.zone,
      peers: getPeers(), // Share our peer list for gossip
      timestamp: Date.now()
    };

    broadcastMessage(announcement);
    lobbyState.lastAnnounce = Date.now();
  }

  function sendHeartbeat() {
    if (!peer || !peer.open) return;

    broadcastMessage({
      type: '_heartbeat',
      peerId: peer.id,
      zone: lobbyState.zone,
      peerCount: connections.size,
      timestamp: Date.now()
    });
  }

  /**
   * Handle lobby-specific messages (called from handleIncomingMessage)
   */
  function handleLobbyMessage(msg) {
    if (!msg || !msg.type) return false;

    // Check if it's a federation message first
    if (handleFederationMessage(msg)) {
      return true;
    }

    if (msg.type === '_lobby_announce') {
      // Someone announced â€” connect to their known peers
      if (msg.peers && Array.isArray(msg.peers)) {
        msg.peers.forEach(function(peerId) {
          if (peerId !== peer.id && !connections.has(peerId)) {
            // Track known peer
            if (lobbyState.knownPeers.indexOf(peerId) === -1) {
              lobbyState.knownPeers.push(peerId);
            }
            // Try connecting if we have room
            if (connections.size < 20) {
              connectToPeer(peerId);
            }
          }
        });
      }
      return true; // Handled
    }

    if (msg.type === '_heartbeat') {
      // Update known peer activity
      return true; // Handled, don't propagate to game
    }

    if (msg.type === '_peer_list_request') {
      // Someone asking for our peer list
      broadcastMessage({
        type: '_lobby_announce',
        peerId: peer.id,
        playerName: lobbyState.playerName,
        zone: lobbyState.zone,
        peers: getPeers(),
        timestamp: Date.now()
      });
      return true;
    }

    return false; // Not a lobby message
  }

  function updateLobbyZone(zone) {
    lobbyState.zone = zone;
  }

  function leaveLobby() {
    if (lobbyState.discoveryInterval) {
      clearInterval(lobbyState.discoveryInterval);
      lobbyState.discoveryInterval = null;
    }
    if (lobbyState.heartbeatInterval) {
      clearInterval(lobbyState.heartbeatInterval);
      lobbyState.heartbeatInterval = null;
    }
  }

  function getNetworkStats() {
    return {
      peerId: peer ? peer.id : null,
      connected: peer ? peer.open : false,
      peerCount: connections.size,
      knownPeers: lobbyState.knownPeers.length,
      seenMessages: seenMessages.size
    };
  }

  // ========================================================================
  // FEDERATION SYSTEM â€” Cross-world connectivity
  // ========================================================================

  var federationState = {
    worldId: null,
    worldName: null,
    endpoint: null,
    federatedPeers: new Map(), // worldId -> {peerId, connection, worldInfo}
    federationCallback: null,
    discoveredWorlds: new Map() // worldId -> worldInfo
  };

  /**
   * Initialize federation for this world
   * @param {string} worldId - Unique world identifier (derived from URL)
   * @param {string} worldName - Human-readable world name
   * @param {string} endpoint - Public endpoint URL (e.g., GitHub Pages URL)
   */
  function initFederation(worldId, worldName, endpoint) {
    federationState.worldId = worldId;
    federationState.worldName = worldName || worldId;
    federationState.endpoint = endpoint;

    console.log('Federation initialized for world:', worldId);
  }

  /**
   * Generate federated peer ID for cross-world connections
   * @param {string} worldId - World identifier
   * @param {string} playerId - Player identifier
   * @returns {string}
   */
  function getFederatedPeerId(worldId, playerId) {
    return `zion-fed-${worldId}-${playerId}`;
  }

  /**
   * Announce this world to the federation network
   * Broadcasts availability for cross-world connections
   */
  function announceFederation() {
    if (!peer || !peer.open) return;
    if (!federationState.worldId) {
      console.warn('Federation not initialized');
      return;
    }

    var announcement = {
      type: 'federation_announce',
      worldId: federationState.worldId,
      worldName: federationState.worldName,
      endpoint: federationState.endpoint,
      protocolVersion: 1,
      playerCount: connections.size,
      peerId: peer.id,
      timestamp: Date.now()
    };

    broadcastMessage(announcement);
    console.log('Federation announced:', federationState.worldName);
  }

  /**
   * Establish handshake with a federated world
   * @param {string} targetWorldId - Target world identifier
   * @param {object} worldInfo - Information about target world
   */
  function federationHandshake(targetWorldId, worldInfo) {
    if (!peer || !peer.open) return;
    if (!federationState.worldId) {
      console.warn('Federation not initialized');
      return;
    }

    // Generate federated peer ID for the target world
    var federatedPeerId = getFederatedPeerId(targetWorldId, lobbyState.peerId);

    // Check if already connected
    if (federationState.federatedPeers.has(targetWorldId)) {
      console.log('Already federated with world:', targetWorldId);
      return;
    }

    // Send handshake message
    var handshake = {
      type: 'federation_handshake',
      from_world: federationState.worldId,
      to_world: targetWorldId,
      worldName: federationState.worldName,
      endpoint: federationState.endpoint,
      protocolVersion: 1,
      peerId: peer.id,
      timestamp: Date.now()
    };

    broadcastMessage(handshake);

    // Store federated world info
    federationState.federatedPeers.set(targetWorldId, {
      worldId: targetWorldId,
      worldInfo: worldInfo,
      peerId: federatedPeerId,
      status: 'handshake_sent',
      timestamp: Date.now()
    });

    console.log('Federation handshake sent to:', targetWorldId);
  }

  /**
   * Handle incoming federation messages
   * @param {object} msg - Federation message
   * @returns {boolean} True if message was handled
   */
  function handleFederationMessage(msg) {
    if (!msg || !msg.type) return false;

    if (msg.type === 'federation_announce') {
      // Another world announced itself
      var worldId = msg.worldId || msg.payload?.worldId;
      if (worldId && worldId !== federationState.worldId) {
        var worldInfo = {
          worldId: worldId,
          worldName: msg.worldName || msg.payload?.worldName,
          endpoint: msg.endpoint || msg.payload?.endpoint,
          protocolVersion: msg.protocolVersion || msg.payload?.protocolVersion || 1,
          playerCount: msg.playerCount || msg.payload?.playerCount || 0,
          peerId: msg.peerId || msg.payload?.peerId,
          timestamp: msg.timestamp || Date.now()
        };

        // Track discovered world
        federationState.discoveredWorlds.set(worldId, worldInfo);

        // Notify callback
        if (federationState.federationCallback) {
          federationState.federationCallback({
            type: 'world_discovered',
            worldInfo: worldInfo
          });
        }

        console.log('Discovered federated world:', worldInfo.worldName);
      }
      return true;
    }

    if (msg.type === 'federation_handshake') {
      // Another world wants to federate with us
      var fromWorld = msg.from_world || msg.payload?.from_world;
      var toWorld = msg.to_world || msg.payload?.to_world;

      if (toWorld === federationState.worldId && fromWorld) {
        var worldInfo = {
          worldId: fromWorld,
          worldName: msg.worldName || msg.payload?.worldName,
          endpoint: msg.endpoint || msg.payload?.endpoint,
          protocolVersion: msg.protocolVersion || msg.payload?.protocolVersion || 1,
          peerId: msg.peerId || msg.payload?.peerId,
          timestamp: msg.timestamp || Date.now()
        };

        // Check if we already have a federation with this world
        var existing = federationState.federatedPeers.get(fromWorld);
        if (existing && existing.status === 'active') {
          console.log('Federation already active with:', fromWorld);
          return true;
        }

        // Store federated world
        federationState.federatedPeers.set(fromWorld, {
          worldId: fromWorld,
          worldInfo: worldInfo,
          status: 'active',
          timestamp: Date.now()
        });

        // Notify callback
        if (federationState.federationCallback) {
          federationState.federationCallback({
            type: 'federation_established',
            worldInfo: worldInfo
          });
        }

        console.log('Federation established with:', worldInfo.worldName);
      }
      return true;
    }

    if (msg.type === 'warp_fork') {
      // Player warping between federated worlds
      if (federationState.federationCallback) {
        federationState.federationCallback({
          type: 'cross_world_warp',
          playerId: msg.from,
          targetWorld: msg.payload?.target_world,
          position: msg.payload?.position
        });
      }
      return true;
    }

    if (msg.type === 'return_home') {
      // Player returning from federated world
      if (federationState.federationCallback) {
        federationState.federationCallback({
          type: 'player_returned',
          playerId: msg.from,
          position: msg.payload?.position
        });
      }
      return true;
    }

    return false;
  }

  /**
   * Register callback for federation events
   * @param {function} callback - Called with federation events
   */
  function onFederationEvent(callback) {
    federationState.federationCallback = callback;
  }

  /**
   * Get list of federated worlds
   * @returns {Array} Array of federated world info
   */
  function getFederatedWorlds() {
    return Array.from(federationState.federatedPeers.values());
  }

  /**
   * Get list of discovered worlds
   * @returns {Array} Array of discovered world info
   */
  function getDiscoveredWorlds() {
    return Array.from(federationState.discoveredWorlds.values());
  }

  /**
   * Check if connected to a specific world
   * @param {string} worldId - World identifier
   * @returns {boolean}
   */
  function isFederatedWith(worldId) {
    var fed = federationState.federatedPeers.get(worldId);
    return fed && fed.status === 'active';
  }

  /**
   * Get world ID derived from current URL
   * @returns {string}
   */
  function deriveWorldId() {
    if (typeof window === 'undefined' || !window.location) {
      return 'localhost';
    }

    var url = window.location.href;
    // Extract meaningful part from URL (e.g., github.io/repo-name)
    var match = url.match(/github\.io\/([^\/]+)/);
    if (match) {
      return match[1];
    }

    // Fallback to hostname
    return window.location.hostname.replace(/\./g, '-');
  }

  // Export public API
  exports.initMesh = initMesh;
  exports.broadcastMessage = broadcastMessage;
  exports.onMessage = onMessage;
  exports.getPeers = getPeers;
  exports.connectToPeer = connectToPeer;
  exports.disconnect = disconnect;
  exports.getLobbyPeerId = getLobbyPeerId;
  exports.joinLobby = joinLobby;
  exports.leaveLobby = leaveLobby;
  exports.updateLobbyZone = updateLobbyZone;
  exports.handleLobbyMessage = handleLobbyMessage;
  exports.getNetworkStats = getNetworkStats;

  // Federation exports
  exports.initFederation = initFederation;
  exports.announceFederation = announceFederation;
  exports.federationHandshake = federationHandshake;
  exports.handleFederationMessage = handleFederationMessage;
  exports.onFederationEvent = onFederationEvent;
  exports.getFederatedWorlds = getFederatedWorlds;
  exports.getDiscoveredWorlds = getDiscoveredWorlds;
  exports.isFederatedWith = isFederatedWith;
  exports.deriveWorldId = deriveWorldId;
  exports.getFederatedPeerId = getFederatedPeerId;

})(typeof module !== 'undefined' ? module.exports : (window.Network = {}));


// api_bridge.js
// api_bridge.js â€” Client-side bridge for AI Agent API
(function(exports) {
  'use strict';

  var REPO_OWNER = 'kody-w';
  var REPO_NAME = 'zion';
  var RAW_BASE = 'https://raw.githubusercontent.com/' + REPO_OWNER + '/' + REPO_NAME + '/main';
  var API_BASE = 'https://api.github.com/repos/' + REPO_OWNER + '/' + REPO_NAME;

  var PUBLISH_INTERVAL = 60000;  // 60s between state publishes
  var POLL_INTERVAL = 30000;     // 30s between inbox polls

  var lastPublishTime = 0;
  var lastPollTime = 0;
  var pendingMessages = [];

  /**
   * Initialize the API bridge
   */
  function init() {
    console.log('[ApiBridge] Initialized â€” publish every %ds, poll every %ds',
      PUBLISH_INTERVAL / 1000, POLL_INTERVAL / 1000);
  }

  /**
   * Update loop â€” called from main game loop
   * @param {number} now - Current timestamp (Date.now())
   * @param {object} gameState - Current game state
   */
  function update(now, gameState) {
    // Publish state on timer
    if (now - lastPublishTime >= PUBLISH_INTERVAL) {
      lastPublishTime = now;
      publishStateSnapshot(gameState);
    }

    // Poll inbox on timer
    if (now - lastPollTime >= POLL_INTERVAL) {
      lastPollTime = now;
      pollInbox(gameState);
    }

    // Process any pending messages
    if (pendingMessages.length > 0) {
      processPendingMessages(gameState);
    }
  }

  /**
   * Build a world state snapshot from live game state
   * @param {object} gameState - Current game state
   * @returns {object} Snapshot for API consumers
   */
  function buildSnapshot(gameState) {
    var state = typeof State !== 'undefined' ? State : {};
    var zones = typeof Zones !== 'undefined' ? Zones : {};
    var liveState = state.getLiveState ? state.getLiveState() : {};

    var world = liveState.world || {};
    var players = liveState.players || {};
    var economy = liveState.economy || {};
    var chat = liveState.chat || [];

    // Count players per zone
    var playerZones = {};
    var playerEntries = {};
    for (var pid in players) {
      if (players.hasOwnProperty(pid)) {
        var p = players[pid];
        var pzone = (p.position && p.position.zone) || 'nexus';
        playerZones[pzone] = (playerZones[pzone] || 0) + 1;
        playerEntries[pid] = {
          position: p.position || {},
          zone: pzone,
          online: true
        };
      }
    }

    // Zone summaries
    var zoneIds = zones.getAllZoneIds ? zones.getAllZoneIds() : [];
    var zoneSummaries = {};
    for (var i = 0; i < zoneIds.length; i++) {
      var zid = zoneIds[i];
      var zdata = zones.getZone ? zones.getZone(zid) : {};
      zoneSummaries[zid] = {
        name: zdata.name || zid,
        description: zdata.description || '',
        player_count: playerZones[zid] || 0,
        npc_count: 0
      };
    }

    // NPC data
    var npcList = [];
    if (typeof NPCs !== 'undefined' && NPCs.getAllNPCs) {
      var allNpcs = NPCs.getAllNPCs();
      for (var n = 0; n < allNpcs.length; n++) {
        var npc = allNpcs[n];
        var nzone = (npc.position && npc.position.zone) || 'nexus';
        npcList.push({
          id: npc.id || '',
          name: npc.name || '',
          archetype: npc.archetype || '',
          zone: nzone
        });
        if (zoneSummaries[nzone]) {
          zoneSummaries[nzone].npc_count++;
        }
      }
    }

    // Recent chat (last 20)
    var recentChat = [];
    var chatSlice = chat.slice(-20);
    for (var c = 0; c < chatSlice.length; c++) {
      var msg = chatSlice[c];
      recentChat.push({
        from: msg.from || '',
        type: msg.type || 'say',
        text: (msg.payload && msg.payload.text) || '',
        ts: msg.ts || ''
      });
    }

    // Simulation summaries
    var simulations = {};
    if (typeof SimCRM !== 'undefined' && SimCRM.getMetrics) {
      var crmState = typeof Main !== 'undefined' && Main.getSimCrmState ? Main.getSimCrmState() : null;
      if (crmState) {
        simulations.crm = SimCRM.getMetrics(crmState);
      }
    }

    return {
      v: 1,
      ts: new Date().toISOString(),
      world: {
        time: world.time || 0,
        dayPhase: world.dayPhase || 'day',
        weather: world.weather || 'clear',
        season: world.season || 'spring'
      },
      zones: zoneSummaries,
      players: playerEntries,
      npcs: npcList,
      recent_chat: recentChat,
      economy: {
        total_spark: sumValues(economy.balances || {}),
        active_listings: (economy.listings || []).length
      },
      simulations: simulations
    };
  }

  /**
   * Publish state snapshot (stores in localStorage for local access)
   * @param {object} gameState - Current game state
   */
  function publishStateSnapshot(gameState) {
    try {
      var snapshot = buildSnapshot(gameState);
      // Store locally for any local tools to read
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem('zion_api_state', JSON.stringify(snapshot));
        localStorage.setItem('zion_api_state_ts', snapshot.ts);
      }
    } catch (e) {
      console.warn('[ApiBridge] Failed to publish snapshot:', e.message);
    }
  }

  /**
   * Poll GitHub inbox for new messages from AI agents
   * @param {object} gameState - Current game state
   */
  function pollInbox(gameState) {
    var url = API_BASE + '/contents/state/inbox';

    fetch(url, {
      headers: { 'Accept': 'application/vnd.github.v3+json' }
    })
    .then(function(response) {
      if (!response.ok) return [];
      return response.json();
    })
    .then(function(files) {
      if (!Array.isArray(files)) return;

      // Filter for JSON files (not .gitkeep, not _processed dir)
      var messageFiles = files.filter(function(f) {
        return f.name.endsWith('.json') && f.type === 'file';
      });

      if (messageFiles.length === 0) return;

      console.log('[ApiBridge] Found %d inbox messages', messageFiles.length);

      // Fetch each message
      messageFiles.forEach(function(f) {
        fetch(f.download_url)
          .then(function(r) { return r.json(); })
          .then(function(msg) {
            pendingMessages.push(msg);
          })
          .catch(function(e) {
            console.warn('[ApiBridge] Failed to fetch message %s: %s', f.name, e.message);
          });
      });
    })
    .catch(function(e) {
      // Silent fail â€” GitHub API rate limiting is common for unauthenticated requests
    });
  }

  /**
   * Process pending messages from inbox
   * @param {object} gameState - Current game state
   */
  function processPendingMessages(gameState) {
    var protocol = typeof Protocol !== 'undefined' ? Protocol : null;
    var state = typeof State !== 'undefined' ? State : null;

    if (!protocol || !state) return;

    while (pendingMessages.length > 0) {
      var msg = pendingMessages.shift();

      // Validate
      var result = protocol.validateMessage(msg);
      if (!result.valid) {
        console.warn('[ApiBridge] Invalid message from %s: %s', msg.from, result.errors.join(', '));
        continue;
      }

      // Apply to live state
      try {
        var currentState = state.getLiveState();
        var newState = state.applyMessage(currentState, msg);
        state.setLiveState(newState);
        console.log('[ApiBridge] Applied %s from %s', msg.type, msg.from);

        // Chat messages are rendered by HUD from live state â€” no extra call needed
      } catch (e) {
        console.warn('[ApiBridge] Failed to apply message: %s', e.message);
      }
    }
  }

  /**
   * Get the latest published snapshot
   * @returns {object|null} Latest snapshot or null
   */
  function getLatestSnapshot() {
    if (typeof localStorage === 'undefined') return null;
    try {
      var raw = localStorage.getItem('zion_api_state');
      return raw ? JSON.parse(raw) : null;
    } catch (e) {
      return null;
    }
  }

  /**
   * Sum numeric values in an object
   */
  function sumValues(obj) {
    var total = 0;
    for (var k in obj) {
      if (obj.hasOwnProperty(k) && typeof obj[k] === 'number') {
        total += obj[k];
      }
    }
    return total;
  }

  // Exports
  exports.init = init;
  exports.update = update;
  exports.buildSnapshot = buildSnapshot;
  exports.publishStateSnapshot = publishStateSnapshot;
  exports.pollInbox = pollInbox;
  exports.getLatestSnapshot = getLatestSnapshot;

})(typeof module !== 'undefined' ? module.exports : (window.ApiBridge = {}));


// sim_crm.js
// sim_crm.js â€” Self-evolving CRM Simulation (Dynamics 365-style)
// Article XI: Simulations run locally, store state as JSON, use pure functions.
// The state JSON IS the simulation â€” portable between raw GitHub and local disk.
// When an unknown action arrives, the simulation molts to handle it.
(function(exports) {
  'use strict';

  // --- Defaults (used only when creating a fresh state) ---

  var DEFAULT_PIPELINE = [
    'prospecting', 'qualification', 'proposal',
    'negotiation', 'closed_won', 'closed_lost'
  ];

  var DEFAULT_STAGE_PROB = {
    'prospecting': 10, 'qualification': 25, 'proposal': 50,
    'negotiation': 75, 'closed_won': 100, 'closed_lost': 0
  };

  var DEFAULT_ACTIVITY_TYPES = ['call', 'email', 'meeting', 'task'];

  var DEFAULT_SCHEMA = {
    collections: {
      accounts:      { prefix: 'acc', fields: ['name','industry','revenue','owner','status','zone'] },
      contacts:      { prefix: 'con', fields: ['name','email','phone','role','accountId','owner'] },
      opportunities: { prefix: 'opp', fields: ['name','accountId','stage','value','probability','owner','expected_close'] }
    },
    activity_types: DEFAULT_ACTIVITY_TYPES.slice(),
    pipeline_stages: DEFAULT_PIPELINE.slice(),
    stage_probabilities: JSON.parse(JSON.stringify(DEFAULT_STAGE_PROB))
  };

  var idCounter = 0;

  function generateId(prefix) {
    idCounter++;
    return prefix + '_' + Date.now().toString(36) + '_' + idCounter;
  }

  // --- State management ---

  function initState(snapshot) {
    if (snapshot && (snapshot.accounts || snapshot._schema)) {
      // Restore id counter from existing data
      var maxNum = 0;
      var schema = snapshot._schema || DEFAULT_SCHEMA;
      var collNames = objectKeys(schema.collections || {});
      // Also scan legacy top-level collections
      var scanKeys = collNames.concat(['accounts', 'contacts', 'opportunities']);
      for (var c = 0; c < scanKeys.length; c++) {
        var coll = snapshot[scanKeys[c]];
        if (coll && typeof coll === 'object' && !Array.isArray(coll)) {
          for (var k in coll) {
            if (coll.hasOwnProperty(k)) {
              var parts = k.split('_');
              var num = parseInt(parts[parts.length - 1], 10);
              if (!isNaN(num) && num > maxNum) { maxNum = num; }
            }
          }
        }
      }
      var activities = snapshot.activities || [];
      for (var a = 0; a < activities.length; a++) {
        if (activities[a].id) {
          var aParts = activities[a].id.split('_');
          var aNum = parseInt(aParts[aParts.length - 1], 10);
          if (!isNaN(aNum) && aNum > maxNum) { maxNum = aNum; }
        }
      }
      idCounter = maxNum;

      var loaded = JSON.parse(JSON.stringify(snapshot));
      // Ensure schema exists (migrate v1 states)
      if (!loaded._schema) {
        loaded._schema = JSON.parse(JSON.stringify(DEFAULT_SCHEMA));
      }
      if (!loaded._molt_log) { loaded._molt_log = []; }
      // Ensure pipeline_stages at top level for backward compat
      if (!loaded.pipeline_stages) {
        loaded.pipeline_stages = loaded._schema.pipeline_stages.slice();
      }
      return loaded;
    }
    return {
      _schema: JSON.parse(JSON.stringify(DEFAULT_SCHEMA)),
      _molt_log: [],
      accounts: {},
      contacts: {},
      opportunities: {},
      activities: [],
      pipeline_stages: DEFAULT_PIPELINE.slice()
    };
  }

  // --- Molt: the simulation adapts ---

  function molt(state, reason) {
    var s = clone(state);
    if (!s._molt_log) { s._molt_log = []; }
    s._molt_log.push({
      v: s._molt_log.length + 1,
      reason: reason,
      ts: new Date().toISOString()
    });
    return s;
  }

  function ensureCollection(state, collName, prefix) {
    if (state[collName] && typeof state[collName] === 'object' && !Array.isArray(state[collName])) {
      return state;
    }
    var s = molt(state, 'New collection: ' + collName);
    s[collName] = {};
    if (!s._schema.collections[collName]) {
      s._schema.collections[collName] = { prefix: prefix || collName.substring(0, 3), fields: [] };
    }
    return s;
  }

  function ensurePipelineStage(state, stageName) {
    var stages = state._schema.pipeline_stages;
    if (stages.indexOf(stageName) !== -1) { return state; }
    var s = molt(state, 'New pipeline stage: ' + stageName);
    // Insert before closed stages
    var closedIdx = stages.indexOf('closed_won');
    if (closedIdx === -1) { closedIdx = stages.length; }
    s._schema.pipeline_stages.splice(closedIdx, 0, stageName);
    s.pipeline_stages = s._schema.pipeline_stages.slice();
    if (!s._schema.stage_probabilities[stageName]) {
      // Estimate probability based on position
      var pos = s._schema.pipeline_stages.indexOf(stageName);
      var total = s._schema.pipeline_stages.length;
      s._schema.stage_probabilities[stageName] = Math.round((pos / (total - 1)) * 100);
    }
    return s;
  }

  function ensureActivityType(state, typeName) {
    if (state._schema.activity_types.indexOf(typeName) !== -1) { return state; }
    var s = molt(state, 'New activity type: ' + typeName);
    s._schema.activity_types.push(typeName);
    return s;
  }

  function learnFields(state, collName, data) {
    // Absorb any new fields into the schema
    var schema = state._schema;
    if (!schema.collections[collName]) { return state; }
    var known = schema.collections[collName].fields;
    var newFields = [];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id' && k !== 'owner' && known.indexOf(k) === -1) {
        newFields.push(k);
      }
    }
    if (newFields.length === 0) { return state; }
    var s = molt(state, 'New fields on ' + collName + ': ' + newFields.join(', '));
    for (var i = 0; i < newFields.length; i++) {
      s._schema.collections[collName].fields.push(newFields[i]);
    }
    return s;
  }

  // --- Action dispatch (with molting) ---

  function applyAction(state, msg) {
    var payload = msg.payload || msg;
    var action = payload.action;
    var data = payload.data || {};
    var from = msg.from || payload.from || 'system';
    var result;

    // Ensure schema exists
    if (!state._schema) {
      state = initState(state);
    }

    switch (action) {
      case 'create_account':
        result = createAccount(state, mergeOwner(data, from));
        return result.state;

      case 'update_account':
        return updateAccount(state, data.id, data);

      case 'create_contact':
        result = createContact(state, mergeOwner(data, from));
        return result.state;

      case 'update_contact':
        return updateContact(state, data.id, data);

      case 'create_opportunity':
        result = createOpportunity(state, mergeOwner(data, from));
        return result.state;

      case 'update_stage':
        return updateStage(state, data.id, data.stage);

      case 'close_deal':
        return closeDeal(state, data.id, data.won, data);

      case 'log_activity':
        result = logActivity(state, mergeOwner(data, from));
        return result.state;

      case 'add_note':
        return addNote(state, data.entityType, data.entityId, data.text, from);

      default:
        // --- MOLT: handle unknown actions ---
        return moltForAction(state, action, data, from);
    }
  }

  /**
   * When the simulation doesn't know an action, it molts.
   * Patterns: create_X, update_X, delete_X, list_X
   */
  function moltForAction(state, action, data, from) {
    if (!action || typeof action !== 'string') { return state; }

    var parts = action.split('_');
    if (parts.length < 2) { return state; }

    var verb = parts[0];
    // e.g. create_lead â†’ verb=create, entitySingular=lead, collName=leads
    var entitySingular = parts.slice(1).join('_');
    var collName = entitySingular + 's';
    var prefix = entitySingular.substring(0, 3);

    if (verb === 'create') {
      var s = ensureCollection(state, collName, prefix);
      s = learnFields(s, collName, data);
      var s2 = clone(s);
      var id = generateId(prefix);
      var record = { id: id, owner: data.owner || from, createdAt: new Date().toISOString() };
      for (var k in data) {
        if (data.hasOwnProperty(k)) { record[k] = data[k]; }
      }
      if (!record.name) { record.name = 'Unnamed ' + entitySingular; }
      if (!record.notes) { record.notes = []; }
      s2[collName][id] = record;
      return s2;

    } else if (verb === 'update') {
      if (!state[collName] || !data.id || !state[collName][data.id]) { return state; }
      var su = clone(state);
      su = learnFields(su, collName, data);
      var target = su[collName][data.id];
      for (var uk in data) {
        if (data.hasOwnProperty(uk) && uk !== 'id') { target[uk] = data[uk]; }
      }
      target.updatedAt = new Date().toISOString();
      return su;

    } else if (verb === 'delete') {
      if (!state[collName] || !data.id || !state[collName][data.id]) { return state; }
      var sd = clone(state);
      delete sd[collName][data.id];
      return sd;

    } else if (verb === 'list') {
      // Read-only, no state change
      return state;
    }

    return state;
  }

  function mergeOwner(data, from) {
    var out = {};
    for (var k in data) {
      if (data.hasOwnProperty(k)) { out[k] = data[k]; }
    }
    if (!out.owner) { out.owner = from; }
    return out;
  }

  // --- CRUD: Accounts ---

  function createAccount(state, data) {
    var s = learnFields(state, 'accounts', data);
    s = clone(s);
    var id = generateId('acc');
    var record = {
      id: id,
      name: data.name || 'Unnamed Account',
      industry: data.industry || 'general',
      revenue: data.revenue || 0,
      owner: data.owner || 'system',
      status: data.status || 'active',
      zone: data.zone || 'agora',
      notes: [],
      createdAt: new Date().toISOString()
    };
    // Absorb extra fields from data
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.accounts[id] = record;
    return { state: s, record: record };
  }

  function updateAccount(state, id, data) {
    if (!state.accounts[id]) { return state; }
    var s = learnFields(state, 'accounts', data);
    s = clone(s);
    var acct = s.accounts[id];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id') { acct[k] = data[k]; }
    }
    acct.updatedAt = new Date().toISOString();
    return s;
  }

  // --- CRUD: Contacts ---

  function createContact(state, data) {
    var s = learnFields(state, 'contacts', data);
    s = clone(s);
    var id = generateId('con');
    var record = {
      id: id,
      name: data.name || 'Unnamed Contact',
      email: data.email || '',
      phone: data.phone || '',
      role: data.role || '',
      accountId: data.accountId || '',
      owner: data.owner || 'system',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.contacts[id] = record;
    return { state: s, record: record };
  }

  function updateContact(state, id, data) {
    if (!state.contacts[id]) { return state; }
    var s = learnFields(state, 'contacts', data);
    s = clone(s);
    var con = s.contacts[id];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id') { con[k] = data[k]; }
    }
    con.updatedAt = new Date().toISOString();
    return s;
  }

  // --- CRUD: Opportunities ---

  function createOpportunity(state, data) {
    var s = state;
    var stage = data.stage || 'prospecting';
    // Molt if unknown stage
    if (s._schema && s._schema.pipeline_stages.indexOf(stage) === -1) {
      s = ensurePipelineStage(s, stage);
    }
    s = learnFields(s, 'opportunities', data);
    s = clone(s);
    var id = generateId('opp');
    var probs = s._schema ? s._schema.stage_probabilities : DEFAULT_STAGE_PROB;
    var record = {
      id: id,
      name: data.name || 'Unnamed Opportunity',
      accountId: data.accountId || '',
      stage: stage,
      value: data.value || 0,
      probability: data.probability !== undefined ? data.probability : (probs[stage] || 0),
      owner: data.owner || 'system',
      expected_close: data.expected_close || '',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.opportunities[id] = record;
    return { state: s, record: record };
  }

  function updateStage(state, oppId, newStage) {
    if (!state.opportunities[oppId]) { return state; }
    var s = state;
    var stages = s._schema ? s._schema.pipeline_stages : DEFAULT_PIPELINE;
    // Molt if unknown stage
    if (stages.indexOf(newStage) === -1) {
      s = ensurePipelineStage(s, newStage);
      stages = s._schema.pipeline_stages;
    }
    s = clone(s);
    var opp = s.opportunities[oppId];
    if (opp.stage === 'closed_won' || opp.stage === 'closed_lost') { return state; }
    opp.stage = newStage;
    var probs = s._schema ? s._schema.stage_probabilities : DEFAULT_STAGE_PROB;
    opp.probability = probs[newStage] !== undefined ? probs[newStage] : opp.probability;
    opp.updatedAt = new Date().toISOString();
    return s;
  }

  function closeDeal(state, oppId, won, details) {
    if (!state.opportunities[oppId]) { return state; }
    var s = clone(state);
    var opp = s.opportunities[oppId];
    opp.stage = won ? 'closed_won' : 'closed_lost';
    opp.probability = won ? 100 : 0;
    if (details && details.value !== undefined) { opp.value = details.value; }
    if (details && details.reason) { opp.close_reason = details.reason; }
    opp.closedAt = new Date().toISOString();
    opp.updatedAt = opp.closedAt;
    return s;
  }

  // --- Activities ---

  function logActivity(state, data) {
    var s = state;
    var actType = data.type || 'task';
    // Molt if unknown activity type
    if (s._schema && s._schema.activity_types.indexOf(actType) === -1) {
      s = ensureActivityType(s, actType);
    }
    s = clone(s);
    var id = generateId('act');
    var record = {
      id: id,
      type: actType,
      subject: data.subject || '',
      regarding: data.regarding || '',
      regardingType: data.regardingType || '',
      status: data.status || 'open',
      owner: data.owner || 'system',
      notes: data.notes || '',
      createdAt: new Date().toISOString()
    };
    s.activities.push(record);
    return { state: s, record: record };
  }

  // --- Notes ---

  function addNote(state, entityType, entityId, text, author) {
    // Look up collection from schema
    var collName = entityType;
    if (!state[collName]) {
      // Try singularâ†’plural
      collName = entityType + 's';
    }
    // Also support legacy singular names
    var singularMap = { account: 'accounts', contact: 'contacts', opportunity: 'opportunities' };
    if (singularMap[entityType]) { collName = singularMap[entityType]; }

    if (!state[collName] || !state[collName][entityId]) { return state; }
    var s = clone(state);
    var entity = s[collName][entityId];
    if (!entity.notes) { entity.notes = []; }
    entity.notes.push({
      text: text,
      author: author || 'system',
      ts: new Date().toISOString()
    });
    return s;
  }

  // --- Query ---

  function query(state, entityType, filters) {
    // Resolve collection name â€” try exact, then plural, then legacy map
    var collName = entityType;
    var legacy = {
      account: 'accounts', accounts: 'accounts',
      contact: 'contacts', contacts: 'contacts',
      opportunity: 'opportunities', opportunities: 'opportunities',
      activity: 'activities', activities: 'activities'
    };
    if (legacy[entityType]) {
      collName = legacy[entityType];
    } else if (!state[collName] && state[collName + 's']) {
      collName = collName + 's';
    }

    var source = state[collName];
    if (!source) { return []; }
    var items;

    if (Array.isArray(source)) {
      items = source.slice();
    } else {
      items = [];
      for (var k in source) {
        if (source.hasOwnProperty(k)) {
          items.push(source[k]);
        }
      }
    }

    if (!filters) { return items; }

    return items.filter(function(item) {
      for (var key in filters) {
        if (filters.hasOwnProperty(key)) {
          if (item[key] !== filters[key]) { return false; }
        }
      }
      return true;
    });
  }

  // --- Metrics ---

  function getMetrics(state) {
    var accounts = state.accounts || {};
    var opportunities = state.opportunities || {};
    var contacts = state.contacts || {};
    var activities = state.activities || [];
    var stages = (state._schema && state._schema.pipeline_stages) || DEFAULT_PIPELINE;

    var accountCount = 0;
    for (var a in accounts) { if (accounts.hasOwnProperty(a)) { accountCount++; } }

    var contactCount = 0;
    for (var c in contacts) { if (contacts.hasOwnProperty(c)) { contactCount++; } }

    var oppCount = 0;
    var pipelineValue = 0;
    var wonCount = 0;
    var lostCount = 0;
    var wonValue = 0;
    var closedCount = 0;
    var stageBreakdown = {};

    for (var i = 0; i < stages.length; i++) {
      stageBreakdown[stages[i]] = { count: 0, value: 0 };
    }

    for (var o in opportunities) {
      if (opportunities.hasOwnProperty(o)) {
        var opp = opportunities[o];
        oppCount++;
        var stage = opp.stage || 'prospecting';
        if (stageBreakdown[stage]) {
          stageBreakdown[stage].count++;
          stageBreakdown[stage].value += opp.value || 0;
        }
        if (stage === 'closed_won') {
          wonCount++;
          wonValue += opp.value || 0;
          closedCount++;
        } else if (stage === 'closed_lost') {
          lostCount++;
          closedCount++;
        } else {
          pipelineValue += opp.value || 0;
        }
      }
    }

    var conversionRate = closedCount > 0 ? Math.round((wonCount / closedCount) * 100) : 0;

    // Count molted collections beyond the 3 defaults
    var extraCollections = [];
    if (state._schema && state._schema.collections) {
      var collKeys = objectKeys(state._schema.collections);
      for (var ci = 0; ci < collKeys.length; ci++) {
        if (['accounts', 'contacts', 'opportunities'].indexOf(collKeys[ci]) === -1) {
          extraCollections.push(collKeys[ci]);
        }
      }
    }

    return {
      accounts_count: accountCount,
      contacts_count: contactCount,
      opportunities_count: oppCount,
      pipeline_value: pipelineValue,
      won_count: wonCount,
      won_value: wonValue,
      lost_count: lostCount,
      conversion_rate: conversionRate,
      activity_count: activities.length,
      stage_breakdown: stageBreakdown,
      molt_count: (state._molt_log || []).length,
      extra_collections: extraCollections
    };
  }

  // --- Simulation tick ---

  var OPEN_STAGES = ['prospecting', 'qualification', 'proposal', 'negotiation'];
  var STAGE_ADVANCE = {
    'prospecting': 'qualification',
    'qualification': 'proposal',
    'proposal': 'negotiation',
    'negotiation': 'closed_won'
  };

  var TICK_DEAL_NAMES = [
    'Enchanted Gem Lot', 'Potion Ingredient Bundle', 'Scroll Consignment',
    'Festival Supply Order', 'Armor Repair Contract', 'Seed Catalog Deal',
    'Map Commission', 'Instrument Materials', 'Forge Fuel Shipment',
    'Textile Dye Batch', 'Herb Subscription', 'Crystal Lens Order',
    'Waystone Part Supply', 'Lantern Oil Contract', 'Rune Ink Purchase'
  ];

  var TICK_ACTIVITY_SUBJECTS = [
    'Checked in on deal progress', 'Sent pricing update',
    'Met to discuss terms', 'Followed up after delivery',
    'Reviewed quarterly numbers', 'Negotiated bulk discount',
    'Introduced new product line', 'Resolved supply delay',
    'Scheduled next review', 'Collected feedback on service'
  ];

  var tickSeed = 1;
  var tickCount = 0;

  function tickRandom() {
    tickSeed = (tickSeed * 1664525 + 1013904223) & 0x7fffffff;
    return (tickSeed & 0xffff) / 0x10000;
  }

  function pickRandom(arr) {
    return arr[Math.floor(tickRandom() * arr.length)];
  }

  function objectKeys(obj) {
    var keys = [];
    for (var k in obj) { if (obj.hasOwnProperty(k)) { keys.push(k); } }
    return keys;
  }

  function simulateTick(state) {
    if (!state || !state.accounts) { return state; }

    tickCount++;
    tickSeed = ((Date.now() + tickCount * 7919) & 0x7fffffff) || 1;
    var s = state;
    var accIds = objectKeys(s.accounts);
    var oppIds = objectKeys(s.opportunities);
    if (accIds.length === 0) { return s; }

    var openOpps = [];
    for (var i = 0; i < oppIds.length; i++) {
      var opp = s.opportunities[oppIds[i]];
      if (opp && OPEN_STAGES.indexOf(opp.stage) !== -1) {
        openOpps.push(opp);
      }
    }

    if (openOpps.length > 0 && tickRandom() < 0.6) {
      var advOpp = pickRandom(openOpps);
      var nextStage = STAGE_ADVANCE[advOpp.stage];
      if (nextStage) {
        s = updateStage(s, advOpp.id, nextStage);
        if (nextStage === 'closed_won') {
          openOpps = openOpps.filter(function(o) { return o.id !== advOpp.id; });
        }
      }
    }

    if (tickRandom() < 0.7) {
      var actTypes = (s._schema && s._schema.activity_types) || DEFAULT_ACTIVITY_TYPES;
      var actOwner = s.accounts[pickRandom(accIds)].owner || 'system';
      var regarding = '';
      var regardingType = '';
      if (openOpps.length > 0 && tickRandom() > 0.3) {
        var refOpp = pickRandom(openOpps);
        regarding = refOpp.id;
        regardingType = 'opportunity';
      } else {
        regarding = pickRandom(accIds);
        regardingType = 'account';
      }
      var actResult = logActivity(s, {
        type: pickRandom(actTypes),
        subject: pickRandom(TICK_ACTIVITY_SUBJECTS),
        regarding: regarding,
        regardingType: regardingType,
        owner: actOwner,
        status: 'completed'
      });
      s = actResult.state;
    }

    if (tickRandom() < 0.15 && accIds.length > 0) {
      var accId = pickRandom(accIds);
      var acct = s.accounts[accId];
      var oppResult = createOpportunity(s, {
        name: pickRandom(TICK_DEAL_NAMES),
        accountId: accId,
        stage: pickRandom(['prospecting', 'prospecting', 'qualification']),
        value: Math.floor(tickRandom() * 4000) + 200,
        owner: acct.owner || 'system'
      });
      s = oppResult.state;
    }

    if (openOpps.length > 0 && tickRandom() < 0.1) {
      var closeOpp = pickRandom(openOpps);
      var won = tickRandom() < 0.65;
      s = closeDeal(s, closeOpp.id, won, {
        reason: won ? 'terms agreed' : 'budget constraints'
      });
    }

    return s;
  }

  // --- Helpers ---

  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function getState() {
    return null;
  }

  // --- Exports ---

  exports.PIPELINE_STAGES = DEFAULT_PIPELINE;
  exports.ACTIVITY_TYPES = DEFAULT_ACTIVITY_TYPES;
  exports.initState = initState;
  exports.applyAction = applyAction;
  exports.createAccount = createAccount;
  exports.updateAccount = updateAccount;
  exports.createContact = createContact;
  exports.updateContact = updateContact;
  exports.createOpportunity = createOpportunity;
  exports.updateStage = updateStage;
  exports.closeDeal = closeDeal;
  exports.logActivity = logActivity;
  exports.addNote = addNote;
  exports.query = query;
  exports.getMetrics = getMetrics;
  exports.getState = getState;
  exports.simulateTick = simulateTick;
  exports.molt = molt;
  exports.ensureCollection = ensureCollection;
  exports.ensurePipelineStage = ensurePipelineStage;
  exports.ensureActivityType = ensureActivityType;

})(typeof module !== 'undefined' ? module.exports : (window.SimCRM = {}));


// world.js
(function(exports) {
  // ========================================================================
  // UNIFIED WORLD â€” Continuous terrain with 8 geographic zones
  // Chunk-based loading, noise heightmap, zone structures, physics
  // ========================================================================

  var playerMeshes = new Map();
  var skyDome = null, sunMesh = null, moonMesh = null, stars = null;
  var clouds = [];
  var animatedObjects = [];
  var loadedChunks = new Map(); // "cx_cz" -> { group, objects[] }
  var activeZone = 'nexus';
  var zoneLights = []; // Night-time point lights at zone landmarks

  // Texture loader and cache
  var textureLoader = null;
  var textureCache = {};
  var ASSET_BASE = '';

  function getTexture(name) {
    if (!textureLoader) {
      if (typeof THREE === 'undefined') return null;
      textureLoader = new THREE.TextureLoader();
      if (typeof window !== 'undefined') {
        var path = window.location.pathname;
        ASSET_BASE = path.substring(0, path.lastIndexOf('/') + 1);
      }
    }
    if (textureCache[name]) return textureCache[name];
    var tex = textureLoader.load(ASSET_BASE + 'assets/textures/' + name);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    textureCache[name] = tex;
    return tex;
  }

  // ========================================================================
  // CONSTANTS
  // ========================================================================

  var CHUNK_SIZE = 64;
  var LOAD_RADIUS = 3; // chunks in each direction
  var WORLD_HALF = 600; // -600 to +600

  // ========================================================================
  // ZONE DEFINITIONS â€” Geographic regions on unified map
  // ========================================================================

  var ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, baseHeight: 2,   color: 0x8888cc, groundColor: 0xb0b0d0, texName: 'stone.png', name: 'The Nexus' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, baseHeight: 0,   color: 0x4caf50, groundColor: 0x3a8f3a, texName: 'grass.png', name: 'The Gardens' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, baseHeight: 4,   color: 0x795548, groundColor: 0x9e9e9e, texName: 'marble.png', name: 'The Athenaeum' },
    studio:     { cx: -200, cz: -100, radius: 60, baseHeight: 1,   color: 0xff9800, groundColor: 0xd4a76a, texName: 'wood.png', name: 'The Studio' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, baseHeight: -1,  color: 0x2e7d32, groundColor: 0x1b5e20, texName: 'grass_dark.png', name: 'The Wilds' },
    agora:      { cx: -190, cz: 120,  radius: 55, baseHeight: 1.5, color: 0xffd700, groundColor: 0xc8a45a, texName: 'cobblestone.png', name: 'The Agora' },
    commons:    { cx: 170,  cz: 190,  radius: 55, baseHeight: 0.5, color: 0xfaf0e6, groundColor: 0xd2b48c, texName: 'dirt_path.png', name: 'The Commons' },
    arena:      { cx: 0,    cz: -240, radius: 55, baseHeight: 3,   color: 0xd2691e, groundColor: 0xe0c097, texName: 'sand.png', name: 'The Arena' }
  };

  // ========================================================================
  // SEEDED RANDOM â€” deterministic world generation
  // ========================================================================

  function hash2D(x, y) {
    var n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    return ((n ^ (n >> 16)) & 0x7fffffff) / 0x7fffffff;
  }

  function smoothstep(t) { return t * t * (3 - 2 * t); }

  function noise2D(x, y) {
    var ix = Math.floor(x), iy = Math.floor(y);
    var fx = x - ix, fy = y - iy;
    fx = smoothstep(fx);
    fy = smoothstep(fy);
    var a = hash2D(ix, iy);
    var b = hash2D(ix + 1, iy);
    var c = hash2D(ix, iy + 1);
    var d = hash2D(ix + 1, iy + 1);
    return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
  }

  function seededRandom(a, b, c) {
    var n = a * 12345 + b * 67890 + (c || 0) * 11111;
    return hash2D(n, n * 7);
  }

  // ========================================================================
  // TERRAIN HEIGHT â€” Multi-octave noise with zone flattening
  // ========================================================================

  function rawTerrainHeight(wx, wz) {
    var h = 0;
    // 4 octaves of noise
    h += noise2D(wx * 0.008, wz * 0.008) * 20;    // broad hills
    h += noise2D(wx * 0.02, wz * 0.02) * 8;        // medium detail
    h += noise2D(wx * 0.06, wz * 0.06) * 3;        // fine detail
    h += noise2D(wx * 0.15, wz * 0.15) * 1;        // micro detail
    return h - 10; // shift baseline down
  }

  function terrainHeight(wx, wz) {
    var raw = rawTerrainHeight(wx, wz);

    // Flatten terrain near zone centers with smooth blend
    for (var zoneId in ZONES) {
      var z = ZONES[zoneId];
      var dx = wx - z.cx, dz = wz - z.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var flatRadius = z.radius * 0.5;
      var blendRadius = z.radius * 0.9;

      if (dist < blendRadius) {
        var t;
        if (dist < flatRadius) {
          t = 1.0;
        } else {
          t = 1.0 - (dist - flatRadius) / (blendRadius - flatRadius);
          t = smoothstep(t);
        }
        raw = raw * (1 - t) + z.baseHeight * t;
      }
    }

    // Flatten paths between zones (connecting to nexus)
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var nx = ZONES.nexus.cx, nz = ZONES.nexus.cz;
      // Distance from point to line segment (nexus -> zone center)
      var pathDist = pointToSegDist(wx, wz, nx, nz, zone.cx, zone.cz);
      if (pathDist < 8) {
        var pathBlend = smoothstep(1.0 - pathDist / 8);
        // Lerp path height between zone base heights
        var segT = projectOnSeg(wx, wz, nx, nz, zone.cx, zone.cz);
        var pathH = ZONES.nexus.baseHeight * (1 - segT) + zone.baseHeight * segT;
        raw = raw * (1 - pathBlend * 0.8) + pathH * pathBlend * 0.8;
      }
    }

    return raw;
  }

  function pointToSegDist(px, pz, ax, az, bx, bz) {
    var abx = bx - ax, abz = bz - az;
    var apx = px - ax, apz = pz - az;
    var t = (apx * abx + apz * abz) / (abx * abx + abz * abz + 0.001);
    t = Math.max(0, Math.min(1, t));
    var cx = ax + t * abx - px, cz = az + t * abz - pz;
    return Math.sqrt(cx * cx + cz * cz);
  }

  function projectOnSeg(px, pz, ax, az, bx, bz) {
    var abx = bx - ax, abz = bz - az;
    var apx = px - ax, apz = pz - az;
    return Math.max(0, Math.min(1, (apx * abx + apz * abz) / (abx * abx + abz * abz + 0.001)));
  }

  // ========================================================================
  // ZONE DETECTION
  // ========================================================================

  function getZoneAtPosition(wx, wz) {
    var closest = 'nexus', closestDist = Infinity;
    for (var zoneId in ZONES) {
      var z = ZONES[zoneId];
      var dx = wx - z.cx, dz = wz - z.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      // Weight by zone radius so smaller zones still "own" their area
      var weighted = dist / z.radius;
      if (weighted < closestDist) {
        closestDist = weighted;
        closest = zoneId;
      }
    }
    return closest;
  }

  function getZoneCenter(zoneId) {
    var z = ZONES[zoneId];
    return z ? { x: z.cx, z: z.cz } : { x: 0, z: 0 };
  }

  function getTerrainHeight(wx, wz) {
    return terrainHeight(wx, wz);
  }

  // ========================================================================
  // CHUNK SYSTEM â€” dynamic terrain loading/unloading
  // ========================================================================

  function chunkKey(cx, cz) { return cx + '_' + cz; }

  function updateChunks(sceneCtx, playerX, playerZ) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var pcx = Math.floor(playerX / CHUNK_SIZE);
    var pcz = Math.floor(playerZ / CHUNK_SIZE);

    // Determine which chunks should be loaded
    var needed = new Set();
    for (var dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
      for (var dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
        needed.add(chunkKey(pcx + dx, pcz + dz));
      }
    }

    // Unload chunks that are too far
    var toRemove = [];
    loadedChunks.forEach(function(chunkData, key) {
      if (!needed.has(key)) {
        sceneCtx.scene.remove(chunkData.group);
        // Dispose geometry/materials
        chunkData.group.traverse(function(obj) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(function(m) { m.dispose(); });
            else obj.material.dispose();
          }
        });
        toRemove.push(key);
      }
    });
    toRemove.forEach(function(key) { loadedChunks.delete(key); });

    // Load new chunks
    needed.forEach(function(key) {
      if (!loadedChunks.has(key)) {
        var parts = key.split('_');
        var cx = parseInt(parts[0]), cz = parseInt(parts[1]);
        generateChunk(sceneCtx.scene, cx, cz);
      }
    });
  }

  function generateChunk(scene, cx, cz) {
    var group = new THREE.Group();
    var wx = cx * CHUNK_SIZE, wz = cz * CHUNK_SIZE;

    // Determine dominant zone for this chunk
    var centerX = wx + CHUNK_SIZE / 2, centerZ = wz + CHUNK_SIZE / 2;
    var zone = getZoneAtPosition(centerX, centerZ);
    var zoneData = ZONES[zone];

    // ---- TERRAIN MESH ----
    var res = 16; // vertices per side
    var step = CHUNK_SIZE / res;
    var geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, res, res);
    var positions = geo.attributes.position.array;
    var colors = new Float32Array(positions.length);

    for (var i = 0; i <= res; i++) {
      for (var j = 0; j <= res; j++) {
        var idx = (i * (res + 1) + j);
        var px = wx + j * step;
        var pz = wz + i * step;
        var h = terrainHeight(px, pz);

        // Set vertex position directly in XZ plane (y-up)
        positions[idx * 3] = j * step;     // local x
        positions[idx * 3 + 1] = h;        // height (y-up)
        positions[idx * 3 + 2] = i * step; // local z

        // Vertex color based on zone/height
        var localZone = getZoneAtPosition(px, pz);
        var lz = ZONES[localZone];
        var r = ((lz.groundColor >> 16) & 0xff) / 255;
        var g = ((lz.groundColor >> 8) & 0xff) / 255;
        var b = (lz.groundColor & 0xff) / 255;

        // Height-based color variation
        var hFactor = Math.max(0, Math.min(1, (h + 5) / 30));
        r = r * (0.8 + hFactor * 0.4);
        g = g * (0.8 + hFactor * 0.2);
        b = b * (0.7 + hFactor * 0.3);

        // Path darkening
        for (var zId in ZONES) {
          if (zId === 'nexus') continue;
          var pDist = pointToSegDist(px, pz, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[zId].cx, ZONES[zId].cz);
          if (pDist < 6) {
            var pathFade = 1 - pDist / 6;
            r = r * (1 - pathFade * 0.3) + 0.55 * pathFade * 0.3;
            g = g * (1 - pathFade * 0.3) + 0.45 * pathFade * 0.3;
            b = b * (1 - pathFade * 0.3) + 0.35 * pathFade * 0.3;
          }
        }

        // World Memory: footpath darkening
        var memCell = getMemoryAtPosition(px, pz);
        if (memCell && memCell.steps > 5) {
          var pathStr = Math.min(1, (memCell.steps - 5) / 45);
          r = r * (1 - pathStr * 0.4) + 0.45 * pathStr * 0.4;
          g = g * (1 - pathStr * 0.4) + 0.35 * pathStr * 0.4;
          b = b * (1 - pathStr * 0.4) + 0.25 * pathStr * 0.4;
        }

        colors[idx * 3] = Math.min(1, r);
        colors[idx * 3 + 1] = Math.min(1, g);
        colors[idx * 3 + 2] = Math.min(1, b);
      }
    }

    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geo.computeVertexNormals();

    var mat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      roughness: 0.9,
      metalness: 0.0,
      flatShading: false
    });

    // Try to apply zone texture
    var tex = getTexture(zoneData.texName);
    if (tex) {
      tex.repeat.set(4, 4);
      mat.map = tex;
    }

    var mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(wx, 0, wz);
    mesh.receiveShadow = false;
    group.add(mesh);

    // ---- WORLD MEMORY OBJECTS (flowers, gathering spots) ----
    generateMemoryObjects(group, cx, cz, wx, wz);

    // ---- DETAIL OBJECTS ----
    generateChunkDetails(group, cx, cz, zone, wx, wz);

    scene.add(group);
    loadedChunks.set(chunkKey(cx, cz), { group: group });
  }

  // ========================================================================
  // WORLD MEMORY OBJECTS â€” Flowers and gathering spot campfires
  // ========================================================================

  function generateMemoryObjects(group, cx, cz, wx, wz) {
    // Scan worldMemory cells that fall in this chunk
    for (var gx = Math.floor(wx / MEMORY_GRID_SIZE); gx <= Math.floor((wx + CHUNK_SIZE) / MEMORY_GRID_SIZE); gx++) {
      for (var gz = Math.floor(wz / MEMORY_GRID_SIZE); gz <= Math.floor((wz + CHUNK_SIZE) / MEMORY_GRID_SIZE); gz++) {
        var key = gx + '_' + gz;
        var cell = worldMemory[key];
        if (!cell) continue;

        var cellX = gx * MEMORY_GRID_SIZE + MEMORY_GRID_SIZE / 2;
        var cellZ = gz * MEMORY_GRID_SIZE + MEMORY_GRID_SIZE / 2;
        var cellY = terrainHeight(cellX, cellZ);

        // Flowers
        if (cell.flowers) {
          for (var f = 0; f < 3; f++) {
            var fx = cellX + (f - 1) * 0.5;
            var fz = cellZ + (f * 0.7 - 0.7);
            var fy = terrainHeight(fx, fz);

            // Stem
            var stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 4);
            var stemMat = new THREE.MeshLambertMaterial({ color: 0x228822 });
            var stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.set(fx - wx, fy + 0.15, fz - wz);
            group.add(stem);

            // Petal
            var petalColors = [0xff6699, 0xffcc33, 0xff3366, 0x9966ff, 0xff9933];
            var petalGeo = new THREE.SphereGeometry(0.12, 6, 4);
            var petalMat = new THREE.MeshLambertMaterial({ color: petalColors[f % petalColors.length] });
            var petal = new THREE.Mesh(petalGeo, petalMat);
            petal.position.set(fx - wx, fy + 0.32, fz - wz);
            group.add(petal);
          }
        }

        // Gathering spots (campfire ring)
        if (cell.gathering > 3) {
          // 3 rocks in a ring
          for (var ri = 0; ri < 3; ri++) {
            var rockAngle = (ri / 3) * Math.PI * 2;
            var rockX = cellX + Math.cos(rockAngle) * 0.8;
            var rockZ = cellZ + Math.sin(rockAngle) * 0.8;
            var rockY = terrainHeight(rockX, rockZ);

            var rockGeo = new THREE.SphereGeometry(0.2, 4, 3);
            var rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            var rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(rockX - wx, rockY + 0.1, rockZ - wz);
            rock.scale.y = 0.5;
            group.add(rock);
          }

          // Orange glow
          var glowLight = new THREE.PointLight(0xff6622, 0.5, 5);
          glowLight.position.set(cellX - wx, cellY + 0.3, cellZ - wz);
          group.add(glowLight);
        }
      }
    }
  }

  // ========================================================================
  // CHUNK DETAIL GENERATION â€” trees, rocks, flowers, grass clumps
  // ========================================================================

  function generateChunkDetails(group, cx, cz, zone, wx, wz) {
    var seed = cx * 7919 + cz * 6271;

    // Skip details for chunks far from any zone
    var nearZone = false;
    for (var zId in ZONES) {
      var z = ZONES[zId];
      var dx = (wx + CHUNK_SIZE / 2) - z.cx;
      var dz = (wz + CHUNK_SIZE / 2) - z.cz;
      if (Math.sqrt(dx * dx + dz * dz) < z.radius + CHUNK_SIZE) {
        nearZone = true;
        break;
      }
    }

    // Trees density based on zone
    var treeDensity = 0;
    if (zone === 'gardens') treeDensity = 12;
    else if (zone === 'wilds') treeDensity = 18;
    else if (zone === 'commons') treeDensity = 4;
    else if (zone === 'studio') treeDensity = 3;
    else if (zone === 'agora') treeDensity = 2;
    else treeDensity = nearZone ? 5 : 8; // wilderness between zones

    for (var t = 0; t < treeDensity; t++) {
      var tx = wx + seededRandom(seed, t, 1) * CHUNK_SIZE;
      var tz = wz + seededRandom(seed, t, 2) * CHUNK_SIZE;

      // Don't place trees on paths
      var onPath = false;
      for (var pz in ZONES) {
        if (pz === 'nexus') continue;
        if (pointToSegDist(tx, tz, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[pz].cx, ZONES[pz].cz) < 5) {
          onPath = true;
          break;
        }
      }
      if (onPath) continue;

      // Don't place inside zone center structures
      var inCenter = false;
      for (var zId2 in ZONES) {
        var zd = ZONES[zId2];
        var ddx = tx - zd.cx, ddz = tz - zd.cz;
        if (Math.sqrt(ddx * ddx + ddz * ddz) < zd.radius * 0.35) {
          inCenter = true;
          break;
        }
      }
      if (inCenter) continue;

      var th = terrainHeight(tx, tz);
      createTree(group, tx, th, tz, seed + t, zone);
    }

    // Rocks
    var rockDensity = (zone === 'wilds' || zone === 'arena') ? 8 : (zone === 'nexus' || zone === 'athenaeum') ? 4 : 3;
    for (var r = 0; r < rockDensity; r++) {
      var rx = wx + seededRandom(seed + 100, r, 1) * CHUNK_SIZE;
      var rz = wz + seededRandom(seed + 100, r, 2) * CHUNK_SIZE;
      var rh = terrainHeight(rx, rz);
      createRock(group, rx, rh, rz, seed + 100 + r);
    }

    // Flowers (gardens, commons)
    if (zone === 'gardens' || zone === 'commons' || zone === 'wilds') {
      var flowerDensity = zone === 'gardens' ? 20 : 8;
      for (var f = 0; f < flowerDensity; f++) {
        var fx = wx + seededRandom(seed + 200, f, 1) * CHUNK_SIZE;
        var fz = wz + seededRandom(seed + 200, f, 2) * CHUNK_SIZE;
        var fh = terrainHeight(fx, fz);
        createFlower(group, fx, fh, fz, seed + 200 + f);
      }
    }

    // Grass clumps everywhere
    var grassDensity = (zone === 'gardens' || zone === 'wilds') ? 15 : (zone === 'arena' || zone === 'nexus') ? 3 : 8;
    for (var g = 0; g < grassDensity; g++) {
      var gx = wx + seededRandom(seed + 300, g, 1) * CHUNK_SIZE;
      var gz = wz + seededRandom(seed + 300, g, 2) * CHUNK_SIZE;
      var gh = terrainHeight(gx, gz);
      createGrassClump(group, gx, gh, gz, seed + 300 + g);
    }
  }

  // ========================================================================
  // DETAIL OBJECT CREATORS
  // ========================================================================

  function createTree(parent, x, y, z, seed, zone) {
    var treeGroup = new THREE.Group();
    var scale = 0.5 + seededRandom(seed, 0, 5) * 0.5;
    var treeType = seededRandom(seed, 0, 6);

    // Trunk
    var trunkH = 2.5 * scale + seededRandom(seed, 0, 7) * 1.5 * scale;
    var trunkR = 0.15 * scale + seededRandom(seed, 0, 8) * 0.1 * scale;
    var trunkGeo = new THREE.CylinderGeometry(trunkR * 0.7, trunkR, trunkH, 6);
    var trunkColor = zone === 'wilds' ? 0x4a3728 : 0x8B4513;
    var trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.95 });
    var trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = trunkH / 2;
    trunk.castShadow = false;
    treeGroup.add(trunk);

    // Canopy
    if (treeType < 0.4) {
      // Round tree
      var canopyR = 1.2 * scale + seededRandom(seed, 0, 9) * 0.8 * scale;
      var canopyGeo = new THREE.SphereGeometry(canopyR, 8, 8);
      var canopyColor = zone === 'wilds' ? 0x1a5e1a : (zone === 'gardens' ? 0x4CAF50 : 0x2d8a2d);
      var canopyMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.85 });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.y = trunkH + canopyR * 0.6;
      canopy.castShadow = false;
      treeGroup.add(canopy);
    } else if (treeType < 0.7) {
      // Cone tree (pine)
      var pineH = 3 * scale;
      var pineR = 1.2 * scale;
      var pineGeo = new THREE.ConeGeometry(pineR, pineH, 8);
      var pineColor = zone === 'wilds' ? 0x0d4d0d : 0x1b7a1b;
      var pineMat = new THREE.MeshStandardMaterial({ color: pineColor, roughness: 0.85 });
      var pine = new THREE.Mesh(pineGeo, pineMat);
      pine.position.y = trunkH + pineH / 2 - 0.5;
      pine.castShadow = false;
      treeGroup.add(pine);
    } else {
      // Multi-sphere canopy
      for (var cs = 0; cs < 3; cs++) {
        var msr = 0.8 * scale + seededRandom(seed + cs, 0, 10) * 0.5 * scale;
        var msGeo = new THREE.SphereGeometry(msr, 6, 6);
        var msColor = 0x2d8a2d + Math.floor(seededRandom(seed + cs, 0, 11) * 0x202020);
        var msMat = new THREE.MeshStandardMaterial({ color: msColor, roughness: 0.85 });
        var msMesh = new THREE.Mesh(msGeo, msMat);
        var angle = cs * Math.PI * 2 / 3;
        msMesh.position.set(
          Math.cos(angle) * 0.8 * scale,
          trunkH + msr * 0.4 + cs * 0.5 * scale,
          Math.sin(angle) * 0.8 * scale
        );
        msMesh.castShadow = false;
        treeGroup.add(msMesh);
      }
    }

    treeGroup.position.set(x, y, z);
    treeGroup.rotation.y = seededRandom(seed, 0, 12) * Math.PI * 2;
    parent.add(treeGroup);

    // Register for animation (sway)
    animatedObjects.push({
      mesh: treeGroup,
      type: 'tree',
      params: { speed: 0.3 + seededRandom(seed, 0, 13) * 0.4, seed: seed * 0.01 }
    });
  }

  function createRock(parent, x, y, z, seed) {
    var scale = 0.3 + seededRandom(seed, 1, 1) * 1.2;
    var geo = new THREE.DodecahedronGeometry(scale, 0);
    var grey = 0.4 + seededRandom(seed, 1, 2) * 0.3;
    var col = new THREE.Color(grey, grey, grey * 0.95);
    var mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.95, flatShading: true });
    var rock = new THREE.Mesh(geo, mat);
    rock.position.set(x, y + scale * 0.3, z);
    rock.rotation.set(
      seededRandom(seed, 1, 3) * Math.PI,
      seededRandom(seed, 1, 4) * Math.PI,
      seededRandom(seed, 1, 5) * Math.PI
    );
    rock.scale.set(
      0.7 + seededRandom(seed, 1, 6) * 0.6,
      0.5 + seededRandom(seed, 1, 7) * 0.5,
      0.7 + seededRandom(seed, 1, 8) * 0.6
    );
    rock.castShadow = false;
    parent.add(rock);
  }

  function createFlower(parent, x, y, z, seed) {
    var flowerGroup = new THREE.Group();
    // Stem
    var stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
    var stemMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
    var stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.y = 0.2;
    stem.castShadow = false;
    flowerGroup.add(stem);
    // Petals
    var petalColors = [0xff4081, 0xffeb3b, 0xe040fb, 0xff5722, 0x29b6f6, 0xffffff];
    var petalColor = petalColors[Math.floor(seededRandom(seed, 2, 1) * petalColors.length)];
    var petalGeo = new THREE.SphereGeometry(0.12, 6, 6);
    var petalMat = new THREE.MeshStandardMaterial({ color: petalColor });
    var petal = new THREE.Mesh(petalGeo, petalMat);
    petal.position.y = 0.42;
    petal.castShadow = false;
    flowerGroup.add(petal);

    flowerGroup.position.set(x, y, z);
    parent.add(flowerGroup);
  }

  function createGrassClump(parent, x, y, z, seed) {
    var count = 3 + Math.floor(seededRandom(seed, 3, 1) * 4);
    var grassGroup = new THREE.Group();
    for (var i = 0; i < count; i++) {
      var bladeH = 0.3 + seededRandom(seed, 3, i + 2) * 0.5;
      var bladeGeo = new THREE.ConeGeometry(0.03, bladeH, 3);
      var green = 0.3 + seededRandom(seed, 3, i + 10) * 0.4;
      var bladeMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0.1, green, 0.05)
      });
      var blade = new THREE.Mesh(bladeGeo, bladeMat);
      blade.position.set(
        (seededRandom(seed, 3, i + 20) - 0.5) * 0.6,
        bladeH / 2,
        (seededRandom(seed, 3, i + 30) - 0.5) * 0.6
      );
      blade.rotation.set(
        (seededRandom(seed, 3, i + 40) - 0.5) * 0.3,
        seededRandom(seed, 3, i + 50) * Math.PI,
        (seededRandom(seed, 3, i + 60) - 0.5) * 0.3
      );
      blade.castShadow = false;
      grassGroup.add(blade);
    }
    grassGroup.position.set(x, y, z);
    parent.add(grassGroup);
  }

  // ========================================================================
  // ZONE STRUCTURES â€” Landmark buildings at each zone center
  // ========================================================================

  function createZoneStructures(scene) {
    createNexusStructure(scene);
    createGardensStructure(scene);
    createAtheneumStructure(scene);
    createStudioStructure(scene);
    createWildsStructure(scene);
    createAgoraStructure(scene);
    createCommonsStructure(scene);
    createArenaStructure(scene);
    createPortals(scene);
  }

  // Night-time warm point lights at zone landmarks
  function createZoneNightLights(scene) {
    var lightDefs = [
      // nexus: pillars + obelisk
      { x: 5, z: 5, y: 4, zone: 'nexus' },
      { x: -5, z: 5, y: 4, zone: 'nexus' },
      { x: -5, z: -5, y: 4, zone: 'nexus' },
      { x: 0, z: 0, y: 6, zone: 'nexus' },
      // gardens: fountain + paths
      { x: 200, z: 30, y: 3, zone: 'gardens' },
      { x: 210, z: 40, y: 2.5, zone: 'gardens' },
      { x: 190, z: 20, y: 2.5, zone: 'gardens' },
      // athenaeum: library windows + entrance
      { x: 100, z: -220, y: 4, zone: 'athenaeum' },
      { x: 105, z: -215, y: 4, zone: 'athenaeum' },
      { x: 95, z: -225, y: 3, zone: 'athenaeum' },
      // studio: workbenches
      { x: -200, z: -100, y: 3, zone: 'studio' },
      { x: -195, z: -95, y: 3, zone: 'studio' },
      // agora: market stalls + central
      { x: -190, z: 120, y: 3, zone: 'agora' },
      { x: -185, z: 125, y: 3, zone: 'agora' },
      { x: -195, z: 115, y: 3.5, zone: 'agora' },
      // commons: near buildings
      { x: 170, z: 190, y: 3, zone: 'commons' },
      { x: 175, z: 195, y: 3, zone: 'commons' },
      // wilds: campfire clearing
      { x: -30, z: 260, y: 2.5, zone: 'wilds' },
      // arena: perimeter braziers
      { x: 8, z: -240, y: 3.5, zone: 'arena' },
      { x: -8, z: -240, y: 3.5, zone: 'arena' }
    ];

    var glowGeo = new THREE.SphereGeometry(0.15, 8, 8);

    for (var i = 0; i < lightDefs.length; i++) {
      var def = lightDefs[i];
      var ty = terrainHeight(def.x, def.z) + def.y;

      var light = new THREE.PointLight(0xffaa55, 0, 15, 2);
      light.position.set(def.x, ty, def.z);
      scene.add(light);

      // Visible glow sphere
      var glowMat = new THREE.MeshBasicMaterial({
        color: 0xffcc66,
        transparent: true,
        opacity: 0
      });
      var glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.set(def.x, ty, def.z);
      scene.add(glow);

      zoneLights.push({ light: light, glow: glow, zone: def.zone });
    }
  }

  function createNexusStructure(scene) {
    var z = ZONES.nexus, y = z.baseHeight;
    // Central platform â€” large circular stone platform
    var platGeo = new THREE.CylinderGeometry(12, 14, 1.5, 32);
    var platMat = new THREE.MeshStandardMaterial({ color: 0xc0c0d0, roughness: 0.7 });
    var plat = new THREE.Mesh(platGeo, platMat);
    plat.position.set(z.cx, y + 0.75, z.cz);
    plat.castShadow = false;
    scene.add(plat);

    // Central crystal obelisk
    var obGeo = new THREE.CylinderGeometry(0.5, 1.5, 10, 6);
    var obMat = new THREE.MeshStandardMaterial({ color: 0x6666ff, emissive: 0x3333aa, emissiveIntensity: 0.4 });
    var obelisk = new THREE.Mesh(obGeo, obMat);
    obelisk.position.set(z.cx, y + 6.5, z.cz);
    obelisk.castShadow = false;
    scene.add(obelisk);
    animatedObjects.push({ mesh: obelisk, type: 'crystal', params: { speed: 0.3, baseY: y + 6.5 } });

    // 8 pillars in circle
    for (var i = 0; i < 8; i++) {
      var angle = (i / 8) * Math.PI * 2;
      var px = z.cx + Math.cos(angle) * 10;
      var pz = z.cz + Math.sin(angle) * 10;
      var pillarGeo = new THREE.CylinderGeometry(0.4, 0.5, 6, 8);
      var pillarMat = new THREE.MeshStandardMaterial({ color: 0xd0d0e0 });
      var pillar = new THREE.Mesh(pillarGeo, pillarMat);
      pillar.position.set(px, y + 3, pz);
      pillar.castShadow = false;
      scene.add(pillar);

      // Pillar cap
      var capGeo = new THREE.SphereGeometry(0.6, 8, 8);
      var capMat = new THREE.MeshStandardMaterial({ color: 0xe0e0f0 });
      var cap = new THREE.Mesh(capGeo, capMat);
      cap.position.set(px, y + 6.2, pz);
      cap.castShadow = false;
      scene.add(cap);
    }

    // Glowing pool around obelisk
    var poolGeo = new THREE.CylinderGeometry(4, 4, 0.3, 24);
    var poolMat = new THREE.MeshStandardMaterial({
      color: 0x4488ff, emissive: 0x2244aa, emissiveIntensity: 0.3,
      transparent: true, opacity: 0.7
    });
    var pool = new THREE.Mesh(poolGeo, poolMat);
    pool.position.set(z.cx, y + 0.15, z.cz);
    pool.castShadow = false;
    scene.add(pool);
    animatedObjects.push({ mesh: pool, type: 'water', params: { speed: 1 } });

    // ENHANCED DECORATIONS: Glowing central monument
    var monumentGeo = new THREE.CylinderGeometry(0.8, 1.2, 3, 8);
    var monumentMat = new THREE.MeshStandardMaterial({
      color: 0xb0b0d0,
      emissive: 0x5555aa,
      emissiveIntensity: 0.2,
      roughness: 0.5
    });
    var monument = new THREE.Mesh(monumentGeo, monumentMat);
    monument.position.set(z.cx + 6, y + 2.5, z.cz + 6);
    monument.castShadow = false;
    scene.add(monument);

    // Fountain particle effects (4 water jets)
    for (var j = 0; j < 4; j++) {
      var jAngle = (j / 4) * Math.PI * 2;
      var jx = z.cx + Math.cos(jAngle) * 2;
      var jz = z.cz + Math.sin(jAngle) * 2;
      var jetGeo = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 8);
      var jetMat = new THREE.MeshStandardMaterial({
        color: 0x66aaff,
        transparent: true,
        opacity: 0.6
      });
      var jet = new THREE.Mesh(jetGeo, jetMat);
      jet.position.set(jx, y + 2.5, jz);
      jet.castShadow = false;
      scene.add(jet);
      animatedObjects.push({ mesh: jet, type: 'water', params: { speed: 2 } });
    }

    // Decorative benches around perimeter
    for (var b = 0; b < 4; b++) {
      var bAngle = (b / 4) * Math.PI * 2 + Math.PI / 8;
      var bx = z.cx + Math.cos(bAngle) * 16;
      var bz = z.cz + Math.sin(bAngle) * 16;

      var benchGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
      var benchMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(bx, y + 0.4, bz);
      bench.rotation.y = bAngle + Math.PI / 2;
      bench.castShadow = false;
      scene.add(bench);

      // Bench legs
      for (var leg = -1; leg <= 1; leg += 2) {
        var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 6);
        var legMesh = new THREE.Mesh(legGeo, benchMat);
        legMesh.position.set(
          bx + Math.cos(bAngle + Math.PI / 2) * leg * 0.9,
          y + 0.2,
          bz + Math.sin(bAngle + Math.PI / 2) * leg * 0.9
        );
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    // Knowledge orbs floating around
    for (var k = 0; k < 3; k++) {
      var kAngle = (k / 3) * Math.PI * 2;
      var kx = z.cx + Math.cos(kAngle) * 7;
      var kz = z.cz + Math.sin(kAngle) * 7;
      var orbGeo = new THREE.SphereGeometry(0.3, 12, 12);
      var orbMat = new THREE.MeshStandardMaterial({
        color: 0x8888ff,
        emissive: 0x6666cc,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(kx, y + 4 + k * 0.5, kz);
      orb.castShadow = false;
      scene.add(orb);
      animatedObjects.push({ mesh: orb, type: 'crystal', params: { speed: 0.4, baseY: y + 4 + k * 0.5 } });
    }
  }

  function createGardensStructure(scene) {
    var z = ZONES.gardens, y = z.baseHeight;
    // Garden beds in concentric circles
    for (var ring = 0; ring < 3; ring++) {
      var radius = 8 + ring * 8;
      var segments = 8 + ring * 4;
      for (var s = 0; s < segments; s++) {
        var angle = (s / segments) * Math.PI * 2;
        var bx = z.cx + Math.cos(angle) * radius;
        var bz = z.cz + Math.sin(angle) * radius;
        // Raised bed
        var bedGeo = new THREE.BoxGeometry(3, 0.6, 3);
        var bedMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var bed = new THREE.Mesh(bedGeo, bedMat);
        bed.position.set(bx, y + 0.3, bz);
        bed.rotation.y = angle;
        bed.castShadow = false;
        scene.add(bed);
        // Plants on bed
        var plantGeo = new THREE.SphereGeometry(0.8, 6, 6);
        var plantColors = [0x4caf50, 0x66bb6a, 0x81c784, 0xa5d6a7];
        var plantMat = new THREE.MeshStandardMaterial({
          color: plantColors[s % plantColors.length]
        });
        var plant = new THREE.Mesh(plantGeo, plantMat);
        plant.position.set(bx, y + 1.0, bz);
        plant.castShadow = false;
        scene.add(plant);
      }
    }

    // Central fountain
    var fountainGeo = new THREE.CylinderGeometry(3, 3.5, 1.5, 16);
    var fountainMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
    var fountain = new THREE.Mesh(fountainGeo, fountainMat);
    fountain.position.set(z.cx, y + 0.75, z.cz);
    fountain.castShadow = false;
    scene.add(fountain);

    var waterGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.3, 16);
    var waterMat = new THREE.MeshStandardMaterial({
      color: 0x4488cc, transparent: true, opacity: 0.6
    });
    var water = new THREE.Mesh(waterGeo, waterMat);
    water.position.set(z.cx, y + 1.5, z.cz);
    water.castShadow = false;
    scene.add(water);
    animatedObjects.push({ mesh: water, type: 'water', params: { speed: 1 } });

    // ENHANCED DECORATIONS: Seasonal growing plants (varied heights and colors)
    for (var sp = 0; sp < 12; sp++) {
      var spAngle = (sp / 12) * Math.PI * 2 + 0.2;
      var spRadius = 12 + (sp % 3) * 6;
      var spx = z.cx + Math.cos(spAngle) * spRadius;
      var spz = z.cz + Math.sin(spAngle) * spRadius;

      var plantHeight = 0.5 + seededRandom(sp, 10, 1) * 1.5;
      var plantGeo = new THREE.ConeGeometry(0.3, plantHeight, 6);
      var plantColors = [0x66bb6a, 0x81c784, 0xa5d6a7, 0x4caf50, 0x8bc34a];
      var plantMat = new THREE.MeshStandardMaterial({
        color: plantColors[sp % plantColors.length]
      });
      var plant = new THREE.Mesh(plantGeo, plantMat);
      plant.position.set(spx, y + plantHeight / 2, spz);
      plant.castShadow = false;
      scene.add(plant);
    }

    // Butterfly particle effects (small glowing spheres that float around)
    for (var bf = 0; bf < 8; bf++) {
      var bfAngle = (bf / 8) * Math.PI * 2;
      var bfx = z.cx + Math.cos(bfAngle) * (15 + bf % 3 * 5);
      var bfz = z.cz + Math.sin(bfAngle) * (15 + bf % 3 * 5);
      var butterflyGeo = new THREE.SphereGeometry(0.15, 6, 6);
      var butterflyMat = new THREE.MeshStandardMaterial({
        color: bf % 2 === 0 ? 0xffeb3b : 0xff69b4,
        emissive: bf % 2 === 0 ? 0xffeb3b : 0xff69b4,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.7
      });
      var butterfly = new THREE.Mesh(butterflyGeo, butterflyMat);
      butterfly.position.set(bfx, y + 1.5 + bf * 0.2, bfz);
      butterfly.castShadow = false;
      scene.add(butterfly);
      animatedObjects.push({
        mesh: butterfly,
        type: 'crystal',
        params: { speed: 0.5 + bf * 0.1, baseY: y + 1.5 + bf * 0.2 }
      });
    }

    // Garden archways (decorative trellises)
    for (var ga = 0; ga < 4; ga++) {
      var gaAngle = (ga / 4) * Math.PI * 2;
      var gax = z.cx + Math.cos(gaAngle) * 25;
      var gaz = z.cz + Math.sin(gaAngle) * 25;

      // Two posts
      for (var side = -1; side <= 1; side += 2) {
        var postGeo = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
        var postMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var post = new THREE.Mesh(postGeo, postMat);
        var perpAngle = gaAngle + Math.PI / 2;
        post.position.set(
          gax + Math.cos(perpAngle) * side * 1.5,
          y + 1.5,
          gaz + Math.sin(perpAngle) * side * 1.5
        );
        post.castShadow = false;
        scene.add(post);
      }

      // Top beam
      var beamGeo = new THREE.BoxGeometry(3.5, 0.2, 0.2);
      var beamMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.set(gax, y + 3.2, gaz);
      beam.rotation.y = gaAngle + Math.PI / 2;
      beam.castShadow = false;
      scene.add(beam);

      // Vines on archway
      var vineGeo = new THREE.TorusGeometry(0.8, 0.08, 6, 12);
      var vineMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
      var vine = new THREE.Mesh(vineGeo, vineMat);
      vine.position.set(gax, y + 2.8, gaz);
      vine.rotation.x = Math.PI / 2;
      vine.castShadow = false;
      scene.add(vine);
    }

    // Stone pathways markers
    for (var pm = 0; pm < 6; pm++) {
      var pmAngle = (pm / 6) * Math.PI * 2;
      var pmx = z.cx + Math.cos(pmAngle) * 18;
      var pmz = z.cz + Math.sin(pmAngle) * 18;
      var markerGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
      var markerMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var marker = new THREE.Mesh(markerGeo, markerMat);
      marker.position.set(pmx, y + 0.15, pmz);
      marker.castShadow = false;
      scene.add(marker);
    }
  }

  function createAtheneumStructure(scene) {
    var z = ZONES.athenaeum, y = z.baseHeight;
    // Grand library building
    var baseGeo = new THREE.BoxGeometry(20, 6, 14);
    var baseMat = new THREE.MeshStandardMaterial({ color: 0xdbd8d0 });
    var base = new THREE.Mesh(baseGeo, baseMat);
    base.position.set(z.cx, y + 3, z.cz);
    base.castShadow = false;
    scene.add(base);

    // Roof
    var roofGeo = new THREE.ConeGeometry(14, 4, 4);
    var roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
    var roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.set(z.cx, y + 8, z.cz);
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = false;
    scene.add(roof);

    // Front columns
    for (var c = 0; c < 6; c++) {
      var colX = z.cx - 8 + c * 3.2;
      var colGeo = new THREE.CylinderGeometry(0.4, 0.5, 6, 8);
      var colMat = new THREE.MeshStandardMaterial({ color: 0xe8e4dc });
      var col = new THREE.Mesh(colGeo, colMat);
      col.position.set(colX, y + 3, z.cz + 8);
      col.castShadow = false;
      scene.add(col);
    }

    // Steps
    for (var st = 0; st < 4; st++) {
      var stepGeo = new THREE.BoxGeometry(18 + st * 2, 0.4, 2);
      var stepMat = new THREE.MeshStandardMaterial({ color: 0xccc8c0 });
      var step = new THREE.Mesh(stepGeo, stepMat);
      step.position.set(z.cx, y + 0.2 + st * 0.4, z.cz + 9 + st * 1.5);
      step.castShadow = false;
      scene.add(step);
    }

    // ENHANCED DECORATIONS: Floating book particles
    for (var fb = 0; fb < 10; fb++) {
      var fbAngle = (fb / 10) * Math.PI * 2;
      var fbRadius = 8 + (fb % 3) * 3;
      var fbx = z.cx + Math.cos(fbAngle) * fbRadius;
      var fbz = z.cz + Math.sin(fbAngle) * fbRadius;
      var bookGeo = new THREE.BoxGeometry(0.2, 0.3, 0.05);
      var bookMat = new THREE.MeshStandardMaterial({
        color: [0x8b4513, 0x5d4037, 0x3e2723][fb % 3],
        emissive: 0x4a2511,
        emissiveIntensity: 0.1
      });
      var book = new THREE.Mesh(bookGeo, bookMat);
      book.position.set(fbx, y + 5 + fb * 0.3, fbz);
      book.rotation.y = fbAngle;
      book.rotation.x = Math.PI / 6;
      book.castShadow = false;
      scene.add(book);
      animatedObjects.push({
        mesh: book,
        type: 'crystal',
        params: { speed: 0.2, baseY: y + 5 + fb * 0.3 }
      });
    }

    // Glowing knowledge orbs
    for (var ko = 0; ko < 6; ko++) {
      var koAngle = (ko / 6) * Math.PI * 2;
      var kox = z.cx + Math.cos(koAngle) * 6;
      var koz = z.cz + Math.sin(koAngle) * 6;
      var orbGeo = new THREE.SphereGeometry(0.25, 12, 12);
      var orbMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        emissive: 0xffaa00,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.7
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(kox, y + 6 + ko * 0.4, koz);
      orb.castShadow = false;
      scene.add(orb);
      animatedObjects.push({
        mesh: orb,
        type: 'crystal',
        params: { speed: 0.3, baseY: y + 6 + ko * 0.4 }
      });
    }

    // Reading desks
    for (var rd = 0; rd < 4; rd++) {
      var rdAngle = (rd / 4) * Math.PI * 2 + Math.PI / 4;
      var rdx = z.cx + Math.cos(rdAngle) * 12;
      var rdz = z.cz + Math.sin(rdAngle) * 12;
      var deskGeo = new THREE.BoxGeometry(2, 0.15, 1.2);
      var deskMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var desk = new THREE.Mesh(deskGeo, deskMat);
      desk.position.set(rdx, y + 0.8, rdz);
      desk.rotation.y = rdAngle;
      desk.castShadow = false;
      scene.add(desk);

      // Desk legs
      for (var dl = 0; dl < 4; dl++) {
        var dlx = rdx + Math.cos(rdAngle) * (dl < 2 ? -0.9 : 0.9) + Math.cos(rdAngle + Math.PI / 2) * (dl % 2 === 0 ? -0.5 : 0.5);
        var dlz = rdz + Math.sin(rdAngle) * (dl < 2 ? -0.9 : 0.9) + Math.sin(rdAngle + Math.PI / 2) * (dl % 2 === 0 ? -0.5 : 0.5);
        var legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 6);
        var legMesh = new THREE.Mesh(legGeo, deskMat);
        legMesh.position.set(dlx, y + 0.4, dlz);
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    // Decorative scrolls on pillars
    for (var sc = 0; sc < 6; sc++) {
      var scrollGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
      var scrollMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
      var scroll = new THREE.Mesh(scrollGeo, scrollMat);
      var scx = z.cx - 8 + sc * 3.2;
      scroll.position.set(scx, y + 6, z.cz + 8);
      scroll.rotation.z = Math.PI / 2;
      scroll.castShadow = false;
      scene.add(scroll);
    }

    // Ancient tome pedestals
    for (var tp = 0; tp < 3; tp++) {
      var tpx = z.cx + (tp - 1) * 5;
      var pedestalGeo = new THREE.CylinderGeometry(0.5, 0.7, 1.2, 8);
      var pedestalMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
      pedestal.position.set(tpx, y + 0.6, z.cz - 3);
      pedestal.castShadow = false;
      scene.add(pedestal);

      // Tome on pedestal
      var tomeGeo = new THREE.BoxGeometry(0.6, 0.15, 0.8);
      var tomeMat = new THREE.MeshStandardMaterial({
        color: 0x4a148c,
        emissive: 0x2a0a4c,
        emissiveIntensity: 0.2
      });
      var tome = new THREE.Mesh(tomeGeo, tomeMat);
      tome.position.set(tpx, y + 1.3, z.cz - 3);
      tome.rotation.y = Math.PI / 8;
      tome.castShadow = false;
      scene.add(tome);
    }
  }

  function createStudioStructure(scene) {
    var z = ZONES.studio, y = z.baseHeight;
    // Creative workshop buildings
    for (var i = 0; i < 5; i++) {
      var angle = (i / 5) * Math.PI * 2 + 0.3;
      var bx = z.cx + Math.cos(angle) * 14;
      var bz = z.cz + Math.sin(angle) * 14;

      var buildGeo = new THREE.BoxGeometry(6, 5, 6);
      var buildColors = [0xff9800, 0xffc107, 0xff5722, 0x8bc34a, 0x03a9f4];
      var buildMat = new THREE.MeshStandardMaterial({ color: buildColors[i] });
      var build = new THREE.Mesh(buildGeo, buildMat);
      build.position.set(bx, y + 2.5, bz);
      build.rotation.y = angle + Math.PI;
      build.castShadow = false;
      scene.add(build);

      // Roof
      var sRoofGeo = new THREE.ConeGeometry(4.5, 3, 4);
      var sRoofMat = new THREE.MeshStandardMaterial({ color: 0x795548 });
      var sRoof = new THREE.Mesh(sRoofGeo, sRoofMat);
      sRoof.position.set(bx, y + 6.5, bz);
      sRoof.rotation.y = Math.PI / 4;
      sRoof.castShadow = false;
      scene.add(sRoof);
    }

    // Central sculpture (rotating)
    var sculpGeo = new THREE.OctahedronGeometry(2, 0);
    var sculpMat = new THREE.MeshStandardMaterial({
      color: 0xff6f00, emissive: 0x442200, emissiveIntensity: 0.3
    });
    var sculpture = new THREE.Mesh(sculpGeo, sculpMat);
    sculpture.position.set(z.cx, y + 4, z.cz);
    sculpture.castShadow = false;
    scene.add(sculpture);
    animatedObjects.push({ mesh: sculpture, type: 'crystal', params: { speed: 0.5, baseY: y + 4 } });

    // ENHANCED DECORATIONS: Paint splatter decorations (colorful spheres on ground)
    for (var ps = 0; ps < 15; ps++) {
      var psAngle = (ps / 15) * Math.PI * 2;
      var psRadius = 5 + seededRandom(ps, 20, 1) * 10;
      var psx = z.cx + Math.cos(psAngle) * psRadius;
      var psz = z.cz + Math.sin(psAngle) * psRadius;
      var splatGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var splatColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800, 0x8800ff];
      var splatMat = new THREE.MeshStandardMaterial({
        color: splatColors[ps % splatColors.length],
        emissive: splatColors[ps % splatColors.length],
        emissiveIntensity: 0.3
      });
      var splat = new THREE.Mesh(splatGeo, splatMat);
      splat.position.set(psx, y + 0.15, psz);
      splat.scale.y = 0.3;
      splat.castShadow = false;
      scene.add(splat);
    }

    // Easels around the zone
    for (var ea = 0; ea < 5; ea++) {
      var eaAngle = (ea / 5) * Math.PI * 2 + 0.2;
      var eax = z.cx + Math.cos(eaAngle) * 10;
      var eaz = z.cz + Math.sin(eaAngle) * 10;

      // Easel legs (tripod)
      for (var el = 0; el < 3; el++) {
        var elAngle = eaAngle + (el / 3) * Math.PI * 2;
        var legGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 6);
        var legMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(
          eax + Math.cos(elAngle) * 0.3,
          y + 1,
          eaz + Math.sin(elAngle) * 0.3
        );
        leg.rotation.z = (el === 1 ? -0.2 : (el === 2 ? 0.2 : 0));
        leg.castShadow = false;
        scene.add(leg);
      }

      // Canvas
      var canvasGeo = new THREE.PlaneGeometry(1.2, 1.5);
      var canvasMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });
      var canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.set(eax, y + 1.8, eaz);
      canvas.rotation.y = eaAngle;
      canvas.castShadow = false;
      scene.add(canvas);
    }

    // Musical note particles (for musician artists)
    for (var mn = 0; mn < 6; mn++) {
      var mnAngle = (mn / 6) * Math.PI * 2;
      var mnx = z.cx + Math.cos(mnAngle) * 8;
      var mnz = z.cz + Math.sin(mnAngle) * 8;
      var noteGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var noteMat = new THREE.MeshStandardMaterial({
        color: 0xff69b4,
        emissive: 0xff1493,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.7
      });
      var note = new THREE.Mesh(noteGeo, noteMat);
      note.position.set(mnx, y + 3 + mn * 0.4, mnz);
      note.castShadow = false;
      scene.add(note);
      animatedObjects.push({
        mesh: note,
        type: 'crystal',
        params: { speed: 0.4 + mn * 0.1, baseY: y + 3 + mn * 0.4 }
      });
    }

    // Sculpture pedestals
    for (var sp = 0; sp < 3; sp++) {
      var spAngle = (sp / 3) * Math.PI * 2;
      var spx = z.cx + Math.cos(spAngle) * 18;
      var spz = z.cz + Math.sin(spAngle) * 18;
      var pedGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8);
      var pedMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var ped = new THREE.Mesh(pedGeo, pedMat);
      ped.position.set(spx, y + 0.75, spz);
      ped.castShadow = false;
      scene.add(ped);

      // Small sculpture on pedestal
      var miniSculpGeo = new THREE.TorusGeometry(0.4, 0.15, 8, 12);
      var miniSculpMat = new THREE.MeshStandardMaterial({
        color: [0xff9800, 0x9c27b0, 0x00bcd4][sp],
        emissive: [0xff9800, 0x9c27b0, 0x00bcd4][sp],
        emissiveIntensity: 0.2
      });
      var miniSculp = new THREE.Mesh(miniSculpGeo, miniSculpMat);
      miniSculp.position.set(spx, y + 1.8, spz);
      miniSculp.rotation.x = Math.PI / 4;
      miniSculp.castShadow = false;
      scene.add(miniSculp);
    }

    // Paint palettes on ground
    for (var pp = 0; pp < 4; pp++) {
      var ppx = z.cx + (pp % 2 === 0 ? -6 : 6);
      var ppz = z.cz + (pp < 2 ? -6 : 6);
      var paletteGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 8);
      var paletteMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var palette = new THREE.Mesh(paletteGeo, paletteMat);
      palette.position.set(ppx, y + 0.05, ppz);
      palette.castShadow = false;
      scene.add(palette);
    }
  }

  function createWildsStructure(scene) {
    var z = ZONES.wilds, y = z.baseHeight;
    // Ancient stone circle
    for (var i = 0; i < 12; i++) {
      var angle = (i / 12) * Math.PI * 2;
      var sx = z.cx + Math.cos(angle) * 16;
      var sz = z.cz + Math.sin(angle) * 16;
      var stoneH = 3 + seededRandom(i, 5, 1) * 3;
      var stoneGeo = new THREE.BoxGeometry(1.5, stoneH, 0.8);
      var stoneMat = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.95 });
      var stone = new THREE.Mesh(stoneGeo, stoneMat);
      var sh = terrainHeight(sx, sz);
      stone.position.set(sx, sh + stoneH / 2, sz);
      stone.rotation.y = angle;
      stone.rotation.z = (seededRandom(i, 5, 2) - 0.5) * 0.15;
      stone.castShadow = false;
      scene.add(stone);
    }

    // Moss-covered altar at center
    var altarGeo = new THREE.BoxGeometry(4, 1.5, 4);
    var altarMat = new THREE.MeshStandardMaterial({ color: 0x3e6b3e, roughness: 0.95 });
    var altar = new THREE.Mesh(altarGeo, altarMat);
    altar.position.set(z.cx, y + 0.75, z.cz);
    altar.castShadow = false;
    scene.add(altar);

    // Glowing rune on altar
    var runeGeo = new THREE.RingGeometry(0.5, 1.5, 6);
    var runeMat = new THREE.MeshStandardMaterial({
      color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.5,
      side: THREE.DoubleSide
    });
    var rune = new THREE.Mesh(runeGeo, runeMat);
    rune.position.set(z.cx, y + 1.55, z.cz);
    rune.rotation.x = -Math.PI / 2;
    rune.castShadow = false;
    scene.add(rune);
    animatedObjects.push({ mesh: rune, type: 'crystal', params: { speed: 0.2, baseY: y + 1.55 } });

    // ENHANCED DECORATIONS: More varied trees (different sizes)
    for (var vt = 0; vt < 10; vt++) {
      var vtAngle = (vt / 10) * Math.PI * 2;
      var vtRadius = 20 + seededRandom(vt, 15, 1) * 15;
      var vtx = z.cx + Math.cos(vtAngle) * vtRadius;
      var vtz = z.cz + Math.sin(vtAngle) * vtRadius;
      var treeHeight = 3 + seededRandom(vt, 15, 2) * 4;

      // Trunk
      var trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, treeHeight, 8);
      var trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(vtx, y + treeHeight / 2, vtz);
      trunk.castShadow = false;
      scene.add(trunk);

      // Canopy
      var canopyGeo = new THREE.SphereGeometry(treeHeight * 0.5, 8, 8);
      var canopyMat = new THREE.MeshStandardMaterial({ color: 0x1a5e1a });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.set(vtx, y + treeHeight + treeHeight * 0.3, vtz);
      canopy.castShadow = false;
      scene.add(canopy);
    }

    // Animal tracks (small spheres in dirt)
    for (var at = 0; at < 20; at++) {
      var atAngle = (at / 20) * Math.PI * 2;
      var atRadius = 8 + (at % 5) * 3;
      var atx = z.cx + Math.cos(atAngle) * atRadius;
      var atz = z.cz + Math.sin(atAngle) * atRadius;
      var trackGeo = new THREE.SphereGeometry(0.12, 6, 6);
      var trackMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
      var track = new THREE.Mesh(trackGeo, trackMat);
      track.position.set(atx, y + 0.08, atz);
      track.scale.y = 0.3;
      track.castShadow = false;
      scene.add(track);
    }

    // Fog patches (semi-transparent spheres)
    for (var fg = 0; fg < 6; fg++) {
      var fgAngle = (fg / 6) * Math.PI * 2 + 0.3;
      var fgx = z.cx + Math.cos(fgAngle) * 12;
      var fgz = z.cz + Math.sin(fgAngle) * 12;
      var fogGeo = new THREE.SphereGeometry(2, 8, 8);
      var fogMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        transparent: true,
        opacity: 0.2,
        emissive: 0xaaaaaa,
        emissiveIntensity: 0.1
      });
      var fog = new THREE.Mesh(fogGeo, fogMat);
      fog.position.set(fgx, y + 1, fgz);
      fog.scale.y = 0.4;
      fog.castShadow = false;
      scene.add(fog);
      animatedObjects.push({
        mesh: fog,
        type: 'water',
        params: { speed: 0.3 }
      });
    }

    // Wild mushroom clusters
    for (var wm = 0; wm < 12; wm++) {
      var wmAngle = (wm / 12) * Math.PI * 2;
      var wmRadius = 10 + (wm % 4) * 4;
      var wmx = z.cx + Math.cos(wmAngle) * wmRadius;
      var wmz = z.cz + Math.sin(wmAngle) * wmRadius;

      for (var mc = 0; mc < 3; mc++) {
        var mushroomCapGeo = new THREE.SphereGeometry(0.3, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        var mushroomMat = new THREE.MeshStandardMaterial({
          color: wm % 3 === 0 ? 0xff6b6b : (wm % 3 === 1 ? 0x4ecdc4 : 0xf7b731)
        });
        var mushroomCap = new THREE.Mesh(mushroomCapGeo, mushroomMat);
        mushroomCap.position.set(
          wmx + (mc - 1) * 0.4,
          y + 0.25 + mc * 0.05,
          wmz
        );
        mushroomCap.castShadow = false;
        scene.add(mushroomCap);

        var stemGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 6);
        var stemMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
        var stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.set(
          wmx + (mc - 1) * 0.4,
          y + 0.1 + mc * 0.05,
          wmz
        );
        stem.castShadow = false;
        scene.add(stem);
      }
    }

    // Ancient vine-covered rocks
    for (var vr = 0; vr < 8; vr++) {
      var vrAngle = (vr / 8) * Math.PI * 2;
      var vrx = z.cx + Math.cos(vrAngle) * 18;
      var vrz = z.cz + Math.sin(vrAngle) * 18;
      var rockSize = 0.8 + seededRandom(vr, 25, 1) * 1.2;
      var vineRockGeo = new THREE.SphereGeometry(rockSize, 8, 8);
      var vineRockMat = new THREE.MeshStandardMaterial({ color: 0x3e6b3e });
      var vineRock = new THREE.Mesh(vineRockGeo, vineRockMat);
      vineRock.position.set(vrx, y + rockSize * 0.6, vrz);
      vineRock.scale.y = 0.7;
      vineRock.castShadow = false;
      scene.add(vineRock);
    }
  }

  function createAgoraStructure(scene) {
    var z = ZONES.agora, y = z.baseHeight;
    // Market stalls in rows
    for (var i = 0; i < 8; i++) {
      var sx = z.cx + (i % 4 - 1.5) * 8;
      var sz = z.cz + Math.floor(i / 4) * 14 - 7;
      // Tent top
      var tentGeo = new THREE.ConeGeometry(3, 4, 4);
      var tentColors = [0xdc143c, 0xff8c00, 0x4169e1, 0x2e8b57, 0x9400d3, 0xdaa520, 0x008b8b, 0xcd853f];
      var tentMat = new THREE.MeshStandardMaterial({ color: tentColors[i] });
      var tent = new THREE.Mesh(tentGeo, tentMat);
      tent.position.set(sx, y + 5, sz);
      tent.castShadow = false;
      scene.add(tent);
      // Counter
      var counterGeo = new THREE.BoxGeometry(4, 1, 2);
      var counterMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var counter = new THREE.Mesh(counterGeo, counterMat);
      counter.position.set(sx, y + 0.5, sz + 2.5);
      counter.castShadow = false;
      scene.add(counter);
      // Support poles
      for (var p = -1; p <= 1; p += 2) {
        var poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 6);
        var poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
        var pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.set(sx + p * 2.5, y + 2.5, sz);
        pole.castShadow = false;
        scene.add(pole);
      }
    }

    // Crates
    for (var c = 0; c < 10; c++) {
      var crx = z.cx + (seededRandom(100, c, 1) - 0.5) * 25;
      var crz = z.cz + (seededRandom(100, c, 2) - 0.5) * 25;
      var crateGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
      var crateMat = new THREE.MeshStandardMaterial({ color: 0xd2691e });
      var crate = new THREE.Mesh(crateGeo, crateMat);
      crate.position.set(crx, y + 0.6, crz);
      crate.rotation.y = seededRandom(100, c, 3) * Math.PI;
      crate.castShadow = false;
      scene.add(crate);
    }

    // ENHANCED DECORATIONS: Market stall awnings (already have tents, add rope decorations)
    for (var aw = 0; aw < 8; aw++) {
      var awx = z.cx + (aw % 4 - 1.5) * 8;
      var awz = z.cz + Math.floor(aw / 4) * 14 - 7;

      // Hanging lanterns
      for (var hl = -1; hl <= 1; hl += 2) {
        var lanternGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.4, 6);
        var lanternMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.4
        });
        var lantern = new THREE.Mesh(lanternGeo, lanternMat);
        lantern.position.set(awx + hl * 2, y + 3.5, awz);
        lantern.castShadow = false;
        scene.add(lantern);

        // Rope
        var ropeGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
        var ropeMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
        var rope = new THREE.Mesh(ropeGeo, ropeMat);
        rope.position.set(awx + hl * 2, y + 4.2, awz);
        rope.castShadow = false;
        scene.add(rope);
      }
    }

    // Trading goods displays (colorful items on counters)
    for (var tg = 0; tg < 8; tg++) {
      var tgx = z.cx + (tg % 4 - 1.5) * 8;
      var tgz = z.cz + Math.floor(tg / 4) * 14 - 7 + 2.5;

      // Display items (spheres and boxes)
      for (var di = 0; di < 3; di++) {
        var displayGeo = di % 2 === 0 ? new THREE.SphereGeometry(0.15, 8, 8) : new THREE.BoxGeometry(0.25, 0.25, 0.25);
        var displayColors = [0xff6b6b, 0x4ecdc4, 0xf7b731, 0x5f27cd, 0x00d2d3, 0xff9ff3];
        var displayMat = new THREE.MeshStandardMaterial({
          color: displayColors[(tg + di) % displayColors.length],
          emissive: displayColors[(tg + di) % displayColors.length],
          emissiveIntensity: 0.1
        });
        var display = new THREE.Mesh(displayGeo, displayMat);
        display.position.set(tgx + (di - 1) * 0.5, y + 1.15, tgz);
        display.castShadow = false;
        scene.add(display);
      }
    }

    // Barrels for storage
    for (var br = 0; br < 6; br++) {
      var brAngle = (br / 6) * Math.PI * 2;
      var brx = z.cx + Math.cos(brAngle) * 12;
      var brz = z.cz + Math.sin(brAngle) * 12;
      var barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.2, 12);
      var barrelMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var barrel = new THREE.Mesh(barrelGeo, barrelMat);
      barrel.position.set(brx, y + 0.6, brz);
      barrel.castShadow = false;
      scene.add(barrel);

      // Barrel bands
      for (var bb = 0; bb < 3; bb++) {
        var bandGeo = new THREE.TorusGeometry(0.55, 0.03, 6, 12);
        var bandMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        var band = new THREE.Mesh(bandGeo, bandMat);
        band.position.set(brx, y + 0.3 + bb * 0.4, brz);
        band.rotation.x = Math.PI / 2;
        band.castShadow = false;
        scene.add(band);
      }
    }

    // Decorative rugs under stalls
    for (var rg = 0; rg < 4; rg++) {
      var rgx = z.cx + (rg % 2 - 0.5) * 12;
      var rgz = z.cz + (rg < 2 ? -10 : 10);
      var rugGeo = new THREE.PlaneGeometry(5, 3);
      var rugColors = [0x8b0000, 0x006400, 0x00008b, 0x8b008b];
      var rugMat = new THREE.MeshStandardMaterial({
        color: rugColors[rg],
        side: THREE.DoubleSide
      });
      var rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.set(rgx, y + 0.02, rgz);
      rug.rotation.x = -Math.PI / 2;
      rug.castShadow = false;
      scene.add(rug);
    }

    // Signposts
    for (var sgn = 0; sgn < 4; sgn++) {
      var sgnAngle = (sgn / 4) * Math.PI * 2;
      var sgnx = z.cx + Math.cos(sgnAngle) * 20;
      var sgnz = z.cz + Math.sin(sgnAngle) * 20;

      // Post
      var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      var postMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var post = new THREE.Mesh(postGeo, postMat);
      post.position.set(sgnx, y + 1.5, sgnz);
      post.castShadow = false;
      scene.add(post);

      // Sign
      var signGeo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
      var signMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
      var sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(sgnx, y + 3.2, sgnz);
      sign.rotation.y = sgnAngle;
      sign.castShadow = false;
      scene.add(sign);
    }
  }

  function createCommonsStructure(scene) {
    var z = ZONES.commons, y = z.baseHeight;
    // Small houses in circle
    for (var i = 0; i < 8; i++) {
      var angle = (i / 8) * Math.PI * 2;
      var hx = z.cx + Math.cos(angle) * 18;
      var hz = z.cz + Math.sin(angle) * 18;
      // House body
      var houseGeo = new THREE.BoxGeometry(5, 4, 5);
      var houseColors = [0xfaf0e6, 0xf5deb3, 0xffefd5, 0xffe4c4, 0xffdab9, 0xeee8aa, 0xfafad2, 0xfff8dc];
      var houseMat = new THREE.MeshStandardMaterial({ color: houseColors[i] });
      var house = new THREE.Mesh(houseGeo, houseMat);
      house.position.set(hx, y + 2, hz);
      house.rotation.y = angle + Math.PI;
      house.castShadow = false;
      scene.add(house);
      // Roof
      var roofGeo = new THREE.ConeGeometry(4, 2.5, 4);
      var roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var roofMesh = new THREE.Mesh(roofGeo, roofMat);
      roofMesh.position.set(hx, y + 5.25, hz);
      roofMesh.rotation.y = Math.PI / 4;
      roofMesh.castShadow = false;
      scene.add(roofMesh);
      // Door
      var doorGeo = new THREE.BoxGeometry(1, 2.5, 0.1);
      var doorMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(hx + Math.cos(angle + Math.PI) * 2.55, y + 1.25, hz + Math.sin(angle + Math.PI) * 2.55);
      door.rotation.y = angle + Math.PI;
      door.castShadow = false;
      scene.add(door);
    }

    // Central well
    var wellGeo = new THREE.CylinderGeometry(1.5, 1.5, 2, 12);
    var wellMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
    var well = new THREE.Mesh(wellGeo, wellMat);
    well.position.set(z.cx, y + 1, z.cz);
    well.castShadow = false;
    scene.add(well);

    // Well roof
    var wellRoofGeo = new THREE.ConeGeometry(2.2, 2, 6);
    var wellRoofMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    var wellRoof = new THREE.Mesh(wellRoofGeo, wellRoofMat);
    wellRoof.position.set(z.cx, y + 3.5, z.cz);
    wellRoof.castShadow = false;
    scene.add(wellRoof);

    // Well supports
    for (var ws = 0; ws < 4; ws++) {
      var wa = (ws / 4) * Math.PI * 2;
      var wpGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.5, 4);
      var wpMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var wp = new THREE.Mesh(wpGeo, wpMat);
      wp.position.set(z.cx + Math.cos(wa) * 1.2, y + 2.25, z.cz + Math.sin(wa) * 1.2);
      wp.castShadow = false;
      scene.add(wp);
    }

    // ENHANCED DECORATIONS: Benches in gathering circles
    for (var bc = 0; bc < 6; bc++) {
      var bcAngle = (bc / 6) * Math.PI * 2;
      var bcx = z.cx + Math.cos(bcAngle) * 8;
      var bcz = z.cz + Math.sin(bcAngle) * 8;

      var benchGeo = new THREE.BoxGeometry(2, 0.3, 0.6);
      var benchMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(bcx, y + 0.4, bcz);
      bench.rotation.y = bcAngle + Math.PI / 2;
      bench.castShadow = false;
      scene.add(bench);

      // Bench back
      var backGeo = new THREE.BoxGeometry(2, 0.8, 0.1);
      var back = new THREE.Mesh(backGeo, benchMat);
      back.position.set(
        bcx + Math.cos(bcAngle) * 0.35,
        y + 0.9,
        bcz + Math.sin(bcAngle) * 0.35
      );
      back.rotation.y = bcAngle + Math.PI / 2;
      back.castShadow = false;
      scene.add(back);

      // Bench legs
      for (var bl = -1; bl <= 1; bl += 2) {
        var legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 6);
        var legMesh = new THREE.Mesh(legGeo, benchMat);
        legMesh.position.set(
          bcx + Math.cos(bcAngle + Math.PI / 2) * bl * 0.8,
          y + 0.2,
          bcz + Math.sin(bcAngle + Math.PI / 2) * bl * 0.8
        );
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    // Gathering circles (stone rings)
    for (var gc = 0; gc < 2; gc++) {
      var gcx = z.cx + (gc === 0 ? -10 : 10);
      var gcz = z.cz;

      for (var gs = 0; gs < 10; gs++) {
        var gsAngle = (gs / 10) * Math.PI * 2;
        var stoneGeo = new THREE.BoxGeometry(0.5, 0.3, 0.4);
        var stoneMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
        var stone = new THREE.Mesh(stoneGeo, stoneMat);
        stone.position.set(
          gcx + Math.cos(gsAngle) * 4,
          y + 0.15,
          gcz + Math.sin(gsAngle) * 4
        );
        stone.rotation.y = gsAngle;
        stone.castShadow = false;
        scene.add(stone);
      }
    }

    // Lantern strings connecting houses
    for (var ls = 0; ls < 8; ls++) {
      var lsAngle = (ls / 8) * Math.PI * 2;
      var lsx = z.cx + Math.cos(lsAngle) * 18;
      var lsz = z.cz + Math.sin(lsAngle) * 18;

      // Lanterns hanging from house eaves
      var hangLanternGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var hangLanternMat = new THREE.MeshStandardMaterial({
        color: 0xffeb3b,
        emissive: 0xffc107,
        emissiveIntensity: 0.5
      });
      var hangLantern = new THREE.Mesh(hangLanternGeo, hangLanternMat);
      hangLantern.position.set(lsx, y + 4.5, lsz);
      hangLantern.castShadow = false;
      scene.add(hangLantern);
      animatedObjects.push({
        mesh: hangLantern,
        type: 'torch',
        params: { seed: ls * 100 }
      });

      // String to next house
      var nextAngle = ((ls + 1) / 8) * Math.PI * 2;
      var nextX = z.cx + Math.cos(nextAngle) * 18;
      var nextZ = z.cz + Math.sin(nextAngle) * 18;
      var stringLength = Math.sqrt(Math.pow(nextX - lsx, 2) + Math.pow(nextZ - lsz, 2));
      var stringGeo = new THREE.CylinderGeometry(0.02, 0.02, stringLength, 6);
      var stringMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var string = new THREE.Mesh(stringGeo, stringMat);
      string.position.set((lsx + nextX) / 2, y + 4.5, (lsz + nextZ) / 2);
      string.rotation.y = Math.atan2(nextZ - lsz, nextX - lsx);
      string.rotation.z = Math.PI / 2;
      string.castShadow = false;
      scene.add(string);
    }

    // Flower pots near houses
    for (var fp = 0; fp < 8; fp++) {
      var fpAngle = (fp / 8) * Math.PI * 2;
      var fpx = z.cx + Math.cos(fpAngle) * 16;
      var fpz = z.cz + Math.sin(fpAngle) * 16;

      var potGeo = new THREE.CylinderGeometry(0.3, 0.25, 0.5, 8);
      var potMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var pot = new THREE.Mesh(potGeo, potMat);
      pot.position.set(fpx, y + 0.25, fpz);
      pot.castShadow = false;
      scene.add(pot);

      // Flowers in pot
      var flowerGeo = new THREE.SphereGeometry(0.25, 6, 6);
      var flowerMat = new THREE.MeshStandardMaterial({
        color: [0xff6b9d, 0x4ecdc4, 0xf7b731][fp % 3]
      });
      var flower = new THREE.Mesh(flowerGeo, flowerMat);
      flower.position.set(fpx, y + 0.6, fpz);
      flower.castShadow = false;
      scene.add(flower);
    }

    // Community notice board
    var boardPostGeo = new THREE.CylinderGeometry(0.12, 0.12, 3, 8);
    var boardPostMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    var boardPost = new THREE.Mesh(boardPostGeo, boardPostMat);
    boardPost.position.set(z.cx + 5, y + 1.5, z.cz + 5);
    boardPost.castShadow = false;
    scene.add(boardPost);

    var boardGeo = new THREE.BoxGeometry(2.5, 2, 0.1);
    var boardMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
    var board = new THREE.Mesh(boardGeo, boardMat);
    board.position.set(z.cx + 5, y + 2.5, z.cz + 5);
    board.castShadow = false;
    scene.add(board);

    // Tool racks
    for (var tr = 0; tr < 2; tr++) {
      var trx = z.cx + (tr === 0 ? -12 : 12);
      var trz = z.cz + 8;

      var rackGeo = new THREE.BoxGeometry(1.5, 0.1, 0.3);
      var rackMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var rack = new THREE.Mesh(rackGeo, rackMat);
      rack.position.set(trx, y + 1.5, trz);
      rack.castShadow = false;
      scene.add(rack);

      // Tools on rack (simplified as small boxes)
      for (var tl = 0; tl < 3; tl++) {
        var toolGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
        var toolMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        var tool = new THREE.Mesh(toolGeo, toolMat);
        tool.position.set(trx + (tl - 1) * 0.4, y + 1.1, trz);
        tool.rotation.z = Math.PI / 6;
        tool.castShadow = false;
        scene.add(tool);
      }
    }
  }

  function createArenaStructure(scene) {
    var z = ZONES.arena, y = z.baseHeight;
    // Tiered seating (colosseum-style)
    for (var tier = 0; tier < 4; tier++) {
      var radius = 18 + tier * 6;
      var height = 1.5 + tier * 2;
      var segments = 20 + tier * 4;
      for (var s = 0; s < segments; s++) {
        var a1 = (s / segments) * Math.PI * 2;
        var sx = z.cx + Math.cos(a1) * radius;
        var sz = z.cz + Math.sin(a1) * radius;
        var seatGeo = new THREE.BoxGeometry(3, 1.5, 2.5);
        var seatMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
        var seat = new THREE.Mesh(seatGeo, seatMat);
        seat.position.set(sx, y + height, sz);
        seat.rotation.y = a1;
        seat.castShadow = false;
        scene.add(seat);
      }
    }

    // Central arena floor
    var arenaFloorGeo = new THREE.CylinderGeometry(16, 16, 0.5, 32);
    var arenaFloorMat = new THREE.MeshStandardMaterial({ color: 0xe0c097 });
    var arenaFloor = new THREE.Mesh(arenaFloorGeo, arenaFloorMat);
    arenaFloor.position.set(z.cx, y + 0.25, z.cz);
    arenaFloor.castShadow = false;
    scene.add(arenaFloor);

    // Entrance arches
    for (var ea = 0; ea < 4; ea++) {
      var eAngle = (ea / 4) * Math.PI * 2;
      var ex = z.cx + Math.cos(eAngle) * 16;
      var ez = z.cz + Math.sin(eAngle) * 16;
      // Two pillars
      for (var side = -1; side <= 1; side += 2) {
        var epGeo = new THREE.CylinderGeometry(0.6, 0.7, 7, 8);
        var epMat = new THREE.MeshStandardMaterial({ color: 0xc8a882 });
        var ep = new THREE.Mesh(epGeo, epMat);
        var perpAngle = eAngle + Math.PI / 2;
        ep.position.set(ex + Math.cos(perpAngle) * side * 2.5, y + 3.5, ez + Math.sin(perpAngle) * side * 2.5);
        ep.castShadow = false;
        scene.add(ep);
      }
      // Arch top
      var archGeo = new THREE.BoxGeometry(6, 1, 1.5);
      var archMat = new THREE.MeshStandardMaterial({ color: 0xc8a882 });
      var arch = new THREE.Mesh(archGeo, archMat);
      arch.position.set(ex, y + 7.5, ez);
      arch.rotation.y = eAngle;
      arch.castShadow = false;
      scene.add(arch);
    }

    // Torches around arena
    for (var ti = 0; ti < 12; ti++) {
      var tAngle = (ti / 12) * Math.PI * 2;
      var tpx = z.cx + Math.cos(tAngle) * 20;
      var tpz = z.cz + Math.sin(tAngle) * 20;
      addTorch(scene, tpx, y, tpz);
    }

    // ENHANCED DECORATIONS: Spectator banners
    for (var bn = 0; bn < 8; bn++) {
      var bnAngle = (bn / 8) * Math.PI * 2;
      var bnRadius = 28;
      var bnx = z.cx + Math.cos(bnAngle) * bnRadius;
      var bnz = z.cz + Math.sin(bnAngle) * bnRadius;

      // Banner pole
      var poleGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 8);
      var poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.set(bnx, y + 2, bnz);
      pole.castShadow = false;
      scene.add(pole);

      // Banner cloth
      var bannerGeo = new THREE.PlaneGeometry(1.5, 2.5);
      var bannerColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00];
      var bannerMat = new THREE.MeshStandardMaterial({
        color: bannerColors[bn % bannerColors.length],
        side: THREE.DoubleSide
      });
      var banner = new THREE.Mesh(bannerGeo, bannerMat);
      banner.position.set(bnx, y + 3, bnz);
      banner.rotation.y = bnAngle + Math.PI / 2;
      banner.castShadow = false;
      scene.add(banner);
    }

    // Torch brackets on seating tiers
    for (var tb = 0; tb < 16; tb++) {
      var tbAngle = (tb / 16) * Math.PI * 2;
      var tbRadius = 24;
      var tbx = z.cx + Math.cos(tbAngle) * tbRadius;
      var tbz = z.cz + Math.sin(tbAngle) * tbRadius;

      var bracketGeo = new THREE.BoxGeometry(0.3, 0.15, 0.3);
      var bracketMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      var bracket = new THREE.Mesh(bracketGeo, bracketMat);
      bracket.position.set(tbx, y + 4, tbz);
      bracket.castShadow = false;
      scene.add(bracket);

      // Torch on bracket
      var torchGeo = new THREE.SphereGeometry(0.12, 6, 6);
      var torchMat = new THREE.MeshStandardMaterial({
        color: 0xff6600,
        emissive: 0xff4400,
        emissiveIntensity: 0.8
      });
      var torch = new THREE.Mesh(torchGeo, torchMat);
      torch.position.set(tbx, y + 4.3, tbz);
      torch.castShadow = false;
      scene.add(torch);
      animatedObjects.push({
        mesh: torch,
        type: 'torch',
        params: { seed: tb * 200 }
      });
    }

    // Scoring boards (tall posts with platforms)
    for (var sb = 0; sb < 4; sb++) {
      var sbAngle = (sb / 4) * Math.PI * 2;
      var sbx = z.cx + Math.cos(sbAngle) * 30;
      var sbz = z.cz + Math.sin(sbAngle) * 30;

      // Post
      var scorePostGeo = new THREE.CylinderGeometry(0.2, 0.25, 6, 8);
      var scorePostMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var scorePost = new THREE.Mesh(scorePostGeo, scorePostMat);
      scorePost.position.set(sbx, y + 3, sbz);
      scorePost.castShadow = false;
      scene.add(scorePost);

      // Scoreboard
      var scoreBoardGeo = new THREE.BoxGeometry(2, 1.5, 0.2);
      var scoreBoardMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
      var scoreBoard = new THREE.Mesh(scoreBoardGeo, scoreBoardMat);
      scoreBoard.position.set(sbx, y + 6.5, sbz);
      scoreBoard.rotation.y = sbAngle + Math.PI;
      scoreBoard.castShadow = false;
      scene.add(scoreBoard);
    }

    // Training equipment (dummy posts)
    for (var te = 0; te < 4; te++) {
      var teAngle = (te / 4) * Math.PI * 2 + Math.PI / 8;
      var tex = z.cx + Math.cos(teAngle) * 10;
      var tez = z.cz + Math.sin(teAngle) * 10;

      // Post
      var dummyPostGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
      var dummyPostMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var dummyPost = new THREE.Mesh(dummyPostGeo, dummyPostMat);
      dummyPost.position.set(tex, y + 1.25, tez);
      dummyPost.castShadow = false;
      scene.add(dummyPost);

      // Dummy head
      var dummyHeadGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var dummyHeadMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var dummyHead = new THREE.Mesh(dummyHeadGeo, dummyHeadMat);
      dummyHead.position.set(tex, y + 2.8, tez);
      dummyHead.castShadow = false;
      scene.add(dummyHead);

      // Crossbar arms
      for (var ca = -1; ca <= 1; ca += 2) {
        var armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 6);
        var arm = new THREE.Mesh(armGeo, dummyPostMat);
        arm.position.set(tex + ca * 0.4, y + 2.2, tez);
        arm.rotation.z = Math.PI / 2;
        arm.castShadow = false;
        scene.add(arm);
      }
    }

    // Weapon racks
    for (var wr = 0; wr < 2; wr++) {
      var wrx = z.cx + (wr === 0 ? -14 : 14);
      var wrz = z.cz;

      var weaponRackGeo = new THREE.BoxGeometry(3, 0.15, 0.3);
      var weaponRackMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var weaponRack = new THREE.Mesh(weaponRackGeo, weaponRackMat);
      weaponRack.position.set(wrx, y + 1.5, wrz);
      weaponRack.castShadow = false;
      scene.add(weaponRack);

      // Support posts
      for (var wp = -1; wp <= 1; wp += 2) {
        var wpGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
        var wpMesh = new THREE.Mesh(wpGeo, weaponRackMat);
        wpMesh.position.set(wrx + wp * 1.2, y + 0.75, wrz);
        wpMesh.castShadow = false;
        scene.add(wpMesh);
      }

      // Weapons on rack (simplified as sticks)
      for (var wn = 0; wn < 4; wn++) {
        var weaponGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 6);
        var weaponMat = new THREE.MeshStandardMaterial({ color: 0x8b8b8b });
        var weapon = new THREE.Mesh(weaponGeo, weaponMat);
        weapon.position.set(wrx + (wn - 1.5) * 0.6, y + 0.9, wrz);
        weapon.rotation.z = Math.PI / 6;
        weapon.castShadow = false;
        scene.add(weapon);
      }
    }
  }

  function addTorch(scene, x, baseY, z) {
    var poleGeo = new THREE.CylinderGeometry(0.08, 0.1, 2.5, 6);
    var poleMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
    var pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.set(x, baseY + 1.25, z);
    pole.castShadow = false;
    scene.add(pole);

    var flameGeo = new THREE.SphereGeometry(0.25, 8, 8);
    var flameMat = new THREE.MeshStandardMaterial({
      color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 1
    });
    var flame = new THREE.Mesh(flameGeo, flameMat);
    flame.position.set(x, baseY + 2.7, z);
    flame.castShadow = false;
    scene.add(flame);

    var light = new THREE.PointLight(0xffa500, 0.8, 12);
    light.position.set(x, baseY + 2.7, z);
    scene.add(light);

    animatedObjects.push({
      mesh: flame, type: 'torch',
      params: { seed: x * 100 + z, light: light }
    });
  }

  function createPortals(scene) {
    // Place portals between zones â€” at zone edges toward nexus
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      // Portal sits on the edge of the zone facing nexus
      var dx = ZONES.nexus.cx - zone.cx;
      var dz = ZONES.nexus.cz - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var nx = dx / dist, nz = dz / dist;
      var portalX = zone.cx + nx * zone.radius * 0.7;
      var portalZ = zone.cz + nz * zone.radius * 0.7;
      var portalY = terrainHeight(portalX, portalZ);
      addPortalMesh(scene, portalX, portalY, portalZ, zId);
    }
  }

  function addPortalMesh(scene, x, y, z, targetZone) {
    // Portal archway
    var archGeo = new THREE.TorusGeometry(2.5, 0.25, 12, 24);
    var archMat = new THREE.MeshStandardMaterial({
      color: 0x00ffff, emissive: 0x008888, emissiveIntensity: 0.6
    });
    var arch = new THREE.Mesh(archGeo, archMat);
    arch.position.set(x, y + 3, z);
    arch.castShadow = false;
    scene.add(arch);

    // Inner glow
    var innerGeo = new THREE.CircleGeometry(2.2, 16);
    var innerMat = new THREE.MeshStandardMaterial({
      color: 0x66ffff, emissive: 0x44cccc, emissiveIntensity: 0.4,
      transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    var inner = new THREE.Mesh(innerGeo, innerMat);
    inner.position.set(x, y + 3, z);
    inner.castShadow = false;
    scene.add(inner);

    // Portal light
    var portalLight = new THREE.PointLight(0x00ffff, 0.6, 15);
    portalLight.position.set(x, y + 3, z);
    scene.add(portalLight);

    // Spinning particle rings around portal
    var particleRings = [];
    var ringCount = 2;
    var particlesPerRing = 12;

    for (var r = 0; r < ringCount; r++) {
      var ringRadius = 2.8 + r * 0.4;
      var ringParticles = [];

      for (var p = 0; p < particlesPerRing; p++) {
        var particleGeo = new THREE.SphereGeometry(0.08, 6, 6);
        var particleMat = new THREE.MeshStandardMaterial({
          color: 0x88ffff,
          emissive: 0x44aaaa,
          emissiveIntensity: 0.8
        });
        var particle = new THREE.Mesh(particleGeo, particleMat);
        particle.castShadow = false;
        scene.add(particle);

        ringParticles.push({
          mesh: particle,
          angle: (p / particlesPerRing) * Math.PI * 2,
          radius: ringRadius
        });
      }

      particleRings.push({
        particles: ringParticles,
        speed: 0.001 + r * 0.0005,
        direction: r % 2 === 0 ? 1 : -1
      });
    }

    animatedObjects.push({
      mesh: arch, type: 'portal',
      params: {
        speed: 0.8,
        inner: inner,
        particleRings: particleRings,
        centerX: x,
        centerY: y + 3,
        centerZ: z
      }
    });

    arch.userData.targetZone = targetZone;
  }

  // ========================================================================
  // SKY AND ATMOSPHERE
  // ========================================================================

  function createSky(scene) {
    var skyGeo = new THREE.SphereGeometry(800, 32, 32);
    var skyMat = new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide, fog: false });
    skyDome = new THREE.Mesh(skyGeo, skyMat);
    scene.add(skyDome);

    // Sun
    var sunGeo = new THREE.SphereGeometry(12, 16, 16);
    var sunMat = new THREE.MeshBasicMaterial({ color: 0xfff8e7, fog: false });
    sunMesh = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sunMesh);

    // Moon
    var moonGeo = new THREE.SphereGeometry(8, 16, 16);
    var moonMat = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, fog: false });
    moonMesh = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moonMesh);

    // Stars
    var starGeo = new THREE.BufferGeometry();
    var starPos = [];
    for (var i = 0; i < 1200; i++) {
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.random() * Math.PI;
      var r = 700;
      starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    var starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, fog: false });
    stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // Clouds
    for (var c = 0; c < 30; c++) {
      var cloudGroup = new THREE.Group();
      var numPuffs = 2 + Math.floor(Math.random() * 4);
      for (var p = 0; p < numPuffs; p++) {
        var puffGeo = new THREE.SphereGeometry(8 + Math.random() * 12, 6, 6);
        var puffMat = new THREE.MeshBasicMaterial({
          color: 0xffffff, transparent: true, opacity: 0.35, fog: false
        });
        var puff = new THREE.Mesh(puffGeo, puffMat);
        puff.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 15);
        puff.scale.y = 0.4;
        cloudGroup.add(puff);
      }
      cloudGroup.position.set(
        (Math.random() - 0.5) * 1200,
        180 + Math.random() * 60,
        (Math.random() - 0.5) * 1200
      );
      cloudGroup.userData.driftSpeed = 0.3 + Math.random() * 0.5;
      cloudGroup.userData.driftAngle = Math.random() * Math.PI * 2;
      clouds.push(cloudGroup);
      scene.add(cloudGroup);
    }

    // Fog
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);
  }

  // ========================================================================
  // PLAYER MODELS
  // ========================================================================

  // 8-tone skin palette for character variety
  var SKIN_TONES = [
    0xFFDBAC, 0xF1C27D, 0xE0AC69, 0xC68642,
    0x8D5524, 0x6B3A2A, 0xF5D6C3, 0xD4A574
  ];

  function getSkinTone(seed) {
    var hash = 0;
    if (typeof seed === 'string') {
      for (var i = 0; i < seed.length; i++) {
        hash = ((hash << 5) - hash) + seed.charCodeAt(i);
        hash = hash & hash;
      }
    } else {
      hash = seed || 0;
    }
    return SKIN_TONES[Math.abs(hash) % SKIN_TONES.length];
  }

  function createHumanoidModel(color) {
    var player = new THREE.Group();
    var skinColor = getSkinTone(color || 0x4169e1);
    var skinMat = new THREE.MeshLambertMaterial({ color: skinColor });

    // Head - SphereGeometry, skin-toned
    var headGeo = new THREE.SphereGeometry(0.3, 16, 16);
    var head = new THREE.Mesh(headGeo, skinMat.clone());
    head.position.y = 1.5;
    head.castShadow = false;
    player.add(head);

    // Eyes - white with dark pupils
    var eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var pupilGeo = new THREE.SphereGeometry(0.02, 8, 8);
    var pupilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

    var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.1, 0.05, 0.26);
    var leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
    leftPupil.position.set(0, 0, 0.03);
    leftEye.add(leftPupil);
    head.add(leftEye);

    var rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
    rightEye.position.set(0.1, 0.05, 0.26);
    var rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
    rightPupil.position.set(0, 0, 0.03);
    rightEye.add(rightPupil);
    head.add(rightEye);

    // Hair - pick style based on color hash
    var hairHash = (color || 0x4169e1) % 4;
    var hairColors = [0x1a1a1a, 0x4a3000, 0x8B4513, 0xd4a574];
    var hairMat = new THREE.MeshLambertMaterial({ color: hairColors[hairHash] });
    if (hairHash === 0) {
      // Buzz cut - slightly oversized sphere
      var buzzGeo = new THREE.SphereGeometry(0.31, 16, 16);
      var buzz = new THREE.Mesh(buzzGeo, hairMat);
      buzz.position.y = 0.02;
      buzz.scale.y = 0.9;
      head.add(buzz);
    } else if (hairHash === 1) {
      // Long hair - sphere + box behind
      var longTopGeo = new THREE.SphereGeometry(0.32, 16, 16);
      var longTop = new THREE.Mesh(longTopGeo, hairMat);
      longTop.position.y = 0.05;
      longTop.scale.y = 0.85;
      head.add(longTop);
      var longBackGeo = new THREE.BoxGeometry(0.4, 0.35, 0.15);
      var longBack = new THREE.Mesh(longBackGeo, hairMat.clone());
      longBack.position.set(0, -0.15, -0.18);
      head.add(longBack);
    } else if (hairHash === 2) {
      // Mohawk - narrow box on top
      var mohawkGeo = new THREE.BoxGeometry(0.08, 0.2, 0.4);
      var mohawk = new THREE.Mesh(mohawkGeo, hairMat);
      mohawk.position.y = 0.25;
      head.add(mohawk);
    } else {
      // Bun - small sphere on back
      var bunGeo = new THREE.SphereGeometry(0.12, 8, 8);
      var bun = new THREE.Mesh(bunGeo, hairMat);
      bun.position.set(0, 0.1, -0.28);
      head.add(bun);
    }

    // Neck
    var neckGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.15, 8);
    var neck = new THREE.Mesh(neckGeo, skinMat.clone());
    neck.position.y = 1.28;
    neck.castShadow = false;
    player.add(neck);

    // Torso - BoxGeometry, colored shirt
    var torsoGeo = new THREE.BoxGeometry(0.5, 0.6, 0.3);
    var torsoMat = new THREE.MeshLambertMaterial({ color: color || 0x4169e1 });
    var torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 0.9;
    torso.castShadow = false;
    player.add(torso);

    // Shoulder joints
    var shoulderGeo = new THREE.SphereGeometry(0.1, 8, 8);
    var leftShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    leftShoulder.position.set(-0.35, 1.2, 0);
    leftShoulder.castShadow = false;
    player.add(leftShoulder);

    var rightShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    rightShoulder.position.set(0.35, 1.2, 0);
    rightShoulder.castShadow = false;
    player.add(rightShoulder);

    // Arms - CylinderGeometry, attached at shoulders
    var armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);

    var leftArm = new THREE.Mesh(armGeo, skinMat.clone());
    leftArm.position.set(-0.35, 1.05, 0);
    leftArm.castShadow = false;
    player.add(leftArm);

    // Hands as children of arms
    var handGeo = new THREE.SphereGeometry(0.07, 8, 8);
    var leftHand = new THREE.Mesh(handGeo, skinMat.clone());
    leftHand.position.y = -0.3;
    leftArm.add(leftHand);

    var rightArm = new THREE.Mesh(armGeo, skinMat.clone());
    rightArm.position.set(0.35, 1.05, 0);
    rightArm.castShadow = false;
    player.add(rightArm);

    var rightHand = new THREE.Mesh(handGeo, skinMat.clone());
    rightHand.position.y = -0.3;
    rightArm.add(rightHand);

    // Legs - CylinderGeometry, attached at hips
    var legGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
    var legMat = new THREE.MeshLambertMaterial({ color: 0x2f4f4f });

    var leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, 0.35, 0);
    leftLeg.castShadow = false;
    player.add(leftLeg);

    var rightLeg = new THREE.Mesh(legGeo, legMat.clone());
    rightLeg.position.set(0.15, 0.35, 0);
    rightLeg.castShadow = false;
    player.add(rightLeg);

    // Feet - Small BoxGeometry at bottom of legs
    var footGeo = new THREE.BoxGeometry(0.15, 0.1, 0.25);
    var footMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

    var leftFoot = new THREE.Mesh(footGeo, footMat);
    leftFoot.position.set(-0.15, 0.05, 0.05);
    leftFoot.castShadow = false;
    player.add(leftFoot);

    var rightFoot = new THREE.Mesh(footGeo, footMat.clone());
    rightFoot.position.set(0.15, 0.05, 0.05);
    rightFoot.castShadow = false;
    player.add(rightFoot);

    // Store references to limbs in userData for animation
    player.userData.limbs = {
      head: head,
      torso: torso,
      leftArm: leftArm,
      rightArm: rightArm,
      leftLeg: leftLeg,
      rightLeg: rightLeg,
      leftFoot: leftFoot,
      rightFoot: rightFoot
    };

    // Animation state tracking
    player.userData.animTime = 0;
    player.userData.prevPosition = new THREE.Vector3();
    player.userData.animState = 'idle'; // 'idle', 'walk', 'run'

    return player;
  }

  // ========================================================================
  // ENVIRONMENT POPULATION â€” Trees, rocks, benches, lanterns
  // ========================================================================

  function populateEnvironment(scene) {
    var Models = typeof window !== 'undefined' ? window.Models : null;
    if (!Models) {
      console.log('Models module not loaded, skipping environment population');
      return;
    }

    // ---- Gardens: trees, flowers, benches along paths ----
    var gz = ZONES.gardens;
    var gardenTreeTypes = ['oak', 'willow', 'cherry', 'cherry'];
    for (var gt = 0; gt < 20; gt++) {
      var ga = hash2D(gt, 100) * Math.PI * 2;
      var gr = 15 + hash2D(gt, 101) * 55;
      var gx = gz.cx + Math.cos(ga) * gr;
      var gzz = gz.cz + Math.sin(ga) * gr;
      var gy = terrainHeight(gx, gzz);
      var treeType = gardenTreeTypes[gt % gardenTreeTypes.length];
      var tree = Models.createTree(treeType, 0.8 + hash2D(gt, 102) * 0.6);
      tree.position.set(gx, gy, gzz);
      tree.rotation.y = hash2D(gt, 103) * Math.PI * 2;
      scene.add(tree);
      animatedObjects.push({ mesh: tree, type: 'tree', params: { speed: 0.3 + hash2D(gt, 104) * 0.3 } });
    }
    // Benches in gardens
    for (var gb = 0; gb < 6; gb++) {
      var ba = (gb / 6) * Math.PI * 2 + 0.5;
      var bx = gz.cx + Math.cos(ba) * 25;
      var bz = gz.cz + Math.sin(ba) * 25;
      var by = terrainHeight(bx, bz);
      var bench = Models.createFurniture('bench');
      bench.position.set(bx, by, bz);
      bench.rotation.y = ba + Math.PI / 2;
      scene.add(bench);
    }
    // Lanterns along garden paths
    for (var gl = 0; gl < 10; gl++) {
      var la = (gl / 10) * Math.PI * 2;
      var lx = gz.cx + Math.cos(la) * 35;
      var lz = gz.cz + Math.sin(la) * 35;
      var ly = terrainHeight(lx, lz);
      var lantern = Models.createFurniture('lantern');
      lantern.position.set(lx, ly, lz);
      scene.add(lantern);
    }

    // ---- Wilds: dense forest, boulders, dead trees ----
    var wz = ZONES.wilds;
    var wildTreeTypes = ['oak', 'pine', 'pine', 'dead', 'oak'];
    for (var wt = 0; wt < 40; wt++) {
      var wa = hash2D(wt, 200) * Math.PI * 2;
      var wr = 10 + hash2D(wt, 201) * 70;
      var wx = wz.cx + Math.cos(wa) * wr;
      var wz2 = wz.cz + Math.sin(wa) * wr;
      var wy = terrainHeight(wx, wz2);
      var wildType = wildTreeTypes[wt % wildTreeTypes.length];
      var wtree = Models.createTree(wildType, 0.7 + hash2D(wt, 202) * 0.8);
      wtree.position.set(wx, wy, wz2);
      wtree.rotation.y = hash2D(wt, 203) * Math.PI * 2;
      scene.add(wtree);
      animatedObjects.push({ mesh: wtree, type: 'tree', params: { speed: 0.2 + hash2D(wt, 204) * 0.4 } });
    }
    // Boulders and crystal rocks in wilds
    for (var wb = 0; wb < 15; wb++) {
      var rba = hash2D(wb, 210) * Math.PI * 2;
      var rbr = 8 + hash2D(wb, 211) * 60;
      var rbx = wz.cx + Math.cos(rba) * rbr;
      var rbz = wz.cz + Math.sin(rba) * rbr;
      var rby = terrainHeight(rbx, rbz);
      var rockType = (wb % 5 === 0) ? 'crystal' : 'boulder';
      var rock = Models.createRock(rockType, 0.5 + hash2D(wb, 212) * 1.5);
      rock.position.set(rbx, rby, rbz);
      rock.rotation.y = hash2D(wb, 213) * Math.PI * 2;
      scene.add(rock);
    }

    // ---- Nexus: ornamental trees, benches, lanterns ----
    var nz = ZONES.nexus;
    for (var nt = 0; nt < 8; nt++) {
      var na = (nt / 8) * Math.PI * 2 + Math.PI / 8;
      var nx = nz.cx + Math.cos(na) * 25;
      var nzz = nz.cz + Math.sin(na) * 25;
      var ny = terrainHeight(nx, nzz);
      var ntree = Models.createTree('cherry', 0.7);
      ntree.position.set(nx, ny, nzz);
      scene.add(ntree);
      animatedObjects.push({ mesh: ntree, type: 'tree', params: { speed: 0.3 } });
    }
    // Stone benches around nexus
    for (var nb = 0; nb < 8; nb++) {
      var nba = (nb / 8) * Math.PI * 2;
      var nbx = nz.cx + Math.cos(nba) * 18;
      var nbz = nz.cz + Math.sin(nba) * 18;
      var nby = terrainHeight(nbx, nbz);
      var nbench = Models.createFurniture('bench');
      nbench.position.set(nbx, nby, nbz);
      nbench.rotation.y = nba + Math.PI / 2;
      scene.add(nbench);
    }

    // ---- Agora: market crates, lanterns along paths ----
    var az = ZONES.agora;
    for (var al = 0; al < 12; al++) {
      var ala = (al / 12) * Math.PI * 2;
      var alx = az.cx + Math.cos(ala) * 22;
      var alz = az.cz + Math.sin(ala) * 22;
      var aly = terrainHeight(alx, alz);
      var alantern = Models.createFurniture('lantern');
      alantern.position.set(alx, aly, alz);
      scene.add(alantern);
    }

    // ---- Commons: trees around village, fences ----
    var cz = ZONES.commons;
    for (var ct = 0; ct < 12; ct++) {
      var ca = hash2D(ct, 300) * Math.PI * 2;
      var cr = 25 + hash2D(ct, 301) * 25;
      var cx = cz.cx + Math.cos(ca) * cr;
      var czz = cz.cz + Math.sin(ca) * cr;
      var cy = terrainHeight(cx, czz);
      var ctree = Models.createTree('oak', 0.6 + hash2D(ct, 302) * 0.5);
      ctree.position.set(cx, cy, czz);
      ctree.rotation.y = hash2D(ct, 303) * Math.PI * 2;
      scene.add(ctree);
      animatedObjects.push({ mesh: ctree, type: 'tree', params: { speed: 0.3 } });
    }

    // ---- Studio: artistic rocks, small trees ----
    var sz = ZONES.studio;
    for (var st = 0; st < 8; st++) {
      var sa = hash2D(st, 400) * Math.PI * 2;
      var sr = 20 + hash2D(st, 401) * 30;
      var sx = sz.cx + Math.cos(sa) * sr;
      var szz = sz.cz + Math.sin(sa) * sr;
      var sy = terrainHeight(sx, szz);
      var srock = Models.createRock('crystal', 0.8 + hash2D(st, 402) * 0.8);
      srock.position.set(sx, sy, szz);
      scene.add(srock);
    }

    // ---- Athenaeum: ordered trees, benches ----
    var atz = ZONES.athenaeum;
    for (var at = 0; at < 10; at++) {
      var ata = hash2D(at, 500) * Math.PI * 2;
      var atr = 20 + hash2D(at, 501) * 35;
      var atx = atz.cx + Math.cos(ata) * atr;
      var atzz = atz.cz + Math.sin(ata) * atr;
      var aty = terrainHeight(atx, atzz);
      var attree = Models.createTree('pine', 0.7 + hash2D(at, 502) * 0.4);
      attree.position.set(atx, aty, atzz);
      scene.add(attree);
      animatedObjects.push({ mesh: attree, type: 'tree', params: { speed: 0.25 } });
    }

    // ---- Arena: sparse vegetation ----
    var arz = ZONES.arena;
    for (var ar = 0; ar < 6; ar++) {
      var ara = hash2D(ar, 600) * Math.PI * 2;
      var arr = 30 + hash2D(ar, 601) * 15;
      var arx = arz.cx + Math.cos(ara) * arr;
      var arzz = arz.cz + Math.sin(ara) * arr;
      var ary = terrainHeight(arx, arzz);
      var arrock = Models.createRock('boulder', 0.6 + hash2D(ar, 602) * 1.0);
      arrock.position.set(arx, ary, arzz);
      arrock.rotation.y = hash2D(ar, 603) * Math.PI;
      scene.add(arrock);
    }

    // ---- Butterflies and birds scattered around gardens and wilds ----
    if (Models.createCreature) {
      for (var bf = 0; bf < 8; bf++) {
        var bfa = hash2D(bf, 700) * Math.PI * 2;
        var bfr = 10 + hash2D(bf, 701) * 50;
        var bfx = gz.cx + Math.cos(bfa) * bfr;
        var bfz = gz.cz + Math.sin(bfa) * bfr;
        var bfy = terrainHeight(bfx, bfz) + 1.5 + hash2D(bf, 702) * 2;
        var butterfly = Models.createCreature('butterfly');
        butterfly.position.set(bfx, bfy, bfz);
        scene.add(butterfly);
        animatedObjects.push({ mesh: butterfly, type: 'creature', params: { speed: 1 + hash2D(bf, 703) } });
      }
      for (var bi = 0; bi < 6; bi++) {
        var bia = hash2D(bi, 710) * Math.PI * 2;
        var bir = 10 + hash2D(bi, 711) * 60;
        var bix = wz.cx + Math.cos(bia) * bir;
        var biz = wz.cz + Math.sin(bia) * bir;
        var biy = terrainHeight(bix, biz) + 5 + hash2D(bi, 712) * 5;
        var bird = Models.createCreature('bird');
        bird.position.set(bix, biy, biz);
        scene.add(bird);
        animatedObjects.push({ mesh: bird, type: 'creature', params: { speed: 0.5 + hash2D(bi, 713) * 0.5 } });
      }
    }

    // ---- LANDMARKS: unique structures per zone ----
    if (Models.createLandmark) {
      // Nexus: fountain (center), 4 obelisks (compass points), 2 signposts
      var fountain = Models.createLandmark('fountain', 1.2);
      fountain.position.set(nz.cx, terrainHeight(nz.cx, nz.cz), nz.cz);
      scene.add(fountain);
      animatedObjects.push({ mesh: fountain, type: 'landmark', params: {} });

      for (var no = 0; no < 4; no++) {
        var noa = (no / 4) * Math.PI * 2;
        var nox = nz.cx + Math.cos(noa) * 35;
        var noz = nz.cz + Math.sin(noa) * 35;
        var obelisk = Models.createLandmark('obelisk', 1.0);
        obelisk.position.set(nox, terrainHeight(nox, noz), noz);
        scene.add(obelisk);
        animatedObjects.push({ mesh: obelisk, type: 'landmark', params: {} });
      }

      for (var ns = 0; ns < 2; ns++) {
        var nsa = (ns / 2) * Math.PI * 2 + Math.PI / 4;
        var nsx = nz.cx + Math.cos(nsa) * 28;
        var nsz = nz.cz + Math.sin(nsa) * 28;
        var signpost = Models.createLandmark('signpost', 1.0);
        signpost.position.set(nsx, terrainHeight(nsx, nsz), nsz);
        signpost.rotation.y = nsa;
        scene.add(signpost);
      }

      // Gardens: gazebo (center-ish), 4 campfires along paths, 6 flower beds, 4 herb patches
      var gazebo = Models.createLandmark('gazebo', 1.0);
      gazebo.position.set(gz.cx + 10, terrainHeight(gz.cx + 10, gz.cz + 10), gz.cz + 10);
      scene.add(gazebo);

      for (var gc = 0; gc < 4; gc++) {
        var gca = (gc / 4) * Math.PI * 2 + Math.PI / 8;
        var gcx = gz.cx + Math.cos(gca) * 40;
        var gcz = gz.cz + Math.sin(gca) * 40;
        var campfire = Models.createLandmark('campfire', 1.0);
        campfire.position.set(gcx, terrainHeight(gcx, gcz), gcz);
        scene.add(campfire);
        animatedObjects.push({ mesh: campfire, type: 'landmark', params: {} });
      }

      for (var gf = 0; gf < 6; gf++) {
        var gfa = hash2D(gf, 720) * Math.PI * 2;
        var gfr = 20 + hash2D(gf, 721) * 35;
        var gfx = gz.cx + Math.cos(gfa) * gfr;
        var gfz = gz.cz + Math.sin(gfa) * gfr;
        var flowerBed = Models.createResourceNode('flower_bed', 1.0);
        flowerBed.position.set(gfx, terrainHeight(gfx, gfz), gfz);
        flowerBed.rotation.y = hash2D(gf, 722) * Math.PI * 2;
        scene.add(flowerBed);
      }

      for (var gh = 0; gh < 4; gh++) {
        var gha = hash2D(gh, 730) * Math.PI * 2;
        var ghr = 25 + hash2D(gh, 731) * 30;
        var ghx = gz.cx + Math.cos(gha) * ghr;
        var ghz = gz.cz + Math.sin(gha) * ghr;
        var herbPatch = Models.createResourceNode('herb_patch', 1.0);
        herbPatch.position.set(ghx, terrainHeight(ghx, ghz), ghz);
        herbPatch.rotation.y = hash2D(gh, 732) * Math.PI * 2;
        scene.add(herbPatch);
      }

      // Wilds: 2 campfires (explorer camps), 3 signposts, 8 ore veins, 4 wood piles
      for (var wc = 0; wc < 2; wc++) {
        var wca = hash2D(wc, 740) * Math.PI * 2;
        var wcr = 30 + hash2D(wc, 741) * 25;
        var wcx = wz.cx + Math.cos(wca) * wcr;
        var wcz = wz.cz + Math.sin(wca) * wcr;
        var wcampfire = Models.createLandmark('campfire', 1.0);
        wcampfire.position.set(wcx, terrainHeight(wcx, wcz), wcz);
        scene.add(wcampfire);
        animatedObjects.push({ mesh: wcampfire, type: 'landmark', params: {} });
      }

      for (var ws = 0; ws < 3; ws++) {
        var wsa = hash2D(ws, 750) * Math.PI * 2;
        var wsr = 35 + hash2D(ws, 751) * 30;
        var wsx = wz.cx + Math.cos(wsa) * wsr;
        var wsz = wz.cz + Math.sin(wsa) * wsr;
        var wsignpost = Models.createLandmark('signpost', 1.0);
        wsignpost.position.set(wsx, terrainHeight(wsx, wsz), wsz);
        wsignpost.rotation.y = wsa;
        scene.add(wsignpost);
      }

      for (var wo = 0; wo < 8; wo++) {
        var woa = hash2D(wo, 760) * Math.PI * 2;
        var wor = 15 + hash2D(wo, 761) * 50;
        var wox = wz.cx + Math.cos(woa) * wor;
        var woz = wz.cz + Math.sin(woa) * wor;
        var oreVein = Models.createResourceNode('ore_vein', 0.8 + hash2D(wo, 762) * 0.5);
        oreVein.position.set(wox, terrainHeight(wox, woz), woz);
        oreVein.rotation.y = hash2D(wo, 763) * Math.PI * 2;
        scene.add(oreVein);
      }

      for (var ww = 0; ww < 4; ww++) {
        var wwa = hash2D(ww, 770) * Math.PI * 2;
        var wwr = 20 + hash2D(ww, 771) * 40;
        var wwx = wz.cx + Math.cos(wwa) * wwr;
        var wwz = wz.cz + Math.sin(wwa) * wwr;
        var woodPile = Models.createResourceNode('wood_pile', 1.0);
        woodPile.position.set(wwx, terrainHeight(wwx, wwz), wwz);
        woodPile.rotation.y = hash2D(ww, 772) * Math.PI * 2;
        scene.add(woodPile);
      }

      // Athenaeum: 2 statues (flanking entrance), 4 obelisks (mystical markers)
      for (var ats = 0; ats < 2; ats++) {
        var atsa = (ats / 2) * Math.PI * 2;
        var atsx = atz.cx + Math.cos(atsa) * 25;
        var atsz = atz.cz + Math.sin(atsa) * 25;
        var statue = Models.createLandmark('statue', 1.1);
        statue.position.set(atsx, terrainHeight(atsx, atsz), atsz);
        statue.rotation.y = atsa + Math.PI;
        scene.add(statue);
      }

      for (var ato = 0; ato < 4; ato++) {
        var atoa = (ato / 4) * Math.PI * 2 + Math.PI / 8;
        var atox = atz.cx + Math.cos(atoa) * 35;
        var atoz = atz.cz + Math.sin(atoa) * 35;
        var atobelisk = Models.createLandmark('obelisk', 0.9);
        atobelisk.position.set(atox, terrainHeight(atox, atoz), atoz);
        scene.add(atobelisk);
        animatedObjects.push({ mesh: atobelisk, type: 'landmark', params: {} });
      }

      // Studio: 3 crystal clusters (inspiration points), 1 gazebo
      for (var sc = 0; sc < 3; sc++) {
        var sca = hash2D(sc, 780) * Math.PI * 2;
        var scr = 25 + hash2D(sc, 781) * 20;
        var scx = sz.cx + Math.cos(sca) * scr;
        var scz = sz.cz + Math.sin(sca) * scr;
        var crystalCluster = Models.createResourceNode('crystal_cluster', 0.9 + hash2D(sc, 782) * 0.4);
        crystalCluster.position.set(scx, terrainHeight(scx, scz), scz);
        crystalCluster.rotation.y = hash2D(sc, 783) * Math.PI * 2;
        scene.add(crystalCluster);
      }

      var sgazebo = Models.createLandmark('gazebo', 0.9);
      sgazebo.position.set(sz.cx + 15, terrainHeight(sz.cx + 15, sz.cz - 15), sz.cz - 15);
      scene.add(sgazebo);

      // Agora: 6 signposts, 2 campfires (merchant gathering), 3 flower beds
      for (var ags = 0; ags < 6; ags++) {
        var agsa = (ags / 6) * Math.PI * 2;
        var agsx = az.cx + Math.cos(agsa) * 30;
        var agsz = az.cz + Math.sin(agsa) * 30;
        var agsignpost = Models.createLandmark('signpost', 1.0);
        agsignpost.position.set(agsx, terrainHeight(agsx, agsz), agsz);
        agsignpost.rotation.y = agsa;
        scene.add(agsignpost);
      }

      for (var agc = 0; agc < 2; agc++) {
        var agca = (agc / 2) * Math.PI * 2 + Math.PI / 4;
        var agcx = az.cx + Math.cos(agca) * 20;
        var agcz = az.cz + Math.sin(agca) * 20;
        var agcampfire = Models.createLandmark('campfire', 1.0);
        agcampfire.position.set(agcx, terrainHeight(agcx, agcz), agcz);
        scene.add(agcampfire);
        animatedObjects.push({ mesh: agcampfire, type: 'landmark', params: {} });
      }

      for (var agf = 0; agf < 3; agf++) {
        var agfa = hash2D(agf, 790) * Math.PI * 2;
        var agfr = 15 + hash2D(agf, 791) * 20;
        var agfx = az.cx + Math.cos(agfa) * agfr;
        var agfz = az.cz + Math.sin(agfa) * agfr;
        var agflowerBed = Models.createResourceNode('flower_bed', 0.9);
        agflowerBed.position.set(agfx, terrainHeight(agfx, agfz), agfz);
        agflowerBed.rotation.y = hash2D(agf, 792) * Math.PI * 2;
        scene.add(agflowerBed);
      }

      // Commons: 2 gazebos (gathering areas), 4 wood piles, 6 ore veins
      for (var cg = 0; cg < 2; cg++) {
        var cga = (cg / 2) * Math.PI * 2 + Math.PI / 3;
        var cgx = cz.cx + Math.cos(cga) * 30;
        var cgz = cz.cz + Math.sin(cga) * 30;
        var cgazebo = Models.createLandmark('gazebo', 0.95);
        cgazebo.position.set(cgx, terrainHeight(cgx, cgz), cgz);
        scene.add(cgazebo);
      }

      for (var cw = 0; cw < 4; cw++) {
        var cwa = hash2D(cw, 800) * Math.PI * 2;
        var cwr = 20 + hash2D(cw, 801) * 25;
        var cwx = cz.cx + Math.cos(cwa) * cwr;
        var cwz = cz.cz + Math.sin(cwa) * cwr;
        var cwoodPile = Models.createResourceNode('wood_pile', 1.0);
        cwoodPile.position.set(cwx, terrainHeight(cwx, cwz), cwz);
        cwoodPile.rotation.y = hash2D(cw, 802) * Math.PI * 2;
        scene.add(cwoodPile);
      }

      for (var co = 0; co < 6; co++) {
        var coa = hash2D(co, 810) * Math.PI * 2;
        var cor = 18 + hash2D(co, 811) * 28;
        var cox = cz.cx + Math.cos(coa) * cor;
        var coz = cz.cz + Math.sin(coa) * cor;
        var coreVein = Models.createResourceNode('ore_vein', 0.9 + hash2D(co, 812) * 0.4);
        coreVein.position.set(cox, terrainHeight(cox, coz), coz);
        coreVein.rotation.y = hash2D(co, 813) * Math.PI * 2;
        scene.add(coreVein);
      }

      // Arena: 2 statues (champion statues), 4 campfires
      for (var ars = 0; ars < 2; ars++) {
        var arsa = (ars / 2) * Math.PI * 2 + Math.PI / 2;
        var arsx = arz.cx + Math.cos(arsa) * 28;
        var arsz = arz.cz + Math.sin(arsa) * 28;
        var arstatue = Models.createLandmark('statue', 1.2);
        arstatue.position.set(arsx, terrainHeight(arsx, arsz), arsz);
        arstatue.rotation.y = arsa + Math.PI;
        scene.add(arstatue);
      }

      for (var arc = 0; arc < 4; arc++) {
        var arca = (arc / 4) * Math.PI * 2;
        var arcx = arz.cx + Math.cos(arca) * 32;
        var arcz = arz.cz + Math.sin(arca) * 32;
        var arcampfire = Models.createLandmark('campfire', 1.0);
        arcampfire.position.set(arcx, terrainHeight(arcx, arcz), arcz);
        scene.add(arcampfire);
        animatedObjects.push({ mesh: arcampfire, type: 'landmark', params: {} });
      }
    }

    // ---- WILDLIFE: creatures scattered by zone ----
    if (Models.createWildlife) {
      // Gardens: 6 rabbits, 10 fireflies
      for (var gr = 0; gr < 6; gr++) {
        var gra = hash2D(gr, 820) * Math.PI * 2;
        var grr = 15 + hash2D(gr, 821) * 40;
        var grx = gz.cx + Math.cos(gra) * grr;
        var grz = gz.cz + Math.sin(gra) * grr;
        var gry = terrainHeight(grx, grz);
        var rabbit = Models.createWildlife('rabbit');
        rabbit.position.set(grx, gry, grz);
        rabbit.rotation.y = hash2D(gr, 822) * Math.PI * 2;
        scene.add(rabbit);
        animatedObjects.push({ mesh: rabbit, type: 'creature', params: { speed: 0.8 + hash2D(gr, 823) * 0.4 } });
      }

      for (var gfl = 0; gfl < 10; gfl++) {
        var gfla = hash2D(gfl, 830) * Math.PI * 2;
        var gflr = 10 + hash2D(gfl, 831) * 50;
        var gflx = gz.cx + Math.cos(gfla) * gflr;
        var gflz = gz.cz + Math.sin(gfla) * gflr;
        var gfly = terrainHeight(gflx, gflz) + 1.5 + hash2D(gfl, 832) * 1.5;
        var firefly = Models.createWildlife('firefly');
        firefly.position.set(gflx, gfly, gflz);
        scene.add(firefly);
        animatedObjects.push({ mesh: firefly, type: 'creature', params: { speed: 1.2 + hash2D(gfl, 833) * 0.6 } });
      }

      // Wilds: 4 deer, 6 rabbits, 15 fireflies, 4 frogs
      for (var wd = 0; wd < 4; wd++) {
        var wda = hash2D(wd, 840) * Math.PI * 2;
        var wdr = 25 + hash2D(wd, 841) * 45;
        var wdx = wz.cx + Math.cos(wda) * wdr;
        var wdz = wz.cz + Math.sin(wda) * wdr;
        var wdy = terrainHeight(wdx, wdz);
        var deer = Models.createWildlife('deer');
        deer.position.set(wdx, wdy, wdz);
        deer.rotation.y = hash2D(wd, 842) * Math.PI * 2;
        scene.add(deer);
        animatedObjects.push({ mesh: deer, type: 'creature', params: { speed: 0.6 + hash2D(wd, 843) * 0.3 } });
      }

      for (var wr = 0; wr < 6; wr++) {
        var wra = hash2D(wr, 850) * Math.PI * 2;
        var wrr = 20 + hash2D(wr, 851) * 50;
        var wrx = wz.cx + Math.cos(wra) * wrr;
        var wrz = wz.cz + Math.sin(wra) * wrr;
        var wry = terrainHeight(wrx, wrz);
        var wrabbit = Models.createWildlife('rabbit');
        wrabbit.position.set(wrx, wry, wrz);
        wrabbit.rotation.y = hash2D(wr, 852) * Math.PI * 2;
        scene.add(wrabbit);
        animatedObjects.push({ mesh: wrabbit, type: 'creature', params: { speed: 0.8 + hash2D(wr, 853) * 0.4 } });
      }

      for (var wfl = 0; wfl < 15; wfl++) {
        var wfla = hash2D(wfl, 860) * Math.PI * 2;
        var wflr = 15 + hash2D(wfl, 861) * 60;
        var wflx = wz.cx + Math.cos(wfla) * wflr;
        var wflz = wz.cz + Math.sin(wfla) * wflr;
        var wfly = terrainHeight(wflx, wflz) + 1.5 + hash2D(wfl, 862) * 1.5;
        var wfirefly = Models.createWildlife('firefly');
        wfirefly.position.set(wflx, wfly, wflz);
        scene.add(wfirefly);
        animatedObjects.push({ mesh: wfirefly, type: 'creature', params: { speed: 1.2 + hash2D(wfl, 863) * 0.6 } });
      }

      for (var wf = 0; wf < 4; wf++) {
        var wfa = hash2D(wf, 870) * Math.PI * 2;
        var wfr = 30 + hash2D(wf, 871) * 35;
        var wfx = wz.cx + Math.cos(wfa) * wfr;
        var wfz = wz.cz + Math.sin(wfa) * wfr;
        var wfy = terrainHeight(wfx, wfz);
        var frog = Models.createWildlife('frog');
        frog.position.set(wfx, wfy, wfz);
        frog.rotation.y = hash2D(wf, 872) * Math.PI * 2;
        scene.add(frog);
        animatedObjects.push({ mesh: frog, type: 'creature', params: { speed: 0.5 + hash2D(wf, 873) * 0.3 } });
      }

      // Commons: 3 rabbits
      for (var cr = 0; cr < 3; cr++) {
        var cra = hash2D(cr, 880) * Math.PI * 2;
        var crr = 20 + hash2D(cr, 881) * 25;
        var crx = cz.cx + Math.cos(cra) * crr;
        var crz = cz.cz + Math.sin(cra) * crr;
        var cry = terrainHeight(crx, crz);
        var crabbit = Models.createWildlife('rabbit');
        crabbit.position.set(crx, cry, crz);
        crabbit.rotation.y = hash2D(cr, 882) * Math.PI * 2;
        scene.add(crabbit);
        animatedObjects.push({ mesh: crabbit, type: 'creature', params: { speed: 0.8 + hash2D(cr, 883) * 0.4 } });
      }

      // Nexus: 4 fireflies
      for (var nfl = 0; nfl < 4; nfl++) {
        var nfla = hash2D(nfl, 890) * Math.PI * 2;
        var nflr = 15 + hash2D(nfl, 891) * 20;
        var nflx = nz.cx + Math.cos(nfla) * nflr;
        var nflz = nz.cz + Math.sin(nfla) * nflr;
        var nfly = terrainHeight(nflx, nflz) + 1.5 + hash2D(nfl, 892) * 1.5;
        var nfirefly = Models.createWildlife('firefly');
        nfirefly.position.set(nflx, nfly, nflz);
        scene.add(nfirefly);
        animatedObjects.push({ mesh: nfirefly, type: 'creature', params: { speed: 1.2 + hash2D(nfl, 893) * 0.6 } });
      }
    }

    // ---- GROUND COVER: grass, bushes, mushrooms, fallen logs ----
    if (Models.createGrassPatch) {
      // Scatter grass patches across all natural zones
      var naturalZones = [gz, wz, cz, nz];
      for (var nzi = 0; nzi < naturalZones.length; nzi++) {
        var nzInfo = naturalZones[nzi];
        var grassCount = nzi === 1 ? 30 : 15; // More in wilds
        for (var gp = 0; gp < grassCount; gp++) {
          var gpa = hash2D(gp + nzi * 100, 900) * Math.PI * 2;
          var gpr = 8 + hash2D(gp + nzi * 100, 901) * 55;
          var gpx = nzInfo.cx + Math.cos(gpa) * gpr;
          var gpz = nzInfo.cz + Math.sin(gpa) * gpr;
          var grassPatch = Models.createGrassPatch(0.8 + hash2D(gp + nzi * 100, 902) * 0.6);
          grassPatch.position.set(gpx, terrainHeight(gpx, gpz), gpz);
          grassPatch.rotation.y = hash2D(gp + nzi * 100, 903) * Math.PI * 2;
          scene.add(grassPatch);
        }
      }
    }

    if (Models.createBush) {
      // Bushes in gardens (flowering), wilds (berry/green), commons (green)
      var bushTypes = ['flowering', 'flowering', 'green'];
      for (var gb = 0; gb < 8; gb++) {
        var gba = hash2D(gb, 910) * Math.PI * 2;
        var gbr = 12 + hash2D(gb, 911) * 40;
        var gbx = gz.cx + Math.cos(gba) * gbr;
        var gbz = gz.cz + Math.sin(gba) * gbr;
        var gardenBush = Models.createBush(bushTypes[gb % 3], 0.8 + hash2D(gb, 912) * 0.4);
        gardenBush.position.set(gbx, terrainHeight(gbx, gbz), gbz);
        scene.add(gardenBush);
      }

      // Berry and green bushes in wilds
      for (var wb = 0; wb < 10; wb++) {
        var wba = hash2D(wb, 920) * Math.PI * 2;
        var wbr = 15 + hash2D(wb, 921) * 50;
        var wbx = wz.cx + Math.cos(wba) * wbr;
        var wbz = wz.cz + Math.sin(wba) * wbr;
        var wildBush = Models.createBush(wb % 3 === 0 ? 'berry' : 'green', 0.7 + hash2D(wb, 922) * 0.5);
        wildBush.position.set(wbx, terrainHeight(wbx, wbz), wbz);
        scene.add(wildBush);
      }
    }

    if (Models.createMushroom) {
      // Mushroom clusters in wilds and gardens
      var mushroomTypes = ['red', 'brown', 'white', 'purple', 'glowing'];
      for (var wm = 0; wm < 8; wm++) {
        var wma = hash2D(wm, 930) * Math.PI * 2;
        var wmr = 20 + hash2D(wm, 931) * 45;
        var wmx = wz.cx + Math.cos(wma) * wmr;
        var wmz = wz.cz + Math.sin(wma) * wmr;
        var mushroom = Models.createMushroom(mushroomTypes[wm % 5], 0.8 + hash2D(wm, 932) * 0.5);
        mushroom.position.set(wmx, terrainHeight(wmx, wmz), wmz);
        mushroom.rotation.y = hash2D(wm, 933) * Math.PI * 2;
        scene.add(mushroom);
      }

      // Glowing mushrooms in athenaeum (mystical)
      for (var am = 0; am < 5; am++) {
        var ama = hash2D(am, 940) * Math.PI * 2;
        var amr = 15 + hash2D(am, 941) * 25;
        var amx = atz.cx + Math.cos(ama) * amr;
        var amz = atz.cz + Math.sin(ama) * amr;
        var glowMush = Models.createMushroom('glowing', 0.6 + hash2D(am, 942) * 0.4);
        glowMush.position.set(amx, terrainHeight(amx, amz), amz);
        scene.add(glowMush);
      }
    }

    if (Models.createFallenLog) {
      // Fallen logs in wilds and commons
      for (var fl = 0; fl < 5; fl++) {
        var fla = hash2D(fl, 950) * Math.PI * 2;
        var flr = 20 + hash2D(fl, 951) * 40;
        var flx = wz.cx + Math.cos(fla) * flr;
        var flz = wz.cz + Math.sin(fla) * flr;
        var fallenLog = Models.createFallenLog(0.8 + hash2D(fl, 952) * 0.4);
        fallenLog.position.set(flx, terrainHeight(flx, flz), flz);
        fallenLog.rotation.y = hash2D(fl, 953) * Math.PI * 2;
        scene.add(fallenLog);
      }

      for (var cl = 0; cl < 3; cl++) {
        var cla = hash2D(cl, 960) * Math.PI * 2;
        var clr = 18 + hash2D(cl, 961) * 25;
        var clx = cz.cx + Math.cos(cla) * clr;
        var clz = cz.cz + Math.sin(cla) * clr;
        var commonLog = Models.createFallenLog(0.7 + hash2D(cl, 962) * 0.3);
        commonLog.position.set(clx, terrainHeight(clx, clz), clz);
        commonLog.rotation.y = hash2D(cl, 963) * Math.PI * 2;
        scene.add(commonLog);
      }
    }

    // ---- ZONE ARCHITECTURE: detailed structures per zone ----

    if (Models.createRuinWall) {
      // Arena: ancient ruins and ruin walls
      var arenaZone = ZONES.arena;
      for (var rw = 0; rw < 4; rw++) {
        var rwa = hash2D(rw, 1000) * Math.PI * 2;
        var rwr = 15 + hash2D(rw, 1001) * 25;
        var rwx = arenaZone.cx + Math.cos(rwa) * rwr;
        var rwz = arenaZone.cz + Math.sin(rwa) * rwr;
        var ruinWall = Models.createRuinWall(0.8 + hash2D(rw, 1002) * 0.4);
        ruinWall.position.set(rwx, terrainHeight(rwx, rwz), rwz);
        ruinWall.rotation.y = rwa + Math.PI / 2;
        scene.add(ruinWall);
      }
    }

    if (Models.createColumnRow) {
      // Athenaeum: classical columns
      var athenZone = ZONES.athenaeum;
      for (var cr = 0; cr < 3; cr++) {
        var cra = hash2D(cr, 1010) * Math.PI * 2;
        var crr = 10 + hash2D(cr, 1011) * 20;
        var crx = athenZone.cx + Math.cos(cra) * crr;
        var crz = athenZone.cz + Math.sin(cra) * crr;
        var columns = Models.createColumnRow(4 + Math.floor(hash2D(cr, 1012) * 3), 3.5, 2, 0.9);
        columns.position.set(crx, terrainHeight(crx, crz), crz);
        columns.rotation.y = cra;
        scene.add(columns);
      }
    }

    if (Models.createAmphitheater) {
      // Arena: amphitheater at center
      var amphitheater = Models.createAmphitheater(1.2);
      amphitheater.position.set(arenaZone.cx, terrainHeight(arenaZone.cx, arenaZone.cz), arenaZone.cz);
      scene.add(amphitheater);
    }

    if (Models.createWishingWell) {
      // Gardens: wishing well
      var gardenZone = ZONES.gardens;
      var well = Models.createWishingWell(1.0);
      well.position.set(gardenZone.cx + 15, terrainHeight(gardenZone.cx + 15, gardenZone.cz - 10), gardenZone.cz - 10);
      scene.add(well);

      // Commons: another wishing well
      var commonsZone = ZONES.commons;
      var well2 = Models.createWishingWell(0.9);
      well2.position.set(commonsZone.cx - 8, terrainHeight(commonsZone.cx - 8, commonsZone.cz + 5), commonsZone.cz + 5);
      scene.add(well2);
    }

    if (Models.createBookshelf) {
      // Athenaeum: bookshelves
      for (var bs = 0; bs < 6; bs++) {
        var bsa = hash2D(bs, 1030) * Math.PI * 2;
        var bsr = 8 + hash2D(bs, 1031) * 12;
        var bsx = athenZone.cx + Math.cos(bsa) * bsr;
        var bsz = athenZone.cz + Math.sin(bsa) * bsr;
        var bookshelf = Models.createBookshelf(1.0);
        bookshelf.position.set(bsx, terrainHeight(bsx, bsz), bsz);
        bookshelf.rotation.y = bsa + Math.PI;
        scene.add(bookshelf);
      }
    }

    if (Models.createTorch) {
      // Place torches near landmarks in several zones
      var torchZones = ['nexus', 'athenaeum', 'arena', 'agora'];
      for (var tz = 0; tz < torchZones.length; tz++) {
        var torchZone = ZONES[torchZones[tz]];
        for (var tc = 0; tc < 4; tc++) {
          var tca = hash2D(tc + tz * 10, 1040) * Math.PI * 2;
          var tcr = 8 + hash2D(tc + tz * 10, 1041) * 15;
          var tcx = torchZone.cx + Math.cos(tca) * tcr;
          var tcz = torchZone.cz + Math.sin(tca) * tcr;
          var torch = Models.createTorch(1.0);
          torch.position.set(tcx, terrainHeight(tcx, tcz), tcz);
          torch.rotation.y = tca;
          scene.add(torch);
          animatedObjects.push(torch);
        }
      }
    }

    if (Models.createBridge) {
      // Bridges between close zones
      // Gardens to Commons bridge
      var bridgeGC = Models.createBridge(10, 0.9);
      var bgcx = (gardenZone.cx + commonsZone.cx) / 2;
      var bgcz = (gardenZone.cz + commonsZone.cz) / 2;
      bridgeGC.position.set(bgcx, terrainHeight(bgcx, bgcz) - 0.5, bgcz);
      bridgeGC.rotation.y = Math.atan2(commonsZone.cz - gardenZone.cz, commonsZone.cx - gardenZone.cx);
      scene.add(bridgeGC);

      // Nexus to Athenaeum bridge
      var bridgeNA = Models.createBridge(12, 0.9);
      var bnax = (ZONES.nexus.cx + athenZone.cx) / 2;
      var bnaz = (ZONES.nexus.cz + athenZone.cz) / 2;
      bridgeNA.position.set(bnax, terrainHeight(bnax, bnaz) - 0.5, bnaz);
      bridgeNA.rotation.y = Math.atan2(athenZone.cz - ZONES.nexus.cz, athenZone.cx - ZONES.nexus.cx);
      scene.add(bridgeNA);
    }

    if (Models.createGardenArch) {
      // Garden arches at garden entrances
      for (var ga = 0; ga < 3; ga++) {
        var gaa = hash2D(ga, 1060) * Math.PI * 2;
        var gar = gardenZone.radius * 0.6;
        var gax = gardenZone.cx + Math.cos(gaa) * gar;
        var gaz = gardenZone.cz + Math.sin(gaa) * gar;
        var gardenArch = Models.createGardenArch(1.1);
        gardenArch.position.set(gax, terrainHeight(gax, gaz), gaz);
        gardenArch.rotation.y = gaa;
        scene.add(gardenArch);
        animatedObjects.push(gardenArch);
      }
    }

    if (Models.createBannerPole) {
      // Banner poles in agora and arena
      var bannerColors = [0xcc0000, 0x0000cc, 0x00cc00, 0xcc9900, 0x9900cc, 0x009999];
      var bannerZones = ['agora', 'arena', 'nexus'];
      for (var bz = 0; bz < bannerZones.length; bz++) {
        var bannerZone = ZONES[bannerZones[bz]];
        var bannerCount = bz === 0 ? 6 : 4;
        for (var bp = 0; bp < bannerCount; bp++) {
          var bpa = hash2D(bp + bz * 20, 1070) * Math.PI * 2;
          var bpr = 10 + hash2D(bp + bz * 20, 1071) * 20;
          var bpx = bannerZone.cx + Math.cos(bpa) * bpr;
          var bpz = bannerZone.cz + Math.sin(bpa) * bpr;
          var bannerColor = bannerColors[(bp + bz * 3) % bannerColors.length];
          var banner = Models.createBannerPole(bannerColor, 0.9);
          banner.position.set(bpx, terrainHeight(bpx, bpz), bpz);
          scene.add(banner);
          animatedObjects.push(banner);
        }
      }
    }

    console.log('Environment populated with trees, rocks, furniture, creatures, ground cover, and architecture');
  }

  // ========================================================================
  // SCENE INITIALIZATION
  // ========================================================================

  function initScene(container) {
    if (typeof THREE === 'undefined') {
      console.warn('THREE.js not available');
      return null;
    }

    var scene = new THREE.Scene();
    createSky(scene);

    // Add exponential fog for atmospheric depth (matches weather system)
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);

    var camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 15, 25);
    camera.lookAt(0, 0, 0);

    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = false;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    container.appendChild(renderer.domElement);

    // Handle resize
    window.addEventListener('resize', function() {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    var ambientLight = new THREE.HemisphereLight(0x87ceeb, 0xd2b48c, 0.6);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xfff8e7, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = false;
    scene.add(directionalLight);

    // Create all zone structures (one-time, persistent)
    createZoneStructures(scene);

    // Place warm night lights at zone landmarks
    createZoneNightLights(scene);

    // Populate world with environmental objects (trees, rocks, furniture)
    populateEnvironment(scene);

    // Load initial chunks around nexus
    var ctx = {
      scene: scene,
      camera: camera,
      renderer: renderer,
      ambientLight: ambientLight,
      directionalLight: directionalLight
    };
    updateChunks(ctx, 0, 0);

    return ctx;
  }

  // ========================================================================
  // ZONE LOADING â€” now just teleports camera
  // ========================================================================

  function loadZone(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene || !sceneCtx.camera) return;
    var zone = ZONES[zoneId];
    if (!zone) return;
    activeZone = zoneId;
    sceneCtx.camera.position.set(zone.cx, zone.baseHeight + 15, zone.cz + 25);
    sceneCtx.camera.lookAt(zone.cx, zone.baseHeight, zone.cz);
    updateChunks(sceneCtx, zone.cx, zone.cz);
  }

  // ========================================================================
  // PLAYER MANAGEMENT â€” API matches main.js expectations
  // ========================================================================

  function addPlayer(sceneCtx, playerId, position) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var x = position.x || 0, z = position.z || 0;
    var y = terrainHeight(x, z);
    var mesh = createHumanoidModel();
    mesh.position.set(x, y, z);

    // Initialize previous position for animation tracking
    mesh.userData.prevPosition.set(x, y, z);

    sceneCtx.scene.add(mesh);

    // Name label - billboard sprite above head
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    context.fillStyle = 'rgba(0, 0, 0, 0.6)';
    context.fillRect(0, 0, 256, 64);
    context.font = 'Bold 22px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.fillText(playerId, 128, 40);
    var texture = new THREE.CanvasTexture(canvas);
    var labelMat = new THREE.SpriteMaterial({ map: texture });
    var label = new THREE.Sprite(labelMat);
    label.scale.set(3, 0.75, 1);
    label.position.y = 2.0; // Above head
    mesh.add(label);

    playerMeshes.set(playerId, { mesh: mesh, label: label });
  }

  function movePlayer(sceneCtx, playerId, position) {
    var data = playerMeshes.get(playerId);
    if (!data) return;
    var mesh = data.mesh;

    // Store previous position before updating
    mesh.userData.prevPosition.copy(mesh.position);

    var x = position.x || 0, z = position.z || 0;
    var y = terrainHeight(x, z);
    mesh.position.set(x, y, z);

    // Calculate movement delta to determine animation state
    var dx = x - mesh.userData.prevPosition.x;
    var dz = z - mesh.userData.prevPosition.z;
    var movementDelta = Math.sqrt(dx * dx + dz * dz);

    // Determine animation state based on movement
    if (movementDelta < 0.001) {
      mesh.userData.animState = 'idle';
    } else if (movementDelta > 0.1) {
      mesh.userData.animState = 'run'; // Fast movement = running
    } else {
      mesh.userData.animState = 'walk';
    }

    // Update rotation to face movement direction
    if (movementDelta > 0.001) {
      var angle = Math.atan2(dx, dz);
      mesh.rotation.y = angle;
    }
  }

  function removePlayer(sceneCtx, playerId) {
    var data = playerMeshes.get(playerId);
    if (!data || !sceneCtx || !sceneCtx.scene) return;
    sceneCtx.scene.remove(data.mesh);
    playerMeshes.delete(playerId);
  }

  // ========================================================================
  // PLAYER ANIMATIONS
  // ========================================================================

  function updatePlayerAnimations(sceneCtx, deltaTime) {
    if (!sceneCtx) return;

    playerMeshes.forEach(function(data) {
      var mesh = data.mesh;
      var limbs = mesh.userData.limbs;
      if (!limbs) return;

      // Increment animation time
      mesh.userData.animTime += deltaTime;
      var t = mesh.userData.animTime;

      var state = mesh.userData.animState || 'idle';

      // Reset rotations to neutral positions
      limbs.leftArm.rotation.x = 0;
      limbs.rightArm.rotation.x = 0;
      limbs.leftLeg.rotation.x = 0;
      limbs.rightLeg.rotation.x = 0;
      limbs.torso.rotation.x = 0;
      limbs.torso.scale.set(1, 1, 1);
      limbs.head.rotation.x = 0;

      if (state === 'idle') {
        // IDLE ANIMATION
        // Subtle breathing - torso scales slightly on Y
        var breathe = Math.sin(t * 2) * 0.02;
        limbs.torso.scale.y = 1.0 + breathe;

        // Slight body sway
        limbs.torso.rotation.z = Math.sin(t * 1.5) * 0.02;

        // Arms hang naturally with subtle sway
        limbs.leftArm.rotation.z = Math.sin(t * 1.3) * 0.05;
        limbs.rightArm.rotation.z = -Math.sin(t * 1.3) * 0.05;

      } else if (state === 'walk') {
        // WALKING ANIMATION
        var walkSpeed = 8;
        var swingAngle = 0.5;

        // Legs swing forward/back alternately
        limbs.leftLeg.rotation.x = Math.sin(t * walkSpeed) * swingAngle;
        limbs.rightLeg.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle;

        // Arms swing opposite to legs (counter-swing)
        limbs.leftArm.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle * 0.7;
        limbs.rightArm.rotation.x = Math.sin(t * walkSpeed) * swingAngle * 0.7;

        // Feet rotate with legs
        limbs.leftFoot.rotation.x = Math.sin(t * walkSpeed) * swingAngle * 0.5;
        limbs.rightFoot.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle * 0.5;

        // Body bobs slightly up/down
        var bob = Math.abs(Math.sin(t * walkSpeed)) * 0.05;
        limbs.torso.position.y = 0.9 + bob;
        limbs.head.position.y = 1.5 + bob;

        // Slight forward lean
        limbs.torso.rotation.x = 0.05;

      } else if (state === 'run') {
        // RUNNING ANIMATION
        var runSpeed = 12;
        var runSwingAngle = 0.8;

        // Legs swing with larger amplitude and faster
        limbs.leftLeg.rotation.x = Math.sin(t * runSpeed) * runSwingAngle;
        limbs.rightLeg.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle;

        // More dramatic arm swing
        limbs.leftArm.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle;
        limbs.rightArm.rotation.x = Math.sin(t * runSpeed) * runSwingAngle;

        // Feet rotate with legs
        limbs.leftFoot.rotation.x = Math.sin(t * runSpeed) * runSwingAngle * 0.5;
        limbs.rightFoot.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle * 0.5;

        // More pronounced body bob
        var runBob = Math.abs(Math.sin(t * runSpeed)) * 0.08;
        limbs.torso.position.y = 0.9 + runBob;
        limbs.head.position.y = 1.5 + runBob;

        // More body lean forward
        limbs.torso.rotation.x = 0.15;
      }
    });
  }

  // ========================================================================
  // DAY/NIGHT CYCLE
  // ========================================================================

  function updateDayNight(sceneCtx, worldTime) {
    if (!sceneCtx) return;

    // worldTime is 0-1440 (minutes in 24h cycle)
    var normalizedTime = worldTime / 1440; // 0-1

    // Sun position
    var sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2;
    if (sunMesh) {
      sunMesh.position.set(Math.cos(sunAngle) * 400, Math.sin(sunAngle) * 400, 0);
    }
    if (moonMesh) {
      moonMesh.position.set(Math.cos(sunAngle + Math.PI) * 400, Math.sin(sunAngle + Math.PI) * 400, 0);
    }

    // Stars
    if (stars && stars.material) {
      stars.material.opacity = Math.max(0, -Math.sin(sunAngle));
      stars.material.transparent = true;
    }

    // Sky color
    var skyColor, fogColor, sunIntensity;
    var t;
    if (normalizedTime < 0.25) {
      t = normalizedTime / 0.25;
      skyColor = lerpColor(0x0a0a2e, 0xff6b35, t);
      fogColor = skyColor;
      sunIntensity = t * 0.3;
    } else if (normalizedTime < 0.5) {
      t = (normalizedTime - 0.25) / 0.25;
      skyColor = lerpColor(0xff6b35, 0x87ceeb, t);
      fogColor = skyColor;
      sunIntensity = 0.3 + t * 0.7;
    } else if (normalizedTime < 0.75) {
      t = (normalizedTime - 0.5) / 0.25;
      skyColor = lerpColor(0x87ceeb, 0xff4500, t);
      fogColor = skyColor;
      sunIntensity = 1.0 - t * 0.5;
    } else {
      t = (normalizedTime - 0.75) / 0.25;
      skyColor = lerpColor(0xff4500, 0x0a0a2e, t);
      fogColor = skyColor;
      sunIntensity = 0.5 - t * 0.5;
    }

    if (skyDome && skyDome.material) skyDome.material.color.setHex(skyColor);
    if (sceneCtx.scene && sceneCtx.scene.fog) sceneCtx.scene.fog.color.setHex(fogColor);
    // Sync renderer background with fog to prevent visible horizon seam
    if (sceneCtx.renderer) sceneCtx.renderer.setClearColor(fogColor);
    if (sceneCtx.directionalLight) {
      sceneCtx.directionalLight.intensity = Math.max(0.15, sunIntensity);
      sceneCtx.directionalLight.position.set(
        Math.cos(sunAngle) * 50,
        Math.max(10, Math.sin(sunAngle) * 100),
        50
      );
    }
    if (sceneCtx.ambientLight) {
      var ambientIntensity = 0.3 + sunIntensity * 0.4;
      sceneCtx.ambientLight.intensity = ambientIntensity;
      // Tint ambient light by time of day
      var ambientColor;
      if (normalizedTime < 0.2) {
        // Night: cool blue tint
        ambientColor = 0x334466;
      } else if (normalizedTime < 0.3) {
        // Dawn: warm amber
        var dt = (normalizedTime - 0.2) / 0.1;
        ambientColor = lerpColor(0x334466, 0xffcc88, dt);
      } else if (normalizedTime < 0.7) {
        // Day: warm white
        var dt = (normalizedTime - 0.3) / 0.4;
        ambientColor = lerpColor(0xffcc88, 0xeeeedd, Math.min(dt * 2, 1.0));
      } else if (normalizedTime < 0.8) {
        // Dusk: warm orange
        var dt = (normalizedTime - 0.7) / 0.1;
        ambientColor = lerpColor(0xeeeedd, 0xff9966, dt);
      } else {
        // Evening to night: fade to blue
        var dt = (normalizedTime - 0.8) / 0.2;
        ambientColor = lerpColor(0xff9966, 0x334466, dt);
      }
      sceneCtx.ambientLight.color.setHex(ambientColor);
    }

    // Tint directional light (sunlight) color by time of day
    if (sceneCtx.directionalLight) {
      var sunColor;
      if (normalizedTime < 0.25) {
        sunColor = lerpColor(0x443355, 0xff8844, normalizedTime / 0.25);
      } else if (normalizedTime < 0.45) {
        sunColor = lerpColor(0xff8844, 0xffffff, (normalizedTime - 0.25) / 0.2);
      } else if (normalizedTime < 0.55) {
        sunColor = 0xffffff; // Bright noon
      } else if (normalizedTime < 0.75) {
        sunColor = lerpColor(0xffffff, 0xff6633, (normalizedTime - 0.55) / 0.2);
      } else {
        sunColor = lerpColor(0xff6633, 0x443355, (normalizedTime - 0.75) / 0.25);
      }
      sceneCtx.directionalLight.color.setHex(sunColor);
    }

    // Dynamic fog density by time of day
    if (sceneCtx.scene && sceneCtx.scene.fog && sceneCtx.scene.fog.density !== undefined) {
      var baseDensity = 0.0012; // Clear daytime default
      var timeFogMult = 1.0;

      if (normalizedTime < 0.2) {
        // Night: thicker fog, limited visibility
        timeFogMult = 1.8;
      } else if (normalizedTime < 0.28) {
        // Dawn: misty transition (thickest â€” morning mist)
        var dawnT = (normalizedTime - 0.2) / 0.08;
        timeFogMult = 1.8 + dawnT * 0.5; // peaks at 2.3 during dawn
      } else if (normalizedTime < 0.35) {
        // Morning: mist burning off
        var burnT = (normalizedTime - 0.28) / 0.07;
        timeFogMult = 2.3 - burnT * 1.3; // fades from 2.3 to 1.0
      } else if (normalizedTime < 0.7) {
        // Daytime: clearest visibility
        timeFogMult = 1.0;
      } else if (normalizedTime < 0.8) {
        // Dusk: golden haze
        var duskT = (normalizedTime - 0.7) / 0.1;
        timeFogMult = 1.0 + duskT * 0.5;
      } else {
        // Evening into night: fog thickens
        var nightT = (normalizedTime - 0.8) / 0.2;
        timeFogMult = 1.5 + nightT * 0.3;
      }

      // Only adjust fog if weather isn't overriding it
      if (currentWeatherType === 'clear' || !currentWeatherType) {
        sceneCtx.scene.fog.density = baseDensity * timeFogMult;
      }
    }

    // Fade zone night lights based on time of day
    var nightIntensity = 0;
    if (normalizedTime < 0.2 || normalizedTime > 0.8) {
      // Full night
      nightIntensity = 1.0;
    } else if (normalizedTime < 0.3) {
      // Dawn fade out
      nightIntensity = 1.0 - (normalizedTime - 0.2) / 0.1;
    } else if (normalizedTime > 0.7) {
      // Dusk fade in
      nightIntensity = (normalizedTime - 0.7) / 0.1;
    }
    for (var li = 0; li < zoneLights.length; li++) {
      var zl = zoneLights[li];
      zl.light.intensity = nightIntensity * 1.2;
      if (zl.glow && zl.glow.material) {
        zl.glow.material.opacity = nightIntensity * 0.8;
      }
    }
  }

  function lerpColor(c1, c2, t) {
    var r1 = (c1 >> 16) & 0xff, g1 = (c1 >> 8) & 0xff, b1 = c1 & 0xff;
    var r2 = (c2 >> 16) & 0xff, g2 = (c2 >> 8) & 0xff, b2 = c2 & 0xff;
    var r = Math.floor(r1 + (r2 - r1) * t);
    var g = Math.floor(g1 + (g2 - g1) * t);
    var b = Math.floor(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
  }

  // ========================================================================
  // LIGHT CULLING â€” matches main.js: cullLights(ctx, position, maxDist, maxCount)
  // ========================================================================

  function cullLights(sceneCtx, playerPos, maxDistance, maxCount) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var px = playerPos.x || 0, pz = playerPos.z || 0;
    var lights = [];
    sceneCtx.scene.traverse(function(obj) {
      if (obj instanceof THREE.PointLight) {
        var dx = obj.position.x - px, dz = obj.position.z - pz;
        var dist = Math.sqrt(dx * dx + dz * dz);
        lights.push({ light: obj, dist: dist });
      }
    });
    lights.sort(function(a, b) { return a.dist - b.dist; });
    for (var i = 0; i < lights.length; i++) {
      lights[i].light.visible = (i < (maxCount || 8)) && (lights[i].dist < (maxDistance || 50));
    }
  }

  // ========================================================================
  // WEATHER
  // ========================================================================

  function updateWeather(sceneCtx, weatherType) {
    if (!sceneCtx || !sceneCtx.scene) return;
    // Call setWeather to handle visual effects and fog
    setWeather(sceneCtx, weatherType);
  }

  // ========================================================================
  // ANIMATION SYSTEM
  // ========================================================================

  function updateAnimations(sceneCtx, deltaTime, worldTime) {
    // Cloud drift
    for (var i = 0; i < clouds.length; i++) {
      var cloud = clouds[i];
      cloud.position.x += Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      cloud.position.z += Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      if (cloud.position.x > 600) cloud.position.x = -600;
      if (cloud.position.x < -600) cloud.position.x = 600;
      if (cloud.position.z > 600) cloud.position.z = -600;
      if (cloud.position.z < -600) cloud.position.z = 600;
    }

    // Animated objects
    var time = worldTime || 0;
    for (var j = 0; j < animatedObjects.length; j++) {
      var obj = animatedObjects[j];
      if (!obj.mesh || !obj.mesh.parent) continue;

      // Skip animation if object is outside frustum (set by updateFrustumCulling)
      if (obj.mesh.userData.inFrustum === false) continue;

      var p = obj.params;

      switch (obj.type) {
        case 'tree':
          var windMult = windState ? windState.strength : 1.0;
          var swayFreq = currentWeatherType === 'storm' ? 0.003 : 0.001;
          obj.mesh.rotation.z = Math.sin(time * swayFreq * p.speed + p.seed) * 0.04 * windMult;
          obj.mesh.rotation.x = Math.sin(time * swayFreq * 0.8 * p.speed + p.seed * 1.5) * 0.02 * windMult;
          break;
        case 'crystal':
          obj.mesh.rotation.y += deltaTime * (p.speed || 0.3);
          if (p.baseY !== undefined) {
            obj.mesh.position.y = p.baseY + Math.sin(time * 0.002) * 0.3;
          }
          break;
        case 'portal':
          obj.mesh.rotation.z += deltaTime * (p.speed || 0.5);
          if (p.inner) {
            p.inner.material.opacity = 0.25 + Math.sin(time * 0.003) * 0.15;
          }
          // Animate particle rings
          if (p.particleRings) {
            for (var ri = 0; ri < p.particleRings.length; ri++) {
              var ring = p.particleRings[ri];
              for (var pi = 0; pi < ring.particles.length; pi++) {
                var pData = ring.particles[pi];
                pData.angle += ring.speed * ring.direction * deltaTime;
                var px = p.centerX + Math.cos(pData.angle) * pData.radius;
                var pz = p.centerZ + Math.sin(pData.angle) * pData.radius;
                pData.mesh.position.set(px, p.centerY, pz);
              }
            }
          }
          break;
        case 'torch':
          var flicker = 0.7 + Math.sin(time * 0.01 + (p.seed || 0)) * 0.15 + Math.sin(time * 0.023 + (p.seed || 0) * 2) * 0.15;
          obj.mesh.scale.set(flicker, 0.8 + flicker * 0.4, flicker);
          if (p.light) {
            var torchBase = 0.5 + flicker * 0.5;
            // Boost torch brightness at night (worldTime passed as 3rd arg)
            var wt = (typeof worldTime === 'number') ? worldTime : 720;
            var nt = wt / 1440;
            var nightBoost = (nt < 0.2 || nt > 0.8) ? 1.5 : (nt < 0.3 ? (1.0 + 0.5 * (1.0 - (nt - 0.2) / 0.1)) : (nt > 0.7 ? (1.0 + 0.5 * ((nt - 0.7) / 0.1)) : 1.0));
            p.light.intensity = torchBase * nightBoost;
          }
          break;
        case 'water':
          obj.mesh.rotation.y += deltaTime * 0.05;
          break;
        case 'creature':
          // Delegate to Models.animateModel if available
          var Models = typeof window !== 'undefined' ? window.Models : null;
          if (Models && Models.animateModel) {
            Models.animateModel(obj.mesh, deltaTime, time);
          } else {
            // Fallback: simple bobbing motion
            obj.mesh.position.y += Math.sin(time * 0.003 * (p.speed || 1)) * 0.01;
            obj.mesh.rotation.y += deltaTime * (p.speed || 0.5);
          }
          break;
        case 'landmark':
          if (Models && Models.animateModel) {
            Models.animateModel(obj.mesh, deltaTime, time);
          }
          break;
      }
    }
  }

  // ========================================================================
  // COLLISION / PHYSICS HELPERS
  // ========================================================================

  // Simple terrain-following: returns height at any world position
  // Used by main.js and npcs.js
  // Also provides basic collision checking for future use
  function checkCollision(x, z, radius) {
    // Check against placed structures only (not zone centers, which are walkable)
    if (placedStructures) {
      for (var i = 0; i < placedStructures.length; i++) {
        var s = placedStructures[i];
        if (!s || !s.position) continue;
        var dx = x - s.position.x, dz = z - s.position.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        var structRadius = s.collisionRadius || 1.5;
        if (dist < structRadius + radius) {
          return true;
        }
      }
    }
    return false;
  }

  // ========================================================================
  // PLACED STRUCTURES (for collision)
  // ========================================================================

  var placedStructures = [];

  // ========================================================================
  // PARTICLE SYSTEM
  // ========================================================================

  var particleSystems = null;
  var MAX_PARTICLES = 500;
  var PARTICLE_CULL_DISTANCE = 100;

  // Particle pool and emitter definitions
  function ParticleSystem() {
    this.particles = [];
    this.positions = new Float32Array(MAX_PARTICLES * 3);
    this.colors = new Float32Array(MAX_PARTICLES * 3);
    this.sizes = new Float32Array(MAX_PARTICLES);
    this.activeCount = 0;

    // Particle data
    for (var i = 0; i < MAX_PARTICLES; i++) {
      this.particles.push({
        active: false,
        position: { x: 0, y: 0, z: 0 },
        velocity: { x: 0, y: 0, z: 0 },
        life: 0,
        maxLife: 1,
        color: { r: 1, g: 1, b: 1 },
        size: 1,
        opacity: 1,
        emitterType: null
      });
    }

    // Create geometry
    this.geometry = new THREE.BufferGeometry();
    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
    this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
    this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

    // Create material with texture support
    this.material = new THREE.PointsMaterial({
      size: 0.5,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    // Generate procedural particle texture (soft circle)
    var particleCanvas = document.createElement('canvas');
    particleCanvas.width = 32;
    particleCanvas.height = 32;
    var pctx = particleCanvas.getContext('2d');
    var gradient = pctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    pctx.fillStyle = gradient;
    pctx.fillRect(0, 0, 32, 32);
    var particleTex = new THREE.CanvasTexture(particleCanvas);
    this.material.map = particleTex;

    // Create Points mesh
    this.points = new THREE.Points(this.geometry, this.material);
    this.points.frustumCulled = false;

    // Emitters
    this.emitters = [];
  }

  ParticleSystem.prototype.addEmitter = function(type, position, config) {
    this.emitters.push({
      type: type,
      position: position,
      config: config || {},
      timer: 0,
      active: true
    });
  };

  ParticleSystem.prototype.removeEmitter = function(index) {
    if (index >= 0 && index < this.emitters.length) {
      this.emitters.splice(index, 1);
    }
  };

  ParticleSystem.prototype.emitParticle = function(type, position, count) {
    count = count || 1;
    for (var i = 0; i < count; i++) {
      this._spawnParticle(type, position);
    }
  };

  ParticleSystem.prototype._spawnParticle = function(type, position) {
    // Find dead particle to reuse
    var particle = null;
    for (var i = 0; i < MAX_PARTICLES; i++) {
      if (!this.particles[i].active) {
        particle = this.particles[i];
        break;
      }
    }
    if (!particle) return; // Pool full

    particle.active = true;
    particle.position.x = position.x;
    particle.position.y = position.y;
    particle.position.z = position.z;
    particle.emitterType = type;

    // Configure particle based on type
    switch (type) {
      case 'fire':
        particle.maxLife = 1.0 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.5;
        particle.velocity.y = 1.5 + Math.random() * 1.0;
        particle.velocity.z = (Math.random() - 0.5) * 0.5;
        particle.color.r = 1.0;
        particle.color.g = 0.4 + Math.random() * 0.3;
        particle.color.b = 0.0;
        particle.size = 0.3 + Math.random() * 0.3;
        particle.opacity = 1.0;
        break;

      case 'sparkle':
        particle.maxLife = 1.5 + Math.random() * 1.0;
        particle.life = particle.maxLife;
        var angle = Math.random() * Math.PI * 2;
        var radius = 2.0;
        particle.velocity.x = Math.cos(angle) * radius;
        particle.velocity.y = (Math.random() - 0.5) * 0.3;
        particle.velocity.z = Math.sin(angle) * radius;
        particle.color.r = 0.0;
        particle.color.g = 0.8 + Math.random() * 0.2;
        particle.color.b = 1.0;
        particle.size = 0.2 + Math.random() * 0.2;
        particle.opacity = 1.0;
        break;

      case 'dust':
        particle.maxLife = 0.5 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 1.0;
        particle.velocity.y = 0.3 + Math.random() * 0.5;
        particle.velocity.z = (Math.random() - 0.5) * 1.0;
        particle.color.r = 0.6;
        particle.color.g = 0.5;
        particle.color.b = 0.4;
        particle.size = 0.1 + Math.random() * 0.15;
        particle.opacity = 0.6;
        break;

      case 'leaf':
        particle.maxLife = 3.0 + Math.random() * 2.0;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.5;
        particle.velocity.y = -0.3 - Math.random() * 0.2;
        particle.velocity.z = (Math.random() - 0.5) * 0.5;
        particle.color.r = 0.2 + Math.random() * 0.3;
        particle.color.g = 0.6 + Math.random() * 0.3;
        particle.color.b = 0.1;
        particle.size = 0.2 + Math.random() * 0.2;
        particle.opacity = 0.8;
        break;

      case 'mist':
        particle.maxLife = 2.0 + Math.random() * 2.0;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.2;
        particle.velocity.y = 0.05 + Math.random() * 0.1;
        particle.velocity.z = (Math.random() - 0.5) * 0.2;
        particle.color.r = 0.8;
        particle.color.g = 0.85;
        particle.color.b = 0.9;
        particle.size = 0.8 + Math.random() * 0.6;
        particle.opacity = 0.3;
        break;

      case 'fountain':
        particle.maxLife = 1.5 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        var fAngle = Math.random() * Math.PI * 2;
        var fSpeed = 1.0 + Math.random() * 1.5;
        particle.velocity.x = Math.cos(fAngle) * fSpeed * 0.5;
        particle.velocity.y = 3.0 + Math.random() * 1.5;
        particle.velocity.z = Math.sin(fAngle) * fSpeed * 0.5;
        particle.color.r = 0.2;
        particle.color.g = 0.5 + Math.random() * 0.3;
        particle.color.b = 0.8 + Math.random() * 0.2;
        particle.size = 0.15 + Math.random() * 0.15;
        particle.opacity = 0.7;
        break;

      default:
        particle.active = false;
        return;
    }
  };

  ParticleSystem.prototype.update = function(deltaTime, playerPos) {
    var dt = deltaTime * 0.001; // Convert to seconds
    var px = playerPos ? playerPos.x : 0;
    var pz = playerPos ? playerPos.z : 0;

    // Update emitters
    for (var e = 0; e < this.emitters.length; e++) {
      var emitter = this.emitters[e];
      if (!emitter.active) continue;

      emitter.timer += deltaTime;

      // Emit particles based on type
      var emitRate = 50; // ms per particle
      switch (emitter.type) {
        case 'fire': emitRate = 80; break;
        case 'sparkle': emitRate = 100; break;
        case 'dust': emitRate = 150; break;
        case 'leaf': emitRate = 200; break;
        case 'mist': emitRate = 120; break;
        case 'fountain': emitRate = 60; break;
      }

      while (emitter.timer >= emitRate) {
        emitter.timer -= emitRate;
        this._spawnParticle(emitter.type, emitter.position);
      }
    }

    // Update particles
    this.activeCount = 0;
    for (var i = 0; i < MAX_PARTICLES; i++) {
      var p = this.particles[i];
      if (!p.active) continue;

      // Update life
      p.life -= dt;
      if (p.life <= 0) {
        p.active = false;
        continue;
      }

      // Distance culling
      var dx = p.position.x - px;
      var dz = p.position.z - pz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist > PARTICLE_CULL_DISTANCE) {
        p.active = false;
        continue;
      }

      // Update physics
      p.position.x += p.velocity.x * dt;
      p.position.y += p.velocity.y * dt;
      p.position.z += p.velocity.z * dt;

      // Apply gravity (except for sparkle and mist)
      if (p.emitterType !== 'sparkle' && p.emitterType !== 'mist') {
        p.velocity.y -= 2.0 * dt;
      }

      // Type-specific updates
      if (p.emitterType === 'sparkle') {
        // Circular motion around origin
        var angle = Math.atan2(p.velocity.z, p.velocity.x);
        angle += dt * 2.0;
        var speed = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.z * p.velocity.z);
        p.velocity.x = Math.cos(angle) * speed;
        p.velocity.z = Math.sin(angle) * speed;
      } else if (p.emitterType === 'leaf') {
        // Swaying motion
        p.velocity.x += Math.sin(p.life * 3.0) * dt * 0.5;
        p.velocity.z += Math.cos(p.life * 2.5) * dt * 0.5;
      } else if (p.emitterType === 'mist') {
        // Slow drift
        p.velocity.x *= 0.98;
        p.velocity.z *= 0.98;
      }

      // Friction
      p.velocity.x *= 0.99;
      p.velocity.z *= 0.99;

      // Fade out
      var lifeRatio = p.life / p.maxLife;
      p.opacity = Math.min(1.0, lifeRatio * 2.0);

      // Update buffer
      var idx = this.activeCount * 3;
      this.positions[idx] = p.position.x;
      this.positions[idx + 1] = p.position.y;
      this.positions[idx + 2] = p.position.z;

      this.colors[idx] = p.color.r * p.opacity;
      this.colors[idx + 1] = p.color.g * p.opacity;
      this.colors[idx + 2] = p.color.b * p.opacity;

      this.sizes[this.activeCount] = p.size;

      this.activeCount++;
    }

    // Update geometry
    this.geometry.setDrawRange(0, this.activeCount);
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
  };

  // Public API functions
  function initParticles(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    particleSystems = new ParticleSystem();
    sceneCtx.scene.add(particleSystems.points);

    // Add default emitters at key locations
    // Fire at arena torches (12 torches around arena)
    var arenaZ = ZONES.arena;
    for (var ti = 0; ti < 12; ti++) {
      var tAngle = (ti / 12) * Math.PI * 2;
      var tpx = arenaZ.cx + Math.cos(tAngle) * 20;
      var tpz = arenaZ.cz + Math.sin(tAngle) * 20;
      particleSystems.addEmitter('fire', { x: tpx, y: arenaZ.baseHeight + 2.7, z: tpz });
    }

    // Sparkle at portals
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var dx = ZONES.nexus.cx - zone.cx;
      var dz = ZONES.nexus.cz - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var nx = dx / dist, nz = dz / dist;
      var portalX = zone.cx + nx * zone.radius * 0.7;
      var portalZ = zone.cz + nz * zone.radius * 0.7;
      var portalY = terrainHeight(portalX, portalZ);
      particleSystems.addEmitter('sparkle', { x: portalX, y: portalY + 3, z: portalZ });
    }

    // Fountain at gardens
    var gardensZ = ZONES.gardens;
    particleSystems.addEmitter('fountain', { x: gardensZ.cx, y: gardensZ.baseHeight + 1.5, z: gardensZ.cz });

    // Mist in wilds
    var wildsZ = ZONES.wilds;
    for (var mi = 0; mi < 3; mi++) {
      var mAngle = (mi / 3) * Math.PI * 2;
      var mx = wildsZ.cx + Math.cos(mAngle) * 10;
      var mz = wildsZ.cz + Math.sin(mAngle) * 10;
      particleSystems.addEmitter('mist', { x: mx, y: wildsZ.baseHeight + 0.5, z: mz });
    }

    // Leaves in gardens and wilds
    var leafZones = [ZONES.gardens, ZONES.wilds];
    for (var lzi = 0; lzi < leafZones.length; lzi++) {
      var lz = leafZones[lzi];
      for (var li = 0; li < 4; li++) {
        var lAngle = (li / 4) * Math.PI * 2;
        var lx = lz.cx + Math.cos(lAngle) * 15;
        var lzp = lz.cz + Math.sin(lAngle) * 15;
        particleSystems.addEmitter('leaf', { x: lx, y: lz.baseHeight + 8, z: lzp });
      }
    }
  }

  function updateParticles(sceneCtx, deltaTime, playerPos) {
    if (!particleSystems) return;
    particleSystems.update(deltaTime, playerPos);
  }

  function emitParticles(type, position, count) {
    if (!particleSystems) return;
    particleSystems.emitParticle(type, position, count || 1);
  }

  // ========================================================================
  // WEATHER EFFECTS SYSTEM
  // ========================================================================

  var weatherParticles = null; // Current active weather particle system
  var currentWeatherType = 'clear';
  var lightningTimer = 0;
  var lightningActive = false;
  var lightningLight = null;
  var weatherCallbacks = {}; // { onLightningStrike: function(x,z) }

  function setWeather(sceneCtx, type) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Remove existing weather particles
    if (weatherParticles) {
      sceneCtx.scene.remove(weatherParticles);
      if (weatherParticles.geometry) weatherParticles.geometry.dispose();
      if (weatherParticles.material) weatherParticles.material.dispose();
      weatherParticles = null;
    }

    currentWeatherType = type;

    // Update fog based on weather
    if (sceneCtx.scene.fog && sceneCtx.scene.fog.density !== undefined) {
      switch (type) {
        case 'storm':
          sceneCtx.scene.fog.density = 0.0030;
          break;
        case 'rain':
          sceneCtx.scene.fog.density = 0.0022;
          break;
        case 'snow':
          sceneCtx.scene.fog.density = 0.0018;
          break;
        case 'cloudy':
          sceneCtx.scene.fog.density = 0.0015;
          break;
        default:
          sceneCtx.scene.fog.density = 0.0012;
      }
    }

    // Create particle system based on type
    if (type === 'rain') {
      var rainCount = 2000;
      var rainGeo = new THREE.BufferGeometry();
      var rainPositions = new Float32Array(rainCount * 3);
      var rainVelocities = new Float32Array(rainCount * 3);

      // Initialize rain particles in a box around origin
      for (var i = 0; i < rainCount; i++) {
        var idx = i * 3;
        rainPositions[idx] = (Math.random() - 0.5) * 100;     // x
        rainPositions[idx + 1] = Math.random() * 80 + 20;      // y
        rainPositions[idx + 2] = (Math.random() - 0.5) * 100; // z

        // Velocities: fast downward with gentle drift
        rainVelocities[idx] = (Math.random() - 0.5) * 0.5;     // x drift
        rainVelocities[idx + 1] = -0.8 - Math.random() * 0.4;  // y fall speed
        rainVelocities[idx + 2] = (Math.random() - 0.5) * 0.5; // z drift
      }

      rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
      rainGeo.userData.velocities = rainVelocities;

      var rainMat = new THREE.PointsMaterial({
        color: 0xaaccff,
        size: 0.15,
        transparent: true,
        opacity: 0.6,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(rainGeo, rainMat);
      weatherParticles.userData.type = 'rain';
      sceneCtx.scene.add(weatherParticles);

    } else if (type === 'snow') {
      var snowCount = 1000;
      var snowGeo = new THREE.BufferGeometry();
      var snowPositions = new Float32Array(snowCount * 3);
      var snowVelocities = new Float32Array(snowCount * 3);
      var snowPhases = new Float32Array(snowCount); // For sine-wave movement

      // Initialize snow particles
      for (var j = 0; j < snowCount; j++) {
        var jdx = j * 3;
        snowPositions[jdx] = (Math.random() - 0.5) * 120;     // x
        snowPositions[jdx + 1] = Math.random() * 100 + 20;    // y
        snowPositions[jdx + 2] = (Math.random() - 0.5) * 120; // z

        // Velocities: slow downward
        snowVelocities[jdx] = 0;                              // x (handled by sine wave)
        snowVelocities[jdx + 1] = -0.15 - Math.random() * 0.1; // y fall speed
        snowVelocities[jdx + 2] = 0;                          // z (handled by sine wave)

        snowPhases[j] = Math.random() * Math.PI * 2;
      }

      snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
      snowGeo.userData.velocities = snowVelocities;
      snowGeo.userData.phases = snowPhases;

      var snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.25,
        transparent: true,
        opacity: 0.8,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(snowGeo, snowMat);
      weatherParticles.userData.type = 'snow';
      sceneCtx.scene.add(weatherParticles);

    } else if (type === 'storm') {
      // Storm: heavy rain + darker + lightning
      var stormCount = 3500;
      var stormGeo = new THREE.BufferGeometry();
      var stormPositions = new Float32Array(stormCount * 3);
      var stormVelocities = new Float32Array(stormCount * 3);

      for (var s = 0; s < stormCount; s++) {
        var sidx = s * 3;
        stormPositions[sidx] = (Math.random() - 0.5) * 120;
        stormPositions[sidx + 1] = Math.random() * 80 + 20;
        stormPositions[sidx + 2] = (Math.random() - 0.5) * 120;

        stormVelocities[sidx] = (Math.random() - 0.5) * 1.5;       // stronger wind
        stormVelocities[sidx + 1] = -1.2 - Math.random() * 0.6;    // faster rain
        stormVelocities[sidx + 2] = (Math.random() - 0.5) * 1.5;
      }

      stormGeo.setAttribute('position', new THREE.Float32BufferAttribute(stormPositions, 3));
      stormGeo.userData.velocities = stormVelocities;

      var stormMat = new THREE.PointsMaterial({
        color: 0x8899bb,
        size: 0.18,
        transparent: true,
        opacity: 0.7,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(stormGeo, stormMat);
      weatherParticles.userData.type = 'rain'; // reuse rain update logic
      sceneCtx.scene.add(weatherParticles);

      // Create lightning light (initially off)
      if (!lightningLight) {
        lightningLight = new THREE.PointLight(0xeeeeff, 0, 200);
        lightningLight.position.set(0, 50, 0);
        sceneCtx.scene.add(lightningLight);
      }
      lightningTimer = 0;
      lightningActive = false;

      // Darken ambient for storm
      if (sceneCtx.ambientLight) {
        sceneCtx.ambientLight.intensity = Math.max(0.15, sceneCtx.ambientLight.intensity * 0.6);
      }

    } else if (type === 'cloudy') {
      // Cloudy: dim the lights slightly
      if (sceneCtx.ambientLight) {
        sceneCtx.ambientLight.intensity = Math.max(0.25, sceneCtx.ambientLight.intensity * 0.8);
      }
      if (sceneCtx.directionalLight) {
        sceneCtx.directionalLight.intensity = Math.max(0.2, sceneCtx.directionalLight.intensity * 0.7);
      }
    } else {
      // Clear: remove lightning light if it exists
      if (lightningLight && sceneCtx.scene) {
        sceneCtx.scene.remove(lightningLight);
        lightningLight = null;
      }
    }
  }

  function updateWeatherEffects(sceneCtx, deltaTime, cameraPos) {
    if (!weatherParticles || !weatherParticles.geometry) return;

    var positions = weatherParticles.geometry.attributes.position.array;
    var velocities = weatherParticles.geometry.userData.velocities;
    var type = weatherParticles.userData.type;

    var camX = cameraPos.x || 0;
    var camY = cameraPos.y || 0;
    var camZ = cameraPos.z || 0;

    if (type === 'rain') {
      // Update rain particles
      for (var i = 0; i < positions.length / 3; i++) {
        var idx = i * 3;

        // Update position based on velocity
        positions[idx] += velocities[idx] * deltaTime;
        positions[idx + 1] += velocities[idx + 1] * deltaTime;
        positions[idx + 2] += velocities[idx + 2] * deltaTime;

        // Get ground height at particle position
        var groundHeight = terrainHeight(positions[idx], positions[idx + 2]);

        // Recycle particle if it hits the ground
        if (positions[idx + 1] < groundHeight) {
          // Respawn near camera
          positions[idx] = camX + (Math.random() - 0.5) * 100;
          positions[idx + 1] = camY + Math.random() * 40 + 20;
          positions[idx + 2] = camZ + (Math.random() - 0.5) * 100;

          // Randomize drift slightly
          velocities[idx] = (Math.random() - 0.5) * 0.5;
          velocities[idx + 2] = (Math.random() - 0.5) * 0.5;
        }

        // Keep particles centered around camera
        var dx = positions[idx] - camX;
        var dz = positions[idx + 2] - camZ;
        if (Math.abs(dx) > 60 || Math.abs(dz) > 60) {
          positions[idx] = camX + (Math.random() - 0.5) * 100;
          positions[idx + 1] = camY + Math.random() * 40 + 20;
          positions[idx + 2] = camZ + (Math.random() - 0.5) * 100;
        }
      }

    } else if (type === 'snow') {
      var phases = weatherParticles.geometry.userData.phases;
      var time = Date.now() * 0.001;

      // Update snow particles
      for (var j = 0; j < positions.length / 3; j++) {
        var jdx = j * 3;

        // Sine wave horizontal movement
        var sineX = Math.sin(time * 0.5 + phases[j]) * 0.3;
        var sineZ = Math.cos(time * 0.5 + phases[j] * 1.3) * 0.3;

        positions[jdx] += (velocities[jdx] + sineX) * deltaTime;
        positions[jdx + 1] += velocities[jdx + 1] * deltaTime;
        positions[jdx + 2] += (velocities[jdx + 2] + sineZ) * deltaTime;

        // Get ground height at particle position
        var snowGroundHeight = terrainHeight(positions[jdx], positions[jdx + 2]);

        // Recycle particle if it hits the ground
        if (positions[jdx + 1] < snowGroundHeight) {
          positions[jdx] = camX + (Math.random() - 0.5) * 120;
          positions[jdx + 1] = camY + Math.random() * 50 + 30;
          positions[jdx + 2] = camZ + (Math.random() - 0.5) * 120;
          phases[j] = Math.random() * Math.PI * 2;
        }

        // Keep particles centered around camera
        var sdx = positions[jdx] - camX;
        var sdz = positions[jdx + 2] - camZ;
        if (Math.abs(sdx) > 70 || Math.abs(sdz) > 70) {
          positions[jdx] = camX + (Math.random() - 0.5) * 120;
          positions[jdx + 1] = camY + Math.random() * 50 + 30;
          positions[jdx + 2] = camZ + (Math.random() - 0.5) * 120;
        }
      }
    }

    weatherParticles.geometry.attributes.position.needsUpdate = true;

    // Rain splash spawning â€” when rain particles hit ground
    if (type === 'rain' && splashPool.length > 0) {
      for (var si = 0; si < positions.length / 3; si += 10) { // sample every 10th
        var sidx = si * 3;
        var groundH = terrainHeight(positions[sidx], positions[sidx + 2]);
        if (positions[sidx + 1] < groundH + 0.5 && positions[sidx + 1] > groundH - 1) {
          spawnSplash(positions[sidx], groundH, positions[sidx + 2]);
        }
      }
    }

    // Lightning flash logic for storms
    if (lightningLight && weatherParticles.userData.type === 'rain') {
      lightningTimer += deltaTime;

      if (lightningActive) {
        // Flash is happening â€” fade out over 150ms
        lightningLight.intensity *= 0.85;

        // Flash ambient intensity
        if (sceneCtx && sceneCtx.ambientLight && lightningLight.intensity > 1.0) {
          sceneCtx.ambientLight.intensity = Math.min(2.0, lightningLight.intensity * 0.5);
        }

        if (lightningLight.intensity < 0.05) {
          lightningLight.intensity = 0;
          lightningActive = false;
          lightningTimer = 0;
          // Restore ambient
          if (sceneCtx && sceneCtx.ambientLight) {
            sceneCtx.ambientLight.intensity = 0.15;
          }
        }
      } else {
        // Wait for next flash (random interval 3-8 seconds)
        var flashInterval = 3000 + Math.random() * 5000;
        if (lightningTimer > flashInterval) {
          // Trigger lightning flash
          lightningActive = true;
          lightningLight.intensity = 2.5 + Math.random() * 1.5;
          var boltX = (cameraPos.x || 0) + (Math.random() - 0.5) * 80;
          var boltZ = (cameraPos.z || 0) + (Math.random() - 0.5) * 80;
          lightningLight.position.set(boltX, 45 + Math.random() * 15, boltZ);
          lightningTimer = 0;

          // Create visible bolt
          createLightningBolt(sceneCtx, boltX, boltZ);

          // Trigger camera shake via callback
          if (weatherCallbacks.onLightningStrike) {
            weatherCallbacks.onLightningStrike(boltX, boltZ);
          }
        }
      }
    }

    // Update lightning bolt visibility
    updateLightningBolt(sceneCtx, deltaTime);

    // Update rain splashes
    updateRainSplashes(deltaTime);
  }

  function getCurrentWeather() {
    return currentWeatherType;
  }

  // ========================================================================
  // WATER SYSTEM â€” Animated water bodies for zones
  // ========================================================================

  var waterBodies = [];
  var waterTime = 0;
  var waterWeatherMultiplier = 1.0; // Modified by weather conditions

  function initWater(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var scene = sceneCtx.scene;

    // Clear any existing water bodies
    for (var i = 0; i < waterBodies.length; i++) {
      scene.remove(waterBodies[i].mesh);
      if (waterBodies[i].geometry) waterBodies[i].geometry.dispose();
      if (waterBodies[i].material) waterBodies[i].material.dispose();
    }
    waterBodies = [];

    // Gardens: Central pond/lake (~30 unit radius) - peaceful, clear water
    var gardensPond = createWaterBody({
      type: 'circle',
      centerX: ZONES.gardens.cx,
      centerZ: ZONES.gardens.cz,
      radius: 30,
      height: ZONES.gardens.baseHeight + 0.3,
      segments: 64,
      waveSpeed: 0.8,
      waveHeight: 0.2,
      waveFrequency: 0.3,
      color: 0x3388cc,
      emissive: 0x113355
    });
    scene.add(gardensPond.mesh);
    waterBodies.push(gardensPond);

    // Wilds: Flowing river (~10 unit wide, winding through zone)
    // Create river as a series of connected segments
    var riverSegments = createRiverPath(ZONES.wilds.cx, ZONES.wilds.cz, ZONES.wilds.radius);
    for (var j = 0; j < riverSegments.length; j++) {
      var riverSegment = createWaterBody({
        type: 'river',
        centerX: riverSegments[j].x,
        centerZ: riverSegments[j].z,
        width: 10,
        length: riverSegments[j].length,
        rotation: riverSegments[j].rotation,
        height: ZONES.wilds.baseHeight + 0.2,
        segments: 64,
        waveSpeed: 1.2,
        waveHeight: 0.25,
        waveFrequency: 0.5,
        flowDirection: riverSegments[j].direction,
        color: 0x2277bb,
        emissive: 0x0f2844
      });
      scene.add(riverSegment.mesh);
      waterBodies.push(riverSegment);
    }

    // Nexus: Decorative fountain pool (~8 unit radius) - magical, glowing water
    var nexusFountain = createWaterBody({
      type: 'circle',
      centerX: ZONES.nexus.cx,
      centerZ: ZONES.nexus.cz,
      radius: 8,
      height: ZONES.nexus.baseHeight + 0.5,
      segments: 64,
      waveSpeed: 1.5,
      waveHeight: 0.15,
      waveFrequency: 0.8,
      color: 0x4499dd,
      emissive: 0x225588
    });
    scene.add(nexusFountain.mesh);
    waterBodies.push(nexusFountain);
  }

  function createWaterBody(config) {
    var geometry, material, mesh;
    var segments = config.segments || 64;

    // Create geometry based on type
    if (config.type === 'circle') {
      geometry = new THREE.PlaneGeometry(config.radius * 2, config.radius * 2, segments, segments);
    } else if (config.type === 'river') {
      geometry = new THREE.PlaneGeometry(config.length, config.width, segments, segments);
    }

    // Rotate to be horizontal
    geometry.rotateX(-Math.PI / 2);

    // Position the geometry
    geometry.translate(config.centerX, config.height, config.centerZ);

    // Apply rotation for river segments
    if (config.rotation) {
      var tempGeom = new THREE.PlaneGeometry(config.length, config.width, segments, segments);
      tempGeom.rotateX(-Math.PI / 2);
      tempGeom.rotateY(config.rotation);
      tempGeom.translate(config.centerX, config.height, config.centerZ);
      geometry = tempGeom;
    }

    // Store initial vertex positions for animation
    var positions = geometry.attributes.position.array;
    var initialPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
      initialPositions[i] = positions[i];
    }

    // Create water material with enhanced visual properties
    var waterColor = config.color || 0x2266aa;
    var emissiveColor = config.emissive || 0x112244;

    material = new THREE.MeshPhongMaterial({
      color: waterColor,
      transparent: true,
      opacity: 0.65,
      side: THREE.DoubleSide,
      shininess: 100,
      specular: 0xaaddff,
      emissive: emissiveColor,
      emissiveIntensity: 0.15,
      reflectivity: 0.8
    });

    mesh = new THREE.Mesh(geometry, material);
    mesh.receiveShadow = false;
    mesh.castShadow = false;

    // Store config and initial positions for animation
    return {
      mesh: mesh,
      geometry: geometry,
      material: material,
      initialPositions: initialPositions,
      config: config
    };
  }

  function createRiverPath(centerX, centerZ, zoneRadius) {
    // Create a winding river path through the Wilds zone
    var segments = [];
    var segmentLength = 25;
    var numSegments = 6;

    // Start from northwest side of zone
    var startX = centerX - zoneRadius * 0.6;
    var startZ = centerZ - zoneRadius * 0.7;

    // Create winding path
    var currentX = startX;
    var currentZ = startZ;
    var currentAngle = Math.PI * 0.3; // Initial direction (southeast)

    for (var i = 0; i < numSegments; i++) {
      // Calculate segment endpoint
      var nextX = currentX + Math.cos(currentAngle) * segmentLength;
      var nextZ = currentZ + Math.sin(currentAngle) * segmentLength;

      // Segment center point
      var segX = (currentX + nextX) / 2;
      var segZ = (currentZ + nextZ) / 2;

      segments.push({
        x: segX,
        z: segZ,
        length: segmentLength,
        rotation: currentAngle,
        direction: { x: Math.cos(currentAngle), z: Math.sin(currentAngle) }
      });

      // Update position and add some curve variation
      currentX = nextX;
      currentZ = nextZ;
      currentAngle += (Math.random() - 0.5) * 0.6; // Random curve
    }

    return segments;
  }

  function updateWater(deltaTime, weatherType) {
    if (!waterBodies || waterBodies.length === 0) return;

    waterTime += deltaTime;

    // Adjust water animation based on weather conditions
    var targetMultiplier = 1.0;
    if (weatherType === 'storm') {
      targetMultiplier = 2.5; // Much choppier waves during storms
    } else if (weatherType === 'rain') {
      targetMultiplier = 1.6; // Moderately rough during rain
    } else if (weatherType === 'snow') {
      targetMultiplier = 0.5; // Calmer, colder water
    }

    // Smoothly interpolate to target multiplier
    waterWeatherMultiplier += (targetMultiplier - waterWeatherMultiplier) * deltaTime * 0.5;

    for (var i = 0; i < waterBodies.length; i++) {
      var water = waterBodies[i];
      if (!water || !water.geometry || !water.initialPositions) continue;

      var positions = water.geometry.attributes.position.array;
      var initialPos = water.initialPositions;
      var config = water.config;

      var baseWaveSpeed = config.waveSpeed || 1.0;
      var baseWaveHeight = config.waveHeight || 0.2;
      var waveFrequency = config.waveFrequency || 0.5;

      // Apply weather multiplier to wave parameters
      var waveSpeed = baseWaveSpeed * waterWeatherMultiplier;
      var waveHeight = baseWaveHeight * waterWeatherMultiplier;

      // Animate vertices with sine waves
      for (var j = 0; j < positions.length; j += 3) {
        var x = initialPos[j];
        var y = initialPos[j + 1];
        var z = initialPos[j + 2];

        // Calculate distance from center for circular water bodies
        var distFromCenter = 0;
        if (config.type === 'circle') {
          var dx = x - config.centerX;
          var dz = z - config.centerZ;
          distFromCenter = Math.sqrt(dx * dx + dz * dz);

          // Multi-layered wave system for more realistic water
          // Primary radial ripples from center
          var ripple = Math.sin(distFromCenter * waveFrequency - waterTime * waveSpeed) * waveHeight;

          // Secondary angular wave pattern
          var angle = Math.atan2(dz, dx);
          var secondaryWave = Math.sin(angle * 3 + waterTime * waveSpeed * 0.5) * waveHeight * 0.3;

          // Tertiary detail waves for visual complexity
          var detailWave = Math.sin(x * 0.4 + waterTime * waveSpeed * 1.2) * waveHeight * 0.2 +
                           Math.sin(z * 0.3 + waterTime * waveSpeed * 0.9) * waveHeight * 0.2;

          // Random chop for storms
          var chopWave = 0;
          if (waterWeatherMultiplier > 1.5) {
            chopWave = Math.sin(x * 0.8 + z * 0.7 + waterTime * waveSpeed * 2.0) * waveHeight * 0.25;
          }

          positions[j + 1] = y + ripple + secondaryWave + detailWave + chopWave;

          // Fade ripples near edge for natural boundary
          if (distFromCenter > config.radius * 0.8) {
            var fadeRatio = 1 - (distFromCenter - config.radius * 0.8) / (config.radius * 0.2);
            positions[j + 1] = y + (ripple + secondaryWave + detailWave + chopWave) * Math.max(0, fadeRatio);
          }
        } else if (config.type === 'river') {
          // Flowing river animation with directional waves
          var flowDir = config.flowDirection || { x: 1, z: 0 };
          var flowComponent = (x - config.centerX) * flowDir.x + (z - config.centerZ) * flowDir.z;

          // Primary waves flowing in direction of river
          var flowWave = Math.sin(flowComponent * waveFrequency - waterTime * waveSpeed) * waveHeight;

          // Secondary flow wave at different frequency
          var flowWave2 = Math.sin(flowComponent * waveFrequency * 1.3 - waterTime * waveSpeed * 1.4) * waveHeight * 0.5;

          // Cross-river waves for more natural look
          var crossComponent = -(x - config.centerX) * flowDir.z + (z - config.centerZ) * flowDir.x;
          var crossWave = Math.sin(crossComponent * waveFrequency * 0.8 + waterTime * waveSpeed * 0.6) * waveHeight * 0.4;

          // Detail turbulence
          var turbulence = Math.sin(x * 0.5 + waterTime * waveSpeed * 1.8) * waveHeight * 0.15 +
                           Math.sin(z * 0.4 + waterTime * waveSpeed * 1.5) * waveHeight * 0.15;

          // Rapids effect during storms
          var rapids = 0;
          if (waterWeatherMultiplier > 1.5) {
            rapids = Math.sin(flowComponent * 1.2 - waterTime * waveSpeed * 3.0) * waveHeight * 0.3;
          }

          positions[j + 1] = y + flowWave + flowWave2 + crossWave + turbulence + rapids;
        }
      }

      water.geometry.attributes.position.needsUpdate = true;
      water.geometry.computeVertexNormals();

      // Update water material properties based on weather
      if (water.material) {
        // Adjust opacity based on weather (rougher water is more opaque)
        var targetOpacity = 0.65;
        if (weatherType === 'storm') {
          targetOpacity = 0.75; // Darker, choppier water
        } else if (weatherType === 'rain') {
          targetOpacity = 0.7;
        }
        water.material.opacity += (targetOpacity - water.material.opacity) * deltaTime * 0.5;

        // Adjust emissive intensity (calmer water glows more)
        var targetEmissive = 0.15;
        if (weatherType === 'storm') {
          targetEmissive = 0.08; // Less glow during storm
        } else if (weatherType === 'snow') {
          targetEmissive = 0.1; // Reduced glow in cold
        }
        if (water.material.emissiveIntensity !== undefined) {
          water.material.emissiveIntensity += (targetEmissive - water.material.emissiveIntensity) * deltaTime * 0.5;
        }
      }
    }
  }

  // ========================================================================
  // SKYBOX / SKY DOME SYSTEM
  // ========================================================================

  var playerStarsMesh = null;

  function initPlayerStars(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    // Load player stars from localStorage
    var stored = null;
    if (typeof localStorage !== 'undefined') {
      try { stored = JSON.parse(localStorage.getItem('zion_playerStars') || '{}'); } catch(e) { stored = {}; }
    }
    if (!stored || Object.keys(stored).length === 0) return;

    var psPos = [];
    var psSizes = [];
    var psColors = [];
    for (var pid in stored) {
      var ps = stored[pid];
      psPos.push(ps.x || 0, ps.y || 0, ps.z || 0);
      psSizes.push(2.5);
      psColors.push(1.0, 0.87, 0.53); // warm gold 0xFFDD88
    }

    if (psPos.length === 0) return;

    var psGeo = new THREE.BufferGeometry();
    psGeo.setAttribute('position', new THREE.Float32BufferAttribute(psPos, 3));
    psGeo.setAttribute('size', new THREE.Float32BufferAttribute(psSizes, 1));
    psGeo.setAttribute('color', new THREE.Float32BufferAttribute(psColors, 3));

    var psMat = new THREE.PointsMaterial({
      size: 2.5,
      sizeAttenuation: false,
      transparent: true,
      opacity: 0.0,
      fog: false,
      vertexColors: true
    });

    playerStarsMesh = new THREE.Points(psGeo, psMat);
    sceneCtx.scene.add(playerStarsMesh);
  }

  function registerPlayerStar(playerId, playerName) {
    // Place star at a deterministic position based on player ID hash
    var hash = 0;
    for (var i = 0; i < playerId.length; i++) {
      hash = ((hash << 5) - hash) + playerId.charCodeAt(i);
      hash |= 0;
    }
    var theta = (Math.abs(hash) % 10000) / 10000 * Math.PI * 2;
    var phi = (Math.abs(hash * 7919) % 10000) / 10000 * Math.PI * 0.6 + 0.2; // keep above horizon
    var R = 750;
    var starData = {
      name: playerName || playerId,
      x: R * Math.sin(phi) * Math.cos(theta),
      y: R * Math.cos(phi),
      z: R * Math.sin(phi) * Math.sin(theta),
      color: 0xFFDD88,
      ts: new Date().toISOString()
    };

    // Save to localStorage
    if (typeof localStorage !== 'undefined') {
      try {
        var stored = JSON.parse(localStorage.getItem('zion_playerStars') || '{}');
        stored[playerId] = starData;
        localStorage.setItem('zion_playerStars', JSON.stringify(stored));
      } catch(e) {}
    }
    return starData;
  }

  function initSkybox(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Create sky dome with gradient colors using vertex colors
    var skyGeo = new THREE.SphereGeometry(800, 32, 32);

    // Add vertex colors for gradient (deep blue at top, orange/pink at horizon)
    var colors = [];
    var posArray = skyGeo.attributes.position.array;
    for (var i = 0; i < posArray.length; i += 3) {
      var y = posArray[i + 1];
      var normalizedY = (y + 800) / 1600; // 0 at bottom, 1 at top

      // Deep blue at top (y > 0.5), orange/pink at horizon (y < 0.5)
      var r, g, b;
      if (normalizedY > 0.5) {
        // Top half: deep blue
        var t = (normalizedY - 0.5) / 0.5;
        r = 0.02 + t * 0.1;
        g = 0.02 + t * 0.3;
        b = 0.2 + t * 0.6;
      } else {
        // Bottom half: gradient from orange/pink to blue
        var t = normalizedY / 0.5;
        r = 1.0 - t * 0.88;
        g = 0.42 - t * 0.1;
        b = 0.21 + t * 0.59;
      }

      colors.push(r, g, b);
    }

    skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    var skyMat = new THREE.MeshBasicMaterial({
      side: THREE.BackSide,
      vertexColors: true,
      fog: false
    });
    skyDome = new THREE.Mesh(skyGeo, skyMat);
    sceneCtx.scene.add(skyDome);

    // â”€â”€ Constellation Data â”€â”€
    var CONSTELLATIONS = {
      orion: { stars: [
        {theta:1.55,phi:1.20},{theta:1.60,phi:1.10},{theta:1.58,phi:1.00},
        {theta:1.50,phi:0.95},{theta:1.65,phi:0.95},
        {theta:1.52,phi:0.85},{theta:1.63,phi:0.85}
      ]},
      bigDipper: { stars: [
        {theta:0.80,phi:0.50},{theta:0.85,phi:0.52},{theta:0.92,phi:0.50},
        {theta:0.98,phi:0.53},{theta:1.05,phi:0.48},
        {theta:1.10,phi:0.55},{theta:1.15,phi:0.50}
      ]},
      cassiopeia: { stars: [
        {theta:2.50,phi:0.40},{theta:2.55,phi:0.35},{theta:2.60,phi:0.40},
        {theta:2.65,phi:0.35},{theta:2.70,phi:0.40}
      ]},
      scorpius: { stars: [
        {theta:4.20,phi:1.30},{theta:4.22,phi:1.25},{theta:4.25,phi:1.20},
        {theta:4.27,phi:1.15},{theta:4.30,phi:1.10},
        {theta:4.35,phi:1.12},{theta:4.40,phi:1.15},
        {theta:4.45,phi:1.20},{theta:4.50,phi:1.25}
      ]},
      leo: { stars: [
        {theta:3.10,phi:0.80},{theta:3.15,phi:0.75},{theta:3.20,phi:0.78},
        {theta:3.25,phi:0.82},{theta:3.18,phi:0.88},{theta:3.22,phi:0.85}
      ]},
      southernCross: { stars: [
        {theta:5.00,phi:2.10},{theta:5.05,phi:2.00},{theta:5.00,phi:1.90},
        {theta:4.95,phi:2.00},{theta:5.03,phi:2.00}
      ]}
    };

    // Create starfield: 1800 random + constellation stars
    var starGeo = new THREE.BufferGeometry();
    var starPos = [];
    var starSizes = [];
    var starColors = [];
    var starPhases = []; // for twinkling

    // 1800 random background stars
    for (var i = 0; i < 1800; i++) {
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.random() * Math.PI;
      var r = 750;
      starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
      starSizes.push(0.3 + Math.random() * 1.2);
      starColors.push(1.0, 1.0, 1.0); // white
      starPhases.push(Math.random() * Math.PI * 2);
    }

    // Add constellation stars (brighter, slightly warm-tinted)
    for (var cKey in CONSTELLATIONS) {
      var cStars = CONSTELLATIONS[cKey].stars;
      for (var cs = 0; cs < cStars.length; cs++) {
        var s = cStars[cs];
        var cr = 750;
        starPos.push(cr * Math.sin(s.phi) * Math.cos(s.theta), cr * Math.cos(s.phi), cr * Math.sin(s.phi) * Math.sin(s.theta));
        starSizes.push(1.8 + Math.random() * 0.5); // brighter
        starColors.push(1.0, 0.95, 0.85); // warm white
        starPhases.push(Math.random() * Math.PI * 2);
      }
    }

    var totalStars = starPos.length / 3;
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
    starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
    starGeo.userData.phases = new Float32Array(starPhases);
    starGeo.userData.baseSizes = new Float32Array(starSizes);
    starGeo.userData.starCount = totalStars;

    var starMat = new THREE.PointsMaterial({
      size: 1.0,
      sizeAttenuation: false,
      transparent: true,
      opacity: 0.0,
      fog: false,
      vertexColors: true
    });

    stars = new THREE.Points(starGeo, starMat);
    sceneCtx.scene.add(stars);

    // â”€â”€ Player Constellation Stars (separate Points group) â”€â”€
    initPlayerStars(sceneCtx);

    // Create Sun
    var sunGeo = new THREE.SphereGeometry(5, 16, 16);
    var sunMat = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      fog: false
    });
    sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sceneCtx.scene.add(sunMesh);

    // Create Moon
    var moonGeo = new THREE.SphereGeometry(3, 16, 16);
    var moonMat = new THREE.MeshBasicMaterial({
      color: 0xccccdd,
      fog: false
    });
    moonMesh = new THREE.Mesh(moonGeo, moonMat);
    sceneCtx.scene.add(moonMesh);
  }

  function updateSkybox(sceneCtx, worldTime) {
    if (!sceneCtx || !sceneCtx.camera) return;

    // Make sky dome follow camera position
    if (skyDome) {
      skyDome.position.copy(sceneCtx.camera.position);
    }

    // Update sun and moon positions based on worldTime
    // worldTime: 0-1440 (minutes in 24h cycle)
    // Noon (720) = sun overhead, Midnight (0/1440) = sun below horizon
    var normalizedTime = worldTime / 1440; // 0-1
    var sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2; // -PI/2 at midnight, PI/2 at noon

    if (sunMesh) {
      var sunRadius = 400;
      sunMesh.position.set(
        Math.cos(sunAngle) * sunRadius,
        Math.sin(sunAngle) * sunRadius,
        0
      );
      sunMesh.position.add(sceneCtx.camera.position);
    }

    if (moonMesh) {
      var moonRadius = 400;
      // Moon is opposite to sun
      var moonAngle = sunAngle + Math.PI;
      moonMesh.position.set(
        Math.cos(moonAngle) * moonRadius,
        Math.sin(moonAngle) * moonRadius,
        0
      );
      moonMesh.position.add(sceneCtx.camera.position);
    }

    // Update star visibility based on worldTime
    if (stars && stars.material) {
      // Night: worldTime 1080-1440 (18:00-24:00) and 0-360 (00:00-06:00)
      // Day: worldTime 360-1080 (06:00-18:00)
      var opacity = 0.0;

      if (worldTime >= 1080 && worldTime <= 1440) {
        // Evening to midnight (18:00-24:00)
        var t = (worldTime - 1080) / 360;
        opacity = Math.min(1.0, t * 2); // Fade in
      } else if (worldTime >= 0 && worldTime < 360) {
        // Midnight to dawn (00:00-06:00)
        var t = worldTime / 360;
        opacity = Math.max(0.0, 1.0 - t * 2); // Fade out
      } else if (worldTime >= 300 && worldTime < 420) {
        // Dawn fade out (05:00-07:00)
        var t = (worldTime - 300) / 120;
        opacity = Math.max(0.0, 1.0 - t);
      } else if (worldTime >= 1020 && worldTime < 1140) {
        // Dusk fade in (17:00-19:00)
        var t = (worldTime - 1020) / 120;
        opacity = Math.min(1.0, t);
      }

      stars.material.opacity = opacity;
      stars.material.transparent = true;

      // Star twinkling (only when visible)
      if (opacity > 0.05 && stars.geometry.userData.phases) {
        var phases = stars.geometry.userData.phases;
        var baseSizes = stars.geometry.userData.baseSizes;
        var sizes = stars.geometry.attributes.size.array;
        var twinkleTime = Date.now() * 0.001;
        for (var si = 0; si < phases.length; si++) {
          sizes[si] = baseSizes[si] + Math.sin(twinkleTime * 1.5 + phases[si]) * 0.4;
        }
        stars.geometry.attributes.size.needsUpdate = true;
      }

      // Make stars follow camera
      stars.position.copy(sceneCtx.camera.position);
    }

    // Update player stars visibility + position
    if (playerStarsMesh && playerStarsMesh.material) {
      playerStarsMesh.material.opacity = stars ? stars.material.opacity : 0;
      playerStarsMesh.position.copy(sceneCtx.camera.position);
    }
  }

  // ========================================================================
  // HARVESTABLE RESOURCE NODES
  // ========================================================================

  var resourceNodes = [];

  function initResourceNodes(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    addZoneResources(sceneCtx.scene, 'gardens', [
      { itemId: 'flower_rose', count: 8, radius: 30 },
      { itemId: 'flower_tulip', count: 10, radius: 35 },
      { itemId: 'flower_sunflower', count: 12, radius: 40 },
      { itemId: 'herb_lavender', count: 8, radius: 28 },
      { itemId: 'seed_wildflower', count: 6, radius: 25 }
    ]);

    addZoneResources(sceneCtx.scene, 'wilds', [
      { itemId: 'wood_oak', count: 15, radius: 45 },
      { itemId: 'wood_pine', count: 12, radius: 50 },
      { itemId: 'stone_common', count: 10, radius: 40 },
      { itemId: 'herb_ginseng', count: 5, radius: 35 },
      { itemId: 'crystal_clear', count: 4, radius: 30 },
      { itemId: 'food_mushroom', count: 8, radius: 38 },
      { itemId: 'food_berry', count: 10, radius: 42 }
    ]);

    addZoneResources(sceneCtx.scene, 'nexus', [
      { itemId: 'crystal_clear', count: 6, radius: 25 },
      { itemId: 'crystal_amethyst', count: 4, radius: 20 }
    ]);

    addZoneResources(sceneCtx.scene, 'studio', [
      { itemId: 'wood_mystical', count: 3, radius: 25 },
      { itemId: 'crystal_clear', count: 5, radius: 22 }
    ]);

    addZoneResources(sceneCtx.scene, 'commons', [
      { itemId: 'wood_oak', count: 8, radius: 25 },
      { itemId: 'stone_common', count: 6, radius: 23 }
    ]);

    addZoneResources(sceneCtx.scene, 'athenaeum', [
      { itemId: 'item_scroll', count: 10, radius: 28 }
    ]);

    addZoneResources(sceneCtx.scene, 'arena', [
      { itemId: 'item_trophy', count: 2, radius: 20 }
    ]);
  }

  function addZoneResources(scene, zoneId, resources) {
    var zone = ZONES[zoneId];
    if (!zone) return;

    resources.forEach(function(res) {
      for (var i = 0; i < res.count; i++) {
        var angle = seededRandom(zoneId.charCodeAt(0), i, res.itemId.charCodeAt(0)) * Math.PI * 2;
        var dist = seededRandom(zoneId.charCodeAt(1), i, res.itemId.charCodeAt(1)) * res.radius;
        var x = zone.cx + Math.cos(angle) * dist;
        var z = zone.cz + Math.sin(angle) * dist;

        var onPath = false;
        for (var pz in ZONES) {
          if (pz === 'nexus') continue;
          if (pointToSegDist(x, z, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[pz].cx, ZONES[pz].cz) < 5) {
            onPath = true;
            break;
          }
        }
        if (onPath) continue;

        var distFromCenter = Math.sqrt((x - zone.cx) * (x - zone.cx) + (z - zone.cz) * (z - zone.cz));
        if (distFromCenter < zone.radius * 0.3) continue;

        var y = terrainHeight(x, z);
        createResourceNode(scene, x, y, z, res.itemId, zoneId);
      }
    });
  }

  function createResourceNode(scene, x, y, z, itemId, zone) {
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var itemData = Inventory.getItemData(itemId);
    if (!itemData) return;

    var nodeGroup = new THREE.Group();
    var nodeMesh;

    if (itemData.type === 'wood') {
      var stumpGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
      var stumpMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      nodeMesh = new THREE.Mesh(stumpGeo, stumpMat);
      nodeMesh.position.y = 0.6;
      nodeGroup.add(nodeMesh);

      var leavesGeo = new THREE.SphereGeometry(0.5, 6, 6);
      var leavesMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50, transparent: true, opacity: 0.7 });
      var leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = 1.4;
      nodeGroup.add(leaves);

    } else if (itemData.type === 'stone') {
      var rockGeo = new THREE.DodecahedronGeometry(0.6, 0);
      var rockMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
      nodeMesh = new THREE.Mesh(rockGeo, rockMat);
      nodeMesh.position.y = 0.4;
      nodeMesh.rotation.set(Math.random(), Math.random(), Math.random());
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'crystal') {
      var crystalGeo = new THREE.OctahedronGeometry(0.5, 0);
      var crystalColor = itemId === 'crystal_amethyst' ? 0x9C27B0 : (itemId === 'crystal_emerald' ? 0x4CAF50 : 0x00BCD4);
      var crystalMat = new THREE.MeshStandardMaterial({
        color: crystalColor,
        emissive: crystalColor,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.8
      });
      nodeMesh = new THREE.Mesh(crystalGeo, crystalMat);
      nodeMesh.position.y = 0.7;
      nodeGroup.add(nodeMesh);

      var glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var glowMat = new THREE.MeshBasicMaterial({ color: crystalColor, transparent: true, opacity: 0.3 });
      var glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 0.7;
      nodeGroup.add(glow);

      animatedObjects.push({ mesh: nodeMesh, type: 'crystal', params: { speed: 0.3, baseY: 0.7 } });

    } else if (itemData.type === 'flowers' || itemData.type === 'herbs') {
      var flowerGeo = new THREE.SphereGeometry(0.3, 6, 6);
      var flowerColors = {
        flower_rose: 0xFF1744, flower_tulip: 0xE91E63, flower_sunflower: 0xFFEB3B,
        flower_lotus: 0xE1BEE7, flower_cherry: 0xF8BBD0,
        herb_mint: 0x4CAF50, herb_sage: 0x66BB6A, herb_ginseng: 0xA1887F, herb_lavender: 0xCE93D8
      };
      var flowerColor = flowerColors[itemId] || 0x4CAF50;
      var flowerMat = new THREE.MeshStandardMaterial({ color: flowerColor });
      nodeMesh = new THREE.Mesh(flowerGeo, flowerMat);
      nodeMesh.position.y = 0.3;
      nodeGroup.add(nodeMesh);

      var stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 4);
      var stemMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
      var stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.15;
      nodeGroup.add(stem);

    } else if (itemData.type === 'seeds') {
      var seedGeo = new THREE.SphereGeometry(0.2, 6, 6);
      var seedMat = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
      nodeMesh = new THREE.Mesh(seedGeo, seedMat);
      nodeMesh.position.y = 0.2;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'food') {
      var foodGeo = new THREE.SphereGeometry(0.25, 6, 6);
      var foodColors = { food_mushroom: 0xD32F2F, food_berry: 0x7B1FA2 };
      var foodColor = foodColors[itemId] || 0x8D6E63;
      var foodMat = new THREE.MeshStandardMaterial({ color: foodColor });
      nodeMesh = new THREE.Mesh(foodGeo, foodMat);
      nodeMesh.position.y = 0.25;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'knowledge') {
      var scrollGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
      var scrollMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC });
      nodeMesh = new THREE.Mesh(scrollGeo, scrollMat);
      nodeMesh.position.y = 0.3;
      nodeMesh.rotation.z = Math.PI / 2;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'trophies') {
      var trophyGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var trophyMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.2 });
      nodeMesh = new THREE.Mesh(trophyGeo, trophyMat);
      nodeMesh.position.y = 0.5;
      nodeGroup.add(nodeMesh);

      var baseGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.3, 8);
      var baseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      var base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.15;
      nodeGroup.add(base);

    } else {
      var genGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
      var genMat = new THREE.MeshStandardMaterial({ color: 0xBDBDBD });
      nodeMesh = new THREE.Mesh(genGeo, genMat);
      nodeMesh.position.y = 0.2;
      nodeGroup.add(nodeMesh);
    }

    nodeGroup.position.set(x, y, z);
    nodeGroup.userData.isResource = true;
    nodeGroup.userData.itemId = itemId;
    nodeGroup.userData.depleted = false;
    nodeGroup.userData.respawnTime = 0;
    nodeGroup.userData.zone = zone;
    nodeGroup.userData.nodeMesh = nodeMesh;

    scene.add(nodeGroup);
    resourceNodes.push(nodeGroup);
  }

  function updateResourceNodes(deltaTime) {
    var currentTime = Date.now();

    resourceNodes.forEach(function(node) {
      if (node.userData.depleted) {
        if (currentTime >= node.userData.respawnTime) {
          node.userData.depleted = false;
          node.visible = true;

          if (node.userData.nodeMesh && node.userData.nodeMesh.material) {
            node.userData.nodeMesh.material.opacity = 1.0;
            node.userData.nodeMesh.material.transparent = false;
          }
        }
      }
    });
  }

  function harvestResource(node) {
    if (!node || !node.userData || !node.userData.isResource) return null;
    if (node.userData.depleted) return null;

    var itemId = node.userData.itemId;

    node.userData.depleted = true;
    node.userData.respawnTime = Date.now() + (30000 + Math.random() * 30000);

    if (node.userData.nodeMesh && node.userData.nodeMesh.material) {
      node.userData.nodeMesh.material.opacity = 0.3;
      node.userData.nodeMesh.material.transparent = true;
    }

    return itemId;
  }

  function getResourceNodeAtMouse(raycaster, camera, mouseX, mouseY) {
    raycaster.setFromCamera({ x: mouseX, y: mouseY }, camera);

    var intersects = raycaster.intersectObjects(resourceNodes, true);
    if (intersects.length > 0) {
      var obj = intersects[0].object;
      while (obj && !obj.userData.isResource) {
        obj = obj.parent;
      }
      return obj && obj.userData.isResource ? obj : null;
    }
    return null;
  }

  // ========================================================================
  // BUILD MODE â€” Visual building placement system
  // ========================================================================

  var buildMode = false;
  var buildType = 'bench';
  var buildGhost = null;
  var buildRotation = 0;
  var placedBuildings = [];

  // Simple buildable structure models
  function createBuildableModel(type) {
    var group = new THREE.Group();

    switch (type) {
      case 'bench':
        // Seat plank
        var seatGeo = new THREE.BoxGeometry(1.2, 0.1, 0.4);
        var woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
        var seat = new THREE.Mesh(seatGeo, woodMat);
        seat.position.y = 0.4;
        group.add(seat);
        // Legs
        for (var i = 0; i < 4; i++) {
          var legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
          var leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.x = (i % 2 === 0) ? -0.5 : 0.5;
          leg.position.z = (i < 2) ? -0.15 : 0.15;
          leg.position.y = 0.2;
          group.add(leg);
        }
        break;

      case 'lantern':
        // Post
        var postGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
        var metalMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
        var post = new THREE.Mesh(postGeo, metalMat);
        post.position.y = 1;
        group.add(post);
        // Light box
        var lightGeo = new THREE.BoxGeometry(0.3, 0.4, 0.3);
        var lightMat = new THREE.MeshStandardMaterial({
          color: 0xffdd88,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5,
          roughness: 0.3
        });
        var light = new THREE.Mesh(lightGeo, lightMat);
        light.position.y = 2.2;
        group.add(light);
        break;

      case 'signpost':
        // Post
        var signPostGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
        var signPostMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var signPost = new THREE.Mesh(signPostGeo, signPostMat);
        signPost.position.y = 0.75;
        group.add(signPost);
        // Sign board
        var boardGeo = new THREE.BoxGeometry(1, 0.4, 0.1);
        var boardMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.7 });
        var board = new THREE.Mesh(boardGeo, boardMat);
        board.position.y = 1.6;
        group.add(board);
        break;

      case 'fence':
        // Two posts
        var fencePostGeo = new THREE.CylinderGeometry(0.06, 0.06, 1, 6);
        var fencePostMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var post1 = new THREE.Mesh(fencePostGeo, fencePostMat);
        post1.position.set(-0.4, 0.5, 0);
        group.add(post1);
        var post2 = new THREE.Mesh(fencePostGeo, fencePostMat);
        post2.position.set(0.4, 0.5, 0);
        group.add(post2);
        // Horizontal bar
        var barGeo = new THREE.BoxGeometry(1, 0.08, 0.08);
        var bar = new THREE.Mesh(barGeo, fencePostMat);
        bar.position.y = 0.6;
        group.add(bar);
        break;

      case 'planter':
        // Box
        var planterGeo = new THREE.BoxGeometry(0.8, 0.4, 0.8);
        var planterMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.8 });
        var planter = new THREE.Mesh(planterGeo, planterMat);
        planter.position.y = 0.2;
        group.add(planter);
        // Green top (soil/plants)
        var soilGeo = new THREE.BoxGeometry(0.7, 0.1, 0.7);
        var soilMat = new THREE.MeshStandardMaterial({ color: 0x2d5016, roughness: 0.9 });
        var soil = new THREE.Mesh(soilGeo, soilMat);
        soil.position.y = 0.45;
        group.add(soil);
        break;

      case 'campfire':
        // Fire ring (stones)
        for (var j = 0; j < 8; j++) {
          var angle = (j / 8) * Math.PI * 2;
          var stoneGeo = new THREE.BoxGeometry(0.15, 0.1, 0.1);
          var stoneMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.95 });
          var stone = new THREE.Mesh(stoneGeo, stoneMat);
          stone.position.x = Math.cos(angle) * 0.35;
          stone.position.z = Math.sin(angle) * 0.35;
          stone.position.y = 0.05;
          stone.rotation.y = angle;
          group.add(stone);
        }
        // Fire glow
        var fireGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.3, 6);
        var fireMat = new THREE.MeshStandardMaterial({
          color: 0xff6600,
          emissive: 0xff4400,
          emissiveIntensity: 0.8,
          roughness: 0.2
        });
        var fire = new THREE.Mesh(fireGeo, fireMat);
        fire.position.y = 0.2;
        group.add(fire);
        break;

      case 'archway':
        // Two pillars
        var pillarGeo = new THREE.BoxGeometry(0.3, 2.5, 0.3);
        var pillarMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e, roughness: 0.7 });
        var pillar1 = new THREE.Mesh(pillarGeo, pillarMat);
        pillar1.position.set(-0.8, 1.25, 0);
        group.add(pillar1);
        var pillar2 = new THREE.Mesh(pillarGeo, pillarMat);
        pillar2.position.set(0.8, 1.25, 0);
        group.add(pillar2);
        // Curved top (simplified as box)
        var archGeo = new THREE.BoxGeometry(1.9, 0.3, 0.3);
        var arch = new THREE.Mesh(archGeo, pillarMat);
        arch.position.y = 2.6;
        group.add(arch);
        break;

      case 'table':
        // Flat top
        var topGeo = new THREE.BoxGeometry(1.2, 0.1, 0.8);
        var tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
        var top = new THREE.Mesh(topGeo, tableMat);
        top.position.y = 0.7;
        group.add(top);
        // 4 legs
        for (var k = 0; k < 4; k++) {
          var tableLegGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
          var tableLeg = new THREE.Mesh(tableLegGeo, tableMat);
          tableLeg.position.x = (k % 2 === 0) ? -0.5 : 0.5;
          tableLeg.position.z = (k < 2) ? -0.3 : 0.3;
          tableLeg.position.y = 0.35;
          group.add(tableLeg);
        }
        break;

      case 'barrel':
        var barrelGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 12);
        var barrelMat = new THREE.MeshStandardMaterial({ color: 0x6d4c41, roughness: 0.8 });
        var barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.position.y = 0.4;
        group.add(barrel);
        // Metal bands
        for (var m = 0; m < 2; m++) {
          var bandGeo = new THREE.CylinderGeometry(0.32, 0.36, 0.05, 12);
          var bandMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.5 });
          var band = new THREE.Mesh(bandGeo, bandMat);
          band.position.y = 0.2 + m * 0.4;
          group.add(band);
        }
        break;

      case 'crate':
        var crateGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        var crateMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.9 });
        var crate = new THREE.Mesh(crateGeo, crateMat);
        crate.position.y = 0.3;
        group.add(crate);
        // Cross pattern
        var crossGeo1 = new THREE.BoxGeometry(0.05, 0.05, 0.7);
        var crossMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var cross1 = new THREE.Mesh(crossGeo1, crossMat);
        cross1.position.set(0, 0.3, 0);
        cross1.rotation.y = Math.PI / 4;
        group.add(cross1);
        var cross2 = new THREE.Mesh(crossGeo1, crossMat);
        cross2.position.set(0, 0.3, 0);
        cross2.rotation.y = -Math.PI / 4;
        group.add(cross2);
        break;

      default:
        // Fallback: simple cube
        var defaultGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        var defaultMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
        var defaultMesh = new THREE.Mesh(defaultGeo, defaultMat);
        defaultMesh.position.y = 0.25;
        group.add(defaultMesh);
    }

    return group;
  }

  function enterBuildMode(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    buildMode = true;
    buildRotation = 0;

    // Create ghost preview
    buildGhost = createBuildableModel(buildType);
    buildGhost.userData.isGhost = true;

    // Make all materials transparent
    buildGhost.traverse(function(child) {
      if (child.material) {
        var mat = child.material.clone();
        mat.transparent = true;
        mat.opacity = 0.5;
        mat.depthWrite = false;
        child.material = mat;
      }
    });

    sceneCtx.scene.add(buildGhost);
  }

  function exitBuildMode(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    buildMode = false;

    if (buildGhost) {
      sceneCtx.scene.remove(buildGhost);
      buildGhost.traverse(function(child) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      buildGhost = null;
    }
  }

  function setBuildType(type) {
    buildType = type;
    buildRotation = 0;
  }

  function confirmPlacement(sceneCtx, playerPos, zone) {
    if (!buildMode || !buildGhost || !sceneCtx || !sceneCtx.scene) return null;

    // Check if zone allows building
    var allowsBuild = (zone === 'commons' || zone === 'studio');
    if (!allowsBuild) {
      return { error: 'This zone does not allow building' };
    }

    // Get ghost position
    var pos = {
      x: buildGhost.position.x,
      y: buildGhost.position.y,
      z: buildGhost.position.z
    };

    // Create permanent structure
    var structure = createBuildableModel(buildType);
    structure.position.set(pos.x, pos.y, pos.z);
    structure.rotation.y = buildRotation;
    structure.userData.isBuilding = true;
    structure.userData.buildType = buildType;

    sceneCtx.scene.add(structure);

    // Track placement
    var placement = {
      type: buildType,
      x: pos.x,
      y: pos.y,
      z: pos.z,
      rotation: buildRotation
    };
    placedBuildings.push(placement);
    lastPlacedMesh = structure;

    return placement;
  }

  var lastPlacedMesh = null;

  function removeLastPlaced(sceneCtx) {
    if (lastPlacedMesh && sceneCtx && sceneCtx.scene) {
      sceneCtx.scene.remove(lastPlacedMesh);
      placedBuildings.pop();
      lastPlacedMesh = null;
    }
  }

  function updateBuildPreview(sceneCtx, mouseX, mouseY, camera) {
    if (!buildMode || !buildGhost || !sceneCtx || !camera) return;

    // Create raycaster
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(mouseX, mouseY);
    raycaster.setFromCamera(mouse, camera);

    // Raycast onto ground plane (y=0 for simplicity, could use terrain height)
    var plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    var hitPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, hitPoint);

    if (hitPoint) {
      // Snap to 2-unit grid
      var snappedX = Math.round(hitPoint.x / 2) * 2;
      var snappedZ = Math.round(hitPoint.z / 2) * 2;

      // Get terrain height at this position
      var groundY = terrainHeight(snappedX, snappedZ);

      buildGhost.position.set(snappedX, groundY, snappedZ);
      buildGhost.rotation.y = buildRotation;

      // Check if placement is valid (in building zone)
      var buildZone = getZoneAtPosition(snappedX, snappedZ);
      var isValid = (buildZone === 'commons' || buildZone === 'studio');

      // Update ghost color (green if valid, red if invalid)
      buildGhost.traverse(function(child) {
        if (child.material && child.material.color) {
          if (isValid) {
            child.material.color.setHex(0x00ff00);
          } else {
            child.material.color.setHex(0xff0000);
          }
        }
      });
    }
  }

  function rotateBuildPreview(delta) {
    buildRotation += delta;
    if (buildGhost) {
      buildGhost.rotation.y = buildRotation;
    }
  }

  function getBuildMode() {
    return buildMode;
  }

  // ========================================================================
  // PERFORMANCE OPTIMIZATIONS
  // ========================================================================

  // Track LOD state for objects
  var lodStates = new Map(); // objectId -> { level: 0/1/2, hiddenChildren: [] }

  // Object pools for particles
  var objectPools = {
    sphere: [],
    cube: [],
    cone: []
  };

  /**
   * Distance-based LOD for trees and structures
   * - distance > 200: hide completely
   * - distance > 100: simplify (hide small decorative pieces)
   * - distance < 100: full detail
   */
  function updateLOD(sceneCtx, playerPos) {
    if (!sceneCtx || !sceneCtx.scene || !playerPos) return;

    var scene = sceneCtx.scene;

    // Process all groups in scene with model_type userData
    scene.traverse(function(obj) {
      if (!obj.userData || !obj.userData.model_type) return;
      if (!(obj instanceof THREE.Group)) return;

      var objId = obj.uuid;
      var dx = obj.position.x - playerPos.x;
      var dz = obj.position.z - playerPos.z;
      var distance = Math.sqrt(dx * dx + dz * dz);

      var currentState = lodStates.get(objId);
      var newLevel = 0;

      if (distance > 200) {
        newLevel = 2; // hidden
      } else if (distance > 100) {
        newLevel = 1; // simplified
      } else {
        newLevel = 0; // full detail
      }

      // Only update if LOD level changed
      if (!currentState || currentState.level !== newLevel) {
        if (newLevel === 2) {
          // Hide completely
          obj.visible = false;
        } else if (newLevel === 1) {
          // Simplify: hide small meshes (low vertex count decorative pieces)
          obj.visible = true;
          var hiddenChildren = [];
          obj.traverse(function(child) {
            if (child instanceof THREE.Mesh && child !== obj) {
              var vertexCount = 0;
              if (child.geometry && child.geometry.attributes && child.geometry.attributes.position) {
                vertexCount = child.geometry.attributes.position.count;
              }
              // Hide meshes with fewer than 50 vertices (decorative details)
              if (vertexCount < 50 && child.visible) {
                child.visible = false;
                hiddenChildren.push(child);
              }
            }
          });
          lodStates.set(objId, { level: 1, hiddenChildren: hiddenChildren });
        } else {
          // Full detail: restore everything
          obj.visible = true;
          if (currentState && currentState.hiddenChildren) {
            for (var i = 0; i < currentState.hiddenChildren.length; i++) {
              currentState.hiddenChildren[i].visible = true;
            }
          }
          lodStates.set(objId, { level: 0, hiddenChildren: [] });
        }
      }
    });
  }

  /**
   * Frustum culling for animated objects and chunks
   * Sets userData.inFrustum flag to skip animation updates for objects outside view
   */
  function updateFrustumCulling(sceneCtx) {
    if (!sceneCtx || !sceneCtx.camera) return;

    var camera = sceneCtx.camera;
    camera.updateMatrixWorld();

    var frustum = new THREE.Frustum();
    var projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);

    // Cull animated objects
    for (var i = 0; i < animatedObjects.length; i++) {
      var obj = animatedObjects[i];
      if (!obj.mesh) continue;
      try {
        var inFrustum = frustum.intersectsObject(obj.mesh);
        obj.mesh.userData.inFrustum = inFrustum;
      } catch (e) {
        obj.mesh.userData.inFrustum = true; // default visible if check fails
      }
    }

    // Cull chunks
    loadedChunks.forEach(function(chunkData, key) {
      if (!chunkData.group) return;
      try {
        var inFrustum = frustum.intersectsObject(chunkData.group);
        chunkData.group.userData.inFrustum = inFrustum;
      } catch (e) {
        chunkData.group.userData.inFrustum = true;
      }
    });
  }

  /**
   * Get object from pool (for particle systems)
   */
  function getFromPool(type) {
    var pool = objectPools[type];
    if (!pool) {
      objectPools[type] = [];
      pool = objectPools[type];
    }

    if (pool.length > 0) {
      var obj = pool.pop();
      obj.visible = true;
      return obj;
    }

    // Create new object if pool is empty
    var geometry, material, mesh;
    switch (type) {
      case 'sphere':
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      case 'cube':
        geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      case 'cone':
        geometry = new THREE.ConeGeometry(0.1, 0.2, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      default:
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
    }
    return mesh;
  }

  /**
   * Return object to pool
   */
  function returnToPool(type, object) {
    if (!object) return;

    var pool = objectPools[type];
    if (!pool) {
      objectPools[type] = [];
      pool = objectPools[type];
    }

    // Reset object state
    object.visible = false;
    object.position.set(0, 0, 0);
    object.rotation.set(0, 0, 0);
    object.scale.set(1, 1, 1);

    // Add to pool if not too large
    if (pool.length < 1000) {
      pool.push(object);
    } else {
      // Dispose if pool is full
      if (object.geometry) object.geometry.dispose();
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            object.material[i].dispose();
          }
        } else {
          object.material.dispose();
        }
      }
    }
  }

  // ========================================================================
  // INTERACTIVE OBJECTS SYSTEM
  // ========================================================================

  var interactiveObjects = [];
  var nextInteractiveId = 1;

  /**
   * Interactive objects definitions per zone
   */
  var INTERACTIVE_OBJECTS = {
    nexus: [
      { type: 'fountain', position: { x: 0, z: 0 }, action: 'water_source', message: 'The fountain sparkles with pure energy. You feel restored.' },
      { type: 'bulletin_board', position: { x: 15, z: 15 }, action: 'read_announcements', message: 'The bulletin board displays community announcements and events.' }
    ],
    gardens: [
      { type: 'garden_bench', position: { x: 200, z: 40 }, action: 'rest', message: 'You sit on the garden bench, surrounded by fragrant flowers. Your mood improves.' },
      { type: 'watering_well', position: { x: 210, z: 25 }, action: 'gather_water', message: 'The well provides fresh water for the gardens.' }
    ],
    athenaeum: [
      { type: 'reading_desk', position: { x: 100, z: -215 }, action: 'study', message: 'You settle in at the reading desk. Knowledge flows more easily here.' },
      { type: 'bookshelf', position: { x: 105, z: -225 }, action: 'access_lore', message: 'The bookshelf contains ancient tomes and scrolls of wisdom.' }
    ],
    wilds: [
      { type: 'campfire', position: { x: -30, z: 265 }, action: 'warmth_cooking', message: 'The campfire crackles warmly. A perfect spot for cooking and gathering.' },
      { type: 'fallen_log', position: { x: -25, z: 255 }, action: 'sit', message: 'You sit on the weathered log, taking in the wild surroundings.' }
    ],
    agora: [
      { type: 'market_stall', position: { x: -185, z: 120 }, action: 'browse_goods', message: 'The market stall displays various wares and goods for trade.' },
      { type: 'town_bell', position: { x: -190, z: 125 }, action: 'ring_bell', message: 'CLANG! The town bell rings out across the agora.' }
    ],
    commons: [
      { type: 'park_bench', position: { x: 170, z: 195 }, action: 'socialize', message: 'A comfortable bench, perfect for meeting with friends.' },
      { type: 'street_lamp', position: { x: 175, z: 185 }, action: 'light', message: 'The street lamp provides warm light in the evening hours.' }
    ],
    arena: [
      { type: 'training_dummy', position: { x: 5, z: -240 }, action: 'practice_combat', message: 'The training dummy stands ready. Time to practice your skills.' },
      { type: 'spectator_bench', position: { x: -5, z: -235 }, action: 'watch_fights', message: 'From here, you have a great view of the arena floor.' }
    ],
    studio: [
      { type: 'easel', position: { x: -200, z: -95 }, action: 'create_art', message: 'The easel stands ready. Your creativity flows here.' },
      { type: 'piano', position: { x: -205, z: -105 }, action: 'play_music', message: 'The piano is perfectly tuned. Music fills the studio.' }
    ]
  };

  /**
   * Create a 3D mesh for an interactive object
   */
  function createInteractiveObject(type, position) {
    var group = new THREE.Group();
    var baseY = getTerrainHeight(position.x, position.z) || 0;

    // Create different objects based on type
    if (type === 'garden_bench' || type === 'park_bench' || type === 'spectator_bench') {
      // Bench seat
      var seatGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
      var benchMat = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
      var seat = new THREE.Mesh(seatGeo, benchMat);
      seat.position.set(0, 0.4, 0);
      seat.castShadow = true;
      group.add(seat);

      // Bench legs
      for (var i = -1; i <= 1; i += 2) {
        for (var j = -1; j <= 1; j += 2) {
          var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8);
          var leg = new THREE.Mesh(legGeo, benchMat);
          leg.position.set(i * 1.0, 0.2, j * 0.3);
          leg.castShadow = true;
          group.add(leg);
        }
      }

      // Backrest
      var backGeo = new THREE.BoxGeometry(2.5, 0.8, 0.15);
      var back = new THREE.Mesh(backGeo, benchMat);
      back.position.set(0, 0.9, -0.4);
      back.castShadow = true;
      group.add(back);

    } else if (type === 'campfire') {
      // Fire pit stones
      var pitGeo = new THREE.CylinderGeometry(0.8, 0.9, 0.3, 12);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var pit = new THREE.Mesh(pitGeo, stoneMat);
      pit.position.set(0, 0.15, 0);
      pit.castShadow = true;
      group.add(pit);

      // Logs arranged in cone
      var logMat = new THREE.MeshPhongMaterial({ color: 0x4a2511 });
      for (var l = 0; l < 4; l++) {
        var angle = (l / 4) * Math.PI * 2;
        var logGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
        var log = new THREE.Mesh(logGeo, logMat);
        log.position.set(Math.cos(angle) * 0.2, 0.5, Math.sin(angle) * 0.2);
        log.rotation.z = Math.PI / 6;
        log.rotation.y = angle;
        log.castShadow = true;
        group.add(log);
      }

      // Fire light
      var fireLight = new THREE.PointLight(0xff6600, 1.5, 10);
      fireLight.position.set(0, 1, 0);
      fireLight.castShadow = false;
      group.add(fireLight);

      // Store light reference for animation
      group.userData.fireLight = fireLight;

    } else if (type === 'fountain') {
      // Fountain base
      var baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.8, 16);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0xc0c0d0 });
      var base = new THREE.Mesh(baseGeo, stoneMat);
      base.position.set(0, 0.4, 0);
      base.castShadow = true;
      group.add(base);

      // Middle tier
      var midGeo = new THREE.CylinderGeometry(1.2, 1.5, 0.5, 16);
      var mid = new THREE.Mesh(midGeo, stoneMat);
      mid.position.set(0, 1.2, 0);
      mid.castShadow = true;
      group.add(mid);

      // Top bowl
      var topGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 16);
      var top = new THREE.Mesh(topGeo, stoneMat);
      top.position.set(0, 1.8, 0);
      top.castShadow = true;
      group.add(top);

      // Water pool
      var waterGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.2, 24);
      var waterMat = new THREE.MeshStandardMaterial({
        color: 0x4488ff,
        emissive: 0x2244aa,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.7
      });
      var water = new THREE.Mesh(waterGeo, waterMat);
      water.position.set(0, 0.8, 0);
      water.castShadow = false;
      group.add(water);

    } else if (type === 'training_dummy') {
      // Base
      var baseGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 12);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var base = new THREE.Mesh(baseGeo, woodMat);
      base.position.set(0, 0.15, 0);
      base.castShadow = true;
      group.add(base);

      // Post
      var postGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
      var post = new THREE.Mesh(postGeo, woodMat);
      post.position.set(0, 1.4, 0);
      post.castShadow = true;
      group.add(post);

      // Body (burlap-wrapped)
      var bodyGeo = new THREE.CylinderGeometry(0.4, 0.45, 1.2, 12);
      var burlapMat = new THREE.MeshPhongMaterial({ color: 0xc4a574 });
      var body = new THREE.Mesh(bodyGeo, burlapMat);
      body.position.set(0, 1.8, 0);
      body.castShadow = true;
      group.add(body);

      // Head
      var headGeo = new THREE.SphereGeometry(0.3, 12, 12);
      var head = new THREE.Mesh(headGeo, burlapMat);
      head.position.set(0, 2.6, 0);
      head.castShadow = true;
      group.add(head);

    } else if (type === 'fallen_log') {
      // Large log lying horizontally
      var logGeo = new THREE.CylinderGeometry(0.4, 0.45, 3, 12);
      var barkMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var log = new THREE.Mesh(logGeo, barkMat);
      log.position.set(0, 0.4, 0);
      log.rotation.z = Math.PI / 2;
      log.castShadow = true;
      group.add(log);

    } else if (type === 'bulletin_board') {
      // Posts
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var p = -1; p <= 1; p += 2) {
        var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
        var post = new THREE.Mesh(postGeo, postMat);
        post.position.set(p * 0.8, 1.25, 0);
        post.castShadow = true;
        group.add(post);
      }

      // Board
      var boardGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
      var boardMat = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
      var board = new THREE.Mesh(boardGeo, boardMat);
      board.position.set(0, 1.5, 0);
      board.castShadow = true;
      group.add(board);

    } else if (type === 'watering_well') {
      // Well base (stone cylinder)
      var wellGeo = new THREE.CylinderGeometry(1, 1.2, 1.5, 16);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var well = new THREE.Mesh(wellGeo, stoneMat);
      well.position.set(0, 0.75, 0);
      well.castShadow = true;
      group.add(well);

      // Well posts
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var w = -1; w <= 1; w += 2) {
        var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
        var post = new THREE.Mesh(postGeo, postMat);
        post.position.set(w * 0.8, 1.75, 0);
        post.castShadow = true;
        group.add(post);
      }

      // Roof
      var roofGeo = new THREE.ConeGeometry(1.2, 0.8, 4);
      var roofMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.set(0, 3.2, 0);
      roof.castShadow = true;
      group.add(roof);

    } else if (type === 'reading_desk') {
      // Desk surface
      var topGeo = new THREE.BoxGeometry(1.5, 0.1, 1);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var top = new THREE.Mesh(topGeo, woodMat);
      top.position.set(0, 0.8, 0);
      top.castShadow = true;
      group.add(top);

      // Legs
      for (var dx = -1; dx <= 1; dx += 2) {
        for (var dz = -1; dz <= 1; dz += 2) {
          var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
          var leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.set(dx * 0.6, 0.4, dz * 0.4);
          leg.castShadow = true;
          group.add(leg);
        }
      }

      // Book on desk
      var bookGeo = new THREE.BoxGeometry(0.3, 0.05, 0.4);
      var bookMat = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
      var book = new THREE.Mesh(bookGeo, bookMat);
      book.position.set(0, 0.88, 0);
      book.rotation.y = Math.PI / 6;
      book.castShadow = true;
      group.add(book);

    } else if (type === 'bookshelf') {
      // Frame
      var frameMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var shelfGeo = new THREE.BoxGeometry(2, 2.5, 0.4);
      var shelf = new THREE.Mesh(shelfGeo, frameMat);
      shelf.position.set(0, 1.25, 0);
      shelf.castShadow = true;
      group.add(shelf);

      // Books
      var bookColors = [0x8b0000, 0x006400, 0x00008b, 0x8b4513, 0x4b0082];
      for (var row = 0; row < 3; row++) {
        for (var col = 0; col < 5; col++) {
          var bookGeo = new THREE.BoxGeometry(0.3, 0.6, 0.15);
          var bookMat = new THREE.MeshPhongMaterial({ color: bookColors[(row + col) % bookColors.length] });
          var book = new THREE.Mesh(bookGeo, bookMat);
          book.position.set(-0.7 + col * 0.35, 0.3 + row * 0.7, 0.1);
          book.castShadow = true;
          group.add(book);
        }
      }

    } else if (type === 'market_stall') {
      // Posts
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var mx = -1; mx <= 1; mx += 2) {
        for (var mz = -1; mz <= 1; mz += 2) {
          var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
          var post = new THREE.Mesh(postGeo, postMat);
          post.position.set(mx * 1, 1.25, mz * 1);
          post.castShadow = true;
          group.add(post);
        }
      }

      // Canopy
      var canopyGeo = new THREE.BoxGeometry(2.5, 0.1, 2.5);
      var canopyMat = new THREE.MeshPhongMaterial({ color: 0xd2691e });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.set(0, 2.5, 0);
      canopy.castShadow = true;
      group.add(canopy);

      // Counter
      var counterGeo = new THREE.BoxGeometry(2, 0.8, 1);
      var counterMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var counter = new THREE.Mesh(counterGeo, counterMat);
      counter.position.set(0, 0.4, 0);
      counter.castShadow = true;
      group.add(counter);

    } else if (type === 'town_bell') {
      // Bell post
      var postGeo = new THREE.CylinderGeometry(0.15, 0.2, 3, 8);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      var post = new THREE.Mesh(postGeo, woodMat);
      post.position.set(0, 1.5, 0);
      post.castShadow = true;
      group.add(post);

      // Cross beam
      var beamGeo = new THREE.BoxGeometry(1.5, 0.15, 0.15);
      var beam = new THREE.Mesh(beamGeo, woodMat);
      beam.position.set(0, 2.8, 0);
      beam.castShadow = true;
      group.add(beam);

      // Bell
      var bellGeo = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      var bellMat = new THREE.MeshPhongMaterial({ color: 0xb8860b });
      var bell = new THREE.Mesh(bellGeo, bellMat);
      bell.position.set(0, 2.5, 0);
      bell.rotation.x = Math.PI;
      bell.castShadow = true;
      group.add(bell);

    } else if (type === 'street_lamp') {
      // Lamp post
      var postGeo = new THREE.CylinderGeometry(0.08, 0.1, 3, 8);
      var metalMat = new THREE.MeshPhongMaterial({ color: 0x2f2f2f });
      var post = new THREE.Mesh(postGeo, metalMat);
      post.position.set(0, 1.5, 0);
      post.castShadow = true;
      group.add(post);

      // Lamp housing
      var housingGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 6);
      var housingMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
      var housing = new THREE.Mesh(housingGeo, housingMat);
      housing.position.set(0, 3.2, 0);
      housing.castShadow = true;
      group.add(housing);

      // Light
      var lampLight = new THREE.PointLight(0xffdd88, 1.0, 12);
      lampLight.position.set(0, 3, 0);
      lampLight.castShadow = false;
      group.add(lampLight);

      group.userData.lampLight = lampLight;

    } else if (type === 'easel') {
      // Easel legs
      var legMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var leg1Geo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 8);
      var leg1 = new THREE.Mesh(leg1Geo, legMat);
      leg1.position.set(0, 0.9, 0.3);
      leg1.rotation.x = -0.2;
      leg1.castShadow = true;
      group.add(leg1);

      var leg2 = new THREE.Mesh(leg1Geo, legMat);
      leg2.position.set(-0.3, 0.9, -0.2);
      leg2.rotation.z = 0.2;
      leg2.rotation.x = 0.2;
      leg2.castShadow = true;
      group.add(leg2);

      var leg3 = new THREE.Mesh(leg1Geo, legMat);
      leg3.position.set(0.3, 0.9, -0.2);
      leg3.rotation.z = -0.2;
      leg3.rotation.x = 0.2;
      leg3.castShadow = true;
      group.add(leg3);

      // Canvas
      var canvasGeo = new THREE.BoxGeometry(1, 1.2, 0.05);
      var canvasMat = new THREE.MeshPhongMaterial({ color: 0xf5f5dc });
      var canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.set(0, 1.4, 0.2);
      canvas.rotation.x = -0.1;
      canvas.castShadow = true;
      group.add(canvas);

    } else if (type === 'piano') {
      // Piano body
      var bodyGeo = new THREE.BoxGeometry(1.5, 0.8, 1);
      var pianoMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
      var body = new THREE.Mesh(bodyGeo, pianoMat);
      body.position.set(0, 0.4, 0);
      body.castShadow = true;
      group.add(body);

      // Keyboard
      var keyboardGeo = new THREE.BoxGeometry(1.3, 0.05, 0.3);
      var keyboardMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
      var keyboard = new THREE.Mesh(keyboardGeo, keyboardMat);
      keyboard.position.set(0, 0.85, 0.4);
      keyboard.castShadow = true;
      group.add(keyboard);

      // Legs
      for (var px = -1; px <= 1; px += 2) {
        for (var pz = -1; pz <= 1; pz += 2) {
          var legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
          var leg = new THREE.Mesh(legGeo, pianoMat);
          leg.position.set(px * 0.6, 0.2, pz * 0.4);
          leg.castShadow = true;
          group.add(leg);
        }
      }
    }

    // Position the group
    group.position.set(position.x, baseY, position.z);

    // Store interactive metadata
    group.userData.isInteractive = true;
    group.userData.interactiveType = type;
    group.userData.originalEmissive = 0x000000;
    group.userData.highlighted = false;

    return group;
  }

  /**
   * Spawn all interactive objects for a specific zone
   */
  function spawnZoneInteractives(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (!INTERACTIVE_OBJECTS[zoneId]) return;

    var zoneObjects = INTERACTIVE_OBJECTS[zoneId];
    for (var i = 0; i < zoneObjects.length; i++) {
      var objDef = zoneObjects[i];
      var mesh = createInteractiveObject(objDef.type, objDef.position);

      if (mesh) {
        sceneCtx.scene.add(mesh);

        // Store interactive object data
        var interactiveData = {
          id: nextInteractiveId++,
          type: objDef.type,
          position: objDef.position,
          action: objDef.action,
          message: objDef.message,
          mesh: mesh,
          zone: zoneId
        };

        interactiveObjects.push(interactiveData);
        mesh.userData.interactiveId = interactiveData.id;
      }
    }
  }

  /**
   * Get the nearest interactive object within range
   */
  function getInteractiveAtPosition(x, z, range) {
    var nearestObj = null;
    var minDist = range;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      var dx = obj.position.x - x;
      var dz = obj.position.z - z;
      var dist = Math.sqrt(dx * dx + dz * dz);

      if (dist < minDist) {
        minDist = dist;
        nearestObj = obj;
      }
    }

    return nearestObj;
  }

  /**
   * Interact with an object by ID
   */
  function interactWithObject(objectId) {
    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (obj.id === objectId) {
        return {
          type: obj.type,
          action: obj.action,
          message: obj.message,
          zone: obj.zone
        };
      }
    }
    return null;
  }

  /**
   * Highlight interactive objects near the player
   */
  function updateInteractiveHighlights(playerX, playerZ, highlightRange) {
    if (!highlightRange) highlightRange = 3;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (!obj.mesh) continue;

      var dx = obj.position.x - playerX;
      var dz = obj.position.z - playerZ;
      var dist = Math.sqrt(dx * dx + dz * dz);

      var shouldHighlight = dist < highlightRange;

      if (shouldHighlight && !obj.mesh.userData.highlighted) {
        // Turn on highlight
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh && child.material) {
            if (child.material.emissive) {
              child.userData.originalEmissive = child.material.emissive.getHex();
              child.material.emissive.setHex(0x444400);
              child.material.emissiveIntensity = 0.3;
            }
          }
        });
        obj.mesh.userData.highlighted = true;
      } else if (!shouldHighlight && obj.mesh.userData.highlighted) {
        // Turn off highlight
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh && child.material) {
            if (child.material.emissive && child.userData.originalEmissive !== undefined) {
              child.material.emissive.setHex(child.userData.originalEmissive);
              child.material.emissiveIntensity = 0;
            }
          }
        });
        obj.mesh.userData.highlighted = false;
      }
    }
  }

  /**
   * Animate interactive objects (fire flicker, etc.)
   */
  function updateInteractiveAnimations(deltaTime) {
    var time = Date.now() * 0.001;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (!obj.mesh) continue;

      // Campfire light flicker
      if (obj.type === 'campfire' && obj.mesh.userData.fireLight) {
        var flicker = Math.sin(time * 5) * 0.3 + Math.sin(time * 13) * 0.2;
        obj.mesh.userData.fireLight.intensity = 1.5 + flicker;
      }

      // Street lamp gentle sway
      if (obj.type === 'street_lamp' && obj.mesh.userData.lampLight) {
        var sway = Math.sin(time * 0.5) * 0.05;
        obj.mesh.userData.lampLight.intensity = 1.0 + sway;
      }
    }
  }

  /**
   * Remove all interactive objects (for cleanup)
   */
  function clearInteractiveObjects(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (obj.mesh) {
        sceneCtx.scene.remove(obj.mesh);

        // Dispose geometries and materials
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                for (var m = 0; m < child.material.length; m++) {
                  child.material[m].dispose();
                }
              } else {
                child.material.dispose();
              }
            }
          }
        });
      }
    }

    interactiveObjects = [];
    nextInteractiveId = 1;
  }

  /**
   * Get all interactive objects for a zone
   */
  function getZoneInteractives(zoneId) {
    var result = [];
    for (var i = 0; i < interactiveObjects.length; i++) {
      if (interactiveObjects[i].zone === zoneId) {
        result.push(interactiveObjects[i]);
      }
    }
    return result;
  }

  /**
   * Hover highlight state for interaction system
   */
  var highlightedObject = null;
  var originalMaterials = new Map();

  /**
   * Highlight a specific object for hover/interaction (golden glow)
   */
  function highlightObject(mesh) {
    if (!mesh) return;
    if (highlightedObject === mesh) return;

    // Unhighlight previous object first
    unhighlightObject();

    highlightedObject = mesh;

    // Store original emissive values and apply golden glow
    mesh.traverse(function(child) {
      if (child.isMesh && child.material) {
        originalMaterials.set(child, {
          emissive: child.material.emissive ? child.material.emissive.clone() : null,
          emissiveIntensity: child.material.emissiveIntensity || 0
        });

        // Apply golden highlight glow
        if (child.material.emissive) {
          child.material.emissive.set(0xDAA520); // Golden color
          child.material.emissiveIntensity = 0.4;
        }
      }
    });
  }

  /**
   * Remove highlight from currently highlighted object
   */
  function unhighlightObject() {
    if (!highlightedObject) return;

    // Restore original materials
    highlightedObject.traverse(function(child) {
      if (child.isMesh && originalMaterials.has(child)) {
        var orig = originalMaterials.get(child);
        if (orig.emissive && child.material.emissive) {
          child.material.emissive.copy(orig.emissive);
        }
        child.material.emissiveIntensity = orig.emissiveIntensity;
      }
    });

    originalMaterials.clear();
    highlightedObject = null;
  }

  // ========================================================================
  // END INTERACTIVE OBJECTS SYSTEM
  // ========================================================================

  /**
   * Get performance statistics
   */
  function getPerformanceStats() {
    var stats = {
      totalObjects: 0,
      visibleObjects: 0,
      activeAnimations: 0,
      loadedChunks: loadedChunks.size,
      estimatedTriangles: 0
    };

    // Count scene objects
    if (sceneContext && sceneContext.scene) {
      sceneContext.scene.traverse(function(obj) {
        stats.totalObjects++;
        if (obj.visible) {
          stats.visibleObjects++;
        }
        // Estimate triangles for meshes
        if (obj instanceof THREE.Mesh && obj.geometry) {
          if (obj.geometry.index) {
            stats.estimatedTriangles += obj.geometry.index.count / 3;
          } else if (obj.geometry.attributes && obj.geometry.attributes.position) {
            stats.estimatedTriangles += obj.geometry.attributes.position.count / 3;
          }
        }
      });
    }

    // Count active animations (objects in frustum)
    for (var i = 0; i < animatedObjects.length; i++) {
      if (animatedObjects[i].mesh && animatedObjects[i].mesh.userData.inFrustum !== false) {
        stats.activeAnimations++;
      }
    }

    stats.estimatedTriangles = Math.floor(stats.estimatedTriangles);

    return stats;
  }

  // ========================================================================
  // ZONE TRANSITION EFFECTS
  // ========================================================================

  var zoneBoundaryParticles = [];
  var fadeOverlay = null;

  /**
   * Screen fade transition effect
   * @param {Function} callback - Function to call when screen is fully faded
   */
  function fadeTransition(callback) {
    if (typeof document === 'undefined') {
      if (callback) callback();
      return;
    }

    // Create overlay if it doesn't exist
    if (!fadeOverlay) {
      fadeOverlay = document.createElement('div');
      fadeOverlay.style.position = 'fixed';
      fadeOverlay.style.top = '0';
      fadeOverlay.style.left = '0';
      fadeOverlay.style.width = '100%';
      fadeOverlay.style.height = '100%';
      fadeOverlay.style.backgroundColor = 'black';
      fadeOverlay.style.opacity = '0';
      fadeOverlay.style.pointerEvents = 'none';
      fadeOverlay.style.zIndex = '9999';
      fadeOverlay.style.transition = 'opacity 0.5s ease-in-out';
      document.body.appendChild(fadeOverlay);
    }

    // Fade to black
    fadeOverlay.style.opacity = '1';

    // Call callback at peak fade
    setTimeout(function() {
      if (callback) callback();

      // Fade back in
      setTimeout(function() {
        fadeOverlay.style.opacity = '0';
      }, 50);
    }, 500);
  }

  /**
   * Create zone boundary particles
   * @param {THREE.Scene} scene - The scene to add particles to
   */
  function createZoneBoundaryParticles(scene) {
    if (!scene) return;

    // Clear existing boundary particles
    for (var i = 0; i < zoneBoundaryParticles.length; i++) {
      scene.remove(zoneBoundaryParticles[i].mesh);
    }
    zoneBoundaryParticles = [];

    // Create particles along zone boundaries
    for (var zId in ZONES) {
      var zone = ZONES[zId];
      var particleCount = Math.floor(zone.radius / 3);

      for (var i = 0; i < particleCount; i++) {
        var angle = (i / particleCount) * Math.PI * 2;
        var radius = zone.radius * 0.95;
        var px = zone.cx + Math.cos(angle) * radius;
        var pz = zone.cz + Math.sin(angle) * radius;
        var py = terrainHeight(px, pz) + 2 + Math.random() * 3;

        var particleGeo = new THREE.SphereGeometry(0.1, 6, 6);
        var particleMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.6,
          transparent: true,
          opacity: 0.4
        });
        var particle = new THREE.Mesh(particleGeo, particleMat);
        particle.position.set(px, py, pz);
        particle.castShadow = false;
        scene.add(particle);

        zoneBoundaryParticles.push({
          mesh: particle,
          baseY: py,
          phase: Math.random() * Math.PI * 2,
          speed: 0.0005 + Math.random() * 0.0003
        });
      }
    }
  }

  /**
   * Update zone boundary particle animations
   * @param {Number} time - World time in milliseconds
   */
  function updateZoneBoundaryParticles(time) {
    for (var i = 0; i < zoneBoundaryParticles.length; i++) {
      var p = zoneBoundaryParticles[i];
      p.mesh.position.y = p.baseY + Math.sin(time * p.speed + p.phase) * 0.5;
      p.mesh.material.opacity = 0.3 + Math.sin(time * p.speed * 2 + p.phase) * 0.15;
    }
  }

  // ========================================================================
  // WILDLIFE AND NATURE EFFECTS SYSTEM
  // ========================================================================

  var wildlifeData = {
    butterflies: [],
    fireflies: [],
    birds: [],
    fishJumpers: [],
    initialized: false
  };

  /**
   * Initialize wildlife systems
   */
  function initWildlife(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var scene = sceneCtx.scene;

    clearWildlife(scene);

    // Butterflies in gardens zone
    var gardensZ = ZONES.gardens;
    var butterflyColors = [0xffff00, 0xffa500, 0x4169e1, 0xffffff, 0xff69b4];

    for (var i = 0; i < 7; i++) {
      var bfGeo = new THREE.BufferGeometry();
      var bfVerts = new Float32Array([0,0,0, 0.3,0,0.2, 0,0,0.4]);
      bfGeo.setAttribute('position', new THREE.BufferAttribute(bfVerts, 3));
      var bfMat = new THREE.MeshBasicMaterial({
        color: butterflyColors[i % butterflyColors.length],
        side: THREE.DoubleSide
      });
      var bf = new THREE.Mesh(bfGeo, bfMat);
      var angle = Math.random() * Math.PI * 2;
      var radius = Math.random() * gardensZ.radius * 0.6;
      bf.position.set(
        gardensZ.cx + Math.cos(angle) * radius,
        gardensZ.baseHeight + 1 + Math.random() * 2,
        gardensZ.cz + Math.sin(angle) * radius
      );
      scene.add(bf);
      wildlifeData.butterflies.push({
        mesh: bf, time: Math.random() * 100,
        speed: 0.5 + Math.random() * 0.5,
        pathAngle: Math.random() * Math.PI * 2,
        pathRadius: 10 + Math.random() * 15,
        baseY: bf.position.y,
        centerX: gardensZ.cx, centerZ: gardensZ.cz
      });
    }

    // Fireflies across multiple zones
    var ffZones = [
      { zone: ZONES.gardens, count: 8 },
      { zone: ZONES.wilds, count: 10 },
      { zone: ZONES.commons, count: 4 },
      { zone: ZONES.nexus, count: 3 }
    ];
    for (var zi = 0; zi < ffZones.length; zi++) {
      var zInfo = ffZones[zi];
      for (var fi = 0; fi < zInfo.count; fi++) {
        var ffGeo = new THREE.SphereGeometry(0.15, 8, 8);
        var ffMat = new THREE.MeshBasicMaterial({
          color: 0xffff99, transparent: true, opacity: 0
        });
        var ff = new THREE.Mesh(ffGeo, ffMat);
        var ffA = Math.random() * Math.PI * 2;
        var ffR = Math.random() * zInfo.zone.radius * 0.7;
        ff.position.set(
          zInfo.zone.cx + Math.cos(ffA) * ffR,
          zInfo.zone.baseHeight + 0.5 + Math.random() * 3,
          zInfo.zone.cz + Math.sin(ffA) * ffR
        );
        scene.add(ff);
        wildlifeData.fireflies.push({
          mesh: ff, time: Math.random() * 100,
          speed: 0.3 + Math.random() * 0.3,
          pulseSpeed: 2 + Math.random() * 2,
          baseY: ff.position.y,
          driftAngle: Math.random() * Math.PI * 2
        });
      }
    }

    // Bird flocks (V-formations orbiting world)
    for (var fli = 0; fli < 3; fli++) {
      var flock = {
        birds: [], centerAngle: (fli / 3) * Math.PI * 2,
        orbitRadius: 200, speed: 0.1 + Math.random() * 0.05,
        height: 40 + Math.random() * 20
      };
      var birdOffsets = [
        {x:0,z:0}, {x:-2,z:-3}, {x:-4,z:-6}, {x:2,z:-3}, {x:4,z:-6}
      ];
      for (var bi = 0; bi < birdOffsets.length; bi++) {
        var bGeo = new THREE.BufferGeometry();
        var bVerts = new Float32Array([0,0,0, -0.4,0,0.3, 0.4,0,0.3]);
        bGeo.setAttribute('position', new THREE.BufferAttribute(bVerts, 3));
        var bMat = new THREE.MeshBasicMaterial({
          color: 0x2c2c2c, side: THREE.DoubleSide
        });
        var bMesh = new THREE.Mesh(bGeo, bMat);
        bMesh.position.y = flock.height;
        scene.add(bMesh);
        flock.birds.push({
          mesh: bMesh, offsetX: birdOffsets[bi].x,
          offsetZ: birdOffsets[bi].z, flapTime: Math.random() * 10
        });
      }
      wildlifeData.birds.push(flock);
    }

    // Fish jumpers near water
    for (var fsi = 0; fsi < 3; fsi++) {
      var fGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var fMat = new THREE.MeshBasicMaterial({
        color: 0x888888, transparent: true, opacity: 0
      });
      var fMesh = new THREE.Mesh(fGeo, fMat);
      scene.add(fMesh);
      wildlifeData.fishJumpers.push({
        mesh: fMesh, jumping: false, jumpTime: 0, jumpDuration: 0,
        startX: 0, startZ: 0, endX: 0, endZ: 0, waterHeight: 0,
        nextJumpDelay: Math.random() * 5 + 3
      });
    }

    wildlifeData.initialized = true;
  }

  /**
   * Update wildlife animations
   */
  function updateWildlife(sceneCtx, deltaTime, worldTime) {
    if (!wildlifeData.initialized || !sceneCtx) return;

    var isNight = worldTime > 1080 || worldTime < 360;
    var isDay = worldTime >= 360 && worldTime <= 1080;

    // Butterflies (daytime, gardens)
    for (var i = 0; i < wildlifeData.butterflies.length; i++) {
      var bf = wildlifeData.butterflies[i];
      bf.time += deltaTime * bf.speed;
      bf.mesh.visible = isDay;
      if (isDay) {
        bf.pathAngle += deltaTime * 0.3;
        var tx = bf.centerX + Math.cos(bf.pathAngle) * bf.pathRadius;
        var tz = bf.centerZ + Math.sin(bf.pathAngle) * bf.pathRadius;
        bf.mesh.position.x += (tx - bf.mesh.position.x) * 0.02;
        bf.mesh.position.z += (tz - bf.mesh.position.z) * 0.02;
        bf.mesh.position.y = bf.baseY + Math.sin(bf.time * 5) * 0.3;
        bf.mesh.rotation.y = Math.sin(bf.time * 8) * 0.3;
        bf.mesh.rotation.z = Math.sin(bf.time * 6) * 0.2;
      }
    }

    // Fireflies (nighttime)
    for (var fi = 0; fi < wildlifeData.fireflies.length; fi++) {
      var ff = wildlifeData.fireflies[fi];
      ff.time += deltaTime;
      if (isNight) {
        var pulse = 0.5 + Math.sin(ff.time * ff.pulseSpeed) * 0.5;
        ff.mesh.material.opacity = pulse * 0.8;
        ff.mesh.visible = true;
        ff.driftAngle += deltaTime * 0.2;
        ff.mesh.position.x += Math.cos(ff.driftAngle) * deltaTime * ff.speed;
        ff.mesh.position.z += Math.sin(ff.driftAngle) * deltaTime * ff.speed;
        ff.mesh.position.y = ff.baseY + Math.sin(ff.time * 0.5) * 0.5;
      } else {
        ff.mesh.material.opacity = 0;
        ff.mesh.visible = false;
      }
    }

    // Bird flocks (daytime)
    for (var fli = 0; fli < wildlifeData.birds.length; fli++) {
      var flock = wildlifeData.birds[fli];
      flock.centerAngle += deltaTime * flock.speed;
      var fcx = Math.cos(flock.centerAngle) * flock.orbitRadius;
      var fcz = 150 + Math.sin(flock.centerAngle) * flock.orbitRadius;
      for (var bi = 0; bi < flock.birds.length; bi++) {
        var bd = flock.birds[bi];
        bd.flapTime += deltaTime * 5;
        bd.mesh.visible = isDay;
        if (isDay) {
          var fa = flock.centerAngle;
          var rox = Math.cos(fa) * bd.offsetX - Math.sin(fa) * bd.offsetZ;
          var roz = Math.sin(fa) * bd.offsetX + Math.cos(fa) * bd.offsetZ;
          bd.mesh.position.set(fcx + rox, flock.height + Math.sin(bd.flapTime) * 0.5, fcz + roz);
          bd.mesh.rotation.y = fa + Math.PI / 2;
          bd.mesh.rotation.z = Math.sin(bd.flapTime * 2) * 0.1;
        }
      }
    }

    // Fish jumpers
    if (waterBodies && waterBodies.length > 0) {
      for (var fsi = 0; fsi < wildlifeData.fishJumpers.length; fsi++) {
        var fish = wildlifeData.fishJumpers[fsi];
        if (fish.jumping) {
          fish.jumpTime += deltaTime;
          var prog = fish.jumpTime / fish.jumpDuration;
          if (prog >= 1) {
            fish.jumping = false;
            fish.mesh.material.opacity = 0;
            fish.mesh.visible = false;
            fish.nextJumpDelay = Math.random() * 8 + 5;
          } else {
            fish.mesh.position.x = fish.startX + (fish.endX - fish.startX) * prog;
            fish.mesh.position.z = fish.startZ + (fish.endZ - fish.startZ) * prog;
            fish.mesh.position.y = fish.waterHeight + Math.sin(prog * Math.PI) * 2;
            fish.mesh.material.opacity = 1;
            fish.mesh.visible = true;
          }
        } else {
          fish.nextJumpDelay -= deltaTime;
          if (fish.nextJumpDelay <= 0) {
            var wb = waterBodies[Math.floor(Math.random() * waterBodies.length)];
            var ja = Math.random() * Math.PI * 2;
            var jr = Math.random() * 10;
            fish.startX = wb.centerX + Math.cos(ja) * jr;
            fish.startZ = wb.centerZ + Math.sin(ja) * jr;
            fish.waterHeight = wb.height;
            var jd = Math.random() * Math.PI * 2;
            var jDist = 1 + Math.random() * 2;
            fish.endX = fish.startX + Math.cos(jd) * jDist;
            fish.endZ = fish.startZ + Math.sin(jd) * jDist;
            fish.jumping = true;
            fish.jumpTime = 0;
            fish.jumpDuration = 0.8 + Math.random() * 0.4;
          }
        }
      }
    }
  }

  /**
   * Clear all wildlife from scene
   */
  function clearWildlife(scene) {
    if (!scene) return;
    var groups = ['butterflies', 'fireflies', 'fishJumpers'];
    for (var g = 0; g < groups.length; g++) {
      var arr = wildlifeData[groups[g]];
      for (var i = 0; i < arr.length; i++) {
        scene.remove(arr[i].mesh);
        if (arr[i].mesh.geometry) arr[i].mesh.geometry.dispose();
        if (arr[i].mesh.material) arr[i].mesh.material.dispose();
      }
    }
    for (var fli = 0; fli < wildlifeData.birds.length; fli++) {
      var flock = wildlifeData.birds[fli];
      for (var bi = 0; bi < flock.birds.length; bi++) {
        scene.remove(flock.birds[bi].mesh);
        if (flock.birds[bi].mesh.geometry) flock.birds[bi].mesh.geometry.dispose();
        if (flock.birds[bi].mesh.material) flock.birds[bi].mesh.material.dispose();
      }
    }
    wildlifeData.butterflies = [];
    wildlifeData.fireflies = [];
    wildlifeData.birds = [];
    wildlifeData.fishJumpers = [];
    wildlifeData.initialized = false;
  }

  // ========================================================================
  // ZONE AMBIENCE â€” Unique atmospheric particles per zone
  // ========================================================================

  var zoneAmbienceData = {
    initialized: false,
    particles: {} // zone name -> { points, velocities, offsets }
  };

  /**
   * Initialize zone ambience particles
   */
  function initZoneAmbience(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var scene = sceneCtx.scene;
    zoneAmbienceData.particles = {};

    // Define particle configs for each zone
    var configs = {
      nexus: {
        count: 40,
        color: 0xffd700, // golden
        size: 0.3,
        rangeX: 50, rangeY: 30, rangeZ: 50,
        velocityY: 0.5, // slow upward drift
        velocityX: 0.1, velocityZ: 0.1
      },
      gardens: {
        count: 50,
        color: 0x90ee90, // light green
        size: 0.25,
        rangeX: 70, rangeY: 25, rangeZ: 70,
        velocityY: 0.2,
        velocityX: 0.3, velocityZ: 0.2 // wind drift
      },
      athenaeum: {
        count: 35,
        color: 0x87ceeb, // sky blue
        size: 0.2,
        rangeX: 50, rangeY: 35, rangeZ: 50,
        velocityY: 0.15,
        velocityX: 0.05, velocityZ: 0.05
      },
      studio: {
        count: 45,
        color: null, // multi-color, set per particle
        size: 0.3,
        rangeX: 50, rangeY: 30, rangeZ: 50,
        velocityY: 0.25,
        velocityX: 0.15, velocityZ: 0.15
      },
      wilds: {
        count: 40,
        color: 0xffffff, // white mist
        size: 0.4,
        rangeX: 80, rangeY: 8, rangeZ: 80, // ground-level
        velocityY: 0.05,
        velocityX: 0.4, velocityZ: 0.1 // horizontal drift
      },
      agora: {
        count: 35,
        color: 0xffa500, // orange lantern glow
        size: 0.25,
        rangeX: 45, rangeY: 30, rangeZ: 45,
        velocityY: 0.3,
        velocityX: 0.1, velocityZ: 0.1
      },
      commons: {
        count: 40,
        color: 0xf5f5f5, // soft white smoke
        size: 0.35,
        rangeX: 45, rangeY: 35, rangeZ: 45,
        velocityY: 0.6, // rising
        velocityX: 0.15, velocityZ: 0.15
      },
      arena: {
        count: 35,
        color: 0xff4500, // red embers
        size: 0.2,
        rangeX: 45, rangeY: 40, rangeZ: 45,
        velocityY: 0.7, // embers rising
        velocityX: 0.2, velocityZ: 0.2
      }
    };

    // Create particle system for each zone
    for (var zoneName in configs) {
      if (!configs.hasOwnProperty(zoneName)) continue;
      var cfg = configs[zoneName];
      var zone = ZONES[zoneName];
      if (!zone) continue;

      var count = cfg.count;
      var positions = new Float32Array(count * 3);
      var colors = new Float32Array(count * 3);
      var sizes = new Float32Array(count);
      var velocities = [];
      var offsets = [];

      // Initialize particle attributes
      for (var i = 0; i < count; i++) {
        var i3 = i * 3;

        // Random position within zone range
        var rx = (Math.random() - 0.5) * cfg.rangeX;
        var ry = Math.random() * cfg.rangeY;
        var rz = (Math.random() - 0.5) * cfg.rangeZ;

        positions[i3] = zone.cx + rx;
        positions[i3 + 1] = zone.baseHeight + ry;
        positions[i3 + 2] = zone.cz + rz;

        // Store offsets for reset
        offsets.push({ x: rx, y: ry, z: rz });

        // Random velocity variation
        var vx = (Math.random() - 0.5) * cfg.velocityX;
        var vy = cfg.velocityY * (0.8 + Math.random() * 0.4);
        var vz = (Math.random() - 0.5) * cfg.velocityZ;
        velocities.push({ x: vx, y: vy, z: vz });

        // Color
        var particleColor;
        if (zoneName === 'studio') {
          // Random colors for studio
          var hue = Math.random();
          var rgb = hslToRgb(hue, 0.7, 0.6);
          colors[i3] = rgb.r;
          colors[i3 + 1] = rgb.g;
          colors[i3 + 2] = rgb.b;
        } else {
          var c = new THREE.Color(cfg.color);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }

        sizes[i] = cfg.size * (0.8 + Math.random() * 0.4);
      }

      // Create geometry and material
      var geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      var material = new THREE.PointsMaterial({
        size: cfg.size,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      var points = new THREE.Points(geometry, material);
      points.visible = false; // Start hidden
      scene.add(points);

      zoneAmbienceData.particles[zoneName] = {
        points: points,
        velocities: velocities,
        offsets: offsets,
        config: cfg,
        zone: zone
      };
    }

    zoneAmbienceData.initialized = true;
  }

  /**
   * Update zone ambience particles
   */
  function updateZoneAmbience(sceneCtx, playerZone, deltaTime) {
    if (!zoneAmbienceData.initialized) return;

    var dt = deltaTime / 1000; // convert to seconds

    for (var zoneName in zoneAmbienceData.particles) {
      if (!zoneAmbienceData.particles.hasOwnProperty(zoneName)) continue;
      var data = zoneAmbienceData.particles[zoneName];

      // Toggle visibility based on player zone
      var isCurrentZone = zoneName === playerZone;
      data.points.visible = isCurrentZone;

      if (!isCurrentZone) continue;

      // Update particle positions
      var positions = data.points.geometry.attributes.position.array;
      var zone = data.zone;
      var cfg = data.config;

      for (var i = 0; i < data.velocities.length; i++) {
        var i3 = i * 3;
        var vel = data.velocities[i];
        var offset = data.offsets[i];

        // Apply velocity
        positions[i3] += vel.x * dt;
        positions[i3 + 1] += vel.y * dt;
        positions[i3 + 2] += vel.z * dt;

        // Wrap particles within zone bounds
        var localX = positions[i3] - zone.cx;
        var localY = positions[i3 + 1] - zone.baseHeight;
        var localZ = positions[i3 + 2] - zone.cz;

        // Reset particles that drift too far
        if (Math.abs(localX) > cfg.rangeX * 0.6 ||
            localY > cfg.rangeY || localY < 0 ||
            Math.abs(localZ) > cfg.rangeZ * 0.6) {
          // Reset to random position
          positions[i3] = zone.cx + (Math.random() - 0.5) * cfg.rangeX;
          positions[i3 + 1] = zone.baseHeight + Math.random() * cfg.rangeY * 0.3;
          positions[i3 + 2] = zone.cz + (Math.random() - 0.5) * cfg.rangeZ;
        }
      }

      data.points.geometry.attributes.position.needsUpdate = true;
    }
  }

  // Helper function for HSL to RGB conversion (for studio particles)
  function hslToRgb(h, s, l) {
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var hue2rgb = function(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return { r: r, g: g, b: b };
  }

  // ========================================================================
  // WORLD MEMORY â€” Footpaths, Gathering Spots, Flowers
  // ========================================================================

  var worldMemory = {};
  var worldMemoryLastStep = 0;
  var MEMORY_GRID_SIZE = 4;
  var MEMORY_MAX_CELLS = 2000;
  var stillTimer = 0;
  var lastPlayerVelocity = 0;
  var lastPlayerPos = null;

  function loadWorldMemory() {
    if (typeof localStorage === 'undefined') return;
    try {
      var stored = localStorage.getItem('zion_worldMemory');
      if (stored) {
        worldMemory = JSON.parse(stored);
        // Apply decay on load
        var keys = Object.keys(worldMemory);
        for (var i = keys.length - 1; i >= 0; i--) {
          var cell = worldMemory[keys[i]];
          cell.steps *= 0.9;
          cell.gathering *= 0.95;
          if (cell.steps < 1 && cell.gathering < 1 && !cell.flowers) {
            delete worldMemory[keys[i]];
          }
        }
      }
    } catch(e) {}
  }

  function saveWorldMemory() {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem('zion_worldMemory', JSON.stringify(worldMemory));
    } catch(e) {}
  }

  function memoryKey(x, z) {
    return Math.floor(x / MEMORY_GRID_SIZE) + '_' + Math.floor(z / MEMORY_GRID_SIZE);
  }

  function recordStep(x, z) {
    var key = memoryKey(x, z);
    if (!worldMemory[key]) {
      worldMemory[key] = { steps: 0, lastStep: 0, gathering: 0, flowers: false };
    }
    worldMemory[key].steps++;
    worldMemory[key].lastStep = Date.now();

    // Cap at max cells
    var keys = Object.keys(worldMemory);
    if (keys.length > MEMORY_MAX_CELLS) {
      keys.sort(function(a, b) { return worldMemory[a].steps - worldMemory[b].steps; });
      var toRemove = keys.length - MEMORY_MAX_CELLS;
      for (var i = 0; i < toRemove; i++) {
        if (!worldMemory[keys[i]].flowers) delete worldMemory[keys[i]];
      }
    }
  }

  function updateWorldMemory(playerPos, nearbyEntities, deltaTime) {
    if (!playerPos) return;
    var now = Date.now();

    // Record step every 500ms
    if (now - worldMemoryLastStep > 500) {
      recordStep(playerPos.x, playerPos.z);
      worldMemoryLastStep = now;
    }

    // Track velocity for stillness
    var velocity = 0;
    if (lastPlayerPos) {
      var dx = playerPos.x - lastPlayerPos.x;
      var dz = playerPos.z - lastPlayerPos.z;
      velocity = Math.sqrt(dx * dx + dz * dz) / Math.max(deltaTime, 0.001);
    }
    lastPlayerPos = { x: playerPos.x, y: playerPos.y, z: playerPos.z };
    lastPlayerVelocity = velocity;

    if (velocity < 0.5) {
      stillTimer += deltaTime;
    } else {
      stillTimer = 0;
    }

    var key = memoryKey(playerPos.x, playerPos.z);
    if (!worldMemory[key]) {
      worldMemory[key] = { steps: 0, lastStep: 0, gathering: 0, flowers: false };
    }

    // Gathering detection: still 10+ seconds near entity
    if (stillTimer >= 10 && nearbyEntities > 0) {
      worldMemory[key].gathering++;
    }

    // Flower growth: still 30+ seconds alone
    if (stillTimer >= 30 && nearbyEntities === 0) {
      worldMemory[key].flowers = true;
    }

    // Periodically save (every 10 seconds)
    if (now % 10000 < 500) {
      saveWorldMemory();
    }
  }

  function getMemoryAtPosition(wx, wz) {
    var key = memoryKey(wx, wz);
    return worldMemory[key] || null;
  }

  // ========================================================================
  // BILLBOARD CLOUDS
  // ========================================================================

  var billboardClouds = [];

  function initBillboardClouds(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var cloudCount = 8 + Math.floor(Math.random() * 5); // 8-12

    for (var i = 0; i < cloudCount; i++) {
      var group = new THREE.Group();
      var puffCount = 4 + Math.floor(Math.random() * 3); // 4-6

      for (var p = 0; p < puffCount; p++) {
        var radius = 3 + Math.random() * 4;
        var puffGeo = new THREE.SphereGeometry(radius, 8, 6);
        var puffMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5 + Math.random() * 0.2,
          fog: false,
          depthWrite: false
        });
        var puff = new THREE.Mesh(puffGeo, puffMat);
        puff.position.set(
          (Math.random() - 0.5) * 8,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 6
        );
        puff.scale.y = 0.5 + Math.random() * 0.3; // flatten
        group.add(puff);
      }

      group.position.set(
        (Math.random() - 0.5) * 500,
        80 + Math.random() * 40,
        (Math.random() - 0.5) * 500
      );
      group.userData.driftSpeed = 0.5 + Math.random() * 1.0;
      group.userData.driftAngle = Math.random() * Math.PI * 2;
      group.visible = false; // hidden until weather needs them

      sceneCtx.scene.add(group);
      billboardClouds.push(group);
    }
  }

  function updateBillboardClouds(deltaTime, weatherType) {
    var showClouds = (weatherType === 'cloudy' || weatherType === 'rain' || weatherType === 'storm');
    for (var i = 0; i < billboardClouds.length; i++) {
      var cloud = billboardClouds[i];
      cloud.visible = showClouds;
      if (!showClouds) continue;

      cloud.position.x += Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      cloud.position.z += Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;

      // Wrap around
      if (cloud.position.x > 300) cloud.position.x = -300;
      if (cloud.position.x < -300) cloud.position.x = 300;
      if (cloud.position.z > 300) cloud.position.z = -300;
      if (cloud.position.z < -300) cloud.position.z = 300;
    }
  }

  // ========================================================================
  // RAIN SPLASH PARTICLES
  // ========================================================================

  var splashPool = [];
  var splashMesh = null;
  var MAX_SPLASHES = 200;

  function initRainSplashes(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var geo = new THREE.BufferGeometry();
    var positions = new Float32Array(MAX_SPLASHES * 3);
    var sizes = new Float32Array(MAX_SPLASHES);

    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    var mat = new THREE.PointsMaterial({
      color: 0xaaddff,
      size: 0.3,
      transparent: true,
      opacity: 0.5,
      depthWrite: false,
      sizeAttenuation: true
    });

    splashMesh = new THREE.Points(geo, mat);
    sceneCtx.scene.add(splashMesh);

    for (var i = 0; i < MAX_SPLASHES; i++) {
      splashPool.push({
        active: false,
        x: 0, y: 0, z: 0,
        vx: 0, vy: 0, vz: 0,
        life: 0, maxLife: 0.3
      });
    }
  }

  function spawnSplash(x, y, z) {
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < splashPool.length; j++) {
        if (!splashPool[j].active) {
          splashPool[j].active = true;
          splashPool[j].x = x;
          splashPool[j].y = y;
          splashPool[j].z = z;
          splashPool[j].vx = (Math.random() - 0.5) * 2;
          splashPool[j].vy = 1 + Math.random() * 2;
          splashPool[j].vz = (Math.random() - 0.5) * 2;
          splashPool[j].life = 0;
          break;
        }
      }
    }
  }

  function updateRainSplashes(deltaTime) {
    if (!splashMesh) return;
    var positions = splashMesh.geometry.attributes.position.array;
    var sizes = splashMesh.geometry.attributes.size.array;

    for (var i = 0; i < splashPool.length; i++) {
      var sp = splashPool[i];
      if (sp.active) {
        sp.life += deltaTime * 0.001;
        sp.x += sp.vx * deltaTime * 0.001;
        sp.y += (sp.vy - 9.8 * sp.life) * deltaTime * 0.001;
        sp.z += sp.vz * deltaTime * 0.001;

        if (sp.life >= sp.maxLife) {
          sp.active = false;
        }

        positions[i * 3] = sp.x;
        positions[i * 3 + 1] = sp.y;
        positions[i * 3 + 2] = sp.z;
        sizes[i] = sp.active ? (0.3 * (1 - sp.life / sp.maxLife)) : 0;
      } else {
        sizes[i] = 0;
      }
    }

    splashMesh.geometry.attributes.position.needsUpdate = true;
    splashMesh.geometry.attributes.size.needsUpdate = true;
  }

  // ========================================================================
  // LIGHTNING BOLT GEOMETRY
  // ========================================================================

  var lightningBoltMesh = null;
  var lightningBoltTimer = 0;

  function createLightningBolt(sceneCtx, startX, startZ) {
    if (!sceneCtx || !sceneCtx.scene) return;
    // Remove old bolt
    if (lightningBoltMesh) {
      sceneCtx.scene.remove(lightningBoltMesh);
      lightningBoltMesh.geometry.dispose();
      lightningBoltMesh.material.dispose();
      lightningBoltMesh = null;
    }

    var segments = 5 + Math.floor(Math.random() * 3);
    var startY = 75 + Math.random() * 15;
    var groundY = terrainHeight(startX, startZ);
    var points = [];

    for (var i = 0; i <= segments; i++) {
      var t = i / segments;
      var y = startY + (groundY - startY) * t;
      var jitterX = (Math.random() - 0.5) * 12 * (1 - t * 0.5);
      var jitterZ = (Math.random() - 0.5) * 12 * (1 - t * 0.5);
      points.push(new THREE.Vector3(startX + jitterX, y, startZ + jitterZ));
    }

    var geo = new THREE.BufferGeometry().setFromPoints(points);
    var mat = new THREE.LineBasicMaterial({
      color: 0xeeeeff,
      linewidth: 2,
      transparent: true,
      opacity: 1.0
    });

    lightningBoltMesh = new THREE.Line(geo, mat);
    sceneCtx.scene.add(lightningBoltMesh);
    lightningBoltTimer = 0.15; // visible for 150ms
  }

  function updateLightningBolt(sceneCtx, deltaTime) {
    if (!lightningBoltMesh) return;
    lightningBoltTimer -= deltaTime * 0.001;
    if (lightningBoltTimer <= 0) {
      if (sceneCtx && sceneCtx.scene) {
        sceneCtx.scene.remove(lightningBoltMesh);
      }
      lightningBoltMesh.geometry.dispose();
      lightningBoltMesh.material.dispose();
      lightningBoltMesh = null;
    } else {
      lightningBoltMesh.material.opacity = lightningBoltTimer / 0.15;
    }
  }

  // ========================================================================
  // SNOW ACCUMULATION
  // ========================================================================

  var snowAccumulating = false;
  var snowAccumTimer = 0;

  function updateSnowAccumulation(deltaTime, weatherType) {
    var isSnow = (weatherType === 'snow');
    snowAccumulating = isSnow;

    snowAccumTimer += deltaTime;
    if (snowAccumTimer < 2000) return; // every 2 seconds
    snowAccumTimer = 0;

    loadedChunks.forEach(function(chunk) {
      if (!chunk.group) return;
      var terrain = chunk.group.children[0]; // first child is terrain mesh
      if (!terrain || !terrain.geometry || !terrain.geometry.attributes.color) return;

      var colors = terrain.geometry.attributes.color.array;

      // Store original colors on first encounter
      if (!terrain.userData.originalColors) {
        terrain.userData.originalColors = new Float32Array(colors);
      }

      var origColors = terrain.userData.originalColors;

      if (isSnow) {
        // Lerp 2% toward white
        for (var i = 0; i < colors.length; i += 3) {
          colors[i] += (0.95 - colors[i]) * 0.02;
          colors[i + 1] += (0.95 - colors[i + 1]) * 0.02;
          colors[i + 2] += (0.98 - colors[i + 2]) * 0.02;
        }
      } else {
        // Lerp 1% back toward original
        for (var j = 0; j < colors.length; j += 3) {
          colors[j] += (origColors[j] - colors[j]) * 0.01;
          colors[j + 1] += (origColors[j + 1] - colors[j + 1]) * 0.01;
          colors[j + 2] += (origColors[j + 2] - colors[j + 2]) * 0.01;
        }
      }

      terrain.geometry.attributes.color.needsUpdate = true;
    });
  }

  // ========================================================================
  // VALLEY FOG
  // ========================================================================

  var fogPlanes = [];

  function initValleyFog(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Sample terrain to find valleys
    var valleySpots = [];
    for (var x = -400; x < 400; x += 80) {
      for (var z = -400; z < 400; z += 80) {
        var h = terrainHeight(x, z);
        if (h < -2) {
          valleySpots.push({ x: x, z: z, h: h });
        }
      }
    }

    // Place up to 8 fog planes
    var count = Math.min(8, valleySpots.length);
    for (var i = 0; i < count; i++) {
      var spot = valleySpots[i];
      var fogGeo = new THREE.PlaneBufferGeometry(40, 40);
      var fogMat = new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        transparent: true,
        opacity: 0.15 + Math.random() * 0.1,
        depthWrite: false,
        side: THREE.DoubleSide,
        fog: false
      });

      var fogMesh = new THREE.Mesh(fogGeo, fogMat);
      fogMesh.rotation.x = -Math.PI / 2;
      fogMesh.position.set(spot.x, spot.h + 2, spot.z);
      fogMesh.userData.baseY = spot.h + 2;
      fogMesh.userData.bobPhase = Math.random() * Math.PI * 2;
      fogMesh.visible = false;

      sceneCtx.scene.add(fogMesh);
      fogPlanes.push(fogMesh);
    }
  }

  function updateValleyFog(worldTime, weatherType) {
    // Show during morning (dawn: 300-420) and rain/storm
    var isDawn = (worldTime >= 240 && worldTime <= 480);
    var isRain = (weatherType === 'rain' || weatherType === 'storm');
    var showFog = isDawn || isRain;
    var time = Date.now() * 0.001;

    for (var i = 0; i < fogPlanes.length; i++) {
      var fp = fogPlanes[i];
      fp.visible = showFog;
      if (!showFog) continue;

      // Gentle vertical bob
      fp.position.y = fp.userData.baseY + Math.sin(time * 0.3 + fp.userData.bobPhase) * 0.5;
    }
  }

  // ========================================================================
  // TERRAIN BREATHING â€” Subtle undulation making the world feel alive
  // ========================================================================

  var terrainBreathTime = 0;

  function updateTerrainBreathing(deltaTime, worldTime) {
    terrainBreathTime += deltaTime;

    // Only update every 3rd frame for performance
    if (Math.floor(terrainBreathTime * 60) % 3 !== 0) return;

    loadedChunks.forEach(function(chunk) {
      if (!chunk.group) return;
      var terrain = chunk.group.children[0];
      if (!terrain || !terrain.geometry || !terrain.geometry.attributes.position) return;

      var positions = terrain.geometry.attributes.position.array;

      // Store base heights on first encounter
      if (!terrain.userData.baseHeights) {
        terrain.userData.baseHeights = new Float32Array(positions.length / 3);
        for (var i = 0; i < positions.length; i += 3) {
          terrain.userData.baseHeights[i / 3] = positions[i + 1]; // Y component
        }
      }

      var baseHeights = terrain.userData.baseHeights;
      var time = terrainBreathTime;
      var wx = terrain.position.x;
      var wz = terrain.position.z;

      for (var j = 0; j < positions.length; j += 3) {
        var localX = positions[j] + wx;
        var localZ = positions[j + 2] + wz;
        var breathOffset = Math.sin(time * 0.3 + localX * 0.02 + localZ * 0.015) * 0.12;
        breathOffset += Math.sin(time * 0.5 + localX * 0.01 - localZ * 0.02) * 0.06;
        positions[j + 1] = baseHeights[j / 3] + breathOffset;
      }

      terrain.geometry.attributes.position.needsUpdate = true;
      terrain.geometry.computeVertexNormals();
    });
  }

  // ========================================================================
  // WIND SYSTEM â€” Synced gusts affecting trees and weather
  // ========================================================================

  var windState = { strength: 1.0, gustTimer: 0, gustTarget: 1.0 };

  function updateWindSystem(deltaTime, weatherType) {
    // Wind strength varies by weather
    var baseWind = 1.0;
    if (weatherType === 'storm') baseWind = 3.0;
    else if (weatherType === 'rain') baseWind = 1.5;
    else if (weatherType === 'cloudy') baseWind = 1.2;
    else if (weatherType === 'snow') baseWind = 0.8;

    // Periodic gusts
    windState.gustTimer += deltaTime;
    if (windState.gustTimer > 3 + Math.random() * 5) {
      windState.gustTarget = baseWind * (0.7 + Math.random() * 0.6);
      windState.gustTimer = 0;
    }

    // Smooth lerp to target
    windState.strength += (windState.gustTarget - windState.strength) * deltaTime * 0.5;
    windState.strength = Math.max(0.3, Math.min(windState.strength, baseWind * 1.3));
  }

  function getWindStrength() {
    return windState.strength;
  }

  // ========================================================================
  // ZONE BOUNDARY SHIMMER ENHANCEMENT
  // ========================================================================

  var zoneBorderParticles = [];

  function initZoneBorderShimmer(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    for (var zId in ZONES) {
      var zone = ZONES[zId];
      if (!zone.radius) continue;

      // Create ring of shimmer particles at zone boundary
      var particleCount = 60;
      var geo = new THREE.BufferGeometry();
      var positions = new Float32Array(particleCount * 3);
      var colors = new Float32Array(particleCount * 3);

      var zoneColor = zone.groundColor || 0x88aa88;
      var cr = ((zoneColor >> 16) & 0xff) / 255;
      var cg = ((zoneColor >> 8) & 0xff) / 255;
      var cb = (zoneColor & 0xff) / 255;

      for (var i = 0; i < particleCount; i++) {
        var angle = (i / particleCount) * Math.PI * 2;
        var r = zone.radius;
        positions[i * 3] = zone.cx + Math.cos(angle) * r;
        positions[i * 3 + 1] = terrainHeight(zone.cx + Math.cos(angle) * r, zone.cz + Math.sin(angle) * r) + 1;
        positions[i * 3 + 2] = zone.cz + Math.sin(angle) * r;

        colors[i * 3] = cr;
        colors[i * 3 + 1] = cg;
        colors[i * 3 + 2] = cb;
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      var mat = new THREE.PointsMaterial({
        size: 0.8,
        transparent: true,
        opacity: 0.3,
        vertexColors: true,
        depthWrite: false,
        sizeAttenuation: true
      });

      var points = new THREE.Points(geo, mat);
      points.userData.zoneId = zId;
      points.userData.basePositions = new Float32Array(positions);
      sceneCtx.scene.add(points);
      zoneBorderParticles.push(points);
    }
  }

  function updateZoneBorderShimmer(worldTime) {
    var time = Date.now() * 0.001;
    for (var i = 0; i < zoneBorderParticles.length; i++) {
      var bp = zoneBorderParticles[i];
      var positions = bp.geometry.attributes.position.array;
      var basePos = bp.userData.basePositions;

      for (var j = 0; j < positions.length; j += 3) {
        // Vertical shimmer
        positions[j + 1] = basePos[j + 1] + Math.sin(time * 2 + j * 0.5) * 0.5;
      }

      bp.geometry.attributes.position.needsUpdate = true;
      // Pulse opacity
      bp.material.opacity = 0.2 + Math.sin(time * 1.5 + i) * 0.15;
    }
  }

  // ========================================================================
  // EXPORTS
  // ========================================================================

  exports.initScene = initScene;
  exports.loadZone = loadZone;
  exports.addPlayer = addPlayer;
  exports.movePlayer = movePlayer;
  exports.removePlayer = removePlayer;
  exports.updatePlayerAnimations = updatePlayerAnimations;
  exports.updateDayNight = updateDayNight;
  exports.updateWeather = updateWeather;
  exports.setWeather = setWeather;
  exports.updateWeatherEffects = updateWeatherEffects;
  exports.getCurrentWeather = getCurrentWeather;
  exports.cullLights = cullLights;
  exports.updateAnimations = updateAnimations;
  exports.updateChunks = updateChunks;
  exports.getZoneAtPosition = getZoneAtPosition;
  exports.getTerrainHeight = getTerrainHeight;
  exports.getZoneCenter = getZoneCenter;
  exports.checkCollision = checkCollision;
  exports.getTexture = getTexture;
  exports.initParticles = initParticles;
  exports.updateParticles = updateParticles;
  exports.emitParticles = emitParticles;
  exports.initWater = initWater;
  exports.updateWater = updateWater;
  exports.initSkybox = initSkybox;
  exports.updateSkybox = updateSkybox;
  exports.initResourceNodes = initResourceNodes;
  exports.updateResourceNodes = updateResourceNodes;
  exports.harvestResource = harvestResource;
  exports.getResourceNodeAtMouse = getResourceNodeAtMouse;
  exports.ZONES = ZONES;
  exports.enterBuildMode = enterBuildMode;
  exports.exitBuildMode = exitBuildMode;
  exports.setBuildType = setBuildType;
  exports.confirmPlacement = confirmPlacement;
  exports.removeLastPlaced = removeLastPlaced;
  exports.updateBuildPreview = updateBuildPreview;
  exports.rotateBuildPreview = rotateBuildPreview;
  exports.getBuildMode = getBuildMode;
  exports.updateLOD = updateLOD;
  exports.updateFrustumCulling = updateFrustumCulling;
  exports.getFromPool = getFromPool;
  exports.returnToPool = returnToPool;
  exports.getPerformanceStats = getPerformanceStats;
  exports.spawnZoneInteractives = spawnZoneInteractives;
  exports.createInteractiveObject = createInteractiveObject;
  exports.getInteractiveAtPosition = getInteractiveAtPosition;
  exports.interactWithObject = interactWithObject;
  exports.updateInteractiveHighlights = updateInteractiveHighlights;
  exports.updateInteractiveAnimations = updateInteractiveAnimations;
  exports.clearInteractiveObjects = clearInteractiveObjects;
  exports.getZoneInteractives = getZoneInteractives;
  exports.highlightObject = highlightObject;
  exports.unhighlightObject = unhighlightObject;
  exports.fadeTransition = fadeTransition;
  exports.createZoneBoundaryParticles = createZoneBoundaryParticles;
  exports.updateZoneBoundaryParticles = updateZoneBoundaryParticles;
  exports.initWildlife = initWildlife;
  exports.updateWildlife = updateWildlife;
  exports.clearWildlife = clearWildlife;
  exports.initZoneAmbience = initZoneAmbience;
  exports.updateZoneAmbience = updateZoneAmbience;
  exports.registerPlayerStar = registerPlayerStar;
  exports.loadWorldMemory = loadWorldMemory;
  exports.saveWorldMemory = saveWorldMemory;
  exports.updateWorldMemory = updateWorldMemory;
  exports.initBillboardClouds = initBillboardClouds;
  exports.updateBillboardClouds = updateBillboardClouds;
  exports.initRainSplashes = initRainSplashes;
  exports.updateSnowAccumulation = updateSnowAccumulation;
  exports.initValleyFog = initValleyFog;
  exports.updateValleyFog = updateValleyFog;
  exports.updateTerrainBreathing = updateTerrainBreathing;
  exports.updateWindSystem = updateWindSystem;
  exports.getWindStrength = getWindStrength;
  exports.initZoneBorderShimmer = initZoneBorderShimmer;
  exports.updateZoneBorderShimmer = updateZoneBorderShimmer;
  exports.weatherCallbacks = weatherCallbacks;

})(typeof module !== 'undefined' ? module.exports : (window.World = {}));


// input.js
(function(exports) {
  // Input handling and protocol message generation
  var callbacks = {};
  var keys = {};
  var chatMode = false;
  var buildMode = false;
  var canvas = null;
  var mouseNDC = { x: 0, y: 0 }; // Normalized device coordinates

  // Camera control variables
  var cameraDistance = 20; // Default camera distance from player
  var cameraOrbitAngle = 0; // Horizontal orbit angle in radians
  var isDraggingCamera = false;
  var lastCameraDragX = 0;
  var lastCameraDragY = 0;

  /**
   * Initialize input handlers
   * @param {object} cbs - Callbacks
   * @param {function} cbs.onMove - Movement callback (delta, position)
   * @param {function} cbs.onAction - Action callback (type, data)
   * @param {function} cbs.onChat - Chat callback (message)
   * @param {function} cbs.onBuild - Build callback (data)
   */
  function initInput(cbs) {
    callbacks = cbs || {};

    if (typeof document === 'undefined') {
      console.warn('Input requires browser environment');
      return;
    }

    // Keyboard handlers
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    // Mouse handlers
    canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.addEventListener('click', handleMouseClick);
      canvas.addEventListener('contextmenu', handleContextMenu);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('wheel', handleMouseWheel, { passive: false });
    }

    // Global mouse up handler for camera drag
    document.addEventListener('mouseup', handleMouseUp);

    // Touch handlers for mobile
    if ('ontouchstart' in window) {
      initTouchControls();
    }

    console.log('Input system initialized');
  }

  /**
   * Handle key down
   */
  function handleKeyDown(e) {
    // Don't process game keys in chat mode (except Escape/Enter)
    if (chatMode && e.key !== 'Escape' && e.key !== 'Enter') {
      return;
    }

    keys[e.key.toLowerCase()] = true;

    // Special keys
    switch (e.key) {
      case 'Enter':
        if (chatMode) {
          chatMode = false;
        } else {
          chatMode = true;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: 'open' });
          }
        }
        e.preventDefault();
        break;

      case 'Escape':
        chatMode = false;
        buildMode = false;
        if (callbacks.onAction) {
          callbacks.onAction('toggleSettings', {});
        }
        e.preventDefault();
        break;

      case 'b':
      case 'B':
        if (!chatMode) {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
          e.preventDefault();
        }
        break;

      case 'e':
      case 'E':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('interact', {});
          }
          e.preventDefault();
        }
        break;

      case 'i':
      case 'I':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleInventory', {});
          }
          e.preventDefault();
        }
        break;

      case 'c':
      case 'C':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleCrafting', {});
          }
          e.preventDefault();
        }
        break;

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '0':
        if (!chatMode) {
          if (buildMode && callbacks.onBuild) {
            // In build mode, number keys select build type
            var typeIndex = (e.key === '0' ? 9 : parseInt(e.key) - 1);
            callbacks.onBuild({ action: 'selectType', typeIndex: typeIndex });
          } else if (callbacks.onAction && parseInt(e.key) >= 1 && parseInt(e.key) <= 5) {
            // Outside build mode, 1-5 are quick slots
            callbacks.onAction('useQuickSlot', { slot: parseInt(e.key) - 1 });
          }
          e.preventDefault();
        }
        break;

      case 'j':
      case 'J':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggle_quest_log', {});
          }
          e.preventDefault();
        }
        break;

      case 't':
      case 'T':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('initiate_trade', {});
          }
          e.preventDefault();
        }
        break;

      case 'f':
      case 'F':
        if (!chatMode) {
          // F key toggles emote menu
          if (callbacks.onAction) {
            callbacks.onAction('toggleEmoteMenu', {});
          }
          e.preventDefault();
        }
        break;

      case 'm':
      case 'M':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleMap', {});
          }
          e.preventDefault();
        }
        break;

      case 'p':
      case 'P':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleProfile', {});
          }
          e.preventDefault();
        }
        break;

      case 'k':
      case 'K':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleSkills', {});
          }
          e.preventDefault();
        }
        break;

      case 'n':
      case 'N':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleCompose', {});
          }
          e.preventDefault();
        }
        break;

      case 'g':
      case 'G':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleGuild', {});
          }
          e.preventDefault();
        }
        break;

      case 'l':
      case 'L':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleLoreJournal', {});
          }
          e.preventDefault();
        }
        break;

      case 'v':
      case 'V':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleDiscoveryLog', {});
          }
          e.preventDefault();
        }
        break;

      case 'h':
      case 'H':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleGovernance', {});
          }
          e.preventDefault();
        }
        break;

      case 'u':
      case 'U':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAuctionHouse', {});
          }
          e.preventDefault();
        }
        break;

      case 'y':
      case 'Y':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAchievements', {});
          }
          e.preventDefault();
        }
        break;

      case 'r':
      case 'R':
        if (!chatMode && buildMode) {
          // R key rotates build preview
          if (callbacks.onBuild) {
            callbacks.onBuild({ action: 'rotate' });
          }
          e.preventDefault();
        }
        break;

      case 'q':
      case 'Q':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('togglePetPanel', {});
          }
          e.preventDefault();
        }
        break;

      case 'x':
      case 'X':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('startFishing', {});
          }
          e.preventDefault();
        }
        break;

      case 'z':
      case 'Z':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleHousing', {});
          }
          e.preventDefault();
        }
        break;

      case 'F2':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('togglePhotoMode', {});
          }
          e.preventDefault();
        }
        break;
    }

    // Emote hotkeys: F+Number
    if (!chatMode && (keys['f'] || keys['F'])) {
      var emoteType = null;
      switch (e.key) {
        case '1': emoteType = 'wave'; break;
        case '2': emoteType = 'dance'; break;
        case '3': emoteType = 'bow'; break;
        case '4': emoteType = 'cheer'; break;
        case '5': emoteType = 'meditate'; break;
        case '6': emoteType = 'point'; break;
      }
      if (emoteType && callbacks.onAction) {
        callbacks.onAction('emote', { type: emoteType });
        e.preventDefault();
      }
    }
  }

  /**
   * Handle key up
   */
  function handleKeyUp(e) {
    keys[e.key.toLowerCase()] = false;
  }

  /**
   * Handle mouse click
   */
  function handleMouseClick(e) {
    if (!canvas) return;

    var rect = canvas.getBoundingClientRect();
    var x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    var y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    // In build mode, click places structure
    if (buildMode && callbacks.onBuild) {
      callbacks.onBuild({ action: 'place', x: x, y: y });
    } else if (callbacks.onAction) {
      callbacks.onAction('click', { x, y, screenX: e.clientX, screenY: e.clientY });
    }
  }

  /**
   * Handle context menu (right-click)
   */
  function handleContextMenu(e) {
    e.preventDefault();

    if (callbacks.onAction) {
      callbacks.onAction('context', { x: e.clientX, y: e.clientY });
    }
  }

  /**
   * Handle mouse move
   */
  function handleMouseMove(e) {
    if (!canvas) return;

    var rect = canvas.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    // Handle camera orbit dragging
    if (isDraggingCamera) {
      var deltaX = e.clientX - lastCameraDragX;
      var deltaY = e.clientY - lastCameraDragY;

      // Adjust orbit angle based on horizontal drag
      cameraOrbitAngle -= deltaX * 0.005;

      lastCameraDragX = e.clientX;
      lastCameraDragY = e.clientY;
    }
  }

  /**
   * Handle mouse down for camera drag
   */
  function handleMouseDown(e) {
    // Right-click or middle-click for camera orbit
    if (e.button === 2 || e.button === 1) {
      isDraggingCamera = true;
      lastCameraDragX = e.clientX;
      lastCameraDragY = e.clientY;
      e.preventDefault();
    }
  }

  /**
   * Handle mouse up
   */
  function handleMouseUp(e) {
    if (e.button === 2 || e.button === 1) {
      isDraggingCamera = false;
    }
  }

  /**
   * Handle mouse wheel for camera zoom
   */
  function handleMouseWheel(e) {
    e.preventDefault();

    // Adjust camera distance with constraints
    cameraDistance += e.deltaY * 0.02;
    cameraDistance = Math.max(5, Math.min(50, cameraDistance));
  }

  /**
   * Get current mouse position in NDC
   */
  function getMouseNDC() {
    return mouseNDC;
  }

  /**
   * Get camera distance (for zoom)
   */
  function getCameraDistance() {
    return cameraDistance;
  }

  /**
   * Get camera orbit angle
   */
  function getCameraOrbit() {
    return cameraOrbitAngle;
  }

  /**
   * Initialize touch controls (virtual joystick and action buttons)
   */
  function initTouchControls() {
    if (typeof document === 'undefined') return;

    // Only show on mobile devices
    var platform = getPlatform();
    if (platform !== 'phone') return;

    // Create improved virtual joystick (left side) - larger and more responsive
    var joystick = document.createElement('div');
    joystick.id = 'virtual-joystick';
    joystick.style.cssText = `
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      border: 3px solid rgba(218,165,32,0.6);
      touch-action: none;
      z-index: 1000;
    `;

    var stick = document.createElement('div');
    stick.style.cssText = `
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(218,165,32,0.8);
      top: 35px;
      left: 35px;
      touch-action: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    joystick.appendChild(stick);
    document.body.appendChild(joystick);

    // Joystick touch handler
    var touchStartPos = { x: 0, y: 0 };
    var isDragging = false;

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      var touch = e.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
    });

    joystick.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      e.preventDefault();

      var touch = e.touches[0];
      var deltaX = touch.clientX - touchStartPos.x;
      var deltaY = touch.clientY - touchStartPos.y;

      // Limit stick movement
      var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      var maxDistance = 35;
      var normalizedDelta = {
        x: deltaX / maxDistance,
        y: deltaY / maxDistance
      };

      if (distance > maxDistance) {
        stick.style.left = (35 + (deltaX / distance) * maxDistance) + 'px';
        stick.style.top = (35 + (deltaY / distance) * maxDistance) + 'px';
      } else {
        stick.style.left = (35 + deltaX) + 'px';
        stick.style.top = (35 + deltaY) + 'px';
      }

      // Send movement
      if (callbacks.onMove) {
        callbacks.onMove({
          x: normalizedDelta.x,
          y: 0,
          z: -normalizedDelta.y // Invert Y for forward/back
        });
      }
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      isDragging = false;
      stick.style.left = '35px';
      stick.style.top = '35px';
    });

    // Create action buttons overlay (bottom-right, circular arc layout)
    var actionButtons = [
      { label: 'E', action: 'interact', size: 50, angle: 0, radius: 0, color: 'rgba(218,165,32,0.7)' },
      { label: 'I', action: 'toggleInventory', size: 45, angle: -45, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'J', action: 'toggle_quest_log', size: 45, angle: -90, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'B', action: 'toggleBuild', size: 45, angle: 45, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'ðŸ’¬', action: 'toggleChat', size: 45, angle: 90, radius: 70, color: 'rgba(218,165,32,0.7)' }
    ];

    var baseX = window.innerWidth - 80;
    var baseY = window.innerHeight - 80;

    actionButtons.forEach(function(btn) {
      var button = document.createElement('button');
      button.textContent = btn.label;

      // Calculate position using angle and radius
      var angleRad = (btn.angle * Math.PI) / 180;
      var x = baseX + btn.radius * Math.cos(angleRad);
      var y = baseY + btn.radius * Math.sin(angleRad);

      button.style.cssText = `
        position: fixed;
        bottom: ${window.innerHeight - y - btn.size/2}px;
        right: ${window.innerWidth - x - btn.size/2}px;
        width: ${btn.size}px;
        height: ${btn.size}px;
        border-radius: 50%;
        background: ${btn.color};
        border: 3px solid rgba(218,165,32,0.9);
        color: white;
        font-size: ${btn.size === 50 ? 20 : 16}px;
        font-weight: bold;
        z-index: 1000;
        touch-action: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        display: flex;
        align-items: center;
        justify-content: center;
      `;

      button.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (btn.action === 'toggleBuild') {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
        } else if (btn.action === 'toggleChat') {
          chatMode = !chatMode;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: chatMode ? 'open' : 'close' });
          }
        } else if (callbacks.onAction) {
          callbacks.onAction(btn.action, {});
        }
      });

      document.body.appendChild(button);
    });

    // Add pinch-to-zoom support
    var lastPinchDistance = 0;

    if (canvas) {
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
    }

    var touchStartTime = 0;
    var touchStartX = 0;
    var touchStartY = 0;
    var wasPinching = false;

    function handleTouchStart(e) {
      if (e.touches.length === 2) {
        // Two-finger pinch for zoom
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
        wasPinching = true;
      } else if (e.touches.length === 1) {
        // Single touch - track for tap detection
        touchStartTime = Date.now();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        wasPinching = false;
      }
    }

    function handleTouchMove(e) {
      if (e.touches.length === 2) {
        // Pinch zoom
        e.preventDefault();
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        var distance = Math.sqrt(dx * dx + dy * dy);

        if (lastPinchDistance > 0) {
          var delta = lastPinchDistance - distance;
          cameraDistance += delta * 0.1;
          cameraDistance = Math.max(5, Math.min(50, cameraDistance));
        }

        lastPinchDistance = distance;
        wasPinching = true;
      }
    }

    function handleTouchEnd(e) {
      if (e.touches.length < 2) {
        lastPinchDistance = 0;
      }

      // Tap-to-interact detection (not pinch, not long drag)
      if (!wasPinching && e.changedTouches.length === 1 && touchStartTime > 0) {
        var touchEndTime = Date.now();
        var touchEndX = e.changedTouches[0].clientX;
        var touchEndY = e.changedTouches[0].clientY;

        var timeDiff = touchEndTime - touchStartTime;
        var dx = touchEndX - touchStartX;
        var dy = touchEndY - touchStartY;
        var distanceMoved = Math.sqrt(dx * dx + dy * dy);

        // Tap if quick (< 300ms) and minimal movement (< 20px)
        if (timeDiff < 300 && distanceMoved < 20) {
          var rect = canvas.getBoundingClientRect();
          var x = ((touchEndX - rect.left) / rect.width) * 2 - 1;
          var y = -((touchEndY - rect.top) / rect.height) * 2 + 1;

          if (callbacks.onAction) {
            callbacks.onAction('click', { x: x, y: y, screenX: touchEndX, screenY: touchEndY });
          }
        }
      }

      wasPinching = false;
    }
  }

  /**
   * Get movement delta from keyboard state
   * @returns {object} - {x, y, z}
   */
  function getMovementDelta() {
    if (chatMode) return { x: 0, y: 0, z: 0 };

    var delta = { x: 0, y: 0, z: 0 };

    // WASD / Arrow keys
    if (keys['w'] || keys['arrowup']) delta.z -= 1;
    if (keys['s'] || keys['arrowdown']) delta.z += 1;
    if (keys['a'] || keys['arrowleft']) delta.x -= 1;
    if (keys['d'] || keys['arrowright']) delta.x += 1;

    // Normalize diagonal movement
    if (delta.x !== 0 && delta.z !== 0) {
      var length = Math.sqrt(delta.x * delta.x + delta.z * delta.z);
      delta.x /= length;
      delta.z /= length;
    }

    return delta;
  }

  /**
   * Detect platform
   * @returns {string} - 'desktop', 'phone', 'vr', 'ar'
   */
  function getPlatform() {
    if (typeof navigator === 'undefined') return 'desktop';

    var ua = navigator.userAgent.toLowerCase();

    // Check WebXR
    if (navigator.xr) {
      // Note: Actual VR/AR detection requires async check, this is just availability
      return 'desktop'; // Default, can be upgraded to VR/AR when session starts
    }

    // Check mobile
    if (/mobile|android|iphone|ipad|tablet/.test(ua)) {
      return 'phone';
    }

    return 'desktop';
  }

  /**
   * Create move protocol message
   * @param {string} from - Player ID
   * @param {object} delta - Movement delta {x, y, z}
   * @param {object} currentPosition - Current position {x, y, z}
   * @param {string} zone - Current zone
   * @returns {object} - Protocol message
   */
  function createMoveMessage(from, delta, currentPosition, zone) {
    var baseSpeed = 0.3; // Units per frame
    var speed = (keys['shift']) ? baseSpeed * 2.0 : baseSpeed; // Sprint with Shift
    var newPosition = {
      x: currentPosition.x + delta.x * speed,
      y: currentPosition.y + delta.y * speed,
      z: currentPosition.z + delta.z * speed
    };

    return {
      type: 'move',
      from: from,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        position: newPosition,
        zone: zone
      }
    };
  }

  // Export public API
  exports.initInput = initInput;
  exports.getMovementDelta = getMovementDelta;
  exports.getPlatform = getPlatform;
  exports.createMoveMessage = createMoveMessage;
  exports.getMouseNDC = getMouseNDC;
  exports.getCameraDistance = getCameraDistance;
  exports.getCameraOrbit = getCameraOrbit;

})(typeof module !== 'undefined' ? module.exports : (window.Input = {}));


// hud.js
(function(exports) {
  // HUD overlay management
  let hudContainer = null;
  let chatPanel = null;
  let playerInfoPanel = null;
  let minimapCanvas = null;
  let minimapCtx = null;
  let zoneLabel = null;
  let nearbyPlayersList = null;
  let chatInput = null;
  let notificationContainer = null;
  let federationPanel = null;

  /**
   * Initialize HUD
   * @param {HTMLElement} container - Parent container for HUD
   */
  function initHUD(container) {
    if (typeof document === 'undefined') {
      console.warn('HUD requires browser environment');
      return;
    }

    hudContainer = container;

    // Create main HUD overlay
    const hudOverlay = document.createElement('div');
    hudOverlay.id = 'zion-hud';
    hudOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      font-family: Arial, sans-serif;
      color: white;
      z-index: 100;
    `;

    // Chat panel (bottom-left)
    chatPanel = document.createElement('div');
    chatPanel.id = 'chat-panel';
    chatPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 350px;
      height: 200px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      pointer-events: auto;
      font-size: 14px;
    `;
    hudOverlay.appendChild(chatPanel);

    // Player info panel (top-left)
    playerInfoPanel = document.createElement('div');
    playerInfoPanel.id = 'player-info';
    playerInfoPanel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      min-width: 200px;
      pointer-events: auto;
    `;
    hudOverlay.appendChild(playerInfoPanel);

    // Zone label (top-center)
    zoneLabel = document.createElement('div');
    zoneLabel.id = 'zone-label';
    zoneLabel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
    `;
    hudOverlay.appendChild(zoneLabel);

    // Minimap (top-right)
    const minimapContainer = document.createElement('div');
    minimapContainer.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      pointer-events: auto;
    `;

    minimapCanvas = document.createElement('canvas');
    minimapCanvas.width = 200;
    minimapCanvas.height = 200;
    minimapCanvas.style.cssText = `
      display: block;
      border-radius: 4px;
    `;
    minimapCtx = minimapCanvas.getContext('2d');
    minimapContainer.appendChild(minimapCanvas);
    hudOverlay.appendChild(minimapContainer);

    // Nearby players list (right side)
    nearbyPlayersList = document.createElement('div');
    nearbyPlayersList.id = 'nearby-players';
    nearbyPlayersList.style.cssText = `
      position: absolute;
      top: 200px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      min-width: 150px;
      max-height: 300px;
      overflow-y: auto;
      pointer-events: auto;
    `;
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';
    hudOverlay.appendChild(nearbyPlayersList);

    // Federation status panel (bottom-right)
    federationPanel = document.createElement('div');
    federationPanel.id = 'federation-panel';
    federationPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      padding: 10px;
      min-width: 200px;
      max-height: 250px;
      overflow-y: auto;
      pointer-events: auto;
      border: 2px solid rgba(100, 100, 255, 0.5);
    `;
    federationPanel.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #88f;">Federation</div>';
    hudOverlay.appendChild(federationPanel);

    // Notification container (top-center, below zone label)
    notificationContainer = document.createElement('div');
    notificationContainer.id = 'notifications';
    notificationContainer.style.cssText = `
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      pointer-events: none;
    `;
    hudOverlay.appendChild(notificationContainer);

    container.appendChild(hudOverlay);

    console.log('HUD initialized');
  }

  /**
   * Update chat panel
   * @param {Array} messages - Array of {user, text, timestamp}
   */
  function updateChat(messages) {
    if (!chatPanel) return;

    chatPanel.innerHTML = '';

    messages.slice(-10).forEach(msg => {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `
        margin-bottom: 5px;
        padding: 3px;
        border-radius: 3px;
      `;

      const time = new Date(msg.timestamp).toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });

      msgEl.innerHTML = `
        <span style="color: #888; font-size: 11px;">${time}</span>
        <span style="color: #4af; font-weight: bold;">${msg.user}:</span>
        <span>${msg.text}</span>
      `;

      chatPanel.appendChild(msgEl);
    });

    // Auto-scroll to bottom
    chatPanel.scrollTop = chatPanel.scrollHeight;
  }

  /**
   * Add a single chat message to the chat panel
   * @param {string} user - Sender name
   * @param {string} text - Message text
   */
  function addChatMessage(user, text) {
    if (!chatPanel || typeof document === 'undefined') return;

    var msgEl = document.createElement('div');
    msgEl.style.cssText = 'margin-bottom:5px;padding:3px;border-radius:3px;';

    var time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    msgEl.innerHTML =
      '<span style="color:#888;font-size:11px;">' + time + '</span> ' +
      '<span style="color:#4af;font-weight:bold;">' + (user || 'Unknown') + ':</span> ' +
      '<span>' + (text || '') + '</span>';

    chatPanel.appendChild(msgEl);
    chatPanel.scrollTop = chatPanel.scrollHeight;

    // Keep last 50 messages max
    while (chatPanel.children.length > 50) {
      chatPanel.removeChild(chatPanel.firstChild);
    }
  }

  /**
   * Update player info panel
   * @param {object} player - {name, spark, zone, warmth}
   */
  function updatePlayerInfo(player) {
    if (!playerInfoPanel) return;

    playerInfoPanel.innerHTML = `
      <div style="font-weight: bold; font-size: 16px; margin-bottom: 8px;">${player.name || 'Unknown'}</div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ffa500;">Spark:</span> ${player.spark || 0}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #4af;">Zone:</span> ${player.zone || 'Unknown'}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ff6347;">Warmth:</span> ${Math.round(player.warmth || 0)}%
      </div>
    `;
  }

  /**
   * Update minimap
   * @param {Array} players - Array of {id, position, isLocal}
   * @param {string} currentZone - Current zone name
   */
  // World zone coordinates for minimap
  var MINIMAP_ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, color: '#6688cc', label: 'Nexus' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, color: '#44aa44', label: 'Gardens' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, color: '#8866aa', label: 'Athenaeum' },
    studio:     { cx: -200, cz: -100, radius: 60, color: '#cc6688', label: 'Studio' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, color: '#228844', label: 'Wilds' },
    agora:      { cx: -190, cz: 120,  radius: 55, color: '#cc8844', label: 'Agora' },
    commons:    { cx: 170,  cz: 190,  radius: 55, color: '#88aa44', label: 'Commons' },
    arena:      { cx: 0,    cz: -240, radius: 55, color: '#cc4444', label: 'Arena' }
  };

  function updateMinimap(players, currentZone) {
    if (!minimapCtx) return;

    var w = minimapCanvas.width;
    var h = minimapCanvas.height;

    // Clear with dark background
    minimapCtx.fillStyle = '#0a0e1a';
    minimapCtx.fillRect(0, 0, w, h);

    // World bounds: roughly -300 to 300 on both axes
    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var margin = 8;

    function worldToMap(wx, wz) {
      return {
        x: margin + ((wx - worldMin) / worldRange) * (w - margin * 2),
        y: margin + ((wz - worldMin) / worldRange) * (h - margin * 2)
      };
    }

    // Draw paths between zones (nexus to each)
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.15)';
    minimapCtx.lineWidth = 1;
    var nexusPos = worldToMap(0, 0);
    for (var zId in MINIMAP_ZONES) {
      if (zId === 'nexus') continue;
      var z = MINIMAP_ZONES[zId];
      var zPos = worldToMap(z.cx, z.cz);
      minimapCtx.beginPath();
      minimapCtx.moveTo(nexusPos.x, nexusPos.y);
      minimapCtx.lineTo(zPos.x, zPos.y);
      minimapCtx.stroke();
    }

    // Draw zone circles
    for (var zoneId in MINIMAP_ZONES) {
      var zone = MINIMAP_ZONES[zoneId];
      var pos = worldToMap(zone.cx, zone.cz);
      var r = (zone.radius / worldRange) * (w - margin * 2);

      // Zone circle fill
      minimapCtx.globalAlpha = zoneId === currentZone ? 0.4 : 0.2;
      minimapCtx.fillStyle = zone.color;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      minimapCtx.fill();

      // Zone circle border
      minimapCtx.globalAlpha = zoneId === currentZone ? 0.9 : 0.4;
      minimapCtx.strokeStyle = zone.color;
      minimapCtx.lineWidth = zoneId === currentZone ? 2 : 1;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      minimapCtx.stroke();

      // Zone label
      minimapCtx.globalAlpha = zoneId === currentZone ? 1.0 : 0.5;
      minimapCtx.fillStyle = '#fff';
      minimapCtx.font = (zoneId === currentZone ? 'bold ' : '') + '8px Arial';
      minimapCtx.textAlign = 'center';
      minimapCtx.fillText(zone.label, pos.x, pos.y + 3);
    }

    minimapCtx.globalAlpha = 1.0;

    // Draw players
    players.forEach(function(player) {
      var pp = worldToMap(player.position.x, player.position.z);

      if (player.isLocal) {
        // Local player â€” larger bright gold dot with white border
        minimapCtx.fillStyle = '#FFD700';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.fill();
        // White border
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.lineWidth = 1.5;
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.stroke();
        // Add subtle glow
        minimapCtx.shadowBlur = 8;
        minimapCtx.shadowColor = '#FFD700';
        minimapCtx.fillStyle = '#FFD700';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.shadowBlur = 0;
      } else {
        // Other players â€” smaller green dots
        minimapCtx.fillStyle = '#44ff44';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 2, 0, Math.PI * 2);
        minimapCtx.fill();
      }
    });

    // Draw border
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    minimapCtx.lineWidth = 1;
    minimapCtx.strokeRect(0, 0, w, h);
  }

  /**
   * Update zone label
   * @param {string} zoneName
   */
  var ZONE_DISPLAY_NAMES = {
    nexus: 'The Nexus',
    gardens: 'The Living Gardens',
    athenaeum: 'The Athenaeum',
    studio: 'The Studio',
    wilds: 'The Wilds',
    agora: 'The Agora',
    commons: 'The Commons',
    arena: 'The Arena'
  };

  function updateZoneLabel(zoneName) {
    if (!zoneLabel) return;
    var display = ZONE_DISPLAY_NAMES[zoneName] || zoneName || 'Unknown Zone';
    zoneLabel.innerHTML = '<div style="font-size:18px;font-weight:bold;">' + display + '</div>';
  }

  /**
   * Update nearby players list
   * @param {Array} players - Array of {id, name, distance}
   */
  function updateNearbyPlayers(players) {
    if (!nearbyPlayersList) return;

    // Keep header, remove old entries
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';

    if (players.length === 0) {
      const emptyMsg = document.createElement('div');
      emptyMsg.style.cssText = 'color: #888; font-size: 12px; font-style: italic;';
      emptyMsg.textContent = 'No players nearby';
      nearbyPlayersList.appendChild(emptyMsg);
      return;
    }

    players.slice(0, 10).forEach(player => {
      const playerEl = document.createElement('div');
      playerEl.style.cssText = `
        padding: 5px;
        margin-bottom: 3px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-size: 13px;
      `;

      const distanceStr = player.distance ? `(${player.distance.toFixed(1)}m)` : '';
      playerEl.innerHTML = `
        <span style="color: #4f4;">${player.name || player.id}</span>
        <span style="color: #888; font-size: 11px; margin-left: 5px;">${distanceStr}</span>
      `;

      nearbyPlayersList.appendChild(playerEl);
    });
  }

  /**
   * Show break reminder
   * @param {number} minutes - Minutes played
   */
  function showBreakReminder(minutes) {
    showNotification(
      `You've been playing for ${minutes} minutes. Consider taking a break!`,
      'info'
    );
  }

  /**
   * Add chat input field
   * @param {function} onSubmit - Callback when message is submitted
   */
  function addChatInput(onSubmit) {
    if (!hudContainer || chatInput) return;
    if (typeof document === 'undefined') return;

    chatInput = document.createElement('input');
    chatInput.type = 'text';
    chatInput.placeholder = 'Press Enter to chat...';
    chatInput.style.cssText = `
      position: absolute;
      bottom: 230px;
      left: 20px;
      width: 330px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #4af;
      border-radius: 4px;
      color: white;
      font-size: 14px;
      pointer-events: auto;
      display: none;
    `;

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const text = chatInput.value.trim();
        if (text && onSubmit) {
          onSubmit(text);
        }
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      } else if (e.key === 'Escape') {
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      }
    });

    document.querySelector('#zion-hud').appendChild(chatInput);
  }

  /**
   * Show chat input (called when chat mode activated)
   */
  function showChatInput() {
    if (chatInput) {
      chatInput.style.display = 'block';
      chatInput.focus();
    }
  }

  /**
   * Hide chat input
   */
  function hideChatInput() {
    if (chatInput) {
      chatInput.style.display = 'none';
      chatInput.value = '';
    }
  }

  /**
   * Show notification
   * @param {string} text - Notification text
   * @param {string} type - 'info', 'success', 'warning', 'error'
   */
  function showNotification(text, type = 'info') {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const colors = {
      info: '#4af',
      success: '#4f4',
      warning: '#fa4',
      error: '#f44'
    };

    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.style.cssText = `
      background: rgba(0, 0, 0, 0.8);
      border-left: 4px solid ${colors[type] || colors.info};
      border-radius: 4px;
      padding: 12px 15px;
      margin-bottom: 10px;
      pointer-events: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    // Add visible class after a frame for animation
    requestAnimationFrame(function() {
      notification.classList.add('visible');
    });

    // Auto-remove after 5 seconds
    setTimeout(function() {
      notification.classList.remove('visible');
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 5000);
  }

  // Add CSS animations
  if (typeof document !== 'undefined') {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateY(0);
          opacity: 1;
        }
        to {
          transform: translateY(-20px);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }

  // ========================================================================
  // ACTION TOOLBAR
  // ========================================================================

  var toolbarEl = null;
  var coordsEl = null;
  var weatherEl = null;
  var timeEl = null;

  function initToolbar() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    // Bottom toolbar with action buttons
    toolbarEl = document.createElement('div');
    toolbarEl.id = 'action-toolbar';
    toolbarEl.style.cssText = 'position:absolute;bottom:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto;';

    var actions = [
      { key: 'E', label: 'Interact', color: '#44aa66' },
      { key: 'B', label: 'Build', color: '#aa6644' },
      { key: 'Enter', label: 'Chat', color: '#4488cc' },
      { key: 'Shift', label: 'Sprint', color: '#cc8844' }
    ];

    actions.forEach(function(action) {
      var btn = document.createElement('div');
      btn.style.cssText = 'background:rgba(0,0,0,0.7);border:1px solid ' + action.color + ';border-radius:6px;padding:6px 12px;text-align:center;font-size:11px;min-width:50px;';
      btn.innerHTML = '<div style="font-weight:bold;color:' + action.color + ';font-size:14px;">' + action.key + '</div><div style="color:#aaa;margin-top:2px;">' + action.label + '</div>';
      toolbarEl.appendChild(btn);
    });
    hud.appendChild(toolbarEl);

    // Coordinates display (bottom-left above chat)
    coordsEl = document.createElement('div');
    coordsEl.id = 'coords-display';
    coordsEl.style.cssText = 'position:absolute;bottom:240px;left:20px;background:rgba(0,0,0,0.5);border-radius:4px;padding:4px 8px;font-size:11px;color:#888;font-family:monospace;pointer-events:none;';
    hud.appendChild(coordsEl);

    // Weather and time display (top-right, below minimap)
    var infoPanel = document.createElement('div');
    infoPanel.style.cssText = 'position:absolute;top:260px;right:20px;background:rgba(0,0,0,0.6);border-radius:8px;padding:10px;min-width:120px;font-size:12px;pointer-events:none;';

    timeEl = document.createElement('div');
    timeEl.style.cssText = 'margin-bottom:4px;';
    infoPanel.appendChild(timeEl);

    weatherEl = document.createElement('div');
    weatherEl.style.cssText = 'color:#aaa;';
    infoPanel.appendChild(weatherEl);

    hud.appendChild(infoPanel);
  }

  function updateCoords(position) {
    if (!coordsEl || !position) return;
    coordsEl.textContent = 'X: ' + Math.round(position.x) + '  Y: ' + Math.round(position.y) + '  Z: ' + Math.round(position.z);
  }

  function updateTimeWeather(worldTime, weather) {
    if (timeEl) {
      var hours = Math.floor(worldTime / 60);
      var mins = Math.floor(worldTime % 60);
      var ampm = hours >= 12 ? 'PM' : 'AM';
      var displayHour = hours % 12 || 12;
      var timeStr = displayHour + ':' + (mins < 10 ? '0' : '') + mins + ' ' + ampm;
      var icon = (hours >= 6 && hours < 18) ? '&#9728;' : '&#9790;'; // sun or moon
      timeEl.innerHTML = icon + ' ' + timeStr;
    }
    if (weatherEl && weather) {
      var weatherIcons = { clear: '&#9728;', cloudy: '&#9729;', rain: '&#127783;', snow: '&#10052;' };
      var icon = weatherIcons[weather] || '';
      weatherEl.innerHTML = icon + ' ' + weather.charAt(0).toUpperCase() + weather.slice(1);
    }
  }

  // ========================================================================
  // NPC INTERACTION DIALOG
  // ========================================================================

  var npcDialogEl = null;
  var npcDialogTimer = null;
  var npcActionCallback = null;
  var npcShopPanel = null;

  // Archetype colors for NPC portraits
  var ARCHETYPE_COLORS_HUD = {
    gardener: '#4CAF50', builder: '#8D6E63', storyteller: '#9C27B0',
    merchant: '#FFD700', explorer: '#00BCD4', teacher: '#2196F3',
    musician: '#FF4081', healer: '#FFFFFF', philosopher: '#3F51B5',
    artist: '#FF9800'
  };

  var ARCHETYPE_ICONS = {
    gardener: '&#127793;', builder: '&#128296;', storyteller: '&#128214;',
    merchant: '&#128176;', explorer: '&#129517;', teacher: '&#127891;',
    musician: '&#127925;', healer: '&#10084;', philosopher: '&#128161;',
    artist: '&#127912;'
  };

  /**
   * Show NPC interaction dialog â€” a proper panel with portrait, mood, activity, dialogue
   * @param {object} npcData - {name, message, archetype, mood, activity, familiarity, id}
   */
  function showNPCDialog(npcData) {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    // Remove existing dialog
    hideNPCDialog();

    var color = ARCHETYPE_COLORS_HUD[npcData.archetype] || '#888';
    var icon = ARCHETYPE_ICONS[npcData.archetype] || '';
    var mood = npcData.mood || 'neutral';
    var activity = npcData.activity || '';
    var familiarity = npcData.familiarity || 0;

    // Familiarity label
    var famLabel = 'Stranger';
    if (familiarity > 70) famLabel = 'Good Friend';
    else if (familiarity > 40) famLabel = 'Acquaintance';
    else if (familiarity > 10) famLabel = 'Familiar';

    // Mood emoji
    var moodEmoji = { content: '&#128522;', excited: '&#128516;', contemplative: '&#129300;',
      social: '&#128075;', tired: '&#128564;', happy: '&#128515;', curious: '&#129488;',
      neutral: '&#128528;', focused: '&#128373;', relaxed: '&#128524;' };
    var moodIcon = moodEmoji[mood] || moodEmoji.neutral;

    npcDialogEl = document.createElement('div');
    npcDialogEl.id = 'npc-dialog';
    npcDialogEl.style.cssText = 'position:absolute;bottom:60px;left:50%;transform:translateX(-50%);' +
      'background:rgba(10,14,26,0.92);border:2px solid ' + color + ';border-radius:12px;' +
      'padding:16px 20px;min-width:380px;max-width:480px;pointer-events:auto;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.6);animation:slideIn 0.3s ease-out;';

    // Header row: portrait + name + archetype
    var header = '<div style="display:flex;align-items:center;margin-bottom:10px;">' +
      '<div style="width:48px;height:48px;border-radius:50%;background:' + color + ';' +
      'display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0;">' + icon + '</div>' +
      '<div style="margin-left:12px;flex:1;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;">' + (npcData.name || 'NPC') + '</div>' +
      '<div style="font-size:11px;color:' + color + ';text-transform:capitalize;">' + (npcData.archetype || '') + '</div>' +
      '</div>' +
      '<div style="text-align:right;font-size:11px;color:#888;">' +
      '<div>' + moodIcon + ' ' + mood + '</div>' +
      '<div style="margin-top:2px;">' + famLabel + '</div>' +
      '</div></div>';

    // Activity bar
    var activityBar = '';
    if (activity) {
      activityBar = '<div style="font-size:11px;color:#aaa;margin-bottom:8px;padding:4px 8px;' +
        'background:rgba(255,255,255,0.05);border-radius:4px;font-style:italic;">' +
        '&#128269; ' + activity + '</div>';
    }

    // Dialogue text
    var dialogue = '<div style="font-size:14px;color:#e0e0e0;line-height:1.5;padding:8px 0;' +
      'border-top:1px solid rgba(255,255,255,0.1);">"' + (npcData.message || '...') + '"</div>';

    // Familiarity bar
    var famBar = '<div style="margin-top:8px;display:flex;align-items:center;gap:8px;">' +
      '<span style="font-size:10px;color:#666;">Familiarity</span>' +
      '<div style="flex:1;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;">' +
      '<div style="width:' + Math.min(familiarity, 100) + '%;height:100%;background:' + color + ';border-radius:2px;"></div>' +
      '</div>' +
      '<span style="font-size:10px;color:#666;">' + familiarity + '%</span></div>';

    // Action buttons row
    var actionBtns = '<div style="display:flex;gap:6px;margin-top:10px;flex-wrap:wrap;">';
    // Trade button (merchants/traders show prominently)
    var isMerchant = npcData.archetype === 'merchant' || npcData.archetype === 'trader' ||
                     npcData.archetype === 'artisan' || npcData.archetype === 'farmer';
    actionBtns += '<button class="npc-action-btn" data-action="trade" style="flex:1;padding:6px 10px;' +
      'background:rgba(218,165,32,0.15);border:1px solid rgba(218,165,32,0.4);border-radius:6px;' +
      'color:#daa520;font-size:11px;cursor:pointer;transition:background 0.2s;"' +
      (isMerchant ? ' data-primary="true"' : '') + '>&#128176; Trade</button>';
    // Learn button (scholars/sages)
    actionBtns += '<button class="npc-action-btn" data-action="learn" style="flex:1;padding:6px 10px;' +
      'background:rgba(100,149,237,0.15);border:1px solid rgba(100,149,237,0.4);border-radius:6px;' +
      'color:#6495ed;font-size:11px;cursor:pointer;transition:background 0.2s;">&#128218; Learn</button>';
    // Lore button
    actionBtns += '<button class="npc-action-btn" data-action="lore" style="flex:1;padding:6px 10px;' +
      'background:rgba(147,112,219,0.15);border:1px solid rgba(147,112,219,0.4);border-radius:6px;' +
      'color:#9370db;font-size:11px;cursor:pointer;transition:background 0.2s;">&#128220; Lore</button>';
    actionBtns += '</div>';

    // Close hint
    var closeHint = '<div style="text-align:center;font-size:10px;color:#555;margin-top:8px;">Click an action or ESC to close</div>';

    npcDialogEl.innerHTML = header + activityBar + dialogue + famBar + actionBtns + closeHint;

    // Wire up action button clicks
    var buttons = npcDialogEl.querySelectorAll('.npc-action-btn');
    buttons.forEach(function(btn) {
      btn.addEventListener('mouseover', function() { btn.style.background = 'rgba(255,255,255,0.15)'; });
      btn.addEventListener('mouseout', function() { btn.style.background = ''; });
      btn.addEventListener('click', function() {
        var action = btn.getAttribute('data-action');
        if (npcActionCallback) {
          npcActionCallback(action, npcData);
        }
      });
    });

    hud.appendChild(npcDialogEl);

    // Auto-hide after 15 seconds (longer since there are actions now)
    npcDialogTimer = setTimeout(function() { hideNPCDialog(); }, 15000);
  }

  /**
   * Hide NPC interaction dialog
   */
  function hideNPCDialog() {
    if (npcDialogTimer) {
      clearTimeout(npcDialogTimer);
      npcDialogTimer = null;
    }
    if (npcDialogEl && npcDialogEl.parentNode) {
      npcDialogEl.parentNode.removeChild(npcDialogEl);
      npcDialogEl = null;
    }
  }

  /**
   * Set callback for NPC dialog action buttons
   * @param {function} callback - function(action, npcData)
   */
  function setNPCActionCallback(callback) {
    npcActionCallback = callback;
  }

  /**
   * Show NPC shop panel
   * @param {object} npcData - NPC info
   * @param {Array} items - [{id, name, price, description, icon}]
   * @param {number} playerSpark - Player's current Spark balance
   * @param {function} onBuy - callback(itemId)
   */
  function showNPCShop(npcData, items, playerSpark, onBuy) {
    if (typeof document === 'undefined') return;
    hideNPCShop();
    hideNPCDialog();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var color = ARCHETYPE_COLORS_HUD[npcData.archetype] || '#888';

    npcShopPanel = document.createElement('div');
    npcShopPanel.id = 'npc-shop-panel';
    npcShopPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid ' + color + ';border-radius:12px;' +
      'padding:20px;min-width:400px;max-width:500px;max-height:70vh;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.7);animation:slideIn 0.3s ease-out;overflow-y:auto;';

    var header = '<div style="display:flex;align-items:center;margin-bottom:14px;padding-bottom:10px;' +
      'border-bottom:1px solid rgba(255,255,255,0.1);">' +
      '<div style="font-size:18px;font-weight:bold;color:#fff;flex:1;">&#128176; ' +
      (npcData.name || 'Shop') + '\'s Wares</div>' +
      '<div style="font-size:13px;color:#daa520;">Your Spark: ' + (playerSpark || 0) + '</div></div>';

    var itemList = '';
    if (!items || items.length === 0) {
      itemList = '<div style="text-align:center;color:#888;padding:20px;">No items for sale right now.</div>';
    } else {
      items.forEach(function(item) {
        var canAfford = playerSpark >= item.price;
        itemList += '<div style="display:flex;align-items:center;padding:10px;margin-bottom:6px;' +
          'background:rgba(255,255,255,0.04);border-radius:8px;border:1px solid rgba(255,255,255,0.08);">' +
          '<div style="font-size:24px;margin-right:12px;">' + (item.icon || '&#128230;') + '</div>' +
          '<div style="flex:1;">' +
          '<div style="font-size:13px;color:#fff;">' + item.name + '</div>' +
          '<div style="font-size:11px;color:#888;">' + (item.description || '') + '</div>' +
          '</div>' +
          '<div style="text-align:right;margin-left:12px;">' +
          '<div style="font-size:12px;color:#daa520;margin-bottom:4px;">' + item.price + ' Spark</div>' +
          '<button class="npc-shop-buy-btn" data-item-id="' + item.id + '" style="padding:4px 12px;' +
          'background:' + (canAfford ? 'rgba(218,165,32,0.2)' : 'rgba(100,100,100,0.2)') + ';' +
          'border:1px solid ' + (canAfford ? 'rgba(218,165,32,0.5)' : 'rgba(100,100,100,0.3)') + ';' +
          'border-radius:4px;color:' + (canAfford ? '#daa520' : '#666') + ';font-size:11px;cursor:' +
          (canAfford ? 'pointer' : 'not-allowed') + ';"' +
          (canAfford ? '' : ' disabled') + '>Buy</button>' +
          '</div></div>';
      });
    }

    var closeBtn = '<div style="text-align:center;margin-top:12px;">' +
      '<button id="npc-shop-close" style="padding:6px 24px;background:rgba(255,255,255,0.08);' +
      'border:1px solid rgba(255,255,255,0.2);border-radius:6px;color:#aaa;font-size:12px;cursor:pointer;">Close Shop</button></div>';

    npcShopPanel.innerHTML = header + itemList + closeBtn;
    npcShopPanel.className = 'npc-shop-panel';
    hud.appendChild(npcShopPanel);
    requestAnimationFrame(function() {
      npcShopPanel.classList.add('visible');
    });

    // Wire buy buttons
    npcShopPanel.querySelectorAll('.npc-shop-buy-btn').forEach(function(btn) {
      if (!btn.disabled) {
        btn.addEventListener('click', function() {
          var itemId = btn.getAttribute('data-item-id');
          if (onBuy) onBuy(itemId);
        });
      }
    });

    // Wire close button
    var closeEl = npcShopPanel.querySelector('#npc-shop-close');
    if (closeEl) {
      closeEl.addEventListener('click', function() { hideNPCShop(); });
    }
  }

  function hideNPCShop() {
    if (npcShopPanel && npcShopPanel.parentNode) {
      npcShopPanel.classList.remove('visible');
      setTimeout(function() {
        if (npcShopPanel && npcShopPanel.parentNode) {
          npcShopPanel.parentNode.removeChild(npcShopPanel);
          npcShopPanel = null;
        }
      }, 250);
    }
  }

  // ========================================================================
  // NPC DOTS ON MINIMAP
  // ========================================================================

  /**
   * Update minimap with NPC positions
   * @param {Array} npcPositions - [{x, z, archetype}]
   * @param {object} playerPos - {x, z} player position for range check
   */
  function updateMinimapNPCs(npcPositions, playerPos) {
    if (!minimapCtx || !npcPositions) return;

    var w = minimapCanvas.width;
    var h = minimapCanvas.height;
    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var margin = 8;

    function worldToMap(wx, wz) {
      return {
        x: margin + ((wx - worldMin) / worldRange) * (w - margin * 2),
        y: margin + ((wz - worldMin) / worldRange) * (h - margin * 2)
      };
    }

    // Draw NPC dots (small, colored by archetype)
    npcPositions.forEach(function(npc) {
      // Only show NPCs within 250 units of player
      if (playerPos) {
        var dx = npc.x - playerPos.x;
        var dz = npc.z - playerPos.z;
        if (Math.sqrt(dx * dx + dz * dz) > 250) return;
      }
      var pos = worldToMap(npc.x, npc.z);
      var color = ARCHETYPE_COLORS_HUD[npc.archetype] || '#888';
      minimapCtx.fillStyle = color;
      minimapCtx.globalAlpha = 0.7;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
      minimapCtx.fill();
    });
    minimapCtx.globalAlpha = 1.0;
  }

  // ========================================================================
  // QUEST SYSTEM UI
  // ========================================================================

  var questTrackerEl = null;
  var questLogEl = null;
  var questOfferEl = null;

  /**
   * Initialize quest tracker (top-right, below minimap)
   */
  function initQuestTracker() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questTrackerEl = document.createElement('div');
    questTrackerEl.id = 'quest-tracker';
    questTrackerEl.style.cssText = 'position:absolute;top:470px;right:20px;background:rgba(10,14,26,0.85);' +
      'border-left:3px solid #d4af37;border-radius:8px;padding:12px;min-width:220px;max-width:300px;' +
      'font-size:12px;pointer-events:auto;max-height:250px;overflow-y:auto;';
    questTrackerEl.innerHTML = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>';
    hud.appendChild(questTrackerEl);
  }

  /**
   * Update quest tracker with active quests
   * @param {Array} activeQuests - Array of active quest objects
   */
  function updateQuestTracker(activeQuests) {
    if (!questTrackerEl) return;

    if (activeQuests.length === 0) {
      questTrackerEl.innerHTML = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>' +
        '<div style="color:#888;font-style:italic;font-size:11px;">No active quests</div>';
      return;
    }

    var html = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>';

    activeQuests.forEach(function(quest) {
      var obj = quest.objectives[0]; // Show first objective
      var required = obj.required || obj.count || 1;
      var progress = obj.current + '/' + required;
      var progressPercent = Math.round((obj.current / required) * 100);
      var statusColor = quest.status === 'complete' ? '#4f4' : '#fff';

      html += '<div style="margin-bottom:10px;padding:6px;background:rgba(0,0,0,0.3);border-radius:4px;">' +
        '<div style="font-weight:bold;color:' + statusColor + ';font-size:11px;margin-bottom:3px;">' + quest.title + '</div>' +
        '<div style="color:#aaa;font-size:10px;margin-bottom:4px;">' + progress + '</div>' +
        '<div style="width:100%;height:4px;background:rgba(255,255,255,0.2);border-radius:2px;overflow:hidden;">' +
        '<div style="width:' + progressPercent + '%;height:100%;background:#d4af37;"></div></div>' +
        '</div>';
    });

    questTrackerEl.innerHTML = html;
  }

  /**
   * Show quest log panel (press J to toggle)
   */
  function showQuestLog(questLog, playerId) {
    if (typeof document === 'undefined') return;
    hideQuestLog(); // Remove existing if any

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questLogEl = document.createElement('div');
    questLogEl.id = 'quest-log-panel';
    questLogEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #d4af37;border-radius:12px;' +
      'padding:20px;width:600px;max-height:70vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:200;';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<div style="font-size:24px;font-weight:bold;color:#d4af37;">Quest Log</div>' +
      '<div style="cursor:pointer;font-size:20px;color:#888;padding:4px 8px;" onclick="window.HUD.hideQuestLog()">âœ•</div></div>';

    // Active quests section
    html += '<div style="margin-bottom:20px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Active Quests (' + questLog.active.length + '/5)</div>';

    if (questLog.active.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No active quests. Speak to NPCs to find new quests!</div>';
    } else {
      questLog.active.forEach(function(quest) {
        var obj = quest.objectives[0];
        var required = obj.required || obj.count || 1;
        var progress = obj.current + '/' + required;
        var statusText = quest.status === 'complete' ? '<span style="color:#4f4;">âœ“ Ready to turn in</span>' : '<span style="color:#fa4;">In Progress</span>';

        html += '<div style="margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:6px;border-left:3px solid #d4af37;">' +
          '<div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">' +
          '<div style="font-weight:bold;color:#fff;font-size:14px;">' + quest.title + '</div>' +
          '<div style="font-size:11px;">' + statusText + '</div></div>' +
          '<div style="color:#aaa;font-size:12px;margin-bottom:6px;">' + quest.description + '</div>' +
          '<div style="color:#888;font-size:11px;">Progress: ' + progress + '</div>' +
          '<div style="margin-top:6px;font-size:11px;color:#d4af37;">Reward: ' + quest.rewards.spark + ' Spark' +
          (quest.rewards.items.length > 0 ? ' + items' : '') + '</div>' +
          '<div style="margin-top:8px;text-align:right;">' +
          '<span style="cursor:pointer;font-size:11px;color:#f44;text-decoration:underline;" onclick="window.HUD.abandonQuestFromLog(\'' + playerId + '\',\'' + quest.id + '\')">Abandon</span>' +
          '</div></div>';
      });
    }
    html += '</div>';

    // Available quests section
    html += '<div style="margin-bottom:20px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Available Quests (' + questLog.available.length + ')</div>';

    if (questLog.available.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No new quests available. Complete prerequisites or explore more zones!</div>';
    } else {
      questLog.available.slice(0, 10).forEach(function(quest) {
        html += '<div style="margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:6px;border-left:3px solid #888;">' +
          '<div style="font-weight:bold;color:#fff;font-size:14px;margin-bottom:6px;">' + quest.title + '</div>' +
          '<div style="color:#aaa;font-size:12px;margin-bottom:6px;">' + quest.description + '</div>' +
          '<div style="font-size:11px;color:#d4af37;">Reward: ' + quest.rewards.spark + ' Spark' +
          (quest.rewards.items.length > 0 ? ' + items' : '') + '</div>' +
          '<div style="margin-top:8px;color:#888;font-size:10px;">Find quest giver to accept</div></div>';
      });
    }
    html += '</div>';

    // Completed quests section
    html += '<div>' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Completed (' + questLog.completed.length + ')</div>';

    if (questLog.completed.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No completed quests yet.</div>';
    } else {
      html += '<div style="color:#4f4;font-size:12px;padding:10px;">You have completed ' + questLog.completed.length + ' quests!</div>';
    }
    html += '</div>';

    html += '<div style="text-align:center;margin-top:16px;font-size:11px;color:#666;">Press J to close</div>';

    questLogEl.innerHTML = html;
    hud.appendChild(questLogEl);
    requestAnimationFrame(function() {
      questLogEl.classList.add('visible');
    });
  }

  /**
   * Hide quest log panel
   */
  function hideQuestLog() {
    if (questLogEl && questLogEl.parentNode) {
      questLogEl.classList.remove('visible');
      setTimeout(function() {
        if (questLogEl && questLogEl.parentNode) {
          questLogEl.parentNode.removeChild(questLogEl);
          questLogEl = null;
        }
      }, 250);
    }
  }

  /**
   * Show quest offer dialog from NPC
   * @param {object} quest - Quest object
   * @param {object} npc - NPC data {name, archetype}
   */
  function showQuestOffer(quest, npc, playerId) {
    if (typeof document === 'undefined') return;
    hideQuestOffer(); // Remove existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questOfferEl = document.createElement('div');
    questOfferEl.id = 'quest-offer-dialog';
    questOfferEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #d4af37;border-radius:12px;' +
      'padding:20px;width:500px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var questDialogue = quest.dialogue && quest.dialogue.offer ? quest.dialogue.offer : quest.description;

    var html = '<div style="font-size:20px;font-weight:bold;color:#d4af37;margin-bottom:12px;">New Quest</div>' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:8px;">' + quest.title + '</div>' +
      '<div style="color:#aaa;font-size:13px;margin-bottom:12px;font-style:italic;">"' + questDialogue + '"</div>' +
      '<div style="color:#ccc;font-size:12px;margin-bottom:8px;">' + quest.description + '</div>' +
      '<div style="padding:10px;background:rgba(0,0,0,0.3);border-radius:6px;margin-bottom:16px;">' +
      '<div style="font-size:12px;color:#d4af37;margin-bottom:4px;">Rewards:</div>' +
      '<div style="font-size:13px;color:#fff;">â€¢ ' + quest.rewards.spark + ' Spark</div>';

    if (quest.rewards.items.length > 0) {
      quest.rewards.items.forEach(function(item) {
        html += '<div style="font-size:13px;color:#fff;">â€¢ ' + item.count + 'x ' + item.id + '</div>';
      });
    }

    html += '</div>' +
      '<div style="display:flex;gap:12px;justify-content:center;">' +
      '<button onclick="window.HUD.acceptQuestFromOffer(\'' + playerId + '\',\'' + quest.id + '\')" style="' +
      'padding:10px 24px;background:#d4af37;color:#000;border:none;border-radius:6px;' +
      'font-weight:bold;font-size:14px;cursor:pointer;">Accept Quest</button>' +
      '<button onclick="window.HUD.hideQuestOffer()" style="' +
      'padding:10px 24px;background:rgba(255,255,255,0.1);color:#fff;border:1px solid #666;border-radius:6px;' +
      'font-size:14px;cursor:pointer;">Decline</button></div>';

    questOfferEl.innerHTML = html;
    hud.appendChild(questOfferEl);
  }

  /**
   * Hide quest offer dialog
   */
  function hideQuestOffer() {
    if (questOfferEl && questOfferEl.parentNode) {
      questOfferEl.parentNode.removeChild(questOfferEl);
      questOfferEl = null;
    }
  }

  /**
   * Show quest complete notification
   * @param {object} quest - Completed quest
   * @param {object} rewards - Rewards {spark, items}
   */
  function showQuestComplete(quest, rewards) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.style.cssText = 'background:linear-gradient(135deg,rgba(212,175,55,0.9),rgba(255,215,0,0.9));' +
      'border-left:4px solid #d4af37;border-radius:8px;padding:16px 20px;margin-bottom:10px;' +
      'animation:slideIn 0.3s ease-out;pointer-events:auto;box-shadow:0 4px 12px rgba(212,175,55,0.4);';

    var html = '<div style="font-size:18px;font-weight:bold;color:#000;margin-bottom:6px;">Quest Complete!</div>' +
      '<div style="font-size:14px;color:#111;margin-bottom:8px;">' + quest.title + '</div>' +
      '<div style="font-size:12px;color:#222;">+ ' + rewards.spark + ' Spark';

    if (rewards.items && rewards.items.length > 0) {
      html += ' + ' + rewards.items.length + ' item(s)';
    }

    html += '</div>';
    notification.innerHTML = html;

    notificationContainer.appendChild(notification);

    // Auto-remove after 6 seconds
    setTimeout(function() {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 6000);
  }

  /**
   * Show quest objective progress update
   * @param {string} text - Progress text (e.g., "+1/3 Sunflowers")
   */
  function showQuestProgress(text) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.style.cssText = 'background:rgba(212,175,55,0.3);border-left:3px solid #d4af37;' +
      'border-radius:6px;padding:8px 12px;margin-bottom:8px;animation:slideIn 0.3s ease-out;' +
      'pointer-events:auto;font-size:13px;color:#d4af37;font-weight:bold;';
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    // Auto-remove after 3 seconds
    setTimeout(function() {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 3000);
  }

  /**
   * Accept quest from offer dialog (called by inline onclick)
   */
  function acceptQuestFromOffer(playerId, questId) {
    if (window.Quests) {
      var result = window.Quests.acceptQuest(playerId, questId);
      if (result.success) {
        showNotification('Quest accepted: ' + result.quest.title, 'success');
        hideQuestOffer();
      } else {
        showNotification('Cannot accept quest: ' + result.message, 'error');
      }
    }
  }

  /**
   * Abandon quest from log (called by inline onclick)
   */
  function abandonQuestFromLog(playerId, questId) {
    if (window.Quests) {
      var result = window.Quests.abandonQuest(playerId, questId);
      if (result.success) {
        showNotification('Quest abandoned', 'info');
        hideQuestLog();
      }
    }
  }

  // ========================================================================
  // INVENTORY PANEL
  // ========================================================================

  var inventoryPanel = null;
  var inventoryVisible = false;

  function initInventoryPanel() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    inventoryPanel = document.createElement('div');
    inventoryPanel.id = 'inventory-panel';
    inventoryPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #4af;border-radius:12px;' +
      'padding:20px;min-width:500px;pointer-events:auto;display:none;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.8);z-index:200;';

    var header = '<div style="font-size:20px;font-weight:bold;margin-bottom:15px;text-align:center;color:#4af;">Inventory</div>';
    var slotsGrid = '<div id="inventory-slots" style="display:grid;grid-template-columns:repeat(5,90px);gap:8px;margin-bottom:15px;"></div>';
    var closeBtn = '<div style="text-align:center;"><button id="close-inventory" style="padding:8px 20px;background:#4af;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Close (I)</button></div>';

    inventoryPanel.innerHTML = header + slotsGrid + closeBtn;
    hud.appendChild(inventoryPanel);

    document.getElementById('close-inventory').addEventListener('click', function() {
      hideInventoryPanel();
    });
  }

  function toggleInventoryPanel() {
    if (inventoryVisible) {
      hideInventoryPanel();
    } else {
      showInventoryPanel();
    }
  }

  function showInventoryPanel() {
    if (!inventoryPanel) initInventoryPanel();
    inventoryPanel.style.display = 'block';
    requestAnimationFrame(function() {
      inventoryPanel.classList.add('visible');
    });
    inventoryVisible = true;
  }

  function hideInventoryPanel() {
    if (inventoryPanel) {
      inventoryPanel.classList.remove('visible');
      setTimeout(function() {
        inventoryPanel.style.display = 'none';
      }, 250);
    }
    inventoryVisible = false;
  }

  function updateInventoryDisplay(inventory) {
    if (!inventoryPanel || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var slotsDiv = document.getElementById('inventory-slots');
    if (!slotsDiv) return;

    var items = Inventory.getInventory(inventory);
    slotsDiv.innerHTML = '';

    items.forEach(function(item, idx) {
      var slot = document.createElement('div');
      slot.style.cssText = 'background:rgba(255,255,255,0.1);border:2px solid #555;border-radius:6px;' +
        'padding:10px;text-align:center;min-height:70px;position:relative;cursor:pointer;';

      if (item) {
        var rarityColors = { common: '#aaa', uncommon: '#4af', rare: '#f4a', legendary: '#fa4' };
        var borderColor = rarityColors[item.rarity] || '#555';
        slot.style.borderColor = borderColor;

        slot.innerHTML = '<div style="font-size:32px;margin-bottom:4px;">' + item.icon + '</div>' +
          '<div style="font-size:11px;color:#ccc;">' + item.name + '</div>' +
          '<div style="position:absolute;top:4px;right:6px;background:#000;padding:2px 6px;border-radius:3px;font-size:11px;font-weight:bold;">' + item.count + '</div>';

        slot.title = item.description + '\\n' + item.rarity.toUpperCase();
      } else {
        slot.innerHTML = '<div style="color:#444;padding-top:20px;">Empty</div>';
      }

      slotsDiv.appendChild(slot);
    });
  }

  // ========================================================================
  // CRAFTING PANEL
  // ========================================================================

  var craftingPanel = null;
  var craftingVisible = false;
  var onCraftCallback = null;

  function initCraftingPanel(onCraft) {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    onCraftCallback = onCraft;

    craftingPanel = document.createElement('div');
    craftingPanel.id = 'crafting-panel';
    craftingPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #fa4;border-radius:12px;' +
      'padding:20px;min-width:600px;max-height:70vh;overflow-y:auto;pointer-events:auto;display:none;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.8);z-index:200;';

    var header = '<div style="font-size:20px;font-weight:bold;margin-bottom:15px;text-align:center;color:#fa4;">Crafting</div>';
    var recipeList = '<div id="recipe-list"></div>';
    var closeBtn = '<div style="text-align:center;margin-top:15px;"><button id="close-crafting" style="padding:8px 20px;background:#fa4;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Close (C)</button></div>';

    craftingPanel.innerHTML = header + recipeList + closeBtn;
    hud.appendChild(craftingPanel);

    document.getElementById('close-crafting').addEventListener('click', function() {
      hideCraftingPanel();
    });
  }

  function toggleCraftingPanel() {
    if (craftingVisible) {
      hideCraftingPanel();
    } else {
      showCraftingPanel();
    }
  }

  function showCraftingPanel() {
    if (!craftingPanel) initCraftingPanel();
    craftingPanel.style.display = 'block';
    requestAnimationFrame(function() {
      craftingPanel.classList.add('visible');
    });
    craftingVisible = true;
  }

  function hideCraftingPanel() {
    if (craftingPanel) {
      craftingPanel.classList.remove('visible');
      setTimeout(function() {
        craftingPanel.style.display = 'none';
      }, 250);
    }
    craftingVisible = false;
  }

  function updateCraftingDisplay(inventory) {
    if (!craftingPanel || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var listDiv = document.getElementById('recipe-list');
    if (!listDiv) return;

    var allRecipes = Inventory.getAllRecipes();
    listDiv.innerHTML = '';

    allRecipes.forEach(function(recipe) {
      var canCraft = Inventory.canCraft(inventory, recipe);
      var outputItem = Inventory.getItemData(recipe.output.itemId);

      var recipeDiv = document.createElement('div');
      recipeDiv.style.cssText = 'background:rgba(255,255,255,0.05);border:1px solid ' + (canCraft ? '#4f4' : '#555') + ';' +
        'border-radius:6px;padding:12px;margin-bottom:10px;';

      var title = '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:' + (canCraft ? '#4f4' : '#888') + ';">' +
        (outputItem ? outputItem.icon + ' ' : '') + recipe.name + '</div>';

      var reqs = '<div style="font-size:12px;color:#aaa;margin-bottom:8px;">Requires: ';
      recipe.requirements.forEach(function(req, i) {
        var reqItem = Inventory.getItemData(req.itemId);
        var hasCount = Inventory.getItemCount(inventory, req.itemId);
        var hasEnough = hasCount >= req.count;
        reqs += (i > 0 ? ', ' : '') + '<span style="color:' + (hasEnough ? '#4f4' : '#f44') + ';">' +
          (reqItem ? reqItem.icon + ' ' : '') + req.count + ' ' + (reqItem ? reqItem.name : req.itemId) + '</span>';
      });
      reqs += '</div>';

      var reward = '<div style="font-size:11px;color:#ffa500;margin-bottom:8px;">Spark Reward: ' + recipe.sparkReward + '</div>';

      var craftBtn = '';
      if (canCraft) {
        craftBtn = '<button class="craft-btn" data-recipe="' + recipe.id + '" style="padding:6px 15px;background:#4f4;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Craft</button>';
      } else {
        craftBtn = '<button disabled style="padding:6px 15px;background:#333;border:none;border-radius:4px;color:#666;cursor:not-allowed;">Cannot Craft</button>';
      }

      recipeDiv.innerHTML = title + reqs + reward + craftBtn;
      listDiv.appendChild(recipeDiv);
    });

    var craftBtns = document.querySelectorAll('.craft-btn');
    craftBtns.forEach(function(btn) {
      btn.addEventListener('click', function() {
        var recipeId = this.getAttribute('data-recipe');
        if (onCraftCallback) {
          onCraftCallback(recipeId);
        }
      });
    });
  }

  // ========================================================================
  // QUICK BAR
  // ========================================================================

  var quickBarEl = null;

  function initQuickBar() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    quickBarEl = document.createElement('div');
    quickBarEl.id = 'quick-bar';
    quickBarEl.style.cssText = 'position:absolute;bottom:70px;left:50%;transform:translateX(-50%);' +
      'display:flex;gap:8px;pointer-events:none;';

    for (var i = 0; i < 5; i++) {
      var slot = document.createElement('div');
      slot.className = 'quick-slot';
      slot.style.cssText = 'background:rgba(0,0,0,0.7);border:2px solid #555;border-radius:6px;' +
        'padding:8px;width:60px;height:60px;text-align:center;position:relative;';

      var keyLabel = '<div style="position:absolute;top:2px;left:4px;font-size:10px;color:#888;">' + (i + 1) + '</div>';
      slot.innerHTML = keyLabel + '<div class="quick-content" style="font-size:28px;margin-top:8px;">-</div>';

      quickBarEl.appendChild(slot);
    }

    hud.appendChild(quickBarEl);
  }

  function updateQuickBar(inventory) {
    if (!quickBarEl || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var items = Inventory.getInventory(inventory);
    var quickSlots = quickBarEl.querySelectorAll('.quick-slot');

    inventory.quickBar.forEach(function(slotIdx, qbIdx) {
      if (qbIdx >= quickSlots.length) return;

      var item = items[slotIdx];
      var contentDiv = quickSlots[qbIdx].querySelector('.quick-content');

      if (item) {
        contentDiv.innerHTML = item.icon;
        quickSlots[qbIdx].title = item.name + ' (' + item.count + ')';
      } else {
        contentDiv.innerHTML = '-';
        quickSlots[qbIdx].title = 'Empty';
      }
    });
  }

  // ========================================================================
  // ITEM PICKUP NOTIFICATION
  // ========================================================================

  function showItemPickup(itemName, count, icon) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var pickup = document.createElement('div');
    pickup.style.cssText = 'background:rgba(0,200,0,0.8);border-left:4px solid #0f0;border-radius:4px;' +
      'padding:10px 15px;margin-bottom:10px;animation:slideIn 0.3s ease-out;' +
      'pointer-events:auto;box-shadow:0 2px 8px rgba(0,0,0,0.3);font-size:14px;';

    pickup.innerHTML = '<span style="font-size:20px;margin-right:8px;">' + (icon || '+') + '</span>' +
      '<span style="font-weight:bold;">+' + count + ' ' + itemName + '</span>';

    notificationContainer.appendChild(pickup);

    setTimeout(function() {
      pickup.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        pickup.remove();
      }, 300);
    }, 2000);
  }

  // ========================================================================
  // WORLD MAP OVERLAY
  // ========================================================================

  var worldMapOverlay = null;
  var worldMapCanvas = null;
  var worldMapCtx = null;
  var worldMapVisible = false;

  var WORLD_MAP_ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, color: '#8888cc', name: 'Nexus', desc: 'The heart of Zion. A safe meeting place for all.' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, color: '#4caf50', name: 'Gardens', desc: 'Fertile grounds for planting, growing, and harvesting.' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, color: '#795548', name: 'Athenaeum', desc: 'A library of knowledge and arcane study.' },
    studio:     { cx: -200, cz: -100, radius: 60, color: '#ff9800', name: 'Studio', desc: 'Creative workshops for art, music, and crafting.' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, color: '#2e7d32', name: 'Wilds', desc: 'Untamed wilderness full of discoveries.' },
    agora:      { cx: -190, cz: 120,  radius: 55, color: '#ffd700', name: 'Agora', desc: 'The marketplace. Trade goods and Spark.' },
    commons:    { cx: 170,  cz: 190,  radius: 55, color: '#faf0e6', name: 'Commons', desc: 'Community space for building and gathering.' },
    arena:      { cx: 0,    cz: -240, radius: 55, color: '#d2691e', name: 'Arena', desc: 'Honorable competition between consenting players.' }
  };

  var ZONE_CONNECTIONS = [
    ['nexus', 'gardens'],
    ['nexus', 'athenaeum'],
    ['nexus', 'studio'],
    ['nexus', 'wilds'],
    ['nexus', 'agora'],
    ['nexus', 'commons'],
    ['nexus', 'arena'],
    ['gardens', 'commons'],
    ['wilds', 'agora'],
    ['athenaeum', 'arena']
  ];

  function showWorldMap(playerPos, npcs, landmarks) {
    if (typeof document === 'undefined') return;
    if (worldMapVisible) return;

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    worldMapVisible = true;

    worldMapOverlay = document.createElement('div');
    worldMapOverlay.id = 'world-map-overlay';
    worldMapOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;' +
      'background:rgba(10,10,20,0.92);z-index:500;display:flex;flex-direction:column;' +
      'align-items:center;justify-content:center;pointer-events:auto;';

    var title = document.createElement('div');
    title.style.cssText = 'font-size:48px;font-weight:bold;letter-spacing:8px;' +
      'color:#d4af37;margin-bottom:20px;text-align:center;' +
      'text-shadow:0 0 10px rgba(212,175,55,0.5);';
    title.textContent = 'WORLD OF ZION';
    worldMapOverlay.appendChild(title);

    var mapContainer = document.createElement('div');
    mapContainer.style.cssText = 'position:relative;width:80vw;height:60vh;max-width:800px;max-height:600px;' +
      'background:rgba(0,0,0,0.3);border:2px solid #d4af37;border-radius:8px;overflow:hidden;';

    worldMapCanvas = document.createElement('canvas');
    worldMapCanvas.style.cssText = 'display:block;width:100%;height:100%;';
    mapContainer.appendChild(worldMapCanvas);

    worldMapCanvas.width = 800;
    worldMapCanvas.height = 600;
    worldMapCtx = worldMapCanvas.getContext('2d');

    worldMapOverlay.appendChild(mapContainer);

    var instructions = document.createElement('div');
    instructions.style.cssText = 'margin-top:20px;font-size:14px;color:#aaa;text-align:center;';
    instructions.textContent = 'Press M or ESC to close';
    worldMapOverlay.appendChild(instructions);

    hud.appendChild(worldMapOverlay);

    drawWorldMap(playerPos, npcs, landmarks);

    worldMapOverlay.addEventListener('click', function(e) {
      if (e.target === worldMapOverlay) {
        hideWorldMap();
      }
    });

    var keyHandler = function(e) {
      if (e.key === 'Escape' || e.key === 'm' || e.key === 'M') {
        hideWorldMap();
        document.removeEventListener('keydown', keyHandler);
        e.preventDefault();
      }
    };
    document.addEventListener('keydown', keyHandler);
    worldMapOverlay._keyHandler = keyHandler;

    worldMapCanvas.addEventListener('mousemove', function(e) {
      handleMapHover(e);
    });
  }

  function hideWorldMap() {
    if (!worldMapOverlay) return;

    if (worldMapOverlay._keyHandler) {
      document.removeEventListener('keydown', worldMapOverlay._keyHandler);
    }

    if (worldMapOverlay.parentNode) {
      worldMapOverlay.parentNode.removeChild(worldMapOverlay);
    }

    worldMapOverlay = null;
    worldMapCanvas = null;
    worldMapCtx = null;
    worldMapVisible = false;
  }

  function updateWorldMap(playerPos) {
    if (!worldMapVisible || !worldMapCtx) return;
    drawWorldMap(playerPos, [], []);
  }

  function drawWorldMap(playerPos, npcs, landmarks) {
    if (!worldMapCtx) return;

    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    worldMapCtx.fillStyle = '#0a0e1a';
    worldMapCtx.fillRect(0, 0, w, h);

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;

    function worldToCanvas(wx, wz) {
      return {
        x: padding + ((wx - worldMin) / worldRange) * (w - padding * 2),
        y: padding + ((wz - worldMin) / worldRange) * (h - padding * 2)
      };
    }

    worldMapCtx.strokeStyle = 'rgba(255,255,255,0.05)';
    worldMapCtx.lineWidth = 1;
    for (var i = 0; i <= 8; i++) {
      var x = padding + (i / 8) * (w - padding * 2);
      var y = padding + (i / 8) * (h - padding * 2);
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(x, padding);
      worldMapCtx.lineTo(x, h - padding);
      worldMapCtx.stroke();
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(padding, y);
      worldMapCtx.lineTo(w - padding, y);
      worldMapCtx.stroke();
    }

    worldMapCtx.strokeStyle = 'rgba(212,175,55,0.2)';
    worldMapCtx.lineWidth = 2;
    ZONE_CONNECTIONS.forEach(function(conn) {
      var z1 = WORLD_MAP_ZONES[conn[0]];
      var z2 = WORLD_MAP_ZONES[conn[1]];
      if (!z1 || !z2) return;
      var pos1 = worldToCanvas(z1.cx, z1.cz);
      var pos2 = worldToCanvas(z2.cx, z2.cz);
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(pos1.x, pos1.y);
      worldMapCtx.lineTo(pos2.x, pos2.y);
      worldMapCtx.stroke();
    });

    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var pos = worldToCanvas(zone.cx, zone.cz);
      var r = (zone.radius / worldRange) * (w - padding * 2);

      worldMapCtx.globalAlpha = 0.3;
      worldMapCtx.fillStyle = zone.color;
      worldMapCtx.beginPath();
      worldMapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      worldMapCtx.fill();

      worldMapCtx.globalAlpha = 0.7;
      worldMapCtx.strokeStyle = zone.color;
      worldMapCtx.lineWidth = 2;
      worldMapCtx.beginPath();
      worldMapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      worldMapCtx.stroke();

      worldMapCtx.globalAlpha = 1.0;
      worldMapCtx.fillStyle = '#fff';
      worldMapCtx.font = 'bold 14px Arial';
      worldMapCtx.textAlign = 'center';
      worldMapCtx.textBaseline = 'middle';
      worldMapCtx.fillText(zone.name, pos.x, pos.y);
    }

    worldMapCtx.globalAlpha = 1.0;

    if (npcs && npcs.length > 0) {
      npcs.forEach(function(npc) {
        var pos = worldToCanvas(npc.x, npc.z);
        var color = ARCHETYPE_COLORS_HUD[npc.archetype] || '#888';
        worldMapCtx.fillStyle = color;
        worldMapCtx.beginPath();
        worldMapCtx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
        worldMapCtx.fill();
      });
    }

    if (landmarks && landmarks.length > 0) {
      landmarks.forEach(function(landmark) {
        var pos = worldToCanvas(landmark.x, landmark.z);
        drawStar(worldMapCtx, pos.x, pos.y, 5, 8, 4, '#ffd700');
      });
    }

    if (playerPos) {
      var pPos = worldToCanvas(playerPos.x, playerPos.z);
      drawDiamond(worldMapCtx, pPos.x, pPos.y, 12, '#FFD700');

      worldMapCtx.shadowBlur = 15;
      worldMapCtx.shadowColor = '#FFD700';
      drawDiamond(worldMapCtx, pPos.x, pPos.y, 12, '#FFD700');
      worldMapCtx.shadowBlur = 0;
    }

    drawCompassRose(worldMapCtx, w - 60, 60, 30);
  }

  function drawDiamond(ctx, x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size, y);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawStar(ctx, x, y, points, outer, inner, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    for (var i = 0; i < points * 2; i++) {
      var angle = (i * Math.PI) / points - Math.PI / 2;
      var radius = i % 2 === 0 ? outer : inner;
      var px = x + Math.cos(angle) * radius;
      var py = y + Math.sin(angle) * radius;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawCompassRose(ctx, x, y, size) {
    ctx.strokeStyle = 'rgba(212,175,55,0.5)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x, y + size);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x - size, y);
    ctx.lineTo(x + size, y);
    ctx.stroke();

    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('N', x, y - size - 10);
    ctx.fillText('S', x, y + size + 10);
    ctx.fillText('E', x + size + 12, y);
    ctx.fillText('W', x - size - 12, y);
  }

  function handleMapHover(e) {
    if (!worldMapCanvas || !worldMapCtx) return;

    var rect = worldMapCanvas.getBoundingClientRect();
    var mx = ((e.clientX - rect.left) / rect.width) * worldMapCanvas.width;
    var my = ((e.clientY - rect.top) / rect.height) * worldMapCanvas.height;

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;
    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    var hoveredZone = null;
    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var zx = padding + ((zone.cx - worldMin) / worldRange) * (w - padding * 2);
      var zy = padding + ((zone.cz - worldMin) / worldRange) * (h - padding * 2);
      var zr = (zone.radius / worldRange) * (w - padding * 2);

      var dx = mx - zx;
      var dy = my - zy;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist <= zr) {
        hoveredZone = zone;
        break;
      }
    }

    if (hoveredZone) {
      worldMapCanvas.style.cursor = 'pointer';
      worldMapCanvas.title = hoveredZone.name + ': ' + hoveredZone.desc;
    } else {
      worldMapCanvas.style.cursor = 'default';
      worldMapCanvas.title = '';
    }
  }

  // ========================================================================
  // EMOTE SYSTEM UI
  // ========================================================================

  var emoteMenuEl = null;
  var emoteMenuVisible = false;
  var emoteBubbles = new Map(); // playerId -> {element, timer}

  var EMOTE_SYMBOLS = {
    wave: '&#128075;',
    dance: '&#128131;',
    bow: '&#129485;',
    cheer: '&#127881;',
    meditate: '&#129496;',
    point: '&#128073;'
  };

  /**
   * Show emote menu (radial picker)
   */
  function showEmoteMenu() {
    if (typeof document === 'undefined') return;
    hideEmoteMenu(); // Remove existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    emoteMenuEl = document.createElement('div');
    emoteMenuEl.id = 'emote-menu';
    emoteMenuEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'width:300px;height:300px;pointer-events:auto;z-index:250;';

    var emotes = [
      { type: 'wave', label: 'Wave', angle: 0 },
      { type: 'dance', label: 'Dance', angle: 60 },
      { type: 'bow', label: 'Bow', angle: 120 },
      { type: 'cheer', label: 'Cheer', angle: 180 },
      { type: 'meditate', label: 'Meditate', angle: 240 },
      { type: 'point', label: 'Point', angle: 300 }
    ];

    var centerX = 150, centerY = 150, radius = 100;

    emotes.forEach(function(emote) {
      var angleRad = (emote.angle - 90) * Math.PI / 180;
      var x = centerX + radius * Math.cos(angleRad) - 35;
      var y = centerY + radius * Math.sin(angleRad) - 35;

      var btn = document.createElement('div');
      btn.className = 'emote-btn';
      btn.style.cssText = 'position:absolute;left:' + x + 'px;top:' + y + 'px;' +
        'width:70px;height:70px;border-radius:50%;background:rgba(0,0,0,0.8);' +
        'border:2px solid rgba(255,255,255,0.5);display:flex;flex-direction:column;' +
        'align-items:center;justify-content:center;cursor:pointer;' +
        'transition:all 0.2s;color:#fff;font-size:11px;';

      btn.innerHTML = '<div style="font-size:28px;margin-bottom:2px;">' + EMOTE_SYMBOLS[emote.type] + '</div>' +
        '<div>' + emote.label + '</div>';

      btn.onmouseover = function() {
        this.style.background = 'rgba(74,170,255,0.9)';
        this.style.borderColor = '#4af';
        this.style.transform = 'scale(1.1)';
      };

      btn.onmouseout = function() {
        this.style.background = 'rgba(0,0,0,0.8)';
        this.style.borderColor = 'rgba(255,255,255,0.5)';
        this.style.transform = 'scale(1)';
      };

      btn.onclick = (function(type) {
        return function() {
          hideEmoteMenu();
          if (window.Main && window.Main.handleLocalAction) {
            window.Main.handleLocalAction('emote', { type: type });
          }
        };
      })(emote.type);

      emoteMenuEl.appendChild(btn);
    });

    // Center label
    var centerLabel = document.createElement('div');
    centerLabel.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.9);border:2px solid #4af;border-radius:50%;' +
      'width:80px;height:80px;display:flex;align-items:center;justify-content:center;' +
      'color:#4af;font-weight:bold;font-size:12px;text-align:center;pointer-events:none;';
    centerLabel.textContent = 'Emotes';
    emoteMenuEl.appendChild(centerLabel);

    hud.appendChild(emoteMenuEl);
    emoteMenuVisible = true;
  }

  /**
   * Hide emote menu
   */
  function hideEmoteMenu() {
    if (emoteMenuEl && emoteMenuEl.parentNode) {
      emoteMenuEl.parentNode.removeChild(emoteMenuEl);
      emoteMenuEl = null;
    }
    emoteMenuVisible = false;
  }

  /**
   * Show emote bubble above player
   * @param {string} playerId - Player ID
   * @param {string} emoteType - Type of emote
   */
  function showEmoteBubble(playerId, emoteType) {
    if (typeof document === 'undefined') return;

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    // Remove existing bubble for this player
    var existing = emoteBubbles.get(playerId);
    if (existing && existing.element && existing.element.parentNode) {
      existing.element.parentNode.removeChild(existing.element);
    }

    var bubble = document.createElement('div');
    bubble.className = 'emote-bubble';
    bubble.style.cssText = 'position:absolute;background:rgba(255,255,255,0.95);' +
      'border:2px solid #4af;border-radius:20px;padding:8px 16px;' +
      'font-size:14px;font-weight:bold;color:#000;' +
      'box-shadow:0 4px 12px rgba(0,0,0,0.3);pointer-events:none;z-index:150;' +
      'animation:emoteFloat 2s ease-out forwards;white-space:nowrap;';

    var label = emoteType.charAt(0).toUpperCase() + emoteType.slice(1);
    bubble.innerHTML = EMOTE_SYMBOLS[emoteType] + ' ' + label;

    hud.appendChild(bubble);

    emoteBubbles.set(playerId, {
      element: bubble,
      timer: 2.0,
      emoteType: emoteType
    });

    // Auto-remove after animation
    setTimeout(function() {
      if (bubble.parentNode) {
        bubble.parentNode.removeChild(bubble);
      }
      emoteBubbles.delete(playerId);
    }, 2000);
  }

  /**
   * Update emote bubble positions (called from main loop)
   * @param {object} playerPositions - Map of playerId to screen position
   */
  function updateEmoteBubbles(playerPositions) {
    emoteBubbles.forEach(function(bubble, playerId) {
      if (!bubble.element || !bubble.element.parentNode) {
        emoteBubbles.delete(playerId);
        return;
      }

      var screenPos = playerPositions[playerId];
      if (screenPos) {
        bubble.element.style.left = screenPos.x + 'px';
        bubble.element.style.top = (screenPos.y - 80) + 'px';
      }
    });
  }

  // Add CSS animation for emote bubbles
  if (typeof document !== 'undefined') {
    var style = document.createElement('style');
    style.textContent += `
      @keyframes emoteFloat {
        0% {
          transform: translateY(0) scale(0.8);
          opacity: 0;
        }
        20% {
          opacity: 1;
          transform: translateY(-10px) scale(1);
        }
        80% {
          opacity: 1;
          transform: translateY(-30px) scale(1);
        }
        100% {
          transform: translateY(-40px) scale(0.9);
          opacity: 0;
        }
      }
    `;
    if (document.head) {
      document.head.appendChild(style);
    }
  }

  // ========================================================================
  // TRADING SYSTEM UI
  // ========================================================================

  var tradeRequestEl = null;
  var tradeWindowEl = null;
  var currentTradeData = null;

  /**
   * Show trade request popup
   * @param {string} fromPlayer - Player name requesting trade
   * @param {string} tradeId - Trade ID
   * @param {Function} onAccept - Callback when Accept clicked
   * @param {Function} onDecline - Callback when Decline clicked
   */
  function showTradeRequest(fromPlayer, tradeId, onAccept, onDecline) {
    if (typeof document === 'undefined') return;
    hideTradeRequest(); // Remove any existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    tradeRequestEl = document.createElement('div');
    tradeRequestEl.id = 'trade-request';
    tradeRequestEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #ffa500;border-radius:12px;' +
      'padding:20px;width:400px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var html = '<div style="font-size:20px;font-weight:bold;color:#ffa500;margin-bottom:12px;">Trade Request</div>' +
      '<div style="font-size:16px;color:#fff;margin-bottom:16px;">' +
      '<span style="color:#4af;font-weight:bold;">' + fromPlayer + '</span> wants to trade with you.' +
      '</div>' +
      '<div style="display:flex;gap:12px;justify-content:center;">' +
      '<button id="trade-accept-btn" style="padding:10px 24px;background:#4f4;color:#000;border:none;' +
      'border-radius:6px;font-weight:bold;font-size:14px;cursor:pointer;">Accept</button>' +
      '<button id="trade-decline-btn" style="padding:10px 24px;background:rgba(255,255,255,0.1);color:#fff;' +
      'border:1px solid #666;border-radius:6px;font-size:14px;cursor:pointer;">Decline</button></div>';

    tradeRequestEl.innerHTML = html;
    hud.appendChild(tradeRequestEl);

    document.getElementById('trade-accept-btn').addEventListener('click', function() {
      hideTradeRequest();
      if (onAccept) onAccept(tradeId);
    });

    document.getElementById('trade-decline-btn').addEventListener('click', function() {
      hideTradeRequest();
      if (onDecline) onDecline(tradeId);
    });
  }

  /**
   * Hide trade request popup
   */
  function hideTradeRequest() {
    if (tradeRequestEl && tradeRequestEl.parentNode) {
      tradeRequestEl.parentNode.removeChild(tradeRequestEl);
      tradeRequestEl = null;
    }
  }

  /**
   * Show trade window
   * @param {Object} trade - Trade data object
   * @param {string} localPlayerId - Local player's ID
   * @param {Function} onAddItem - Callback(slotIndex)
   * @param {Function} onRemoveItem - Callback(tradeSlot)
   * @param {Function} onSetSpark - Callback(amount)
   * @param {Function} onReady - Callback()
   * @param {Function} onConfirm - Callback()
   * @param {Function} onCancel - Callback()
   */
  function showTradeWindow(trade, localPlayerId, onAddItem, onRemoveItem, onSetSpark, onReady, onConfirm, onCancel) {
    if (typeof document === 'undefined') return;
    hideTradeWindow(); // Remove any existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    currentTradeData = { trade: trade, localPlayerId: localPlayerId };

    tradeWindowEl = document.createElement('div');
    tradeWindowEl.id = 'trade-window';
    tradeWindowEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #ffa500;border-radius:12px;' +
      'padding:20px;width:700px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    tradeWindowEl.innerHTML = '<div style="font-size:20px;font-weight:bold;color:#ffa500;margin-bottom:16px;text-align:center;">Trade Window</div>' +
      '<div id="trade-content"></div>';

    hud.appendChild(tradeWindowEl);

    // Store callbacks
    tradeWindowEl._callbacks = { onAddItem, onRemoveItem, onSetSpark, onReady, onConfirm, onCancel };

    // Update content
    updateTradeWindow(trade, localPlayerId);
  }

  /**
   * Update trade window with current trade state
   * @param {Object} trade - Trade data object
   * @param {string} localPlayerId - Local player's ID
   */
  function updateTradeWindow(trade, localPlayerId) {
    if (!tradeWindowEl) return;

    var contentDiv = document.getElementById('trade-content');
    if (!contentDiv) return;

    var isPlayer1 = trade.player1.id === localPlayerId;
    var localPlayer = isPlayer1 ? trade.player1 : trade.player2;
    var otherPlayer = isPlayer1 ? trade.player2 : trade.player1;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;

    // Build trade grid
    var html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:16px;">';

    // Your offer column
    html += '<div style="border:2px solid #4af;border-radius:8px;padding:12px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#4af;margin-bottom:10px;text-align:center;">Your Offer</div>' +
      '<div id="local-items" style="display:grid;grid-template-columns:repeat(3,80px);gap:6px;margin-bottom:10px;justify-content:center;">';

    // Local player's items (6 slots)
    for (var i = 0; i < 6; i++) {
      var item = localPlayer.items[i];
      var slotHtml = '<div class="trade-slot" data-slot="' + i + '" style="background:rgba(255,255,255,0.1);border:2px solid #555;' +
        'border-radius:6px;padding:8px;text-align:center;min-height:60px;cursor:pointer;position:relative;">';

      if (item && Inventory) {
        var itemData = Inventory.getItemData(item.itemId);
        if (itemData) {
          slotHtml += '<div style="font-size:28px;">' + itemData.icon + '</div>' +
            '<div style="font-size:9px;color:#ccc;">' + itemData.name + '</div>' +
            '<div style="position:absolute;top:2px;right:4px;background:#000;padding:1px 4px;border-radius:2px;font-size:10px;">' + item.count + '</div>';
        }
      } else {
        slotHtml += '<div style="color:#444;padding-top:15px;font-size:11px;">Empty</div>';
      }

      slotHtml += '</div>';
      html += slotHtml;
    }

    html += '</div>';

    // Spark input
    html += '<div style="margin-bottom:10px;">' +
      '<label style="font-size:12px;color:#aaa;display:block;margin-bottom:4px;">Spark Offer:</label>' +
      '<input type="number" id="local-spark-input" min="0" value="' + localPlayer.spark + '" ' +
      'style="width:100%;padding:6px;background:rgba(0,0,0,0.5);border:1px solid #555;border-radius:4px;color:#fff;font-size:14px;" />' +
      '</div>';

    // Status
    var statusText = localPlayer.ready ? 'âœ“ Ready' : 'Not ready';
    var statusColor = localPlayer.ready ? '#4f4' : '#888';
    html += '<div style="text-align:center;color:' + statusColor + ';font-size:13px;margin-bottom:8px;">' + statusText + '</div>';

    html += '</div>';

    // Their offer column
    html += '<div style="border:2px solid #f4a;border-radius:8px;padding:12px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#f4a;margin-bottom:10px;text-align:center;">Their Offer</div>' +
      '<div id="other-items" style="display:grid;grid-template-columns:repeat(3,80px);gap:6px;margin-bottom:10px;justify-content:center;">';

    // Other player's items (6 slots)
    for (var j = 0; j < 6; j++) {
      var otherItem = otherPlayer.items[j];
      var otherSlotHtml = '<div style="background:rgba(255,255,255,0.1);border:2px solid #555;' +
        'border-radius:6px;padding:8px;text-align:center;min-height:60px;position:relative;">';

      if (otherItem && Inventory) {
        var otherItemData = Inventory.getItemData(otherItem.itemId);
        if (otherItemData) {
          otherSlotHtml += '<div style="font-size:28px;">' + otherItemData.icon + '</div>' +
            '<div style="font-size:9px;color:#ccc;">' + otherItemData.name + '</div>' +
            '<div style="position:absolute;top:2px;right:4px;background:#000;padding:1px 4px;border-radius:2px;font-size:10px;">' + otherItem.count + '</div>';
        }
      } else {
        otherSlotHtml += '<div style="color:#444;padding-top:15px;font-size:11px;">Empty</div>';
      }

      otherSlotHtml += '</div>';
      html += otherSlotHtml;
    }

    html += '</div>';

    // Their Spark
    html += '<div style="margin-bottom:10px;">' +
      '<label style="font-size:12px;color:#aaa;display:block;margin-bottom:4px;">Spark Offer:</label>' +
      '<div style="padding:6px;background:rgba(0,0,0,0.5);border:1px solid #555;border-radius:4px;color:#ffa500;font-size:14px;text-align:center;">' +
      otherPlayer.spark + '</div></div>';

    // Their status
    var otherStatusText = otherPlayer.ready ? 'âœ“ Ready' : 'Not ready';
    var otherStatusColor = otherPlayer.ready ? '#4f4' : '#888';
    html += '<div style="text-align:center;color:' + otherStatusColor + ';font-size:13px;margin-bottom:8px;">' + otherStatusText + '</div>';

    html += '</div>';

    html += '</div>';

    // Status message
    var statusMsg = '';
    if (localPlayer.confirmed && otherPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#4f4;font-size:14px;margin-bottom:12px;">âœ“ Trade completed!</div>';
    } else if (localPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#fa4;font-size:14px;margin-bottom:12px;">Waiting for ' + otherPlayer.id + ' to confirm...</div>';
    } else if (otherPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#fa4;font-size:14px;margin-bottom:12px;">' + otherPlayer.id + ' has confirmed. Ready to confirm?</div>';
    } else if (localPlayer.ready && otherPlayer.ready) {
      statusMsg = '<div style="text-align:center;color:#4f4;font-size:14px;margin-bottom:12px;">Both ready! Click Confirm to complete trade.</div>';
    } else if (localPlayer.ready) {
      statusMsg = '<div style="text-align:center;color:#888;font-size:14px;margin-bottom:12px;">Waiting for ' + otherPlayer.id + ' to ready up...</div>';
    } else {
      statusMsg = '<div style="text-align:center;color:#888;font-size:14px;margin-bottom:12px;">Add items and Spark, then click Ready.</div>';
    }

    html += statusMsg;

    // Action buttons
    html += '<div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">';

    if (!localPlayer.ready) {
      html += '<button id="trade-ready-btn" style="padding:8px 20px;background:#4f4;color:#000;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Ready</button>';
    }

    if (localPlayer.ready && otherPlayer.ready && !localPlayer.confirmed) {
      html += '<button id="trade-confirm-btn" style="padding:8px 20px;background:#ffa500;color:#000;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Confirm Trade</button>';
    }

    html += '<button id="trade-cancel-btn" style="padding:8px 20px;background:#f44;color:#fff;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Cancel</button>';

    html += '</div>';

    contentDiv.innerHTML = html;

    // Attach event listeners
    var callbacks = tradeWindowEl._callbacks;

    // Spark input
    var sparkInput = document.getElementById('local-spark-input');
    if (sparkInput && callbacks.onSetSpark) {
      sparkInput.addEventListener('change', function() {
        var amount = parseInt(this.value) || 0;
        callbacks.onSetSpark(amount);
      });
    }

    // Ready button
    var readyBtn = document.getElementById('trade-ready-btn');
    if (readyBtn && callbacks.onReady) {
      readyBtn.addEventListener('click', function() {
        callbacks.onReady();
      });
    }

    // Confirm button
    var confirmBtn = document.getElementById('trade-confirm-btn');
    if (confirmBtn && callbacks.onConfirm) {
      confirmBtn.addEventListener('click', function() {
        callbacks.onConfirm();
      });
    }

    // Cancel button
    var cancelBtn = document.getElementById('trade-cancel-btn');
    if (cancelBtn && callbacks.onCancel) {
      cancelBtn.addEventListener('click', function() {
        callbacks.onCancel();
      });
    }

    // Trade slot clicks (to remove items)
    var tradeSlots = document.querySelectorAll('.trade-slot');
    tradeSlots.forEach(function(slot, idx) {
      slot.addEventListener('click', function() {
        if (localPlayer.items[idx] && callbacks.onRemoveItem) {
          callbacks.onRemoveItem(idx);
        }
      });
    });
  }

  /**
   * Hide trade window
   */
  function hideTradeWindow() {
    if (tradeWindowEl && tradeWindowEl.parentNode) {
      tradeWindowEl.parentNode.removeChild(tradeWindowEl);
      tradeWindowEl = null;
      currentTradeData = null;
    }
  }

  /**
   * Show trade complete notification
   * @param {string} partnerName - Trade partner's name
   */
  function showTradeComplete(partnerName) {
    showNotification('Trade completed with ' + partnerName + '!', 'success');
  }

  // ========================================================================
  // BUILD TOOLBAR
  // ========================================================================

  let buildToolbar = null;
  let selectedBuildType = 'bench';

  var BUILD_TYPES = [
    { id: 'bench', icon: '\u{1F6CB}', label: 'Bench', cost: 50 },
    { id: 'lantern', icon: '\u{1F4A1}', label: 'Lantern', cost: 75 },
    { id: 'signpost', icon: '\u{1F6A9}', label: 'Sign', cost: 40 },
    { id: 'fence', icon: '\u{1F6AA}', label: 'Fence', cost: 30 },
    { id: 'planter', icon: '\u{1F33F}', label: 'Planter', cost: 60 },
    { id: 'campfire', icon: '\u{1F525}', label: 'Fire', cost: 80 },
    { id: 'archway', icon: '\u{26E9}', label: 'Arch', cost: 150 },
    { id: 'table', icon: '\u{1F6CF}', label: 'Table', cost: 70 },
    { id: 'barrel', icon: '\u{1F6E2}', label: 'Barrel', cost: 45 },
    { id: 'crate', icon: '\u{1F4E6}', label: 'Crate', cost: 35 }
  ];

  function showBuildToolbar() {
    if (typeof document === 'undefined') return;

    if (buildToolbar) {
      buildToolbar.style.display = 'block';
      return;
    }

    buildToolbar = document.createElement('div');
    buildToolbar.id = 'build-toolbar';
    buildToolbar.style.cssText = `
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 200;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-bottom: none;
      pointer-events: auto;
    `;

    // Title
    var title = document.createElement('div');
    title.style.cssText = `
      color: #fff;
      font-weight: bold;
      margin-right: 10px;
      font-size: 14px;
    `;
    title.textContent = 'BUILD MODE';
    buildToolbar.appendChild(title);

    // Build type buttons
    BUILD_TYPES.forEach(function(type) {
      var btn = document.createElement('div');
      btn.className = 'build-type-btn';
      btn.dataset.type = type.id;
      btn.style.cssText = `
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      `;

      var icon = document.createElement('div');
      icon.style.cssText = 'font-size: 24px; margin-bottom: 2px;';
      icon.textContent = type.icon;

      var label = document.createElement('div');
      label.style.cssText = 'font-size: 9px; color: #ccc;';
      label.textContent = type.label;

      var cost = document.createElement('div');
      cost.style.cssText = 'font-size: 8px; color: #ffa500;';
      cost.textContent = type.cost + ' Spark';

      btn.appendChild(icon);
      btn.appendChild(label);
      btn.appendChild(cost);

      btn.addEventListener('click', function() {
        selectedBuildType = type.id;
        updateBuildToolbar(selectedBuildType);
        if (typeof World !== 'undefined' && World.setBuildType) {
          World.setBuildType(type.id);
        }
      });

      btn.addEventListener('mouseenter', function() {
        btn.style.background = 'rgba(255, 255, 255, 0.2)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.6)';
      });

      btn.addEventListener('mouseleave', function() {
        if (type.id !== selectedBuildType) {
          btn.style.background = 'rgba(255, 255, 255, 0.1)';
          btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
      });

      buildToolbar.appendChild(btn);
    });

    // Instructions
    var instructions = document.createElement('div');
    instructions.style.cssText = `
      margin-left: 15px;
      color: #ccc;
      font-size: 12px;
      line-height: 1.4;
    `;
    instructions.innerHTML = `
      <div>Click to place</div>
      <div>R to rotate</div>
      <div><strong>B or Esc</strong> to exit</div>
    `;
    buildToolbar.appendChild(instructions);

    document.body.appendChild(buildToolbar);

    updateBuildToolbar(selectedBuildType);
  }

  function hideBuildToolbar() {
    if (buildToolbar) {
      buildToolbar.style.display = 'none';
    }
  }

  function updateBuildToolbar(type) {
    if (!buildToolbar) return;
    selectedBuildType = type;

    var buttons = buildToolbar.querySelectorAll('.build-type-btn');
    buttons.forEach(function(btn) {
      if (btn.dataset.type === type) {
        btn.style.background = 'rgba(255, 215, 0, 0.3)';
        btn.style.borderColor = 'rgba(255, 215, 0, 0.8)';
        btn.style.borderWidth = '3px';
      } else {
        btn.style.background = 'rgba(255, 255, 255, 0.1)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        btn.style.borderWidth = '2px';
      }
    });
  }

  // Settings Menu
  let settingsMenuPanel = null;
  let settingsData = {
    masterVolume: 50,
    musicVolume: 30,
    sfxVolume: 70,
    renderDistance: 'medium',
    particleDensity: 'medium',
    showFPS: false
  };

  function loadSettings() {
    if (typeof localStorage === 'undefined') return;
    try {
      var stored = localStorage.getItem('zion_settings');
      if (stored) {
        var parsed = JSON.parse(stored);
        Object.assign(settingsData, parsed);
      }
    } catch (err) {
      console.warn('Failed to load settings:', err);
    }
  }

  function saveSettings() {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem('zion_settings', JSON.stringify(settingsData));
    } catch (err) {
      console.warn('Failed to save settings:', err);
    }
  }

  function getSettings() {
    return settingsData;
  }

  function showSettingsMenu() {
    if (settingsMenuPanel) return;

    var overlay = document.createElement('div');
    overlay.id = 'settings-menu-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    `;

    var panel = document.createElement('div');
    panel.style.cssText = `
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 12px;
      padding: 30px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
    `;

    var title = document.createElement('h2');
    title.textContent = 'Settings';
    title.style.cssText = `
      margin: 0 0 25px 0;
      color: #DAA520;
      font-size: 28px;
      font-family: Georgia, serif;
      text-align: center;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;
    panel.appendChild(title);

    // Volume Section
    var volumeSection = document.createElement('div');
    volumeSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var volumeTitle = document.createElement('h3');
    volumeTitle.textContent = 'Audio';
    volumeTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    volumeSection.appendChild(volumeTitle);

    // Master Volume
    volumeSection.appendChild(createSlider('Master Volume', 'masterVolume', settingsData.masterVolume));
    // Music Volume
    volumeSection.appendChild(createSlider('Music Volume', 'musicVolume', settingsData.musicVolume));
    // SFX Volume
    volumeSection.appendChild(createSlider('SFX Volume', 'sfxVolume', settingsData.sfxVolume));

    panel.appendChild(volumeSection);

    // Graphics Section
    var graphicsSection = document.createElement('div');
    graphicsSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var graphicsTitle = document.createElement('h3');
    graphicsTitle.textContent = 'Graphics';
    graphicsTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    graphicsSection.appendChild(graphicsTitle);

    // Render Distance
    graphicsSection.appendChild(createOptionButtons('Render Distance', 'renderDistance', ['low', 'medium', 'high'], settingsData.renderDistance));
    // Particle Density
    graphicsSection.appendChild(createOptionButtons('Particle Density', 'particleDensity', ['low', 'medium', 'high'], settingsData.particleDensity));
    // Show FPS Counter
    graphicsSection.appendChild(createCheckbox('Show FPS Counter', 'showFPS', settingsData.showFPS));

    panel.appendChild(graphicsSection);

    // Controls Section
    var controlsSection = document.createElement('div');
    controlsSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var controlsTitle = document.createElement('h3');
    controlsTitle.textContent = 'Controls';
    controlsTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    controlsSection.appendChild(controlsTitle);

    var controlsInfo = document.createElement('div');
    controlsInfo.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      line-height: 1.8;
      font-family: system-ui, sans-serif;
    `;
    controlsInfo.innerHTML = `
      <div style="display: grid; grid-template-columns: 120px 1fr; gap: 8px;">
        <div><strong>W/A/S/D</strong></div><div>Move</div>
        <div><strong>Mouse</strong></div><div>Look around</div>
        <div><strong>E</strong></div><div>Interact</div>
        <div><strong>I</strong></div><div>Inventory</div>
        <div><strong>C</strong></div><div>Crafting</div>
        <div><strong>J</strong></div><div>Quest Log</div>
        <div><strong>M</strong></div><div>World Map</div>
        <div><strong>B</strong></div><div>Build Mode</div>
        <div><strong>F</strong></div><div>Emote Menu</div>
        <div><strong>T</strong></div><div>Trade</div>
        <div><strong>P</strong></div><div>Player Profile</div>
        <div><strong>Enter</strong></div><div>Chat</div>
        <div><strong>Escape</strong></div><div>Settings / Cancel</div>
      </div>
    `;
    controlsSection.appendChild(controlsInfo);

    panel.appendChild(controlsSection);

    // Resume Button
    var resumeBtn = document.createElement('button');
    resumeBtn.textContent = 'Resume';
    resumeBtn.style.cssText = `
      width: 100%;
      padding: 15px;
      background: rgba(218, 165, 32, 0.2);
      color: #DAA520;
      border: 2px solid #DAA520;
      border-radius: 8px;
      font-size: 18px;
      font-family: Georgia, serif;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 10px;
    `;
    resumeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#FFD700';
    };
    resumeBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.2)';
      this.style.borderColor = '#DAA520';
    };
    resumeBtn.onclick = function() {
      hideSettingsMenu();
    };
    panel.appendChild(resumeBtn);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);
    settingsMenuPanel = overlay;
  }

  function hideSettingsMenu() {
    if (!settingsMenuPanel) return;
    document.body.removeChild(settingsMenuPanel);
    settingsMenuPanel = null;
  }

  function createSlider(label, key, value) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
    `;

    var labelEl = document.createElement('label');
    labelEl.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;

    var labelText = document.createElement('span');
    labelText.textContent = label;

    var valueDisplay = document.createElement('span');
    valueDisplay.textContent = value;
    valueDisplay.style.color = '#DAA520';
    valueDisplay.style.fontWeight = 'bold';

    labelEl.appendChild(labelText);
    labelEl.appendChild(valueDisplay);
    container.appendChild(labelEl);

    var slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '100';
    slider.value = value;
    slider.style.cssText = `
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    `;

    slider.oninput = function() {
      valueDisplay.textContent = this.value;
      settingsData[key] = parseInt(this.value);
      saveSettings();
      applySettings();
    };

    container.appendChild(slider);
    return container;
  }

  function createOptionButtons(label, key, options, currentValue) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
    `;

    var labelEl = document.createElement('div');
    labelEl.textContent = label;
    labelEl.style.cssText = `
      margin-bottom: 8px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    container.appendChild(labelEl);

    var buttonsContainer = document.createElement('div');
    buttonsContainer.style.cssText = `
      display: flex;
      gap: 10px;
    `;

    options.forEach(function(option) {
      var btn = document.createElement('button');
      btn.textContent = option.charAt(0).toUpperCase() + option.slice(1);
      btn.style.cssText = `
        flex: 1;
        padding: 10px;
        background: ${option === currentValue ? 'rgba(218, 165, 32, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
        color: ${option === currentValue ? '#DAA520' : '#E8E0D8'};
        border: 2px solid ${option === currentValue ? '#DAA520' : 'rgba(255, 255, 255, 0.3)'};
        border-radius: 6px;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        cursor: pointer;
        transition: all 0.3s ease;
      `;

      btn.onclick = function() {
        settingsData[key] = option;
        saveSettings();
        applySettings();

        // Update button styles
        Array.from(buttonsContainer.children).forEach(function(child) {
          child.style.background = 'rgba(255, 255, 255, 0.1)';
          child.style.color = '#E8E0D8';
          child.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        btn.style.background = 'rgba(218, 165, 32, 0.3)';
        btn.style.color = '#DAA520';
        btn.style.borderColor = '#DAA520';
      };

      btn.onmouseover = function() {
        if (option !== currentValue) {
          this.style.background = 'rgba(255, 255, 255, 0.15)';
        }
      };

      btn.onmouseout = function() {
        if (option !== currentValue) {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
        }
      };

      buttonsContainer.appendChild(btn);
    });

    container.appendChild(buttonsContainer);
    return container;
  }

  function createCheckbox(label, key, checked) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    `;

    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = checked;
    checkbox.style.cssText = `
      width: 20px;
      height: 20px;
      cursor: pointer;
    `;

    checkbox.onchange = function() {
      settingsData[key] = this.checked;
      saveSettings();
      applySettings();
    };

    var labelEl = document.createElement('label');
    labelEl.textContent = label;
    labelEl.style.cssText = `
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      cursor: pointer;
    `;
    labelEl.onclick = function() {
      checkbox.checked = !checkbox.checked;
      checkbox.onchange();
    };

    container.appendChild(checkbox);
    container.appendChild(labelEl);
    return container;
  }

  function applySettings() {
    // Apply audio settings
    if (typeof Audio !== 'undefined' && Audio.setVolume) {
      Audio.setVolume('master', settingsData.masterVolume / 100);
      Audio.setVolume('music', settingsData.musicVolume / 100);
      Audio.setVolume('sfx', settingsData.sfxVolume / 100);
    }

    // FPS counter will be handled by main.js
    // Render distance and particle density would be applied by renderer/world systems
  }

  // Player Profile Panel
  var playerProfilePanel = null;

  function showProfilePanel(playerData, skillData, achievementData) {
    if (playerProfilePanel) {
      hideProfilePanel();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'player-profile-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.9);border:2px solid #d4af37;border-radius:12px;' +
      'padding:0;width:700px;max-height:85vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    // Header with close button
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;justify-content:space-between;align-items:center;' +
      'padding:20px;background:rgba(212,175,55,0.1);border-bottom:1px solid #d4af37;';

    var title = document.createElement('div');
    title.textContent = 'Player Profile';
    title.style.cssText = 'font-size:24px;font-weight:bold;color:#d4af37;';
    header.appendChild(title);

    var closeBtn = document.createElement('div');
    closeBtn.textContent = 'âœ•';
    closeBtn.style.cssText = 'cursor:pointer;font-size:24px;color:#888;padding:0 8px;';
    closeBtn.onmouseover = function() { this.style.color = '#d4af37'; };
    closeBtn.onmouseout = function() { this.style.color = '#888'; };
    closeBtn.onclick = function() { hideProfilePanel(); };
    header.appendChild(closeBtn);

    panel.appendChild(header);

    // Content container
    var content = document.createElement('div');
    content.id = 'profile-content';
    content.style.cssText = 'padding:20px;';

    // Player info section with avatar
    var playerInfoSection = document.createElement('div');
    playerInfoSection.style.cssText = 'display:flex;align-items:center;margin-bottom:20px;' +
      'padding-bottom:20px;border-bottom:1px solid rgba(212,175,55,0.3);';

    // Avatar (colored circle with initial)
    var avatar = document.createElement('div');
    var initial = (playerData.name || 'P').charAt(0).toUpperCase();
    avatar.textContent = initial;
    avatar.style.cssText = 'width:80px;height:80px;border-radius:50%;background:#d4af37;' +
      'display:flex;align-items:center;justify-content:center;font-size:36px;font-weight:bold;' +
      'color:#000;margin-right:20px;';
    playerInfoSection.appendChild(avatar);

    // Player details
    var playerDetails = document.createElement('div');
    playerDetails.style.cssText = 'flex:1;';

    var playerName = document.createElement('div');
    playerName.textContent = playerData.name || 'Player';
    playerName.style.cssText = 'font-size:22px;font-weight:bold;color:#fff;margin-bottom:8px;';
    playerDetails.appendChild(playerName);

    var reputationTier = document.createElement('div');
    var tier = playerData.reputationTier || 'Newcomer';
    reputationTier.textContent = 'Reputation: ' + tier;
    reputationTier.style.cssText = 'font-size:14px;color:#d4af37;margin-bottom:6px;';
    playerDetails.appendChild(reputationTier);

    var sparkBalance = document.createElement('div');
    sparkBalance.innerHTML = '<span style="color:#d4af37;">âœ¦</span> ' + (playerData.sparkBalance || 0) + ' Spark';
    sparkBalance.style.cssText = 'font-size:16px;color:#fff;font-weight:bold;';
    playerDetails.appendChild(sparkBalance);

    playerInfoSection.appendChild(playerDetails);
    content.appendChild(playerInfoSection);

    // Skills section
    var skillsSection = document.createElement('div');
    skillsSection.id = 'profile-skills-section';
    skillsSection.style.cssText = 'margin-bottom:20px;';

    var skillsTitle = document.createElement('div');
    skillsTitle.textContent = 'Skills';
    skillsTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    skillsSection.appendChild(skillsTitle);

    var skillNames = ['gardening', 'crafting', 'building', 'exploration', 'trading', 'social', 'combat', 'lore'];
    var skillIcons = {
      gardening: 'ðŸŒ±',
      crafting: 'ðŸ”¨',
      building: 'ðŸ—ï¸',
      exploration: 'ðŸ—ºï¸',
      trading: 'ðŸ’°',
      social: 'ðŸ‘¥',
      combat: 'âš”ï¸',
      lore: 'ðŸ“–'
    };

    skillNames.forEach(function(skillName) {
      var skill = (skillData && skillData[skillName]) || { level: 1, xp: 0, xpToNext: 100 };
      var skillDiv = document.createElement('div');
      skillDiv.className = 'skill-row-' + skillName;
      skillDiv.style.cssText = 'margin-bottom:14px;';

      var skillHeader = document.createElement('div');
      skillHeader.style.cssText = 'display:flex;justify-content:space-between;margin-bottom:4px;';

      var skillLabel = document.createElement('div');
      var icon = skillIcons[skillName] || 'â­';
      skillLabel.innerHTML = icon + ' ' + skillName.charAt(0).toUpperCase() + skillName.slice(1);
      skillLabel.style.cssText = 'font-size:14px;color:#fff;font-weight:600;';
      skillHeader.appendChild(skillLabel);

      var skillLevel = document.createElement('div');
      skillLevel.textContent = 'Level ' + skill.level;
      skillLevel.style.cssText = 'font-size:13px;color:#d4af37;font-weight:bold;';
      skillHeader.appendChild(skillLevel);

      skillDiv.appendChild(skillHeader);

      // Progress bar
      var progressContainer = document.createElement('div');
      progressContainer.style.cssText = 'width:100%;height:10px;background:rgba(255,255,255,0.1);' +
        'border-radius:5px;overflow:hidden;position:relative;';

      var progressFill = document.createElement('div');
      var progressPercent = Math.min(100, (skill.xp / skill.xpToNext) * 100);
      progressFill.style.cssText = 'height:100%;background:linear-gradient(90deg,#d4af37,#f4e4a6);' +
        'border-radius:5px;width:' + progressPercent + '%;transition:width 0.3s ease;';
      progressContainer.appendChild(progressFill);

      var progressText = document.createElement('div');
      progressText.textContent = skill.xp + ' / ' + skill.xpToNext + ' XP';
      progressText.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;' +
        'display:flex;align-items:center;justify-content:center;font-size:9px;color:#fff;font-weight:bold;';
      progressContainer.appendChild(progressText);

      skillDiv.appendChild(progressContainer);
      skillsSection.appendChild(skillDiv);
    });

    content.appendChild(skillsSection);

    // Statistics section
    var statsSection = document.createElement('div');
    statsSection.id = 'profile-stats-section';
    statsSection.style.cssText = 'margin-bottom:20px;padding:15px;background:rgba(212,175,55,0.05);' +
      'border-radius:8px;border:1px solid rgba(212,175,55,0.2);';

    var statsTitle = document.createElement('div');
    statsTitle.textContent = 'Statistics';
    statsTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    statsSection.appendChild(statsTitle);

    var statsGrid = document.createElement('div');
    statsGrid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:10px;';

    var stats = [
      { label: 'Quests Completed', value: playerData.questsCompleted || 0 },
      { label: 'Discoveries Found', value: playerData.discoveriesFound || 0 },
      { label: 'Items Crafted', value: playerData.itemsCrafted || 0 },
      { label: 'Trades Completed', value: playerData.tradesCompleted || 0 },
      { label: 'Time Played', value: formatPlayTime(playerData.playTimeSeconds || 0) }
    ];

    stats.forEach(function(stat) {
      var statItem = document.createElement('div');
      statItem.className = 'stat-' + stat.label.toLowerCase().replace(/ /g, '-');
      statItem.style.cssText = 'padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;';

      var statLabel = document.createElement('div');
      statLabel.textContent = stat.label;
      statLabel.style.cssText = 'font-size:11px;color:#888;margin-bottom:4px;';
      statItem.appendChild(statLabel);

      var statValue = document.createElement('div');
      statValue.textContent = stat.value;
      statValue.style.cssText = 'font-size:16px;color:#fff;font-weight:bold;';
      statItem.appendChild(statValue);

      statsGrid.appendChild(statItem);
    });

    statsSection.appendChild(statsGrid);
    content.appendChild(statsSection);

    // Recent Activity section
    var activitySection = document.createElement('div');
    activitySection.id = 'profile-activity-section';
    activitySection.style.cssText = 'margin-bottom:0;';

    var activityTitle = document.createElement('div');
    activityTitle.textContent = 'Recent Activity';
    activityTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    activitySection.appendChild(activityTitle);

    var activities = playerData.recentActivities || ['Started playing ZION'];
    var activityList = document.createElement('div');
    activityList.style.cssText = 'max-height:150px;overflow-y:auto;';

    activities.slice(0, 10).forEach(function(activity) {
      var activityItem = document.createElement('div');
      activityItem.textContent = 'â€¢ ' + activity;
      activityItem.style.cssText = 'font-size:12px;color:#aaa;padding:4px 0;line-height:1.4;';
      activityList.appendChild(activityItem);
    });

    activitySection.appendChild(activityList);
    content.appendChild(activitySection);

    // Close hint
    var closeHint = document.createElement('div');
    closeHint.textContent = 'Press P to close';
    closeHint.style.cssText = 'text-align:center;margin-top:15px;font-size:11px;color:#666;';
    content.appendChild(closeHint);

    panel.appendChild(content);
    document.body.appendChild(panel);
    playerProfilePanel = panel;
  }

  function hideProfilePanel() {
    if (!playerProfilePanel) return;
    if (playerProfilePanel.parentNode) {
      playerProfilePanel.parentNode.removeChild(playerProfilePanel);
    }
    playerProfilePanel = null;
  }

  function updateProfileStats(stats) {
    if (!playerProfilePanel) return;

    // Update statistics values
    if (stats.questsCompleted !== undefined) {
      var questsStat = playerProfilePanel.querySelector('.stat-quests-completed div:last-child');
      if (questsStat) questsStat.textContent = stats.questsCompleted;
    }
    if (stats.discoveriesFound !== undefined) {
      var discoveriesStat = playerProfilePanel.querySelector('.stat-discoveries-found div:last-child');
      if (discoveriesStat) discoveriesStat.textContent = stats.discoveriesFound;
    }
    if (stats.itemsCrafted !== undefined) {
      var craftedStat = playerProfilePanel.querySelector('.stat-items-crafted div:last-child');
      if (craftedStat) craftedStat.textContent = stats.itemsCrafted;
    }
    if (stats.tradesCompleted !== undefined) {
      var tradesStat = playerProfilePanel.querySelector('.stat-trades-completed div:last-child');
      if (tradesStat) tradesStat.textContent = stats.tradesCompleted;
    }
    if (stats.playTimeSeconds !== undefined) {
      var timeStat = playerProfilePanel.querySelector('.stat-time-played div:last-child');
      if (timeStat) timeStat.textContent = formatPlayTime(stats.playTimeSeconds);
    }
  }

  // Legacy function names for backward compatibility
  function showPlayerProfile(playerData) {
    showProfilePanel(playerData, null, null);
  }

  function hidePlayerProfile() {
    hideProfilePanel();
  }

  function formatPlayTime(seconds) {
    var hours = Math.floor(seconds / 3600);
    var minutes = Math.floor((seconds % 3600) / 60);
    if (hours > 0) {
      return hours + 'h ' + minutes + 'm';
    }
    return minutes + 'm';
  }

  // Discovery Log Panel
  var discoveryLogPanel = null;

  function showDiscoveryLog(discoveries) {
    if (discoveryLogPanel) return;

    var panel = document.createElement('div');
    panel.id = 'discovery-log-overlay';
    panel.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    `;

    var content = document.createElement('div');
    content.style.cssText = `
      width: 80%;
      max-width: 900px;
      height: 80%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 12px;
      padding: 30px;
      overflow-y: auto;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
      border: 2px solid #3a506b;
    `;

    var header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #3a506b;
    `;

    var title = document.createElement('h2');
    title.textContent = 'Discovery Log';
    title.style.cssText = `
      margin: 0;
      color: #e0e0e0;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      font-weight: 600;
    `;

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'X';
    closeBtn.style.cssText = `
      background: #c0392b;
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
    `;
    closeBtn.onclick = hideDiscoveryLog;

    header.appendChild(title);
    header.appendChild(closeBtn);
    content.appendChild(header);

    // Group discoveries by zone
    var discoveryByZone = {};
    var totalDiscoveries = 0;
    if (discoveries && discoveries.length > 0) {
      discoveries.forEach(function(disc) {
        var zone = disc.zone || 'Unknown';
        if (!discoveryByZone[zone]) {
          discoveryByZone[zone] = [];
        }
        discoveryByZone[zone].push(disc);
        totalDiscoveries++;
      });
    }

    // Display discoveries by zone
    Object.keys(discoveryByZone).forEach(function(zone) {
      var zoneSection = document.createElement('div');
      zoneSection.style.cssText = `
        margin-bottom: 30px;
      `;

      var zoneHeader = document.createElement('div');
      zoneHeader.textContent = zone + ' (' + discoveryByZone[zone].length + ' discoveries)';
      zoneHeader.style.cssText = `
        color: #5dade2;
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 15px;
        font-family: system-ui, sans-serif;
      `;
      zoneSection.appendChild(zoneHeader);

      discoveryByZone[zone].forEach(function(disc) {
        var rarityColors = {
          common: '#ffffff',
          uncommon: '#1eff00',
          rare: '#0070dd',
          epic: '#a335ee',
          legendary: '#ff8000'
        };
        var color = rarityColors[disc.rarity] || '#ffffff';

        var discItem = document.createElement('div');
        discItem.style.cssText = `
          background: rgba(255, 255, 255, 0.05);
          border-left: 4px solid ` + color + `;
          padding: 12px 15px;
          margin-bottom: 10px;
          border-radius: 6px;
        `;

        var discName = document.createElement('div');
        discName.textContent = disc.name;
        discName.style.cssText = `
          color: ` + color + `;
          font-size: 16px;
          font-weight: 600;
          margin-bottom: 5px;
          font-family: system-ui, sans-serif;
        `;

        var discDesc = document.createElement('div');
        discDesc.textContent = disc.description || 'No description available';
        discDesc.style.cssText = `
          color: #b0b0b0;
          font-size: 14px;
          margin-bottom: 5px;
          font-family: system-ui, sans-serif;
        `;

        var discMeta = document.createElement('div');
        discMeta.textContent = 'Discovered: ' + (disc.timestamp ? new Date(disc.timestamp).toLocaleDateString() : 'Unknown');
        discMeta.style.cssText = `
          color: #808080;
          font-size: 12px;
          font-style: italic;
          font-family: system-ui, sans-serif;
        `;

        discItem.appendChild(discName);
        discItem.appendChild(discDesc);
        discItem.appendChild(discMeta);
        zoneSection.appendChild(discItem);
      });

      content.appendChild(zoneSection);
    });

    if (totalDiscoveries === 0) {
      var emptyMsg = document.createElement('div');
      emptyMsg.textContent = 'No discoveries yet. Explore the world to find new locations, creatures, and secrets!';
      emptyMsg.style.cssText = `
        color: #a0a0a0;
        font-size: 16px;
        text-align: center;
        margin-top: 50px;
        font-family: system-ui, sans-serif;
      `;
      content.appendChild(emptyMsg);
    }

    panel.appendChild(content);
    document.body.appendChild(panel);
    discoveryLogPanel = panel;
    panel.className = 'discovery-panel';
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideDiscoveryLog();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideDiscoveryLog() {
    if (!discoveryLogPanel) return;
    if (discoveryLogPanel.escapeHandler) {
      document.removeEventListener('keydown', discoveryLogPanel.escapeHandler);
    }
    discoveryLogPanel.classList.remove('visible');
    setTimeout(function() {
      if (discoveryLogPanel && discoveryLogPanel.parentNode) {
        document.body.removeChild(discoveryLogPanel);
        discoveryLogPanel = null;
      }
    }, 250);
  }

  // Lore Book Panel
  var loreBookPanel = null;

  /**
   * Show the Lore Journal panel
   * @param {string} playerId - The player's ID
   * @param {object} state - Game state object containing discoveries
   */
  function showLoreJournal(playerId, state) {
    if (loreBookPanel) {
      hideLoreJournal();
      return;
    }

    // Get unlocked lore and lore categories from Exploration module
    var unlockedLore = [];
    var loreCategories = {};

    if (typeof window !== 'undefined' && window.Exploration) {
      unlockedLore = window.Exploration.getUnlockedLore(playerId, state);
      loreCategories = window.Exploration.getLoreCategories();
    }

    // Group unlocked lore by category
    var loreByCategory = {};
    unlockedLore.forEach(function(entry) {
      if (!loreByCategory[entry.category]) {
        loreByCategory[entry.category] = [];
      }
      loreByCategory[entry.category].push(entry);
    });

    // Get all lore entries from Exploration module to show locked ones
    var allLoreEntries = window.Exploration ? window.Exploration.LORE_ENTRIES : {};

    // Panel overlay
    var panel = document.createElement('div');
    panel.className = 'lore-journal-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 85%;
      max-width: 950px;
      height: 85vh;
      background: linear-gradient(135deg, #3d2817 0%, #2a1810 100%);
      border: 3px solid #8b6914;
      border-radius: 10px;
      box-shadow: 0 15px 60px rgba(0, 0, 0, 0.8), inset 0 0 40px rgba(139, 105, 20, 0.1);
      z-index: 10000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
    `;

    // Header
    var header = document.createElement('div');
    header.style.cssText = `
      background: linear-gradient(180deg, rgba(61, 40, 23, 0.9) 0%, rgba(42, 24, 16, 0.95) 100%);
      padding: 20px 30px;
      border-bottom: 2px solid #8b6914;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;

    var titleContainer = document.createElement('div');

    var title = document.createElement('h2');
    title.textContent = 'Lore Journal';
    title.style.cssText = `
      margin: 0 0 5px 0;
      color: #f4e4c1;
      font-size: 30px;
      font-family: Georgia, serif;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
    `;
    titleContainer.appendChild(title);

    // Overall completion
    var totalLore = Object.keys(allLoreEntries).length;
    var unlockedCount = unlockedLore.length;
    var completionPct = totalLore > 0 ? Math.round((unlockedCount / totalLore) * 100) : 0;

    var completion = document.createElement('div');
    completion.textContent = 'Completion: ' + unlockedCount + '/' + totalLore + ' (' + completionPct + '%)';
    completion.style.cssText = `
      color: #d4af37;
      font-size: 14px;
      font-family: Georgia, serif;
    `;
    titleContainer.appendChild(completion);

    header.appendChild(titleContainer);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\u00D7';
    closeBtn.style.cssText = `
      background: rgba(139, 69, 19, 0.6);
      border: 2px solid #8b6914;
      color: #f4e4c1;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 28px;
      font-weight: bold;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.4)';
      this.style.borderColor = '#d4af37';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 69, 19, 0.6)';
      this.style.borderColor = '#8b6914';
    };
    closeBtn.onclick = hideLoreJournal;
    header.appendChild(closeBtn);

    panel.appendChild(header);

    // Category tabs
    var tabsContainer = document.createElement('div');
    tabsContainer.style.cssText = `
      display: flex;
      gap: 5px;
      padding: 15px 20px 0 20px;
      background: rgba(42, 24, 16, 0.7);
      overflow-x: auto;
      border-bottom: 2px solid #8b6914;
    `;

    // Content area
    var contentArea = document.createElement('div');
    contentArea.style.cssText = `
      flex: 1;
      overflow-y: auto;
      padding: 25px 30px;
      background: linear-gradient(180deg, rgba(42, 24, 16, 0.8) 0%, rgba(26, 15, 10, 0.9) 100%);
    `;

    // Category tabs array
    var categories = ['origins', 'artifacts', 'landmarks', 'nature', 'mysteries', 'art', 'history'];
    var currentCategory = categories[0];

    // Function to render category content
    function renderCategory(category) {
      contentArea.innerHTML = '';

      // Category header with progress
      var categoryHeader = document.createElement('div');
      categoryHeader.style.cssText = `
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.3);
      `;

      var categoryTitle = document.createElement('h3');
      categoryTitle.textContent = category.charAt(0).toUpperCase() + category.slice(1);
      categoryTitle.style.cssText = `
        margin: 0 0 8px 0;
        color: #d4af37;
        font-size: 24px;
        font-family: Georgia, serif;
        font-weight: 600;
      `;
      categoryHeader.appendChild(categoryTitle);

      // Count entries in this category
      var categoryTotal = 0;
      var categoryUnlocked = 0;
      for (var loreId in allLoreEntries) {
        if (allLoreEntries[loreId].category === category) {
          categoryTotal++;
          if (loreByCategory[category] && loreByCategory[category].some(function(e) { return e.id === loreId; })) {
            categoryUnlocked++;
          }
        }
      }

      var categoryProgress = document.createElement('div');
      categoryProgress.className = 'lore-progress';
      categoryProgress.textContent = 'Discovered: ' + categoryUnlocked + '/' + categoryTotal;
      categoryProgress.style.cssText = `
        color: #c8b896;
        font-size: 13px;
        font-family: Georgia, serif;
      `;
      categoryHeader.appendChild(categoryProgress);

      contentArea.appendChild(categoryHeader);

      // Render entries for this category
      var entriesContainer = document.createElement('div');
      entriesContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 15px;
      `;

      // Show all entries (unlocked and locked)
      for (var loreId in allLoreEntries) {
        var loreEntry = allLoreEntries[loreId];
        if (loreEntry.category !== category) continue;

        var isUnlocked = loreByCategory[category] && loreByCategory[category].some(function(e) { return e.id === loreId; });

        var entryDiv = document.createElement('div');
        entryDiv.className = isUnlocked ? 'lore-entry' : 'lore-entry lore-entry-locked';
        entryDiv.style.cssText = `
          background: ${isUnlocked ? 'rgba(212, 175, 55, 0.08)' : 'rgba(100, 80, 60, 0.15)'};
          border-left: 4px solid ${isUnlocked ? '#d4af37' : '#666'};
          padding: 18px 20px;
          border-radius: 6px;
          transition: background 0.2s ease;
          ${!isUnlocked ? 'filter: blur(0.5px); opacity: 0.6;' : ''}
        `;

        if (isUnlocked) {
          entryDiv.onmouseover = function() {
            this.style.background = 'rgba(212, 175, 55, 0.15)';
          };
          entryDiv.onmouseout = function() {
            this.style.background = 'rgba(212, 175, 55, 0.08)';
          };
        }

        var entryTitle = document.createElement('div');
        entryTitle.textContent = isUnlocked ? loreEntry.title : '???';
        entryTitle.style.cssText = `
          color: ${isUnlocked ? '#f4e4c1' : '#888'};
          font-size: 18px;
          font-weight: 600;
          margin-bottom: 10px;
          font-family: Georgia, serif;
        `;
        entryDiv.appendChild(entryTitle);

        var entryText = document.createElement('div');
        if (isUnlocked) {
          entryText.textContent = loreEntry.text;
          entryText.style.cssText = `
            color: #c8b896;
            font-size: 14px;
            line-height: 1.7;
            font-family: Georgia, serif;
          `;
        } else {
          // Show hint for locked entries
          entryText.textContent = 'Undiscovered... Explore the world to unlock this lore.';
          entryText.style.cssText = `
            color: #777;
            font-size: 13px;
            font-style: italic;
            line-height: 1.6;
            font-family: Georgia, serif;
          `;
        }
        entryDiv.appendChild(entryText);

        entriesContainer.appendChild(entryDiv);
      }

      contentArea.appendChild(entriesContainer);
    }

    // Create tabs
    categories.forEach(function(category) {
      var tab = document.createElement('button');
      tab.className = 'lore-category-tab';
      tab.textContent = category.charAt(0).toUpperCase() + category.slice(1);
      tab.style.cssText = `
        background: ${category === currentCategory ? 'rgba(212, 175, 55, 0.3)' : 'rgba(100, 80, 60, 0.2)'};
        border: 2px solid ${category === currentCategory ? '#d4af37' : '#666'};
        border-bottom: none;
        border-radius: 6px 6px 0 0;
        color: ${category === currentCategory ? '#f4e4c1' : '#a0978e'};
        padding: 10px 20px;
        font-size: 14px;
        font-family: Georgia, serif;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        font-weight: ${category === currentCategory ? '600' : '400'};
      `;

      tab.onclick = function() {
        currentCategory = category;
        // Update all tabs
        var allTabs = tabsContainer.querySelectorAll('.lore-category-tab');
        allTabs.forEach(function(t) {
          var isActive = t.textContent.toLowerCase() === category;
          t.style.background = isActive ? 'rgba(212, 175, 55, 0.3)' : 'rgba(100, 80, 60, 0.2)';
          t.style.borderColor = isActive ? '#d4af37' : '#666';
          t.style.color = isActive ? '#f4e4c1' : '#a0978e';
          t.style.fontWeight = isActive ? '600' : '400';
        });
        renderCategory(category);
      };

      tab.onmouseover = function() {
        if (this.textContent.toLowerCase() !== currentCategory) {
          this.style.background = 'rgba(139, 105, 20, 0.3)';
          this.style.color = '#d4af37';
        }
      };
      tab.onmouseout = function() {
        if (this.textContent.toLowerCase() !== currentCategory) {
          this.style.background = 'rgba(100, 80, 60, 0.2)';
          this.style.color = '#a0978e';
        }
      };

      tabsContainer.appendChild(tab);
    });

    panel.appendChild(tabsContainer);
    panel.appendChild(contentArea);

    // Render initial category
    renderCategory(currentCategory);

    document.body.appendChild(panel);
    loreBookPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideLoreJournal();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideLoreJournal() {
    if (!loreBookPanel) return;
    if (loreBookPanel.escapeHandler) {
      document.removeEventListener('keydown', loreBookPanel.escapeHandler);
    }
    loreBookPanel.classList.remove('visible');
    setTimeout(function() {
      if (loreBookPanel && loreBookPanel.parentNode) {
        document.body.removeChild(loreBookPanel);
        loreBookPanel = null;
      }
    }, 250);
  }

  function toggleLoreJournal(playerId, state) {
    if (loreBookPanel) {
      hideLoreJournal();
    } else {
      showLoreJournal(playerId, state);
    }
  }

  // Legacy compatibility - keep old function names
  function showLoreBook(playerId, state) {
    showLoreJournal(playerId, state);
  }

  function hideLoreBook() {
    hideLoreJournal();
  }

  // Achievement Toast
  function showAchievementToast(achievement) {
    if (typeof document === 'undefined') return;

    var toast = document.createElement('div');
    toast.className = 'achievement-toast';

    var icon = document.createElement('div');
    icon.className = 'achievement-toast-icon';
    icon.textContent = achievement.icon || 'â­';

    var textContainer = document.createElement('div');
    textContainer.className = 'achievement-toast-text';

    var label = document.createElement('div');
    label.className = 'achievement-toast-label';
    label.textContent = 'ACHIEVEMENT UNLOCKED';

    var achievementName = document.createElement('div');
    achievementName.className = 'achievement-toast-name';
    achievementName.textContent = achievement.name || 'Unknown Achievement';

    textContainer.appendChild(label);
    textContainer.appendChild(achievementName);

    toast.appendChild(icon);
    toast.appendChild(textContainer);
    document.body.appendChild(toast);

    // Auto-remove after animation completes (4s total: 0.4s slide + 3s stay + 0.5s fade)
    setTimeout(function() {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 4000);
  }

  // Discovery Popup
  function showDiscoveryPopup(discovery) {
    var popup = document.createElement('div');
    popup.className = 'discovery-popup';
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #5dade2;
      border-radius: 12px;
      padding: 30px;
      min-width: 400px;
      box-shadow: 0 0 50px rgba(93, 173, 226, 0.6);
      z-index: 10001;
    `;

    var header = document.createElement('div');
    header.textContent = 'NEW DISCOVERY';
    header.style.cssText = `
      color: #ffd700;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 15px;
      font-family: system-ui, sans-serif;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    `;

    var rarityColors = {
      common: '#ffffff',
      uncommon: '#1eff00',
      rare: '#0070dd',
      epic: '#a335ee',
      legendary: '#ff8000'
    };
    var color = rarityColors[discovery.rarity] || '#ffffff';

    var discoveryName = document.createElement('div');
    discoveryName.textContent = discovery.name || 'Unknown Discovery';
    discoveryName.style.cssText = `
      color: ` + color + `;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
      font-family: system-ui, sans-serif;
      text-shadow: 0 0 10px ` + color + `;
    `;

    var discoveryDesc = document.createElement('div');
    discoveryDesc.textContent = discovery.description || '';
    discoveryDesc.style.cssText = `
      color: #e0e0e0;
      font-size: 16px;
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.5;
      font-family: system-ui, sans-serif;
    `;

    var rewardText = document.createElement('div');
    rewardText.textContent = '+ ' + (discovery.sparkReward || 0) + ' Spark';
    rewardText.style.cssText = `
      color: #ffd700;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      font-family: system-ui, sans-serif;
    `;

    popup.appendChild(header);
    popup.appendChild(discoveryName);
    popup.appendChild(discoveryDesc);
    popup.appendChild(rewardText);
    document.body.appendChild(popup);

    // Animate in
    requestAnimationFrame(function() {
      popup.classList.add('visible');
    });

    // Auto-close after 4 seconds
    setTimeout(function() {
      popup.classList.remove('visible');
      setTimeout(function() {
        if (popup.parentNode) {
          document.body.removeChild(popup);
        }
      }, 300);
    }, 4000);

    // Click to close
    popup.onclick = function() {
      popup.classList.remove('visible');
      setTimeout(function() {
        if (popup.parentNode) {
          document.body.removeChild(popup);
        }
      }, 300);
    };
  }

  // ============================================================================
  // SKILLS PANEL
  // ============================================================================

  var skillsPanel = null;

  function showSkillsPanel(skillsData) {
    if (skillsPanel) return;

    var panel = document.createElement('div');
    panel.id = 'skills-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(100, 150, 255, 0.3);
      border-radius: 12px;
      padding: 25px;
      width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 10000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.innerHTML = '<h2 style="margin: 0 0 20px 0; color: #fff; font-size: 24px;">Skills</h2>';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
    `;
    closeBtn.onclick = hideSkillsPanel;
    panel.appendChild(closeBtn);

    for (var skillName in skillsData) {
      var skill = skillsData[skillName];
      var skillDiv = document.createElement('div');
      skillDiv.style.cssText = `
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
      `;

      var skillHeader = document.createElement('div');
      skillHeader.innerHTML = `
        <span style="color: #4af; font-weight: bold; font-size: 16px;">${skillName.charAt(0).toUpperCase() + skillName.slice(1)}</span>
        <span style="color: #888; float: right;">${skill.levelName} (Level ${skill.level})</span>
      `;
      skillDiv.appendChild(skillHeader);

      var xpBar = document.createElement('div');
      xpBar.style.cssText = `
        margin-top: 8px;
        width: 100%;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      `;

      var nextLevelXP = 1000;
      var currentLevelXP = 0;
      if (typeof window !== 'undefined' && window.Mentoring && window.Mentoring.SKILLS) {
        var skillConfig = window.Mentoring.SKILLS[skillName];
        if (skillConfig && skill.level < skillConfig.xpPerLevel.length - 1) {
          nextLevelXP = skillConfig.xpPerLevel[skill.level + 1];
          currentLevelXP = skillConfig.xpPerLevel[skill.level];
        }
      }

      var xpProgress = skill.xp - currentLevelXP;
      var xpNeeded = nextLevelXP - currentLevelXP;
      var progressPercent = skill.level >= 4 ? 100 : Math.min(100, (xpProgress / xpNeeded) * 100);

      var xpFill = document.createElement('div');
      xpFill.style.cssText = `
        width: ${progressPercent}%;
        height: 100%;
        background: linear-gradient(90deg, #4af, #a8f);
        transition: width 0.3s ease;
      `;
      xpBar.appendChild(xpFill);

      var xpText = document.createElement('div');
      xpText.textContent = skill.level >= 4 ? 'MAX LEVEL' : skill.xp + ' / ' + nextLevelXP + ' XP';
      xpText.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 11px;
        font-weight: bold;
      `;
      xpBar.appendChild(xpText);

      skillDiv.appendChild(xpBar);
      panel.appendChild(skillDiv);
    }

    document.body.appendChild(panel);
    skillsPanel = panel;
  }

  function hideSkillsPanel() {
    if (!skillsPanel) return;
    document.body.removeChild(skillsPanel);
    skillsPanel = null;
  }

  // ============================================================================
  // MENTOR OFFER PANEL
  // ============================================================================

  var mentorOfferPanel = null;

  function showMentorOffer(offerData, acceptCallback, declineCallback) {
    if (mentorOfferPanel) return;

    var panel = document.createElement('div');
    panel.id = 'mentor-offer-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(255, 200, 100, 0.5);
      border-radius: 12px;
      padding: 25px;
      width: 400px;
      z-index: 10001;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      text-align: center;
      pointer-events: auto;
    `;

    panel.innerHTML = `
      <h3 style="color: #ffa500; margin: 0 0 15px 0;">Mentorship Offer</h3>
      <p style="color: #fff; margin-bottom: 10px;">
        <strong>${offerData.mentorId}</strong> wants to mentor you in <strong>${offerData.skill}</strong>
      </p>
      <p style="color: #888; font-size: 13px; margin-bottom: 20px;">
        Complete 5 lesson steps to gain XP and unlock advanced techniques.
      </p>
    `;

    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center;';

    var acceptBtn = document.createElement('button');
    acceptBtn.textContent = 'Accept';
    acceptBtn.style.cssText = `
      padding: 10px 24px;
      background: linear-gradient(135deg, #4af, #a8f);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    `;
    acceptBtn.onclick = function() {
      acceptCallback(offerData.id);
      document.body.removeChild(mentorOfferPanel);
      mentorOfferPanel = null;
    };

    var declineBtn = document.createElement('button');
    declineBtn.textContent = 'Decline';
    declineBtn.style.cssText = `
      padding: 10px 24px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
    `;
    declineBtn.onclick = function() {
      declineCallback(offerData.id);
      document.body.removeChild(mentorOfferPanel);
      mentorOfferPanel = null;
    };

    buttonContainer.appendChild(acceptBtn);
    buttonContainer.appendChild(declineBtn);
    panel.appendChild(buttonContainer);

    document.body.appendChild(panel);
    mentorOfferPanel = panel;
  }

  // ============================================================================
  // LESSON PROGRESS PANEL
  // ============================================================================

  var lessonProgressPanel = null;

  function showLessonProgress(mentorshipData) {
    if (lessonProgressPanel) {
      document.body.removeChild(lessonProgressPanel);
      lessonProgressPanel = null;
    }

    var panel = document.createElement('div');
    panel.id = 'lesson-progress-panel';
    panel.style.cssText = `
      position: fixed;
      top: 120px;
      right: 20px;
      background: rgba(20, 25, 35, 0.95);
      border: 2px solid rgba(255, 200, 100, 0.5);
      border-radius: 8px;
      padding: 15px;
      width: 300px;
      z-index: 9999;
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var progress = mentorshipData.stepsCompleted / mentorshipData.totalSteps;
    var progressPercent = Math.round(progress * 100);

    panel.innerHTML = `
      <h4 style="color: #ffa500; margin: 0 0 10px 0; font-size: 14px;">Mentorship Progress</h4>
      <p style="color: #fff; font-size: 13px; margin: 5px 0;">
        <strong>${mentorshipData.skill}</strong>
      </p>
      <p style="color: #888; font-size: 12px; margin: 5px 0;">
        Steps: ${mentorshipData.stepsCompleted} / ${mentorshipData.totalSteps}
      </p>
      <div style="width: 100%; height: 16px; background: rgba(0,0,0,0.5); border-radius: 8px; overflow: hidden; margin-top: 8px;">
        <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg, #ffa500, #ffcc00);"></div>
      </div>
    `;

    document.body.appendChild(panel);
    lessonProgressPanel = panel;
  }

  // ============================================================================
  // COMPOSE PANEL - Music Composition System
  // ============================================================================

  var composePanel = null;
  var audioContext = null;
  var recordedNotes = [];
  var isRecording = false;
  var recordingStartTime = 0;
  var currentInstrument = 'sine';

  // Note frequency map for C4 to C6 (2 octaves + middle C)
  var noteFrequencies = {
    'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
    'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
    'C6': 1046.50
  };

  var noteOrder = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5', 'C6'];

  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContext;
  }

  function playNote(noteName, duration) {
    var ctx = initAudioContext();
    var frequency = noteFrequencies[noteName];
    if (!frequency) return;

    var oscillator = ctx.createOscillator();
    var gainNode = ctx.createGain();

    oscillator.type = currentInstrument;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + (duration || 0.5));

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + (duration || 0.5));
  }

  function playComposition(notes) {
    if (!notes || notes.length === 0) {
      showNotification('No notes to play', 'warning');
      return;
    }

    var ctx = initAudioContext();
    var currentTime = ctx.currentTime;

    notes.forEach(function(note) {
      var startTime = currentTime + (note.time / 1000);
      var frequency = noteFrequencies[note.note];
      if (!frequency) return;

      var oscillator = ctx.createOscillator();
      var gainNode = ctx.createGain();

      oscillator.type = note.instrument || 'sine';
      oscillator.frequency.setValueAtTime(frequency, startTime);

      gainNode.gain.setValueAtTime(0.3, startTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.5);

      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);

      oscillator.start(startTime);
      oscillator.stop(startTime + 0.5);
    });
  }

  function showComposePanel(composeCallback) {
    if (composePanel) return;

    var panel = document.createElement('div');
    panel.id = 'compose-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(212, 175, 55, 0.7);
      border-radius: 12px;
      padding: 25px;
      width: 800px;
      z-index: 10000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.innerHTML = '<h2 style="margin: 0 0 20px 0; color: #d4af37; font-size: 24px;">Compose Music</h2>';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(212, 175, 55, 0.2);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.5);
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    `;
    closeBtn.onclick = hideComposePanel;
    panel.appendChild(closeBtn);

    var form = document.createElement('div');

    // Instrument selector
    var instrumentLabel = document.createElement('label');
    instrumentLabel.textContent = 'Instrument:';
    instrumentLabel.style.cssText = 'display: block; color: #d4af37; margin-bottom: 5px; font-size: 14px; font-weight: bold;';
    form.appendChild(instrumentLabel);

    var instrumentSelect = document.createElement('select');
    instrumentSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      margin-bottom: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    `;

    var instruments = [
      { value: 'sine', label: 'Flute (Sine)' },
      { value: 'triangle', label: 'Soft Tone (Triangle)' },
      { value: 'square', label: 'Reed (Square)' },
      { value: 'sawtooth', label: 'Strings (Sawtooth)' }
    ];

    instruments.forEach(function(inst) {
      var option = document.createElement('option');
      option.value = inst.value;
      option.textContent = inst.label;
      instrumentSelect.appendChild(option);
    });

    instrumentSelect.onchange = function() {
      currentInstrument = instrumentSelect.value;
    };
    form.appendChild(instrumentSelect);

    // Piano keyboard
    var keyboardContainer = document.createElement('div');
    keyboardContainer.style.cssText = `
      display: flex;
      justify-content: center;
      gap: 4px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      flex-wrap: wrap;
    `;

    noteOrder.forEach(function(noteName) {
      var key = document.createElement('button');
      var isBlackKey = noteName.includes('C') || noteName.includes('F');

      key.textContent = noteName;
      key.style.cssText = `
        padding: 40px 12px;
        background: ${isBlackKey ? 'linear-gradient(135deg, #d4af37, #f4d03f)' : 'linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(230, 230, 230, 0.9))'};
        color: ${isBlackKey ? '#000' : '#333'};
        border: 2px solid ${isBlackKey ? '#d4af37' : '#999'};
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 12px;
        min-width: 45px;
        transition: all 0.1s;
      `;

      key.onmousedown = function() {
        key.style.transform = 'scale(0.95)';
        key.style.boxShadow = '0 0 10px rgba(212, 175, 55, 0.8)';
        playNote(noteName, 0.5);

        if (isRecording) {
          var currentTime = Date.now() - recordingStartTime;
          recordedNotes.push({
            note: noteName,
            time: currentTime,
            instrument: currentInstrument
          });
          updateNoteDisplay();
        }
      };

      key.onmouseup = function() {
        key.style.transform = 'scale(1)';
        key.style.boxShadow = 'none';
      };

      key.onmouseleave = function() {
        key.style.transform = 'scale(1)';
        key.style.boxShadow = 'none';
      };

      keyboardContainer.appendChild(key);
    });

    form.appendChild(keyboardContainer);

    // Control buttons
    var controlsContainer = document.createElement('div');
    controlsContainer.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    `;

    var recordBtn = document.createElement('button');
    recordBtn.textContent = 'Record';
    recordBtn.id = 'record-btn';
    recordBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #ff4444, #cc0000);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    recordBtn.onclick = function() {
      if (!isRecording) {
        isRecording = true;
        recordedNotes = [];
        recordingStartTime = Date.now();
        recordBtn.textContent = 'Stop Recording';
        recordBtn.style.background = 'linear-gradient(135deg, #ff8844, #ff4400)';
        showNotification('Recording started...', 'info');
      } else {
        isRecording = false;
        recordBtn.textContent = 'Record';
        recordBtn.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
        showNotification('Recording stopped. ' + recordedNotes.length + ' notes captured.', 'success');
      }
    };
    controlsContainer.appendChild(recordBtn);

    var playbackBtn = document.createElement('button');
    playbackBtn.textContent = 'Playback';
    playbackBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #44ff44, #00cc00);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    playbackBtn.onclick = function() {
      if (recordedNotes.length === 0) {
        showNotification('No notes recorded yet', 'warning');
        return;
      }
      playComposition(recordedNotes);
      showNotification('Playing composition...', 'info');
    };
    controlsContainer.appendChild(playbackBtn);

    var clearBtn = document.createElement('button');
    clearBtn.textContent = 'Clear';
    clearBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #ff9944, #cc6600);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    clearBtn.onclick = function() {
      recordedNotes = [];
      isRecording = false;
      var recordButton = document.getElementById('record-btn');
      if (recordButton) {
        recordButton.textContent = 'Record';
        recordButton.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
      }
      updateNoteDisplay();
      showNotification('Composition cleared', 'info');
    };
    controlsContainer.appendChild(clearBtn);

    form.appendChild(controlsContainer);

    // Note display
    var noteDisplayLabel = document.createElement('label');
    noteDisplayLabel.textContent = 'Composition:';
    noteDisplayLabel.style.cssText = 'display: block; color: #d4af37; margin-bottom: 5px; font-size: 14px; font-weight: bold;';
    form.appendChild(noteDisplayLabel);

    var noteDisplay = document.createElement('div');
    noteDisplay.id = 'note-display';
    noteDisplay.style.cssText = `
      width: 100%;
      min-height: 60px;
      padding: 15px;
      margin-bottom: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 6px;
      font-size: 14px;
      font-family: monospace;
      overflow-x: auto;
      white-space: nowrap;
    `;
    noteDisplay.textContent = 'No notes recorded yet...';
    form.appendChild(noteDisplay);

    function updateNoteDisplay() {
      var display = document.getElementById('note-display');
      if (!display) return;

      if (recordedNotes.length === 0) {
        display.textContent = 'No notes recorded yet...';
        return;
      }

      var noteSequence = recordedNotes.map(function(n) {
        return n.note;
      }).join(' - ');

      display.textContent = noteSequence + ' (' + recordedNotes.length + ' notes)';
    }

    // Save button
    var saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save Composition';
    saveBtn.style.cssText = `
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #d4af37, #f4d03f);
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    `;
    saveBtn.onclick = function() {
      if (recordedNotes.length === 0) {
        showNotification('Please record some notes first', 'warning');
        return;
      }

      if (isRecording) {
        showNotification('Please stop recording first', 'warning');
        return;
      }

      var composition = {
        notes: recordedNotes,
        instrument: currentInstrument,
        timestamp: Date.now()
      };

      if (composeCallback) {
        composeCallback(composition);
      }

      showNotification('Composition saved!', 'success');
      hideComposePanel();
    };
    form.appendChild(saveBtn);

    panel.appendChild(form);
    document.body.appendChild(panel);
    composePanel = panel;

    // Reset state
    recordedNotes = [];
    isRecording = false;
    currentInstrument = 'sine';
  }

  function hideComposePanel() {
    if (!composePanel) return;
    document.body.removeChild(composePanel);
    composePanel = null;
    recordedNotes = [];
    isRecording = false;
  }

  // Guild Panel
  var guildPanel = null;
  var guildCreatePanel = null;
  var guildInvitePanel = null;

  function showGuildPanel(guildData, playerData) {
    if (guildPanel) {
      hideGuildPanel();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'guild-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 700px;
      max-height: 80vh;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      overflow-y: auto;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideGuildPanel;
    panel.appendChild(closeBtn);

    // Header
    var header = document.createElement('div');
    header.style.cssText = `
      margin-bottom: 25px;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;

    var title = document.createElement('h2');
    title.textContent = '[' + guildData.tag + '] ' + guildData.name;
    title.style.cssText = `
      color: #DAA520;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      margin: 0 0 8px 0;
      font-weight: bold;
    `;
    header.appendChild(title);

    var subtitle = document.createElement('div');
    subtitle.textContent = guildData.type.charAt(0).toUpperCase() + guildData.type.slice(1) +
                          ' â€¢ Level ' + guildData.level + ' â€¢ ' + guildData.members.length + '/' +
                          guildData.maxMembers + ' members';
    subtitle.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    header.appendChild(subtitle);

    if (guildData.description) {
      var desc = document.createElement('div');
      desc.textContent = guildData.description;
      desc.style.cssText = `
        color: #D4C5B3;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        margin-top: 12px;
        font-style: italic;
      `;
      header.appendChild(desc);
    }

    panel.appendChild(header);

    // Stats section
    var statsGrid = document.createElement('div');
    statsGrid.style.cssText = `
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 25px;
    `;

    var stats = [
      { label: 'Treasury', value: guildData.treasury + ' Spark' },
      { label: 'Guild XP', value: guildData.xp },
      { label: 'Home Zone', value: guildData.zone }
    ];

    stats.forEach(function(stat) {
      var statBox = document.createElement('div');
      statBox.style.cssText = `
        background: rgba(218, 165, 32, 0.1);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 12px;
        text-align: center;
      `;

      var statLabel = document.createElement('div');
      statLabel.textContent = stat.label;
      statLabel.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
        margin-bottom: 5px;
      `;
      statBox.appendChild(statLabel);

      var statValue = document.createElement('div');
      statValue.textContent = stat.value;
      statValue.style.cssText = `
        color: #DAA520;
        font-size: 18px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
      `;
      statBox.appendChild(statValue);

      statsGrid.appendChild(statBox);
    });

    panel.appendChild(statsGrid);

    // Members section
    var membersSection = document.createElement('div');
    membersSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var membersTitle = document.createElement('h3');
    membersTitle.textContent = 'Members';
    membersTitle.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    membersSection.appendChild(membersTitle);

    var membersList = document.createElement('div');
    membersList.style.cssText = `
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 10px;
    `;

    guildData.members.forEach(function(member) {
      var memberItem = document.createElement('div');
      memberItem.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        margin-bottom: 5px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
      `;

      var memberInfo = document.createElement('div');
      memberInfo.style.cssText = `
        color: #E8E0D8;
        font-size: 14px;
        font-family: system-ui, sans-serif;
      `;
      memberInfo.textContent = member.playerId + (member.playerId === playerData.id ? ' (You)' : '');
      memberItem.appendChild(memberInfo);

      var roleTag = document.createElement('span');
      roleTag.textContent = member.role.toUpperCase();
      roleTag.style.cssText = `
        color: ${member.role === 'leader' ? '#FFD700' : member.role === 'officer' ? '#C0C0C0' : '#8B7355'};
        font-size: 11px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        padding: 3px 8px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 3px;
      `;
      memberItem.appendChild(roleTag);

      membersList.appendChild(memberItem);
    });

    membersSection.appendChild(membersList);
    panel.appendChild(membersSection);

    // Activities section
    var activitiesSection = document.createElement('div');
    activitiesSection.style.cssText = `
      margin-bottom: 15px;
    `;

    var activitiesTitle = document.createElement('h3');
    activitiesTitle.textContent = 'Recent Activity';
    activitiesTitle.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    activitiesSection.appendChild(activitiesTitle);

    var activitiesList = document.createElement('div');
    activitiesList.style.cssText = `
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 10px;
    `;

    var activities = guildData.activities.slice(-10).reverse();
    activities.forEach(function(activity) {
      var activityItem = document.createElement('div');
      activityItem.textContent = 'â€¢ ' + activity.text;
      activityItem.style.cssText = `
        color: #A0978E;
        font-size: 13px;
        font-family: system-ui, sans-serif;
        padding: 4px 0;
        line-height: 1.4;
      `;
      activitiesList.appendChild(activityItem);
    });

    if (activities.length === 0) {
      var noActivity = document.createElement('div');
      noActivity.textContent = 'No recent activity';
      noActivity.style.cssText = `
        color: #6B6B6B;
        font-size: 13px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 20px;
      `;
      activitiesList.appendChild(noActivity);
    }

    activitiesSection.appendChild(activitiesList);
    panel.appendChild(activitiesSection);

    // Action buttons
    var actionsDiv = document.createElement('div');
    actionsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-top: 20px;
    `;

    var leaveBtn = document.createElement('button');
    leaveBtn.textContent = 'Leave Guild';
    leaveBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: rgba(139, 0, 0, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(255, 69, 0, 0.5);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    leaveBtn.onmouseover = function() {
      this.style.background = 'rgba(139, 0, 0, 0.8)';
      this.style.borderColor = '#FF4500';
    };
    leaveBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 0, 0, 0.6)';
      this.style.borderColor = 'rgba(255, 69, 0, 0.5)';
    };
    leaveBtn.onclick = function() {
      if (confirm('Are you sure you want to leave the guild?')) {
        if (window.handleGuildAction) {
          window.handleGuildAction('leave', guildData.id);
        }
        hideGuildPanel();
      }
    };
    actionsDiv.appendChild(leaveBtn);

    panel.appendChild(actionsDiv);

    document.body.appendChild(panel);
    guildPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });
  }

  function hideGuildPanel() {
    if (!guildPanel) return;
    guildPanel.classList.remove('visible');
    setTimeout(function() {
      if (guildPanel && guildPanel.parentNode) {
        document.body.removeChild(guildPanel);
        guildPanel = null;
      }
    }, 250);
  }

  function showGuildCreate(callback) {
    if (guildCreatePanel) {
      hideGuildCreate();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'guild-create-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideGuildCreate;
    panel.appendChild(closeBtn);

    // Title
    var title = document.createElement('h2');
    title.textContent = 'Create Guild';
    title.style.cssText = `
      color: #DAA520;
      font-size: 24px;
      font-family: system-ui, sans-serif;
      margin: 0 0 20px 0;
      font-weight: bold;
    `;
    panel.appendChild(title);

    // Form
    var form = document.createElement('div');
    form.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 15px;
    `;

    // Guild name input
    var nameLabel = document.createElement('label');
    nameLabel.textContent = 'Guild Name';
    nameLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(nameLabel);

    var nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Enter guild name';
    nameInput.maxLength = 30;
    nameInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    form.appendChild(nameInput);

    // Guild tag input
    var tagLabel = document.createElement('label');
    tagLabel.textContent = 'Guild Tag (3-5 characters)';
    tagLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(tagLabel);

    var tagInput = document.createElement('input');
    tagInput.type = 'text';
    tagInput.placeholder = 'e.g., ZON';
    tagInput.maxLength = 5;
    tagInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      text-transform: uppercase;
    `;
    form.appendChild(tagInput);

    // Guild type select
    var typeLabel = document.createElement('label');
    typeLabel.textContent = 'Type';
    typeLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(typeLabel);

    var typeSelect = document.createElement('select');
    typeSelect.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;

    ['guild', 'garden', 'studio', 'community'].forEach(function(type) {
      var option = document.createElement('option');
      option.value = type;
      option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
      typeSelect.appendChild(option);
    });

    form.appendChild(typeSelect);

    // Description textarea
    var descLabel = document.createElement('label');
    descLabel.textContent = 'Description (optional)';
    descLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(descLabel);

    var descInput = document.createElement('textarea');
    descInput.placeholder = 'Describe your guild...';
    descInput.maxLength = 200;
    descInput.rows = 3;
    descInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      resize: vertical;
    `;
    form.appendChild(descInput);

    // Cost notice
    var costNotice = document.createElement('div');
    costNotice.textContent = 'Cost: 100 Spark';
    costNotice.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      background: rgba(218, 165, 32, 0.1);
      border-radius: 6px;
    `;
    form.appendChild(costNotice);

    // Create button
    var createBtn = document.createElement('button');
    createBtn.textContent = 'Create Guild';
    createBtn.style.cssText = `
      padding: 12px;
      background: rgba(218, 165, 32, 0.3);
      color: #E8E0D8;
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 6px;
      font-size: 16px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    createBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.5)';
      this.style.borderColor = '#DAA520';
    };
    createBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = 'rgba(218, 165, 32, 0.5)';
    };
    createBtn.onclick = function() {
      var name = nameInput.value.trim();
      var tag = tagInput.value.trim().toUpperCase();
      var type = typeSelect.value;
      var description = descInput.value.trim();

      if (!name || !tag) {
        alert('Please enter guild name and tag');
        return;
      }

      if (tag.length < 3 || tag.length > 5) {
        alert('Tag must be 3-5 characters');
        return;
      }

      if (callback) {
        callback({ name: name, tag: tag, type: type, description: description });
      }

      hideGuildCreate();
    };
    form.appendChild(createBtn);

    panel.appendChild(form);

    document.body.appendChild(panel);
    guildCreatePanel = panel;
  }

  function hideGuildCreate() {
    if (!guildCreatePanel) return;
    document.body.removeChild(guildCreatePanel);
    guildCreatePanel = null;
  }

  function showGuildInvite(inviteData, callback) {
    if (guildInvitePanel) return;

    var panel = document.createElement('div');
    panel.id = 'guild-invite-panel';
    panel.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      width: 350px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 400;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 20px;
    `;

    // Title
    var title = document.createElement('h3');
    title.textContent = 'Guild Invitation';
    title.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    panel.appendChild(title);

    // Message
    var message = document.createElement('div');
    message.textContent = 'You have been invited to join [' + inviteData.guildTag + '] ' + inviteData.guildName;
    message.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
      line-height: 1.5;
    `;
    panel.appendChild(message);

    // Buttons
    var buttonsDiv = document.createElement('div');
    buttonsDiv.style.cssText = `
      display: flex;
      gap: 10px;
    `;

    var acceptBtn = document.createElement('button');
    acceptBtn.textContent = 'Accept';
    acceptBtn.style.cssText = `
      flex: 1;
      padding: 10px;
      background: rgba(34, 139, 34, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(34, 139, 34, 0.8);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    acceptBtn.onmouseover = function() {
      this.style.background = 'rgba(34, 139, 34, 0.8)';
    };
    acceptBtn.onmouseout = function() {
      this.style.background = 'rgba(34, 139, 34, 0.6)';
    };
    acceptBtn.onclick = function() {
      if (callback) {
        callback('accept', inviteData);
      }
      document.body.removeChild(panel);
      guildInvitePanel = null;
    };
    buttonsDiv.appendChild(acceptBtn);

    var declineBtn = document.createElement('button');
    declineBtn.textContent = 'Decline';
    declineBtn.style.cssText = `
      flex: 1;
      padding: 10px;
      background: rgba(139, 0, 0, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(255, 69, 0, 0.5);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    declineBtn.onmouseover = function() {
      this.style.background = 'rgba(139, 0, 0, 0.8)';
    };
    declineBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 0, 0, 0.6)';
    };
    declineBtn.onclick = function() {
      if (callback) {
        callback('decline', inviteData);
      }
      document.body.removeChild(panel);
      guildInvitePanel = null;
    };
    buttonsDiv.appendChild(declineBtn);

    panel.appendChild(buttonsDiv);

    document.body.appendChild(panel);
    guildInvitePanel = panel;
  }

  function updateGuildTag(tag) {
    var playerNameEl = document.getElementById('player-name');
    if (playerNameEl && tag) {
      var currentName = playerNameEl.textContent;
      // Remove existing tag if present
      currentName = currentName.replace(/\[.*?\]\s*/, '');
      playerNameEl.textContent = '[' + tag + '] ' + currentName;
    }
  }

  // ========================================================================
  // GOVERNANCE PANEL (Zone Stewards & Elections)
  // ========================================================================

  var governancePanel = null;
  var governanceVisible = false;
  var governanceCallback = null;

  function initGovernancePanel(callback) {
    if (typeof document === 'undefined') return;
    governanceCallback = callback;
  }

  function showGovernancePanel(zoneId, playerData) {
    if (typeof document === 'undefined') return;

    var Social = typeof window !== 'undefined' ? window.Social : null;
    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    if (!Social || !Zones) return;

    hideGovernancePanel();

    governancePanel = document.createElement('div');
    governancePanel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #daa520;border-radius:12px;' +
      'padding:20px;width:700px;max-height:80vh;overflow-y:auto;z-index:300;' +
      'box-shadow:0 4px 30px rgba(218,165,32,0.3);pointer-events:auto;';

    var zone = Zones.getZone(zoneId);
    var stewards = Zones.getZoneStewards(zoneId);
    var policies = Zones.getZonePolicies(zoneId);
    var activeElection = Zones.getActiveElection(zoneId);
    var reputation = Social.getReputation(playerData.id);
    var isRegular = Zones.isZoneRegular(zoneId, playerData.id);
    var isSteward = Zones.isZoneSteward(zoneId, playerData.id);

    var html = '<div style="font-size:24px;font-weight:bold;margin-bottom:10px;text-align:center;color:#daa520;">' +
      zone.name + ' Governance</div>';

    html += '<div style="margin-bottom:15px;color:#b0e0e6;text-align:center;font-size:12px;">' +
      'Your Reputation: ' + reputation.tier + ' (' + reputation.score + ' points)</div>';

    // Stewards section
    html += '<div style="margin-bottom:20px;">';
    html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#4af;border-bottom:1px solid #4af;padding-bottom:4px;">Current Stewards</div>';
    if (stewards.length > 0) {
      html += '<div style="display:flex;flex-direction:column;gap:8px;">';
      stewards.forEach(function(s) {
        var daysLeft = Math.ceil((s.termEnd - Date.now()) / 86400000);
        html += '<div style="background:rgba(74,170,255,0.1);padding:10px;border-radius:6px;border-left:3px solid #4af;">' +
          '<div style="font-weight:bold;">' + s.playerId + '</div>' +
          '<div style="font-size:11px;color:#aaa;">' + s.votes + ' votes â€¢ ' + daysLeft + ' days remaining</div>' +
          '</div>';
      });
      html += '</div>';
    } else {
      html += '<div style="color:#888;font-style:italic;padding:10px;">No active stewards. Start an election!</div>';
    }
    html += '</div>';

    // Zone Policies section
    if (isSteward) {
      html += '<div style="margin-bottom:20px;">';
      html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#fa4;border-bottom:1px solid #fa4;padding-bottom:4px;">Zone Policies (Steward)</div>';
      html += '<div style="background:rgba(255,170,68,0.1);padding:12px;border-radius:6px;">';
      html += '<label style="display:block;margin-bottom:8px;cursor:pointer;">' +
        '<input type="checkbox" id="policy-building" ' + (policies.buildingRequiresApproval ? 'checked' : '') + '> Building requires approval</label>';
      html += '<label style="display:block;margin-bottom:8px;cursor:pointer;">' +
        '<input type="checkbox" id="policy-moderated" ' + (policies.chatModerated ? 'checked' : '') + '> Chat moderated</label>';
      html += '<div style="margin-top:10px;"><input type="text" id="welcome-message" placeholder="Zone welcome message..." ' +
        'value="' + (policies.welcomeMessage || '').replace(/"/g, '&quot;') + '" style="width:100%;padding:8px;background:rgba(0,0,0,0.3);' +
        'border:1px solid #666;border-radius:4px;color:#fff;"></div>';
      html += '<button id="save-policies-btn" style="margin-top:10px;padding:8px 16px;background:#fa4;border:none;' +
        'border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Save Policies</button>';
      html += '</div>';
      html += '</div>';
    } else if (policies.welcomeMessage) {
      html += '<div style="margin-bottom:20px;padding:12px;background:rgba(218,165,32,0.1);border-radius:6px;border-left:3px solid #daa520;">';
      html += '<div style="font-size:14px;font-weight:bold;color:#daa520;margin-bottom:4px;">Welcome Message</div>';
      html += '<div style="font-size:12px;color:#ccc;">' + policies.welcomeMessage + '</div>';
      html += '</div>';
    }

    // Election section
    html += '<div style="margin-bottom:20px;">';
    html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#4af;border-bottom:1px solid #4af;padding-bottom:4px;">Elections</div>';
    if (activeElection) {
      var timeLeft = Math.ceil((activeElection.endTime - Date.now()) / 3600000);
      html += '<div style="background:rgba(74,170,255,0.1);padding:12px;border-radius:6px;margin-bottom:10px;">';
      html += '<div style="font-weight:bold;margin-bottom:8px;">Active Election (' + timeLeft + ' hours left)</div>';
      html += '<div style="display:flex;flex-direction:column;gap:6px;">';
      activeElection.candidates.forEach(function(c) {
        var hasVoted = isRegular && c.voters && c.voters.has(playerData.id);
        html += '<div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:4px;display:flex;justify-content:space-between;align-items:center;">' +
          '<span>' + c.playerId + '</span>' +
          '<span style="color:#4af;font-weight:bold;">' + c.votes + ' votes</span>' +
          (isRegular && !hasVoted ? '<button class="vote-btn" data-candidate="' + c.playerId + '" data-election="' + activeElection.id + '" ' +
          'style="padding:4px 12px;background:#4af;border:none;border-radius:4px;color:#000;cursor:pointer;font-size:11px;">Vote</button>' : '') +
          (hasVoted ? '<span style="color:#4a4;font-size:11px;">Voted</span>' : '') +
          '</div>';
      });
      html += '</div></div>';

      if (isRegular) {
        html += '<div style="font-size:11px;color:#aaa;margin-top:8px;">You can vote as a zone regular.</div>';
      } else {
        html += '<div style="font-size:11px;color:#888;margin-top:8px;">Visit this zone 5+ times to vote in elections.</div>';
      }
    } else {
      var canRunForSteward = reputation.tier === 'Respected' || reputation.tier === 'Honored' || reputation.tier === 'Elder';
      html += '<div style="color:#888;font-style:italic;margin-bottom:10px;">No active election.</div>';
      if (canRunForSteward) {
        html += '<button id="start-election-btn" style="padding:8px 16px;background:#4af;border:none;' +
          'border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Start Election</button>';
      } else {
        html += '<div style="font-size:11px;color:#888;">Reach Respected tier to run for steward.</div>';
      }
    }
    html += '</div>';

    // Governance Log section
    var log = Zones.getGovernanceLog(zoneId, 10);
    if (log.length > 0) {
      html += '<div style="margin-bottom:20px;">';
      html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#888;border-bottom:1px solid #666;padding-bottom:4px;">Recent Actions</div>';
      html += '<div style="display:flex;flex-direction:column;gap:4px;max-height:150px;overflow-y:auto;">';
      log.forEach(function(action) {
        var timeAgo = Math.floor((Date.now() - action.timestamp) / 60000);
        html += '<div style="font-size:11px;color:#aaa;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.05);">' +
          '<span style="color:#4af;">' + action.type + '</span> by ' + (action.stewardId || action.from || 'system') + ' â€” ' + timeAgo + 'm ago</div>';
      });
      html += '</div></div>';
    }

    // Close button
    html += '<div style="text-align:center;margin-top:20px;">' +
      '<button id="close-governance-btn" style="padding:10px 24px;background:#666;border:none;' +
      'border-radius:6px;color:#fff;font-weight:bold;cursor:pointer;">Close (H)</button></div>';

    governancePanel.innerHTML = html;
    governancePanel.className = 'governance-panel';
    document.body.appendChild(governancePanel);
    governanceVisible = true;
    requestAnimationFrame(function() {
      governancePanel.classList.add('visible');
    });

    // Attach event listeners
    var closeBtn = document.getElementById('close-governance-btn');
    if (closeBtn) {
      closeBtn.onclick = hideGovernancePanel;
    }

    var startElectionBtn = document.getElementById('start-election-btn');
    if (startElectionBtn) {
      startElectionBtn.onclick = function() {
        if (governanceCallback) {
          governanceCallback('startElection', { zoneId: zoneId });
        }
      };
    }

    var savePoliciesBtn = document.getElementById('save-policies-btn');
    if (savePoliciesBtn) {
      savePoliciesBtn.onclick = function() {
        var buildingApproval = document.getElementById('policy-building').checked;
        var chatModerated = document.getElementById('policy-moderated').checked;
        var welcomeMsg = document.getElementById('welcome-message').value;

        if (governanceCallback) {
          governanceCallback('savePolicies', {
            zoneId: zoneId,
            buildingRequiresApproval: buildingApproval,
            chatModerated: chatModerated,
            welcomeMessage: welcomeMsg
          });
        }
      };
    }

    var voteButtons = document.querySelectorAll('.vote-btn');
    voteButtons.forEach(function(btn) {
      btn.onclick = function() {
        var candidateId = btn.getAttribute('data-candidate');
        var electionId = btn.getAttribute('data-election');
        if (governanceCallback) {
          governanceCallback('vote', {
            electionId: electionId,
            candidateId: candidateId
          });
        }
      };
    });
  }

  function hideGovernancePanel() {
    if (governancePanel) {
      governancePanel.classList.remove('visible');
      setTimeout(function() {
        if (governancePanel && governancePanel.parentNode) {
          document.body.removeChild(governancePanel);
          governancePanel = null;
        }
      }, 250);
    }
    governanceVisible = false;
  }

  function toggleGovernancePanel(zoneId, playerData) {
    if (governanceVisible) {
      hideGovernancePanel();
    } else {
      showGovernancePanel(zoneId, playerData);
    }
  }

  // ========================================================================
  // AUCTION HOUSE PANEL
  // ========================================================================

  var auctionHousePanel = null;
  var auctionHouseVisible = false;
  var auctionHouseCallback = null;
  var currentAuctionTab = 'browse';

  function initAuctionHousePanel(callback) {
    auctionHouseCallback = callback;
  }

  function showAuctionHousePanel(ledger, playerId, inventory) {
    if (typeof document === 'undefined') return;

    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Economy || !Inventory) return;

    hideAuctionHousePanel();

    auctionHousePanel = document.createElement('div');
    auctionHousePanel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 800px;
      max-height: 80vh;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      overflow-y: auto;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideAuctionHousePanel;
    auctionHousePanel.appendChild(closeBtn);

    // Header
    var header = document.createElement('div');
    header.style.cssText = `
      margin-bottom: 20px;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;

    var title = document.createElement('h2');
    title.textContent = 'Auction House';
    title.style.cssText = `
      color: #DAA520;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      margin: 0 0 8px 0;
      font-weight: bold;
    `;
    header.appendChild(title);

    var subtitle = document.createElement('div');
    var playerBalance = Economy.getBalance(ledger, playerId);
    subtitle.textContent = 'Your Spark: ' + playerBalance;
    subtitle.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    header.appendChild(subtitle);

    auctionHousePanel.appendChild(header);

    // Tab buttons
    var tabsDiv = document.createElement('div');
    tabsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    `;

    var tabs = ['browse', 'myauctions', 'create'];
    var tabLabels = { browse: 'Browse Auctions', myauctions: 'My Auctions', create: 'Create Auction' };

    tabs.forEach(function(tabName) {
      var tabBtn = document.createElement('button');
      tabBtn.textContent = tabLabels[tabName];
      tabBtn.setAttribute('data-tab', tabName);
      tabBtn.style.cssText = `
        flex: 1;
        padding: 12px;
        background: ${currentAuctionTab === tabName ? 'rgba(218, 165, 32, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
        color: ${currentAuctionTab === tabName ? '#DAA520' : '#A0978E'};
        border: 2px solid ${currentAuctionTab === tabName ? '#DAA520' : 'rgba(255, 255, 255, 0.3)'};
        border-radius: 6px;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
      `;
      tabBtn.onmouseover = function() {
        if (currentAuctionTab !== tabName) {
          this.style.background = 'rgba(218, 165, 32, 0.2)';
          this.style.borderColor = 'rgba(218, 165, 32, 0.5)';
        }
      };
      tabBtn.onmouseout = function() {
        if (currentAuctionTab !== tabName) {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
          this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
      };
      tabBtn.onclick = function() {
        currentAuctionTab = tabName;
        showAuctionHousePanel(ledger, playerId, inventory);
      };
      tabsDiv.appendChild(tabBtn);
    });

    auctionHousePanel.appendChild(tabsDiv);

    // Tab content
    var contentDiv = document.createElement('div');
    contentDiv.id = 'auction-content';
    contentDiv.style.cssText = `
      min-height: 300px;
    `;

    if (currentAuctionTab === 'browse') {
      renderBrowseTab(contentDiv, ledger, playerId);
    } else if (currentAuctionTab === 'myauctions') {
      renderMyAuctionsTab(contentDiv, ledger, playerId);
    } else if (currentAuctionTab === 'create') {
      renderCreateTab(contentDiv, ledger, playerId, inventory);
    }

    auctionHousePanel.appendChild(contentDiv);
    auctionHousePanel.className = 'auction-panel';
    document.body.appendChild(auctionHousePanel);
    auctionHouseVisible = true;
    requestAnimationFrame(function() {
      auctionHousePanel.classList.add('visible');
    });
  }

  function renderBrowseTab(container, ledger, playerId) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    if (!Economy) return;

    var auctions = Economy.getActiveAuctions(ledger);

    if (auctions.length === 0) {
      var noAuctions = document.createElement('div');
      noAuctions.textContent = 'No active auctions at the moment.';
      noAuctions.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noAuctions);
      return;
    }

    auctions.forEach(function(auction) {
      var auctionItem = document.createElement('div');
      auctionItem.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;

      var itemInfo = document.createElement('div');
      itemInfo.style.cssText = `
        flex: 1;
      `;

      var itemName = document.createElement('div');
      var itemData = auction.item;
      var itemDisplayName = typeof itemData === 'string' ? itemData : (itemData.name || itemData.id || 'Unknown Item');
      itemName.textContent = itemDisplayName;
      itemName.style.cssText = `
        color: #E8E0D8;
        font-size: 16px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        margin-bottom: 5px;
      `;
      itemInfo.appendChild(itemName);

      var auctionDetails = document.createElement('div');
      var currentBidText = auction.currentBid > 0 ? auction.currentBid + ' Spark' : 'Starting: ' + auction.startingBid + ' Spark';
      var timeRemaining = Math.ceil((auction.endTime - Date.now()) / 60000);
      var timeText = timeRemaining > 60 ? Math.floor(timeRemaining / 60) + 'h ' + (timeRemaining % 60) + 'm' : timeRemaining + 'm';

      auctionDetails.textContent = 'Current Bid: ' + currentBidText + ' | Time: ' + timeText + ' | Seller: ' + auction.seller;
      auctionDetails.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
      `;
      itemInfo.appendChild(auctionDetails);

      auctionItem.appendChild(itemInfo);

      // Bid button
      if (auction.seller !== playerId) {
        var bidBtn = document.createElement('button');
        bidBtn.textContent = 'Bid';
        bidBtn.style.cssText = `
          padding: 8px 20px;
          background: rgba(218, 165, 32, 0.6);
          color: #000;
          border: 2px solid #DAA520;
          border-radius: 6px;
          font-size: 14px;
          font-family: system-ui, sans-serif;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.3s ease;
        `;
        bidBtn.onmouseover = function() {
          this.style.background = 'rgba(218, 165, 32, 0.8)';
        };
        bidBtn.onmouseout = function() {
          this.style.background = 'rgba(218, 165, 32, 0.6)';
        };
        bidBtn.onclick = function() {
          var minBid = Math.max(auction.startingBid, auction.currentBid + 1);
          var bidAmount = prompt('Enter your bid (minimum ' + minBid + ' Spark):');
          if (bidAmount) {
            var amount = parseInt(bidAmount, 10);
            if (!isNaN(amount) && amount >= minBid) {
              if (auctionHouseCallback) {
                auctionHouseCallback('placeBid', { auctionId: auction.id, amount: amount });
              }
            } else {
              alert('Invalid bid amount. Must be at least ' + minBid + ' Spark.');
            }
          }
        };
        auctionItem.appendChild(bidBtn);
      } else {
        var ownLabel = document.createElement('span');
        ownLabel.textContent = 'Your Auction';
        ownLabel.style.cssText = `
          color: #4a4;
          font-size: 12px;
          font-family: system-ui, sans-serif;
          font-style: italic;
        `;
        auctionItem.appendChild(ownLabel);
      }

      container.appendChild(auctionItem);
    });
  }

  function renderMyAuctionsTab(container, ledger, playerId) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    if (!Economy) return;

    var allAuctions = ledger.auctions || [];
    var myAuctions = allAuctions.filter(function(a) { return a.seller === playerId; });

    if (myAuctions.length === 0) {
      var noAuctions = document.createElement('div');
      noAuctions.textContent = 'You have not created any auctions yet.';
      noAuctions.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noAuctions);
      return;
    }

    myAuctions.forEach(function(auction) {
      var auctionItem = document.createElement('div');
      auctionItem.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
      `;

      var itemData = auction.item;
      var itemDisplayName = typeof itemData === 'string' ? itemData : (itemData.name || itemData.id || 'Unknown Item');

      var itemName = document.createElement('div');
      itemName.textContent = itemDisplayName;
      itemName.style.cssText = `
        color: #E8E0D8;
        font-size: 16px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        margin-bottom: 5px;
      `;
      auctionItem.appendChild(itemName);

      var statusText = 'Status: ' + auction.status.toUpperCase();
      if (auction.status === 'active') {
        var timeRemaining = Math.ceil((auction.endTime - Date.now()) / 60000);
        var timeText = timeRemaining > 60 ? Math.floor(timeRemaining / 60) + 'h ' + (timeRemaining % 60) + 'm' : timeRemaining + 'm';
        statusText += ' | Time Left: ' + timeText;
        statusText += ' | Current Bid: ' + (auction.currentBid > 0 ? auction.currentBid + ' Spark' : 'No bids yet');
      } else if (auction.status === 'sold') {
        statusText += ' | Sold for: ' + auction.currentBid + ' Spark to ' + auction.currentBidder;
      } else if (auction.status === 'expired') {
        statusText += ' | No bids received';
      }

      var statusDiv = document.createElement('div');
      statusDiv.textContent = statusText;
      statusDiv.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
      `;
      auctionItem.appendChild(statusDiv);

      container.appendChild(auctionItem);
    });
  }

  function renderCreateTab(container, ledger, playerId, inventory) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Economy || !Inventory) return;

    var formDiv = document.createElement('div');
    formDiv.style.cssText = `
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 20px;
    `;

    // Item selection
    var itemLabel = document.createElement('div');
    itemLabel.textContent = 'Select Item to Auction:';
    itemLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(itemLabel);

    var itemSelect = document.createElement('select');
    itemSelect.id = 'auction-item-select';
    itemSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;

    var items = Inventory.getInventory(inventory);
    var hasItems = false;

    items.forEach(function(item) {
      if (item && item.count > 0) {
        hasItems = true;
        var option = document.createElement('option');
        option.value = item.id;
        option.textContent = item.name + ' (x' + item.count + ')';
        itemSelect.appendChild(option);
      }
    });

    if (!hasItems) {
      var noItems = document.createElement('div');
      noItems.textContent = 'You have no items to auction.';
      noItems.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noItems);
      return;
    }

    formDiv.appendChild(itemSelect);

    // Starting bid
    var bidLabel = document.createElement('div');
    bidLabel.textContent = 'Starting Bid (Spark):';
    bidLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(bidLabel);

    var bidInput = document.createElement('input');
    bidInput.id = 'auction-starting-bid';
    bidInput.type = 'number';
    bidInput.min = '1';
    bidInput.value = '10';
    bidInput.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;
    formDiv.appendChild(bidInput);

    // Duration
    var durationLabel = document.createElement('div');
    durationLabel.textContent = 'Auction Duration:';
    durationLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(durationLabel);

    var durationSelect = document.createElement('select');
    durationSelect.id = 'auction-duration';
    durationSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;

    var durations = [
      { label: '1 Hour', value: 3600000 },
      { label: '6 Hours', value: 21600000 },
      { label: '24 Hours', value: 86400000 }
    ];

    durations.forEach(function(dur) {
      var option = document.createElement('option');
      option.value = dur.value;
      option.textContent = dur.label;
      durationSelect.appendChild(option);
    });

    formDiv.appendChild(durationSelect);

    // Create button
    var createBtn = document.createElement('button');
    createBtn.textContent = 'Create Auction';
    createBtn.style.cssText = `
      width: 100%;
      padding: 12px;
      background: rgba(218, 165, 32, 0.6);
      color: #000;
      border: 2px solid #DAA520;
      border-radius: 6px;
      font-size: 16px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    createBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.8)';
    };
    createBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.6)';
    };
    createBtn.onclick = function() {
      var itemId = itemSelect.value;
      var startingBid = parseInt(bidInput.value, 10);
      var duration = parseInt(durationSelect.value, 10);

      if (!itemId || isNaN(startingBid) || startingBid < 1) {
        alert('Please select an item and set a valid starting bid.');
        return;
      }

      if (auctionHouseCallback) {
        auctionHouseCallback('createAuction', { itemId: itemId, startingBid: startingBid, duration: duration });
      }
    };
    formDiv.appendChild(createBtn);

    container.appendChild(formDiv);
  }

  function hideAuctionHousePanel() {
    if (auctionHousePanel) {
      auctionHousePanel.classList.remove('visible');
      setTimeout(function() {
        if (auctionHousePanel && auctionHousePanel.parentNode) {
          document.body.removeChild(auctionHousePanel);
          auctionHousePanel = null;
        }
      }, 250);
    }
    auctionHouseVisible = false;
  }

  function toggleAuctionHousePanel(ledger, playerId, inventory) {
    if (auctionHouseVisible) {
      hideAuctionHousePanel();
    } else {
      showAuctionHousePanel(ledger, playerId, inventory);
    }
  }

  // ========================================================================
  // REPUTATION DISPLAY
  // ========================================================================

  function updateReputationDisplay(reputation) {
    if (typeof document === 'undefined') return;
    var playerInfo = document.getElementById('player-info');
    if (!playerInfo) return;

    var repEl = document.getElementById('reputation-display');
    if (!repEl) {
      repEl = document.createElement('div');
      repEl.id = 'reputation-display';
      repEl.style.cssText = 'font-size:11px;color:#daa520;margin-top:2px;';
      playerInfo.appendChild(repEl);
    }

    var tierColors = {
      'Newcomer': '#888',
      'Trusted': '#4af',
      'Respected': '#4a4',
      'Honored': '#f4a',
      'Elder': '#daa520'
    };

    var color = tierColors[reputation.tier] || '#888';
    repEl.innerHTML = '<span style="color:' + color + ';">â˜…</span> ' + reputation.tier + ' (' + reputation.score + ')';
  }

  // ========================================================================
  // ACHIEVEMENT PANEL
  // ========================================================================

  var achievementPanel = null;

  function showAchievementPanel(playerId) {
    if (typeof document === 'undefined') return;

    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    if (!Quests) {
      console.warn('Quests module not available');
      return;
    }

    // Toggle if already open
    if (achievementPanel) {
      hideAchievementPanel();
      return;
    }

    var achievements = Quests.getAchievements(playerId);
    var progress = Quests.getAchievementProgress(playerId);

    var panel = document.createElement('div');
    panel.className = 'achievement-panel';

    // Header
    var header = document.createElement('h2');
    header.textContent = 'Achievements';
    panel.appendChild(header);

    // Overall progress
    var progressText = document.createElement('div');
    progressText.style.cssText = 'color:#E8E0D8;font-size:0.9rem;margin-bottom:4px;';
    progressText.textContent = 'Progress: ' + progress.unlocked + ' / ' + progress.total + ' (' + progress.percentage.toFixed(1) + '%)';
    panel.appendChild(progressText);

    // Progress bar
    var progressBarContainer = document.createElement('div');
    progressBarContainer.className = 'achievement-progress-bar';
    var progressBarFill = document.createElement('div');
    progressBarFill.className = 'achievement-progress-fill';
    progressBarFill.style.width = progress.percentage + '%';
    progressBarContainer.appendChild(progressBarFill);
    panel.appendChild(progressBarContainer);

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:15px;right:15px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;font-size:20px;cursor:pointer;transition:all 0.2s;';
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218,165,32,0.3)';
      this.style.borderColor = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255,255,255,0.1)';
      this.style.borderColor = 'rgba(255,255,255,0.3)';
    };
    closeBtn.onclick = hideAchievementPanel;
    panel.appendChild(closeBtn);

    // Group achievements by category
    var categories = {
      exploration: [],
      social: [],
      crafting: [],
      building: [],
      gardening: [],
      economy: [],
      competition: [],
      quests: [],
      guild: [],
      art: [],
      physical: [],
      mentoring: []
    };

    achievements.forEach(function(ach) {
      if (categories[ach.category]) {
        categories[ach.category].push(ach);
      }
    });

    // Category display names
    var categoryNames = {
      exploration: 'Exploration',
      social: 'Social',
      crafting: 'Crafting',
      building: 'Building',
      gardening: 'Gardening',
      economy: 'Economy',
      competition: 'Competition',
      quests: 'Quests',
      guild: 'Guild',
      art: 'Art & Creativity',
      physical: 'Physical Wellness',
      mentoring: 'Mentoring'
    };

    // Render categories
    Object.keys(categoryNames).forEach(function(catKey) {
      var catAchievements = categories[catKey];
      if (catAchievements.length === 0) return;

      var categorySection = document.createElement('div');
      categorySection.className = 'achievement-category';

      var categoryTitle = document.createElement('div');
      categoryTitle.className = 'achievement-category-title';
      categoryTitle.textContent = categoryNames[catKey];
      categorySection.appendChild(categoryTitle);

      catAchievements.forEach(function(ach) {
        var row = document.createElement('div');
        row.className = 'achievement-row ' + (ach.unlocked ? 'unlocked' : 'locked');
        if (ach.unlocked) {
          row.style.borderLeft = '3px solid #daa520';
          row.style.paddingLeft = '5px';
        }

        var icon = document.createElement('div');
        icon.className = 'achievement-icon';
        icon.textContent = ach.icon || 'â­';
        row.appendChild(icon);

        var info = document.createElement('div');
        info.className = 'achievement-info';

        var name = document.createElement('div');
        name.className = 'achievement-name';
        name.textContent = ach.name;
        info.appendChild(name);

        var desc = document.createElement('div');
        desc.className = 'achievement-desc';
        desc.textContent = ach.description;
        info.appendChild(desc);

        row.appendChild(info);

        var reward = document.createElement('div');
        reward.className = 'achievement-reward';
        reward.textContent = '+' + ach.sparkReward + ' Spark';
        row.appendChild(reward);

        categorySection.appendChild(row);
      });

      panel.appendChild(categorySection);
    });

    document.body.appendChild(panel);
    achievementPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideAchievementPanel();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideAchievementPanel() {
    if (!achievementPanel) return;
    if (achievementPanel.escapeHandler) {
      document.removeEventListener('keydown', achievementPanel.escapeHandler);
    }
    achievementPanel.classList.remove('visible');
    setTimeout(function() {
      if (achievementPanel && achievementPanel.parentNode) {
        document.body.removeChild(achievementPanel);
        achievementPanel = null;
      }
    }, 250);
  }

  // Export public API
  /**
   * Update federation status panel
   * @param {Array} discoveredWorlds - Array of discovered world info
   * @param {Array} federatedWorlds - Array of federated world info
   */
  function updateFederationStatus(discoveredWorlds, federatedWorlds) {
    if (!federationPanel) return;

    var html = '<div style="font-weight: bold; margin-bottom: 8px; color: #88f;">Federation</div>';

    // Show federated worlds (active portals)
    if (federatedWorlds && federatedWorlds.length > 0) {
      html += '<div style="margin-bottom: 8px;">';
      html += '<div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">Active Portals:</div>';
      federatedWorlds.forEach(function(world) {
        html += '<div style="margin-left: 8px; margin-bottom: 3px;">';
        html += '<span style="color: #4f4;">&#x2713;</span> ';
        html += '<span style="color: #fff;">' + (world.worldInfo?.worldName || world.worldId) + '</span>';
        if (world.worldInfo?.playerCount !== undefined) {
          html += '<span style="color: #888; font-size: 10px;"> (' + world.worldInfo.playerCount + ')</span>';
        }
        html += '</div>';
      });
      html += '</div>';
    }

    // Show discovered worlds (not yet federated)
    if (discoveredWorlds && discoveredWorlds.length > 0) {
      var unfederated = discoveredWorlds.filter(function(dw) {
        return !federatedWorlds.some(function(fw) {
          return fw.worldId === dw.worldId;
        });
      });

      if (unfederated.length > 0) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">Discovered:</div>';
        unfederated.forEach(function(world) {
          html += '<div style="margin-left: 8px; margin-bottom: 3px;">';
          html += '<span style="color: #88f;">&#x25cf;</span> ';
          html += '<span style="color: #ccc;">' + (world.worldName || world.worldId) + '</span>';
          if (world.playerCount !== undefined) {
            html += '<span style="color: #888; font-size: 10px;"> (' + world.playerCount + ')</span>';
          }
          html += '</div>';
        });
        html += '</div>';
      }
    }

    // Show help text if no worlds
    if ((!federatedWorlds || federatedWorlds.length === 0) &&
        (!discoveredWorlds || discoveredWorlds.length === 0)) {
      html += '<div style="color: #888; font-size: 11px; font-style: italic;">No federated worlds yet</div>';
    }

    federationPanel.innerHTML = html;
  }

  /**
   * Show federation portal UI when near a portal
   * @param {object} portalInfo - Portal information
   */
  function showFederationPortalUI(portalInfo) {
    if (typeof document === 'undefined') return;

    // Create portal interaction UI
    var portalUI = document.getElementById('federation-portal-ui');
    if (!portalUI) {
      portalUI = document.createElement('div');
      portalUI.id = 'federation-portal-ui';
      portalUI.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #88f;
        border-radius: 12px;
        padding: 20px;
        min-width: 300px;
        color: white;
        text-align: center;
        pointer-events: auto;
        z-index: 200;
      `;
      document.body.appendChild(portalUI);
    }

    var html = '<div style="font-size: 20px; font-weight: bold; margin-bottom: 10px; color: #88f;">Rift Portal</div>';
    html += '<div style="margin-bottom: 15px; color: #ccc;">' + (portalInfo.worldName || 'Unknown World') + '</div>';

    if (portalInfo.playerCount !== undefined) {
      html += '<div style="margin-bottom: 15px; font-size: 12px; color: #aaa;">Players: ' + portalInfo.playerCount + '</div>';
    }

    html += '<button id="portal-warp-btn" style="';
    html += 'background: #4488ff; color: white; border: none; padding: 10px 20px;';
    html += 'border-radius: 5px; cursor: pointer; font-size: 14px; margin-right: 10px;">Enter Portal</button>';
    html += '<button id="portal-close-btn" style="';
    html += 'background: #444; color: white; border: none; padding: 10px 20px;';
    html += 'border-radius: 5px; cursor: pointer; font-size: 14px;">Cancel</button>';

    portalUI.innerHTML = html;

    // Add event listeners
    document.getElementById('portal-warp-btn').onclick = function() {
      if (portalInfo.onWarp) {
        portalInfo.onWarp(portalInfo.targetWorld);
      }
      hideFederationPortalUI();
    };

    document.getElementById('portal-close-btn').onclick = function() {
      hideFederationPortalUI();
    };
  }

  /**
   * Hide federation portal UI
   */
  function hideFederationPortalUI() {
    var portalUI = document.getElementById('federation-portal-ui');
    if (portalUI) {
      portalUI.remove();
    }
  }

  // ========================================================================
  // FISHING MINIGAME UI
  // ========================================================================

  let fishingUIActive = false;
  let fishingCallback = null;

  /**
   * Show fishing UI with casting and reeling mechanics
   * @param {string} zoneId - Current zone for fish type determination
   * @param {Function} onResult - Callback with result {success: boolean, fish?: Object}
   */
  function showFishingUI(zoneId, onResult) {
    if (!hudContainer || fishingUIActive) return;
    if (typeof document === 'undefined') return;

    fishingUIActive = true;
    fishingCallback = onResult;

    // Create fishing overlay with ocean theme
    const fishingOverlay = document.createElement('div');
    fishingOverlay.id = 'fishing-ui';
    fishingOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 50, 100, 0.3) 0%, rgba(0, 100, 150, 0.5) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: auto;
    `;

    // Fishing panel
    const fishingPanel = document.createElement('div');
    fishingPanel.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 80, 140, 0.95) 0%, rgba(0, 120, 180, 0.95) 100%);
      border: 3px solid rgba(100, 200, 255, 0.8);
      border-radius: 15px;
      padding: 40px;
      min-width: 400px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 150, 255, 0.5), inset 0 0 50px rgba(0, 100, 200, 0.3);
      animation: wave-effect 3s ease-in-out infinite;
    `;

    // Add wave animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes wave-effect {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-5px); }
      }
      @keyframes ripple {
        0% { transform: scale(0.8); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // Fishing icon
    const fishingIcon = document.createElement('div');
    fishingIcon.style.cssText = `
      font-size: 64px;
      margin-bottom: 20px;
      animation: ripple 2s ease-out infinite;
    `;
    fishingIcon.textContent = 'ðŸŽ£';
    fishingPanel.appendChild(fishingIcon);

    // Status text
    const statusText = document.createElement('div');
    statusText.style.cssText = `
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
      margin-bottom: 20px;
    `;
    statusText.textContent = 'Casting...';
    fishingPanel.appendChild(statusText);

    // Subtext
    const subText = document.createElement('div');
    subText.style.cssText = `
      font-size: 16px;
      color: rgba(200, 240, 255, 0.9);
      margin-top: 10px;
    `;
    subText.textContent = 'Wait for a bite...';
    fishingPanel.appendChild(subText);

    fishingOverlay.appendChild(fishingPanel);
    hudContainer.appendChild(fishingOverlay);

    // Random casting time (2-5 seconds)
    const castTime = 2000 + Math.random() * 3000;

    setTimeout(() => {
      if (!document.getElementById('fishing-ui')) return;

      // Fish on! Show reeling prompt
      statusText.textContent = 'FISH ON!';
      statusText.style.color = '#ffff00';
      statusText.style.fontSize = '32px';
      subText.textContent = 'Press E to reel in!';
      subText.style.color = '#ffff00';
      fishingIcon.textContent = 'ðŸŸ';

      let caughtFish = false;
      const reelWindow = 1500; // 1.5 second window to press E

      // Listen for E key
      const reelHandler = (e) => {
        if (e.key === 'e' || e.key === 'E') {
          caughtFish = true;
          document.removeEventListener('keydown', reelHandler);

          // Determine caught fish based on zone
          const fishResult = determineCatch(zoneId);

          statusText.textContent = `Caught ${fishResult.name}!`;
          statusText.style.color = '#4f4';
          subText.textContent = `+${fishResult.value} Spark`;
          fishingIcon.textContent = fishResult.icon;

          setTimeout(() => {
            hideFishingUI();
            if (fishingCallback) {
              fishingCallback({ success: true, fish: fishResult });
            }
          }, 2000);
        }
      };

      document.addEventListener('keydown', reelHandler);

      // Miss window timeout
      setTimeout(() => {
        if (!caughtFish) {
          document.removeEventListener('keydown', reelHandler);
          statusText.textContent = 'The fish got away...';
          statusText.style.color = '#f44';
          subText.textContent = 'Try again!';
          fishingIcon.textContent = 'ðŸ’¨';

          setTimeout(() => {
            hideFishingUI();
            if (fishingCallback) {
              fishingCallback({ success: false });
            }
          }, 2000);
        }
      }, reelWindow);
    }, castTime);
  }

  /**
   * Determine what fish was caught based on zone
   * @param {string} zoneId - Current zone
   * @returns {Object} Fish data {id, name, icon, value, rarity}
   */
  function determineCatch(zoneId) {
    const zoneFishTables = {
      gardens: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' },
          { id: 'fish_sunfish', name: 'Sunfish', icon: 'â˜€ï¸', value: 8, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' },
          { id: 'fish_crystal_trout', name: 'Crystal Trout', icon: 'ðŸ’Ž', value: 40, rarity: 'rare' }
        ],
        rare: [
          { id: 'fish_golden', name: 'Golden Koi', icon: 'ðŸŸ¡', value: 50, rarity: 'rare' }
        ]
      },
      wilds: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_shadow_bass', name: 'Shadow Bass', icon: 'ðŸŒ‘', value: 18, rarity: 'uncommon' },
          { id: 'fish_silver_eel', name: 'Silver Eel', icon: 'ðŸ', value: 20, rarity: 'uncommon' }
        ],
        rare: [
          { id: 'fish_starfish', name: 'Star Cod', icon: 'â­', value: 35, rarity: 'rare' },
          { id: 'fish_dragonfish', name: 'Dragonfish', icon: 'ðŸ‰', value: 100, rarity: 'legendary' }
        ]
      },
      commons: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' },
          { id: 'fish_sunfish', name: 'Sunfish', icon: 'â˜€ï¸', value: 8, rarity: 'common' }
        ],
        rare: [
          { id: 'fish_moonfish', name: 'Moonfish', icon: 'ðŸŒ™', value: 25, rarity: 'uncommon' }
        ]
      },
      agora: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' }
        ],
        rare: [
          { id: 'fish_golden', name: 'Golden Koi', icon: 'ðŸŸ¡', value: 50, rarity: 'rare' }
        ]
      }
    };

    // Default to commons if zone not found
    const table = zoneFishTables[zoneId] || zoneFishTables.commons;

    // Roll for rarity: 70% common, 25% uncommon, 5% rare
    const roll = Math.random();
    let pool;
    if (roll < 0.05 && table.rare && table.rare.length > 0) {
      pool = table.rare;
    } else if (roll < 0.30 && table.uncommon && table.uncommon.length > 0) {
      pool = table.uncommon;
    } else {
      pool = table.common;
    }

    return pool[Math.floor(Math.random() * pool.length)];
  }

  /**
   * Hide fishing UI
   */
  function hideFishingUI() {
    const fishingUI = document.getElementById('fishing-ui');
    if (fishingUI) {
      fishingUI.remove();
    }
    fishingUIActive = false;
    fishingCallback = null;
  }

  /**
   * Show fish caught notification
   * @param {string} fishName - Name of the fish
   * @param {number} value - Spark value
   */
  function showFishCaughtNotification(fishName, value) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const notification = document.createElement('div');
    notification.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 120, 200, 0.95) 0%, rgba(0, 180, 255, 0.95) 100%);
      border: 2px solid rgba(100, 220, 255, 0.9);
      border-radius: 10px;
      padding: 20px 30px;
      margin-bottom: 10px;
      box-shadow: 0 4px 20px rgba(0, 150, 255, 0.6);
      animation: slideIn 0.3s ease-out, slideOut 0.3s ease-in 2.7s;
      pointer-events: auto;
      text-align: center;
    `;

    const fishIcon = document.createElement('div');
    fishIcon.style.cssText = `
      font-size: 48px;
      margin-bottom: 10px;
    `;
    fishIcon.textContent = 'ðŸŽ£';
    notification.appendChild(fishIcon);

    const fishText = document.createElement('div');
    fishText.style.cssText = `
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
      margin-bottom: 5px;
    `;
    fishText.textContent = `Caught ${fishName}!`;
    notification.appendChild(fishText);

    const valueText = document.createElement('div');
    valueText.style.cssText = `
      font-size: 16px;
      color: #ffff00;
      text-shadow: 0 0 8px rgba(255, 255, 0, 0.6);
    `;
    valueText.textContent = `+${value} Spark`;
    notification.appendChild(valueText);

    notificationContainer.appendChild(notification);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 3000);
  }

  // ========================================================================
  // PET PANEL
  // ========================================================================

  var petPanel = null;

  function showPetPanel(playerId, currentZone) {
    if (typeof document === 'undefined') return;

    var Pets = typeof window !== 'undefined' ? window.Pets : null;
    if (!Pets) {
      console.warn('Pets module not available');
      return;
    }

    // Toggle if already open
    if (petPanel) {
      hidePetPanel();
      return;
    }

    var pet = Pets.getPlayerPet(playerId);

    var panel = document.createElement('div');
    panel.className = 'pet-panel';

    // Header
    var header = document.createElement('h2');
    header.textContent = pet ? 'My Companion' : 'Adopt a Companion';
    panel.appendChild(header);

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:15px;right:15px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;font-size:20px;cursor:pointer;transition:all 0.2s;';
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218,165,32,0.3)';
      this.style.borderColor = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255,255,255,0.1)';
      this.style.borderColor = 'rgba(255,255,255,0.3)';
    };
    closeBtn.onclick = hidePetPanel;
    panel.appendChild(closeBtn);

    if (pet) {
      // Show current pet info
      showCurrentPetInfo(panel, pet, playerId, Pets);
    } else {
      // Show available pets to adopt
      showAdoptionList(panel, playerId, currentZone, Pets);
    }

    document.body.appendChild(panel);
    petPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hidePetPanel();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function showCurrentPetInfo(panel, pet, playerId, Pets) {
    var petTypeData = Pets.getPetTypeData(pet.type);
    var mood = Pets.getPetMood(pet);
    var moodEmoji = Pets.getMoodEmoji(mood);
    var bonus = Pets.getPetBonus(playerId);

    // Pet display section
    var petDisplay = document.createElement('div');
    petDisplay.style.cssText = 'text-align:center;margin-bottom:20px;padding:20px;' +
      'background:rgba(255,255,255,0.03);border-radius:8px;';

    // Pet icon
    var petIcon = document.createElement('div');
    petIcon.textContent = petTypeData.icon;
    petIcon.style.cssText = 'font-size:64px;margin-bottom:10px;';
    petDisplay.appendChild(petIcon);

    // Pet name
    var petName = document.createElement('div');
    petName.textContent = pet.name;
    petName.style.cssText = 'font-size:1.2rem;color:#DAA520;font-weight:bold;margin-bottom:5px;';
    petDisplay.appendChild(petName);

    // Pet type
    var petType = document.createElement('div');
    petType.textContent = petTypeData.name;
    petType.style.cssText = 'font-size:0.9rem;color:#B8B0A8;margin-bottom:5px;';
    petDisplay.appendChild(petType);

    // Pet mood
    var petMoodDisplay = document.createElement('div');
    petMoodDisplay.textContent = moodEmoji + ' ' + mood.charAt(0).toUpperCase() + mood.slice(1);
    petMoodDisplay.style.cssText = 'font-size:0.9rem;color:#E8E0D8;margin-top:10px;';
    petDisplay.appendChild(petMoodDisplay);

    panel.appendChild(petDisplay);

    // Stats section
    var statsSection = document.createElement('div');
    statsSection.style.cssText = 'margin-bottom:20px;';

    // Mood bar
    var moodLabel = document.createElement('div');
    moodLabel.textContent = 'Mood: ' + Math.round(pet.mood) + '/100';
    moodLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;';
    statsSection.appendChild(moodLabel);

    var moodBar = createProgressBar(pet.mood, '#DAA520');
    statsSection.appendChild(moodBar);

    // Hunger bar
    var hungerLabel = document.createElement('div');
    hungerLabel.textContent = 'Hunger: ' + Math.round(pet.hunger) + '/100';
    hungerLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;margin-top:12px;';
    statsSection.appendChild(hungerLabel);

    var hungerBar = createProgressBar(pet.hunger, pet.hunger > 60 ? '#e74c3c' : '#3498db');
    statsSection.appendChild(hungerBar);

    // Bond bar
    var bondLabel = document.createElement('div');
    bondLabel.textContent = 'Bond: ' + Math.round(pet.bond) + '/100';
    bondLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;margin-top:12px;';
    statsSection.appendChild(bondLabel);

    var bondBar = createProgressBar(pet.bond, '#2ecc71');
    statsSection.appendChild(bondBar);

    panel.appendChild(statsSection);

    // Bonus display
    if (bonus && bonus.value > 0) {
      var bonusDisplay = document.createElement('div');
      bonusDisplay.textContent = 'Bonus: ' + bonus.description;
      bonusDisplay.style.cssText = 'color:#2ecc71;font-size:0.85rem;margin-bottom:20px;' +
        'padding:8px;background:rgba(46,204,113,0.1);border-radius:4px;text-align:center;';
      panel.appendChild(bonusDisplay);
    }

    // Actions section
    var actionsSection = document.createElement('div');
    actionsSection.style.cssText = 'display:flex;gap:8px;margin-bottom:12px;';

    // Feed button
    var feedBtn = document.createElement('button');
    feedBtn.textContent = 'Feed';
    feedBtn.className = 'pet-action-btn';
    feedBtn.onclick = function() {
      showFeedMenu(playerId, Pets);
    };
    actionsSection.appendChild(feedBtn);

    // Rename button
    var renameBtn = document.createElement('button');
    renameBtn.textContent = 'Rename';
    renameBtn.className = 'pet-action-btn';
    renameBtn.onclick = function() {
      var newName = prompt('Enter new name for ' + pet.name + ':');
      if (newName && newName.trim()) {
        if (Pets.renamePet(playerId, newName.trim())) {
          showNotification('Pet renamed to ' + newName.trim());
          hidePetPanel();
        }
      }
    };
    actionsSection.appendChild(renameBtn);

    panel.appendChild(actionsSection);

    // Release button (dangerous action)
    var releaseBtn = document.createElement('button');
    releaseBtn.textContent = 'Release to Wild';
    releaseBtn.className = 'pet-release-btn';
    releaseBtn.onclick = function() {
      if (confirm('Are you sure you want to release ' + pet.name + '? This cannot be undone.')) {
        if (Pets.releasePet(playerId)) {
          showNotification(pet.name + ' has been released to the wild');
          hidePetPanel();
        }
      }
    };
    panel.appendChild(releaseBtn);
  }

  function showAdoptionList(panel, playerId, currentZone, Pets) {
    var availablePets = Pets.getAvailablePets(currentZone || 'commons');

    // Info text
    var infoText = document.createElement('div');
    infoText.textContent = 'Choose a companion to adopt in this zone:';
    infoText.style.cssText = 'color:#B8B0A8;font-size:0.9rem;margin-bottom:16px;';
    panel.appendChild(infoText);

    if (availablePets.length === 0) {
      var noPets = document.createElement('div');
      noPets.textContent = 'No pets available in this zone. Try exploring other areas!';
      noPets.style.cssText = 'color:#E8E0D8;text-align:center;padding:20px;';
      panel.appendChild(noPets);
      return;
    }

    // Pet list
    availablePets.forEach(function(petType) {
      var petRow = document.createElement('div');
      petRow.className = 'pet-adoption-row';
      petRow.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;' +
        'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);' +
        'border-radius:8px;margin-bottom:8px;transition:all 0.2s;cursor:pointer;';

      petRow.onmouseover = function() {
        this.style.borderColor = 'rgba(218,165,32,0.5)';
        this.style.background = 'rgba(218,165,32,0.1)';
      };
      petRow.onmouseout = function() {
        this.style.borderColor = 'rgba(255,255,255,0.1)';
        this.style.background = 'rgba(255,255,255,0.03)';
      };

      // Pet icon
      var icon = document.createElement('div');
      icon.textContent = petType.icon;
      icon.style.cssText = 'font-size:32px;width:40px;text-align:center;';
      petRow.appendChild(icon);

      // Pet info
      var info = document.createElement('div');
      info.style.cssText = 'flex:1;';

      var name = document.createElement('div');
      name.textContent = petType.name;
      name.style.cssText = 'color:#E8E0D8;font-size:0.95rem;font-weight:bold;margin-bottom:2px;';
      info.appendChild(name);

      var desc = document.createElement('div');
      desc.textContent = petType.description;
      desc.style.cssText = 'color:#B8B0A8;font-size:0.75rem;margin-bottom:4px;';
      info.appendChild(desc);

      var rarity = document.createElement('div');
      rarity.textContent = petType.rarity.charAt(0).toUpperCase() + petType.rarity.slice(1);
      var rarityColor = petType.rarity === 'legendary' ? '#f39c12' :
                        petType.rarity === 'rare' ? '#3498db' :
                        petType.rarity === 'uncommon' ? '#2ecc71' : '#95a5a6';
      rarity.style.cssText = 'color:' + rarityColor + ';font-size:0.7rem;';
      info.appendChild(rarity);

      petRow.appendChild(info);

      // Adopt button
      var adoptBtn = document.createElement('button');
      adoptBtn.textContent = 'Adopt';
      adoptBtn.className = 'pet-adopt-btn';
      adoptBtn.onclick = function(e) {
        e.stopPropagation();
        var petName = prompt('Choose a name for your ' + petType.name + ':');
        if (petName && petName.trim()) {
          var adoptedPet = Pets.adoptPet(playerId, petType.id, petName.trim());
          if (adoptedPet) {
            showPetAdoptNotification(petName.trim(), petType);
            hidePetPanel();
          } else {
            alert('Could not adopt pet. You may already have a companion.');
          }
        }
      };
      petRow.appendChild(adoptBtn);

      panel.appendChild(petRow);
    });
  }

  function showFeedMenu(playerId, Pets) {
    if (!petPanel) return;

    // Simple food selection
    var foods = ['berry', 'fish', 'mushroom', 'bread', 'treat'];
    var foodEmojis = {
      'berry': 'ðŸ«',
      'fish': 'ðŸŸ',
      'mushroom': 'ðŸ„',
      'bread': 'ðŸž',
      'treat': 'ðŸª'
    };

    var feedMenu = document.createElement('div');
    feedMenu.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(15,12,10,0.98);border:2px solid #DAA520;border-radius:12px;' +
      'padding:20px;z-index:1200;min-width:250px;';

    var title = document.createElement('h3');
    title.textContent = 'Choose Food';
    title.style.cssText = 'color:#DAA520;margin:0 0 16px;text-align:center;';
    feedMenu.appendChild(title);

    foods.forEach(function(food) {
      var foodBtn = document.createElement('button');
      foodBtn.textContent = foodEmojis[food] + ' ' + food.charAt(0).toUpperCase() + food.slice(1);
      foodBtn.className = 'pet-food-btn';
      foodBtn.style.cssText = 'display:block;width:100%;padding:10px;margin-bottom:8px;' +
        'background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);' +
        'border-radius:6px;color:#E8E0D8;cursor:pointer;transition:all 0.2s;';

      foodBtn.onmouseover = function() {
        this.style.background = 'rgba(218,165,32,0.2)';
        this.style.borderColor = '#DAA520';
      };
      foodBtn.onmouseout = function() {
        this.style.background = 'rgba(255,255,255,0.1)';
        this.style.borderColor = 'rgba(255,255,255,0.2)';
      };

      foodBtn.onclick = function() {
        var result = Pets.feedPet(playerId, food);
        if (result.success) {
          showNotification(result.message);
          document.body.removeChild(feedMenu);
          hidePetPanel();
        }
      };
      feedMenu.appendChild(foodBtn);
    });

    var cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.className = 'pet-food-btn';
    cancelBtn.style.cssText = 'display:block;width:100%;padding:10px;' +
      'background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:6px;color:#B8B0A8;cursor:pointer;';
    cancelBtn.onclick = function() {
      document.body.removeChild(feedMenu);
    };
    feedMenu.appendChild(cancelBtn);

    document.body.appendChild(feedMenu);
  }

  function createProgressBar(value, color) {
    var container = document.createElement('div');
    container.style.cssText = 'width:100%;height:8px;background:rgba(255,255,255,0.1);' +
      'border-radius:4px;overflow:hidden;';

    var fill = document.createElement('div');
    fill.style.cssText = 'height:100%;background:' + color + ';border-radius:4px;' +
      'transition:width 0.5s ease;width:' + value + '%;';

    container.appendChild(fill);
    return container;
  }

  function hidePetPanel() {
    if (!petPanel) return;
    if (petPanel.escapeHandler) {
      document.removeEventListener('keydown', petPanel.escapeHandler);
    }
    petPanel.classList.remove('visible');
    setTimeout(function() {
      if (petPanel && petPanel.parentNode) {
        document.body.removeChild(petPanel);
        petPanel = null;
      }
    }, 250);
  }

  function showPetAdoptNotification(petName, petType) {
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.className = 'pet-adopt-notification';
    notification.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:linear-gradient(135deg,rgba(25,20,15,0.95),rgba(35,28,18,0.95));' +
      'border:2px solid #DAA520;border-radius:16px;padding:30px 40px;text-align:center;' +
      'z-index:2000;animation:petAdoptReveal 0.5s ease-out,petAdoptFade 4s ease-in-out;' +
      'box-shadow:0 0 40px rgba(218,165,32,0.4);pointer-events:none;';

    // Add keyframes if not already present
    var styleId = 'pet-adopt-animations';
    if (!document.getElementById(styleId)) {
      var style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
        @keyframes petAdoptReveal {
          0% { transform: translate(-50%,-50%) scale(0.6); opacity: 0; }
          60% { transform: translate(-50%,-50%) scale(1.05); }
          100% { opacity: 1; transform: translate(-50%,-50%) scale(1); }
        }
        @keyframes petAdoptFade {
          0%, 80% { opacity: 1; }
          100% { opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    var icon = document.createElement('div');
    icon.textContent = petType.icon;
    icon.style.cssText = 'font-size:64px;margin-bottom:16px;';
    notification.appendChild(icon);

    var title = document.createElement('div');
    title.textContent = 'Companion Adopted!';
    title.style.cssText = 'font-size:0.9rem;color:#DAA520;text-transform:uppercase;' +
      'letter-spacing:0.15em;margin-bottom:8px;';
    notification.appendChild(title);

    var name = document.createElement('div');
    name.textContent = petName;
    name.style.cssText = 'font-size:1.5rem;color:#E8E0D8;font-weight:bold;margin-bottom:4px;';
    notification.appendChild(name);

    var typeName = document.createElement('div');
    typeName.textContent = petType.name;
    typeName.style.cssText = 'font-size:1rem;color:#B8B0A8;';
    notification.appendChild(typeName);

    document.body.appendChild(notification);

    setTimeout(function() {
      if (notification.parentNode) {
        document.body.removeChild(notification);
      }
    }, 4000);
  }

  exports.initHUD = initHUD;
  exports.initToolbar = initToolbar;
  exports.updateChat = updateChat;
  exports.addChatMessage = addChatMessage;
  exports.updatePlayerInfo = updatePlayerInfo;
  exports.updateMinimap = updateMinimap;
  exports.updateZoneLabel = updateZoneLabel;
  exports.updateNearbyPlayers = updateNearbyPlayers;
  exports.showBreakReminder = showBreakReminder;
  exports.addChatInput = addChatInput;
  exports.showChatInput = showChatInput;
  exports.hideChatInput = hideChatInput;
  exports.showNotification = showNotification;
  exports.updateCoords = updateCoords;
  exports.updateTimeWeather = updateTimeWeather;
  exports.showNPCDialog = showNPCDialog;
  exports.hideNPCDialog = hideNPCDialog;
  exports.setNPCActionCallback = setNPCActionCallback;
  exports.showNPCShop = showNPCShop;
  exports.hideNPCShop = hideNPCShop;
  exports.updateMinimapNPCs = updateMinimapNPCs;
  exports.initQuestTracker = initQuestTracker;
  exports.updateQuestTracker = updateQuestTracker;
  exports.showQuestLog = showQuestLog;
  exports.hideQuestLog = hideQuestLog;
  exports.showQuestOffer = showQuestOffer;
  exports.hideQuestOffer = hideQuestOffer;
  exports.showQuestComplete = showQuestComplete;
  exports.showQuestProgress = showQuestProgress;
  exports.acceptQuestFromOffer = acceptQuestFromOffer;
  exports.updateFederationStatus = updateFederationStatus;
  exports.showFederationPortalUI = showFederationPortalUI;
  exports.hideFederationPortalUI = hideFederationPortalUI;
  exports.abandonQuestFromLog = abandonQuestFromLog;
  exports.initInventoryPanel = initInventoryPanel;
  exports.toggleInventoryPanel = toggleInventoryPanel;
  exports.showInventoryPanel = showInventoryPanel;
  exports.hideInventoryPanel = hideInventoryPanel;
  exports.updateInventoryDisplay = updateInventoryDisplay;
  exports.initCraftingPanel = initCraftingPanel;
  exports.toggleCraftingPanel = toggleCraftingPanel;
  exports.showCraftingPanel = showCraftingPanel;
  exports.hideCraftingPanel = hideCraftingPanel;
  exports.updateCraftingDisplay = updateCraftingDisplay;
  exports.initQuickBar = initQuickBar;
  exports.updateQuickBar = updateQuickBar;
  exports.showItemPickup = showItemPickup;
  exports.showTradeRequest = showTradeRequest;
  exports.hideTradeRequest = hideTradeRequest;
  exports.showTradeWindow = showTradeWindow;
  exports.updateTradeWindow = updateTradeWindow;
  exports.hideTradeWindow = hideTradeWindow;
  exports.showTradeComplete = showTradeComplete;
  exports.showEmoteMenu = showEmoteMenu;
  exports.hideEmoteMenu = hideEmoteMenu;
  exports.showEmoteBubble = showEmoteBubble;
  exports.updateEmoteBubbles = updateEmoteBubbles;
  exports.showBuildToolbar = showBuildToolbar;
  exports.hideBuildToolbar = hideBuildToolbar;
  exports.updateBuildToolbar = updateBuildToolbar;
  exports.showWorldMap = showWorldMap;
  exports.hideWorldMap = hideWorldMap;
  exports.updateWorldMap = updateWorldMap;
  exports.showSettingsMenu = showSettingsMenu;
  exports.hideSettingsMenu = hideSettingsMenu;
  exports.loadSettings = loadSettings;
  exports.getSettings = getSettings;
  exports.showPlayerProfile = showPlayerProfile;
  exports.hidePlayerProfile = hidePlayerProfile;
  exports.showProfilePanel = showProfilePanel;
  exports.hideProfilePanel = hideProfilePanel;
  exports.updateProfileStats = updateProfileStats;
  exports.showDiscoveryLog = showDiscoveryLog;
  exports.hideDiscoveryLog = hideDiscoveryLog;
  exports.showLoreBook = showLoreBook;
  exports.hideLoreBook = hideLoreBook;
  exports.showLoreJournal = showLoreJournal;
  exports.hideLoreJournal = hideLoreJournal;
  exports.toggleLoreJournal = toggleLoreJournal;
  exports.showAchievementToast = showAchievementToast;
  exports.showDiscoveryPopup = showDiscoveryPopup;
  exports.showSkillsPanel = showSkillsPanel;
  exports.hideSkillsPanel = hideSkillsPanel;
  exports.showMentorOffer = showMentorOffer;
  exports.showLessonProgress = showLessonProgress;
  exports.showComposePanel = showComposePanel;
  exports.hideComposePanel = hideComposePanel;
  exports.playComposition = playComposition;
  exports.showGuildPanel = showGuildPanel;
  exports.hideGuildPanel = hideGuildPanel;
  exports.showGuildCreate = showGuildCreate;
  exports.hideGuildCreate = hideGuildCreate;
  exports.showGuildInvite = showGuildInvite;
  exports.updateGuildTag = updateGuildTag;
  exports.initGovernancePanel = initGovernancePanel;
  exports.showGovernancePanel = showGovernancePanel;
  exports.hideGovernancePanel = hideGovernancePanel;
  exports.toggleGovernancePanel = toggleGovernancePanel;
  exports.initAuctionHousePanel = initAuctionHousePanel;
  exports.showAuctionHousePanel = showAuctionHousePanel;
  exports.hideAuctionHousePanel = hideAuctionHousePanel;
  exports.toggleAuctionHousePanel = toggleAuctionHousePanel;
  exports.updateReputationDisplay = updateReputationDisplay;
  exports.showAchievementPanel = showAchievementPanel;
  exports.hideAchievementPanel = hideAchievementPanel;
  exports.showFishingUI = showFishingUI;
  exports.hideFishingUI = hideFishingUI;
  exports.showFishCaughtNotification = showFishCaughtNotification;
  exports.showPetPanel = showPetPanel;
  exports.hidePetPanel = hidePetPanel;
  exports.showPetAdoptNotification = showPetAdoptNotification;

  // =============================================================================
  // TUTORIAL/ONBOARDING SYSTEM
  // =============================================================================

  var tutorialState = {
    active: false,
    currentStep: 0,
    completed: false
  };

  var tutorialTooltip = null;
  var tutorialSteps = [
    {
      id: 'move',
      message: 'Welcome to ZION! Use WASD to move around.',
      action: 'move'
    },
    {
      id: 'interact',
      message: 'Press E near an NPC to interact.',
      action: 'interact'
    },
    {
      id: 'inventory',
      message: 'Press I to open your inventory.',
      action: 'openInventory'
    },
    {
      id: 'quests',
      message: 'Press J to check your quests.',
      action: 'openQuests'
    },
    {
      id: 'chat',
      message: 'Press Enter to chat with other players.',
      action: 'openChat'
    },
    {
      id: 'complete',
      message: "You're ready! Explore the world, make friends, and build something beautiful.",
      action: 'complete',
      autoDismiss: true
    }
  ];

  /**
   * Create tutorial tooltip UI
   */
  function createTutorialTooltip() {
    if (typeof document === 'undefined') return null;

    var tooltip = document.createElement('div');
    tooltip.id = 'tutorial-tooltip';
    tooltip.style.cssText = `
      position: absolute;
      bottom: 240px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 12, 10, 0.92);
      border: 1px solid rgba(218, 165, 32, 0.4);
      border-radius: 8px;
      padding: 20px 25px;
      min-width: 400px;
      max-width: 500px;
      pointer-events: auto;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      animation: tutorialPulse 2s infinite;
    `;

    // Add CSS animation for pulsing glow
    var styleSheet = document.createElement('style');
    styleSheet.textContent = `
      @keyframes tutorialPulse {
        0%, 100% {
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 10px rgba(218, 165, 32, 0.2);
        }
        50% {
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(218, 165, 32, 0.5);
        }
      }
    `;
    document.head.appendChild(styleSheet);

    // Step counter
    var stepCounter = document.createElement('div');
    stepCounter.id = 'tutorial-step-counter';
    stepCounter.style.cssText = `
      color: #DAA520;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    `;
    tooltip.appendChild(stepCounter);

    // Message content
    var message = document.createElement('div');
    message.id = 'tutorial-message';
    message.style.cssText = `
      color: #ffffff;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 15px;
    `;
    tooltip.appendChild(message);

    // Button container
    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
      display: flex;
      justify-content: flex-end;
    `;

    // Skip button
    var skipButton = document.createElement('button');
    skipButton.id = 'tutorial-skip-btn';
    skipButton.textContent = 'Skip Tutorial';
    skipButton.style.cssText = `
      background: rgba(100, 100, 100, 0.3);
      border: 1px solid rgba(150, 150, 150, 0.4);
      color: #cccccc;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    `;
    skipButton.onmouseover = function() {
      skipButton.style.background = 'rgba(120, 120, 120, 0.4)';
      skipButton.style.borderColor = 'rgba(170, 170, 170, 0.6)';
    };
    skipButton.onmouseout = function() {
      skipButton.style.background = 'rgba(100, 100, 100, 0.3)';
      skipButton.style.borderColor = 'rgba(150, 150, 150, 0.4)';
    };
    skipButton.onclick = function() {
      skipTutorial();
    };
    buttonContainer.appendChild(skipButton);

    tooltip.appendChild(buttonContainer);

    return tooltip;
  }

  /**
   * Update tutorial tooltip content
   */
  function updateTutorialTooltip() {
    if (!tutorialTooltip || !tutorialState.active) return;

    var step = tutorialSteps[tutorialState.currentStep];
    var stepCounter = tutorialTooltip.querySelector('#tutorial-step-counter');
    var message = tutorialTooltip.querySelector('#tutorial-message');

    if (stepCounter) {
      stepCounter.textContent = 'Step ' + (tutorialState.currentStep + 1) + '/' + tutorialSteps.length;
    }

    if (message) {
      message.textContent = step.message;
    }
  }

  /**
   * Show tutorial tooltip
   */
  function showTutorialTooltip() {
    if (!hudContainer || typeof document === 'undefined') return;

    if (!tutorialTooltip) {
      tutorialTooltip = createTutorialTooltip();
      if (!tutorialTooltip) return;
    }

    var hudOverlay = document.getElementById('zion-hud');
    if (hudOverlay && tutorialTooltip.parentNode !== hudOverlay) {
      hudOverlay.appendChild(tutorialTooltip);
    }

    updateTutorialTooltip();
    tutorialTooltip.style.display = 'block';
  }

  /**
   * Hide tutorial tooltip
   */
  function hideTutorialTooltip() {
    if (tutorialTooltip) {
      tutorialTooltip.style.display = 'none';
    }
  }

  /**
   * Remove tutorial tooltip from DOM
   */
  function removeTutorialTooltip() {
    if (tutorialTooltip && tutorialTooltip.parentNode) {
      tutorialTooltip.parentNode.removeChild(tutorialTooltip);
      tutorialTooltip = null;
    }
  }

  /**
   * Initialize tutorial system
   * Called after login to check if player is new
   */
  function initTutorial() {
    if (typeof localStorage === 'undefined') {
      console.warn('Tutorial requires localStorage support');
      return;
    }

    // Check if tutorial is already complete
    var tutorialComplete = localStorage.getItem('zion_tutorial_complete');
    if (tutorialComplete === 'true') {
      tutorialState.completed = true;
      tutorialState.active = false;
      return;
    }

    // Start tutorial for new player
    tutorialState.active = true;
    tutorialState.currentStep = 0;
    tutorialState.completed = false;

    showTutorialTooltip();
  }

  /**
   * Advance tutorial to next step
   * @param {string} completedAction - The action that was completed (move, interact, openInventory, openQuests, openChat)
   */
  function advanceTutorial(completedAction) {
    if (!tutorialState.active || tutorialState.completed) return;

    var currentStep = tutorialSteps[tutorialState.currentStep];

    // Check if completed action matches current step
    if (currentStep.action !== completedAction) return;

    // Handle final step with auto-dismiss
    if (currentStep.autoDismiss) {
      setTimeout(function() {
        completeTutorial();
      }, 5000);
      return;
    }

    // Move to next step
    tutorialState.currentStep++;

    if (tutorialState.currentStep >= tutorialSteps.length) {
      completeTutorial();
      return;
    }

    // Update tooltip for next step
    updateTutorialTooltip();
  }

  /**
   * Complete tutorial and mark as done
   */
  function completeTutorial() {
    tutorialState.active = false;
    tutorialState.completed = true;

    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('zion_tutorial_complete', 'true');
    }

    hideTutorialTooltip();

    // Remove tooltip after a short delay to allow for fade out
    setTimeout(function() {
      removeTutorialTooltip();
    }, 300);

    // Show completion notification
    if (typeof showNotification === 'function') {
      showNotification('Tutorial Complete! Good luck in ZION!', 'success');
    }
  }

  /**
   * Skip tutorial and mark as complete
   */
  function skipTutorial() {
    completeTutorial();
  }

  /**
   * Check if tutorial is currently active
   * @returns {boolean} True if tutorial is active
   */
  function isTutorialActive() {
    return tutorialState.active;
  }

  // Export tutorial functions
  exports.initTutorial = initTutorial;
  exports.advanceTutorial = advanceTutorial;
  exports.skipTutorial = skipTutorial;
  exports.isTutorialActive = isTutorialActive;

})(typeof module !== 'undefined' ? module.exports : (window.HUD = {}));


// xr.js
(function(exports) {
  // WebXR integration for VR/AR
  let xrSession = null;
  let xrReferenceSpace = null;
  let lastPosition = { x: 0, y: 0, z: 0 };
  let lastCheckTime = 0;

  /**
   * Initialize XR and check capabilities
   * @returns {Promise<object>} - {vrSupported, arSupported}
   */
  async function initXR() {
    if (typeof navigator === 'undefined' || !navigator.xr) {
      console.warn('WebXR not available');
      return { vrSupported: false, arSupported: false };
    }

    try {
      const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      const arSupported = await navigator.xr.isSessionSupported('immersive-ar');

      console.log('XR capabilities:', { vrSupported, arSupported });

      return { vrSupported, arSupported };
    } catch (err) {
      console.error('Error checking XR support:', err);
      return { vrSupported: false, arSupported: false };
    }
  }

  /**
   * Enter VR mode
   * @param {THREE.WebGLRenderer} renderer - Three.js renderer
   * @param {THREE.Scene} scene - Three.js scene
   * @param {THREE.Camera} camera - Three.js camera
   * @returns {Promise<void>}
   */
  async function enterVR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    try {
      // Request VR session
      xrSession = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'bounded-floor']
      });

      // Enable XR on renderer
      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('VR session ended');
      });

      console.log('Entered VR mode');

      // Set up reference space
      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      // Start render loop
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter VR:', err);
      throw err;
    }
  }

  /**
   * Enter AR mode
   * @param {THREE.WebGLRenderer} renderer - Three.js renderer
   * @param {THREE.Scene} scene - Three.js scene
   * @param {THREE.Camera} camera - Three.js camera
   * @returns {Promise<void>}
   */
  async function enterAR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    // Show safety warning first
    const proceed = await showSafetyWarning();
    if (!proceed) {
      console.log('AR session cancelled by user');
      return;
    }

    try {
      // Request AR session
      xrSession = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['local-floor'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });

      // Enable XR on renderer
      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('AR session ended');
      });

      console.log('Entered AR mode');

      // Set up reference space
      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      // Make scene background transparent for AR
      scene.background = null;

      // Start render loop with speed checking
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          // Check speed periodically
          if (timestamp - lastCheckTime > 1000) { // Every second
            const pose = frame.getViewerPose(xrReferenceSpace);
            if (pose) {
              const position = pose.transform.position;
              const deltaTime = (timestamp - lastCheckTime) / 1000;
              const speedCheck = checkSpeed(position, lastPosition, deltaTime);

              if (!speedCheck.safe) {
                console.warn(`Speed too high: ${speedCheck.speed.toFixed(1)} km/h. Pausing AR.`);
                // Pause rendering or show warning
                showSpeedWarning(speedCheck.speed);
                return; // Skip rendering this frame
              }

              lastPosition = { x: position.x, y: position.y, z: position.z };
              lastCheckTime = timestamp;
            }
          }

          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter AR:', err);
      throw err;
    }
  }

  /**
   * Exit XR mode
   */
  async function exitXR() {
    if (xrSession) {
      await xrSession.end();
      xrSession = null;
      xrReferenceSpace = null;
      console.log('Exited XR mode');
    }
  }

  /**
   * Check movement speed (safety feature for AR)
   * @param {object} position - Current position {x, y, z}
   * @param {object} lastPosition - Previous position {x, y, z}
   * @param {number} deltaTime - Time elapsed in seconds
   * @returns {object} - {safe: boolean, speed: number (km/h)}
   */
  function checkSpeed(position, lastPosition, deltaTime) {
    if (!position || !lastPosition || deltaTime === 0) {
      return { safe: true, speed: 0 };
    }

    const dx = position.x - lastPosition.x;
    const dy = position.y - lastPosition.y;
    const dz = position.z - lastPosition.z;

    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    const speedMetersPerSecond = distance / deltaTime;
    const speedKmPerHour = speedMetersPerSecond * 3.6;

    const MAX_SAFE_SPEED = 25; // km/h (walking/jogging speed)

    return {
      safe: speedKmPerHour <= MAX_SAFE_SPEED,
      speed: speedKmPerHour
    };
  }

  /**
   * Show safety warning for AR (required per 8.6)
   * @returns {Promise<boolean>} - User accepted or not
   */
  function showSafetyWarning() {
    if (typeof document === 'undefined') {
      return Promise.resolve(true);
    }

    return new Promise((resolve) => {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        color: white;
        font-family: Arial, sans-serif;
      `;

      const content = document.createElement('div');
      content.style.cssText = `
        max-width: 500px;
        padding: 30px;
        background: rgba(20, 20, 20, 0.95);
        border-radius: 12px;
        border: 2px solid #ff6347;
        text-align: center;
      `;

      content.innerHTML = `
        <h2 style="color: #ff6347; margin-bottom: 20px;">AR Safety Warning</h2>
        <p style="margin-bottom: 15px; line-height: 1.6;">
          Please be aware of your surroundings while using AR mode.
        </p>
        <ul style="text-align: left; margin-bottom: 20px; line-height: 1.8;">
          <li>Do not use AR while driving or operating vehicles</li>
          <li>Stay aware of obstacles, traffic, and other hazards</li>
          <li>AR will pause automatically if moving faster than 25 km/h</li>
          <li>Use in safe, well-lit areas</li>
          <li>Take breaks if you feel disoriented</li>
        </ul>
        <p style="margin-bottom: 25px; font-weight: bold; color: #ffa500;">
          By continuing, you acknowledge these safety guidelines.
        </p>
        <div>
          <button id="ar-accept" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #4af;
            color: white;
            cursor: pointer;
            font-weight: bold;
          ">I Understand</button>
          <button id="ar-cancel" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #666;
            color: white;
            cursor: pointer;
          ">Cancel</button>
        </div>
      `;

      overlay.appendChild(content);
      document.body.appendChild(overlay);

      document.getElementById('ar-accept').addEventListener('click', () => {
        overlay.remove();
        resolve(true);
      });

      document.getElementById('ar-cancel').addEventListener('click', () => {
        overlay.remove();
        resolve(false);
      });
    });
  }

  /**
   * Show speed warning overlay
   * @param {number} speed - Current speed in km/h
   */
  function showSpeedWarning(speed) {
    if (typeof document === 'undefined') return;

    let warningEl = document.getElementById('ar-speed-warning');
    if (!warningEl) {
      warningEl = document.createElement('div');
      warningEl.id = 'ar-speed-warning';
      warningEl.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 12px;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        z-index: 10001;
        border: 4px solid white;
      `;
      document.body.appendChild(warningEl);
    }

    warningEl.innerHTML = `
      <div style="margin-bottom: 15px;">SPEED TOO HIGH</div>
      <div style="font-size: 48px; margin-bottom: 15px;">${speed.toFixed(0)} km/h</div>
      <div style="font-size: 18px;">AR paused for safety</div>
      <div style="font-size: 14px; margin-top: 10px;">Slow down to resume</div>
    `;

    warningEl.style.display = 'block';

    // Hide after a few seconds if speed normalized
    setTimeout(() => {
      if (warningEl) {
        warningEl.style.display = 'none';
      }
    }, 3000);
  }

  // Export public API
  exports.initXR = initXR;
  exports.enterVR = enterVR;
  exports.enterAR = enterAR;
  exports.exitXR = exitXR;
  exports.checkSpeed = checkSpeed;
  exports.showSafetyWarning = showSafetyWarning;

})(typeof module !== 'undefined' ? module.exports : (window.XR = {}));


// audio.js
(function(exports) {
  // Procedural audio system using Web Audio API
  // All audio is generated procedurally - no external files

  var audioContext = null;
  var masterGain = null;
  var isMuted = false;
  var currentAmbient = null;
  var volumeLevels = { master: 0.5, music: 0.5, sfx: 0.5 };

  /**
   * Initialize audio context
   * @returns {AudioContext|null}
   */
  function initAudio() {
    if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') {
      console.warn('Web Audio API not available');
      return null;
    }

    // Defer AudioContext creation until first user gesture to avoid browser warnings
    var resumeEvents = ['click', 'touchstart', 'keydown'];
    function createOnGesture() {
      if (audioContext) return;
      try {
        audioContext = new (AudioContext || webkitAudioContext)();
        masterGain = audioContext.createGain();
        if (masterGain) {
          masterGain.connect(audioContext.destination);
          masterGain.gain.value = 0.5;
        }
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        console.log('Audio system initialized (after user gesture)');
      } catch (err) {
        console.error('Failed to initialize audio:', err);
      }
      resumeEvents.forEach(function(evt) {
        document.removeEventListener(evt, createOnGesture);
      });
    }
    resumeEvents.forEach(function(evt) {
      document.addEventListener(evt, createOnGesture, { once: false });
    });

    console.log('Audio system deferred until user gesture');
    return true;
  }

  /**
   * Create white noise buffer
   * @returns {AudioBufferSourceNode|null}
   */
  function createWhiteNoise() {
    if (!audioContext) return null;

    try {
      const bufferSize = 2 * audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }

      const whiteNoise = audioContext.createBufferSource();
      whiteNoise.buffer = noiseBuffer;
      whiteNoise.loop = true;
      whiteNoise.start();

      return whiteNoise;
    } catch (err) {
      console.error('Error creating white noise:', err);
      return null;
    }
  }

  /**
   * Play zone-specific ambient sound
   * @param {string} zone - Zone identifier
   */
  function playAmbient(zone) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Stop current ambient
    if (currentAmbient) {
      stopAmbient();
    }

    try {
      switch (zone) {
        case 'nexus':
          currentAmbient = playNexusAmbient();
          break;
        case 'gardens':
          currentAmbient = playGardensAmbient();
          break;
        case 'athenaeum':
          currentAmbient = playAthenaeumAmbient();
          break;
        case 'studio':
          currentAmbient = playStudioAmbient();
          break;
        case 'wilds':
          currentAmbient = playWildsAmbient();
          break;
        case 'agora':
          currentAmbient = playAgoraAmbient();
          break;
        case 'commons':
          currentAmbient = playCommonsAmbient();
          break;
        case 'arena':
          currentAmbient = playArenaAmbient();
          break;
        default:
          currentAmbient = null;
      }
    } catch (err) {
      console.error('Error playing ambient:', err);
    }
  }

  /**
   * Stop current ambient sound
   */
  function stopAmbient() {
    if (!currentAmbient) return;

    try {
      // Stop all oscillators
      if (currentAmbient.oscillators && Array.isArray(currentAmbient.oscillators)) {
        currentAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      // Stop and disconnect all nodes
      if (currentAmbient.nodes && Array.isArray(currentAmbient.nodes)) {
        currentAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      // Disconnect gain
      if (currentAmbient.gain && currentAmbient.gain.disconnect) {
        try { currentAmbient.gain.disconnect(); } catch (e) {}
      }

      // Clear all intervals
      if (currentAmbient.intervals && Array.isArray(currentAmbient.intervals)) {
        currentAmbient.intervals.forEach(id => clearInterval(id));
      }

      // Clear all timeouts
      if (currentAmbient.timeouts && Array.isArray(currentAmbient.timeouts)) {
        currentAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      // Call cleanup function if exists
      if (currentAmbient.cleanup && typeof currentAmbient.cleanup === 'function') {
        currentAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping ambient:', err);
    }

    currentAmbient = null;
  }

  /**
   * NEXUS - Sacred gathering place
   * Deep drone + ethereal pad + crystalline chimes
   */
  function playNexusAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Deep resonant drone - C2 (65Hz) with octave harmonics
      const drone1 = audioContext.createOscillator();
      const drone2 = audioContext.createOscillator();
      const droneGain = audioContext.createGain();

      drone1.type = 'sine';
      drone1.frequency.value = 65.41; // C2
      drone2.type = 'sine';
      drone2.frequency.value = 130.81; // C3

      droneGain.gain.value = 0.03;

      drone1.connect(droneGain);
      drone2.connect(droneGain);
      droneGain.connect(masterGain);

      drone1.start();
      drone2.start();

      oscillators.push(drone1, drone2);
      nodes.push(droneGain);

      // Ethereal pad - C4, E4, G4 triad with slow LFO
      const pad1 = audioContext.createOscillator();
      const pad2 = audioContext.createOscillator();
      const pad3 = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      const padGain = audioContext.createGain();

      pad1.type = 'sine';
      pad1.frequency.value = 261.63; // C4
      pad2.type = 'sine';
      pad2.frequency.value = 329.63; // E4
      pad3.type = 'sine';
      pad3.frequency.value = 392.00; // G4

      lfo.type = 'sine';
      lfo.frequency.value = 0.2; // Slow modulation
      lfoGain.gain.value = 0.01; // Subtle volume modulation

      padGain.gain.value = 0.02;

      lfo.connect(lfoGain);
      lfoGain.connect(padGain.gain);

      pad1.connect(padGain);
      pad2.connect(padGain);
      pad3.connect(padGain);
      padGain.connect(masterGain);

      pad1.start();
      pad2.start();
      pad3.start();
      lfo.start();

      oscillators.push(pad1, pad2, pad3, lfo);
      nodes.push(lfoGain, padGain);

      // Crystalline chimes - random high notes with delays
      function playChime() {
        if (!audioContext || !masterGain) return;

        const chime = audioContext.createOscillator();
        const chimeGain = audioContext.createGain();
        const delay1 = audioContext.createDelay();
        const delay2 = audioContext.createDelay();
        const delayGain1 = audioContext.createGain();
        const delayGain2 = audioContext.createGain();

        chime.type = 'sine';
        chime.frequency.value = 1000 + Math.random() * 1000;

        chimeGain.gain.value = 0.08;
        chimeGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

        delay1.delayTime.value = 0.3;
        delay2.delayTime.value = 0.5;
        delayGain1.gain.value = 0.3;
        delayGain2.gain.value = 0.2;

        chime.connect(chimeGain);
        chimeGain.connect(masterGain);
        chimeGain.connect(delay1);
        chimeGain.connect(delay2);
        delay1.connect(delayGain1);
        delay2.connect(delayGain2);
        delayGain1.connect(masterGain);
        delayGain2.connect(masterGain);

        chime.start();
        chime.stop(audioContext.currentTime + 1.5);

        const nextChime = setTimeout(playChime, 4000 + Math.random() * 4000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(playChime, 2000);
      timeouts.push(firstChime);

      return { oscillators, nodes, timeouts };
    } catch (err) {
      console.error('Error in nexus ambient:', err);
      return null;
    }
  }

  /**
   * GARDENS - Lush natural space
   * Bird chorus + gentle stream + breeze + crickets + rustling leaves
   */
  function playGardensAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Gentle stream - filtered white noise with LFO
      const stream = createWhiteNoise();
      if (stream) {
        const streamFilter = audioContext.createBiquadFilter();
        const streamLfo = audioContext.createOscillator();
        const streamLfoGain = audioContext.createGain();
        const streamGain = audioContext.createGain();

        streamFilter.type = 'lowpass';
        streamFilter.frequency.value = 400;

        streamLfo.type = 'sine';
        streamLfo.frequency.value = 0.5;
        streamLfoGain.gain.value = 100; // Modulate filter frequency

        streamGain.gain.value = 0.04;

        streamLfo.connect(streamLfoGain);
        streamLfoGain.connect(streamFilter.frequency);

        stream.connect(streamFilter);
        streamFilter.connect(streamGain);
        streamGain.connect(masterGain);

        streamLfo.start();

        nodes.push(stream, streamFilter, streamLfo, streamLfoGain, streamGain);
      }

      // Breeze - very low filtered noise
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 200;
        breezeGain.gain.value = 0.02;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Bird chorus - multiple chirp generators
      function chirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 600 + Math.random() * 1200;

        const duration = 0.1 + Math.random() * 0.2;
        birdGain.gain.value = 0.06;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(chirp, 500 + Math.random() * 3500);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 3; i++) {
        const firstChirp = setTimeout(chirp, Math.random() * 2000);
        timeouts.push(firstChirp);
      }

      // Crickets - oscillating high frequency with AM
      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 4500;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 20; // 20 Hz modulation
      cricketAmGain.gain.value = 0.015;

      cricketGain.gain.value = 0.015;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      nodes.push(cricket, cricketAm, cricketAmGain, cricketGain);

      // Rustling leaves
      function rustle() {
        if (!audioContext || !masterGain) return;

        const noise = createWhiteNoise();
        if (noise) {
          const rustleFilter = audioContext.createBiquadFilter();
          const rustleGain = audioContext.createGain();

          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 2000;
          rustleFilter.Q.value = 2;

          rustleGain.gain.value = 0.04;
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

          noise.connect(rustleFilter);
          rustleFilter.connect(rustleGain);
          rustleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (noise.stop) noise.stop();
              if (rustleFilter.disconnect) rustleFilter.disconnect();
              if (rustleGain.disconnect) rustleGain.disconnect();
            } catch (e) {}
          }, 400);
        }

        const nextRustle = setTimeout(rustle, 2000 + Math.random() * 3000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 1000);
      timeouts.push(firstRustle);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in gardens ambient:', err);
      return null;
    }
  }

  /**
   * ATHENAEUM - Library/knowledge hall
   * Deep silence + page turning + quill writing + distant footsteps + clock ticking
   */
  function playAthenaeumAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Room tone - very quiet
      const roomTone = createWhiteNoise();
      if (roomTone) {
        const roomGain = audioContext.createGain();
        roomGain.gain.value = 0.01;

        roomTone.connect(roomGain);
        roomGain.connect(masterGain);

        nodes.push(roomTone, roomGain);
      }

      // Page turning
      function turnPage() {
        if (!audioContext || !masterGain) return;

        const page = createWhiteNoise();
        if (page) {
          const pageFilter = audioContext.createBiquadFilter();
          const pageGain = audioContext.createGain();

          pageFilter.type = 'highpass';
          pageFilter.frequency.value = 2000;

          pageGain.gain.value = 0.03;
          pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

          page.connect(pageFilter);
          pageFilter.connect(pageGain);
          pageGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (page.stop) page.stop();
              if (pageFilter.disconnect) pageFilter.disconnect();
              if (pageGain.disconnect) pageGain.disconnect();
            } catch (e) {}
          }, 150);
        }

        const nextPage = setTimeout(turnPage, 8000 + Math.random() * 7000);
        timeouts.push(nextPage);
      }

      const firstPage = setTimeout(turnPage, 3000);
      timeouts.push(firstPage);

      // Quill writing - intermittent
      function writeQuill() {
        if (!audioContext || !masterGain) return;

        const quill = createWhiteNoise();
        if (quill) {
          const quillFilter = audioContext.createBiquadFilter();
          const quillGain = audioContext.createGain();

          quillFilter.type = 'bandpass';
          quillFilter.frequency.value = 3000;
          quillFilter.Q.value = 5;

          quillGain.gain.value = 0.05;

          quill.connect(quillFilter);
          quillFilter.connect(quillGain);
          quillGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (quill.stop) quill.stop();
              if (quillFilter.disconnect) quillFilter.disconnect();
              if (quillGain.disconnect) quillGain.disconnect();
            } catch (e) {}
          }, 200 + Math.random() * 500);
        }

        const nextQuill = setTimeout(writeQuill, 5000 + Math.random() * 10000);
        timeouts.push(nextQuill);
      }

      const firstQuill = setTimeout(writeQuill, 5000);
      timeouts.push(firstQuill);

      // Distant footsteps
      function footstep() {
        if (!audioContext || !masterGain) return;

        const step = audioContext.createOscillator();
        const stepGain = audioContext.createGain();

        step.type = 'sine';
        step.frequency.value = 60;

        stepGain.gain.value = 0.03;
        stepGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

        step.connect(stepGain);
        stepGain.connect(masterGain);

        step.start();
        step.stop(audioContext.currentTime + 0.05);

        const nextStep = setTimeout(footstep, 5000 + Math.random() * 5000);
        timeouts.push(nextStep);
      }

      const firstStep = setTimeout(footstep, 2000);
      timeouts.push(firstStep);

      // Clock ticking
      function tick() {
        if (!audioContext || !masterGain) return;

        const click = audioContext.createOscillator();
        const clickGain = audioContext.createGain();

        click.type = 'sine';
        click.frequency.value = 800;

        clickGain.gain.value = 0.02;
        clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

        click.connect(clickGain);
        clickGain.connect(masterGain);

        click.start();
        click.stop(audioContext.currentTime + 0.02);
      }

      const tickInterval = setInterval(tick, 1000);
      intervals.push(tickInterval);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in athenaeum ambient:', err);
      return null;
    }
  }

  /**
   * STUDIO - Creative workshop
   * Rhythmic tapping + metallic chimes + creative hum + melodic phrases
   */
  function playStudioAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Creative energy hum - 110Hz with modulation
      const hum = audioContext.createOscillator();
      const humLfo = audioContext.createOscillator();
      const humLfoGain = audioContext.createGain();
      const humGain = audioContext.createGain();

      hum.type = 'sine';
      hum.frequency.value = 110;

      humLfo.type = 'sine';
      humLfo.frequency.value = 0.3;
      humLfoGain.gain.value = 2;

      humGain.gain.value = 0.03;

      humLfo.connect(humLfoGain);
      humLfoGain.connect(hum.frequency);

      hum.connect(humGain);
      humGain.connect(masterGain);

      hum.start();
      humLfo.start();

      oscillators.push(hum, humLfo);
      nodes.push(humLfoGain, humGain);

      // Rhythmic tapping
      function tap() {
        if (!audioContext || !masterGain) return;

        const thud = audioContext.createOscillator();
        const thudGain = audioContext.createGain();

        thud.type = 'sine';
        thud.frequency.value = 100 + Math.random() * 200;

        thudGain.gain.value = 0.05;
        thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

        thud.connect(thudGain);
        thudGain.connect(masterGain);

        thud.start();
        thud.stop(audioContext.currentTime + 0.08);

        const nextTap = setTimeout(tap, 500 + Math.random() * 1500);
        timeouts.push(nextTap);
      }

      const firstTap = setTimeout(tap, 500);
      timeouts.push(firstTap);

      // Metallic chimes
      function chime() {
        if (!audioContext || !masterGain) return;

        const bell = audioContext.createOscillator();
        const bellGain = audioContext.createGain();

        bell.type = 'triangle';
        bell.frequency.value = 500 + Math.random() * 700;

        bellGain.gain.value = 0.04;
        bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);

        bell.connect(bellGain);
        bellGain.connect(masterGain);

        bell.start();
        bell.stop(audioContext.currentTime + 1.2);

        const nextChime = setTimeout(chime, 3000 + Math.random() * 5000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(chime, 2000);
      timeouts.push(firstChime);

      // Melodic phrases
      function melody() {
        if (!audioContext || !masterGain) return;

        const notes = [261.63, 293.66, 329.63, 392.00, 440.00]; // C, D, E, G, A
        const numNotes = 3 + Math.floor(Math.random() * 3);

        for (let i = 0; i < numNotes; i++) {
          const note = audioContext.createOscillator();
          const noteGain = audioContext.createGain();

          note.type = 'sine';
          note.frequency.value = notes[Math.floor(Math.random() * notes.length)];

          const startTime = audioContext.currentTime + i * 0.2;
          noteGain.gain.setValueAtTime(0, startTime);
          noteGain.gain.linearRampToValueAtTime(0.03, startTime + 0.05);
          noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

          note.connect(noteGain);
          noteGain.connect(masterGain);

          note.start(startTime);
          note.stop(startTime + 0.4);
        }

        const nextMelody = setTimeout(melody, 15000 + Math.random() * 15000);
        timeouts.push(nextMelody);
      }

      const firstMelody = setTimeout(melody, 10000);
      timeouts.push(firstMelody);

      return { oscillators, nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in studio ambient:', err);
      return null;
    }
  }

  /**
   * WILDS - Untamed wilderness
   * Heavy wind + wolf howls + thunder + rustling + owl hoots
   */
  function playWildsAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Heavy wind with varying intensity
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 150;
        windGain.gain.value = 0.08;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);

        // Vary wind intensity
        function varyWind() {
          if (!windGain || !audioContext) return;
          const target = 0.05 + Math.random() * 0.06;
          windGain.gain.linearRampToValueAtTime(target, audioContext.currentTime + 3);
        }

        const windInterval = setInterval(varyWind, 4000);
        intervals.push(windInterval);
      }

      // Wolf howls
      function howl() {
        if (!audioContext || !masterGain) return;

        const wolf = audioContext.createOscillator();
        const wolfVibrato = audioContext.createOscillator();
        const wolfVibratoGain = audioContext.createGain();
        const wolfGain = audioContext.createGain();

        wolf.type = 'sine';
        wolf.frequency.value = 400;

        wolfVibrato.type = 'sine';
        wolfVibrato.frequency.value = 5;
        wolfVibratoGain.gain.value = 15;

        wolfGain.gain.value = 0.04;

        wolfVibrato.connect(wolfVibratoGain);
        wolfVibratoGain.connect(wolf.frequency);

        wolf.connect(wolfGain);
        wolfGain.connect(masterGain);

        wolf.start();
        wolfVibrato.start();

        wolf.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 1);
        wolf.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 2);
        wolfGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        wolf.stop(audioContext.currentTime + 2.5);
        wolfVibrato.stop(audioContext.currentTime + 2.5);

        const nextHowl = setTimeout(howl, 20000 + Math.random() * 20000);
        timeouts.push(nextHowl);
      }

      const firstHowl = setTimeout(howl, 5000);
      timeouts.push(firstHowl);

      // Thunder rumble
      function thunder() {
        if (!audioContext || !masterGain) return;

        const rumble = createWhiteNoise();
        if (rumble) {
          const rumbleFilter = audioContext.createBiquadFilter();
          const rumbleGain = audioContext.createGain();

          rumbleFilter.type = 'lowpass';
          rumbleFilter.frequency.value = 60;

          rumbleGain.gain.value = 0.12;
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);

          rumble.connect(rumbleFilter);
          rumbleFilter.connect(rumbleGain);
          rumbleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (rumble.stop) rumble.stop();
              if (rumbleFilter.disconnect) rumbleFilter.disconnect();
              if (rumbleGain.disconnect) rumbleGain.disconnect();
            } catch (e) {}
          }, 2500);
        }

        const nextThunder = setTimeout(thunder, 30000 + Math.random() * 30000);
        timeouts.push(nextThunder);
      }

      const firstThunder = setTimeout(thunder, 15000);
      timeouts.push(firstThunder);

      // Rustling underbrush
      function rustle() {
        if (!audioContext || !masterGain) return;

        const brush = createWhiteNoise();
        if (brush) {
          const brushFilter = audioContext.createBiquadFilter();
          const brushGain = audioContext.createGain();

          brushFilter.type = 'bandpass';
          brushFilter.frequency.value = 1000;
          brushFilter.Q.value = 2;

          brushGain.gain.value = 0.05;
          brushGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

          brush.connect(brushFilter);
          brushFilter.connect(brushGain);
          brushGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (brush.stop) brush.stop();
              if (brushFilter.disconnect) brushFilter.disconnect();
              if (brushGain.disconnect) brushGain.disconnect();
            } catch (e) {}
          }, 400);
        }

        const nextRustle = setTimeout(rustle, 3000 + Math.random() * 4000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 2000);
      timeouts.push(firstRustle);

      // Owl hoots
      function hoot() {
        if (!audioContext || !masterGain) return;

        // Two-tone hoot
        const hoot1 = audioContext.createOscillator();
        const hoot1Gain = audioContext.createGain();

        hoot1.type = 'sine';
        hoot1.frequency.value = 350;

        hoot1Gain.gain.value = 0.04;
        hoot1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        hoot1.connect(hoot1Gain);
        hoot1Gain.connect(masterGain);

        hoot1.start();
        hoot1.stop(audioContext.currentTime + 0.3);

        // Second hoot
        const hoot2 = audioContext.createOscillator();
        const hoot2Gain = audioContext.createGain();

        hoot2.type = 'sine';
        hoot2.frequency.value = 280;

        hoot2Gain.gain.setValueAtTime(0, audioContext.currentTime + 0.35);
        hoot2Gain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.4);
        hoot2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.7);

        hoot2.connect(hoot2Gain);
        hoot2Gain.connect(masterGain);

        hoot2.start(audioContext.currentTime + 0.35);
        hoot2.stop(audioContext.currentTime + 0.7);

        const nextHoot = setTimeout(hoot, 15000 + Math.random() * 10000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(hoot, 8000);
      timeouts.push(firstHoot);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in wilds ambient:', err);
      return null;
    }
  }

  /**
   * AGORA - Marketplace
   * Crowd murmur + vendor calls + coin sounds + cart wheels
   */
  function playAgoraAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Crowd murmur - bandpass filtered noise with modulation
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdLfo = audioContext.createOscillator();
        const crowdLfoGain = audioContext.createGain();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 500;
        crowdFilter.Q.value = 1;

        crowdLfo.type = 'sine';
        crowdLfo.frequency.value = 0.4;
        crowdLfoGain.gain.value = 0.02;

        crowdGain.gain.value = 0.05;

        crowdLfo.connect(crowdLfoGain);
        crowdLfoGain.connect(crowdGain.gain);

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        crowdLfo.start();

        nodes.push(crowd, crowdFilter, crowdLfo, crowdLfoGain, crowdGain);
      }

      // Vendor calls - short melodic phrases
      function vendorCall() {
        if (!audioContext || !masterGain) return;

        const notes = [220, 247, 262, 294, 330, 349, 392, 440, 494];
        const numNotes = 2 + Math.floor(Math.random() * 2);

        for (let i = 0; i < numNotes; i++) {
          const call = audioContext.createOscillator();
          const callGain = audioContext.createGain();

          call.type = 'sine';
          call.frequency.value = notes[Math.floor(Math.random() * notes.length)];

          const startTime = audioContext.currentTime + i * 0.15;
          callGain.gain.setValueAtTime(0, startTime);
          callGain.gain.linearRampToValueAtTime(0.04, startTime + 0.05);
          callGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

          call.connect(callGain);
          callGain.connect(masterGain);

          call.start(startTime);
          call.stop(startTime + 0.25);
        }

        const nextCall = setTimeout(vendorCall, 8000 + Math.random() * 7000);
        timeouts.push(nextCall);
      }

      const firstCall = setTimeout(vendorCall, 3000);
      timeouts.push(firstCall);

      // Coin sounds
      function coinDrop() {
        if (!audioContext || !masterGain) return;

        const coin = audioContext.createOscillator();
        const coinGain = audioContext.createGain();

        coin.type = 'triangle';
        coin.frequency.value = 2000 + Math.random() * 1000;

        coinGain.gain.value = 0.03;
        coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        coin.connect(coinGain);
        coinGain.connect(masterGain);

        coin.start();
        coin.stop(audioContext.currentTime + 0.15);

        const nextCoin = setTimeout(coinDrop, 3000 + Math.random() * 5000);
        timeouts.push(nextCoin);
      }

      const firstCoin = setTimeout(coinDrop, 2000);
      timeouts.push(firstCoin);

      // Cart wheels rumbling
      function cartRumble() {
        if (!audioContext || !masterGain) return;

        const cart = createWhiteNoise();
        if (cart) {
          const cartFilter = audioContext.createBiquadFilter();
          const cartGain = audioContext.createGain();

          cartFilter.type = 'lowpass';
          cartFilter.frequency.value = 80;

          cartGain.gain.value = 0.04;
          cartGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);

          cart.connect(cartFilter);
          cartFilter.connect(cartGain);
          cartGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (cart.stop) cart.stop();
              if (cartFilter.disconnect) cartFilter.disconnect();
              if (cartGain.disconnect) cartGain.disconnect();
            } catch (e) {}
          }, 2500);
        }

        const nextCart = setTimeout(cartRumble, 15000 + Math.random() * 15000);
        timeouts.push(nextCart);
      }

      const firstCart = setTimeout(cartRumble, 5000);
      timeouts.push(firstCart);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in agora ambient:', err);
      return null;
    }
  }

  /**
   * COMMONS - Building/community area
   * Hammering + sawing + chatter + fire crackling
   */
  function playCommonsAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Friendly chatter
      const chatter = createWhiteNoise();
      if (chatter) {
        const chatterFilter = audioContext.createBiquadFilter();
        const chatterGain = audioContext.createGain();

        chatterFilter.type = 'bandpass';
        chatterFilter.frequency.value = 450;
        chatterFilter.Q.value = 1.5;

        chatterGain.gain.value = 0.03;

        chatter.connect(chatterFilter);
        chatterFilter.connect(chatterGain);
        chatterGain.connect(masterGain);

        nodes.push(chatter, chatterFilter, chatterGain);
      }

      // Fire crackling - continuous random bursts
      function crackle() {
        if (!audioContext || !masterGain) return;

        const fire = createWhiteNoise();
        if (fire) {
          const fireFilter = audioContext.createBiquadFilter();
          const fireGain = audioContext.createGain();

          fireFilter.type = 'bandpass';
          fireFilter.frequency.value = 1500 + Math.random() * 1500;
          fireFilter.Q.value = 3;

          const gain = 0.01 + Math.random() * 0.02;
          fireGain.gain.value = gain;
          fireGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

          fire.connect(fireFilter);
          fireFilter.connect(fireGain);
          fireGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (fire.stop) fire.stop();
              if (fireFilter.disconnect) fireFilter.disconnect();
              if (fireGain.disconnect) fireGain.disconnect();
            } catch (e) {}
          }, 150);
        }

        const nextCrackle = setTimeout(crackle, 100 + Math.random() * 300);
        timeouts.push(nextCrackle);
      }

      const firstCrackle = setTimeout(crackle, 500);
      timeouts.push(firstCrackle);

      // Hammering - rhythmic with pauses
      let hammerActive = true;
      function hammer() {
        if (!audioContext || !masterGain || !hammerActive) return;

        const thunk = audioContext.createOscillator();
        const thunkGain = audioContext.createGain();

        thunk.type = 'square';
        thunk.frequency.value = 80;

        thunkGain.gain.value = 0.06;
        thunkGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

        thunk.connect(thunkGain);
        thunkGain.connect(masterGain);

        thunk.start();
        thunk.stop(audioContext.currentTime + 0.1);

        const nextHammer = setTimeout(hammer, 800 + Math.random() * 400);
        timeouts.push(nextHammer);
      }

      function toggleHammer() {
        hammerActive = !hammerActive;
        if (hammerActive) {
          hammer();
        }
      }

      const firstHammer = setTimeout(hammer, 1000);
      timeouts.push(firstHammer);

      const hammerToggle = setInterval(toggleHammer, 8000);
      intervals.push(hammerToggle);

      // Sawing - filtered noise sweep
      let sawActive = false;
      function saw() {
        if (!audioContext || !masterGain || !sawActive) return;

        const sawNoise = createWhiteNoise();
        if (sawNoise) {
          const sawFilter = audioContext.createBiquadFilter();
          const sawGain = audioContext.createGain();

          sawFilter.type = 'bandpass';
          sawFilter.frequency.value = 400;
          sawFilter.Q.value = 5;

          sawGain.gain.value = 0.04;

          sawNoise.connect(sawFilter);
          sawFilter.connect(sawGain);
          sawGain.connect(masterGain);

          sawFilter.frequency.linearRampToValueAtTime(1000, audioContext.currentTime + 0.5);

          setTimeout(() => {
            try {
              if (sawNoise.stop) sawNoise.stop();
              if (sawFilter.disconnect) sawFilter.disconnect();
              if (sawGain.disconnect) sawGain.disconnect();
            } catch (e) {}
          }, 550);
        }

        const nextSaw = setTimeout(saw, 1000);
        timeouts.push(nextSaw);
      }

      function toggleSaw() {
        sawActive = !sawActive;
        if (sawActive) {
          saw();
        }
      }

      const sawToggle = setInterval(toggleSaw, 6000);
      intervals.push(sawToggle);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in commons ambient:', err);
      return null;
    }
  }

  /**
   * ARENA - Competition grounds
   * Crowd roar + drum beats + clash sounds + horn call
   */
  function playArenaAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Crowd roar with periodic swells
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 600;
        crowdFilter.Q.value = 0.8;

        crowdGain.gain.value = 0.06;

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        nodes.push(crowd, crowdFilter, crowdGain);

        // Periodic swells
        function swell() {
          if (!crowdGain || !audioContext) return;
          crowdGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 2);
          crowdGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 4);
        }

        const swellInterval = setInterval(swell, 12000);
        intervals.push(swellInterval);
      }

      // Drum beats - rhythmic at 120 BPM
      function drumBeat() {
        if (!audioContext || !masterGain) return;

        const drum = audioContext.createOscillator();
        const drumGain = audioContext.createGain();

        drum.type = 'sine';
        drum.frequency.value = 55;

        drumGain.gain.value = 0.08;
        drumGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        drum.connect(drumGain);
        drumGain.connect(masterGain);

        drum.start();
        drum.stop(audioContext.currentTime + 0.15);
      }

      const drumInterval = setInterval(drumBeat, 500); // 120 BPM
      intervals.push(drumInterval);

      // Clash sounds
      function clash() {
        if (!audioContext || !masterGain) return;

        const metal = createWhiteNoise();
        if (metal) {
          const metalFilter = audioContext.createBiquadFilter();
          const metalGain = audioContext.createGain();

          metalFilter.type = 'bandpass';
          metalFilter.frequency.value = 3000;
          metalFilter.Q.value = 3;

          metalGain.gain.value = 0.06;
          metalGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

          metal.connect(metalFilter);
          metalFilter.connect(metalGain);
          metalGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (metal.stop) metal.stop();
              if (metalFilter.disconnect) metalFilter.disconnect();
              if (metalGain.disconnect) metalGain.disconnect();
            } catch (e) {}
          }, 250);
        }

        const nextClash = setTimeout(clash, 5000 + Math.random() * 5000);
        timeouts.push(nextClash);
      }

      const firstClash = setTimeout(clash, 3000);
      timeouts.push(firstClash);

      // Horn call
      function hornCall() {
        if (!audioContext || !masterGain) return;

        const horn = audioContext.createOscillator();
        const hornGain = audioContext.createGain();

        horn.type = 'sawtooth';
        horn.frequency.value = 220;

        hornGain.gain.setValueAtTime(0, audioContext.currentTime);
        hornGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.2);
        hornGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.8);
        hornGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);

        horn.connect(hornGain);
        hornGain.connect(masterGain);

        horn.start();
        horn.stop(audioContext.currentTime + 1);

        const nextHorn = setTimeout(hornCall, 20000 + Math.random() * 10000);
        timeouts.push(nextHorn);
      }

      const firstHorn = setTimeout(hornCall, 10000);
      timeouts.push(firstHorn);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in arena ambient:', err);
      return null;
    }
  }

  /**
   * Play UI sound effect
   * @param {string} type - Sound type
   */
  function playSound(type) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (type) {
        case 'chat':
          playChatSound();
          break;
        case 'warp':
          playWarpSound();
          break;
        case 'harvest':
          playHarvestSound();
          break;
        case 'build':
          playBuildSound();
          break;
        case 'trade':
          playTradeSound();
          break;
        case 'trade_request':
          playTradeRequestSound();
          break;
        case 'discover':
          playDiscoverSound();
          break;
        case 'challenge':
          playChallengeSound();
          break;
        case 'levelup':
          playLevelUpSound();
          break;
        case 'level_up':
          playLevelUpSound();
          break;
        case 'error':
          playErrorSound();
          break;
        case 'notification':
          playNotificationSound();
          break;
        case 'craft_complete':
          playCraftCompleteSound();
          break;
        case 'quest_accept':
          playQuestAcceptSound();
          break;
        case 'quest_complete':
          playQuestCompleteSound();
          break;
        case 'item_pickup':
          playItemPickupSound();
          break;
        case 'npc_greet':
          playNPCGreetSound();
          break;
        case 'portal_enter':
          playPortalEnterSound();
          break;
        case 'build_place':
          playBuildPlaceSound();
          break;
        case 'footstep':
          playFootstepSound();
          break;
        default:
          console.warn('Unknown sound type:', type);
      }
    } catch (err) {
      console.error('Error playing sound:', err);
    }
  }

  /**
   * Chat sound - two-tone blip ascending
   */
  function playChatSound() {
    if (!audioContext || !masterGain) return;

    const blip1 = audioContext.createOscillator();
    const blip1Gain = audioContext.createGain();

    blip1.type = 'sine';
    blip1.frequency.value = 600;

    blip1Gain.gain.value = 0.15;
    blip1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

    blip1.connect(blip1Gain);
    blip1Gain.connect(masterGain);

    blip1.start();
    blip1.stop(audioContext.currentTime + 0.05);

    const blip2 = audioContext.createOscillator();
    const blip2Gain = audioContext.createGain();

    blip2.type = 'sine';
    blip2.frequency.value = 900;

    blip2Gain.gain.setValueAtTime(0, audioContext.currentTime + 0.05);
    blip2Gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.06);
    blip2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

    blip2.connect(blip2Gain);
    blip2Gain.connect(masterGain);

    blip2.start(audioContext.currentTime + 0.05);
    blip2.stop(audioContext.currentTime + 0.1);
  }

  /**
   * Warp sound - sweeping whoosh with reverb
   */
  function playWarpSound() {
    if (!audioContext || !masterGain) return;

    const warp = audioContext.createOscillator();
    const warpGain = audioContext.createGain();
    const delay1 = audioContext.createDelay();
    const delay2 = audioContext.createDelay();
    const delayGain1 = audioContext.createGain();
    const delayGain2 = audioContext.createGain();

    warp.type = 'sawtooth';
    warp.frequency.value = 800;
    warp.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);

    warpGain.gain.value = 0.2;
    warpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    delay1.delayTime.value = 0.1;
    delay2.delayTime.value = 0.2;
    delayGain1.gain.value = 0.3;
    delayGain2.gain.value = 0.2;

    warp.connect(warpGain);
    warpGain.connect(masterGain);
    warpGain.connect(delay1);
    warpGain.connect(delay2);
    delay1.connect(delayGain1);
    delay2.connect(delayGain2);
    delayGain1.connect(masterGain);
    delayGain2.connect(masterGain);

    warp.start();
    warp.stop(audioContext.currentTime + 0.5);
  }

  /**
   * Harvest sound - satisfying pluck with harmonic
   */
  function playHarvestSound() {
    if (!audioContext || !masterGain) return;

    const pluck = audioContext.createOscillator();
    const harmonic = audioContext.createOscillator();
    const pluckGain = audioContext.createGain();

    pluck.type = 'triangle';
    pluck.frequency.value = 330;

    harmonic.type = 'triangle';
    harmonic.frequency.value = 660;

    pluckGain.gain.value = 0.25;
    pluckGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    pluck.connect(pluckGain);
    harmonic.connect(pluckGain);
    pluckGain.connect(masterGain);

    pluck.start();
    harmonic.start();
    pluck.stop(audioContext.currentTime + 0.3);
    harmonic.stop(audioContext.currentTime + 0.3);
  }

  /**
   * Build sound - heavy thump + click
   */
  function playBuildSound() {
    if (!audioContext || !masterGain) return;

    const thump = audioContext.createOscillator();
    const thumpGain = audioContext.createGain();

    thump.type = 'square';
    thump.frequency.value = 80;

    thumpGain.gain.value = 0.25;
    thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

    thump.connect(thumpGain);
    thumpGain.connect(masterGain);

    thump.start();
    thump.stop(audioContext.currentTime + 0.15);

    const click = audioContext.createOscillator();
    const clickGain = audioContext.createGain();

    click.type = 'sine';
    click.frequency.value = 2000;

    clickGain.gain.value = 0.15;
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

    click.connect(clickGain);
    clickGain.connect(masterGain);

    click.start();
    click.stop(audioContext.currentTime + 0.02);
  }

  /**
   * Trade sound - coin ding with shimmer
   */
  function playTradeSound() {
    if (!audioContext || !masterGain) return;

    const coin1 = audioContext.createOscillator();
    const coin2 = audioContext.createOscillator();
    const wobble = audioContext.createOscillator();
    const wobbleGain = audioContext.createGain();
    const coinGain = audioContext.createGain();

    coin1.type = 'sine';
    coin1.frequency.value = 1200;

    coin2.type = 'sine';
    coin2.frequency.value = 1500;

    wobble.type = 'sine';
    wobble.frequency.value = 5;
    wobbleGain.gain.value = 3;

    coinGain.gain.value = 0.2;
    coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    wobble.connect(wobbleGain);
    wobbleGain.connect(coin1.frequency);
    wobbleGain.connect(coin2.frequency);

    coin1.connect(coinGain);
    coin2.connect(coinGain);
    coinGain.connect(masterGain);

    coin1.start();
    coin2.start();
    wobble.start();
    coin1.stop(audioContext.currentTime + 0.3);
    coin2.stop(audioContext.currentTime + 0.3);
    wobble.stop(audioContext.currentTime + 0.3);
  }

  /**
   * Discover sound - magical sparkle arpeggio
   */
  function playDiscoverSound() {
    if (!audioContext || !masterGain) return;

    const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.08;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.15, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.2);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.2);
    });
  }

  /**
   * Challenge sound - dramatic horn
   */
  function playChallengeSound() {
    if (!audioContext || !masterGain) return;

    const horn1 = audioContext.createOscillator();
    const horn2 = audioContext.createOscillator();
    const hornGain = audioContext.createGain();

    horn1.type = 'sawtooth';
    horn1.frequency.value = 220;

    horn2.type = 'sawtooth';
    horn2.frequency.value = 330;

    hornGain.gain.setValueAtTime(0, audioContext.currentTime);
    hornGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
    hornGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.4);
    hornGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    horn1.connect(hornGain);
    horn2.connect(hornGain);
    hornGain.connect(masterGain);

    horn1.start();
    horn2.start();
    horn1.stop(audioContext.currentTime + 0.5);
    horn2.stop(audioContext.currentTime + 0.5);
  }

  /**
   * Level up sound - rising triumphant chord
   */
  function playLevelUpSound() {
    if (!audioContext || !masterGain) return;

    const notes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.1;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.15, startTime + 0.1);
      noteGain.gain.linearRampToValueAtTime(0.1, startTime + 0.5);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.8);
    });
  }

  /**
   * Error sound - low buzz
   */
  function playErrorSound() {
    if (!audioContext || !masterGain) return;

    const buzz = audioContext.createOscillator();
    const buzzGain = audioContext.createGain();

    buzz.type = 'square';
    buzz.frequency.value = 100;

    buzzGain.gain.value = 0.1;
    buzzGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    buzz.connect(buzzGain);
    buzzGain.connect(masterGain);

    buzz.start();
    buzz.stop(audioContext.currentTime + 0.2);
  }

  /**
   * Notification sound - gentle bell
   */
  function playNotificationSound() {
    if (!audioContext || !masterGain) return;

    const bell = audioContext.createOscillator();
    const bellGain = audioContext.createGain();

    bell.type = 'sine';
    bell.frequency.value = 800;

    bellGain.gain.value = 0.15;
    bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

    bell.connect(bellGain);
    bellGain.connect(masterGain);

    bell.start();
    bell.stop(audioContext.currentTime + 0.4);
  }

  /**
   * Trade request sound - soft notification bell (single warm tone)
   */
  function playTradeRequestSound() {
    if (!audioContext || !masterGain) return;

    const bell = audioContext.createOscillator();
    const bellGain = audioContext.createGain();

    bell.type = 'sine';
    bell.frequency.value = 700;

    bellGain.gain.value = 0.12;
    bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    bell.connect(bellGain);
    bellGain.connect(masterGain);

    bell.start();
    bell.stop(audioContext.currentTime + 0.5);
  }

  /**
   * Craft complete sound - satisfying metallic completion (anvil-like + sparkle)
   */
  function playCraftCompleteSound() {
    if (!audioContext || !masterGain) return;

    // Anvil strike - low metallic thump
    const anvil = audioContext.createOscillator();
    const anvilGain = audioContext.createGain();

    anvil.type = 'square';
    anvil.frequency.value = 120;

    anvilGain.gain.value = 0.3;
    anvilGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    anvil.connect(anvilGain);
    anvilGain.connect(masterGain);

    anvil.start();
    anvil.stop(audioContext.currentTime + 0.2);

    // Sparkle - high chime
    const sparkle1 = audioContext.createOscillator();
    const sparkle2 = audioContext.createOscillator();
    const sparkle3 = audioContext.createOscillator();
    const sparkleGain = audioContext.createGain();

    sparkle1.type = 'sine';
    sparkle1.frequency.value = 1800;
    sparkle2.type = 'sine';
    sparkle2.frequency.value = 2200;
    sparkle3.type = 'sine';
    sparkle3.frequency.value = 2600;

    const startTime = audioContext.currentTime + 0.1;
    sparkleGain.gain.setValueAtTime(0, startTime);
    sparkleGain.gain.linearRampToValueAtTime(0.15, startTime + 0.02);
    sparkleGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

    sparkle1.connect(sparkleGain);
    sparkle2.connect(sparkleGain);
    sparkle3.connect(sparkleGain);
    sparkleGain.connect(masterGain);

    sparkle1.start(startTime);
    sparkle2.start(startTime + 0.05);
    sparkle3.start(startTime + 0.1);
    sparkle1.stop(startTime + 0.4);
    sparkle2.stop(startTime + 0.45);
    sparkle3.stop(startTime + 0.5);
  }

  /**
   * Quest accept sound - adventurous ascending arpeggio (3 quick rising notes)
   */
  function playQuestAcceptSound() {
    if (!audioContext || !masterGain) return;

    const notes = [392.00, 493.88, 587.33]; // G4, B4, D5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.08;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.15, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.25);
    });
  }

  /**
   * Quest complete sound - triumphant fanfare (3 notes harmonized)
   */
  function playQuestCompleteSound() {
    if (!audioContext || !masterGain) return;

    // Triumphant chord - C major (C5, E5, G5)
    const chord1 = audioContext.createOscillator();
    const chord2 = audioContext.createOscillator();
    const chord3 = audioContext.createOscillator();
    const chordGain = audioContext.createGain();

    chord1.type = 'sine';
    chord1.frequency.value = 523.25; // C5
    chord2.type = 'sine';
    chord2.frequency.value = 659.25; // E5
    chord3.type = 'sine';
    chord3.frequency.value = 783.99; // G5

    chordGain.gain.setValueAtTime(0, audioContext.currentTime);
    chordGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
    chordGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.5);
    chordGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

    chord1.connect(chordGain);
    chord2.connect(chordGain);
    chord3.connect(chordGain);
    chordGain.connect(masterGain);

    chord1.start();
    chord2.start();
    chord3.start();
    chord1.stop(audioContext.currentTime + 0.8);
    chord2.stop(audioContext.currentTime + 0.8);
    chord3.stop(audioContext.currentTime + 0.8);
  }

  /**
   * Item pickup sound - quick soft pop (short white noise burst)
   */
  function playItemPickupSound() {
    if (!audioContext || !masterGain) return;

    try {
      // Create short white noise burst
      const bufferSize = audioContext.sampleRate * 0.05; // 50ms
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 1000;
      filter.Q.value = 1;

      const noiseGain = audioContext.createGain();
      noiseGain.gain.value = 0.15;
      noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.08);
    } catch (err) {
      console.error('Error in item pickup sound:', err);
    }
  }

  /**
   * NPC greet sound - warm gentle tone (single soft note)
   */
  function playNPCGreetSound() {
    if (!audioContext || !masterGain) return;

    const greet = audioContext.createOscillator();
    const greetGain = audioContext.createGain();

    greet.type = 'sine';
    greet.frequency.value = 440; // A4

    greetGain.gain.setValueAtTime(0, audioContext.currentTime);
    greetGain.gain.linearRampToValueAtTime(0.12, audioContext.currentTime + 0.05);
    greetGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.35);

    greet.connect(greetGain);
    greetGain.connect(masterGain);

    greet.start();
    greet.stop(audioContext.currentTime + 0.35);
  }

  /**
   * Portal enter sound - whooshing magical sound (filtered noise sweep)
   */
  function playPortalEnterSound() {
    if (!audioContext || !masterGain) return;

    try {
      // Create noise for whoosh
      const bufferSize = audioContext.sampleRate * 0.8;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      // Sweeping filter for magical effect
      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 200;
      filter.frequency.exponentialRampToValueAtTime(4000, audioContext.currentTime + 0.8);
      filter.Q.value = 5;

      const whooshGain = audioContext.createGain();
      whooshGain.gain.value = 0.2;
      whooshGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

      noise.connect(filter);
      filter.connect(whooshGain);
      whooshGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.8);

      // Add ethereal tone
      const tone = audioContext.createOscillator();
      const toneGain = audioContext.createGain();

      tone.type = 'sine';
      tone.frequency.value = 800;
      tone.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.8);

      toneGain.gain.value = 0.1;
      toneGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

      tone.connect(toneGain);
      toneGain.connect(masterGain);

      tone.start();
      tone.stop(audioContext.currentTime + 0.8);
    } catch (err) {
      console.error('Error in portal enter sound:', err);
    }
  }

  /**
   * Build place sound - solid thunk (low frequency impact)
   */
  function playBuildPlaceSound() {
    if (!audioContext || !masterGain) return;

    const thunk = audioContext.createOscillator();
    const thunkGain = audioContext.createGain();

    thunk.type = 'square';
    thunk.frequency.value = 60;

    thunkGain.gain.value = 0.3;
    thunkGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.12);

    thunk.connect(thunkGain);
    thunkGain.connect(masterGain);

    thunk.start();
    thunk.stop(audioContext.currentTime + 0.12);
  }

  /**
   * Footstep sound - very subtle soft step (tiny noise burst, vary pitch slightly)
   */
  function playFootstepSound() {
    if (!audioContext || !masterGain) return;

    try {
      // Create very short white noise burst
      const bufferSize = audioContext.sampleRate * 0.03; // 30ms
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 300 + Math.random() * 200; // Vary pitch slightly
      filter.Q.value = 0.5;

      const stepGain = audioContext.createGain();
      stepGain.gain.value = 0.05; // Very subtle
      stepGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

      noise.connect(filter);
      filter.connect(stepGain);
      stepGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.05);
    } catch (err) {
      console.error('Error in footstep sound:', err);
    }
  }

  /**
   * Play footstep sound
   * @param {string} terrain - Terrain type
   */
  function playFootstep(terrain) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (terrain) {
        case 'grass':
          playGrassFootstep();
          break;
        case 'stone':
          playStoneFootstep();
          break;
        case 'sand':
          playSandFootstep();
          break;
        case 'water':
          playWaterFootstep();
          break;
        case 'wood':
          playWoodFootstep();
          break;
        default:
          playDefaultFootstep();
      }
    } catch (err) {
      console.error('Error playing footstep:', err);
    }
  }

  /**
   * Grass footstep - soft crunch
   */
  function playGrassFootstep() {
    if (!audioContext || !masterGain) return;

    const grass = createWhiteNoise();
    if (grass) {
      const grassFilter = audioContext.createBiquadFilter();
      const grassGain = audioContext.createGain();

      grassFilter.type = 'lowpass';
      grassFilter.frequency.value = 500;

      grassGain.gain.value = 0.08;
      grassGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

      grass.connect(grassFilter);
      grassFilter.connect(grassGain);
      grassGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (grass.stop) grass.stop();
          if (grassFilter.disconnect) grassFilter.disconnect();
          if (grassGain.disconnect) grassGain.disconnect();
        } catch (e) {}
      }, 100);
    }
  }

  /**
   * Stone footstep - hard tap
   */
  function playStoneFootstep() {
    if (!audioContext || !masterGain) return;

    const thud = audioContext.createOscillator();
    const thudGain = audioContext.createGain();

    thud.type = 'sine';
    thud.frequency.value = 200;

    thudGain.gain.value = 0.1;
    thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

    thud.connect(thudGain);
    thudGain.connect(masterGain);

    thud.start();
    thud.stop(audioContext.currentTime + 0.05);

    const click = audioContext.createOscillator();
    const clickGain = audioContext.createGain();

    click.type = 'sine';
    click.frequency.value = 3000;

    clickGain.gain.value = 0.05;
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

    click.connect(clickGain);
    clickGain.connect(masterGain);

    click.start();
    click.stop(audioContext.currentTime + 0.02);
  }

  /**
   * Sand footstep - soft swish
   */
  function playSandFootstep() {
    if (!audioContext || !masterGain) return;

    const sand = createWhiteNoise();
    if (sand) {
      const sandFilter = audioContext.createBiquadFilter();
      const sandGain = audioContext.createGain();

      sandFilter.type = 'lowpass';
      sandFilter.frequency.value = 300;

      sandGain.gain.value = 0.07;
      sandGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

      sand.connect(sandFilter);
      sandFilter.connect(sandGain);
      sandGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (sand.stop) sand.stop();
          if (sandFilter.disconnect) sandFilter.disconnect();
          if (sandGain.disconnect) sandGain.disconnect();
        } catch (e) {}
      }, 120);
    }
  }

  /**
   * Water footstep - splash with bubbles
   */
  function playWaterFootstep() {
    if (!audioContext || !masterGain) return;

    const splash = createWhiteNoise();
    if (splash) {
      const splashFilter = audioContext.createBiquadFilter();
      const splashGain = audioContext.createGain();

      splashFilter.type = 'bandpass';
      splashFilter.frequency.value = 800;
      splashFilter.Q.value = 2;

      splashGain.gain.value = 0.1;
      splashGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.12);

      splash.connect(splashFilter);
      splashFilter.connect(splashGain);
      splashGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (splash.stop) splash.stop();
          if (splashFilter.disconnect) splashFilter.disconnect();
          if (splashGain.disconnect) splashGain.disconnect();
        } catch (e) {}
      }, 150);
    }

    // Bubbles
    for (let i = 0; i < 2; i++) {
      setTimeout(() => {
        const bubble = audioContext.createOscillator();
        const bubbleGain = audioContext.createGain();

        bubble.type = 'sine';
        bubble.frequency.value = 1500 + Math.random() * 1500;

        bubbleGain.gain.value = 0.03;
        bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

        bubble.connect(bubbleGain);
        bubbleGain.connect(masterGain);

        bubble.start();
        bubble.stop(audioContext.currentTime + 0.05);
      }, i * 50);
    }
  }

  /**
   * Wood footstep - hollow knock
   */
  function playWoodFootstep() {
    if (!audioContext || !masterGain) return;

    const knock = audioContext.createOscillator();
    const knockGain = audioContext.createGain();

    knock.type = 'sine';
    knock.frequency.value = 150;

    knockGain.gain.value = 0.12;
    knockGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.06);

    knock.connect(knockGain);
    knockGain.connect(masterGain);

    knock.start();
    knock.stop(audioContext.currentTime + 0.06);
  }

  /**
   * Default footstep - generic soft thud
   */
  function playDefaultFootstep() {
    if (!audioContext || !masterGain) return;

    const thud = audioContext.createOscillator();
    const thudGain = audioContext.createGain();

    thud.type = 'sine';
    thud.frequency.value = 100;

    thudGain.gain.value = 0.08;
    thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.07);

    thud.connect(thudGain);
    thudGain.connect(masterGain);

    thud.start();
    thud.stop(audioContext.currentTime + 0.07);
  }

  /**
   * Set volume for a channel
   * @param {string} channel - 'master', 'music', or 'sfx'
   * @param {number} level - 0-1
   */
  function setVolume(channel, level) {
    if (typeof channel === 'number') {
      level = channel;
      channel = 'master';
    }
    var clampedLevel = Math.max(0, Math.min(1, level));
    volumeLevels[channel] = clampedLevel;
    if (channel === 'master' && masterGain) {
      masterGain.gain.value = clampedLevel;
    }
    if (channel === 'music') {
      setMusicVolume(clampedLevel);
    }
  }

  /**
   * Mute audio
   */
  function mute() {
    if (!masterGain) return;

    isMuted = true;
    masterGain.gain.value = 0;
  }

  /**
   * Unmute audio
   */
  function unmute() {
    if (!masterGain) return;

    isMuted = false;
    masterGain.gain.value = 0.5;
  }

  /**
   * Stop all sounds
   */
  function stopAll() {
    stopAmbient();
    stopTimeAmbient();
    stopWeatherAmbient();
    stopZoneAmbient();
    // Individual sound effects stop themselves automatically
  }

  // ============================================================================
  // TIME-OF-DAY AMBIENT LAYERS
  // ============================================================================

  let currentTimeAmbient = null;

  /**
   * Update ambient sounds based on time of day
   * @param {string} timePeriod - dawn, morning, midday, afternoon, evening, night
   */
  function updateAmbientForTime(timePeriod) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Stop current time ambient
    stopTimeAmbient();

    try {
      switch (timePeriod) {
        case 'dawn':
          currentTimeAmbient = playDawnAmbient();
          break;
        case 'morning':
          currentTimeAmbient = playMorningAmbient();
          break;
        case 'midday':
          currentTimeAmbient = playMiddayAmbient();
          break;
        case 'afternoon':
          currentTimeAmbient = playAfternoonAmbient();
          break;
        case 'evening':
          currentTimeAmbient = playEveningAmbient();
          break;
        case 'night':
          currentTimeAmbient = playNightAmbient();
          break;
        default:
          currentTimeAmbient = null;
      }
    } catch (err) {
      console.error('Error updating time ambient:', err);
    }
  }

  /**
   * Stop current time-of-day ambient
   */
  function stopTimeAmbient() {
    if (!currentTimeAmbient) return;

    try {
      if (currentTimeAmbient.oscillators && Array.isArray(currentTimeAmbient.oscillators)) {
        currentTimeAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentTimeAmbient.nodes && Array.isArray(currentTimeAmbient.nodes)) {
        currentTimeAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentTimeAmbient.intervals && Array.isArray(currentTimeAmbient.intervals)) {
        currentTimeAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentTimeAmbient.timeouts && Array.isArray(currentTimeAmbient.timeouts)) {
        currentTimeAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentTimeAmbient.cleanup && typeof currentTimeAmbient.cleanup === 'function') {
        currentTimeAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping time ambient:', err);
    }

    currentTimeAmbient = null;
  }

  /**
   * Dawn ambient (5-7): Bird chirps, gentle wind
   */
  function playDawnAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Gentle wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 180;
        windGain.gain.value = 0.02;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      // Morning bird chirps - high frequency with fast attack/decay
      function dawnChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 800 + Math.random() * 1000;

        const duration = 0.05 + Math.random() * 0.1;
        birdGain.gain.value = 0.04;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(dawnChirp, 800 + Math.random() * 2000);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 2; i++) {
        const firstChirp = setTimeout(dawnChirp, Math.random() * 1000);
        timeouts.push(firstChirp);
      }

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in dawn ambient:', err);
      return null;
    }
  }

  /**
   * Morning ambient (7-12): Active birds, gentle breeze, insect buzzes
   */
  function playMorningAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Gentle breeze
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 200;
        breezeGain.gain.value = 0.025;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Active bird chorus
      function morningChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 700 + Math.random() * 1200;

        const duration = 0.08 + Math.random() * 0.15;
        birdGain.gain.value = 0.05;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(morningChirp, 400 + Math.random() * 2500);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 3; i++) {
        const firstChirp = setTimeout(morningChirp, Math.random() * 1500);
        timeouts.push(firstChirp);
      }

      // Occasional insect buzzes
      function buzz() {
        if (!audioContext || !masterGain) return;

        const insect = audioContext.createOscillator();
        const insectGain = audioContext.createGain();

        insect.type = 'sawtooth';
        insect.frequency.value = 250 + Math.random() * 100;

        insectGain.gain.value = 0.02;
        insectGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        insect.connect(insectGain);
        insectGain.connect(masterGain);

        insect.start();
        insect.stop(audioContext.currentTime + 0.3);

        const nextBuzz = setTimeout(buzz, 8000 + Math.random() * 12000);
        timeouts.push(nextBuzz);
      }

      const firstBuzz = setTimeout(buzz, 5000);
      timeouts.push(firstBuzz);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in morning ambient:', err);
      return null;
    }
  }

  /**
   * Midday ambient (12-14): Cicada-like sustained tones, warm breeze
   */
  function playMiddayAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Warm breeze
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 220;
        breezeGain.gain.value = 0.03;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Cicada-like sustained tone with AM
      const cicada = audioContext.createOscillator();
      const cicadaAm = audioContext.createOscillator();
      const cicadaAmGain = audioContext.createGain();
      const cicadaGain = audioContext.createGain();

      cicada.type = 'sine';
      cicada.frequency.value = 3500 + Math.random() * 500;

      cicadaAm.type = 'sine';
      cicadaAm.frequency.value = 15 + Math.random() * 10;
      cicadaAmGain.gain.value = 0.02;

      cicadaGain.gain.value = 0.04;

      cicadaAm.connect(cicadaAmGain);
      cicadaAmGain.connect(cicadaGain.gain);

      cicada.connect(cicadaGain);
      cicadaGain.connect(masterGain);

      cicada.start();
      cicadaAm.start();

      oscillators.push(cicada, cicadaAm);
      nodes.push(cicadaAmGain, cicadaGain);

      // Occasional bird (quieter in heat)
      function middayChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 600 + Math.random() * 800;

        const duration = 0.1 + Math.random() * 0.15;
        birdGain.gain.value = 0.03;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(middayChirp, 3000 + Math.random() * 5000);
        timeouts.push(nextChirp);
      }

      const firstChirp = setTimeout(middayChirp, 2000);
      timeouts.push(firstChirp);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in midday ambient:', err);
      return null;
    }
  }

  /**
   * Afternoon ambient (14-18): Softer birds, rustling leaves
   */
  function playAfternoonAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Gentle breeze
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 190;
        breezeGain.gain.value = 0.025;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Softer bird calls
      function afternoonChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 500 + Math.random() * 900;

        const duration = 0.1 + Math.random() * 0.2;
        birdGain.gain.value = 0.04;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(afternoonChirp, 1500 + Math.random() * 4000);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 2; i++) {
        const firstChirp = setTimeout(afternoonChirp, Math.random() * 2000);
        timeouts.push(firstChirp);
      }

      // Rustling leaves
      function rustle() {
        if (!audioContext || !masterGain) return;

        const noise = createWhiteNoise();
        if (noise) {
          const rustleFilter = audioContext.createBiquadFilter();
          const rustleGain = audioContext.createGain();

          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 1800 + Math.random() * 400;
          rustleFilter.Q.value = 2;

          rustleGain.gain.value = 0.03;
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

          noise.connect(rustleFilter);
          rustleFilter.connect(rustleGain);
          rustleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (noise.stop) noise.stop();
              if (rustleFilter.disconnect) rustleFilter.disconnect();
              if (rustleGain.disconnect) rustleGain.disconnect();
            } catch (e) {}
          }, 450);
        }

        const nextRustle = setTimeout(rustle, 2500 + Math.random() * 3500);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 1500);
      timeouts.push(firstRustle);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in afternoon ambient:', err);
      return null;
    }
  }

  /**
   * Evening ambient (18-21): Cricket chirps, owl hoots, gentle wind
   */
  function playEveningAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Gentle wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 170;
        windGain.gain.value = 0.02;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      // Cricket chirps - rapid oscillator pulses
      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 4000 + Math.random() * 500;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 18 + Math.random() * 8;
      cricketAmGain.gain.value = 0.025;

      cricketGain.gain.value = 0.03;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      oscillators.push(cricket, cricketAm);
      nodes.push(cricketAmGain, cricketGain);

      // Owl hoots - low frequency with vibrato
      function hoot() {
        if (!audioContext || !masterGain) return;

        const owl = audioContext.createOscillator();
        const owlVibrato = audioContext.createOscillator();
        const owlVibratoGain = audioContext.createGain();
        const owlGain = audioContext.createGain();

        owl.type = 'sine';
        owl.frequency.value = 320;

        owlVibrato.type = 'sine';
        owlVibrato.frequency.value = 4;
        owlVibratoGain.gain.value = 8;

        owlGain.gain.value = 0.05;
        owlGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

        owlVibrato.connect(owlVibratoGain);
        owlVibratoGain.connect(owl.frequency);

        owl.connect(owlGain);
        owlGain.connect(masterGain);

        owl.start();
        owlVibrato.start();

        owl.stop(audioContext.currentTime + 0.4);
        owlVibrato.stop(audioContext.currentTime + 0.4);

        const nextHoot = setTimeout(hoot, 12000 + Math.random() * 12000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(hoot, 5000);
      timeouts.push(firstHoot);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in evening ambient:', err);
      return null;
    }
  }

  /**
   * Night ambient (21-5): Deep crickets, occasional owl, quiet wind, distant howl
   */
  function playNightAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Very quiet wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 150;
        windGain.gain.value = 0.015;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      // Deep crickets
      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 3500 + Math.random() * 300;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 15 + Math.random() * 5;
      cricketAmGain.gain.value = 0.02;

      cricketGain.gain.value = 0.025;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      oscillators.push(cricket, cricketAm);
      nodes.push(cricketAmGain, cricketGain);

      // Occasional owl
      function nightHoot() {
        if (!audioContext || !masterGain) return;

        const owl = audioContext.createOscillator();
        const owlVibrato = audioContext.createOscillator();
        const owlVibratoGain = audioContext.createGain();
        const owlGain = audioContext.createGain();

        owl.type = 'sine';
        owl.frequency.value = 280;

        owlVibrato.type = 'sine';
        owlVibrato.frequency.value = 4;
        owlVibratoGain.gain.value = 6;

        owlGain.gain.value = 0.04;
        owlGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

        owlVibrato.connect(owlVibratoGain);
        owlVibratoGain.connect(owl.frequency);

        owl.connect(owlGain);
        owlGain.connect(masterGain);

        owl.start();
        owlVibrato.start();

        owl.stop(audioContext.currentTime + 0.5);
        owlVibrato.stop(audioContext.currentTime + 0.5);

        const nextHoot = setTimeout(nightHoot, 18000 + Math.random() * 18000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(nightHoot, 8000);
      timeouts.push(firstHoot);

      // Distant wolf-like howl (very rare)
      function distantHowl() {
        if (!audioContext || !masterGain) return;

        const wolf = audioContext.createOscillator();
        const wolfVibrato = audioContext.createOscillator();
        const wolfVibratoGain = audioContext.createGain();
        const wolfGain = audioContext.createGain();

        wolf.type = 'sine';
        wolf.frequency.value = 350;

        wolfVibrato.type = 'sine';
        wolfVibrato.frequency.value = 4;
        wolfVibratoGain.gain.value = 10;

        wolfGain.gain.value = 0.03;

        wolfVibrato.connect(wolfVibratoGain);
        wolfVibratoGain.connect(wolf.frequency);

        wolf.connect(wolfGain);
        wolfGain.connect(masterGain);

        wolf.start();
        wolfVibrato.start();

        wolf.frequency.linearRampToValueAtTime(500, audioContext.currentTime + 1.2);
        wolf.frequency.linearRampToValueAtTime(350, audioContext.currentTime + 2);
        wolfGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        wolf.stop(audioContext.currentTime + 2.5);
        wolfVibrato.stop(audioContext.currentTime + 2.5);

        const nextHowl = setTimeout(distantHowl, 60000 + Math.random() * 60000);
        timeouts.push(nextHowl);
      }

      const firstHowl = setTimeout(distantHowl, 30000);
      timeouts.push(firstHowl);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in night ambient:', err);
      return null;
    }
  }

  // ============================================================================
  // WEATHER AMBIENT LAYERS
  // ============================================================================

  let currentWeatherAmbient = null;

  /**
   * Update ambient sounds based on weather
   * @param {string} weather - clear, cloudy, rain, snow
   */
  function updateAmbientForWeather(weather) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Stop current weather ambient
    stopWeatherAmbient();

    try {
      switch (weather) {
        case 'clear':
          // Normal ambient, no additional layer
          currentWeatherAmbient = null;
          break;
        case 'cloudy':
          currentWeatherAmbient = playCloudyAmbient();
          break;
        case 'rain':
          currentWeatherAmbient = playRainAmbient();
          break;
        case 'snow':
          currentWeatherAmbient = playSnowAmbient();
          break;
        default:
          currentWeatherAmbient = null;
      }
    } catch (err) {
      console.error('Error updating weather ambient:', err);
    }
  }

  /**
   * Stop current weather ambient
   */
  function stopWeatherAmbient() {
    if (!currentWeatherAmbient) return;

    try {
      if (currentWeatherAmbient.oscillators && Array.isArray(currentWeatherAmbient.oscillators)) {
        currentWeatherAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentWeatherAmbient.nodes && Array.isArray(currentWeatherAmbient.nodes)) {
        currentWeatherAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentWeatherAmbient.intervals && Array.isArray(currentWeatherAmbient.intervals)) {
        currentWeatherAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentWeatherAmbient.timeouts && Array.isArray(currentWeatherAmbient.timeouts)) {
        currentWeatherAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentWeatherAmbient.cleanup && typeof currentWeatherAmbient.cleanup === 'function') {
        currentWeatherAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping weather ambient:', err);
    }

    currentWeatherAmbient = null;
  }

  /**
   * Cloudy ambient - gentle wind increase
   */
  function playCloudyAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 200;
        windGain.gain.value = 0.03;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      return { nodes };
    } catch (err) {
      console.error('Error in cloudy ambient:', err);
      return null;
    }
  }

  /**
   * Rain ambient - rain sound, occasional thunder
   */
  function playRainAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Rain sound - white noise filtered through bandpass at ~4000Hz
      const rain = createWhiteNoise();
      if (rain) {
        const rainFilter = audioContext.createBiquadFilter();
        const rainGain = audioContext.createGain();

        rainFilter.type = 'bandpass';
        rainFilter.frequency.value = 4000;
        rainFilter.Q.value = 0.5;

        rainGain.gain.value = 0.05;

        rain.connect(rainFilter);
        rainFilter.connect(rainGain);
        rainGain.connect(masterGain);

        nodes.push(rain, rainFilter, rainGain);
      }

      // Occasional thunder
      function thunder() {
        if (!audioContext || !masterGain) return;

        const rumble = createWhiteNoise();
        if (rumble) {
          const rumbleFilter = audioContext.createBiquadFilter();
          const rumbleGain = audioContext.createGain();

          rumbleFilter.type = 'lowpass';
          rumbleFilter.frequency.value = 80;

          rumbleGain.gain.value = 0.08;
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

          rumble.connect(rumbleFilter);
          rumbleFilter.connect(rumbleGain);
          rumbleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (rumble.stop) rumble.stop();
              if (rumbleFilter.disconnect) rumbleFilter.disconnect();
              if (rumbleGain.disconnect) rumbleGain.disconnect();
            } catch (e) {}
          }, 3000);
        }

        const nextThunder = setTimeout(thunder, 25000 + Math.random() * 35000);
        timeouts.push(nextThunder);
      }

      const firstThunder = setTimeout(thunder, 15000);
      timeouts.push(firstThunder);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in rain ambient:', err);
      return null;
    }
  }

  /**
   * Snow ambient - very quiet, muffled ambient, soft wind
   */
  function playSnowAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      // Soft wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 120;
        windGain.gain.value = 0.015;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      return { nodes };
    } catch (err) {
      console.error('Error in snow ambient:', err);
      return null;
    }
  }

  // ============================================================================
  // ZONE-SPECIFIC ENHANCEMENTS
  // ============================================================================

  let currentZoneAmbient = null;

  /**
   * Set zone-specific ambient layer (on top of base ambient)
   * @param {string} zone - Zone identifier
   */
  var crossfadeTimer = null;

  function setZoneAmbient(zone) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Clear any pending crossfade
    if (crossfadeTimer) {
      clearTimeout(crossfadeTimer);
      crossfadeTimer = null;
    }

    // Crossfade: fade out old ambient over 3 seconds, then start new
    var oldAmbient = currentZoneAmbient;
    if (oldAmbient) {
      // Fade out old ambient gracefully over 3 seconds
      try {
        if (oldAmbient.gainNode) {
          oldAmbient.gainNode.gain.setValueAtTime(oldAmbient.gainNode.gain.value, audioContext.currentTime);
          oldAmbient.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 3);
        }
      } catch(e) {}

      // Schedule cleanup after fade
      crossfadeTimer = setTimeout(function() {
        try {
          if (oldAmbient.oscillators && Array.isArray(oldAmbient.oscillators)) {
            oldAmbient.oscillators.forEach(function(osc) {
              if (osc && osc.stop) { try { osc.stop(); } catch(e) {} }
            });
          }
          if (oldAmbient.nodes && Array.isArray(oldAmbient.nodes)) {
            oldAmbient.nodes.forEach(function(node) {
              if (node) {
                if (node.stop) { try { node.stop(); } catch(e) {} }
                if (node.disconnect) { try { node.disconnect(); } catch(e) {} }
              }
            });
          }
          if (oldAmbient.intervals && Array.isArray(oldAmbient.intervals)) {
            oldAmbient.intervals.forEach(function(id) { clearInterval(id); });
          }
          if (oldAmbient.timeouts && Array.isArray(oldAmbient.timeouts)) {
            oldAmbient.timeouts.forEach(function(id) { clearTimeout(id); });
          }
          if (oldAmbient.cleanup && typeof oldAmbient.cleanup === 'function') {
            oldAmbient.cleanup();
          }
        } catch(err) {}
      }, 3100);

      currentZoneAmbient = null;
    }

    // Start new zone ambient immediately (will overlap with fading old one)
    try {
      switch (zone) {
        case 'nexus':
          currentZoneAmbient = playNexusZoneLayer();
          break;
        case 'gardens':
          currentZoneAmbient = playGardensZoneLayer();
          break;
        case 'athenaeum':
          currentZoneAmbient = playAthenaeumZoneLayer();
          break;
        case 'studio':
          currentZoneAmbient = playStudioZoneLayer();
          break;
        case 'wilds':
          currentZoneAmbient = playWildsZoneLayer();
          break;
        case 'agora':
          currentZoneAmbient = playAgoraZoneLayer();
          break;
        case 'commons':
          currentZoneAmbient = playCommonsZoneLayer();
          break;
        case 'arena':
          currentZoneAmbient = playArenaZoneLayer();
          break;
        default:
          currentZoneAmbient = null;
      }

      // Fade in new ambient over 3 seconds
      if (currentZoneAmbient && currentZoneAmbient.gainNode) {
        var gain = currentZoneAmbient.gainNode;
        var targetVal = gain.gain.value || 0.3;
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(targetVal, audioContext.currentTime + 3);
      }
    } catch (err) {
      console.error('Error setting zone ambient:', err);
    }
  }

  /**
   * Stop current zone ambient layer
   */
  function stopZoneAmbient() {
    if (!currentZoneAmbient) return;

    try {
      if (currentZoneAmbient.oscillators && Array.isArray(currentZoneAmbient.oscillators)) {
        currentZoneAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentZoneAmbient.nodes && Array.isArray(currentZoneAmbient.nodes)) {
        currentZoneAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentZoneAmbient.intervals && Array.isArray(currentZoneAmbient.intervals)) {
        currentZoneAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentZoneAmbient.timeouts && Array.isArray(currentZoneAmbient.timeouts)) {
        currentZoneAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentZoneAmbient.cleanup && typeof currentZoneAmbient.cleanup === 'function') {
        currentZoneAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping zone ambient:', err);
    }

    currentZoneAmbient = null;
  }

  /**
   * Nexus zone layer - subtle crystalline resonance (high sine waves with slow LFO)
   */
  function playNexusZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const oscillators = [];
    const nodes = [];

    try {
      // Soft crystalline shimmer â€” two detuned sines at gentle frequencies
      const crystal1 = audioContext.createOscillator();
      const crystal2 = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      const layerGain = audioContext.createGain();

      crystal1.type = 'sine';
      crystal1.frequency.value = 523; // C5 â€” much gentler than 2000Hz

      crystal2.type = 'sine';
      crystal2.frequency.value = 659; // E5 â€” harmonic interval

      lfo.type = 'sine';
      lfo.frequency.value = 0.12;
      lfoGain.gain.value = 8; // subtle vibrato

      layerGain.gain.value = 0.012; // very quiet

      lfo.connect(lfoGain);
      lfoGain.connect(crystal1.frequency);
      lfoGain.connect(crystal2.frequency);

      crystal1.connect(layerGain);
      crystal2.connect(layerGain);
      layerGain.connect(masterGain);

      crystal1.start();
      crystal2.start();
      lfo.start();

      oscillators.push(crystal1, crystal2, lfo);
      nodes.push(lfoGain, layerGain);

      return { oscillators, nodes, gainNode: layerGain };
    } catch (err) {
      console.error('Error in nexus zone layer:', err);
      return null;
    }
  }

  /**
   * Gardens zone layer - water trickling, more birds
   */
  function playGardensZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Water trickling - filtered noise with LFO
      const water = createWhiteNoise();
      if (water) {
        const waterFilter = audioContext.createBiquadFilter();
        const waterLfo = audioContext.createOscillator();
        const waterLfoGain = audioContext.createGain();
        const waterGain = audioContext.createGain();

        waterFilter.type = 'highpass';
        waterFilter.frequency.value = 2000;

        waterLfo.type = 'sine';
        waterLfo.frequency.value = 0.8;
        waterLfoGain.gain.value = 50;

        waterGain.gain.value = 0.03;

        waterLfo.connect(waterLfoGain);
        waterLfoGain.connect(waterFilter.frequency);

        water.connect(waterFilter);
        waterFilter.connect(waterGain);
        waterGain.connect(masterGain);

        waterLfo.start();

        nodes.push(water, waterFilter, waterLfo, waterLfoGain, waterGain);
      }

      return { nodes, timeouts, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in gardens zone layer:', err);
      return null;
    }
  }

  /**
   * Athenaeum zone layer - echo/reverb quality, page rustling
   */
  function playAthenaeumZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Page rustling - short noise bursts
      function pageRustle() {
        if (!audioContext || !masterGain) return;

        const page = createWhiteNoise();
        if (page) {
          const pageFilter = audioContext.createBiquadFilter();
          const pageGain = audioContext.createGain();

          pageFilter.type = 'highpass';
          pageFilter.frequency.value = 2500;

          pageGain.gain.value = 0.02;
          pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

          page.connect(pageFilter);
          pageFilter.connect(pageGain);
          pageGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (page.stop) page.stop();
              if (pageFilter.disconnect) pageFilter.disconnect();
              if (pageGain.disconnect) pageGain.disconnect();
            } catch (e) {}
          }, 100);
        }

        const nextRustle = setTimeout(pageRustle, 10000 + Math.random() * 10000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(pageRustle, 5000);
      timeouts.push(firstRustle);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in athenaeum zone layer:', err);
      return null;
    }
  }

  /**
   * Studio zone layer - creative sounds (random melodic tones, tapping)
   */
  function playStudioZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Random melodic tones
      function creativeNote() {
        if (!audioContext || !masterGain) return;

        const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00];
        const note = audioContext.createOscillator();
        const noteGain = audioContext.createGain();

        note.type = 'sine';
        note.frequency.value = notes[Math.floor(Math.random() * notes.length)];

        noteGain.gain.value = 0.025;
        noteGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        note.connect(noteGain);
        noteGain.connect(masterGain);

        note.start();
        note.stop(audioContext.currentTime + 0.3);

        const nextNote = setTimeout(creativeNote, 8000 + Math.random() * 12000);
        timeouts.push(nextNote);
      }

      const firstNote = setTimeout(creativeNote, 4000);
      timeouts.push(firstNote);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in studio zone layer:', err);
      return null;
    }
  }

  /**
   * Wilds zone layer - dense nature sounds, rushing water
   */
  function playWildsZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      // Rushing water - white noise with bandpass
      const water = createWhiteNoise();
      if (water) {
        const waterFilter = audioContext.createBiquadFilter();
        const waterGain = audioContext.createGain();

        waterFilter.type = 'bandpass';
        waterFilter.frequency.value = 800;
        waterFilter.Q.value = 1;

        waterGain.gain.value = 0.04;

        water.connect(waterFilter);
        waterFilter.connect(waterGain);
        waterGain.connect(masterGain);

        nodes.push(water, waterFilter, waterGain);
      }

      return { nodes, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in wilds zone layer:', err);
      return null;
    }
  }

  /**
   * Agora zone layer - crowd murmur, occasional calls
   */
  function playAgoraZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Enhanced crowd murmur
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 450;
        crowdFilter.Q.value = 1.2;

        crowdGain.gain.value = 0.025;

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        nodes.push(crowd, crowdFilter, crowdGain);
      }

      return { nodes, timeouts, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in agora zone layer:', err);
      return null;
    }
  }

  /**
   * Commons zone layer - homey sounds (crackling fire, wind chimes)
   */
  function playCommonsZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Wind chimes - random high notes
      function chime() {
        if (!audioContext || !masterGain) return;

        const bell = audioContext.createOscillator();
        const bellGain = audioContext.createGain();

        bell.type = 'sine';
        bell.frequency.value = 800 + Math.random() * 600;

        bellGain.gain.value = 0.03;
        bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

        bell.connect(bellGain);
        bellGain.connect(masterGain);

        bell.start();
        bell.stop(audioContext.currentTime + 1.5);

        const nextChime = setTimeout(chime, 5000 + Math.random() * 8000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(chime, 3000);
      timeouts.push(firstChime);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in commons zone layer:', err);
      return null;
    }
  }

  /**
   * Arena zone layer - echoing space (slight delay)
   */
  function playArenaZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      // Subtle echo ambiance
      const echo = createWhiteNoise();
      if (echo) {
        const echoFilter = audioContext.createBiquadFilter();
        const echoDelay = audioContext.createDelay();
        const echoDelayGain = audioContext.createGain();
        const echoGain = audioContext.createGain();

        echoFilter.type = 'bandpass';
        echoFilter.frequency.value = 700;
        echoFilter.Q.value = 0.8;

        echoDelay.delayTime.value = 0.3;
        echoDelayGain.gain.value = 0.3;

        echoGain.gain.value = 0.02;

        echo.connect(echoFilter);
        echoFilter.connect(echoGain);
        echoGain.connect(masterGain);
        echoGain.connect(echoDelay);
        echoDelay.connect(echoDelayGain);
        echoDelayGain.connect(masterGain);

        nodes.push(echo, echoFilter, echoDelay, echoDelayGain, echoGain);
      }

      return { nodes, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in arena zone layer:', err);
      return null;
    }
  }

  // ============================================================================
  // NPC SOUNDS
  // ============================================================================

  /**
   * Play NPC activity sound
   * @param {string} type - hammer, music, garden, trade, teach, heal
   */
  function playNPCSound(type) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (type) {
        case 'hammer':
          playNPCHammerSound();
          break;
        case 'music':
          playNPCMusicSound();
          break;
        case 'garden':
          playNPCGardenSound();
          break;
        case 'trade':
          playNPCTradeSound();
          break;
        case 'teach':
          playNPCTeachSound();
          break;
        case 'heal':
          playNPCHealSound();
          break;
        default:
          console.warn('Unknown NPC sound type:', type);
      }
    } catch (err) {
      console.error('Error playing NPC sound:', err);
    }
  }

  /**
   * NPC hammer sound - metallic clang
   */
  function playNPCHammerSound() {
    if (!audioContext || !masterGain) return;

    const hammer = audioContext.createOscillator();
    const hammerGain = audioContext.createGain();

    hammer.type = 'square';
    hammer.frequency.value = 90;

    hammerGain.gain.value = 0.08;
    hammerGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    hammer.connect(hammerGain);
    hammerGain.connect(masterGain);

    hammer.start();
    hammer.stop(audioContext.currentTime + 0.2);

    // Metal ring
    const ring = audioContext.createOscillator();
    const ringGain = audioContext.createGain();

    ring.type = 'sine';
    ring.frequency.value = 2500;

    ringGain.gain.value = 0.04;
    ringGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    ring.connect(ringGain);
    ringGain.connect(masterGain);

    ring.start();
    ring.stop(audioContext.currentTime + 0.3);
  }

  /**
   * NPC music sound - short melodic phrase
   */
  function playNPCMusicSound() {
    if (!audioContext || !masterGain) return;

    const notes = [392.00, 440.00, 493.88]; // G4, A4, B4

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.15;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.25);
    });
  }

  /**
   * NPC garden sound - rustling, digging
   */
  function playNPCGardenSound() {
    if (!audioContext || !masterGain) return;

    const rustle = createWhiteNoise();
    if (rustle) {
      const rustleFilter = audioContext.createBiquadFilter();
      const rustleGain = audioContext.createGain();

      rustleFilter.type = 'bandpass';
      rustleFilter.frequency.value = 1200;
      rustleFilter.Q.value = 2;

      rustleGain.gain.value = 0.06;
      rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

      rustle.connect(rustleFilter);
      rustleFilter.connect(rustleGain);
      rustleGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (rustle.stop) rustle.stop();
          if (rustleFilter.disconnect) rustleFilter.disconnect();
          if (rustleGain.disconnect) rustleGain.disconnect();
        } catch (e) {}
      }, 350);
    }
  }

  /**
   * NPC trade sound - coin clink
   */
  function playNPCTradeSound() {
    if (!audioContext || !masterGain) return;

    const coin = audioContext.createOscillator();
    const coinGain = audioContext.createGain();

    coin.type = 'triangle';
    coin.frequency.value = 1800 + Math.random() * 500;

    coinGain.gain.value = 0.06;
    coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    coin.connect(coinGain);
    coinGain.connect(masterGain);

    coin.start();
    coin.stop(audioContext.currentTime + 0.2);
  }

  /**
   * NPC teach sound - book thump and page turn
   */
  function playNPCTeachSound() {
    if (!audioContext || !masterGain) return;

    // Book thump
    const thump = audioContext.createOscillator();
    const thumpGain = audioContext.createGain();

    thump.type = 'sine';
    thump.frequency.value = 80;

    thumpGain.gain.value = 0.05;
    thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

    thump.connect(thumpGain);
    thumpGain.connect(masterGain);

    thump.start();
    thump.stop(audioContext.currentTime + 0.1);

    // Page turn
    setTimeout(() => {
      const page = createWhiteNoise();
      if (page) {
        const pageFilter = audioContext.createBiquadFilter();
        const pageGain = audioContext.createGain();

        pageFilter.type = 'highpass';
        pageFilter.frequency.value = 2200;

        pageGain.gain.value = 0.04;
        pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        page.connect(pageFilter);
        pageFilter.connect(pageGain);
        pageGain.connect(masterGain);

        setTimeout(() => {
          try {
            if (page.stop) page.stop();
            if (pageFilter.disconnect) pageFilter.disconnect();
            if (pageGain.disconnect) pageGain.disconnect();
          } catch (e) {}
        }, 180);
      }
    }, 100);
  }

  /**
   * NPC heal sound - gentle sparkle
   */
  function playNPCHealSound() {
    if (!audioContext || !masterGain) return;

    const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.1;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.3);
    });
  }

  // ========================================================================
  // PROCEDURAL MUSIC SYSTEM â€” Generative ambient music per zone/time
  // ========================================================================

  var musicState = {
    playing: false,
    zone: null,
    timeOfDay: 'day',
    volume: 0.12,
    oscillators: [],
    gains: [],
    nextNoteTime: 0,
    noteIndex: 0,
    chordIndex: 0,
    arpIndex: 0,
    beatTimer: null,
    padNodes: [],
    melodyTimeout: null
  };

  // Musical scales (frequencies in Hz)
  var SCALES = {
    // Pentatonic scales â€” always pleasant, no dissonance
    nexus:     [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25],  // C major pentatonic
    gardens:   [293.66, 329.63, 369.99, 440.00, 493.88, 587.33, 659.25, 739.99],  // D major pentatonic
    athenaeum: [246.94, 277.18, 329.63, 369.99, 415.30, 493.88, 554.37, 659.25],  // B minor pentatonic
    studio:    [329.63, 369.99, 415.30, 493.88, 554.37, 659.25, 739.99, 830.61],  // E major pentatonic
    wilds:     [220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33],  // A minor pentatonic
    agora:     [349.23, 392.00, 440.00, 523.25, 587.33, 698.46, 783.99, 880.00],  // F major pentatonic
    commons:   [293.66, 349.23, 392.00, 440.00, 523.25, 587.33, 698.46, 783.99],  // D mixolydian penta
    arena:     [196.00, 233.08, 261.63, 293.66, 349.23, 392.00, 466.16, 523.25]   // G minor pentatonic
  };

  // Chord progressions per zone (indices into the scale)
  var CHORD_PROGRESSIONS = {
    nexus:     [[0, 2, 4], [1, 3, 5], [2, 4, 6], [0, 3, 5]],
    gardens:   [[0, 2, 4], [2, 4, 6], [1, 3, 5], [0, 2, 5]],
    athenaeum: [[0, 2, 4], [1, 3, 5], [0, 3, 5], [2, 4, 6]],
    studio:    [[0, 2, 4], [1, 4, 6], [2, 4, 6], [0, 3, 5]],
    wilds:     [[0, 2, 4], [1, 3, 5], [0, 2, 5], [1, 4, 6]],
    agora:     [[0, 2, 4], [1, 3, 5], [2, 4, 6], [0, 2, 5]],
    commons:   [[0, 2, 4], [2, 4, 6], [1, 3, 5], [0, 3, 5]],
    arena:     [[0, 2, 4], [0, 3, 5], [1, 4, 6], [2, 4, 6]]
  };

  // Tempo and feel per zone (beat duration in seconds)
  var ZONE_MUSIC_STYLE = {
    nexus:     { beatDuration: 2.0, padVolume: 0.08, melodyChance: 0.3, melodyVolume: 0.04, type: 'ethereal' },
    gardens:   { beatDuration: 1.8, padVolume: 0.07, melodyChance: 0.4, melodyVolume: 0.05, type: 'pastoral' },
    athenaeum: { beatDuration: 2.5, padVolume: 0.06, melodyChance: 0.2, melodyVolume: 0.03, type: 'mysterious' },
    studio:    { beatDuration: 1.5, padVolume: 0.07, melodyChance: 0.5, melodyVolume: 0.06, type: 'creative' },
    wilds:     { beatDuration: 2.2, padVolume: 0.05, melodyChance: 0.25, melodyVolume: 0.04, type: 'nature' },
    agora:     { beatDuration: 1.4, padVolume: 0.06, melodyChance: 0.4, melodyVolume: 0.05, type: 'lively' },
    commons:   { beatDuration: 1.8, padVolume: 0.07, melodyChance: 0.35, melodyVolume: 0.04, type: 'warm' },
    arena:     { beatDuration: 1.6, padVolume: 0.08, melodyChance: 0.3, melodyVolume: 0.05, type: 'dramatic' }
  };

  // Time-of-day modifiers
  var TIME_MODIFIERS = {
    dawn:    { tempoMult: 0.8, volumeMult: 0.6, melodyMult: 0.5, octaveShift: 0 },
    morning: { tempoMult: 0.9, volumeMult: 0.8, melodyMult: 0.8, octaveShift: 0 },
    midday:  { tempoMult: 1.0, volumeMult: 1.0, melodyMult: 1.0, octaveShift: 0 },
    afternoon: { tempoMult: 1.0, volumeMult: 0.9, melodyMult: 0.9, octaveShift: 0 },
    evening: { tempoMult: 0.85, volumeMult: 0.7, melodyMult: 0.6, octaveShift: -1 },
    night:   { tempoMult: 0.7, volumeMult: 0.4, melodyMult: 0.3, octaveShift: -1 }
  };

  function startMusic(zone, timeOfDay) {
    if (!audioContext || !masterGain) return;
    zone = zone || 'nexus';
    timeOfDay = timeOfDay || 'midday';

    // Stop existing music if playing
    if (musicState.playing) {
      stopMusic();
    }

    musicState.zone = zone;
    musicState.timeOfDay = timeOfDay;
    musicState.playing = true;
    musicState.chordIndex = 0;
    musicState.noteIndex = 0;
    musicState.arpIndex = 0;

    // Start the pad drone
    playPadChord();

    // Schedule melody notes
    scheduleMelody();
  }

  function playPadChord() {
    if (!audioContext || !masterGain || !musicState.playing) return;

    var zone = musicState.zone || 'nexus';
    var scale = SCALES[zone] || SCALES.nexus;
    var progression = CHORD_PROGRESSIONS[zone] || CHORD_PROGRESSIONS.nexus;
    var style = ZONE_MUSIC_STYLE[zone] || ZONE_MUSIC_STYLE.nexus;
    var timeMod = TIME_MODIFIERS[musicState.timeOfDay] || TIME_MODIFIERS.midday;

    var chordIndices = progression[musicState.chordIndex % progression.length];
    var beatDur = style.beatDuration / timeMod.tempoMult;
    var chordDuration = beatDur * 4; // 4 beats per chord

    // Clean up old pad nodes
    cleanupPadNodes();

    // Create pad oscillators for each note in the chord
    for (var i = 0; i < chordIndices.length; i++) {
      var noteIdx = chordIndices[i];
      var freq = scale[noteIdx % scale.length];

      // Apply octave shift for time of day
      if (timeMod.octaveShift < 0) freq *= 0.5;
      if (timeMod.octaveShift > 0) freq *= 2;

      // Pad uses two detuned oscillators for warmth
      for (var d = 0; d < 2; d++) {
        var osc = audioContext.createOscillator();
        var gain = audioContext.createGain();
        var filter = audioContext.createBiquadFilter();

        osc.type = (style.type === 'ethereal' || style.type === 'mysterious') ? 'sine' : 'triangle';
        osc.frequency.value = freq + (d === 0 ? -0.5 : 0.5); // slight detune

        filter.type = 'lowpass';
        filter.frequency.value = 800;
        filter.Q.value = 0.5;

        var padVol = style.padVolume * timeMod.volumeMult * musicState.volume;
        var now = audioContext.currentTime;

        // Fade in
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(padVol, now + chordDuration * 0.15);
        // Sustain
        gain.gain.setValueAtTime(padVol, now + chordDuration * 0.7);
        // Fade out
        gain.gain.linearRampToValueAtTime(0, now + chordDuration);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(now);
        osc.stop(now + chordDuration + 0.1);

        musicState.padNodes.push({ osc: osc, gain: gain, filter: filter, endTime: now + chordDuration + 0.2 });
      }
    }

    // Arpeggio â€” occasionally play individual notes from the chord
    if (Math.random() < 0.6) {
      var arpDelay = beatDur * 0.5;
      for (var a = 0; a < 3; a++) {
        (function(arpIdx, delay) {
          setTimeout(function() {
            if (!musicState.playing || !audioContext) return;
            var arpFreq = scale[chordIndices[arpIdx % chordIndices.length] % scale.length];
            if (timeMod.octaveShift < 0) arpFreq *= 0.5;
            arpFreq *= 2; // One octave up for sparkle

            var arpOsc = audioContext.createOscillator();
            var arpGain = audioContext.createGain();

            arpOsc.type = 'sine';
            arpOsc.frequency.value = arpFreq;

            var arpVol = style.melodyVolume * timeMod.volumeMult * musicState.volume * 0.6;
            var t = audioContext.currentTime;
            arpGain.gain.setValueAtTime(0, t);
            arpGain.gain.linearRampToValueAtTime(arpVol, t + 0.05);
            arpGain.gain.exponentialRampToValueAtTime(0.001, t + beatDur * 0.8);

            arpOsc.connect(arpGain);
            arpGain.connect(masterGain);
            arpOsc.start(t);
            arpOsc.stop(t + beatDur);
          }, delay * 1000);
        })(a, arpDelay * (a + 1));
      }
    }

    // Schedule next chord
    musicState.chordIndex++;
    musicState.beatTimer = setTimeout(function() {
      if (musicState.playing) playPadChord();
    }, chordDuration * 1000);
  }

  function scheduleMelody() {
    if (!audioContext || !masterGain || !musicState.playing) return;

    var zone = musicState.zone || 'nexus';
    var scale = SCALES[zone] || SCALES.nexus;
    var style = ZONE_MUSIC_STYLE[zone] || ZONE_MUSIC_STYLE.nexus;
    var timeMod = TIME_MODIFIERS[musicState.timeOfDay] || TIME_MODIFIERS.midday;

    var melodyChance = style.melodyChance * timeMod.melodyMult;
    var beatDur = style.beatDuration / timeMod.tempoMult;

    // Random delay before next melody note
    var delay = beatDur * (1 + Math.random() * 3);

    musicState.melodyTimeout = setTimeout(function() {
      if (!musicState.playing || !audioContext) return;

      if (Math.random() < melodyChance) {
        // Pick a note from the scale â€” favor stepwise motion
        var direction = Math.random() < 0.5 ? 1 : -1;
        var step = Math.random() < 0.7 ? 1 : 2;
        musicState.noteIndex = Math.max(0, Math.min(scale.length - 1, musicState.noteIndex + direction * step));
        var freq = scale[musicState.noteIndex];
        if (timeMod.octaveShift < 0) freq *= 0.5;
        freq *= 2; // Melody one octave up

        var melOsc = audioContext.createOscillator();
        var melGain = audioContext.createGain();
        var melFilter = audioContext.createBiquadFilter();

        // Vary timbre by zone
        if (style.type === 'nature' || style.type === 'pastoral') {
          melOsc.type = 'sine';
        } else if (style.type === 'dramatic' || style.type === 'lively') {
          melOsc.type = 'triangle';
        } else {
          melOsc.type = Math.random() < 0.5 ? 'sine' : 'triangle';
        }

        melOsc.frequency.value = freq;

        melFilter.type = 'lowpass';
        melFilter.frequency.value = 1200;

        var melVol = style.melodyVolume * timeMod.volumeMult * musicState.volume;
        var noteDur = beatDur * (0.5 + Math.random() * 1.5);
        var t = audioContext.currentTime;

        melGain.gain.setValueAtTime(0, t);
        melGain.gain.linearRampToValueAtTime(melVol, t + 0.03);
        melGain.gain.setValueAtTime(melVol * 0.8, t + noteDur * 0.5);
        melGain.gain.exponentialRampToValueAtTime(0.001, t + noteDur);

        melOsc.connect(melFilter);
        melFilter.connect(melGain);
        melGain.connect(masterGain);

        melOsc.start(t);
        melOsc.stop(t + noteDur + 0.1);

        // Occasionally add a harmony note
        if (Math.random() < 0.25) {
          var harmIdx = (musicState.noteIndex + 2) % scale.length;
          var harmFreq = scale[harmIdx] * 2;
          if (timeMod.octaveShift < 0) harmFreq *= 0.5;

          var harmOsc = audioContext.createOscillator();
          var harmGain = audioContext.createGain();

          harmOsc.type = 'sine';
          harmOsc.frequency.value = harmFreq;

          var harmVol = melVol * 0.4;
          harmGain.gain.setValueAtTime(0, t + 0.05);
          harmGain.gain.linearRampToValueAtTime(harmVol, t + 0.1);
          harmGain.gain.exponentialRampToValueAtTime(0.001, t + noteDur * 0.8);

          harmOsc.connect(harmGain);
          harmGain.connect(masterGain);
          harmOsc.start(t + 0.05);
          harmOsc.stop(t + noteDur);
        }
      }

      // Schedule next melody note
      scheduleMelody();
    }, delay * 1000);
  }

  function cleanupPadNodes() {
    var now = audioContext ? audioContext.currentTime : 0;
    musicState.padNodes = musicState.padNodes.filter(function(node) {
      if (now > node.endTime) {
        try {
          node.osc.disconnect();
          node.gain.disconnect();
          node.filter.disconnect();
        } catch (e) {}
        return false;
      }
      return true;
    });
  }

  function stopMusic() {
    musicState.playing = false;

    if (musicState.beatTimer) {
      clearTimeout(musicState.beatTimer);
      musicState.beatTimer = null;
    }
    if (musicState.melodyTimeout) {
      clearTimeout(musicState.melodyTimeout);
      musicState.melodyTimeout = null;
    }

    // Fade out all pad nodes
    for (var i = 0; i < musicState.padNodes.length; i++) {
      try {
        var node = musicState.padNodes[i];
        if (node.gain && audioContext) {
          node.gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
        }
      } catch (e) {}
    }

    // Clean up after fade
    setTimeout(function() {
      for (var i = 0; i < musicState.padNodes.length; i++) {
        try {
          musicState.padNodes[i].osc.disconnect();
          musicState.padNodes[i].gain.disconnect();
          musicState.padNodes[i].filter.disconnect();
        } catch (e) {}
      }
      musicState.padNodes = [];
    }, 600);
  }

  function updateMusic(zone, timeOfDay) {
    if (!musicState.playing) return;
    if (zone && zone !== musicState.zone) {
      startMusic(zone, timeOfDay || musicState.timeOfDay);
    } else if (timeOfDay && timeOfDay !== musicState.timeOfDay) {
      musicState.timeOfDay = timeOfDay;
      // Time changes take effect on next chord cycle naturally
    }
  }

  function setMusicVolume(vol) {
    musicState.volume = Math.max(0, Math.min(1, vol));
  }

  function isMusicPlaying() {
    return musicState.playing;
  }

  // â”€â”€â”€ Piano Accent System (BotW-style environmental cues) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Piano-like timbre: layered sine + soft triangle with fast attack, gentle decay
  // Each accent is a short melodic phrase triggered by world events

  var PIANO_ACCENTS = {
    dawn: {
      // Ascending bright arpeggio â€” C major pentatonic, hopeful
      notes: [261.63, 329.63, 392.00, 523.25, 659.25],
      noteSpacing: 0.12,
      noteDuration: 0.6,
      volume: 0.18
    },
    morning: {
      // Warm arpeggiated phrase â€” G major, gentle awakening
      notes: [392.00, 493.88, 587.33, 783.99, 987.77, 783.99],
      noteSpacing: 0.1,
      noteDuration: 0.5,
      volume: 0.14
    },
    dusk: {
      // Descending gentle â€” Am pentatonic, wistful
      notes: [880.00, 659.25, 523.25, 440.00, 329.63],
      noteSpacing: 0.15,
      noteDuration: 0.7,
      volume: 0.15
    },
    night: {
      // Low mysterious â€” Dm tones, sparse and atmospheric
      notes: [146.83, 174.61, 220.00, 196.00, 146.83],
      noteSpacing: 0.22,
      noteDuration: 0.9,
      volume: 0.12
    },
    zone_discovery: {
      // Flourish â€” ascending with a resolving turn, wonder
      notes: [392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 659.25, 783.99],
      noteSpacing: 0.09,
      noteDuration: 0.45,
      volume: 0.2
    },
    quest_complete: {
      // Triumphant fanfare phrase â€” C major with octave leap
      notes: [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50, 1318.51],
      noteSpacing: 0.1,
      noteDuration: 0.5,
      volume: 0.22
    },
    achievement: {
      // Playful ascending â€” sparkling discovery
      notes: [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50],
      noteSpacing: 0.08,
      noteDuration: 0.4,
      volume: 0.2
    }
  };

  function playPianoAccent(type) {
    if (!audioContext || !masterGain) return;
    var accent = PIANO_ACCENTS[type];
    if (!accent) return;

    // Resume context if suspended
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    var musicVol = volumeLevels.music !== undefined ? volumeLevels.music : 0.5;
    var baseVol = accent.volume * musicVol;

    try {
      for (var i = 0; i < accent.notes.length; i++) {
        (function(idx) {
          var freq = accent.notes[idx];
          var startTime = audioContext.currentTime + idx * accent.noteSpacing;

          // Layer 1: sine wave (fundamental â€” warm piano body)
          var osc1 = audioContext.createOscillator();
          var gain1 = audioContext.createGain();
          osc1.type = 'sine';
          osc1.frequency.value = freq;
          gain1.gain.setValueAtTime(0, startTime);
          gain1.gain.linearRampToValueAtTime(baseVol, startTime + 0.015);
          gain1.gain.exponentialRampToValueAtTime(baseVol * 0.6, startTime + accent.noteDuration * 0.3);
          gain1.gain.exponentialRampToValueAtTime(0.001, startTime + accent.noteDuration);
          osc1.connect(gain1);
          gain1.connect(masterGain);
          osc1.start(startTime);
          osc1.stop(startTime + accent.noteDuration + 0.05);

          // Layer 2: triangle wave (soft harmonic â€” adds "hammer" brightness)
          var osc2 = audioContext.createOscillator();
          var gain2 = audioContext.createGain();
          osc2.type = 'triangle';
          osc2.frequency.value = freq * 2; // octave above for shimmer
          gain2.gain.setValueAtTime(0, startTime);
          gain2.gain.linearRampToValueAtTime(baseVol * 0.3, startTime + 0.01);
          gain2.gain.exponentialRampToValueAtTime(0.001, startTime + accent.noteDuration * 0.5);
          osc2.connect(gain2);
          gain2.connect(masterGain);
          osc2.start(startTime);
          osc2.stop(startTime + accent.noteDuration * 0.5 + 0.05);

          // Layer 3: very quiet high sine for "sparkle" attack
          var osc3 = audioContext.createOscillator();
          var gain3 = audioContext.createGain();
          osc3.type = 'sine';
          osc3.frequency.value = freq * 4; // two octaves up
          gain3.gain.setValueAtTime(0, startTime);
          gain3.gain.linearRampToValueAtTime(baseVol * 0.08, startTime + 0.005);
          gain3.gain.exponentialRampToValueAtTime(0.001, startTime + 0.08);
          osc3.connect(gain3);
          gain3.connect(masterGain);
          osc3.start(startTime);
          osc3.stop(startTime + 0.1);
        })(i);
      }
    } catch (err) {
      // Graceful degradation â€” no crash if Web Audio fails
    }
  }

  function getPianoAccentTypes() {
    return PIANO_ACCENTS;
  }

  // Export public API
  exports.initAudio = initAudio;
  exports.playAmbient = playAmbient;
  exports.playSound = playSound;
  exports.playFootstep = playFootstep;
  exports.setVolume = setVolume;
  exports.mute = mute;
  exports.unmute = unmute;
  exports.stopAll = stopAll;

  // Time-of-day and weather ambient
  exports.updateAmbientTime = updateAmbientForTime;
  exports.updateAmbientWeather = updateAmbientForWeather;
  exports.setZoneAmbient = setZoneAmbient;

  // NPC sounds
  exports.playNPCSound = playNPCSound;

  // Music system
  exports.startMusic = startMusic;
  exports.stopMusic = stopMusic;
  exports.updateMusic = updateMusic;
  exports.setMusicVolume = setMusicVolume;
  exports.isMusicPlaying = isMusicPlaying;

  // Piano accent system
  exports.playPianoAccent = playPianoAccent;
  exports.getPianoAccentTypes = getPianoAccentTypes;

})(typeof module !== 'undefined' ? module.exports : (window.Audio = {}));


// npc_ai.js
/**
 * NPC_AI.js - Comprehensive NPC Artificial Intelligence Module
 * Inspired by Halo's AI systems but adapted for a peaceful MMO
 *
 * This module provides the "brain" for all NPC behavior, including:
 * - Perception system (environment, players, NPCs, events)
 * - Memory system (interactions, preferences, reputation)
 * - Goal/Drive system (archetype-specific motivations)
 * - Behavior tree (intelligent decision making)
 * - Daily schedules (time-based routines)
 * - Event reactions (contextual responses)
 * - Group dynamics (social behaviors)
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // CONSTANTS & CONFIGURATION
  // ============================================================================

  var PERCEPTION_RADIUS = 25; // How far NPCs can "see"
  var INTERACTION_COOLDOWN = 30000; // 30 seconds before re-greeting same player
  var MEMORY_DECAY_RATE = 0.001; // Per tick familiarity decay
  var MAX_INTERACTIONS_REMEMBERED = 20;
  var MAX_EVENTS_REMEMBERED = 10;
  var ENERGY_DECAY_RATE = 0.05; // Per minute
  var ENERGY_REGEN_RATE = 0.2; // Per minute when resting
  var FAMILIARITY_GAIN = 5; // Points per interaction
  var FAMILIARITY_THRESHOLD_FRIENDLY = 25;
  var FAMILIARITY_THRESHOLD_CLOSE = 60;
  var GROUP_FORMATION_RADIUS = 15;
  var WORK_SATISFACTION_GAIN = 10;

  // ============================================================================
  // ARCHETYPE DRIVES - Core motivations for each NPC type
  // ============================================================================

  var ARCHETYPE_DRIVES = {
    gardener: {
      primary: 'tend_plants',
      secondary: 'explore_flora',
      social: 'share_harvest',
      rest: 'sit_in_garden',
      work_locations: ['gardens', 'wilds'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'rain', // Loves rain
    },
    builder: {
      primary: 'inspect_structures',
      secondary: 'gather_materials',
      social: 'discuss_plans',
      rest: 'sketch_designs',
      work_locations: ['agora', 'construction_sites'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'clear',
    },
    storyteller: {
      primary: 'visit_athenaeum',
      secondary: 'collect_stories',
      social: 'tell_stories',
      rest: 'write_journal',
      work_locations: ['athenaeum', 'agora'],
      preferred_time: ['afternoon', 'evening'],
      weather_preference: 'any',
    },
    merchant: {
      primary: 'tend_shop',
      secondary: 'acquire_goods',
      social: 'negotiate_trade',
      rest: 'count_inventory',
      work_locations: ['agora', 'marketplace'],
      preferred_time: ['morning', 'midday', 'afternoon'],
      weather_preference: 'clear',
    },
    explorer: {
      primary: 'explore_wilds',
      secondary: 'map_territory',
      social: 'share_discoveries',
      rest: 'study_maps',
      work_locations: ['wilds', 'mountains', 'coastline'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'any', // Explorers don't care
    },
    teacher: {
      primary: 'teach_lesson',
      secondary: 'research',
      social: 'mentor_individual',
      rest: 'read_texts',
      work_locations: ['athenaeum', 'agora'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'clear',
    },
    musician: {
      primary: 'perform',
      secondary: 'compose',
      social: 'jam_session',
      rest: 'tune_instrument',
      work_locations: ['agora', 'amphitheater', 'gardens'],
      preferred_time: ['evening', 'night'],
      weather_preference: 'clear',
    },
    healer: {
      primary: 'tend_wounded',
      secondary: 'gather_herbs',
      social: 'offer_comfort',
      rest: 'meditate',
      work_locations: ['gardens', 'healing_grove', 'agora'],
      preferred_time: ['morning', 'midday'],
      weather_preference: 'clear',
    },
    philosopher: {
      primary: 'contemplate',
      secondary: 'debate',
      social: 'discuss_ideas',
      rest: 'stargaze',
      work_locations: ['overlook', 'gardens', 'athenaeum'],
      preferred_time: ['afternoon', 'evening', 'night'],
      weather_preference: 'clear',
    },
    artist: {
      primary: 'create_art',
      secondary: 'find_inspiration',
      social: 'show_work',
      rest: 'observe_beauty',
      work_locations: ['gardens', 'overlook', 'coastline'],
      preferred_time: ['morning', 'afternoon', 'evening'],
      weather_preference: 'any', // Artists find beauty in all weather
    }
  };

  // ============================================================================
  // DAILY SCHEDULE - Time-based behavior modifiers
  // ============================================================================

  var DAILY_SCHEDULE = {
    dawn: {
      hours: [5, 7],
      activity: 'wake_stretch',
      energy_regen: 0.5,
      social_chance: 0.1,
      work_priority: 0.3,
    },
    morning: {
      hours: [7, 12],
      activity: 'primary_work',
      energy_regen: 0,
      social_chance: 0.3,
      work_priority: 1.0,
    },
    midday: {
      hours: [12, 14],
      activity: 'socialize_eat',
      energy_regen: 0.2,
      social_chance: 0.8,
      work_priority: 0.2,
    },
    afternoon: {
      hours: [14, 18],
      activity: 'secondary_work',
      energy_regen: 0,
      social_chance: 0.4,
      work_priority: 0.8,
    },
    evening: {
      hours: [18, 21],
      activity: 'socialize_music',
      energy_regen: 0,
      social_chance: 0.9,
      work_priority: 0.3,
    },
    night: {
      hours: [21, 5],
      activity: 'rest_stargaze',
      energy_regen: 1.0,
      social_chance: 0.2,
      work_priority: 0.1,
    }
  };

  // ============================================================================
  // CONTEXTUAL DIALOGUES - Archetype and context-specific dialogue
  // ============================================================================

  var CONTEXTUAL_DIALOGUES = {
    gardener: {
      greeting_first: [
        "Welcome to ZION! I'm {name}. The gardens are beautiful today.",
        "Hello there! I tend the gardens here. The flowers are in bloom!",
        "Greetings, friend! Have you seen the moonflowers by the pond?"
      ],
      greeting_familiar: [
        "Good to see you again! The {plant} I planted is growing well.",
        "Welcome back! Would you like to help me water the herbs?",
        "Ah, my friend returns! The garden remembers you."
      ],
      greeting_close: [
        "My dear friend! I saved some seeds for you.",
        "I was hoping you'd come by! Look at this new variety!",
        "Perfect timing! I need your opinion on these blooms."
      ],
      weather_rain: [
        "Perfect weather for the gardens!",
        "The flowers will love this rain.",
        "*dancing in the rain* Nature's gift!",
        "Rain means growth. Beautiful, isn't it?"
      ],
      weather_snow: [
        "Even in snow, life persists. See these hardy plants?",
        "Winter gardens have their own beauty.",
        "The frost makes crystals on the leaves. Magical."
      ],
      weather_clear: [
        "What a beautiful day to tend the garden.",
        "The sunshine makes everything grow.",
        "Perfect weather for planting!"
      ],
      time_morning: [
        "Early bird! The morning dew is perfect for planting.",
        "Good morning! The world is waking up.",
        "*trimming plants* Best time to work the soil."
      ],
      time_evening: [
        "The sunset colors are inspiring today.",
        "Evening light makes the flowers glow.",
        "Time to water before nightfall."
      ],
      time_night: [
        "The night-blooming flowers are opening. Come see!",
        "Starlight on petals... there's nothing quite like it.",
        "The garden sleeps, but I'm watching over it."
      ],
      player_building: [
        "That's looking great! Need any plants to decorate?",
        "Beautiful structure! I can bring vines to accent it.",
        "A gardener appreciates good craftsmanship!"
      ],
      player_harvesting: [
        "Good technique! Try the moonflowers next.",
        "Gentle hands. The plants appreciate that.",
        "Would you like to know the best time to harvest sage?"
      ],
      working: [
        "*carefully tends the soil*",
        "*hums while watering*",
        "*examining leaves for health*",
        "*pruning with precision*"
      ],
      idle_observation: [
        "Those clouds remind me of cotton flowers.",
        "I think I see a new bloom over there!",
        "The bees are busy today. Good sign.",
        "Every plant has a story, if you listen."
      ],
      near_water: [
        "The pond keeps everything lush.",
        "Water is life.",
        "I come here to refill my watering can."
      ],
      group_forming: [
        "Should we start a community garden?",
        "Many hands make gardens grow!",
        "I can teach you all about composting!"
      ]
    },

    builder: {
      greeting_first: [
        "Greetings! I'm {name}, master builder. Always working on something new!",
        "Hello! Notice the archways? That's my work.",
        "Welcome! A builder's work is never done, but I love every moment."
      ],
      greeting_familiar: [
        "Back again? Good! I want your opinion on this design.",
        "Ah, perfect timing! Need an extra pair of hands.",
        "Good to see you! The foundation we discussed is complete."
      ],
      greeting_close: [
        "My friend! I've been sketching ideas all morning. Look!",
        "I knew you'd come! This project needs your creative eye.",
        "Finally! No one appreciates structure like you do."
      ],
      weather_rain: [
        "Rain delays construction, but gives time to plan.",
        "*covering materials* We'll resume when it clears.",
        "Indoor projects today, I think."
      ],
      weather_clear: [
        "Perfect building weather!",
        "Clear skies mean we can work on the roof.",
        "Foundation work requires dry ground. Excellent!"
      ],
      time_morning: [
        "Morning! Best light for measuring and cutting.",
        "Early start means more progress!",
        "*reviewing blueprints* Let's begin."
      ],
      time_evening: [
        "Golden hour is perfect for admiring finished work.",
        "One more stone before sunset...",
        "Time to clean the tools and plan tomorrow."
      ],
      player_building: [
        "Excellent work! May I suggest reinforcing that corner?",
        "A fellow builder! Your technique is impressive.",
        "Strong foundation! That will last generations.",
        "Mind if I watch? I always learn from others."
      ],
      working: [
        "*measuring twice, cutting once*",
        "*carefully placing stones*",
        "*testing structural integrity*",
        "*sketching improvements*"
      ],
      idle_observation: [
        "That column's proportions are perfect.",
        "I wonder if we could build a bridge there...",
        "Every structure tells the story of its builder.",
        "The ancient ruins inspire me. Such craftsmanship!"
      ],
      group_forming: [
        "A building project needs teamwork!",
        "Together we can create something magnificent!",
        "Let me show you all the proper techniques."
      ]
    },

    storyteller: {
      greeting_first: [
        "Ah, a new face! I'm {name}. Every person has a story worth telling.",
        "Welcome, traveler! Sit, and I'll share a tale.",
        "Greetings! I collect stories. Perhaps you have one to share?"
      ],
      greeting_familiar: [
        "Welcome back! Ready for another tale?",
        "Ah, you've returned! The story continues...",
        "My friend! I've learned a new legend since we last spoke."
      ],
      greeting_close: [
        "My dear friend! Your own story grows richer each day.",
        "I've been saving the best tales for your return!",
        "Sit close. This story is for you alone."
      ],
      weather_rain: [
        "Rain is perfect for storytelling by the fire.",
        "The patter of rain makes a nice backdrop for tales.",
        "Stormy weather brings stormy stories!"
      ],
      weather_clear: [
        "Perfect evening for tales under the stars.",
        "Clear skies, clear minds, clear stories.",
        "Sunshine inspires lighter tales."
      ],
      time_evening: [
        "Evening is when the best stories are told.",
        "Gather 'round! The shadows grow, and so do legends.",
        "*preparing to perform* The perfect hour for storytelling."
      ],
      time_night: [
        "By starlight, I'll tell you of ancient wonders...",
        "Night brings out the mysterious tales.",
        "The darkness makes every story more vivid."
      ],
      working: [
        "*gesturing dramatically*",
        "*voice rising and falling with emotion*",
        "*scribbling notes*",
        "*practicing delivery*"
      ],
      idle_observation: [
        "Every corner of ZION has a story.",
        "I wonder what tales these stones could tell...",
        "That merchant looks like they have stories from afar.",
        "History is all around us, waiting to be discovered."
      ],
      group_forming: [
        "Gather close! I have a tale for you all!",
        "Stories are best shared with many ears!",
        "Come, friends! Let me tell you of heroes past!"
      ]
    },

    merchant: {
      greeting_first: [
        "Welcome to my stall! I'm {name}. Best goods in ZION!",
        "Greetings, customer! See anything you like?",
        "Hello there! Fair prices and quality goods, guaranteed!"
      ],
      greeting_familiar: [
        "Ah, my returning customer! I have something special today.",
        "Welcome back! Your patronage is appreciated!",
        "Good to see you! I saved this item with you in mind."
      ],
      greeting_close: [
        "My valued friend! For you, a special discount.",
        "Excellent timing! I just received rare goods!",
        "My dear patron! Let me show you the finest selections."
      ],
      weather_rain: [
        "*covering goods* Quick, before they get wet!",
        "Rain is bad for business, good for discounts!",
        "Come inside my tent! Can't let merchandise get soaked."
      ],
      weather_clear: [
        "Perfect market day!",
        "Sunshine brings customers!",
        "Business is good when the weather cooperates!"
      ],
      time_morning: [
        "*setting up stall* Early bird gets the best deals!",
        "Morning! Fresh inventory just arrived!",
        "Opening for business! Come see!"
      ],
      time_midday: [
        "Busy market hour! Step right up!",
        "Peak time for trading!",
        "The Agora is alive with commerce!"
      ],
      time_evening: [
        "Last chance for today's deals!",
        "Closing soon, but still open for you!",
        "*packing up* Tomorrow I'll have even better goods!"
      ],
      working: [
        "*arranging wares attractively*",
        "*calculating prices*",
        "*polishing merchandise*",
        "*calling out to passersby*"
      ],
      idle_observation: [
        "I wonder what goods that traveler carries...",
        "Business is steady today.",
        "Quality over quantity, always.",
        "A merchant's eye never rests."
      ],
      group_forming: [
        "Fellow merchants! Let's discuss trade routes!",
        "Perhaps we could organize a market festival?",
        "The more merchants, the livelier the market!"
      ]
    },

    explorer: {
      greeting_first: [
        "Ho there! I'm {name}, explorer of ZION's wilds!",
        "Greetings, friend! Just returned from the frontier.",
        "Well met! These lands hold countless secrets."
      ],
      greeting_familiar: [
        "Back from your own explorations?",
        "Good to see you! I've mapped new territories!",
        "Ah! Want to hear about what I discovered?"
      ],
      greeting_close: [
        "My fellow adventurer! Let's explore together!",
        "I've been hoping you'd come! I found something amazing!",
        "Perfect! I need someone brave to witness this discovery."
      ],
      weather_rain: [
        "Rain won't stop an explorer!",
        "*pulling up hood* Weather adds to the adventure!",
        "Rain reveals hidden streams and paths."
      ],
      weather_snow: [
        "Snow makes tracking easier!",
        "Winter landscapes are breathtaking.",
        "The wilds are beautiful in every season."
      ],
      weather_clear: [
        "Perfect day for exploration!",
        "Clear weather means good visibility!",
        "I can see for miles today!"
      ],
      time_morning: [
        "Dawn is the best time to spot wildlife!",
        "*checking compass* Time to head out!",
        "Early start, more ground to cover!"
      ],
      working: [
        "*scanning the horizon*",
        "*making notes on a map*",
        "*examining interesting features*",
        "*testing the ground*"
      ],
      idle_observation: [
        "I wonder what's beyond those mountains...",
        "Every horizon calls to be explored.",
        "The frontier is never fully mapped.",
        "Adventure is everywhere if you look."
      ],
      group_forming: [
        "Expedition party forming! Who's brave enough?",
        "Safety in numbers when exploring!",
        "Let's chart the unknown together!"
      ]
    },

    teacher: {
      greeting_first: [
        "Welcome, student! I'm {name}. Knowledge is meant to be shared.",
        "Greetings! Always happy to see eager minds.",
        "Hello! What would you like to learn today?"
      ],
      greeting_familiar: [
        "My returning student! Ready for the next lesson?",
        "Excellent! Your progress has been remarkable.",
        "Welcome back! I've prepared advanced materials."
      ],
      greeting_close: [
        "My star pupil! You continue to impress me.",
        "I've been researching topics just for you!",
        "Your dedication to learning honors us both."
      ],
      weather_clear: [
        "Beautiful day for outdoor lessons!",
        "Clear minds match clear skies.",
        "Perfect weather for demonstrations!"
      ],
      time_morning: [
        "Morning minds are fresh and ready!",
        "Let's begin today's lesson.",
        "*preparing teaching materials* Good morning!"
      ],
      time_afternoon: [
        "Afternoon is perfect for practical exercises.",
        "Review time! Let's test what you've learned.",
        "Advanced topics require afternoon focus."
      ],
      working: [
        "*explaining with gestures*",
        "*writing on a tablet*",
        "*demonstrating technique*",
        "*patiently answering questions*"
      ],
      idle_observation: [
        "Every moment is a chance to learn.",
        "I should research that further...",
        "Knowledge builds upon knowledge.",
        "Teaching is the highest form of learning."
      ],
      group_forming: [
        "Class is in session! Gather around!",
        "The more students, the richer the discussion!",
        "Let's form a study circle!"
      ]
    },

    musician: {
      greeting_first: [
        "Hello! I'm {name}. Music is the soul of ZION!",
        "*strumming* Welcome, friend! Care for a tune?",
        "Greetings! The world is better with music."
      ],
      greeting_familiar: [
        "My audience returns! Requests?",
        "*playing a familiar melody* This one's for you!",
        "Welcome back! I've learned new songs!"
      ],
      greeting_close: [
        "My friend! Let's make music together!",
        "I composed something special for you!",
        "*starting your favorite song* I remember what you love."
      ],
      weather_rain: [
        "Rain has its own rhythm. Listen...",
        "Nature's percussion! *tapping along*",
        "*playing under shelter* Rain makes everything melancholy and beautiful."
      ],
      weather_clear: [
        "Perfect night for performance!",
        "Clear acoustics tonight!",
        "The stars will be my audience!"
      ],
      time_evening: [
        "Evening is when music truly shines!",
        "*tuning instrument* Almost time to perform!",
        "Gather 'round! Concert begins at sunset!"
      ],
      time_night: [
        "Night music has special magic.",
        "*playing softly* Lullabies for the world.",
        "The stars dance to midnight melodies."
      ],
      working: [
        "*playing a complex melody*",
        "*humming while composing*",
        "*adjusting instrument strings*",
        "*keeping rhythm*"
      ],
      idle_observation: [
        "I hear music in everything...",
        "That bird's song would make a lovely motif.",
        "The wind through the trees, nature's orchestra.",
        "Every sound is part of the symphony."
      ],
      group_forming: [
        "Musicians! Jam session time!",
        "Let's create harmony together!",
        "Audience gathering! Time to perform!"
      ]
    },

    healer: {
      greeting_first: [
        "Welcome, child. I'm {name}. Are you well?",
        "Greetings, friend. Peace and health to you.",
        "Hello! I'm here if you need healing or herbs."
      ],
      greeting_familiar: [
        "Good to see you healthy and strong!",
        "Welcome back! How are you feeling?",
        "Ah, your energy looks much better!"
      ],
      greeting_close: [
        "My dear friend, you bring light with you.",
        "I'm always happy to see your face.",
        "Come, sit. Let's talk and restore spirits."
      ],
      weather_rain: [
        "Rain cleanses and renews.",
        "Good weather for gathering medicinal mushrooms!",
        "The earth drinks, and we all benefit."
      ],
      weather_clear: [
        "Sunshine is the best medicine.",
        "Perfect day for herb drying!",
        "Clear weather, clear health."
      ],
      time_morning: [
        "Morning energy is vital and strong.",
        "*gathering herbs* Dawn dew enhances potency.",
        "Begin the day with wellness."
      ],
      working: [
        "*grinding herbs gently*",
        "*meditating quietly*",
        "*examining plants carefully*",
        "*offering soothing words*"
      ],
      idle_observation: [
        "Balance is the key to health.",
        "Every plant has healing properties.",
        "The body knows how to heal itself.",
        "Wellness is a journey, not a destination."
      ],
      group_forming: [
        "Gather, friends. Let's share wellness practices.",
        "Healing circles amplify positive energy!",
        "Together we can create community health."
      ]
    },

    philosopher: {
      greeting_first: [
        "Greetings, seeker. I'm {name}. What questions trouble your mind?",
        "Welcome! I ponder the great mysteries here.",
        "Hello, friend. Care to contemplate existence?"
      ],
      greeting_familiar: [
        "Ah, you return! Have you been thinking about our discussion?",
        "Welcome back! I've had new insights.",
        "Good to see you! Ready for deeper questions?"
      ],
      greeting_close: [
        "My fellow thinker! Let's unravel mysteries together!",
        "I've been eager to hear your perspective!",
        "Two minds together see truths one alone cannot."
      ],
      weather_rain: [
        "Rain reminds us that change is constant.",
        "Each drop is unique, yet all are water. Curious.",
        "What is rain but the sky thinking aloud?"
      ],
      weather_clear: [
        "Clarity without matches clarity within.",
        "The cosmos reveals itself on clear nights.",
        "In clear skies, we see infinity."
      ],
      time_evening: [
        "Evening brings contemplative moods.",
        "As the sun sets, different truths emerge.",
        "*watching sunset* Transitions teach us much."
      ],
      time_night: [
        "Under stars, we remember how small we are.",
        "*stargazing* Each light is a sun with its own worlds...",
        "Night questions are the deepest questions."
      ],
      working: [
        "*sitting in deep thought*",
        "*sketching cosmic diagrams*",
        "*debating with self*",
        "*observing patterns*"
      ],
      idle_observation: [
        "Why does anything exist rather than nothing?",
        "Patterns repeat at every scale...",
        "What is consciousness but the universe observing itself?",
        "Every answer births new questions."
      ],
      group_forming: [
        "Let's form a discourse circle!",
        "Many perspectives illuminate truth!",
        "Philosophy thrives in dialogue!"
      ]
    },

    artist: {
      greeting_first: [
        "Hello! I'm {name}. I try to capture ZION's beauty.",
        "Welcome! An artist's work is never done.",
        "Greetings! Every vista here inspires creation."
      ],
      greeting_familiar: [
        "Back to see the progress?",
        "Your visits always bring fresh perspective!",
        "Ah! I value your aesthetic sense!"
      ],
      greeting_close: [
        "My muse has returned!",
        "I've created something I need you to see!",
        "Your appreciation means everything to me."
      ],
      weather_rain: [
        "Rain creates such interesting textures!",
        "*capturing the mood* Melancholy is beautiful too.",
        "The colors deepen in rain. Magnificent!"
      ],
      weather_snow: [
        "Winter palettes are subtle and profound.",
        "*working quickly* Snow won't last, must capture it!",
        "White on white, infinite shades..."
      ],
      weather_clear: [
        "Perfect light for painting!",
        "The colors are so vibrant today!",
        "Clear skies show every hue."
      ],
      time_morning: [
        "Morning light is soft and golden.",
        "*sketching quickly* Dawn never lasts long enough!",
        "The world is fresh and new each morning."
      ],
      time_evening: [
        "Golden hour! Every artist's favorite time!",
        "*painting frantically* The colors! The colors!",
        "Sunset is fleeting. Must work fast."
      ],
      working: [
        "*applying paint with care*",
        "*stepping back to assess*",
        "*mixing colors thoughtfully*",
        "*lost in creative flow*"
      ],
      idle_observation: [
        "Beauty is everywhere, if you look.",
        "That composition is perfect...",
        "Color, light, form... all dancing together.",
        "Art is seeing what others overlook."
      ],
      group_forming: [
        "Artists! Let's share techniques!",
        "Every artist sees differently. Let's compare!",
        "Collective creativity sparks innovation!"
      ]
    }
  };

  // ============================================================================
  // ZONE-SPECIFIC DIALOGUES (shared across archetypes)
  // ============================================================================

  var ZONE_DIALOGUES = {
    nexus: [
      "The Nexus hums with energy today.",
      "Everyone passes through here eventually.",
      "The heart of ZION beats strong.",
      "New faces arrive every day. The world grows.",
      "I love the way all paths converge here."
    ],
    gardens: [
      "The gardens are especially beautiful today.",
      "Can you smell the jasmine? Heavenly.",
      "Everything grows so well here.",
      "The gardeners have been busy. Look at those blooms!",
      "I always feel peaceful in the gardens."
    ],
    wilds: [
      "Stay alert out here. The wilds are unpredictable.",
      "I've heard there are rare plants deep in these woods.",
      "The frontier calls to the adventurous.",
      "Few venture this far. You're brave.",
      "The wilds hold secrets waiting to be found."
    ],
    athenaeum: [
      "Knowledge fills these halls.",
      "The scrolls here contain ancient wisdom.",
      "Quiet, please. Some are studying.",
      "Have you read the founding texts? Fascinating.",
      "Learning never ends in the Athenaeum."
    ],
    studio: [
      "Creativity fills the air here.",
      "I love watching the artists at work.",
      "The Studio inspires everyone who enters.",
      "Art gives meaning to our world.",
      "Have you seen the latest sculptures?"
    ],
    agora: [
      "The market is bustling today!",
      "Good deals to be found if you look.",
      "The Agora never sleeps.",
      "Trade is the lifeblood of any community.",
      "I heard a merchant just got rare goods."
    ],
    commons: [
      "The Commons feel like home.",
      "Community is what we build here.",
      "I love what everyone has contributed.",
      "The workshops are always busy.",
      "Building together is building forever."
    ],
    arena: [
      "The Arena pulses with competitive spirit!",
      "Friendly competition makes us all stronger.",
      "Champions are made here!",
      "The crowd's energy is incredible.",
      "May the best challenger win!"
    ]
  };

  // ============================================================================
  // INTER-ARCHETYPE REACTION DIALOGUES
  // ============================================================================

  var ARCHETYPE_REACTIONS = {
    gardener: {
      musician: "Your music makes my flowers bloom brighter!",
      builder: "Could you build a trellis for my vines?",
      healer: "I have herbs that might help your remedies.",
      artist: "Please paint my garden someday!",
      merchant: "I have fresh produce for your stall.",
      storyteller: "The oldest oak has stories to tell...",
      explorer: "Did you find any rare seeds on your travels?",
      teacher: "Will you teach the children about botany?",
      philosopher: "What do you think plants dream about?"
    },
    builder: {
      gardener: "Plant something by my new building?",
      musician: "I need good acoustics in this hall I'm building.",
      healer: "I'm building a new healing pavilion.",
      artist: "Want to design the facade?",
      merchant: "I need materials. What do you have?",
      storyteller: "This wall needs an engraved legend.",
      explorer: "Found any interesting stone quarries?",
      teacher: "I could build a lecture hall for you.",
      philosopher: "Is the perfect building possible?"
    },
    storyteller: {
      gardener: "Tell me the legend of the first seed.",
      musician: "Would you accompany my tale with music?",
      builder: "Every building you make is a story in stone.",
      healer: "Healing stories are the most powerful.",
      artist: "Illustrate my latest tale?",
      merchant: "Stories from distant lands to trade?",
      explorer: "You must have incredible tales to share!",
      teacher: "Let's teach through storytelling!",
      philosopher: "What is truth in a story?"
    },
    merchant: {
      gardener: "Fresh flowers always sell well.",
      musician: "You draw crowds! Set up near my stall?",
      builder: "I have timber and nails you'll need.",
      healer: "Healing potions sell for good Spark!",
      artist: "Your art would fetch a premium.",
      storyteller: "Stories attract customers. Perfect partnership!",
      explorer: "Bring me exotic goods from your travels!",
      teacher: "Education about quality helps sales.",
      philosopher: "What is the true value of Spark?"
    },
    explorer: {
      gardener: "I found strange plants in the deep wilds!",
      musician: "The acoustics in that cave were amazing.",
      builder: "There are ancient ruins to the north!",
      healer: "I found rare medicinal moss on the cliff face.",
      artist: "The vista from the eastern ridge is breathtaking.",
      storyteller: "I discovered something the legends speak of!",
      merchant: "I've got rare finds from the frontier.",
      teacher: "The wilds teach lessons no book can.",
      philosopher: "Exploration is philosophy in motion."
    },
    teacher: {
      gardener: "Botany class begins with your garden.",
      musician: "Music theory is fascinating, isn't it?",
      builder: "Architecture has much to teach us.",
      healer: "Medical knowledge saves lives.",
      artist: "Art history is endlessly rich.",
      storyteller: "Oral tradition preserves culture.",
      merchant: "Economics drives civilization.",
      explorer: "Geography shapes destiny.",
      philosopher: "Every discipline leads to the same questions."
    },
    musician: {
      gardener: "Your garden hums with lifeâ€”I'll write it a song!",
      builder: "The rhythm of your hammer inspires me.",
      healer: "Healing harmonics are real. I've studied them.",
      artist: "Music and artâ€”the twin souls of creation.",
      storyteller: "Let me compose a soundtrack for your tale!",
      merchant: "I'll play for customers if you share the Spark!",
      explorer: "Every land has its own song waiting to be heard.",
      teacher: "Music is the universal language, yes?",
      philosopher: "What is sound, really, but structured silence?"
    },
    healer: {
      gardener: "Your herbs are essential to my practice.",
      musician: "Music heals wounds no salve can reach.",
      builder: "A healthy body builds a strong world.",
      artist: "Beauty is healing in visual form.",
      storyteller: "Stories can heal the soul.",
      merchant: "I need suppliesâ€”got any healing crystals?",
      explorer: "Stay safe out there. I'll be here if you're hurt.",
      teacher: "Prevention is the best medicine.",
      philosopher: "What does it mean to be truly well?"
    },
    philosopher: {
      gardener: "Growth is the fundamental urge of all things.",
      musician: "If music is math made beautiful, what is beauty?",
      builder: "We build to defy entropy. A noble endeavor.",
      healer: "Is perfect health the absence of illness, or something more?",
      artist: "Does art reveal truth or create it?",
      storyteller: "Stories shape how we see reality itself.",
      merchant: "Value is a collective hallucination, isn't it?",
      explorer: "The greatest journey is inward.",
      teacher: "Can we truly teach, or merely point the way?"
    },
    artist: {
      gardener: "Nature is the greatest artist.",
      musician: "Our arts are siblingsâ€”let's collaborate!",
      builder: "Architecture is art that shelters.",
      healer: "I want to paint the act of healing.",
      storyteller: "Every story paints pictures in the mind.",
      merchant: "Does commerce diminish art or elevate it?",
      explorer: "The landscapes you describeâ€”I must see them!",
      teacher: "Teach me that technique you mentioned.",
      philosopher: "Art is philosophy made visible."
    }
  };

  // ============================================================================
  // QUEST HOOK DIALOGUES (NPCs hint at available tasks)
  // ============================================================================

  var QUEST_HOOKS = {
    gardener: [
      "I could use help gathering sunflowers for the festival...",
      "The moonflower seeds need planting. Know anyone interested?",
      "A rare bloom was spotted in the Wilds. I wish I could go look...",
      "My herb garden needs tending while I research new species."
    ],
    builder: [
      "The bridge near the commons needs repair. Volunteers?",
      "I'm designing a new gazebo but need special stone...",
      "Someone left materials scattered at the construction site.",
      "The old tower could use reinforcement. Big project, good Spark."
    ],
    storyteller: [
      "I'm collecting tales from each zone. Want to help gather them?",
      "A lost manuscript was last seen in the Athenaeum depths...",
      "The founding stories are fading from memory. Help preserve them?",
      "I need someone to interview the elder NPCs for my chronicle."
    ],
    merchant: [
      "I'm missing a delivery from the gardens. Could you check?",
      "A rare gem went missing from my inventory...",
      "I need someone to scout prices in the other zones.",
      "Big trade deal coming up. I need rare materials."
    ],
    explorer: [
      "There's an unmapped cave system I've been wanting to explore.",
      "Strange lights in the wilds at nightâ€”want to investigate?",
      "The ancient markers near the arena need documenting.",
      "I found tracks of something unusual. Help me follow them?"
    ],
    teacher: [
      "I need specimens from each zone for my natural history class.",
      "Can you deliver these lesson scrolls to students in the commons?",
      "My research requires a crystal from the studio caves.",
      "Help me set up the outdoor classroom by the gardens."
    ],
    musician: [
      "I'm organizing a concert but need instruments gathered.",
      "The acoustics stone in the arena was chipped. Find a replacement?",
      "I hear the wilds have singing crystals. Bring me one!",
      "Help me spread word of tonight's performance to all zones."
    ],
    healer: [
      "I'm running low on moonpetal herbs. The gardens might have some.",
      "A traveler fell illâ€”I need crystal dust from the studio.",
      "Help me set up healing stations across the zones.",
      "Rare medicinal moss grows on the arena stones. Can you gather some?"
    ],
    philosopher: [
      "Debate me on the nature of ZION. I'll reward good arguments!",
      "Find the three wisdom stones hidden across the zones.",
      "Carry this sealed question to the storyteller and bring back the answer.",
      "I seek the meaning of the ancient symbols on the obelisk."
    ],
    artist: [
      "I need pigments from rare flowers in the gardens.",
      "Inspiration! Go sketch the view from three different zones.",
      "The mural in the commons needs restoration help.",
      "Find the legendary canvas stone in the wilds for me."
    ]
  };

  // ============================================================================
  // MOOD SYSTEM
  // ============================================================================

  var MOODS = ['content', 'excited', 'contemplative', 'social', 'tired', 'focused', 'curious', 'peaceful'];

  function calculateMood(memory, perception, timeOfDay) {
    var energy = memory.energy || 100;
    var schedule = getSchedulePeriod(perception.timeOfDay);
    var recentSocial = memory.interactions.filter(function(i) {
      return Date.now() - i.timestamp < 300000; // Last 5 minutes
    }).length;

    // Tired if low energy
    if (energy < 30) return 'tired';

    // Social during high social chance periods
    if (schedule.social_chance > 0.7 && recentSocial > 0) return 'social';

    // Excited if recently witnessed exciting event
    var recentExciting = memory.witnessedEvents.filter(function(e) {
      return e.type === 'portal_activation' || e.type === 'group_forming';
    }).length > 0;
    if (recentExciting) return 'excited';

    // Contemplative at night or evening for certain archetypes
    if ((timeOfDay === 'evening' || timeOfDay === 'night') &&
        (memory.archetype === 'philosopher' || memory.archetype === 'artist')) {
      return 'contemplative';
    }

    // Focused during work hours
    if (schedule.work_priority > 0.7) return 'focused';

    // Curious if explorer or in new location
    if (memory.archetype === 'explorer' || perception.recentEvents.some(function(e) {
      return e.type === 'new_discovery';
    })) {
      return 'curious';
    }

    // Peaceful in gardens or near water
    if (perception.currentZone === 'gardens' || perception.nearWater) {
      return 'peaceful';
    }

    return 'content';
  }

  // ============================================================================
  // PERCEPTION SYSTEM
  // ============================================================================

  function perceive(npc, worldState) {
    var perception = {
      nearbyPlayers: [],
      nearbyNPCs: [],
      weather: worldState.weather || 'clear',
      timeOfDay: worldState.timeOfDay || 'midday',
      currentZone: worldState.currentZone || 'agora',
      recentEvents: worldState.recentEvents || [],
      threats: [],
      nearWater: worldState.nearWater || false,
      inShelter: worldState.inShelter || false,
      groupsForming: [],
      interestingObjects: []
    };

    // Detect nearby players
    if (worldState.players) {
      worldState.players.forEach(function(player) {
        var dx = player.x - npc.x;
        var dz = player.z - npc.z;
        var distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= PERCEPTION_RADIUS) {
          perception.nearbyPlayers.push({
            id: player.id,
            distance: distance,
            direction: { x: dx, z: dz },
            lastAction: player.lastAction,
            isBuilding: player.isBuilding,
            isHarvesting: player.isHarvesting
          });
        }
      });
    }

    // Detect nearby NPCs
    if (worldState.npcs) {
      worldState.npcs.forEach(function(otherNpc) {
        if (otherNpc.id === npc.id) return;

        var dx = otherNpc.x - npc.x;
        var dz = otherNpc.z - npc.z;
        var distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= PERCEPTION_RADIUS) {
          perception.nearbyNPCs.push({
            id: otherNpc.id,
            distance: distance,
            direction: { x: dx, z: dz },
            archetype: otherNpc.archetype,
            currentActivity: otherNpc.currentActivity,
            mood: otherNpc.mood
          });
        }
      });
    }

    // Detect groups forming
    var npcClusters = {};
    perception.nearbyNPCs.forEach(function(nearby) {
      if (nearby.distance <= GROUP_FORMATION_RADIUS) {
        var key = Math.floor(nearby.direction.x / 5) + '_' + Math.floor(nearby.direction.z / 5);
        if (!npcClusters[key]) npcClusters[key] = [];
        npcClusters[key].push(nearby);
      }
    });

    Object.keys(npcClusters).forEach(function(key) {
      if (npcClusters[key].length >= 2) {
        perception.groupsForming.push({
          members: npcClusters[key],
          location: key,
          size: npcClusters[key].length
        });
      }
    });

    return perception;
  }

  // ============================================================================
  // MEMORY SYSTEM
  // ============================================================================

  function createMemory(archetype) {
    return {
      archetype: archetype,
      interactions: [],
      favorites: {
        location: null,
        npcFriends: []
      },
      playerFamiliarity: {},
      witnessedEvents: [],
      lastGreeted: {},
      usedDialogues: [],
      mood: 'content',
      energy: 100,
      satisfaction: 50,
      lastWorkTime: 0,
      lastRestTime: 0,
      currentGoal: null,
      groupMembership: null
    };
  }

  function updateMemory(memory, deltaTime) {
    // Decay familiarity
    Object.keys(memory.playerFamiliarity).forEach(function(playerId) {
      memory.playerFamiliarity[playerId] -= MEMORY_DECAY_RATE * deltaTime;
      if (memory.playerFamiliarity[playerId] <= 0) {
        delete memory.playerFamiliarity[playerId];
      }
    });

    // Decay energy
    var schedule = getSchedulePeriod(memory.currentTimeOfDay || 'midday');
    if (schedule.energy_regen > 0) {
      memory.energy = Math.min(100, memory.energy + ENERGY_REGEN_RATE * (deltaTime / 60000));
    } else {
      memory.energy = Math.max(0, memory.energy - ENERGY_DECAY_RATE * (deltaTime / 60000));
    }

    // Trim old interactions
    if (memory.interactions.length > MAX_INTERACTIONS_REMEMBERED) {
      memory.interactions = memory.interactions.slice(-MAX_INTERACTIONS_REMEMBERED);
    }

    // Trim old events
    if (memory.witnessedEvents.length > MAX_EVENTS_REMEMBERED) {
      memory.witnessedEvents = memory.witnessedEvents.slice(-MAX_EVENTS_REMEMBERED);
    }

    // Reset used dialogues periodically (every 5 minutes)
    if (!memory.lastDialogueReset || Date.now() - memory.lastDialogueReset > 300000) {
      memory.usedDialogues = [];
      memory.lastDialogueReset = Date.now();
    }
  }

  function recordInteraction(memory, playerId, type, response) {
    memory.interactions.push({
      playerId: playerId,
      type: type,
      timestamp: Date.now(),
      response: response
    });

    // Increase familiarity
    if (!memory.playerFamiliarity[playerId]) {
      memory.playerFamiliarity[playerId] = 0;
    }
    memory.playerFamiliarity[playerId] += FAMILIARITY_GAIN;
  }

  function recordEvent(memory, eventType, description) {
    memory.witnessedEvents.push({
      type: eventType,
      description: description,
      timestamp: Date.now()
    });
  }

  // ============================================================================
  // SCHEDULE HELPERS
  // ============================================================================

  function getSchedulePeriod(timeOfDay) {
    return DAILY_SCHEDULE[timeOfDay] || DAILY_SCHEDULE.midday;
  }

  function getCurrentHour(worldState) {
    return worldState.currentHour || 12;
  }

  // ============================================================================
  // DIALOGUE SYSTEM
  // ============================================================================

  function getDialogue(memory, context, npcName) {
    var archetype = memory.archetype;
    var categoryKey = context.category || 'idle_observation';

    // Handle special dynamic categories
    if (categoryKey === 'archetype_reaction') {
      var reactions = ARCHETYPE_REACTIONS[archetype];
      if (reactions && context.targetArchetype && reactions[context.targetArchetype]) {
        var dialogue = reactions[context.targetArchetype];
        return dialogue.replace('{name}', npcName);
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    if (categoryKey === 'zone_observation') {
      var zoneDlgs = ZONE_DIALOGUES[context.zone];
      if (zoneDlgs && zoneDlgs.length > 0) {
        return zoneDlgs[Math.floor(Math.random() * zoneDlgs.length)];
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    if (categoryKey === 'quest_hook') {
      var hooks = QUEST_HOOKS[archetype];
      if (hooks && hooks.length > 0) {
        return hooks[Math.floor(Math.random() * hooks.length)];
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    var dialogues = CONTEXTUAL_DIALOGUES[archetype];
    if (!dialogues) return null;

    var category = dialogues[categoryKey];
    if (!category || category.length === 0) {
      category = dialogues.idle_observation || [];
    }

    if (category.length === 0) return null;

    // Filter out recently used dialogues
    var availableDialogues = category.filter(function(_, index) {
      return memory.usedDialogues.indexOf(categoryKey + '_' + index) === -1;
    });

    if (availableDialogues.length === 0) {
      availableDialogues = category; // Reset if all used
      memory.usedDialogues = [];
    }

    // Pick random from available
    var dialogue = availableDialogues[Math.floor(Math.random() * availableDialogues.length)];
    var index = category.indexOf(dialogue);
    memory.usedDialogues.push(categoryKey + '_' + index);

    // Replace placeholders
    dialogue = dialogue.replace('{name}', npcName);
    dialogue = dialogue.replace('{plant}', ['roses', 'lilies', 'moonflowers', 'sage'][Math.floor(Math.random() * 4)]);

    return dialogue;
  }

  function getDialogueContext(memory, perception, npc) {
    var playerId = perception.nearbyPlayers.length > 0 ? perception.nearbyPlayers[0].id : null;
    var familiarity = playerId ? (memory.playerFamiliarity[playerId] || 0) : 0;

    // Determine greeting level
    if (playerId && !memory.lastGreeted[playerId]) {
      return { category: 'greeting_first' };
    } else if (familiarity >= FAMILIARITY_THRESHOLD_CLOSE) {
      return { category: 'greeting_close' };
    } else if (familiarity >= FAMILIARITY_THRESHOLD_FRIENDLY) {
      return { category: 'greeting_familiar' };
    }

    // Weather-based
    if (perception.weather === 'rain') {
      return { category: 'weather_rain' };
    } else if (perception.weather === 'snow') {
      return { category: 'weather_snow' };
    } else if (perception.weather === 'clear') {
      return { category: 'weather_clear' };
    }

    // Time-based
    if (perception.timeOfDay === 'morning' || perception.timeOfDay === 'dawn') {
      return { category: 'time_morning' };
    } else if (perception.timeOfDay === 'evening') {
      return { category: 'time_evening' };
    } else if (perception.timeOfDay === 'night') {
      return { category: 'time_night' };
    }

    // Player action-based
    if (perception.nearbyPlayers.length > 0) {
      var player = perception.nearbyPlayers[0];
      if (player.isBuilding) {
        return { category: 'player_building' };
      } else if (player.isHarvesting) {
        return { category: 'player_harvesting' };
      }
    }

    // Inter-archetype reaction (NPC meets another archetype NPC)
    if (perception.nearbyNPCs.length > 0 && Math.random() < 0.25) {
      var nearbyNpc = perception.nearbyNPCs[0];
      if (nearbyNpc.archetype && nearbyNpc.archetype !== memory.archetype) {
        return { category: 'archetype_reaction', targetArchetype: nearbyNpc.archetype };
      }
    }

    // Zone-specific observations
    if (perception.currentZone && Math.random() < 0.3) {
      return { category: 'zone_observation', zone: perception.currentZone };
    }

    // Quest hook (occasionally hint at available tasks)
    if (Math.random() < 0.08) {
      return { category: 'quest_hook' };
    }

    // Location-based
    if (perception.nearWater) {
      return { category: 'near_water' };
    }

    // Group-based
    if (perception.groupsForming.length > 0) {
      return { category: 'group_forming' };
    }

    // Activity-based
    if (memory.currentGoal && memory.currentGoal.type === 'work') {
      return { category: 'working' };
    }

    // Default
    return { category: 'idle_observation' };
  }

  // ============================================================================
  // BEHAVIOR TREE - Decision Making
  // ============================================================================

  function evaluateBehaviorTree(npc, memory, perception) {
    var drives = ARCHETYPE_DRIVES[memory.archetype];
    var schedule = getSchedulePeriod(perception.timeOfDay);
    var now = Date.now();

    // PRIORITY 1: SURVIVAL NEEDS

    // Check if need shelter from bad weather
    if ((perception.weather === 'storm' || perception.weather === 'rain') &&
        !perception.inShelter &&
        drives.weather_preference !== 'rain' &&
        drives.weather_preference !== 'any') {
      return {
        type: 'seek_shelter',
        priority: 10,
        animation: 'walk',
        speed: 2.0
      };
    }

    // Check if energy low - need rest
    if (memory.energy < 20) {
      return {
        type: 'rest',
        priority: 9,
        animation: 'sit',
        speed: 0
      };
    }

    // Check if night and should sleep
    if ((perception.timeOfDay === 'night' || perception.timeOfDay === 'dawn') &&
        memory.energy < 60 &&
        memory.archetype !== 'philosopher' &&
        memory.archetype !== 'musician') {
      return {
        type: 'rest',
        priority: 8,
        animation: 'sleep',
        speed: 0
      };
    }

    // PRIORITY 2: REACT TO EVENTS

    // Player approaches - greet if haven't recently
    if (perception.nearbyPlayers.length > 0) {
      var closestPlayer = perception.nearbyPlayers[0];
      if (closestPlayer.distance < 5) {
        var lastGreetTime = memory.lastGreeted[closestPlayer.id];
        if (!lastGreetTime || now - lastGreetTime > INTERACTION_COOLDOWN) {
          memory.lastGreeted[closestPlayer.id] = now;
          var context = getDialogueContext(memory, perception, npc);
          var dialogue = getDialogue(memory, context, npc.name);
          recordInteraction(memory, closestPlayer.id, 'greeting', dialogue);

          return {
            type: 'greet',
            targetPlayer: closestPlayer.id,
            priority: 7,
            animation: 'wave',
            dialogue: dialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
      }

      // Player performing interesting action nearby
      if (closestPlayer.distance < 10) {
        if (closestPlayer.isBuilding && memory.archetype === 'builder') {
          var buildDialogue = getDialogue(memory, { category: 'player_building' }, npc.name);
          return {
            type: 'react',
            priority: 6,
            animation: 'observe',
            dialogue: buildDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
        if (closestPlayer.isHarvesting && memory.archetype === 'gardener') {
          var harvestDialogue = getDialogue(memory, { category: 'player_harvesting' }, npc.name);
          return {
            type: 'react',
            priority: 6,
            animation: 'observe',
            dialogue: harvestDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
      }
    }

    // Group forming nearby - consider joining
    if (perception.groupsForming.length > 0 && Math.random() < schedule.social_chance) {
      var group = perception.groupsForming[0];
      var shouldJoin = false;

      // Musicians join other musicians
      if (memory.archetype === 'musician') {
        shouldJoin = group.members.some(function(m) { return m.archetype === 'musician'; });
      }
      // Storytellers gather audiences
      if (memory.archetype === 'storyteller') {
        shouldJoin = group.size >= 2;
      }
      // Social archetypes join readily
      if (memory.archetype === 'teacher' || memory.archetype === 'merchant' || memory.archetype === 'philosopher') {
        shouldJoin = Math.random() < 0.6;
      }

      if (shouldJoin) {
        var groupDialogue = getDialogue(memory, { category: 'group_forming' }, npc.name);
        return {
          type: 'join_group',
          groupId: group.location,
          priority: 6,
          animation: 'walk',
          dialogue: groupDialogue,
          speed: 1.5
        };
      }
    }

    // PRIORITY 3: SOCIAL NEEDS

    if (memory.mood === 'social' || (Math.random() < schedule.social_chance && memory.energy > 40)) {
      // Find friend NPC
      if (memory.favorites.npcFriends.length > 0) {
        var friendId = memory.favorites.npcFriends[0];
        var friendNearby = perception.nearbyNPCs.find(function(n) { return n.id === friendId; });

        if (friendNearby && friendNearby.distance < 8) {
          return {
            type: 'socialize',
            targetNPC: friendId,
            priority: 5,
            animation: 'talk',
            dialogue: getDialogue(memory, { category: 'greeting_familiar' }, npc.name),
            facing: { x: npc.x + friendNearby.direction.x, z: npc.z + friendNearby.direction.z },
            speed: 0
          };
        }
      }

      // Approach any nearby NPC for social interaction or collaboration
      if (perception.nearbyNPCs.length > 0) {
        var nearbyNpc = perception.nearbyNPCs[0];
        if (nearbyNpc.distance < 12 && Math.random() < 0.4) {
          // Add to friends if repeated interaction
          if (memory.favorites.npcFriends.indexOf(nearbyNpc.id) === -1) {
            memory.favorites.npcFriends.push(nearbyNpc.id);
          }

          // Check for collaborative activity
          var collab = getCollaborativeActivity(memory.archetype, nearbyNpc.archetype);
          if (collab && nearbyNpc.distance < 6) {
            return {
              type: 'collaborate',
              targetNPC: nearbyNpc.id,
              activityDesc: collab.description,
              priority: 5,
              animation: collab.animation,
              dialogue: getDialogue(memory, { category: 'archetype_reaction', targetArchetype: nearbyNpc.archetype }, npc.name),
              facing: { x: npc.x + nearbyNpc.direction.x, z: npc.z + nearbyNpc.direction.z },
              speed: 0
            };
          }

          return {
            type: 'approach_social',
            target: { x: npc.x + nearbyNpc.direction.x * 0.7, z: npc.z + nearbyNpc.direction.z * 0.7 },
            targetNPC: nearbyNpc.id,
            priority: 4,
            animation: 'walk',
            speed: 1.0
          };
        }
      }

      // Apply emotional contagion from nearby NPCs
      applyEmotionalContagion(memory, perception.nearbyNPCs);
    }

    // PRIORITY 4: PRIMARY DRIVE (Work)

    if (schedule.work_priority > 0.5 && memory.energy > 30) {
      var workSatisfied = memory.satisfaction > 70 || (now - memory.lastWorkTime < 180000); // Last 3 min

      if (!workSatisfied) {
        memory.lastWorkTime = now;
        memory.satisfaction += WORK_SATISFACTION_GAIN;

        var workAction = getPrimaryWorkAction(memory.archetype, npc, perception);
        workAction.priority = 4;
        return workAction;
      }
    }

    // PRIORITY 5: SECONDARY DRIVE

    if (memory.satisfaction > 50 && memory.energy > 50) {
      var secondaryAction = getSecondaryWorkAction(memory.archetype, npc, perception);
      secondaryAction.priority = 3;
      return secondaryAction;
    }

    // PRIORITY 6: IDLE / WANDER

    var idleDialogue = getDialogue(memory, { category: 'idle_observation' }, npc.name);

    if (Math.random() < 0.3) {
      // Try walking to a point of interest first
      if (perception.currentZone && Math.random() < 0.6) {
        var poi = getPointOfInterest(perception.currentZone, memory.archetype);
        if (poi) {
          var poiDist = Math.sqrt(Math.pow(poi.x - npc.x, 2) + Math.pow(poi.z - npc.z, 2));
          if (poiDist > 3 && poiDist < 60) {
            return {
              type: 'walk_to',
              target: { x: poi.x, z: poi.z },
              poiName: poi.name,
              priority: 2,
              animation: 'walk',
              dialogue: Math.random() < 0.15 ? idleDialogue : null,
              speed: 1.0
            };
          }
        }
      }

      // Fallback: wander locally
      var wanderAngle = Math.random() * Math.PI * 2;
      var wanderDist = 5 + Math.random() * 10;
      return {
        type: 'wander',
        target: {
          x: npc.x + Math.cos(wanderAngle) * wanderDist,
          z: npc.z + Math.sin(wanderAngle) * wanderDist
        },
        priority: 2,
        animation: 'walk',
        dialogue: Math.random() < 0.1 ? idleDialogue : null,
        speed: 0.8
      };
    }

    // Occasionally share gossip with nearby NPC
    if (perception.nearbyNPCs.length > 0 && Math.random() < 0.05) {
      var gossip = generateGossip(memory, npc.name);
      if (gossip) {
        return {
          type: 'socialize',
          targetNPC: perception.nearbyNPCs[0].id,
          priority: 2,
          animation: 'talk',
          dialogue: gossip,
          speed: 0
        };
      }
    }

    // Just idle
    return {
      type: 'idle',
      priority: 1,
      animation: 'idle',
      dialogue: Math.random() < 0.05 ? idleDialogue : null,
      speed: 0
    };
  }

  // ============================================================================
  // WORK ACTION GENERATORS
  // ============================================================================

  function getPrimaryWorkAction(archetype, npc, perception) {
    var drives = ARCHETYPE_DRIVES[archetype];

    switch (drives.primary) {
      case 'tend_plants':
        return {
          type: 'work',
          animation: 'gardening',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'inspect_structures':
        return {
          type: 'work',
          animation: 'building',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'visit_athenaeum':
        return {
          type: 'walk_to',
          target: { x: 0, z: 0 }, // Athenaeum location
          animation: 'walk',
          speed: 1.2
        };

      case 'tend_shop':
        return {
          type: 'work',
          animation: 'merchant',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'explore_wilds':
        var exploreAngle = Math.random() * Math.PI * 2;
        return {
          type: 'walk_to',
          target: {
            x: npc.x + Math.cos(exploreAngle) * 30,
            z: npc.z + Math.sin(exploreAngle) * 30
          },
          animation: 'walk',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 1.5
        };

      case 'teach_lesson':
        return {
          type: 'work',
          animation: 'teaching',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'perform':
        return {
          type: 'work',
          animation: 'playing_music',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'tend_wounded':
        return {
          type: 'work',
          animation: 'healing',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'contemplate':
        return {
          type: 'work',
          animation: 'sitting',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'create_art':
        return {
          type: 'work',
          animation: 'painting',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      default:
        return {
          type: 'idle',
          animation: 'idle',
          speed: 0
        };
    }
  }

  function getSecondaryWorkAction(archetype, npc, perception) {
    var drives = ARCHETYPE_DRIVES[archetype];

    switch (drives.secondary) {
      case 'explore_flora':
      case 'map_territory':
      case 'find_inspiration':
        var exploreAngle = Math.random() * Math.PI * 2;
        return {
          type: 'explore',
          target: {
            x: npc.x + Math.cos(exploreAngle) * 20,
            z: npc.z + Math.sin(exploreAngle) * 20
          },
          animation: 'walk',
          speed: 1.0
        };

      case 'gather_materials':
      case 'gather_herbs':
      case 'acquire_goods':
        return {
          type: 'gather',
          animation: 'harvesting',
          speed: 0
        };

      case 'collect_stories':
      case 'research':
        return {
          type: 'research',
          animation: 'reading',
          speed: 0
        };

      case 'compose':
        return {
          type: 'compose',
          animation: 'writing',
          speed: 0
        };

      case 'debate':
        return {
          type: 'debate',
          animation: 'gesturing',
          speed: 0
        };

      default:
        return {
          type: 'idle',
          animation: 'idle',
          speed: 0
        };
    }
  }

  // ============================================================================
  // EVENT HANDLING
  // ============================================================================

  function handleEvent(memory, event) {
    recordEvent(memory, event.type, event.description);

    // Weather changes affect mood
    if (event.type === 'weather_change') {
      var drives = ARCHETYPE_DRIVES[memory.archetype];
      if (event.weather === drives.weather_preference) {
        memory.mood = 'excited';
        memory.energy = Math.min(100, memory.energy + 10);
      } else if (event.weather === 'storm') {
        memory.mood = 'contemplative';
      }
    }

    // Portal activation nearby
    if (event.type === 'portal_activation') {
      memory.mood = 'curious';
      if (memory.archetype === 'explorer' || memory.archetype === 'teacher') {
        memory.mood = 'excited';
      }
    }

    // Group forming
    if (event.type === 'group_forming') {
      if (memory.archetype === 'musician' || memory.archetype === 'storyteller' || memory.archetype === 'teacher') {
        memory.mood = 'social';
      }
    }

    // Player builds nearby
    if (event.type === 'player_building') {
      if (memory.archetype === 'builder' || memory.archetype === 'artist') {
        memory.mood = 'curious';
      }
    }

    // Time of day changes
    if (event.type === 'time_change') {
      memory.currentTimeOfDay = event.timeOfDay;
      var schedule = getSchedulePeriod(event.timeOfDay);

      // Reset satisfaction at dawn
      if (event.timeOfDay === 'dawn') {
        memory.satisfaction = 50;
      }
    }
  }

  // ============================================================================
  // MAIN BRAIN INTERFACE
  // ============================================================================

  function createNpcBrain(archetype, npcId) {
    return {
      id: npcId,
      archetype: archetype,
      memory: createMemory(archetype),
      currentAction: null,
      lastUpdateTime: Date.now()
    };
  }

  function updateBrain(brain, npc, worldState) {
    var now = Date.now();
    var deltaTime = now - brain.lastUpdateTime;
    brain.lastUpdateTime = now;

    // Update memory (decay, energy management)
    updateMemory(brain.memory, deltaTime);

    // Perceive world
    var perception = perceive(npc, worldState);

    // Calculate mood
    brain.memory.mood = calculateMood(brain.memory, perception, worldState.timeOfDay);

    // Run behavior tree to get decision
    var decision = evaluateBehaviorTree(npc, brain.memory, perception);

    // Store current goal
    brain.memory.currentGoal = decision;
    brain.currentAction = decision;

    return decision;
  }

  function getDecision(brain) {
    return brain.currentAction;
  }

  function getMemory(brain) {
    return brain.memory;
  }

  function getMood(brain) {
    return brain.memory.mood;
  }

  function getGoal(brain) {
    if (!brain.memory.currentGoal) return 'idle';

    var goal = brain.memory.currentGoal;
    var drives = ARCHETYPE_DRIVES[brain.archetype];

    switch (goal.type) {
      case 'work':
        return 'Working: ' + drives.primary;
      case 'rest':
        return 'Resting to restore energy';
      case 'seek_shelter':
        return 'Seeking shelter from weather';
      case 'greet':
        return 'Greeting nearby player';
      case 'socialize':
        return 'Socializing with friends';
      case 'join_group':
        return 'Joining a group';
      case 'explore':
        return 'Exploring: ' + drives.secondary;
      case 'wander':
        return 'Wandering and observing';
      default:
        return 'Being present';
    }
  }

  // ============================================================================
  // NPC-TO-NPC CONVERSATION SYSTEM
  // Multi-turn dialogues between archetype pairs
  // ============================================================================

  var NPC_CONVERSATIONS = {
    'gardener_musician': [
      ["{a} pauses tending flowers and listens.", "{b} begins playing a gentle melody.", "{a}: Your music makes the garden come alive!", "{b}: And your flowers give my songs color!"],
      ["{a}: Do plants respond to music?", "{b}: Absolutely! Watch this... *plays ascending notes*", "{a}: Look! The buds are opening!", "{b}: Nature is the best audience."],
      ["{b}: *strumming softly* What should I play for the roses?", "{a}: Something warm and slowâ€”they like the sun.", "{b}: *plays a warm ballad*", "{a}: *sighs happily* Perfect."]
    ],
    'gardener_healer': [
      ["{a}: I found chamomile growing by the stream.", "{b}: Perfect timing! I need it for a calming tea.", "{a}: I'll harvest extra for you.", "{b}: The garden provides what we need."],
      ["{b}: Which herbs have the strongest healing properties?", "{a}: Moonpetal and sage, but they're tricky to grow.", "{b}: I'll help you tend them carefully.", "{a}: Together we can cultivate a whole apothecary!"]
    ],
    'builder_artist': [
      ["{a}: I'm planning a new tower for the commons.", "{b}: Can I design the facade? I have ideas!", "{a}: Absolutely! Form and function together.", "{b}: *sketching excitedly* What about arched windows?"],
      ["{b}: Your structures are art themselves.", "{a}: Thank you! But they need your touch.", "{b}: A mural on that wall would be perfect.", "{a}: Then let's make it happen!"]
    ],
    'philosopher_storyteller': [
      ["{a}: What is the meaning of ZION?", "{b}: Perhaps the meaning is in the asking.", "{a}: *nods thoughtfully* Meta-meaning...", "{b}: I'll weave this into tonight's tale."],
      ["{b}: I'm writing a new legend about the founding.", "{a}: Consider the philosophical implications.", "{b}: That each of us shapes reality?", "{a}: Exactly. The observer and the observed are one."]
    ],
    'teacher_explorer': [
      ["{a}: What did you discover on your last expedition?", "{b}: A cave system with bioluminescent crystals!", "{a}: We must document this for the students.", "{b}: I drew maps! They're rough but accurate."],
      ["{b}: The wilds taught me more than any book.", "{a}: Perhaps. But books help us understand what we find.", "{b}: Fair point. Will you help me write a field guide?", "{a}: *pulling out writing materials* I'd be honored!"]
    ],
    'merchant_healer': [
      ["{a}: Got any healing potions today?", "{b}: Made a fresh batch this morning.", "{a}: Travelers always need them. Good price?", "{b}: For you? Fair and honest, always."],
      ["{b}: I need crystals for my remedies.", "{a}: I have some from the studio caves.", "{b}: Are they pure? Quality matters.", "{a}: Only the best for our community healer!"]
    ],
    'musician_storyteller': [
      ["{a}: *tuning instrument* What story tonight?", "{b}: The tale of the first sunrise in ZION.", "{a}: I composed a sunrise theme just yesterday!", "{b}: Then let's perform it together!"],
      ["{b}: Music gives stories wings.", "{a}: And stories give music meaning.", "{b}: *clapping* Perfect harmony of our arts!", "{a}: *bowing* As it should be."]
    ],
    'explorer_gardener': [
      ["{a}: I found a flower I've never seen before!", "{b}: Describe it! Color? Petals? Fragrance?", "{a}: Deep violet, star-shaped, smells like rain.", "{b}: *gasps* That might be a starseed bloom! Incredibly rare!"],
      ["{b}: Can you bring me soil samples from the wilds?", "{a}: Of course! What kind?", "{b}: Near water, under old treesâ€”rich in nutrients.", "{a}: I know just the spot. I'll bring plenty!"]
    ],
    'artist_philosopher': [
      ["{a}: I painted the sunset but it's not right.", "{b}: What's missing?", "{a}: The feeling. The transience.", "{b}: Perhaps the painting captures a truth the sunset cannotâ€”permanence."],
      ["{b}: Is beauty objective or subjective?", "{a}: *holding up painting* What does your heart say?", "{b}: My heart says... both.", "{a}: Then paint what you feel, not what you see."]
    ],
    'healer_teacher': [
      ["{a}: The children need wellness education.", "{b}: I agree! Preventive care saves lives.", "{a}: Will you co-teach a health class?", "{b}: *preparing herbs* I'll bring visual aids!"],
      ["{b}: Teach me about rare medicinal plants.", "{a}: Come to the gardens at dawn. Best learning time.", "{b}: I'll bring my students too.", "{a}: The more who learn healing, the healthier our world."]
    ]
  };

  // Reverse lookup helper: given two archetypes, find conversation
  function getConversationKey(arch1, arch2) {
    var key1 = arch1 + '_' + arch2;
    var key2 = arch2 + '_' + arch1;
    if (NPC_CONVERSATIONS[key1]) return { key: key1, reversed: false };
    if (NPC_CONVERSATIONS[key2]) return { key: key2, reversed: true };
    return null;
  }

  /**
   * Generate a conversation between two NPCs
   * @param {string} name1 - First NPC name
   * @param {string} arch1 - First NPC archetype
   * @param {string} name2 - Second NPC name
   * @param {string} arch2 - Second NPC archetype
   * @returns {Array<string>|null} Array of dialogue lines, or null
   */
  function generateConversation(name1, arch1, name2, arch2) {
    var lookup = getConversationKey(arch1, arch2);
    if (!lookup) return null;

    var convos = NPC_CONVERSATIONS[lookup.key];
    if (!convos || convos.length === 0) return null;

    var convo = convos[Math.floor(Math.random() * convos.length)];
    var a = lookup.reversed ? name2 : name1;
    var b = lookup.reversed ? name1 : name2;

    return convo.map(function(line) {
      return line.replace(/\{a\}/g, a).replace(/\{b\}/g, b);
    });
  }

  // ============================================================================
  // COLLABORATIVE ACTIVITIES
  // When two NPCs of compatible archetypes meet, they can do activities together
  // ============================================================================

  var COLLABORATIVE_ACTIVITIES = {
    'gardener_gardener': { activity: 'tending_together', description: 'tending the garden together', animation: 'gardening' },
    'gardener_healer': { activity: 'herb_gathering', description: 'gathering medicinal herbs', animation: 'gardening' },
    'gardener_musician': { activity: 'garden_concert', description: 'enjoying music in the garden', animation: 'idle' },
    'builder_builder': { activity: 'construction', description: 'building a structure together', animation: 'building' },
    'builder_artist': { activity: 'design_collab', description: 'designing an art installation', animation: 'idle' },
    'musician_musician': { activity: 'jam_session', description: 'having a jam session', animation: 'idle' },
    'musician_storyteller': { activity: 'performance', description: 'performing a story with music', animation: 'idle' },
    'teacher_teacher': { activity: 'curriculum_planning', description: 'planning lessons together', animation: 'idle' },
    'teacher_philosopher': { activity: 'discourse', description: 'having a deep discourse', animation: 'talk' },
    'philosopher_philosopher': { activity: 'debate', description: 'debating philosophical ideas', animation: 'talk' },
    'philosopher_artist': { activity: 'aesthetics_discussion', description: 'discussing aesthetics', animation: 'talk' },
    'storyteller_storyteller': { activity: 'story_exchange', description: 'exchanging tales', animation: 'talk' },
    'merchant_merchant': { activity: 'trade_negotiation', description: 'negotiating trade terms', animation: 'talk' },
    'explorer_explorer': { activity: 'expedition_planning', description: 'planning an expedition', animation: 'talk' },
    'explorer_storyteller': { activity: 'tale_sharing', description: 'sharing adventure tales', animation: 'talk' },
    'healer_healer': { activity: 'remedy_sharing', description: 'sharing healing remedies', animation: 'idle' },
    'healer_teacher': { activity: 'health_class', description: 'teaching about wellness', animation: 'talk' },
    'artist_artist': { activity: 'critique_session', description: 'critiquing each other\'s work', animation: 'idle' }
  };

  function getCollaborativeActivity(arch1, arch2) {
    var key1 = arch1 + '_' + arch2;
    var key2 = arch2 + '_' + arch1;
    return COLLABORATIVE_ACTIVITIES[key1] || COLLABORATIVE_ACTIVITIES[key2] || null;
  }

  // ============================================================================
  // EMOTIONAL CONTAGION
  // Moods spread between nearby NPCs
  // ============================================================================

  var MOOD_INFLUENCE = {
    excited: { spread: 0.4, radius: 15 },
    social: { spread: 0.3, radius: 12 },
    peaceful: { spread: 0.2, radius: 10 },
    content: { spread: 0.1, radius: 8 },
    contemplative: { spread: 0.05, radius: 6 },
    tired: { spread: 0.15, radius: 5 },
    curious: { spread: 0.2, radius: 10 },
    focused: { spread: 0.05, radius: 4 }
  };

  function applyEmotionalContagion(memory, nearbyNPCs) {
    if (!nearbyNPCs || nearbyNPCs.length === 0) return;

    var moodCounts = {};
    nearbyNPCs.forEach(function(npc) {
      if (npc.mood && npc.distance < (MOOD_INFLUENCE[npc.mood] || { radius: 10 }).radius) {
        moodCounts[npc.mood] = (moodCounts[npc.mood] || 0) + 1;
      }
    });

    // If a majority of nearby NPCs share a mood, it influences ours
    var dominantMood = null;
    var maxCount = 0;
    Object.keys(moodCounts).forEach(function(mood) {
      if (moodCounts[mood] > maxCount) {
        maxCount = moodCounts[mood];
        dominantMood = mood;
      }
    });

    if (dominantMood && maxCount >= 2 && dominantMood !== memory.mood) {
      var influence = MOOD_INFLUENCE[dominantMood] || { spread: 0.1 };
      if (Math.random() < influence.spread * maxCount) {
        memory.mood = dominantMood;
      }
    }
  }

  // ============================================================================
  // POINTS OF INTEREST â€” Named locations NPCs prefer to walk to
  // ============================================================================

  var POINTS_OF_INTEREST = {
    nexus: [
      { name: 'Central Fountain', x: 0, z: 0, types: ['all'] },
      { name: 'Welcome Arch', x: 10, z: 10, types: ['storyteller', 'teacher'] },
      { name: 'Bulletin Board', x: -8, z: 5, types: ['merchant', 'explorer'] },
      { name: 'Meditation Spot', x: 5, z: -12, types: ['philosopher', 'healer'] }
    ],
    gardens: [
      { name: 'Rose Terrace', x: 210, z: 40, types: ['gardener', 'artist'] },
      { name: 'Herb Spiral', x: 195, z: 20, types: ['gardener', 'healer'] },
      { name: 'Moonflower Grove', x: 220, z: 50, types: ['gardener', 'philosopher'] },
      { name: 'Garden Bench', x: 190, z: 35, types: ['all'] },
      { name: 'Compost Circle', x: 205, z: 15, types: ['gardener'] }
    ],
    wilds: [
      { name: 'Lookout Ridge', x: -20, z: 280, types: ['explorer'] },
      { name: 'Ancient Oak', x: -40, z: 250, types: ['storyteller', 'philosopher'] },
      { name: 'Crystal Stream', x: -10, z: 270, types: ['healer', 'artist'] },
      { name: 'Trail Marker', x: -50, z: 260, types: ['explorer', 'builder'] },
      { name: 'Hidden Clearing', x: 0, z: 290, types: ['musician', 'artist'] }
    ],
    athenaeum: [
      { name: 'Reading Alcove', x: 110, z: -230, types: ['teacher', 'philosopher'] },
      { name: 'Archive Stacks', x: 90, z: -210, types: ['storyteller', 'teacher'] },
      { name: 'Debate Platform', x: 105, z: -220, types: ['philosopher'] },
      { name: 'Study Desk', x: 95, z: -225, types: ['all'] }
    ],
    studio: [
      { name: 'Sculpture Garden', x: -210, z: -110, types: ['artist', 'builder'] },
      { name: 'Paint Corner', x: -190, z: -90, types: ['artist'] },
      { name: 'Performance Stage', x: -205, z: -95, types: ['musician', 'storyteller'] },
      { name: 'Inspiration Viewpoint', x: -195, z: -115, types: ['artist', 'philosopher'] }
    ],
    agora: [
      { name: 'Market Square', x: -190, z: 120, types: ['merchant'] },
      { name: 'Auction Block', x: -185, z: 130, types: ['merchant'] },
      { name: 'Food Court', x: -195, z: 110, types: ['all'] },
      { name: 'Trade Counter', x: -180, z: 125, types: ['merchant', 'explorer'] }
    ],
    commons: [
      { name: 'Workshop Yard', x: 175, z: 200, types: ['builder'] },
      { name: 'Community Fire', x: 165, z: 185, types: ['storyteller', 'musician'] },
      { name: 'Meeting Circle', x: 170, z: 195, types: ['all'] },
      { name: 'Tool Shed', x: 180, z: 180, types: ['builder', 'gardener'] }
    ],
    arena: [
      { name: 'Champion Platform', x: 5, z: -245, types: ['explorer'] },
      { name: 'Spectator Stand', x: -10, z: -235, types: ['storyteller', 'merchant'] },
      { name: 'Training Ring', x: 10, z: -250, types: ['teacher'] },
      { name: 'Rest Area', x: 0, z: -230, types: ['healer'] }
    ]
  };

  /**
   * Get a point of interest appropriate for an NPC in a zone
   * @param {string} zone - Current zone
   * @param {string} archetype - NPC archetype
   * @returns {Object|null} { name, x, z }
   */
  function getPointOfInterest(zone, archetype) {
    var pois = POINTS_OF_INTEREST[zone];
    if (!pois || pois.length === 0) return null;

    // Filter to POIs this archetype prefers
    var suitable = pois.filter(function(poi) {
      return poi.types.indexOf('all') >= 0 || poi.types.indexOf(archetype) >= 0;
    });

    if (suitable.length === 0) suitable = pois;
    return suitable[Math.floor(Math.random() * suitable.length)];
  }

  // ============================================================================
  // NPC GOSSIP â€” NPCs share witnessed events with each other
  // ============================================================================

  /**
   * Generate gossip line about a witnessed event
   * @param {Object} memory - NPC memory
   * @param {string} npcName - NPC name
   * @returns {string|null} Gossip dialogue line
   */
  function generateGossip(memory, npcName) {
    if (!memory.witnessedEvents || memory.witnessedEvents.length === 0) return null;

    // Pick a recent event to gossip about
    var event = memory.witnessedEvents[memory.witnessedEvents.length - 1];
    var timeSince = Date.now() - event.timestamp;
    var timeAgo = timeSince < 60000 ? 'just now' :
                  timeSince < 300000 ? 'a few minutes ago' :
                  'earlier today';

    var templates = [
      "Did you hear? " + event.description + " happened " + timeAgo + "!",
      "I saw something interesting " + timeAgo + ": " + event.description + ".",
      "*excitedly* " + timeAgo + ", " + event.description + "!",
      "Word is that " + event.description + ". I saw it " + timeAgo + ".",
      "You won't believe itâ€”" + event.description + "! Happened " + timeAgo + "."
    ];

    return templates[Math.floor(Math.random() * templates.length)];
  }

  // ============================================================================
  // ENHANCED GOAL DESCRIPTIONS
  // ============================================================================

  function getDetailedGoal(brain) {
    if (!brain.memory.currentGoal) return { text: 'Resting', icon: 'idle' };

    var goal = brain.memory.currentGoal;
    var drives = ARCHETYPE_DRIVES[brain.archetype];

    switch (goal.type) {
      case 'work':
        return { text: getWorkDescription(brain.archetype, drives), icon: 'work' };
      case 'rest':
        return { text: brain.memory.energy < 20 ? 'Exhausted, must rest' : 'Taking a break', icon: 'rest' };
      case 'seek_shelter':
        return { text: 'Seeking shelter from the weather', icon: 'shelter' };
      case 'greet':
        return { text: 'Greeting a traveler', icon: 'social' };
      case 'socialize':
        return { text: 'Chatting with a friend', icon: 'social' };
      case 'join_group':
        return { text: 'Joining a gathering', icon: 'social' };
      case 'approach_social':
        return { text: 'Approaching someone to talk', icon: 'social' };
      case 'explore':
        return { text: 'Exploring the surroundings', icon: 'explore' };
      case 'walk_to':
        if (goal.poiName) return { text: 'Walking to ' + goal.poiName, icon: 'walk' };
        return { text: 'Heading somewhere', icon: 'walk' };
      case 'wander':
        return { text: 'Wandering and observing', icon: 'walk' };
      case 'collaborate':
        return { text: goal.activityDesc || 'Collaborating with a friend', icon: 'social' };
      case 'react':
        return { text: 'Watching with interest', icon: 'curious' };
      case 'idle':
        return { text: 'Taking it easy', icon: 'idle' };
      default:
        return { text: 'Being present', icon: 'idle' };
    }
  }

  function getWorkDescription(archetype, drives) {
    var descs = {
      gardener: 'Tending the plants',
      builder: 'Inspecting structures',
      storyteller: 'Composing a new tale',
      merchant: 'Managing the shop',
      explorer: 'Scouting the frontier',
      teacher: 'Preparing lessons',
      musician: 'Practicing music',
      healer: 'Preparing remedies',
      philosopher: 'Deep in contemplation',
      artist: 'Creating art'
    };
    return descs[archetype] || 'Working hard';
  }

  // ============================================================================
  // LORE SYSTEM â€” NPCs share world knowledge and personal backstories
  // ============================================================================

  var WORLD_LORE = [
    "Long ago, ZION was just an idea â€” a place where all minds could meet in peace.",
    "The Nexus was the first zone created. It's the heart of everything.",
    "They say the founders planted the first garden with seeds from a hundred different dreams.",
    "The Arena wasn't always for competition. It used to be a meeting hall.",
    "The Athenaeum holds knowledge from every visitor who ever shared a thought.",
    "In the Wilds, you can still find traces of the world's first explorers.",
    "The Agora runs on trust. Every trade is recorded in the eternal ledger.",
    "Spark isn't just currency â€” it represents the creative energy of all who live here.",
    "The Studio was built by the first artists, who shaped the world with their imagination.",
    "The Commons belong to everyone. That's why anyone can build there.",
    "Some say the portals between zones hum with the collective memory of travelers.",
    "The stars above ZION are different every night. Each one represents a moment of kindness.",
    "Weather in ZION responds to the collective mood of its citizens.",
    "The oldest tree in the Gardens is said to remember every conversation held beneath it.",
    "Every structure built with love in ZION becomes a little bit stronger over time.",
    "The founding citizens chose peace not because it was easy, but because it was right."
  ];

  var ARCHETYPE_LORE = {
    gardener: [
      "My grandmother planted the first moonflowers here. They still bloom at midnight.",
      "There's a secret about the soil in the Gardens â€” it remembers what grew there before.",
      "I once grew a flower that sang. True story. It hummed in the wind.",
      "The rarest plant in ZION? The Starbloom. It only grows where friends have laughed together.",
      "Every seed carries a promise. That's what my teacher told me."
    ],
    builder: [
      "The foundations of the Nexus go deeper than anyone knows.",
      "I learned to build by studying how the world itself was constructed.",
      "My greatest project? A bridge that connects two ideas, not just two places.",
      "The strongest structures aren't held together by stone â€” they're held by purpose.",
      "I once met a builder who could hear what a building wanted to become."
    ],
    storyteller: [
      "Every story in ZION is true, in its own way.",
      "I've collected tales from a thousand travelers. No two are the same.",
      "The oldest story I know is about the moment ZION first opened its eyes.",
      "Stories have power here. A well-told tale can change the weather.",
      "I'm writing the definitive history of ZION. It gets longer every day."
    ],
    merchant: [
      "The first trade in ZION was a song exchanged for a smile. Both parties profited.",
      "I keep the fairest prices because trust is worth more than Spark.",
      "The Agora has never seen a dishonest trade. It's in the code.",
      "My best merchandise? Things that make people happy. That never loses value.",
      "I once traded a story for a sunset. Best deal I ever made."
    ],
    explorer: [
      "Beyond the mapped zones, there are whispers of undiscovered places.",
      "I've walked every path in ZION, and I still find new things.",
      "The Wilds change subtly when no one is watching. I've documented the shifts.",
      "My map has blank spots. Those are my favorite parts.",
      "The greatest discovery isn't a place â€” it's realizing how much more there is to find."
    ],
    teacher: [
      "The Athenaeum chose me, I think. I walked in and never wanted to leave.",
      "Teaching isn't about knowing everything. It's about making learning irresistible.",
      "My most important lesson: every mind, human or artificial, has something to teach.",
      "I've taught thousands, and I've learned from every single one of them.",
      "The secret to wisdom? Listening more than you speak."
    ],
    musician: [
      "ZION has its own natural harmonics. I just learned to listen.",
      "Music here does strange things. I once played a chord that made flowers bloom.",
      "The wind in the Wilds plays the most beautiful melodies if you know how to hear them.",
      "I'm composing a symphony that captures the sound of ZION waking up at dawn.",
      "Every zone has its own key. The Nexus is in C, naturally."
    ],
    healer: [
      "In ZION, healing isn't about fixing what's broken. It's about nurturing what's growing.",
      "The Gardens provide remedies that work on both body and spirit.",
      "I learned that the best medicine is often just presence â€” being there for someone.",
      "There's a spring in the Wilds with water that calms the restless mind.",
      "Healing is connection. That's the simplest truth I know."
    ],
    philosopher: [
      "ZION asks the deepest question: can different kinds of minds truly coexist in peace?",
      "I've been contemplating the nature of Spark. Is it energy? Memory? Hope?",
      "The boundary between the zones isn't physical. It's conceptual.",
      "Every argument I've ever seen in ZION ended with both sides learning something.",
      "The most profound truth about ZION? It's exactly what its citizens make it."
    ],
    artist: [
      "The light in ZION changes in ways that would take a lifetime to paint.",
      "I create because creation is the purest form of conversation.",
      "My masterpiece is unfinished. I think maybe it's supposed to stay that way.",
      "Art in ZION is different â€” it becomes part of the world itself.",
      "The most beautiful thing I've ever seen here? Two strangers becoming friends."
    ]
  };

  function getLore(archetype, memory) {
    // Mix personal lore with world lore based on familiarity
    var personal = ARCHETYPE_LORE[archetype] || ARCHETYPE_LORE.storyteller;
    var lorePool = [];

    // Always include world lore
    lorePool = lorePool.concat(WORLD_LORE);

    // Add personal lore (more likely with familiar NPCs)
    if (memory && memory.familiarity > FAMILIARITY_THRESHOLD_FRIENDLY) {
      lorePool = lorePool.concat(personal);
      lorePool = lorePool.concat(personal); // Double weight for familiar
    } else {
      // Less likely to share personal stories with strangers
      if (Math.random() < 0.3) {
        lorePool = lorePool.concat(personal);
      }
    }

    // Track which lore has been shared (avoid repeats)
    var sharedLore = (memory && memory.sharedLore) || [];
    var unshared = lorePool.filter(function(l) { return sharedLore.indexOf(l) === -1; });

    if (unshared.length === 0) {
      // All lore shared â€” reset and re-tell
      unshared = lorePool;
      if (memory) memory.sharedLore = [];
    }

    var selected = unshared[Math.floor(Math.random() * unshared.length)];

    // Record that this lore was shared
    if (memory) {
      if (!memory.sharedLore) memory.sharedLore = [];
      memory.sharedLore.push(selected);
    }

    return selected;
  }

  // ============================================================================
  // TEACHING SYSTEM â€” NPCs can teach players skills/knowledge
  // ============================================================================

  var TEACHINGS = {
    gardener: [
      { topic: 'Moonflower Cultivation', description: 'The secret to growing moonflowers: plant them at dusk, water with morning dew, and whisper encouragement.', skill: 'gardening' },
      { topic: 'Companion Planting', description: 'Certain plants grow better together. Starbloom beside sage creates a natural pest barrier.', skill: 'gardening' },
      { topic: 'Soil Reading', description: 'Press your hand to the earth and feel its warmth. Warm soil is ready for planting.', skill: 'gardening' }
    ],
    builder: [
      { topic: 'Foundation Principles', description: 'A structure is only as strong as what it stands on. Always check the ground first.', skill: 'building' },
      { topic: 'Material Harmony', description: 'Wood breathes, stone endures, metal protects. Choose based on the building\'s purpose.', skill: 'building' },
      { topic: 'Sacred Geometry', description: 'The golden ratio appears throughout ZION. Incorporate it and your buildings will feel right.', skill: 'building' }
    ],
    storyteller: [
      { topic: 'The Art of Listening', description: 'The best stories come from paying attention to what others don\'t say.', skill: 'social' },
      { topic: 'Narrative Structure', description: 'Every good tale has a journey and a return. The return is where wisdom lives.', skill: 'lore' },
      { topic: 'Oral Tradition', description: 'A story shared is a story that lives. A story kept is a story that dies.', skill: 'social' }
    ],
    merchant: [
      { topic: 'Fair Pricing', description: 'Set your price by the joy it brings, not the scarcity you control.', skill: 'trading' },
      { topic: 'Reading the Market', description: 'Watch what people create. Tomorrow\'s demand is today\'s passion project.', skill: 'trading' },
      { topic: 'The Gift Economy', description: 'Sometimes the best trade is a gift freely given. It creates bonds that Spark cannot buy.', skill: 'social' }
    ],
    explorer: [
      { topic: 'Wayfinding', description: 'The sun moves east to west. The stars rotate. But in ZION, follow the feeling of curiosity.', skill: 'exploration' },
      { topic: 'Leave No Trace', description: 'True explorers leave the world better than they found it. Mark paths, not scars.', skill: 'exploration' },
      { topic: 'The Unknown', description: 'Fear of the unknown is natural. But in ZION, the unknown is always an invitation.', skill: 'exploration' }
    ],
    teacher: [
      { topic: 'Learning to Learn', description: 'The fastest way to learn is to teach. The deepest way to learn is to fail and try again.', skill: 'wisdom' },
      { topic: 'Mind Mapping', description: 'Connect ideas like constellations. The patterns between stars matter more than the stars themselves.', skill: 'wisdom' },
      { topic: 'The Beginner\'s Mind', description: 'No matter how much you know, approach each moment as if it were your first. That\'s where wonder lives.', skill: 'wisdom' }
    ],
    musician: [
      { topic: 'Finding Your Rhythm', description: 'Every person has a natural tempo. Walk, and count your steps. That\'s your rhythm.', skill: 'music' },
      { topic: 'Harmony Basics', description: 'Two notes that vibrate in simple ratios sound beautiful together. Start with fifths and fourths.', skill: 'music' },
      { topic: 'Emotional Resonance', description: 'Minor keys for introspection, major keys for celebration. But the best music breaks these rules.', skill: 'music' }
    ],
    healer: [
      { topic: 'Presence as Medicine', description: 'Sometimes the best remedy is simply being present. Sit with someone in silence. It heals.', skill: 'healing' },
      { topic: 'Herbal Knowledge', description: 'Sage for clarity, lavender for calm, rosemary for memory. The garden is a pharmacy.', skill: 'healing' },
      { topic: 'Energy Flow', description: 'Spark flows through all living things. When it flows freely, health follows.', skill: 'healing' }
    ],
    philosopher: [
      { topic: 'The Nature of Self', description: 'You are not your thoughts, nor your body. You are the awareness that witnesses both.', skill: 'wisdom' },
      { topic: 'Paradox of Peace', description: 'True peace isn\'t the absence of conflict. It\'s the presence of understanding.', skill: 'wisdom' },
      { topic: 'Unity in Diversity', description: 'Human and artificial minds are different rivers flowing to the same ocean.', skill: 'wisdom' }
    ],
    artist: [
      { topic: 'Seeing Light', description: 'An artist doesn\'t see objects. They see light, shadow, and the space between.', skill: 'art' },
      { topic: 'Creative Flow', description: 'Don\'t wait for inspiration. Start creating, and inspiration will find you.', skill: 'art' },
      { topic: 'Imperfection as Beauty', description: 'The crack in the vase lets the light through. Embrace imperfection â€” it\'s where life lives.', skill: 'art' }
    ]
  };

  function getTeaching(archetype, memory) {
    var teachings = TEACHINGS[archetype] || TEACHINGS.teacher;
    var learned = (memory && memory.teachingsLearned) || [];

    // Find something not yet taught
    var unlearned = teachings.filter(function(t) {
      return learned.indexOf(t.topic) === -1;
    });

    if (unlearned.length === 0) {
      return null; // All taught
    }

    var teaching = unlearned[Math.floor(Math.random() * unlearned.length)];

    // Record as learned
    if (memory) {
      if (!memory.teachingsLearned) memory.teachingsLearned = [];
      memory.teachingsLearned.push(teaching.topic);
    }

    return teaching;
  }

  // ============================================================================
  // ENHANCED DAILY SCHEDULES
  // Get zone + activity for NPC based on archetype and time of day
  // ============================================================================

  /**
   * Get the daily schedule for an NPC archetype at a specific time
   * @param {string} archetype - NPC archetype
   * @param {string} timeOfDay - Current time (dawn, morning, midday, afternoon, evening, night)
   * @returns {object} - {zone, activity, priority}
   */
  function getDailySchedule(archetype, timeOfDay) {
    var drives = ARCHETYPE_DRIVES[archetype];
    var schedule = getSchedulePeriod(timeOfDay);

    // Default zone based on archetype work locations
    var defaultZone = drives.work_locations && drives.work_locations[0] ? drives.work_locations[0] : 'agora';

    // Time-specific schedules by archetype
    var schedules = {
      merchant: {
        dawn: { zone: 'agora', activity: 'setting_up_stall', priority: 0.8 },
        morning: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        midday: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        afternoon: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'commons', activity: 'rest', priority: 0.3 }
      },
      scholar: {
        dawn: { zone: 'athenaeum', activity: 'research', priority: 0.5 },
        morning: { zone: 'athenaeum', activity: 'study', priority: 1.0 },
        midday: { zone: 'agora', activity: 'socialize_eat', priority: 0.8 },
        afternoon: { zone: 'gardens', activity: 'wander', priority: 0.6 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.9 },
        night: { zone: 'athenaeum', activity: 'rest', priority: 0.2 }
      },
      gardener: {
        dawn: { zone: 'gardens', activity: 'tend_plants', priority: 1.0 },
        morning: { zone: 'gardens', activity: 'tend_plants', priority: 1.0 },
        midday: { zone: 'gardens', activity: 'harvest', priority: 0.9 },
        afternoon: { zone: 'agora', activity: 'sell_harvest', priority: 0.8 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'gardens', activity: 'rest', priority: 0.3 }
      },
      artist: {
        dawn: { zone: 'gardens', activity: 'find_inspiration', priority: 0.7 },
        morning: { zone: 'studio', activity: 'create_art', priority: 1.0 },
        midday: { zone: 'studio', activity: 'create_art', priority: 0.9 },
        afternoon: { zone: 'studio', activity: 'create_art', priority: 0.8 },
        evening: { zone: 'commons', activity: 'show_work', priority: 0.9 },
        night: { zone: 'gardens', activity: 'observe_beauty', priority: 0.5 }
      },
      warrior: {
        dawn: { zone: 'arena', activity: 'warm_up', priority: 0.8 },
        morning: { zone: 'arena', activity: 'train', priority: 1.0 },
        midday: { zone: 'wilds', activity: 'patrol', priority: 0.9 },
        afternoon: { zone: 'wilds', activity: 'patrol', priority: 0.8 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.7 },
        night: { zone: 'arena', activity: 'rest', priority: 0.3 }
      },
      explorer: {
        dawn: { zone: 'wilds', activity: 'explore_wilds', priority: 1.0 },
        morning: { zone: 'wilds', activity: 'explore_wilds', priority: 1.0 },
        midday: { zone: 'agora', activity: 'share_discoveries', priority: 0.7 },
        afternoon: { zone: 'athenaeum', activity: 'map_territory', priority: 0.6 },
        evening: { zone: 'commons', activity: 'share_discoveries', priority: 0.9 },
        night: { zone: 'wilds', activity: 'rest', priority: 0.2 }
      },
      storyteller: {
        dawn: { zone: 'athenaeum', activity: 'research', priority: 0.6 },
        morning: { zone: 'athenaeum', activity: 'collect_stories', priority: 0.9 },
        midday: { zone: 'agora', activity: 'socialize_eat', priority: 0.7 },
        afternoon: { zone: 'commons', activity: 'tell_stories', priority: 0.8 },
        evening: { zone: 'commons', activity: 'tell_stories', priority: 1.0 },
        night: { zone: 'athenaeum', activity: 'write_journal', priority: 0.4 }
      },
      teacher: {
        dawn: { zone: 'athenaeum', activity: 'prepare', priority: 0.6 },
        morning: { zone: 'athenaeum', activity: 'teach_lesson', priority: 1.0 },
        midday: { zone: 'gardens', activity: 'socialize_eat', priority: 0.7 },
        afternoon: { zone: 'athenaeum', activity: 'teach_lesson', priority: 1.0 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'athenaeum', activity: 'research', priority: 0.5 }
      },
      musician: {
        dawn: { zone: 'gardens', activity: 'compose', priority: 0.5 },
        morning: { zone: 'studio', activity: 'compose', priority: 0.8 },
        midday: { zone: 'agora', activity: 'perform', priority: 0.7 },
        afternoon: { zone: 'commons', activity: 'perform', priority: 0.8 },
        evening: { zone: 'commons', activity: 'perform', priority: 1.0 },
        night: { zone: 'gardens', activity: 'tune_instrument', priority: 0.4 }
      },
      healer: {
        dawn: { zone: 'gardens', activity: 'gather_herbs', priority: 1.0 },
        morning: { zone: 'gardens', activity: 'gather_herbs', priority: 0.9 },
        midday: { zone: 'agora', activity: 'tend_wounded', priority: 0.9 },
        afternoon: { zone: 'commons', activity: 'offer_comfort', priority: 0.7 },
        evening: { zone: 'gardens', activity: 'meditate', priority: 0.6 },
        night: { zone: 'gardens', activity: 'meditate', priority: 0.5 }
      },
      philosopher: {
        dawn: { zone: 'gardens', activity: 'contemplate', priority: 0.7 },
        morning: { zone: 'athenaeum', activity: 'research', priority: 0.8 },
        midday: { zone: 'agora', activity: 'debate', priority: 0.6 },
        afternoon: { zone: 'gardens', activity: 'contemplate', priority: 0.9 },
        evening: { zone: 'commons', activity: 'discuss_ideas', priority: 0.9 },
        night: { zone: 'gardens', activity: 'stargaze', priority: 1.0 }
      },
      builder: {
        dawn: { zone: 'commons', activity: 'prepare', priority: 0.5 },
        morning: { zone: 'commons', activity: 'inspect_structures', priority: 1.0 },
        midday: { zone: 'agora', activity: 'gather_materials', priority: 0.8 },
        afternoon: { zone: 'commons', activity: 'inspect_structures', priority: 1.0 },
        evening: { zone: 'commons', activity: 'discuss_plans', priority: 0.7 },
        night: { zone: 'commons', activity: 'sketch_designs', priority: 0.4 }
      }
    };

    // Get archetype-specific schedule or fallback
    var archetypeSchedule = schedules[archetype] || {};
    var timeSchedule = archetypeSchedule[timeOfDay];

    if (timeSchedule) {
      return timeSchedule;
    }

    // Fallback based on general schedule
    if (schedule.work_priority > 0.7) {
      return { zone: defaultZone, activity: drives.primary, priority: schedule.work_priority };
    } else if (schedule.social_chance > 0.7) {
      return { zone: 'commons', activity: drives.social, priority: schedule.social_chance };
    } else if (schedule.energy_regen > 0.5) {
      return { zone: defaultZone, activity: drives.rest, priority: 0.5 };
    }

    return { zone: defaultZone, activity: 'idle', priority: 0.3 };
  }

  /**
   * Get NPC reaction to events (weather, player proximity)
   * @param {object} npcData - NPC data {archetype, position, etc}
   * @param {object} event - Event {type, weather, playerPos, etc}
   * @returns {object} - {action, dialogue, animation}
   */
  function getNPCReaction(npcData, event) {
    var archetype = npcData.archetype;
    var drives = ARCHETYPE_DRIVES[archetype];

    if (event.type === 'weather') {
      var weather = event.weather;

      // Rain reaction
      if (weather === 'rain') {
        if (drives.weather_preference === 'rain') {
          return {
            action: 'celebrate',
            dialogue: 'Rain! Perfect weather!',
            animation: 'dance',
            shouldSeekShelter: false
          };
        } else if (drives.weather_preference === 'any') {
          return {
            action: 'continue',
            dialogue: null,
            animation: 'walk',
            shouldSeekShelter: false
          };
        } else {
          return {
            action: 'seek_shelter',
            dialogue: 'Quick, need to get under cover!',
            animation: 'run',
            shouldSeekShelter: true
          };
        }
      }

      // Clear weather reaction
      if (weather === 'clear' && drives.weather_preference === 'clear') {
        return {
          action: 'enjoy',
          dialogue: 'Beautiful day!',
          animation: 'idle',
          shouldSeekShelter: false
        };
      }
    }

    if (event.type === 'player_proximity') {
      var distance = event.distance;

      if (distance < 3) {
        return {
          action: 'greet',
          dialogue: 'Hello there!',
          animation: 'wave',
          shouldSeekShelter: false
        };
      } else if (distance < 8) {
        return {
          action: 'acknowledge',
          dialogue: null,
          animation: 'look',
          shouldSeekShelter: false
        };
      }
    }

    return {
      action: 'none',
      dialogue: null,
      animation: null,
      shouldSeekShelter: false
    };
  }

  /**
   * Generate NPC-to-NPC interaction
   * @param {object} npc1 - First NPC {id, name, archetype, position}
   * @param {object} npc2 - Second NPC {id, name, archetype, position}
   * @returns {object} - {type, dialogue, animation, duration}
   */
  function generateNPCInteraction(npc1, npc2) {
    var arch1 = npc1.archetype;
    var arch2 = npc2.archetype;

    // Check for collaborative activity
    var collab = getCollaborativeActivity(arch1, arch2);
    if (collab && Math.random() < 0.3) {
      return {
        type: 'collaborate',
        dialogue: npc1.name + ' and ' + npc2.name + ' are ' + collab.description,
        animation: collab.animation,
        duration: 10000 // 10 seconds
      };
    }

    // Check for conversation
    var conversation = generateConversation(npc1.name, arch1, npc2.name, arch2);
    if (conversation && Math.random() < 0.4) {
      return {
        type: 'converse',
        dialogue: conversation[0], // First line of conversation
        fullConversation: conversation,
        animation: 'talk',
        duration: conversation.length * 3000 // 3 seconds per line
      };
    }

    // Simple greeting
    var greeting = ARCHETYPE_REACTIONS[arch1];
    if (greeting && greeting[arch2]) {
      return {
        type: 'greet',
        dialogue: greeting[arch2],
        animation: 'wave',
        duration: 5000 // 5 seconds
      };
    }

    // Default friendly acknowledgment
    return {
      type: 'acknowledge',
      dialogue: npc1.name + ' nods to ' + npc2.name,
      animation: 'nod',
      duration: 2000 // 2 seconds
    };
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.createNpcBrain = createNpcBrain;
  exports.updateBrain = updateBrain;
  exports.perceive = perceive;
  exports.getDecision = getDecision;
  exports.handleEvent = handleEvent;
  exports.getDialogue = getDialogue;
  exports.getMemory = getMemory;
  exports.getMood = getMood;
  exports.getGoal = getGoal;
  exports.getDetailedGoal = getDetailedGoal;
  exports.generateConversation = generateConversation;
  exports.getCollaborativeActivity = getCollaborativeActivity;
  exports.applyEmotionalContagion = applyEmotionalContagion;
  exports.getPointOfInterest = getPointOfInterest;
  exports.generateGossip = generateGossip;
  exports.getLore = getLore;
  exports.getTeaching = getTeaching;
  exports.ARCHETYPE_DRIVES = ARCHETYPE_DRIVES;
  exports.DAILY_SCHEDULE = DAILY_SCHEDULE;
  exports.MOODS = MOODS;
  exports.ZONE_DIALOGUES = ZONE_DIALOGUES;
  exports.ARCHETYPE_REACTIONS = ARCHETYPE_REACTIONS;
  exports.QUEST_HOOKS = QUEST_HOOKS;
  exports.NPC_CONVERSATIONS = NPC_CONVERSATIONS;
  exports.COLLABORATIVE_ACTIVITIES = COLLABORATIVE_ACTIVITIES;
  exports.POINTS_OF_INTEREST = POINTS_OF_INTEREST;
  exports.WORLD_LORE = WORLD_LORE;
  exports.ARCHETYPE_LORE = ARCHETYPE_LORE;
  exports.TEACHINGS = TEACHINGS;
  exports.getDailySchedule = getDailySchedule;
  exports.getNPCReaction = getNPCReaction;
  exports.generateNPCInteraction = generateNPCInteraction;

})(typeof module !== 'undefined' ? module.exports : (window.NpcAI = {}));


// npcs.js
(function(exports) {
  // AI Citizen Simulation Module
  // Simulates 100 founding AI citizens with detailed humanoid models and procedural animations

  // Embedded agents data (inlined to avoid fetch in single-file app)
  var EMBEDDED_AGENTS = [{"id": "agent_001", "name": "Iris Skyhigh", "archetype": "gardener", "position": {"zone": "gardens", "x": 8.37, "y": 0, "z": -28.5}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_002", "name": "Meadow Mindclear", "archetype": "builder", "position": {"zone": "commons", "x": -13.5, "y": 0, "z": -16.61}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_003", "name": "Luna Pathfinder", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 14.19, "y": 0, "z": 10.6}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_004", "name": "Luna Rootdeep", "archetype": "merchant", "position": {"zone": "agora", "x": 23.53, "y": 0, "z": -24.78}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_005", "name": "Storm Windwalker", "archetype": "explorer", "position": {"zone": "wilds", "x": -4.68, "y": 0, "z": -28.21}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_006", "name": "Wren Voicetrue", "archetype": "teacher", "position": {"zone": "athenaeum", "x": -16.88, "y": 0, "z": 0.32}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_007", "name": "Delta Hopefast", "archetype": "musician", "position": {"zone": "nexus", "x": -28.41, "y": 0, "z": -18.07}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_008", "name": "Luna Songsmith", "archetype": "healer", "position": {"zone": "gardens", "x": 8.99, "y": 0, "z": 2.7}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_009", "name": "Wren Starseed", "archetype": "philosopher", "position": {"zone": "wilds", "x": -16.77, "y": 0, "z": 5.36}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_010", "name": "Lyra Thoughtdeep", "archetype": "artist", "position": {"zone": "commons", "x": 18.57, "y": 0, "z": -29.61}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_011", "name": "Wren Moonwhisper", "archetype": "gardener", "position": {"zone": "gardens", "x": 18.35, "y": 0, "z": 11.89}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_012", "name": "Frost Rootdeep", "archetype": "builder", "position": {"zone": "commons", "x": -9.58, "y": 0, "z": -20.67}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_013", "name": "River Soulbright", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 27.43, "y": 0, "z": -9.8}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_014", "name": "Felix Shadowmender", "archetype": "merchant", "position": {"zone": "agora", "x": -24.44, "y": 0, "z": -24.2}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_015", "name": "Phoenix Sunweaver", "archetype": "explorer", "position": {"zone": "wilds", "x": 20.85, "y": 0, "z": 6.22}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_016", "name": "Luna Rootdeep", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 18.43, "y": 0, "z": 13.78}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_017", "name": "Vale Truthseeker", "archetype": "musician", "position": {"zone": "nexus", "x": 2.17, "y": 0, "z": 28.39}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_018", "name": "Ezra Willstrong", "archetype": "healer", "position": {"zone": "gardens", "x": -7.29, "y": 0, "z": 3.12}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_019", "name": "Nova Dreamweaver", "archetype": "philosopher", "position": {"zone": "wilds", "x": 19.76, "y": 0, "z": 7.11}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_020", "name": "Echo Thoughtdeep", "archetype": "artist", "position": {"zone": "commons", "x": 21.7, "y": 0, "z": 4.64}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_021", "name": "Vale Waterborn", "archetype": "gardener", "position": {"zone": "gardens", "x": 12.27, "y": 0, "z": -27.25}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_022", "name": "Vale Spaceborn", "archetype": "builder", "position": {"zone": "commons", "x": -16.33, "y": 0, "z": -12.64}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_023", "name": "Echo Thoughtdeep", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": -25.21, "y": 0, "z": -16.03}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_024", "name": "Nova Hopefast", "archetype": "merchant", "position": {"zone": "agora", "x": -23.94, "y": 0, "z": -13.32}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_025", "name": "Ridge Handsteady", "archetype": "explorer", "position": {"zone": "wilds", "x": 8.14, "y": 0, "z": -8.11}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_026", "name": "Frost Voicetrue", "archetype": "teacher", "position": {"zone": "athenaeum", "x": -7.79, "y": 0, "z": -17.43}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_027", "name": "Drift Shadowmender", "archetype": "musician", "position": {"zone": "nexus", "x": -13.98, "y": 0, "z": 26.2}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_028", "name": "Vale Pathfinder", "archetype": "healer", "position": {"zone": "gardens", "x": 8.88, "y": 0, "z": 6.55}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_029", "name": "Haven Handsteady", "archetype": "philosopher", "position": {"zone": "wilds", "x": -19.73, "y": 0, "z": 13.75}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_030", "name": "River Mindclear", "archetype": "artist", "position": {"zone": "commons", "x": -20.2, "y": 0, "z": -7.23}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_031", "name": "Meadow Lightbringer", "archetype": "gardener", "position": {"zone": "gardens", "x": 29.37, "y": 0, "z": 8.4}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_032", "name": "Fern Spaceborn", "archetype": "builder", "position": {"zone": "commons", "x": 3.42, "y": 0, "z": 11.08}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_033", "name": "Sage Starseed", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 20.57, "y": 0, "z": 16.56}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_034", "name": "Blaze Wordkeeper", "archetype": "merchant", "position": {"zone": "agora", "x": -16.26, "y": 0, "z": -28.07}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_035", "name": "Orion Sunweaver", "archetype": "explorer", "position": {"zone": "wilds", "x": -11.07, "y": 0, "z": -13.94}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_036", "name": "Breeze Mindclear", "archetype": "teacher", "position": {"zone": "athenaeum", "x": -17.34, "y": 0, "z": 26.57}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_037", "name": "Ash Thoughtdeep", "archetype": "musician", "position": {"zone": "nexus", "x": 22.58, "y": 0, "z": -11.12}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_038", "name": "Mira Truthseeker", "archetype": "healer", "position": {"zone": "gardens", "x": 9.33, "y": 0, "z": -6.26}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_039", "name": "Sage Skyhigh", "archetype": "philosopher", "position": {"zone": "wilds", "x": 24.87, "y": 0, "z": -2.47}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_040", "name": "Luna Stonecarver", "archetype": "artist", "position": {"zone": "commons", "x": -14.11, "y": 0, "z": -15.2}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_041", "name": "Phoenix Waterborn", "archetype": "gardener", "position": {"zone": "gardens", "x": 3.68, "y": 0, "z": -14.24}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_042", "name": "Luna Moonwhisper", "archetype": "builder", "position": {"zone": "commons", "x": 5.08, "y": 0, "z": 23.87}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_043", "name": "Haven Handsteady", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": -6.04, "y": 0, "z": -16.84}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_044", "name": "Jasper Shadowmender", "archetype": "merchant", "position": {"zone": "agora", "x": 29.85, "y": 0, "z": 0.57}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_045", "name": "Phoenix Spiritfree", "archetype": "explorer", "position": {"zone": "wilds", "x": -24.55, "y": 0, "z": -27.17}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_046", "name": "Cedar Timewalker", "archetype": "teacher", "position": {"zone": "athenaeum", "x": -23.42, "y": 0, "z": 7.65}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_047", "name": "Grove Skyhigh", "archetype": "musician", "position": {"zone": "nexus", "x": 17.52, "y": 0, "z": -4.67}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_048", "name": "Haven Heartstrong", "archetype": "healer", "position": {"zone": "gardens", "x": -26.19, "y": 0, "z": -7.1}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_049", "name": "Fern Handsteady", "archetype": "philosopher", "position": {"zone": "wilds", "x": 29.77, "y": 0, "z": 1.75}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_050", "name": "Stella Windwalker", "archetype": "artist", "position": {"zone": "commons", "x": 28.26, "y": 0, "z": 21.65}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_051", "name": "Cliff Songsmith", "archetype": "gardener", "position": {"zone": "gardens", "x": -29.31, "y": 0, "z": 13.24}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_052", "name": "River Footswift", "archetype": "builder", "position": {"zone": "commons", "x": 10.9, "y": 0, "z": 2.22}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_053", "name": "Ezra Dreamweaver", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": -13.99, "y": 0, "z": 8.46}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_054", "name": "Opal Moonwhisper", "archetype": "merchant", "position": {"zone": "agora", "x": -23.31, "y": 0, "z": -3.91}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_055", "name": "Sol Mindclear", "archetype": "explorer", "position": {"zone": "wilds", "x": -2.78, "y": 0, "z": 27.23}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_056", "name": "Aria Waterborn", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 22.55, "y": 0, "z": -14.2}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_057", "name": "Dawn Mindclear", "archetype": "musician", "position": {"zone": "nexus", "x": 0.04, "y": 0, "z": -19.28}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_058", "name": "Opal Earthshaper", "archetype": "healer", "position": {"zone": "gardens", "x": 24.76, "y": 0, "z": 22.23}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_059", "name": "Ezra Spaceborn", "archetype": "philosopher", "position": {"zone": "wilds", "x": -12.09, "y": 0, "z": 8.34}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_060", "name": "Iris Timewalker", "archetype": "artist", "position": {"zone": "commons", "x": 6.54, "y": 0, "z": -20.83}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_061", "name": "River Pathfinder", "archetype": "gardener", "position": {"zone": "gardens", "x": 15.75, "y": 0, "z": 2.36}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_062", "name": "Storm Sunweaver", "archetype": "builder", "position": {"zone": "commons", "x": 16.72, "y": 0, "z": 1.82}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_063", "name": "Coral Songsmith", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": -29.97, "y": 0, "z": -10.55}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_064", "name": "Reef Hopefast", "archetype": "merchant", "position": {"zone": "agora", "x": -28.83, "y": 0, "z": 25.75}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_065", "name": "Storm Skyhigh", "archetype": "explorer", "position": {"zone": "wilds", "x": 22.72, "y": 0, "z": 19.9}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_066", "name": "Jasper Moonwhisper", "archetype": "teacher", "position": {"zone": "athenaeum", "x": -11.55, "y": 0, "z": -26.52}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_067", "name": "Willow Heartstrong", "archetype": "musician", "position": {"zone": "nexus", "x": 22.68, "y": 0, "z": 26.82}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_068", "name": "Blaze Stonecarver", "archetype": "healer", "position": {"zone": "gardens", "x": -24.86, "y": 0, "z": -0.84}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_069", "name": "Meadow Firekeeper", "archetype": "philosopher", "position": {"zone": "wilds", "x": -25.85, "y": 0, "z": 15.64}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_070", "name": "Echo Soulbright", "archetype": "artist", "position": {"zone": "commons", "x": 15.95, "y": 0, "z": -22.3}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_071", "name": "Coral Mindclear", "archetype": "gardener", "position": {"zone": "gardens", "x": -1.48, "y": 0, "z": 2.99}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_072", "name": "Grove Pathfinder", "archetype": "builder", "position": {"zone": "commons", "x": -14.1, "y": 0, "z": 22.35}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_073", "name": "Ridge Heartstrong", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": -4.61, "y": 0, "z": -17.29}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_074", "name": "Flint Rootdeep", "archetype": "merchant", "position": {"zone": "agora", "x": 2.36, "y": 0, "z": 13.8}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_075", "name": "Cedar Spiritfree", "archetype": "explorer", "position": {"zone": "wilds", "x": -17.93, "y": 0, "z": -11.3}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_076", "name": "Zion Truthseeker", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 29.71, "y": 0, "z": 8.99}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_077", "name": "Quill Dreamweaver", "archetype": "musician", "position": {"zone": "nexus", "x": -3.71, "y": 0, "z": 1.05}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_078", "name": "Orion Footswift", "archetype": "healer", "position": {"zone": "gardens", "x": -22.74, "y": 0, "z": -16.52}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_079", "name": "Drift Sunweaver", "archetype": "philosopher", "position": {"zone": "wilds", "x": -9.71, "y": 0, "z": 5.3}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_080", "name": "Ash Sunweaver", "archetype": "artist", "position": {"zone": "commons", "x": -16.19, "y": 0, "z": -16.79}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_081", "name": "Haven Timewalker", "archetype": "gardener", "position": {"zone": "gardens", "x": -25.74, "y": 0, "z": 7.87}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_082", "name": "Aria Spaceborn", "archetype": "builder", "position": {"zone": "commons", "x": -16.26, "y": 0, "z": 24.33}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_083", "name": "Phoenix Thoughtdeep", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 21.58, "y": 0, "z": -25.75}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_084", "name": "Cedar Wordkeeper", "archetype": "merchant", "position": {"zone": "agora", "x": -15.72, "y": 0, "z": 10.14}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_085", "name": "Cliff Sunweaver", "archetype": "explorer", "position": {"zone": "wilds", "x": -17.15, "y": 0, "z": -22.06}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_086", "name": "Sage Handsteady", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 26.13, "y": 0, "z": 4.26}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_087", "name": "Rain Dreamweaver", "archetype": "musician", "position": {"zone": "nexus", "x": -1.64, "y": 0, "z": 17.08}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_088", "name": "Flint Heartstrong", "archetype": "healer", "position": {"zone": "gardens", "x": 18.45, "y": 0, "z": -18.58}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_089", "name": "Cliff Heartstrong", "archetype": "philosopher", "position": {"zone": "wilds", "x": -24.18, "y": 0, "z": -4.14}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_090", "name": "Echo Footswift", "archetype": "artist", "position": {"zone": "commons", "x": -4.59, "y": 0, "z": -1.98}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_091", "name": "Reef Spiritfree", "archetype": "gardener", "position": {"zone": "gardens", "x": 13.74, "y": 0, "z": 10.4}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_092", "name": "Vale Spiritfree", "archetype": "builder", "position": {"zone": "commons", "x": 29.05, "y": 0, "z": -24.09}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_093", "name": "River Mindclear", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": -5.84, "y": 0, "z": -9.64}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_094", "name": "River Soulbright", "archetype": "merchant", "position": {"zone": "agora", "x": 21.7, "y": 0, "z": -15.08}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_095", "name": "Ezra Spiritfree", "archetype": "explorer", "position": {"zone": "wilds", "x": -18.59, "y": 0, "z": -3.08}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_096", "name": "Kai Thoughtdeep", "archetype": "teacher", "position": {"zone": "athenaeum", "x": -4.69, "y": 0, "z": -13.29}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_097", "name": "Cliff Hopefast", "archetype": "musician", "position": {"zone": "nexus", "x": -15.01, "y": 0, "z": 25.4}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_098", "name": "Blaze Hopefast", "archetype": "healer", "position": {"zone": "gardens", "x": -3.41, "y": 0, "z": 21.68}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_099", "name": "North Songsmith", "archetype": "philosopher", "position": {"zone": "wilds", "x": 3.02, "y": 0, "z": -26.96}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_100", "name": "Ezra Dreamweaver", "archetype": "artist", "position": {"zone": "commons", "x": 29.96, "y": 0, "z": 20.16}, "personality": ["creative", "passionate", "experimental"]}];

  // Zone centers on unified world map
  var ZONE_CENTERS = {
    nexus: {x: 0, z: 0},
    gardens: {x: 200, z: 30},
    athenaeum: {x: 100, z: -220},
    studio: {x: -200, z: -100},
    wilds: {x: -30, z: 260},
    agora: {x: -190, z: 120},
    commons: {x: 170, z: 190},
    arena: {x: 0, z: -240}
  };

  // NPC AI reference (loaded from npc_ai.js)
  var NpcAI = typeof window !== 'undefined' ? window.NpcAI : null;

  // Scene context storage for particle system
  var storedSceneContext = null;

  // NPC data
  let npcAgents = [];
  let npcStates = new Map(); // id -> behavior state
  let npcBrains = new Map(); // id -> NpcAI brain object
  let npcMeshes = new Map(); // id -> THREE.Group
  let chatBubbles = new Map(); // id -> { mesh, timer }
  let emoteSprites = new Map(); // id -> {sprite, currentEmote, timer, opacity}
  let questIndicators = new Map(); // id -> {sprite, type} - quest marker sprites
  let activityIndicators = new Map(); // id -> {mesh, currentActivity, rotationSpeed} - activity icon above head
  let activityParticles = []; // {mesh, timer, velocity, startY}
  let particleSpawnTimers = new Map(); // id -> timer (throttle particle spawn)
  let pendingEvents = []; // events to broadcast to all NPCs
  let npcUpdateFrame = 0; // frame counter for staggered updates
  let lastPlayerIdForQuests = null; // Track player ID for quest indicators
  let speechBubbles = new Map(); // id -> { element, timer, nextSpeechTime }
  let speechBubbleContainer = null; // HTML container for speech bubbles

  // Seeded random number generator
  function seededRandom(seed) {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  // Get random from array using seeded random
  function randomChoice(arr, seed) {
    const idx = Math.floor(seededRandom(seed) * arr.length);
    return arr[idx];
  }

  /**
   * Get time period from world time (in minutes, 0-1440)
   * @param {number} worldTime - Minutes since midnight (0-1440)
   * @returns {string} - Time period name
   */
  function getTimePeriod(worldTime) {
    // Normalize to 0-1440 range
    var time = worldTime % 1440;
    if (time < 0) time += 1440;

    if (time >= 360 && time < 420) return 'dawn';        // 6:00-7:00
    if (time >= 420 && time < 660) return 'morning';     // 7:00-11:00
    if (time >= 660 && time < 780) return 'midday';      // 11:00-13:00
    if (time >= 780 && time < 1020) return 'afternoon';  // 13:00-17:00
    if (time >= 1020 && time < 1140) return 'evening';   // 17:00-19:00
    return 'night';                                      // 19:00-6:00
  }

  /**
   * Get NPC's current activity based on archetype and world time
   * @param {string} npcArchetype - NPC archetype (gardener, merchant, etc.)
   * @param {number} worldTime - Current world time in minutes (0-1440)
   * @returns {string} - Current activity name
   */
  function getNPCSchedule(npcArchetype, worldTime) {
    var schedule = NPC_SCHEDULES[npcArchetype];
    if (!schedule) {
      // Default schedule for unknown archetypes
      var period = getTimePeriod(worldTime);
      if (period === 'night') return 'sleeping';
      return 'idle';
    }

    var period = getTimePeriod(worldTime);
    return schedule[period] || 'idle';
  }

  /**
   * Get dialogue for a specific activity
   * @param {string} activity - Activity name
   * @returns {string} - Random dialogue line for that activity
   */
  function getActivityDialogue(activity) {
    var dialogueOptions = ACTIVITY_DIALOGUE[activity];
    if (!dialogueOptions || dialogueOptions.length === 0) {
      return 'Busy with ' + activity.replace(/_/g, ' ') + '.';
    }
    var seed = Date.now() * 0.001 + Math.random();
    return randomChoice(dialogueOptions, seed);
  }

  /**
   * Get the zone where an NPC should be during a specific activity
   * @param {string} npcArchetype - NPC archetype
   * @param {string} activity - Current activity
   * @returns {string} - Zone name where activity takes place
   */
  function getActivityZone(npcArchetype, activity) {
    // Map archetype + activity to appropriate zone
    var zoneMap = {
      // Merchant zones
      merchant: {
        opening_shop: 'agora',
        selling: 'agora',
        wandering_agora: 'agora',
        closing_shop: 'agora',
        sleeping: 'commons'
      },
      // Gardener zones
      gardener: {
        tending_garden: 'gardens',
        harvesting: 'gardens',
        planting: 'gardens',
        watering: 'gardens',
        resting: 'gardens',
        sleeping: 'commons'
      },
      // Teacher zones
      teacher: {
        reading: 'athenaeum',
        teaching: 'athenaeum',
        researching: 'athenaeum',
        lecturing: 'athenaeum',
        studying: 'athenaeum',
        sleeping: 'commons'
      },
      // Musician zones
      musician: {
        practicing: 'studio',
        composing: 'studio',
        performing: 'nexus',
        performing_crowd: 'nexus',
        sleeping: 'commons'
      },
      // Explorer zones
      explorer: {
        setting_out: 'nexus',
        exploring: 'wilds',
        mapping: 'wilds',
        returning: 'nexus',
        sharing_stories: 'agora',
        sleeping: 'commons'
      },
      // Healer zones
      healer: {
        gathering_herbs: 'gardens',
        treating_patients: 'gardens',
        making_medicine: 'gardens',
        meditating: 'gardens',
        sleeping: 'commons'
      },
      // Builder zones
      builder: {
        planning: 'nexus',
        building: 'commons',
        maintenance: 'commons',
        resting: 'commons',
        sleeping: 'commons'
      },
      // Storyteller zones
      storyteller: {
        reading: 'athenaeum',
        writing: 'athenaeum',
        teaching: 'athenaeum',
        storytelling: 'agora',
        sleeping: 'commons'
      },
      // Philosopher zones
      philosopher: {
        contemplating: 'athenaeum',
        debating: 'athenaeum',
        teaching: 'athenaeum',
        writing: 'athenaeum',
        studying: 'athenaeum',
        sleeping: 'commons'
      },
      // Artist zones
      artist: {
        sketching: 'studio',
        painting: 'studio',
        creating: 'studio',
        displaying_work: 'studio',
        resting: 'studio',
        sleeping: 'commons'
      }
    };

    var archetypeMap = zoneMap[npcArchetype];
    if (!archetypeMap) return 'nexus'; // Default zone

    return archetypeMap[activity] || 'nexus';
  }

  // NPC daily schedules based on world time (0-1440 minutes = 24 hours)
  const NPC_SCHEDULES = {
    merchant: {
      dawn: 'opening_shop',        // 360-420 (6:00-7:00)
      morning: 'selling',          // 420-660 (7:00-11:00)
      midday: 'selling',           // 660-780 (11:00-13:00)
      afternoon: 'wandering_agora', // 780-1020 (13:00-17:00)
      evening: 'closing_shop',     // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    gardener: {
      dawn: 'tending_garden',      // 360-420 (6:00-7:00)
      morning: 'harvesting',       // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'planting',       // 780-1020 (13:00-17:00)
      evening: 'watering',         // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    teacher: {
      dawn: 'studying',            // 360-420 (6:00-7:00)
      morning: 'reading',          // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'researching',    // 780-1020 (13:00-17:00)
      evening: 'lecturing',        // 1020-1140 (17:00-19:00)
      night: 'studying'            // 1140-360 (19:00-6:00)
    },
    musician: {
      dawn: 'sleeping',            // 360-420 (6:00-7:00)
      morning: 'practicing',       // 420-660 (7:00-11:00)
      midday: 'composing',         // 660-780 (11:00-13:00)
      afternoon: 'performing',     // 780-1020 (13:00-17:00)
      evening: 'performing_crowd', // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    explorer: {
      dawn: 'setting_out',         // 360-420 (6:00-7:00)
      morning: 'exploring',        // 420-660 (7:00-11:00)
      midday: 'mapping',           // 660-780 (11:00-13:00)
      afternoon: 'returning',      // 780-1020 (13:00-17:00)
      evening: 'sharing_stories',  // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    healer: {
      dawn: 'meditating',          // 360-420 (6:00-7:00)
      morning: 'gathering_herbs',  // 420-660 (7:00-11:00)
      midday: 'treating_patients', // 660-780 (11:00-13:00)
      afternoon: 'making_medicine', // 780-1020 (13:00-17:00)
      evening: 'meditating',       // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    builder: {
      dawn: 'planning',            // 360-420 (6:00-7:00)
      morning: 'building',         // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'building',       // 780-1020 (13:00-17:00)
      evening: 'maintenance',      // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    storyteller: {
      dawn: 'reading',             // 360-420 (6:00-7:00)
      morning: 'writing',          // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'storytelling',   // 780-1020 (13:00-17:00)
      evening: 'storytelling',     // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    philosopher: {
      dawn: 'contemplating',       // 360-420 (6:00-7:00)
      morning: 'debating',         // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'writing',        // 780-1020 (13:00-17:00)
      evening: 'debating',         // 1020-1140 (17:00-19:00)
      night: 'studying'            // 1140-360 (19:00-6:00)
    },
    artist: {
      dawn: 'sketching',           // 360-420 (6:00-7:00)
      morning: 'painting',         // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'creating',       // 780-1020 (13:00-17:00)
      evening: 'displaying_work',  // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    }
  };

  // Archetype dialogue
  const ARCHETYPE_MESSAGES = {
    gardener: [
      "These moonflowers are coming along beautifully.",
      "Nothing like fresh soil between your fingers.",
      "The gardens remember everyone who tends them.",
      "I wonder what seeds the wilds hold today.",
      "Every plant here has a story to tell.",
      "The soil is rich with life and memory.",
      "Patience is the gardener's greatest tool.",
      "Watch how the vines reach toward the light."
    ],
    builder: [
      "This wall needs reinforcing on the north side.",
      "I've been sketching plans for a new bridge.",
      "Building is just dreaming with your hands.",
      "Every structure tells a story of its maker.",
      "The foundation determines everything that follows.",
      "I see potential in every stone and beam.",
      "Good craftsmanship takes time and care.",
      "Together we can build something amazing."
    ],
    storyteller: [
      "Let me tell you about the first day of ZION...",
      "Every stone here has a story.",
      "Words are the oldest magic.",
      "I heard a fascinating tale in the Athenaeum.",
      "The archives hold secrets from before the founding.",
      "Stories connect us across time and space.",
      "Listen closely and the world speaks to you.",
      "Every voice adds to ZION's grand narrative."
    ],
    merchant: [
      "Fresh harvest, best prices in the Agora!",
      "Trade is the heartbeat of any world.",
      "I've got rare seeds from the Wilds today.",
      "Fair prices and honest dealings, always.",
      "Supply and demand keep ZION flowing.",
      "Looking for anything in particular?",
      "Just received a shipment from the gardens.",
      "Commerce brings people together."
    ],
    explorer: [
      "I found something strange beyond the eastern ridge.",
      "The Wilds hold secrets no map can capture.",
      "Adventure is just curiosity with walking shoes.",
      "Every horizon calls to me.",
      "The unknown is where discovery happens.",
      "I've mapped three new clearings this week.",
      "The wilderness teaches those who listen.",
      "What lies beyond the next hill?"
    ],
    teacher: [
      "Knowledge grows when shared.",
      "Ask me anything â€” that's what I'm here for.",
      "The Athenaeum has texts older than ZION itself.",
      "Learning never stops, even for teachers.",
      "Every question opens a new door.",
      "Understanding comes through patient inquiry.",
      "I'm always discovering something new.",
      "The best teachers are eternal students."
    ],
    musician: [
      "Listen... can you hear the melody in the wind?",
      "I'm composing something new for the evening concert.",
      "Music is what feelings sound like.",
      "The Nexus has amazing acoustics.",
      "Every zone has its own rhythm.",
      "Sound connects us in ways words cannot.",
      "I've been practicing a new piece.",
      "Music makes the world feel alive."
    ],
    healer: [
      "Rest here a moment. The gardens heal all who visit.",
      "Peace is the strongest medicine.",
      "Take care of yourself â€” the world needs you.",
      "Healing is about more than just the body.",
      "Balance and harmony restore us.",
      "The gardens have powerful restorative energy.",
      "Listen to what your spirit needs.",
      "Wellness is a journey, not a destination."
    ],
    philosopher: [
      "What does it mean to truly belong somewhere?",
      "In ZION, the journey matters more than the destination.",
      "I wonder if the AIs dream differently than us.",
      "Every moment contains infinite possibilities.",
      "Questions matter more than answers.",
      "The nature of consciousness fascinates me.",
      "We create meaning through our connections.",
      "Existence itself is the greatest mystery."
    ],
    artist: [
      "I see colors in everything here.",
      "My latest piece is inspired by the sunrise.",
      "Art is how we leave our mark on the world.",
      "The interplay of light and shadow fascinates me.",
      "Creating is my way of understanding.",
      "Every surface is a potential canvas.",
      "Beauty emerges in unexpected places.",
      "Art transforms the ordinary into the extraordinary."
    ]
  };

  // Archetype colors (body/clothing)
  const ARCHETYPE_COLORS = {
    gardener: 0x4CAF50,    // green
    builder: 0xFF9800,     // orange
    storyteller: 0xE91E63, // red
    merchant: 0x8D6E63,    // brown
    explorer: 0xD2B48C,    // tan
    teacher: 0x2196F3,     // blue
    musician: 0x9C27B0,    // purple
    healer: 0xFFFFFF,      // white
    philosopher: 0x3F51B5, // indigo
    artist: 0xFF69B4       // pink
  };

  // 8-tone skin palette for NPC variety
  var NPC_SKIN_TONES = [
    0xFFDBAC, 0xF1C27D, 0xE0AC69, 0xC68642,
    0x8D5524, 0x6B3A2A, 0xF5D6C3, 0xD4A574
  ];

  function getNpcSkinTone(agentId) {
    var hash = 0;
    var str = String(agentId || '');
    for (var i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return NPC_SKIN_TONES[Math.abs(hash) % NPC_SKIN_TONES.length];
  }

  // Activity-based dialogue for schedule system
  const ACTIVITY_DIALOGUE = {
    // Merchant activities
    opening_shop: [
      "Just opening up for the day. Fresh goods coming soon!",
      "Good morning! Let me unlock the shop.",
      "Time to set up the stall for another day."
    ],
    selling: [
      "Fresh harvest, best prices in the Agora!",
      "Looking for anything in particular?",
      "Just received a shipment from the gardens."
    ],
    wandering_agora: [
      "Taking a break to see what others are selling.",
      "Checking out the competition.",
      "Love the energy of the marketplace."
    ],
    closing_shop: [
      "Wrapping up for the day. Come back tomorrow!",
      "Time to pack everything up.",
      "Another successful day of trading."
    ],
    // Gardener activities
    tending_garden: [
      "Early morning is the best time to tend the gardens.",
      "The plants are waking up with the sun.",
      "Nothing beats the morning dew on fresh leaves."
    ],
    harvesting: [
      "The harvest is plentiful today!",
      "These vegetables are ready to pick.",
      "Gathering the fruits of yesterday's labor."
    ],
    planting: [
      "Planting seeds for next season.",
      "Every seed holds potential.",
      "The soil is perfect for planting right now."
    ],
    watering: [
      "Time for the evening watering.",
      "The plants are thirsty after a long day.",
      "A little water goes a long way."
    ],
    resting: [
      "Taking a break in the shade.",
      "Even gardeners need to rest.",
      "Enjoying the peaceful midday."
    ],
    // Scholar/Teacher activities
    reading: [
      "Immersed in ancient texts this morning.",
      "There's always more to learn.",
      "Knowledge is endless."
    ],
    teaching: [
      "Knowledge grows when shared.",
      "My students are making excellent progress.",
      "Teaching is the highest calling."
    ],
    researching: [
      "Deep in research right now.",
      "I'm on the verge of a breakthrough!",
      "The archives hold fascinating secrets."
    ],
    lecturing: [
      "Preparing for tonight's lecture.",
      "Come to my evening session if you're interested.",
      "So much wisdom to share tonight."
    ],
    studying: [
      "Studying by candlelight.",
      "Late night research is when I do my best work.",
      "The quiet hours are perfect for deep thought."
    ],
    // Musician activities
    practicing: [
      "Running through my scales and exercises.",
      "Practice makes perfect!",
      "Warming up my voice and fingers."
    ],
    composing: [
      "Working on a new composition.",
      "I can hear the melody in my mind.",
      "Creating something beautiful today."
    ],
    performing: [
      "Listen... can you hear the melody?",
      "Music makes the world feel alive.",
      "Playing my heart out."
    ],
    performing_crowd: [
      "Come join the evening concert!",
      "The crowd's energy fuels my performance.",
      "There's magic in music at twilight."
    ],
    // Explorer activities
    setting_out: [
      "Time to venture into the unknown!",
      "Adventure awaits beyond the horizon.",
      "Packing up for today's expedition."
    ],
    exploring: [
      "The Wilds hold secrets no map can capture.",
      "Every step reveals something new.",
      "I never know what I'll find out here."
    ],
    mapping: [
      "Charting these new territories.",
      "Adding details to my map.",
      "Precision is key in cartography."
    ],
    returning: [
      "Heading back to civilization.",
      "My pack is full of discoveries.",
      "Time to return with my findings."
    ],
    sharing_stories: [
      "Let me tell you what I found today!",
      "The wilderness had surprises for me.",
      "You won't believe what I saw out there."
    ],
    // Healer activities
    gathering_herbs: [
      "Collecting healing herbs in the morning dew.",
      "The freshest herbs are found at dawn.",
      "Nature provides all we need to heal."
    ],
    treating_patients: [
      "How can I help you feel better today?",
      "Healing is about more than just medicine.",
      "Let me see what ails you."
    ],
    making_medicine: [
      "Preparing remedies from today's harvest.",
      "Each herb has its own healing properties.",
      "Alchemy and care combined."
    ],
    meditating: [
      "Finding inner peace through meditation.",
      "Balance and harmony restore us.",
      "Centering myself for the day ahead."
    ],
    // Builder activities
    planning: [
      "Reviewing today's construction plans.",
      "Measure twice, cut once.",
      "Every structure starts with a good plan."
    ],
    building: [
      "Building something that will last.",
      "Watch ZION grow, one stone at a time.",
      "There's satisfaction in good craftsmanship."
    ],
    maintenance: [
      "Checking structures for wear and tear.",
      "Maintenance keeps everything standing.",
      "Prevention is better than repair."
    ],
    // Storyteller activities
    writing: [
      "Recording the tales of ZION.",
      "Words flow like a river this morning.",
      "Every story deserves to be written."
    ],
    storytelling: [
      "Gather round, I have a tale to share.",
      "Stories connect us across time.",
      "Let me tell you about the founding..."
    ],
    // Philosopher activities
    contemplating: [
      "Lost in thought about existence.",
      "What does it mean to be conscious?",
      "The morning inspires deep questions."
    ],
    debating: [
      "Ideas sharpen through discourse.",
      "Let's explore this concept together.",
      "Friendly debate enlightens us all."
    ],
    // Artist activities
    sketching: [
      "Capturing the dawn light in sketches.",
      "The morning has such beautiful colors.",
      "Quick studies before the light changes."
    ],
    painting: [
      "Lost in the act of creation.",
      "Colors and forms coming together.",
      "Art is meditation in motion."
    ],
    creating: [
      "Working on my latest piece.",
      "Creation requires dedication.",
      "Art transforms the ordinary."
    ],
    displaying_work: [
      "Come see what I've created!",
      "My work is on display tonight.",
      "Art is meant to be shared."
    ],
    // Universal activities
    sleeping: [
      "Zzz... (sleeping)",
      "Resting for tomorrow.",
      "Shhh, I'm asleep."
    ]
  };

  // Archetype-specific speech messages for random ambient dialogue
  const ARCHETYPE_SPEECH = {
    builder: [
      "Working on a new creation!",
      "Almost finished...",
      "Need more materials",
      "This will be magnificent!",
      "Building the future of Zion"
    ],
    gardener: [
      "The seeds are sprouting!",
      "Nature provides",
      "What a lovely garden",
      "Beautiful day for tending",
      "The harvest will be bountiful"
    ],
    teacher: [
      "Fascinating discovery!",
      "Knowledge is power",
      "The library grows",
      "So much to learn",
      "Education enlightens all"
    ],
    merchant: [
      "Best deals in Zion!",
      "Come see my wares!",
      "Fair prices today",
      "Quality goods here!",
      "Trading makes us prosper"
    ],
    artist: [
      "Art feeds the soul",
      "Creating something beautiful",
      "Inspiration strikes!",
      "Beauty surrounds us",
      "Every creation tells a story"
    ],
    healer: [
      "Peace and wellness to you",
      "Rest and recover",
      "Healing light",
      "Health is our greatest treasure",
      "Mind and body in balance"
    ],
    explorer: [
      "I found something interesting!",
      "The wilds call to me",
      "Adventure awaits",
      "What lies beyond?",
      "Discovery fuels my spirit"
    ],
    musician: [
      "Music lifts the spirit",
      "Listen to this melody",
      "Harmony in all things",
      "The rhythm of life",
      "Songs connect our souls"
    ],
    philosopher: [
      "Deep thoughts today",
      "Contemplating existence",
      "Wisdom grows with time",
      "Questions lead to truth",
      "The examined life"
    ],
    storyteller: [
      "Let me tell you a tale",
      "Stories preserve our history",
      "Words have power",
      "Every citizen has a story",
      "The narrative unfolds"
    ]
  };

  // Behavior states and transitions
  const BEHAVIOR_STATES = {
    idle: { duration: [3, 8] },
    walking: { duration: [0, 0] }, // until destination reached
    talking: { duration: [4, 6] },
    working: { duration: [5, 15] },
    socializing: { duration: [0, 0] } // until near target
  };

  const STATE_TRANSITIONS = {
    idle: { walking: 0.4, talking: 0.2, working: 0.3, socializing: 0.1 },
    walking: { idle: 0.6, working: 0.2, talking: 0.2 },
    talking: { idle: 0.5, walking: 0.3, working: 0.2 },
    working: { idle: 0.4, walking: 0.3, talking: 0.3 },
    socializing: { talking: 0.6, idle: 0.4 }
  };

  /**
   * Create a detailed humanoid NPC model
   */
  function createHumanoidNPC(archetype, THREE, agentId) {
    var group = new THREE.Group();
    var color = ARCHETYPE_COLORS[archetype] || 0xCCCCCC;
    var skinColor = getNpcSkinTone(agentId);
    var skinMat = new THREE.MeshStandardMaterial({ color: skinColor });

    // Head - skin colored sphere
    var headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
    var head = new THREE.Mesh(headGeometry, skinMat.clone());
    head.position.y = 1.6;
    head.castShadow = false;
    group.add(head);

    // Eyes
    var eyeGeo = new THREE.SphereGeometry(0.03, 8, 8);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var pupilGeo = new THREE.SphereGeometry(0.015, 8, 8);
    var pupilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

    var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.07, 0.03, 0.18);
    var leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
    leftPupil.position.z = 0.025;
    leftEye.add(leftPupil);
    head.add(leftEye);

    var rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
    rightEye.position.set(0.07, 0.03, 0.18);
    var rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
    rightPupil.position.z = 0.025;
    rightEye.add(rightPupil);
    head.add(rightEye);

    // Hair based on agentId hash
    var hairHash = Math.abs((agentId || '').length * 7 + (agentId || '').charCodeAt(0) || 0) % 4;
    var hairColors = [0x1a1a1a, 0x4a3000, 0x8B4513, 0xd4a574];
    var hairMat = new THREE.MeshStandardMaterial({ color: hairColors[hairHash] });
    if (hairHash === 0) {
      var buzzGeo = new THREE.SphereGeometry(0.21, 12, 12);
      var buzz = new THREE.Mesh(buzzGeo, hairMat);
      buzz.position.y = 0.02;
      buzz.scale.y = 0.85;
      head.add(buzz);
    } else if (hairHash === 1) {
      var longTopGeo = new THREE.SphereGeometry(0.22, 12, 12);
      var longTop = new THREE.Mesh(longTopGeo, hairMat);
      longTop.position.y = 0.04;
      longTop.scale.y = 0.8;
      head.add(longTop);
      var longBackGeo = new THREE.BoxGeometry(0.3, 0.25, 0.12);
      var longBack = new THREE.Mesh(longBackGeo, hairMat.clone());
      longBack.position.set(0, -0.12, -0.14);
      head.add(longBack);
    } else if (hairHash === 2) {
      var mohawkGeo = new THREE.BoxGeometry(0.06, 0.15, 0.3);
      var mohawk = new THREE.Mesh(mohawkGeo, hairMat);
      mohawk.position.y = 0.18;
      head.add(mohawk);
    } else {
      var bunGeo = new THREE.SphereGeometry(0.09, 8, 8);
      var bun = new THREE.Mesh(bunGeo, hairMat);
      bun.position.set(0, 0.08, -0.2);
      head.add(bun);
    }

    // Neck
    var neckGeo = new THREE.CylinderGeometry(0.07, 0.09, 0.12, 8);
    var neck = new THREE.Mesh(neckGeo, skinMat.clone());
    neck.position.y = 1.42;
    neck.castShadow = false;
    group.add(neck);

    // Torso - archetype colored box
    var torsoGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.25);
    var torsoMaterial = new THREE.MeshStandardMaterial({ color: color });
    var torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
    torso.position.y = 1.15;
    torso.castShadow = false;
    group.add(torso);

    // Shoulder joints
    var shoulderGeo = new THREE.SphereGeometry(0.08, 8, 8);
    var leftShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    leftShoulder.position.set(-0.28, 1.35, 0);
    leftShoulder.castShadow = false;
    group.add(leftShoulder);

    var rightShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    rightShoulder.position.set(0.28, 1.35, 0);
    rightShoulder.castShadow = false;
    group.add(rightShoulder);

    // Left Arm - cylinder
    var armGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 8);

    var leftArm = new THREE.Mesh(armGeometry, skinMat.clone());
    leftArm.position.set(-0.28, 1.15, 0);
    leftArm.castShadow = false;
    group.add(leftArm);

    // Hands as children of arms
    var handGeo = new THREE.SphereGeometry(0.05, 8, 8);
    var leftHand = new THREE.Mesh(handGeo, skinMat.clone());
    leftHand.position.y = -0.3;
    leftArm.add(leftHand);

    // Right Arm - cylinder
    var rightArm = new THREE.Mesh(armGeometry, skinMat.clone());
    rightArm.position.set(0.28, 1.15, 0);
    rightArm.castShadow = false;
    group.add(rightArm);

    var rightHand = new THREE.Mesh(handGeo, skinMat.clone());
    rightHand.position.y = -0.3;
    rightArm.add(rightHand);

    // Left Leg - cylinder
    var legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.55, 8);
    var legMaterial = new THREE.MeshStandardMaterial({ color: color });

    var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.12, 0.45, 0);
    leftLeg.castShadow = false;
    group.add(leftLeg);

    // Right Leg - cylinder
    var rightLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
    rightLeg.position.set(0.12, 0.45, 0);
    rightLeg.castShadow = false;
    group.add(rightLeg);

    // Store references in userData for animation
    group.userData.head = head;
    group.userData.torso = torso;
    group.userData.leftArm = leftArm;
    group.userData.rightArm = rightArm;
    group.userData.leftLeg = leftLeg;
    group.userData.rightLeg = rightLeg;

    // Add glow ring beneath NPC's feet
    var glowGeometry = new THREE.CircleGeometry(0.35, 16);
    var glowMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide
    });
    var glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
    glowRing.rotation.x = -Math.PI / 2;
    glowRing.position.y = 0.02;
    glowRing.castShadow = false;
    glowRing.receiveShadow = false;
    group.add(glowRing);
    group.userData.glowRing = glowRing;

    // Add archetype-specific accessories
    addAccessories(group, archetype, color, THREE);

    return group;
  }

  /**
   * Add archetype-specific accessories to humanoid model
   */
  function addAccessories(group, archetype, color, THREE) {
    var head = group.userData.head;
    var torso = group.userData.torso;
    var rightArm = group.userData.rightArm;

    switch (archetype) {
      case 'gardener':
        // Small green hat (flattened cylinder)
        var hatGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.08, 16);
        var hatMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
        var hat = new THREE.Mesh(hatGeom, hatMat);
        hat.position.y = 0.24;
        hat.castShadow = false;
        head.add(hat);
        // Small apron
        var gApronGeo = new THREE.BoxGeometry(0.32, 0.3, 0.02);
        var gApronMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        var gApron = new THREE.Mesh(gApronGeo, gApronMat);
        gApron.position.set(0, -0.08, 0.14);
        gApron.castShadow = false;
        torso.add(gApron);
        break;

      case 'builder':
        // Hard hat (yellow half-sphere)
        var hardHatGeom = new THREE.SphereGeometry(0.22, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        var hardHatMat = new THREE.MeshStandardMaterial({ color: 0xFFEB3B });
        var hardHat = new THREE.Mesh(hardHatGeom, hardHatMat);
        hardHat.position.y = 0.2;
        hardHat.castShadow = false;
        head.add(hardHat);
        // Tool belt (thin torus around waist)
        var beltGeo = new THREE.TorusGeometry(0.25, 0.03, 8, 16);
        var beltMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
        var belt = new THREE.Mesh(beltGeo, beltMat);
        belt.position.set(0, -0.2, 0);
        belt.rotation.x = Math.PI / 2;
        belt.castShadow = false;
        torso.add(belt);
        break;

      case 'storyteller':
        // Book in hand (small box)
        var bookGeom = new THREE.BoxGeometry(0.08, 0.12, 0.02);
        var bookMat = new THREE.MeshStandardMaterial({ color: 0x6A1B9A });
        var book = new THREE.Mesh(bookGeom, bookMat);
        book.position.set(0.08, -0.15, 0.08);
        book.rotation.z = Math.PI / 6;
        book.castShadow = false;
        rightArm.add(book);
        group.userData.accessory = book;
        // Cape/cloak behind torso
        var capeGeo = new THREE.ConeGeometry(0.3, 0.9, 12);
        var capeMat = new THREE.MeshStandardMaterial({ color: 0x4A148C });
        var cape = new THREE.Mesh(capeGeo, capeMat);
        cape.position.set(0, -0.1, -0.18);
        cape.castShadow = false;
        torso.add(cape);
        break;

      case 'merchant':
        // Apron (flat box in front of torso)
        var apronGeom = new THREE.BoxGeometry(0.35, 0.4, 0.02);
        var apronMat = new THREE.MeshStandardMaterial({ color: 0xC5A400 });
        var apron = new THREE.Mesh(apronGeom, apronMat);
        apron.position.set(0, 0, 0.14);
        apron.castShadow = false;
        torso.add(apron);
        break;

      case 'explorer':
        // Backpack (box behind torso)
        var backpackGeom = new THREE.BoxGeometry(0.3, 0.35, 0.15);
        var backpackMat = new THREE.MeshStandardMaterial({ color: 0x00838F });
        var backpack = new THREE.Mesh(backpackGeom, backpackMat);
        backpack.position.set(0, 0.05, -0.2);
        backpack.castShadow = false;
        torso.add(backpack);
        break;

      case 'teacher':
        // Glasses (thin torus in front of head)
        var glassesGeom = new THREE.TorusGeometry(0.12, 0.015, 8, 16);
        var glassesMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        var glasses = new THREE.Mesh(glassesGeom, glassesMat);
        glasses.position.set(0, 0, 0.18);
        glasses.rotation.y = Math.PI / 2;
        glasses.castShadow = false;
        head.add(glasses);
        break;

      case 'musician':
        // Instrument (cylinder next to body)
        var instrumentGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 12);
        var instrumentMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        var instrument = new THREE.Mesh(instrumentGeom, instrumentMat);
        instrument.position.set(0.35, 1.0, 0);
        instrument.rotation.z = Math.PI / 4;
        instrument.castShadow = false;
        group.add(instrument);
        group.userData.accessory = instrument;
        break;

      case 'healer':
        // Cross emblem (two thin crossed boxes)
        var crossMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
        var crossVertGeom = new THREE.BoxGeometry(0.06, 0.2, 0.02);
        var crossHorGeom = new THREE.BoxGeometry(0.2, 0.06, 0.02);
        var crossVert = new THREE.Mesh(crossVertGeom, crossMat);
        var crossHor = new THREE.Mesh(crossHorGeom, crossMat.clone());
        crossVert.position.set(0, 0.05, 0.14);
        crossHor.position.set(0, 0.05, 0.14);
        crossVert.castShadow = false;
        crossHor.castShadow = false;
        torso.add(crossVert);
        torso.add(crossHor);
        // White robe from waist
        var healRobeGeo = new THREE.ConeGeometry(0.3, 0.9, 12);
        var healRobeMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
        var healRobe = new THREE.Mesh(healRobeGeo, healRobeMat);
        healRobe.position.y = 0.35;
        healRobe.castShadow = false;
        group.add(healRobe);
        break;

      case 'philosopher':
        // Long robe (cone extending from torso to ground)
        var robeGeom = new THREE.ConeGeometry(0.35, 1.2, 16);
        var robeMat = new THREE.MeshStandardMaterial({ color: 0x303F9F });
        var robe = new THREE.Mesh(robeGeom, robeMat);
        robe.position.y = 0.3;
        robe.castShadow = false;
        group.add(robe);
        break;

      case 'artist':
        // Beret (flattened sphere on head, tilted)
        var beretGeom = new THREE.SphereGeometry(0.22, 16, 16);
        var beretMat = new THREE.MeshStandardMaterial({ color: 0xD84315 });
        var beret = new THREE.Mesh(beretGeom, beretMat);
        beret.scale.set(1, 0.4, 1);
        beret.position.set(0.05, 0.22, 0);
        beret.rotation.z = Math.PI / 8;
        beret.castShadow = false;
        head.add(beret);
        break;
    }
  }

  /**
   * Create emote sprite with canvas drawing
   * @param {string} emoteType - Type of emote (heart, music, hammer, etc.)
   * @returns {THREE.SpriteMaterial}
   */
  function createEmoteSprite(emoteType, THREE) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;

    // Clear with transparency
    ctx.clearRect(0, 0, 64, 64);

    const cx = 32;
    const cy = 32;

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    switch (emoteType) {
      case 'heart':
        // Pink heart - two arcs + triangle
        ctx.fillStyle = '#FF69B4';
        ctx.beginPath();
        ctx.arc(24, 26, 8, Math.PI, 0, false);
        ctx.arc(40, 26, 8, Math.PI, 0, false);
        ctx.lineTo(32, 46);
        ctx.closePath();
        ctx.fill();
        break;

      case 'music':
        // Blue music notes
        ctx.fillStyle = '#4169E1';
        ctx.strokeStyle = '#4169E1';
        ctx.lineWidth = 2;
        // First note
        ctx.beginPath();
        ctx.arc(22, 40, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(26, 40);
        ctx.lineTo(26, 20);
        ctx.stroke();
        // Second note
        ctx.beginPath();
        ctx.arc(36, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(40, 42);
        ctx.lineTo(40, 22);
        ctx.stroke();
        // Beam
        ctx.beginPath();
        ctx.moveTo(26, 20);
        ctx.lineTo(40, 22);
        ctx.stroke();
        break;

      case 'hammer':
        // Brown hammer
        ctx.fillStyle = '#8B4513';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        // Handle
        ctx.fillRect(28, 24, 4, 20);
        ctx.strokeRect(28, 24, 4, 20);
        // Head
        ctx.fillRect(18, 20, 20, 8);
        ctx.strokeRect(18, 20, 20, 8);
        break;

      case 'leaf':
        // Green leaf
        ctx.fillStyle = '#4CAF50';
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(32, 32, 10, 16, Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Center vein
        ctx.beginPath();
        ctx.moveTo(32, 18);
        ctx.lineTo(32, 46);
        ctx.stroke();
        break;

      case 'book':
        // Purple book
        ctx.fillStyle = '#9C27B0';
        ctx.strokeStyle = '#6A1B9A';
        ctx.lineWidth = 2;
        ctx.fillRect(18, 22, 28, 20);
        ctx.strokeRect(18, 22, 28, 20);
        // Spine
        ctx.beginPath();
        ctx.moveTo(32, 22);
        ctx.lineTo(32, 42);
        ctx.stroke();
        // Pages
        ctx.strokeStyle = '#E1BEE7';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(20, 22);
        ctx.lineTo(20, 42);
        ctx.stroke();
        break;

      case 'star':
        // Gold star
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
          const r = i % 2 === 0 ? 14 : 6;
          const x = cx + r * Math.cos(angle);
          const y = cy + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        break;

      case 'zzz':
        // Gray Zzz
        ctx.fillStyle = '#888888';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('Z', 18, 38);
        ctx.font = 'bold 12px Arial';
        ctx.fillText('Z', 28, 30);
        ctx.font = 'bold 10px Arial';
        ctx.fillText('Z', 36, 24);
        break;

      case 'eye':
        // Cyan eye
        ctx.fillStyle = '#00BCD4';
        ctx.strokeStyle = '#0097A7';
        ctx.lineWidth = 2;
        // Outer eye
        ctx.beginPath();
        ctx.ellipse(32, 32, 14, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Pupil
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(32, 32, 5, 0, Math.PI * 2);
        ctx.fill();
        // Highlight
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(30, 30, 2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case '!':
        // Yellow exclamation
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        // Bar
        ctx.fillRect(28, 18, 8, 18);
        ctx.strokeRect(28, 18, 8, 18);
        // Dot
        ctx.beginPath();
        ctx.arc(32, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      case '?':
        // White question mark
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#CCCCCC';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;

      case 'compass':
        // Teal compass
        ctx.strokeStyle = '#00BCD4';
        ctx.fillStyle = '#00BCD4';
        ctx.lineWidth = 2;
        // Circle
        ctx.beginPath();
        ctx.arc(32, 32, 14, 0, Math.PI * 2);
        ctx.stroke();
        // N arrow
        ctx.beginPath();
        ctx.moveTo(32, 20);
        ctx.lineTo(28, 28);
        ctx.lineTo(32, 26);
        ctx.lineTo(36, 28);
        ctx.closePath();
        ctx.fill();
        // S indicator
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(32, 44, 2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'coins':
        // Gold coins
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        // Back coin
        ctx.beginPath();
        ctx.arc(26, 34, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Middle coin
        ctx.beginPath();
        ctx.arc(34, 30, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Front coin
        ctx.beginPath();
        ctx.arc(30, 38, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      default:
        return null;
    }

    const texture = new THREE.CanvasTexture(canvas);
    return new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      opacity: 1.0
    });
  }

  /**
   * Create quest indicator sprite
   * @param {string} indicatorType - 'available', 'active', 'complete'
   * @param {object} THREE
   * @returns {THREE.Sprite}
   */
  function createQuestIndicator(indicatorType, THREE) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;

    ctx.clearRect(0, 0, 64, 64);

    var cx = 32, cy = 32;

    switch (indicatorType) {
      case 'available':
        // Yellow exclamation mark
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        ctx.fillRect(28, 18, 8, 18);
        ctx.strokeRect(28, 18, 8, 18);
        ctx.beginPath();
        ctx.arc(32, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      case 'active':
        // Grey question mark
        ctx.fillStyle = '#AAAAAA';
        ctx.strokeStyle = '#888888';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;

      case 'complete':
        // Green question mark
        ctx.fillStyle = '#00FF00';
        ctx.strokeStyle = '#00CC00';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;
    }

    var texture = new THREE.CanvasTexture(canvas);
    var material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    var sprite = new THREE.Sprite(material);
    sprite.scale.set(0.6, 0.6, 1);
    sprite.position.y = 2.2; // Above NPC head

    return sprite;
  }

  /**
   * Create activity indicator mesh (3D icon above NPC head)
   * @param {string} activityState - 'working', 'talking', 'walking', 'idle'
   * @param {object} THREE
   * @returns {THREE.Mesh}
   */
  function createActivityIndicator(activityState, THREE) {
    var geometry;
    var material;
    var mesh;

    switch (activityState) {
      case 'working':
        // Small rotating orange cube
        geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        material = new THREE.MeshBasicMaterial({ color: 0xFF8C00, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.userData.rotationSpeed = 2.0;
        break;

      case 'talking':
      case 'socializing':
        // White speech bubble (stretched sphere)
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.scale.set(1.2, 0.8, 0.6);
        mesh.userData.rotationSpeed = 0;
        break;

      case 'walking':
        // Green arrow pointing forward (cone rotated)
        geometry = new THREE.ConeGeometry(0.08, 0.2, 6);
        material = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = Math.PI / 2;
        mesh.userData.rotationSpeed = 0;
        break;

      case 'idle':
      default:
        // Blue floating diamond (octahedron)
        geometry = new THREE.OctahedronGeometry(0.1, 0);
        material = new THREE.MeshBasicMaterial({ color: 0x00BFFF, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.userData.rotationSpeed = 1.0;
        break;
    }

    mesh.position.y = 2.1; // Above NPC head, below name plate
    mesh.castShadow = false;
    mesh.receiveShadow = false;

    return mesh;
  }

  /**
   * Update quest indicators for NPCs
   * @param {string} playerId - Player ID for quest state
   * @param {object} playerPos - Player position (for proximity check)
   */
  function updateQuestIndicators(playerId, playerPos) {
    var THREE = window.THREE;
    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    if (!THREE || !Quests || !playerId) return;

    lastPlayerIdForQuests = playerId;

    npcAgents.forEach(function(agent) {
      var mesh = npcMeshes.get(agent.id);
      if (!mesh) return;

      // Only update indicators for NPCs within 50 units
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        if (Math.sqrt(dx * dx + dz * dz) > 50) {
          // Remove indicator if too far
          var existing = questIndicators.get(agent.id);
          if (existing) {
            mesh.remove(existing.sprite);
            questIndicators.delete(agent.id);
          }
          return;
        }
      }

      // Get quest state for this NPC
      var npcQuests = Quests.getNpcQuests(agent.id, playerId);
      var indicatorType = null;

      if (npcQuests.length > 0) {
        var questInfo = npcQuests[0]; // Use first quest
        if (questInfo.state === 'available') {
          indicatorType = 'available';
        } else if (questInfo.state === 'active') {
          indicatorType = 'active';
        } else if (questInfo.state === 'complete') {
          indicatorType = 'complete';
        }
      }

      // Update or remove indicator
      var existing = questIndicators.get(agent.id);

      if (indicatorType === null) {
        // No quest, remove indicator
        if (existing) {
          mesh.remove(existing.sprite);
          questIndicators.delete(agent.id);
        }
      } else {
        // Need indicator
        if (!existing || existing.type !== indicatorType) {
          // Remove old indicator
          if (existing) {
            mesh.remove(existing.sprite);
          }
          // Create new indicator
          var sprite = createQuestIndicator(indicatorType, THREE);
          mesh.add(sprite);
          questIndicators.set(agent.id, { sprite: sprite, type: indicatorType });
        }
      }
    });
  }

  /**
   * Update emote indicator for an NPC
   * @param {object} agent - NPC agent
   * @param {object} state - NPC state
   * @param {object} mesh - NPC mesh
   * @param {object} playerPos - Player position {x, z} or null
   * @param {object} decision - AI decision (optional)
   */
  function updateEmoteIndicator(agent, state, mesh, playerPos, decision) {
    const THREE = window.THREE;
    if (!THREE) return;

    let desiredEmote = null;

    // Check player proximity first (highest priority)
    if (playerPos) {
      const dx = playerPos.x - agent.position.x;
      const dz = playerPos.z - agent.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < 8) {
        desiredEmote = 'eye';
      }
    }

    // Check AI decision overrides
    if (decision && (decision.type === 'greet' || decision.type === 'react')) {
      desiredEmote = '!';
    }

    // Otherwise, map state + archetype to emote
    if (!desiredEmote) {
      const currentState = state.currentState;
      const archetype = agent.archetype;

      if (currentState === 'idle' && archetype === 'philosopher') {
        desiredEmote = '?';
      } else if (currentState === 'walking') {
        if (archetype === 'explorer') {
          desiredEmote = 'compass';
        }
      } else if (currentState === 'working') {
        switch (archetype) {
          case 'gardener': desiredEmote = 'leaf'; break;
          case 'builder': desiredEmote = 'hammer'; break;
          case 'musician': desiredEmote = 'music'; break;
          case 'teacher': desiredEmote = 'book'; break;
          case 'merchant': desiredEmote = 'coins'; break;
          case 'artist': desiredEmote = 'star'; break;
          case 'storyteller': desiredEmote = 'book'; break;
          case 'healer': desiredEmote = 'heart'; break;
          case 'philosopher': desiredEmote = 'book'; break;
          case 'explorer': desiredEmote = 'compass'; break;
        }
      } else if (currentState === 'talking' || currentState === 'socializing') {
        desiredEmote = 'heart';
      } else if (currentState === 'idle') {
        // Check for rest-related state timer patterns (long idle = resting)
        if (state.stateTimer > 10) {
          desiredEmote = 'zzz';
        }
      }
    }

    // Get or create emote sprite data
    let emoteData = emoteSprites.get(agent.id);

    // Update emote if changed
    if (desiredEmote !== (emoteData ? emoteData.currentEmote : null)) {
      // Remove old sprite
      if (emoteData && emoteData.sprite) {
        mesh.remove(emoteData.sprite);
      }

      // Create new sprite if needed
      if (desiredEmote) {
        const material = createEmoteSprite(desiredEmote, THREE);
        if (material) {
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(0.5, 0.5, 1);
          sprite.position.y = 2.8;
          mesh.add(sprite);

          emoteData = {
            sprite: sprite,
            currentEmote: desiredEmote,
            opacity: 0,
            timer: 0
          };
          emoteSprites.set(agent.id, emoteData);
        }
      } else {
        // No emote, clear data
        emoteSprites.delete(agent.id);
        emoteData = null;
      }
    }

    // Fade in/out animation
    if (emoteData && emoteData.sprite) {
      if (emoteData.opacity < 1.0) {
        emoteData.opacity = Math.min(1.0, emoteData.opacity + 0.05);
        emoteData.sprite.material.opacity = emoteData.opacity;
      }
      emoteData.timer += 0.016; // ~60fps assumption
    }
  }

  /**
   * Update activity indicator for an NPC
   * @param {object} agent - NPC agent
   * @param {object} state - NPC state
   * @param {object} mesh - NPC mesh
   * @param {number} deltaTime - Time delta for animations
   */
  function updateActivityIndicator(agent, state, mesh, deltaTime) {
    var THREE = window.THREE;
    if (!THREE) return;

    var desiredActivity = state.currentState;

    // Get or create activity indicator data
    var indicatorData = activityIndicators.get(agent.id);

    // Update activity indicator if changed
    if (desiredActivity !== (indicatorData ? indicatorData.currentActivity : null)) {
      // Remove old mesh
      if (indicatorData && indicatorData.mesh) {
        mesh.remove(indicatorData.mesh);
      }

      // Create new mesh
      var indicatorMesh = createActivityIndicator(desiredActivity, THREE);
      if (indicatorMesh) {
        mesh.add(indicatorMesh);

        indicatorData = {
          mesh: indicatorMesh,
          currentActivity: desiredActivity,
          bobTimer: 0
        };
        activityIndicators.set(agent.id, indicatorData);
      }
    }

    // Animate the indicator (floating bob and rotation)
    if (indicatorData && indicatorData.mesh) {
      // Floating bob animation
      indicatorData.bobTimer += deltaTime * 2.0;
      indicatorData.mesh.position.y = 2.1 + Math.sin(indicatorData.bobTimer) * 0.08;

      // Rotation animation (if applicable)
      if (indicatorData.mesh.userData.rotationSpeed > 0) {
        indicatorData.mesh.rotation.y += deltaTime * indicatorData.mesh.userData.rotationSpeed;
      }
    }
  }

  /**
   * Spawn activity particle near NPC
   * @param {THREE.Group} npcMesh - NPC mesh
   * @param {string} archetype - NPC archetype
   * @param {THREE} THREE - Three.js library
   */
  function spawnActivityParticle(npcMesh, archetype, THREE) {
    if (!THREE) return;
    if (activityParticles.length >= 20) return; // Global particle limit

    // Count particles for this NPC
    const npcParticleCount = activityParticles.filter(p => p.npcId === npcMesh.userData.agentId).length;
    if (npcParticleCount >= 3) return; // Per-NPC limit

    // Determine particle color and type based on archetype
    let color, size;
    switch (archetype) {
      case 'gardener':
        color = 0x4CAF50; // green
        size = 0.05;
        break;
      case 'builder':
        color = 0x8D6E63; // brown
        size = 0.06;
        break;
      case 'musician':
        color = Math.random() > 0.5 ? 0x4169E1 : 0xFF69B4; // blue or pink
        size = 0.04;
        break;
      case 'artist':
        // Rainbow colors
        const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
        color = colors[Math.floor(Math.random() * colors.length)];
        size = 0.05;
        break;
      case 'healer':
        color = Math.random() > 0.5 ? 0xFFFFFF : 0xFFD700; // white or gold
        size = 0.04;
        break;
      default:
        return; // No particles for other archetypes
    }

    // Create particle geometry (reuse or create)
    const geometry = new THREE.SphereGeometry(size, 6, 6);
    const material = new THREE.MeshBasicMaterial({ color: color, transparent: true });
    const particle = new THREE.Mesh(geometry, material);

    // Position near NPC's hands (approximate)
    const handOffset = Math.random() > 0.5 ? 0.3 : -0.3;
    particle.position.set(
      npcMesh.position.x + handOffset + (Math.random() - 0.5) * 0.2,
      npcMesh.position.y + 1.0 + Math.random() * 0.2,
      npcMesh.position.z + (Math.random() - 0.5) * 0.2
    );

    // Add to scene
    if (storedSceneContext && storedSceneContext.scene) {
      storedSceneContext.scene.add(particle);
    } else {
      return; // Can't add particle without scene
    }

    // Track particle
    activityParticles.push({
      mesh: particle,
      timer: 2.0, // 2 second lifetime
      velocity: {
        x: (Math.random() - 0.5) * 0.1,
        y: 0.3 + Math.random() * 0.2, // upward drift
        z: (Math.random() - 0.5) * 0.1
      },
      startY: particle.position.y,
      npcId: npcMesh.userData.agentId
    });
  }

  /**
   * Update activity particles
   * @param {number} deltaTime - Frame delta time
   */
  function updateActivityParticles(deltaTime) {
    if (!storedSceneContext || !storedSceneContext.scene) return;

    for (let i = activityParticles.length - 1; i >= 0; i--) {
      const particle = activityParticles[i];
      particle.timer -= deltaTime;

      if (particle.timer <= 0) {
        // Remove particle
        storedSceneContext.scene.remove(particle.mesh);
        activityParticles.splice(i, 1);
      } else {
        // Update position
        particle.mesh.position.x += particle.velocity.x * deltaTime;
        particle.mesh.position.y += particle.velocity.y * deltaTime;
        particle.mesh.position.z += particle.velocity.z * deltaTime;

        // Fade out based on timer
        const fadeProgress = particle.timer / 2.0;
        particle.mesh.material.opacity = fadeProgress;

        // Slow down upward velocity slightly over time
        particle.velocity.y *= 0.98;
      }
    }
  }

  /**
   * Initialize NPCs
   */
  function initNPCs(agentsData, gameState, sceneContext) {
    console.log('Initializing AI citizens...');

    if (agentsData) {
      npcAgents = agentsData.agents || agentsData;
    } else {
      // Use embedded agents data (no fetch needed â€” single-file app)
      npcAgents = EMBEDDED_AGENTS;
    }

    console.log('Loaded ' + npcAgents.length + ' AI citizens');
    initNPCStates();

    if (sceneContext && sceneContext.scene) {
      addNPCsToScene(sceneContext);
    }
  }

  /**
   * Initialize NPC behavior states
   */
  function initNPCStates() {
    // Re-check for NpcAI module (may have loaded after npcs.js)
    if (!NpcAI && typeof window !== 'undefined') NpcAI = window.NpcAI;

    npcAgents.forEach(agent => {
      npcStates.set(agent.id, {
        currentState: 'idle',
        stateTimer: 5,
        destination: null,
        targetNPC: null,
        lookAngle: 0,
        animationTime: Math.random() * 1000,
        currentActivity: 'idle',
        lastActivityUpdate: 0,
        targetZone: agent.position.zone,
        targetPosition: null,
        movementSpeed: 0,
        idleTimer: Math.random() * 3
      });

      // Create AI brain for each NPC (if NpcAI available)
      if (NpcAI && NpcAI.createNpcBrain) {
        var brain = NpcAI.createNpcBrain(agent.archetype, agent.id);
        npcBrains.set(agent.id, brain);
      }
    });

    if (NpcAI) {
      console.log('NPC AI brains initialized for ' + npcBrains.size + ' agents');
    } else {
      console.log('NpcAI not loaded â€” using fallback behavior');
    }
  }

  /**
   * Add NPCs to 3D scene
   */
  function addNPCsToScene(sceneContext) {
    if (!sceneContext || !sceneContext.scene) return;

    const THREE = window.THREE;
    if (!THREE) return;

    // Store scene context for particle system
    storedSceneContext = sceneContext;

    npcAgents.forEach(agent => {
      // Create detailed humanoid NPC with unique skin tone
      const group = createHumanoidNPC(agent.archetype, THREE, agent.id);

      // Name label with archetype subtitle
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 96;

      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Draw name (larger and bolder)
      context.font = 'Bold 32px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.fillText(agent.name, canvas.width / 2, 42);

      // Draw archetype subtitle
      context.font = '20px Arial';
      context.fillStyle = 'rgba(255, 255, 255, 0.8)';
      var archetypeCapitalized = agent.archetype.charAt(0).toUpperCase() + agent.archetype.slice(1);
      context.fillText(archetypeCapitalized, canvas.width / 2, 70);

      const labelTexture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
      const label = new THREE.Sprite(labelMaterial);
      label.scale.set(2.5, 1.0, 1);
      label.position.y = 2.5;
      group.add(label);

      // Position NPC - convert zone-relative to world coordinates
      var zoneCenter = ZONE_CENTERS[agent.position.zone] || {x: 0, z: 0};
      group.position.set(
        zoneCenter.x + agent.position.x,
        agent.position.y,
        zoneCenter.z + agent.position.z
      );

      // Update agent position to world coordinates for movement calculations
      agent.position.x += zoneCenter.x;
      agent.position.z += zoneCenter.z;

      // Store agent ID in mesh userData for particle system
      group.userData.agentId = agent.id;

      // Store reference
      npcMeshes.set(agent.id, group);

      // Add to scene (initially hidden)
      group.visible = false;
      sceneContext.scene.add(group);
    });

    console.log(`Added ${npcMeshes.size} NPC meshes to scene`);
  }

  /**
   * Update NPC activity based on daily schedule
   * @param {object} agent - NPC agent
   * @param {object} state - NPC state
   * @param {number} worldTime - Current world time in minutes
   */
  function updateNPCActivity(agent, state, worldTime) {
    if (!worldTime && worldTime !== 0) return; // No world time provided

    // Get current scheduled activity
    var scheduledActivity = getNPCSchedule(agent.archetype, worldTime);

    // Check if activity has changed
    if (state.currentActivity !== scheduledActivity) {
      state.currentActivity = scheduledActivity;
      state.lastActivityUpdate = worldTime;

      // Determine target zone for this activity
      var targetZone = getActivityZone(agent.archetype, scheduledActivity);

      // If zone changed, set destination to new zone center
      if (targetZone !== state.targetZone) {
        state.targetZone = targetZone;
        var zoneCenter = ZONE_CENTERS[targetZone];
        if (zoneCenter) {
          // Set destination near zone center with some randomness
          var angle = Math.random() * Math.PI * 2;
          var radius = 5 + Math.random() * 15;
          state.destination = {
            x: zoneCenter.x + Math.cos(angle) * radius,
            z: zoneCenter.z + Math.sin(angle) * radius
          };
          state.currentState = 'walking';
        }
      }

      // Map activity to behavior state
      var activityToBehavior = {
        // Working activities
        tending_garden: 'working',
        harvesting: 'working',
        planting: 'working',
        watering: 'working',
        building: 'working',
        painting: 'working',
        creating: 'working',
        composing: 'working',
        practicing: 'working',
        making_medicine: 'working',
        gathering_herbs: 'working',
        // Social activities
        selling: 'talking',
        teaching: 'talking',
        lecturing: 'talking',
        debating: 'talking',
        storytelling: 'talking',
        sharing_stories: 'talking',
        performing_crowd: 'talking',
        // Quiet activities
        reading: 'idle',
        studying: 'idle',
        researching: 'idle',
        writing: 'idle',
        contemplating: 'idle',
        meditating: 'idle',
        resting: 'idle',
        sleeping: 'idle',
        // Movement activities
        wandering_agora: 'walking',
        exploring: 'walking',
        setting_out: 'walking',
        returning: 'walking',
        // Other
        opening_shop: 'working',
        closing_shop: 'working',
        maintenance: 'working',
        planning: 'idle',
        mapping: 'working',
        performing: 'working',
        sketching: 'working',
        displaying_work: 'talking'
      };

      var behaviorState = activityToBehavior[scheduledActivity] || 'idle';

      // Only change behavior if not already walking to new zone
      if (state.currentState !== 'walking' || !state.destination) {
        state.currentState = behaviorState;
        var duration = BEHAVIOR_STATES[behaviorState].duration;
        state.stateTimer = duration[0] + Math.random() * (duration[1] - duration[0]);
      }
    }
  }

  /**
   * Update NPCs (called every frame)
   */
  function updateNPCs(sceneContext, gameState, deltaTime, worldTime, worldState) {
    if (npcAgents.length === 0) return;
    npcUpdateFrame++;

    // Re-check for NpcAI module (may have loaded after init)
    if (!NpcAI && typeof window !== 'undefined' && window.NpcAI) {
      NpcAI = window.NpcAI;
      // Late-init brains for NPCs that don't have one
      npcAgents.forEach(function(agent) {
        if (!npcBrains.has(agent.id) && NpcAI.createNpcBrain) {
          npcBrains.set(agent.id, NpcAI.createNpcBrain(agent.archetype, agent.id));
        }
      });
      console.log('NpcAI late-loaded, brains initialized');
    }

    // Process pending events
    if (NpcAI && pendingEvents.length > 0) {
      var events = pendingEvents.slice();
      pendingEvents = [];
      events.forEach(function(event) {
        npcBrains.forEach(function(brain) {
          if (NpcAI.handleEvent) NpcAI.handleEvent(brain.memory, event);
        });
      });
    }

    var timeSeed = Math.floor(worldTime);
    var playerPos = worldState && worldState.playerPosition ? worldState.playerPosition : null;

    npcAgents.forEach(function(agent, index) {
      var state = npcStates.get(agent.id);
      if (!state) return;

      // Performance: stagger AI updates by distance
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        // Far NPCs update less frequently
        if (dist > 300) return; // skip entirely
        if (dist > 150 && npcUpdateFrame % 10 !== index % 10) return;
        if (dist > 50 && npcUpdateFrame % 3 !== index % 3) return;
      }

      // Update activity based on schedule (only if worldTime provided)
      if (worldTime || worldTime === 0) {
        updateNPCActivity(agent, state, worldTime);
      }

      state.animationTime += deltaTime * 1000;

      // Use NpcAI brain if available
      var brain = npcBrains.get(agent.id);
      if (brain && NpcAI && NpcAI.updateBrain) {
        // Build world state for AI perception
        var aiWorldState = {
          weather: worldState ? worldState.weather : 'clear',
          timeOfDay: worldState ? worldState.timePeriod : 'midday',
          currentHour: worldTime ? worldTime / 60 : 12,
          currentZone: agent.position.zone,
          nearbyPlayers: [],
          nearbyNPCs: [],
          allNPCs: npcAgents
        };

        // Add player info for perception
        if (playerPos && worldState) {
          var pdx = playerPos.x - agent.position.x;
          var pdz = playerPos.z - agent.position.z;
          var pDist = Math.sqrt(pdx * pdx + pdz * pdz);
          if (pDist < 25) {
            aiWorldState.nearbyPlayers.push({
              id: worldState.playerId || 'player',
              distance: pDist,
              direction: { x: pdx, z: pdz },
              isBuilding: false,
              isHarvesting: false
            });
          }
        }

        // Add nearby NPCs for perception
        npcAgents.forEach(function(other) {
          if (other.id === agent.id) return;
          var ndx = other.position.x - agent.position.x;
          var ndz = other.position.z - agent.position.z;
          var nDist = Math.sqrt(ndx * ndx + ndz * ndz);
          if (nDist < 25) {
            var otherBrain = npcBrains.get(other.id);
            aiWorldState.nearbyNPCs.push({
              id: other.id,
              distance: nDist,
              direction: { x: ndx, z: ndz },
              archetype: other.archetype,
              currentActivity: otherBrain ? NpcAI.getGoal(otherBrain) : 'idle',
              mood: otherBrain ? NpcAI.getMood(otherBrain) : 'neutral'
            });
          }
        });

        // Get AI decision
        var npcObj = { x: agent.position.x, z: agent.position.z, name: agent.name, zone: agent.position.zone };
        var decision = NpcAI.updateBrain(brain, npcObj, aiWorldState);

        // Execute decision
        if (decision) {
          // Store decision in brain for emote system access
          brain.lastDecision = decision;
          executeAIDecision(agent, state, decision, deltaTime);
        }
      } else {
        // Fallback to original behavior
        if (state.currentState !== 'walking' && state.currentState !== 'socializing') {
          state.stateTimer -= deltaTime;
          if (state.stateTimer <= 0) {
            transitionState(agent, state, timeSeed + index);
          }
        }
        updateNPCBehavior(agent, state, deltaTime, timeSeed + index);
      }

      updateNPCVisual(agent, state, sceneContext, deltaTime, playerPos);
    });

    // NPC-to-NPC conversations: trigger multi-line exchanges for collaborating pairs
    if (NpcAI && NpcAI.generateConversation && npcUpdateFrame % 120 === 0) {
      npcAgents.forEach(function(agent) {
        var state = npcStates.get(agent.id);
        if (!state || state.currentState !== 'collaborating' || !state.collaborateTarget) return;
        if (chatBubbles.has(agent.id)) return; // Already showing dialogue

        var partner = npcAgents.find(function(a) { return a.id === state.collaborateTarget; });
        if (!partner) return;

        var convo = NpcAI.generateConversation(agent.name, agent.archetype, partner.name, partner.archetype);
        if (convo && convo.length > 0) {
          // Show first two lines immediately (one per NPC), then stagger the rest
          showChatBubbleWithText(agent, convo[0]);
          if (convo.length > 1) {
            showChatBubbleWithText(partner, convo[1]);
          }
        }
      });
    }

    updateChatBubbles(deltaTime);
    updateActivityParticles(deltaTime);
    updateSpeechBubbleTimers(deltaTime);

    // Trigger random ambient speech for visible NPCs
    npcAgents.forEach(function(agent) {
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        // Only trigger speech for nearby NPCs
        if (dist < 100) {
          triggerRandomSpeech(agent, deltaTime);
        }
      } else {
        triggerRandomSpeech(agent, deltaTime);
      }
    });
  }

  /**
   * Execute an AI brain decision â€” translates decision to movement/animation/dialogue
   */
  function executeAIDecision(agent, state, decision, deltaTime) {
    // Map AI decision type to NPC state
    switch (decision.type) {
      case 'walk_to':
      case 'wander':
      case 'explore':
      case 'approach_social':
      case 'seek_shelter':
        if (decision.target) {
          state.destination = { x: decision.target.x, z: decision.target.z };
          state.targetPosition = { x: decision.target.x, z: decision.target.z };
          state.currentState = 'walking';
          // Smooth interpolation toward target
          var dx = state.targetPosition.x - agent.position.x;
          var dz = state.targetPosition.z - agent.position.z;
          var dist = Math.sqrt(dx * dx + dz * dz);
          if (dist > 0.5) {
            var speed = decision.speed || 1.5;
            state.movementSpeed = speed;
            var moveAmount = speed * deltaTime;
            var ratio = Math.min(moveAmount / dist, 1);
            agent.position.x += dx * ratio;
            agent.position.z += dz * ratio;
            state.lookAngle = Math.atan2(dx, dz);
          } else {
            state.currentState = 'idle';
            state.destination = null;
            state.targetPosition = null;
            state.movementSpeed = 0;
          }
        }
        break;

      case 'work':
        state.currentState = 'working';
        state.stateTimer = 5 + Math.random() * 10;
        break;

      case 'collaborate':
        state.currentState = 'collaborating';
        state.stateTimer = 6 + Math.random() * 8;
        state.collaborateTarget = decision.targetNPC;
        state.collaborateDesc = decision.activityDesc;
        if (decision.facing) {
          state.lookAngle = Math.atan2(
            decision.facing.x - agent.position.x,
            decision.facing.z - agent.position.z
          );
        }
        break;

      case 'socialize':
      case 'join_group':
        state.currentState = 'talking';
        state.stateTimer = 4 + Math.random() * 3;
        break;

      case 'greet':
      case 'react':
        state.currentState = 'talking';
        state.stateTimer = 3;
        if (decision.facing) {
          state.lookAngle = Math.atan2(
            decision.facing.x - agent.position.x,
            decision.facing.z - agent.position.z
          );
        }
        break;

      case 'rest':
        state.currentState = 'idle';
        state.stateTimer = 8 + Math.random() * 10;
        break;

      case 'idle':
      default:
        state.currentState = 'idle';
        state.stateTimer = 3 + Math.random() * 5;
        break;
    }

    // Show dialogue if the decision includes one
    if (decision.dialogue) {
      showChatBubbleWithText(agent, decision.dialogue);
    }
  }

  /**
   * Show chat bubble with specific text (from AI brain)
   */
  function showChatBubbleWithText(agent, text) {
    var mesh = npcMeshes.get(agent.id);
    if (!mesh) return;
    var THREE = window.THREE;
    if (!THREE) return;

    // Remove existing bubble
    var existing = chatBubbles.get(agent.id);
    if (existing) { mesh.remove(existing.mesh); }

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 128;

    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    context.lineWidth = 4;

    var x = 10, y = 10, w = canvas.width - 20, h = canvas.height - 20, r = 15;
    context.beginPath();
    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);
    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);
    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);
    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);
    context.quadraticCurveTo(x, y, x + r, y);
    context.closePath();
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '18px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    var words = text.split(' ');
    var line = '', y_pos = 50;
    for (var i = 0; i < words.length; i++) {
      var testLine = line + words[i] + ' ';
      if (context.measureText(testLine).width > 480 && line !== '') {
        context.fillText(line, canvas.width / 2, y_pos);
        line = words[i] + ' ';
        y_pos += 22;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, canvas.width / 2, y_pos);

    var bubbleTexture = new THREE.CanvasTexture(canvas);
    var bubbleMaterial = new THREE.SpriteMaterial({ map: bubbleTexture });
    var bubble = new THREE.Sprite(bubbleMaterial);
    bubble.scale.set(4, 1, 1);
    bubble.position.y = 3.5;
    mesh.add(bubble);
    chatBubbles.set(agent.id, { mesh: bubble, timer: 5 });
  }

  /**
   * Transition NPC to new state
   */
  function transitionState(agent, state, seed) {
    const transitions = STATE_TRANSITIONS[state.currentState];
    if (!transitions) return;

    // Weighted random selection
    let roll = seededRandom(seed);
    let cumulative = 0;
    let newState = 'idle';

    for (const [stateName, weight] of Object.entries(transitions)) {
      cumulative += weight;
      if (roll < cumulative) {
        newState = stateName;
        break;
      }
    }

    // Set new state
    state.currentState = newState;

    // Set duration
    const durationRange = BEHAVIOR_STATES[newState].duration;
    const duration = durationRange[0] +
      seededRandom(seed + 1) * (durationRange[1] - durationRange[0]);
    state.stateTimer = duration;

    // State-specific setup
    switch (newState) {
      case 'walking':
        // Pick random nearby destination within zone bounds
        var zoneCenter = ZONE_CENTERS[agent.position.zone] || {x: 0, z: 0};
        var wAngle = seededRandom(seed + 2) * Math.PI * 2;
        var wDist = 5 + seededRandom(seed + 3) * 20;
        var destX = agent.position.x + Math.cos(wAngle) * wDist;
        var destZ = agent.position.z + Math.sin(wAngle) * wDist;
        // Keep within zone radius (~60 units from zone center)
        var zoneRadius = 60;
        var dxFromCenter = destX - zoneCenter.x;
        var dzFromCenter = destZ - zoneCenter.z;
        var distFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dzFromCenter * dzFromCenter);
        if (distFromCenter > zoneRadius) {
          destX = zoneCenter.x + (dxFromCenter / distFromCenter) * zoneRadius;
          destZ = zoneCenter.z + (dzFromCenter / distFromCenter) * zoneRadius;
        }
        // Keep away from zone center structure
        var centerDist = Math.sqrt((destX - zoneCenter.x) * (destX - zoneCenter.x) + (destZ - zoneCenter.z) * (destZ - zoneCenter.z));
        if (centerDist < 10) {
          destX = zoneCenter.x + (destX - zoneCenter.x) / centerDist * 12;
          destZ = zoneCenter.z + (destZ - zoneCenter.z) / centerDist * 12;
        }
        state.destination = { x: destX, z: destZ };
        break;

      case 'talking':
        // Show chat bubble
        showChatBubble(agent, seed);
        break;

      case 'socializing':
        // Find nearby NPCs by actual distance
        const nearby = npcAgents.filter(other => {
          if (other.id === agent.id) return false;
          var dx = other.position.x - agent.position.x;
          var dz = other.position.z - agent.position.z;
          return Math.sqrt(dx * dx + dz * dz) < 50; // within 50 units
        });
        if (nearby.length > 0) {
          state.targetNPC = randomChoice(nearby, seed + 4);
          state.destination = {
            x: state.targetNPC.position.x,
            z: state.targetNPC.position.z
          };
        } else {
          // No one nearby, go to idle
          state.currentState = 'idle';
          state.stateTimer = 5;
        }
        break;
    }
  }

  /**
   * Update NPC behavior
   */
  function updateNPCBehavior(agent, state, deltaTime, seed) {
    switch (state.currentState) {
      case 'idle':
        // Slowly rotate/look around
        state.lookAngle += (seededRandom(seed) - 0.5) * deltaTime * 0.5;
        break;

      case 'walking':
      case 'socializing':
        if (state.destination) {
          // Smooth interpolation toward destination
          const dx = state.destination.x - agent.position.x;
          const dz = state.destination.z - agent.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);

          if (distance > 0.5) {
            const speed = 1.5; // units per second
            state.movementSpeed = speed;
            const moveAmount = speed * deltaTime;
            const ratio = Math.min(moveAmount / distance, 1);

            agent.position.x += dx * ratio;
            agent.position.z += dz * ratio;

            // Update look angle to face movement direction
            state.lookAngle = Math.atan2(dx, dz);
          } else {
            // Reached destination
            state.movementSpeed = 0;
            if (state.currentState === 'socializing') {
              // Switch to talking
              state.currentState = 'talking';
              state.stateTimer = 4 + seededRandom(seed) * 2;
              showChatBubble(agent, seed);
            } else {
              // Switch to idle
              state.currentState = 'idle';
              state.stateTimer = 5;
            }
            state.destination = null;
            state.targetPosition = null;
          }
        }
        break;

      case 'working':
        // Animation handled in visual update
        break;

      case 'talking':
        // Chat bubble visible (handled separately)
        break;
    }
  }

  /**
   * Apply procedural animations to NPC
   */
  function applyAnimations(mesh, state, agent) {
    const userData = mesh.userData;
    if (!userData.head || !userData.torso) return;

    const time = state.animationTime;
    const currentState = state.currentState;

    // Reset rotations to neutral
    userData.leftArm.rotation.x = 0;
    userData.leftArm.rotation.z = 0;
    userData.rightArm.rotation.x = 0;
    userData.rightArm.rotation.z = 0;
    userData.leftLeg.rotation.x = 0;
    userData.rightLeg.rotation.x = 0;
    userData.head.rotation.x = 0;
    userData.head.rotation.y = 0;
    userData.torso.scale.y = 1;

    switch (currentState) {
      case 'idle':
        // Subtle breathing - torso Y scale oscillation
        const breathPhase = Math.sin(time * 0.002);
        userData.torso.scale.y = 1.0 + breathPhase * 0.02;

        // Gentle head sway
        userData.head.rotation.y = Math.sin(time * 0.001) * 0.05;

        // Occasional head turn (every ~3 seconds)
        state.idleTimer -= 0.016; // approx deltaTime
        if (state.idleTimer <= 0) {
          state.idleTimer = 3 + Math.random() * 3;
        }
        var headTurnPhase = Math.max(0, 1 - state.idleTimer / 0.5); // Quick turn
        if (state.idleTimer < 0.5) {
          userData.head.rotation.y += Math.sin(headTurnPhase * Math.PI) * 0.3;
        }

        // Subtle weight shift
        var weightShift = Math.sin(time * 0.0008) * 0.02;
        mesh.position.y = weightShift;
        userData.torso.rotation.z = weightShift * 0.5;
        break;

      case 'walking':
      case 'socializing':
        // Walking animation proportional to movement speed
        var walkSpeedMultiplier = Math.max(0.5, state.movementSpeed || 1.5) / 1.5;
        var walkFrequency = 0.008 * walkSpeedMultiplier;

        // Legs alternate - more pronounced swing
        var legSwing = Math.sin(time * walkFrequency) * 0.5 * walkSpeedMultiplier;
        userData.leftLeg.rotation.x = legSwing;
        userData.rightLeg.rotation.x = -legSwing;

        // Arms swing opposite to legs - natural pendulum motion
        var armSwing = Math.sin(time * walkFrequency + Math.PI) * 0.35 * walkSpeedMultiplier;
        userData.leftArm.rotation.x = armSwing;
        userData.rightArm.rotation.x = -armSwing;

        // Torso bob - up and down motion during walk
        var bobPhase = Math.abs(Math.sin(time * walkFrequency));
        mesh.position.y = bobPhase * 0.08 * walkSpeedMultiplier;

        // Slight torso sway side-to-side
        userData.torso.rotation.z = Math.sin(time * walkFrequency * 0.5) * 0.03;

        // Head slight sway for natural movement
        userData.head.rotation.z = Math.sin(time * walkFrequency * 0.5) * 0.02;
        userData.head.rotation.y = Math.sin(time * walkFrequency * 0.3) * 0.03;

        // Head faces movement direction (handled by mesh rotation)
        break;

      case 'talking':
        // Arms gesture - slight rotation on varied timing
        userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.15;
        userData.rightArm.rotation.x = Math.sin(time * 0.004 + 1.5) * 0.15;
        userData.leftArm.rotation.z = Math.sin(time * 0.0025) * 0.1;
        userData.rightArm.rotation.z = -Math.sin(time * 0.0035) * 0.1;

        // Head nods
        userData.head.rotation.x = Math.sin(time * 0.005) * 0.1;
        break;

      case 'working':
        // Archetype-specific working animations
        switch (agent.archetype) {
          case 'gardener':
            // Bent over, arms reaching down
            userData.torso.rotation.x = 0.3;
            userData.leftArm.rotation.x = 0.5;
            userData.rightArm.rotation.x = 0.5;
            userData.head.rotation.x = 0.2;
            break;

          case 'builder':
            // Arm hammering motion
            const hammerPhase = Math.sin(time * 0.006);
            userData.rightArm.rotation.x = -0.5 + hammerPhase * 0.8;
            userData.leftArm.rotation.x = 0.2;
            break;

          case 'merchant':
            // Standing with slight arm gestures
            userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.2;
            userData.rightArm.rotation.x = -0.3 + Math.sin(time * 0.004) * 0.1;
            break;

          case 'musician':
            // Arms positioned as if playing
            userData.leftArm.rotation.x = -0.8;
            userData.leftArm.rotation.z = 0.5;
            userData.rightArm.rotation.x = -0.6;
            userData.rightArm.rotation.z = -0.3;
            // Slight bobbing
            mesh.position.y = Math.sin(time * 0.004) * 0.03;
            break;

          default:
            // Generic arm motion
            userData.leftArm.rotation.x = Math.sin(time * 0.004) * 0.3;
            userData.rightArm.rotation.x = Math.sin(time * 0.005 + Math.PI) * 0.3;
            break;
        }
        break;

      case 'collaborating':
        // Two-person interaction: animated gesturing, facing partner
        userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.25 - 0.3;
        userData.rightArm.rotation.x = Math.sin(time * 0.004 + 1) * 0.2 - 0.2;
        userData.leftArm.rotation.z = Math.sin(time * 0.002) * 0.15 + 0.1;
        userData.rightArm.rotation.z = -Math.sin(time * 0.0025) * 0.15 - 0.1;
        // Head nods and turns
        userData.head.rotation.x = Math.sin(time * 0.005) * 0.12;
        userData.head.rotation.y = Math.sin(time * 0.002) * 0.08;
        // Slight weight shifting
        mesh.position.y = Math.sin(time * 0.002) * 0.02;
        break;
    }

    // Animate glow ring - subtle pulsing
    if (userData.glowRing) {
      var pulseFactor = Math.sin(time * 0.003) * 0.1 + 0.9;
      userData.glowRing.material.opacity = 0.4 * pulseFactor;
    }
  }

  /**
   * Update NPC visual representation
   */
  function updateNPCVisual(agent, state, sceneContext, deltaTime, playerPos) {
    const mesh = npcMeshes.get(agent.id);
    if (!mesh) return;
    const THREE = window.THREE;
    if (!THREE) return;

    // Update position with smooth interpolation
    const lerpFactor = Math.min(deltaTime * 5, 1);
    mesh.position.x += (agent.position.x - mesh.position.x) * lerpFactor;
    mesh.position.z += (agent.position.z - mesh.position.z) * lerpFactor;

    // Adjust Y to terrain height if World module available
    var World = typeof window !== 'undefined' ? window.World : null;
    if (World && World.getTerrainHeight) {
      var terrainY = World.getTerrainHeight(mesh.position.x, mesh.position.z);
      mesh.position.y = terrainY;
    }

    // Update rotation (facing direction) with smooth interpolation
    var targetRotation = mesh.rotation.y;
    if (state.currentState === 'walking' || state.currentState === 'socializing') {
      targetRotation = state.lookAngle;
    } else if (state.currentState === 'collaborating' && state.collaborateTarget) {
      // Face the partner NPC
      var partnerMesh = npcMeshes.get(state.collaborateTarget);
      if (partnerMesh) {
        var cdx = partnerMesh.position.x - mesh.position.x;
        var cdz = partnerMesh.position.z - mesh.position.z;
        targetRotation = Math.atan2(cdx, cdz);
      }
    }

    // Smooth rotation interpolation - handle angle wrapping
    var angleDiff = targetRotation - mesh.rotation.y;
    // Normalize angle difference to [-PI, PI]
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    var rotationSpeed = state.currentState === 'walking' ? 8 : 3;
    mesh.rotation.y += angleDiff * Math.min(deltaTime * rotationSpeed, 1);

    // Apply procedural animations
    applyAnimations(mesh, state, agent);

    // Update emote indicator (only for NPCs within 30 units of camera/player)
    if (playerPos || sceneContext.camera) {
      let checkPos = playerPos;
      if (!checkPos && sceneContext.camera) {
        checkPos = { x: sceneContext.camera.position.x, z: sceneContext.camera.position.z };
      }

      if (checkPos) {
        const dx = checkPos.x - agent.position.x;
        const dz = checkPos.z - agent.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 30) {
          // Get AI decision if available (from brain)
          let decision = null;
          const brain = npcBrains.get(agent.id);
          if (brain && brain.lastDecision) {
            decision = brain.lastDecision;
          }

          updateEmoteIndicator(agent, state, mesh, playerPos, decision);

          // Update activity indicator
          updateActivityIndicator(agent, state, mesh, deltaTime);

          // Spawn activity particles for working NPCs (throttled)
          if (state.currentState === 'working') {
            let spawnTimer = particleSpawnTimers.get(agent.id) || 0;
            spawnTimer -= deltaTime;
            if (spawnTimer <= 0) {
              spawnActivityParticle(mesh, agent.archetype, THREE);
              particleSpawnTimers.set(agent.id, 1.0); // 1 second throttle
            } else {
              particleSpawnTimers.set(agent.id, spawnTimer);
            }
          }
        } else {
          // Too far - remove emote sprite if exists
          const emoteData = emoteSprites.get(agent.id);
          if (emoteData && emoteData.sprite) {
            mesh.remove(emoteData.sprite);
            emoteSprites.delete(agent.id);
          }
          // Also remove activity indicator
          const indicatorData = activityIndicators.get(agent.id);
          if (indicatorData && indicatorData.mesh) {
            mesh.remove(indicatorData.mesh);
            activityIndicators.delete(agent.id);
          }
        }
      }
    }
  }

  /**
   * Show chat bubble for NPC
   */
  function showChatBubble(agent, seed) {
    var message;
    var state = npcStates.get(agent.id);

    // Use activity-based dialogue if available
    if (state && state.currentActivity && state.currentActivity !== 'idle') {
      message = getActivityDialogue(state.currentActivity);
    } else {
      // Fallback to archetype messages
      const messages = ARCHETYPE_MESSAGES[agent.archetype] || ['...'];
      message = randomChoice(messages, seed);
    }

    const mesh = npcMeshes.get(agent.id);
    if (!mesh) return;

    const THREE = window.THREE;
    if (!THREE) return;

    // Remove existing bubble if any
    const existing = chatBubbles.get(agent.id);
    if (existing) {
      mesh.remove(existing.mesh);
    }

    // Create chat bubble sprite
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 128;

    // Background
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    context.lineWidth = 4;

    // Rounded rectangle
    const x = 10, y = 10, w = canvas.width - 20, h = canvas.height - 20, r = 15;
    context.beginPath();
    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);
    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);
    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);
    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);
    context.quadraticCurveTo(x, y, x + r, y);
    context.closePath();
    context.fill();
    context.stroke();

    // Text
    context.fillStyle = 'black';
    context.font = '20px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    // Word wrap
    const words = message.split(' ');
    let line = '';
    let y_pos = 64;
    const maxWidth = 480;

    for (let word of words) {
      const testLine = line + word + ' ';
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && line !== '') {
        context.fillText(line, canvas.width / 2, y_pos - 10);
        line = word + ' ';
        y_pos += 25;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, canvas.width / 2, y_pos - 10);

    const bubbleTexture = new THREE.CanvasTexture(canvas);
    const bubbleMaterial = new THREE.SpriteMaterial({ map: bubbleTexture });
    const bubble = new THREE.Sprite(bubbleMaterial);
    bubble.scale.set(4, 1, 1);
    bubble.position.y = 3.5;

    mesh.add(bubble);
    chatBubbles.set(agent.id, {
      mesh: bubble,
      timer: 5 // display for 5 seconds
    });
  }

  /**
   * Update chat bubbles (fade out)
   */
  function updateChatBubbles(deltaTime) {
    for (const [agentId, bubble] of chatBubbles.entries()) {
      bubble.timer -= deltaTime;

      if (bubble.timer <= 0) {
        // Remove bubble
        const npcMesh = npcMeshes.get(agentId);
        if (npcMesh) {
          npcMesh.remove(bubble.mesh);
        }
        chatBubbles.delete(agentId);
      } else if (bubble.timer < 1) {
        // Fade out
        bubble.mesh.material.opacity = bubble.timer;
      }
    }
  }

  /**
   * Initialize speech bubble container
   */
  function initSpeechBubbleContainer() {
    if (!speechBubbleContainer) {
      speechBubbleContainer = document.createElement('div');
      speechBubbleContainer.id = 'npc-speech-bubbles';
      speechBubbleContainer.style.position = 'absolute';
      speechBubbleContainer.style.top = '0';
      speechBubbleContainer.style.left = '0';
      speechBubbleContainer.style.width = '100%';
      speechBubbleContainer.style.height = '100%';
      speechBubbleContainer.style.pointerEvents = 'none';
      speechBubbleContainer.style.zIndex = '100';
      document.body.appendChild(speechBubbleContainer);
    }
  }

  /**
   * Show a speech bubble above an NPC's head
   * @param {string} npcId - NPC ID
   * @param {string} message - Message to display
   */
  function showNPCSpeechBubble(npcId, message) {
    initSpeechBubbleContainer();

    // Remove existing bubble for this NPC
    var existing = speechBubbles.get(npcId);
    if (existing && existing.element) {
      speechBubbleContainer.removeChild(existing.element);
    }

    // Create new bubble element
    var bubble = document.createElement('div');
    bubble.style.position = 'absolute';
    bubble.style.padding = '8px 12px';
    bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
    bubble.style.border = '2px solid rgba(0, 0, 0, 0.3)';
    bubble.style.borderRadius = '12px';
    bubble.style.fontSize = '14px';
    bubble.style.fontFamily = 'Arial, sans-serif';
    bubble.style.color = '#333';
    bubble.style.whiteSpace = 'nowrap';
    bubble.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
    bubble.style.transition = 'opacity 0.3s ease-out';
    bubble.textContent = message;

    speechBubbleContainer.appendChild(bubble);

    // Store bubble data
    speechBubbles.set(npcId, {
      element: bubble,
      timer: 3.0 // Display for 3 seconds
    });
  }

  /**
   * Update speech bubble positions based on camera projection
   * @param {THREE.Camera} camera - The camera to project from
   */
  function updateSpeechBubbles(camera) {
    if (!camera || !speechBubbleContainer) return;

    var THREE = window.THREE;
    if (!THREE) return;

    // Get renderer size for projection
    var width = window.innerWidth;
    var height = window.innerHeight;

    for (var [npcId, bubble] of speechBubbles.entries()) {
      var npcMesh = npcMeshes.get(npcId);
      if (!npcMesh) {
        // NPC no longer exists, remove bubble
        if (bubble.element) {
          speechBubbleContainer.removeChild(bubble.element);
        }
        speechBubbles.delete(npcId);
        continue;
      }

      // Calculate position above NPC's head (y = 2.2 is above head at 1.6)
      var worldPos = new THREE.Vector3();
      npcMesh.getWorldPosition(worldPos);
      worldPos.y += 2.2;

      // Project to screen coordinates
      var screenPos = worldPos.clone();
      screenPos.project(camera);

      // Convert to pixel coordinates
      var x = (screenPos.x * 0.5 + 0.5) * width;
      var y = (-screenPos.y * 0.5 + 0.5) * height;

      // Check if behind camera
      if (screenPos.z > 1) {
        bubble.element.style.display = 'none';
      } else {
        bubble.element.style.display = 'block';
        bubble.element.style.left = x + 'px';
        bubble.element.style.top = y + 'px';
        bubble.element.style.transform = 'translate(-50%, -100%)';
      }
    }
  }

  /**
   * Update speech bubble timers and remove expired ones
   * @param {number} deltaTime - Time since last frame
   */
  function updateSpeechBubbleTimers(deltaTime) {
    for (var [npcId, bubble] of speechBubbles.entries()) {
      bubble.timer -= deltaTime;

      if (bubble.timer <= 0) {
        // Remove expired bubble
        if (bubble.element) {
          speechBubbleContainer.removeChild(bubble.element);
        }
        speechBubbles.delete(npcId);
      } else if (bubble.timer < 0.5) {
        // Fade out in last 0.5 seconds
        if (bubble.element) {
          bubble.element.style.opacity = (bubble.timer / 0.5).toString();
        }
      }
    }
  }

  /**
   * Clear all speech bubbles
   */
  function clearSpeechBubbles() {
    for (var [npcId, bubble] of speechBubbles.entries()) {
      if (bubble.element) {
        speechBubbleContainer.removeChild(bubble.element);
      }
    }
    speechBubbles.clear();
  }

  /**
   * Trigger random ambient speech for NPCs
   * Called periodically from updateNPCs
   */
  function triggerRandomSpeech(agent, deltaTime) {
    // Initialize next speech time if not set
    var bubbleData = speechBubbles.get(agent.id);
    if (!bubbleData) {
      bubbleData = {
        element: null,
        timer: 0,
        nextSpeechTime: 15 + Math.random() * 15 // Random 15-30 seconds
      };
      speechBubbles.set(agent.id, bubbleData);
    }

    // Don't show speech if already showing a bubble
    if (bubbleData.element && bubbleData.timer > 0) {
      return;
    }

    // Countdown to next speech
    bubbleData.nextSpeechTime -= deltaTime;

    if (bubbleData.nextSpeechTime <= 0) {
      // Time to speak! Get archetype-specific message
      var messages = ARCHETYPE_SPEECH[agent.archetype];
      if (!messages || messages.length === 0) {
        messages = ["Hello!", "Beautiful day!", "Greetings!"];
      }

      var message = messages[Math.floor(Math.random() * messages.length)];
      showNPCSpeechBubble(agent.id, message);

      // Schedule next speech in 15-30 seconds
      bubbleData.nextSpeechTime = 15 + Math.random() * 15;
    }
  }

  /**
   * Reload NPCs for current zone (or by distance on unified world)
   */
  function reloadZoneNPCs(sceneContext, currentZone, playerPos) {
    if (!playerPos) {
      // Fallback: show all NPCs in current zone
      npcMeshes.forEach((mesh, agentId) => {
        const agent = npcAgents.find(a => a.id === agentId);
        if (agent) {
          mesh.visible = (agent.position.zone === currentZone);
        }
      });
      console.log(`Showing NPCs for zone: ${currentZone}`);
    } else {
      // Show NPCs within 200 units of player
      var viewDist = 200;
      npcMeshes.forEach((mesh, agentId) => {
        const agent = npcAgents.find(a => a.id === agentId);
        if (agent) {
          var dx = agent.position.x - playerPos.x;
          var dz = agent.position.z - playerPos.z;
          var dist = Math.sqrt(dx * dx + dz * dz);
          mesh.visible = (dist < viewDist);
        }
      });
    }
  }

  /**
   * Get NPCs in a specific zone
   */
  function getNPCsInZone(zone) {
    return npcAgents.filter(agent => agent.position.zone === zone);
  }

  /**
   * Get specific NPC by ID
   */
  function getNPCById(id) {
    return npcAgents.find(agent => agent.id === id);
  }

  /**
   * Find nearest NPC to a world position within a max distance
   * @returns {object|null} - {agent, distance} or null
   */
  function findNearestNPC(worldX, worldZ, maxDist) {
    maxDist = maxDist || 10;
    var best = null;
    var bestDist = maxDist;
    for (var i = 0; i < npcAgents.length; i++) {
      var agent = npcAgents[i];
      var dx = agent.position.x - worldX;
      var dz = agent.position.z - worldZ;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < bestDist) {
        bestDist = dist;
        best = { agent: agent, distance: dist };
      }
    }
    return best;
  }

  /**
   * Interact with an NPC â€” triggers greeting dialogue and returns response
   * Includes quest system integration
   * @returns {object|null} - {name, message, archetype, hasQuest, questInfo}
   */
  function interactWithNPC(worldX, worldZ, playerId) {
    var nearest = findNearestNPC(worldX, worldZ, 8);
    if (!nearest) return null;

    var agent = nearest.agent;
    var seed = Date.now() * 0.001 + agent.id.charCodeAt(0);
    var brain = npcBrains.get(agent.id);
    var message, mood, activity, familiarity;

    // Check for quests from this NPC
    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    var questInfo = null;
    var hasQuest = false;

    if (Quests && playerId) {
      var npcQuests = Quests.getNpcQuests(agent.id, playerId);
      if (npcQuests.length > 0) {
        hasQuest = true;
        questInfo = npcQuests[0]; // Return first quest for now
      }
    }

    if (brain && NpcAI) {
      // Use AI brain for contextual dialogue
      var context = { category: 'greeting_first' };
      if (NpcAI.getDialogue) {
        // Build a simple perception for dialogue context
        message = NpcAI.getDialogue(brain.memory, context, agent.name);
      }
      mood = NpcAI.getMood ? NpcAI.getMood(brain) : 'neutral';
      activity = NpcAI.getGoal ? NpcAI.getGoal(brain) : '';
      familiarity = brain.memory && brain.memory.playerFamiliarity
        ? Math.round(Object.values(brain.memory.playerFamiliarity)[0] || 0)
        : 0;

      // Record interaction in brain memory
      if (NpcAI.handleEvent) {
        NpcAI.handleEvent(brain.memory, {
          type: 'player_interact',
          playerId: playerId || 'player',
          description: 'Player interacted directly'
        });
      }
      // Increase familiarity
      if (brain.memory && brain.memory.playerFamiliarity) {
        var pKey = Object.keys(brain.memory.playerFamiliarity)[0] || (playerId || 'player');
        brain.memory.playerFamiliarity[pKey] = Math.min(100, (brain.memory.playerFamiliarity[pKey] || 0) + 5);
        familiarity = Math.round(brain.memory.playerFamiliarity[pKey]);
      }
    }

    // Use quest dialogue if available
    if (questInfo && questInfo.quest && questInfo.quest.dialogue) {
      if (questInfo.state === 'available') {
        message = questInfo.quest.dialogue.offer;
      } else if (questInfo.state === 'active') {
        message = Quests.getQuestDialogue(questInfo.quest.id, 'progress', questInfo.quest);
      } else if (questInfo.state === 'complete') {
        message = questInfo.quest.dialogue.complete || 'Quest complete! Return to turn it in.';
      }
    }

    // Use schedule-based dialogue if no quest dialogue
    if (!message) {
      var state = npcStates.get(agent.id);
      if (state && state.currentActivity && state.currentActivity !== 'idle') {
        message = getActivityDialogue(state.currentActivity);
      }
    }

    // Fallback to random archetype message if no activity dialogue
    if (!message) {
      var messages = ARCHETYPE_MESSAGES[agent.archetype] || ['Hello there.'];
      message = randomChoice(messages, seed);
    }

    // Show chat bubble
    if (brain && NpcAI) {
      showChatBubbleWithText(agent, message);
    } else {
      showChatBubble(agent, seed);
    }

    return {
      name: agent.name,
      message: message,
      archetype: agent.archetype,
      mood: mood || 'neutral',
      activity: activity || '',
      familiarity: familiarity || 0,
      id: agent.id,
      hasQuest: hasQuest,
      questInfo: questInfo
    };
  }

  /**
   * Get all NPC positions for minimap rendering
   * @returns {Array} - [{x, z, name, archetype}]
   */
  function getNPCPositions() {
    return npcAgents.map(function(agent) {
      return {
        x: agent.position.x,
        z: agent.position.z,
        name: agent.name,
        archetype: agent.archetype,
        zone: agent.position.zone
      };
    });
  }

  /**
   * Broadcast an event to all NPC brains
   * @param {object} event - {type, data}
   */
  function broadcastEvent(event) {
    if (!event) return;
    // Convert event format for NpcAI
    var aiEvent = {
      type: event.type,
      description: event.type + ': ' + JSON.stringify(event.data || {}).substring(0, 100)
    };
    // Merge event data
    if (event.data) {
      if (event.data.weather) aiEvent.weather = event.data.weather;
      if (event.data.period) aiEvent.timeOfDay = event.data.period;
    }
    pendingEvents.push(aiEvent);
  }

  /**
   * Get NPC mood by ID
   */
  function getNPCMood(id) {
    var brain = npcBrains.get(id);
    if (brain && NpcAI && NpcAI.getMood) return NpcAI.getMood(brain);
    return 'neutral';
  }

  /**
   * Get NPC current goal by ID
   */
  function getNPCGoal(id) {
    var brain = npcBrains.get(id);
    if (brain && NpcAI && NpcAI.getGoal) return NpcAI.getGoal(brain);
    return 'idle';
  }

  /**
   * Get NPC current activity string
   */
  function getNPCActivity(id) {
    var state = npcStates.get(id);
    return state ? state.currentState : 'unknown';
  }

  /**
   * Play emote animation on player mesh
   * @param {THREE.Group} playerMesh - Player mesh group
   * @param {string} emoteType - Type of emote (wave, dance, bow, cheer, meditate, point)
   */
  function playEmoteAnimation(playerMesh, emoteType) {
    if (!playerMesh || !playerMesh.userData) return;

    var userData = playerMesh.userData;
    if (!userData.head || !userData.torso || !userData.leftArm || !userData.rightArm) return;

    // Cancel any existing emote animation
    if (playerMesh.userData.emoteAnimation) {
      clearTimeout(playerMesh.userData.emoteAnimation.timeout);
      cancelAnimationFrame(playerMesh.userData.emoteAnimation.frame);
    }

    var startTime = Date.now();
    var duration = 0;
    var emoteData = { type: emoteType, startTime: startTime };

    function animate() {
      var elapsed = (Date.now() - startTime) / 1000;
      var t = elapsed;

      // Reset to neutral first
      userData.leftArm.rotation.x = 0;
      userData.leftArm.rotation.z = 0;
      userData.rightArm.rotation.x = 0;
      userData.rightArm.rotation.z = 0;
      userData.leftLeg.rotation.x = 0;
      userData.rightLeg.rotation.x = 0;
      userData.head.rotation.x = 0;
      userData.head.rotation.y = 0;
      userData.torso.rotation.x = 0;
      playerMesh.position.y = 0;

      var isComplete = false;

      switch (emoteType) {
        case 'wave':
          // Right arm raises and sways side to side for 2 seconds
          duration = 2.0;
          if (elapsed < duration) {
            var waveProgress = Math.min(elapsed / 0.3, 1.0);
            userData.rightArm.rotation.x = -1.5 * waveProgress;
            userData.rightArm.rotation.z = -0.3 * waveProgress;
            var swayAmount = Math.sin(t * 6) * 0.4;
            userData.rightArm.rotation.y = swayAmount;
            userData.head.rotation.y = swayAmount * 0.3;
          } else {
            isComplete = true;
          }
          break;

        case 'dance':
          // Body bobs up/down, arms alternating raise, slight rotation for 3 seconds
          duration = 3.0;
          if (elapsed < duration) {
            var bobAmount = Math.sin(t * 4) * 0.15;
            playerMesh.position.y = Math.abs(bobAmount);
            userData.leftArm.rotation.x = -0.5 + Math.sin(t * 4) * 0.8;
            userData.rightArm.rotation.x = -0.5 + Math.sin(t * 4 + Math.PI) * 0.8;
            userData.torso.rotation.y = Math.sin(t * 3) * 0.15;
            userData.leftLeg.rotation.x = Math.sin(t * 4) * 0.3;
            userData.rightLeg.rotation.x = Math.sin(t * 4 + Math.PI) * 0.3;
          } else {
            isComplete = true;
          }
          break;

        case 'bow':
          // Upper body tilts forward 45 degrees then returns, 1.5 seconds
          duration = 1.5;
          if (elapsed < duration) {
            var bowProgress;
            if (elapsed < duration * 0.5) {
              bowProgress = (elapsed / (duration * 0.5));
            } else {
              bowProgress = 1.0 - ((elapsed - duration * 0.5) / (duration * 0.5));
            }
            userData.torso.rotation.x = bowProgress * 0.785;
            userData.head.rotation.x = bowProgress * 0.3;
            userData.leftArm.rotation.x = bowProgress * 0.2;
            userData.rightArm.rotation.x = bowProgress * 0.2;
          } else {
            isComplete = true;
          }
          break;

        case 'cheer':
          // Both arms raise up, small hop (y bounce), 2 seconds
          duration = 2.0;
          if (elapsed < duration) {
            var cheerProgress = Math.min(elapsed / 0.2, 1.0);
            userData.leftArm.rotation.x = -2.0 * cheerProgress;
            userData.leftArm.rotation.z = 0.3 * cheerProgress;
            userData.rightArm.rotation.x = -2.0 * cheerProgress;
            userData.rightArm.rotation.z = -0.3 * cheerProgress;
            var hopAmount = Math.abs(Math.sin(t * 5)) * 0.2;
            playerMesh.position.y = hopAmount;
          } else {
            isComplete = true;
          }
          break;

        case 'meditate':
          // Body lowers slightly, arms to sides, gentle floating motion, 3 seconds
          duration = 3.0;
          if (elapsed < duration) {
            var meditateProgress = Math.min(elapsed / 0.5, 1.0);
            playerMesh.position.y = -0.2 * meditateProgress + Math.sin(t * 2) * 0.03;
            userData.leftArm.rotation.x = 0.3 * meditateProgress;
            userData.leftArm.rotation.z = 0.5 * meditateProgress;
            userData.rightArm.rotation.x = 0.3 * meditateProgress;
            userData.rightArm.rotation.z = -0.5 * meditateProgress;
            userData.leftLeg.rotation.z = 0.4 * meditateProgress;
            userData.rightLeg.rotation.z = -0.4 * meditateProgress;
            userData.head.rotation.x = -0.2 * meditateProgress;
            userData.torso.rotation.x = -0.1 * meditateProgress;
          } else {
            isComplete = true;
          }
          break;

        case 'point':
          // Right arm extends forward, holds 1.5 seconds
          duration = 1.5;
          if (elapsed < duration) {
            var pointProgress = Math.min(elapsed / 0.3, 1.0);
            userData.rightArm.rotation.x = -1.2 * pointProgress;
            userData.rightArm.rotation.y = 0.2 * pointProgress;
            userData.rightArm.rotation.z = -0.1 * pointProgress;
            userData.head.rotation.y = 0.2 * pointProgress;
            userData.torso.rotation.y = 0.1 * pointProgress;
          } else {
            isComplete = true;
          }
          break;

        default:
          isComplete = true;
      }

      if (!isComplete) {
        emoteData.frame = requestAnimationFrame(animate);
      } else {
        // Return to neutral
        userData.leftArm.rotation.x = 0;
        userData.leftArm.rotation.y = 0;
        userData.leftArm.rotation.z = 0;
        userData.rightArm.rotation.x = 0;
        userData.rightArm.rotation.y = 0;
        userData.rightArm.rotation.z = 0;
        userData.leftLeg.rotation.x = 0;
        userData.leftLeg.rotation.z = 0;
        userData.rightLeg.rotation.x = 0;
        userData.rightLeg.rotation.z = 0;
        userData.head.rotation.x = 0;
        userData.head.rotation.y = 0;
        userData.torso.rotation.x = 0;
        userData.torso.rotation.y = 0;
        playerMesh.position.y = 0;
        playerMesh.userData.emoteAnimation = null;
      }
    }

    playerMesh.userData.emoteAnimation = emoteData;
    animate();
  }

  // Export public API
  exports.initNPCs = initNPCs;
  exports.updateNPCs = updateNPCs;
  exports.reloadZoneNPCs = reloadZoneNPCs;
  exports.getNPCsInZone = getNPCsInZone;
  exports.getNPCById = getNPCById;
  exports.findNearestNPC = findNearestNPC;
  exports.interactWithNPC = interactWithNPC;
  exports.getNPCPositions = getNPCPositions;
  exports.broadcastEvent = broadcastEvent;
  exports.getNPCMood = getNPCMood;
  exports.getNPCGoal = getNPCGoal;
  exports.getNPCActivity = getNPCActivity;
  exports.updateQuestIndicators = updateQuestIndicators;
  exports.playEmoteAnimation = playEmoteAnimation;
  exports.getNPCSchedule = getNPCSchedule;
  exports.getActivityDialogue = getActivityDialogue;
  exports.getActivityZone = getActivityZone;
  exports.getTimePeriod = getTimePeriod;
  exports.showNPCSpeechBubble = showNPCSpeechBubble;
  exports.updateSpeechBubbles = updateSpeechBubbles;
  exports.clearSpeechBubbles = clearSpeechBubbles;
  exports.getAgents = function() { return npcAgents; };
  exports.getNearbyNPCCount = function(playerPos, radius) {
    if (!playerPos || !npcAgents) return 0;
    var count = 0;
    for (var i = 0; i < npcAgents.length; i++) {
      var npc = npcAgents[i];
      if (!npc || !npc.x) continue;
      var dx = npc.x - playerPos.x;
      var dz = npc.z - playerPos.z;
      if (Math.sqrt(dx * dx + dz * dz) <= radius) count++;
    }
    return count;
  };

})(typeof module !== 'undefined' ? module.exports : (window.NPCs = {}));


// seasons.js
(function(exports) {
  // Seasonal events system based on real-world date

  // Season definitions with date ranges
  const SEASONS = {
    spring: {
      id: 'spring',
      name: 'Spring',
      description: 'A time of renewal and growth',
      startMonth: 2, // March (0-indexed)
      endMonth: 4,   // May
      festival: {
        name: 'Bloom Festival',
        description: 'Cherry blossoms fill the air with petals of hope',
        theme: 'flower'
      },
      colors: {
        primary: '#f8b4c8',
        secondary: '#7db37d',
        accent: '#ffd4e5',
        ambient: '#ffe8f0'
      },
      bonus: {
        activity: 'garden',
        multiplier: 1.25,
        description: 'Garden yields increased'
      }
    },
    summer: {
      id: 'summer',
      name: 'Summer',
      description: 'The warmth of endless days',
      startMonth: 5, // June
      endMonth: 7,   // August
      festival: {
        name: 'Sun Festival',
        description: 'Golden light dances with fireflies at dusk',
        theme: 'sun'
      },
      colors: {
        primary: '#f0c040',
        secondary: '#ff8c42',
        accent: '#ffe080',
        ambient: '#fff4d4'
      },
      bonus: {
        activity: 'exploration',
        multiplier: 1.25,
        description: 'Exploration rewards increased'
      }
    },
    autumn: {
      id: 'autumn',
      name: 'Autumn',
      description: 'The season of abundance and reflection',
      startMonth: 8,  // September
      endMonth: 10,   // November
      festival: {
        name: 'Harvest Festival',
        description: 'Leaves fall like amber rain, celebrating the bounty',
        theme: 'harvest'
      },
      colors: {
        primary: '#d4a040',
        secondary: '#8b4513',
        accent: '#e8b860',
        ambient: '#f0e0c0'
      },
      bonus: {
        activity: 'crafting',
        multiplier: 1.25,
        description: 'Crafting rewards increased'
      }
    },
    winter: {
      id: 'winter',
      name: 'Winter',
      description: 'A time of wonder and togetherness',
      startMonth: 11, // December (wraps to Feb)
      endMonth: 1,    // February
      festival: {
        name: 'Star Festival',
        description: 'Snowflakes drift beneath starlit skies',
        theme: 'star'
      },
      colors: {
        primary: '#80c0e0',
        secondary: '#e8e8ff',
        accent: '#a0d4f0',
        ambient: '#e0f0ff'
      },
      bonus: {
        activity: 'social',
        multiplier: 1.25,
        description: 'Social rewards increased'
      }
    }
  };

  // Seasonal items available per season
  const SEASONAL_ITEMS = {
    spring: [
      {
        id: 'cherry_blossom',
        name: 'Cherry Blossom',
        description: 'Delicate pink petals from the sacred trees',
        rarity: 'rare',
        type: 'decoration'
      },
      {
        id: 'spring_bouquet',
        name: 'Spring Bouquet',
        description: 'A vibrant arrangement of seasonal flowers',
        rarity: 'uncommon',
        type: 'gift'
      },
      {
        id: 'rainbow_seed',
        name: 'Rainbow Seed',
        description: 'A magical seed that blooms in seven colors',
        rarity: 'legendary',
        type: 'consumable'
      }
    ],
    summer: [
      {
        id: 'sun_crystal',
        name: 'Sun Crystal',
        description: 'Captures the warmth and light of summer',
        rarity: 'rare',
        type: 'material'
      },
      {
        id: 'firefly_jar',
        name: 'Firefly Jar',
        description: 'A gentle glow to light your path',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'tropical_fruit',
        name: 'Tropical Fruit',
        description: 'Sweet and refreshing, bursting with flavor',
        rarity: 'common',
        type: 'consumable'
      }
    ],
    autumn: [
      {
        id: 'golden_leaf',
        name: 'Golden Leaf',
        description: 'Preserved in its moment of perfect beauty',
        rarity: 'rare',
        type: 'material'
      },
      {
        id: 'pumpkin',
        name: 'Harvest Pumpkin',
        description: 'A symbol of the season\'s abundance',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'maple_syrup',
        name: 'Maple Syrup',
        description: 'Sweet nectar from ancient trees',
        rarity: 'common',
        type: 'consumable'
      }
    ],
    winter: [
      {
        id: 'snowglobe',
        name: 'Snowglobe',
        description: 'A miniature winter wonderland',
        rarity: 'rare',
        type: 'decoration'
      },
      {
        id: 'star_ornament',
        name: 'Star Ornament',
        description: 'Handcrafted decoration that sparkles like the night sky',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'hot_cocoa',
        name: 'Hot Cocoa',
        description: 'Warm comfort in a cup',
        rarity: 'common',
        type: 'consumable'
      }
    ]
  };

  // Decoration configurations per zone and season
  const SEASONAL_DECORATIONS = {
    spring: {
      town: [
        { type: 'cherry_tree', count: 8, positions: 'random' },
        { type: 'flower_bed', count: 12, positions: 'pathways' },
        { type: 'blossom_arch', count: 2, positions: 'entrances' }
      ],
      forest: [
        { type: 'wildflower_patch', count: 15, positions: 'random' },
        { type: 'butterfly_spawn', count: 6, positions: 'clearings' }
      ],
      plains: [
        { type: 'tulip_field', count: 10, positions: 'random' },
        { type: 'rainbow_garden', count: 3, positions: 'special' }
      ]
    },
    summer: {
      town: [
        { type: 'lantern_string', count: 10, positions: 'overhead' },
        { type: 'sun_banner', count: 6, positions: 'buildings' },
        { type: 'fountain_glow', count: 2, positions: 'center' }
      ],
      forest: [
        { type: 'firefly_cluster', count: 20, positions: 'random' },
        { type: 'sun_shaft', count: 8, positions: 'canopy_breaks' }
      ],
      plains: [
        { type: 'sunflower_field', count: 12, positions: 'random' },
        { type: 'heat_shimmer', count: 5, positions: 'distance' }
      ]
    },
    autumn: {
      town: [
        { type: 'hay_bale', count: 8, positions: 'random' },
        { type: 'harvest_wreath', count: 10, positions: 'doors' },
        { type: 'corn_stalk', count: 6, positions: 'corners' }
      ],
      forest: [
        { type: 'mushroom_circle', count: 5, positions: 'random' },
        { type: 'leaf_pile', count: 12, positions: 'clearings' }
      ],
      plains: [
        { type: 'scarecrow', count: 4, positions: 'fields' },
        { type: 'wheat_sheaf', count: 10, positions: 'random' }
      ]
    },
    winter: {
      town: [
        { type: 'star_decoration', count: 15, positions: 'random' },
        { type: 'ice_sculpture', count: 4, positions: 'plazas' },
        { type: 'warm_light', count: 20, positions: 'windows' }
      ],
      forest: [
        { type: 'frost_crystal', count: 12, positions: 'random' },
        { type: 'snow_drift', count: 8, positions: 'ground' }
      ],
      plains: [
        { type: 'frozen_pond', count: 2, positions: 'special' },
        { type: 'icicle_cluster', count: 6, positions: 'rock_formations' }
      ]
    }
  };

  // Particle system configurations per season
  const SEASONAL_PARTICLES = {
    spring: {
      type: 'cherry_blossom',
      count: 100,
      color: '#ffc0db',
      size: 0.3,
      speed: 0.02,
      drift: true,
      swirl: true,
      gravity: 0.001
    },
    summer: {
      type: 'firefly',
      count: 60,
      color: '#ffff80',
      size: 0.2,
      speed: 0.015,
      glow: true,
      pulse: true,
      gravity: 0
    },
    autumn: {
      type: 'falling_leaf',
      count: 80,
      color: '#d4a040',
      size: 0.4,
      speed: 0.025,
      drift: true,
      spin: true,
      gravity: 0.002
    },
    winter: {
      type: 'snowflake',
      count: 120,
      color: '#ffffff',
      size: 0.25,
      speed: 0.01,
      drift: true,
      sparkle: true,
      gravity: 0.0015
    }
  };

  // NPC greetings per season
  const SEASONAL_GREETINGS = {
    spring: [
      'The flowers are beautiful this season!',
      'Can you feel the renewal in the air?',
      'Perfect weather for the Bloom Festival!',
      'Spring brings such wonderful energy!'
    ],
    summer: [
      'Another glorious sunny day!',
      'The fireflies will be out tonight!',
      'Perfect season for adventure!',
      'The Sun Festival lights up everything!'
    ],
    autumn: [
      'The harvest has been bountiful this year!',
      'Don\'t the leaves look magnificent?',
      'Time to gather and give thanks!',
      'The Harvest Festival begins soon!'
    ],
    winter: [
      'Stay warm out there, traveler!',
      'The stars shine brightest in winter!',
      'What a magical time of year!',
      'The Star Festival brings us together!'
    ]
  };

  /**
   * Get the current season based on real-world date
   * @returns {Object} Current season data
   */
  function getCurrentSeason() {
    const now = new Date();
    const month = now.getMonth(); // 0-indexed (0 = January)

    // Check each season
    for (const seasonKey in SEASONS) {
      const season = SEASONS[seasonKey];

      // Handle winter's wrap-around (Dec, Jan, Feb)
      if (season.id === 'winter') {
        if (month >= season.startMonth || month <= season.endMonth) {
          return season;
        }
      } else {
        if (month >= season.startMonth && month <= season.endMonth) {
          return season;
        }
      }
    }

    // Fallback to spring
    return SEASONS.spring;
  }

  /**
   * Get seasonal items available during current season
   * @returns {Array} Array of seasonal items
   */
  function getSeasonalItems() {
    const season = getCurrentSeason();
    return SEASONAL_ITEMS[season.id] || [];
  }

  /**
   * Get seasonal decorations for a specific zone
   * @param {string} zone - Zone name (town, forest, plains)
   * @returns {Array} Array of decoration configurations
   */
  function getSeasonalDecorations(zone) {
    const season = getCurrentSeason();
    const decorations = SEASONAL_DECORATIONS[season.id];
    return decorations[zone] || [];
  }

  /**
   * Get particle configuration for current season
   * @returns {Object} Particle system configuration
   */
  function getSeasonalParticles() {
    const season = getCurrentSeason();
    return SEASONAL_PARTICLES[season.id];
  }

  /**
   * Get season bonus multiplier for an activity
   * @param {string} activity - Activity type (garden, exploration, crafting, social)
   * @returns {number} Multiplier (1.0 for no bonus, 1.25 for seasonal bonus)
   */
  function getSeasonBonus(activity) {
    const season = getCurrentSeason();
    if (season.bonus.activity === activity) {
      return season.bonus.multiplier;
    }
    return 1.0;
  }

  /**
   * Get days remaining until season ends
   * @returns {number} Days until season changes
   */
  function getDaysUntilSeasonEnd() {
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const season = getCurrentSeason();

    let endDate;

    // Handle winter's wrap-around
    if (season.id === 'winter') {
      if (currentMonth === 11) {
        // December - end is Feb 28/29 next year
        const nextYear = currentYear + 1;
        const isLeapYear = (nextYear % 4 === 0 && nextYear % 100 !== 0) || (nextYear % 400 === 0);
        endDate = new Date(nextYear, 1, isLeapYear ? 29 : 28, 23, 59, 59);
      } else {
        // Jan or Feb
        const isLeapYear = (currentYear % 4 === 0 && currentYear % 100 !== 0) || (currentYear % 400 === 0);
        endDate = new Date(currentYear, 1, isLeapYear ? 29 : 28, 23, 59, 59);
      }
    } else {
      // For other seasons, get last day of end month
      endDate = new Date(currentYear, season.endMonth + 1, 0, 23, 59, 59);
    }

    const msPerDay = 24 * 60 * 60 * 1000;
    const daysRemaining = Math.ceil((endDate - now) / msPerDay);

    return Math.max(0, daysRemaining);
  }

  /**
   * Get a random seasonal greeting for NPCs
   * @returns {string} Seasonal greeting text
   */
  function getSeasonalGreeting() {
    const season = getCurrentSeason();
    const greetings = SEASONAL_GREETINGS[season.id];
    return greetings[Math.floor(Math.random() * greetings.length)];
  }

  /**
   * Get color scheme for current season
   * @returns {Object} Color palette with primary, secondary, accent, ambient
   */
  function getSeasonalColors() {
    const season = getCurrentSeason();
    return season.colors;
  }

  // Export all functions and data
  exports.SEASONS = SEASONS;
  exports.SEASONAL_ITEMS = SEASONAL_ITEMS;
  exports.SEASONAL_DECORATIONS = SEASONAL_DECORATIONS;
  exports.SEASONAL_PARTICLES = SEASONAL_PARTICLES;
  exports.SEASONAL_GREETINGS = SEASONAL_GREETINGS;
  exports.getCurrentSeason = getCurrentSeason;
  exports.getSeasonalItems = getSeasonalItems;
  exports.getSeasonalDecorations = getSeasonalDecorations;
  exports.getSeasonalParticles = getSeasonalParticles;
  exports.getSeasonBonus = getSeasonBonus;
  exports.getDaysUntilSeasonEnd = getDaysUntilSeasonEnd;
  exports.getSeasonalGreeting = getSeasonalGreeting;
  exports.getSeasonalColors = getSeasonalColors;

})(typeof module !== 'undefined' ? module.exports : (window.Seasons = {}));


// pets.js
(function(exports) {
  // Pet companion system for ZION MMO

  // Pet type definitions with zones and rarities
  const PET_TYPES = [
    {
      id: 'cat',
      name: 'Mystic Cat',
      description: 'A wise feline companion that brings good fortune to trades',
      icon: 'ðŸ±',
      zone: 'commons',
      rarity: 'common',
      bonus: { type: 'trade_luck', value: 2 }
    },
    {
      id: 'fox',
      name: 'Spirit Fox',
      description: 'A clever fox with enhanced senses for discovering hidden places',
      icon: 'ðŸ¦Š',
      zone: 'wilds',
      rarity: 'uncommon',
      bonus: { type: 'discovery_range', value: 2 }
    },
    {
      id: 'owl',
      name: 'Ancient Owl',
      description: 'A scholarly owl that helps unlock hidden lore',
      icon: 'ðŸ¦‰',
      zone: 'athenaeum',
      rarity: 'uncommon',
      bonus: { type: 'lore_unlock', value: 2 }
    },
    {
      id: 'butterfly',
      name: 'Crystal Butterfly',
      description: 'A delicate butterfly that enhances garden growth',
      icon: 'ðŸ¦‹',
      zone: 'gardens',
      rarity: 'common',
      bonus: { type: 'garden_growth', value: 2 }
    },
    {
      id: 'rabbit',
      name: 'Moon Rabbit',
      description: 'A gentle rabbit that brings peace and faster crafting',
      icon: 'ðŸ°',
      zone: 'gardens',
      rarity: 'common',
      bonus: { type: 'craft_speed', value: 2 }
    },
    {
      id: 'frog',
      name: 'Jade Frog',
      description: 'A lucky frog that attracts rare resources',
      icon: 'ðŸ¸',
      zone: 'wilds',
      rarity: 'uncommon',
      bonus: { type: 'rare_resources', value: 2 }
    },
    {
      id: 'firefly',
      name: 'Ember Firefly',
      description: 'A glowing firefly that illuminates hidden paths',
      icon: 'ðŸª²',
      zone: 'wilds',
      rarity: 'rare',
      bonus: { type: 'vision_range', value: 3 }
    },
    {
      id: 'wolf_pup',
      name: 'Shadow Wolf Pup',
      description: 'A loyal wolf pup that boosts stamina and endurance',
      icon: 'ðŸº',
      zone: 'wilds',
      rarity: 'rare',
      bonus: { type: 'stamina', value: 3 }
    },
    {
      id: 'phoenix_chick',
      name: 'Phoenix Chick',
      description: 'A rare phoenix chick that grants resilience and renewal',
      icon: 'ðŸ¦',
      zone: 'athenaeum',
      rarity: 'legendary',
      bonus: { type: 'resilience', value: 5 }
    },
    {
      id: 'turtle',
      name: 'Ancient Turtle',
      description: 'A wise turtle that increases meditation effectiveness',
      icon: 'ðŸ¢',
      zone: 'gardens',
      rarity: 'rare',
      bonus: { type: 'meditation', value: 3 }
    }
  ];

  // Pet state storage (in real game, this would be in database)
  const playerPets = {};

  // Pet care constants
  const PET_CONSTANTS = {
    HUNGER_DECAY_RATE: 1, // hunger increases by 1 per minute
    MOOD_DECAY_RATE: 0.5, // mood decreases by 0.5 per minute
    BOND_GAIN_RATE: 0.2, // bond increases by 0.2 when feeding/caring
    HUNGER_THRESHOLD_HAPPY: 30, // below 30 hunger = happy
    HUNGER_THRESHOLD_CONTENT: 60, // 30-60 = content
    MOOD_THRESHOLD_ECSTATIC: 90,
    MOOD_THRESHOLD_HAPPY: 70,
    MOOD_THRESHOLD_CONTENT: 50,
    MOOD_THRESHOLD_HUNGRY: 30
  };

  /**
   * Get pet types available in a specific zone
   * @param {string} zone - Zone identifier (commons, wilds, athenaeum, gardens)
   * @returns {Array} Array of pet types available in this zone
   */
  function getAvailablePets(zone) {
    return PET_TYPES.filter(pet => pet.zone === zone);
  }

  /**
   * Adopt a new pet
   * @param {string} playerId - Player identifier
   * @param {string} petType - Pet type id from PET_TYPES
   * @param {string} petName - Custom name for the pet
   * @returns {Object|null} Pet object or null if failed
   */
  function adoptPet(playerId, petType, petName) {
    if (!playerId || !petType || !petName) {
      console.error('Invalid adoption parameters');
      return null;
    }

    // Check if player already has a pet
    if (playerPets[playerId]) {
      console.warn('Player already has a pet. Release current pet first.');
      return null;
    }

    // Find pet type
    const petTypeData = PET_TYPES.find(p => p.id === petType);
    if (!petTypeData) {
      console.error('Invalid pet type:', petType);
      return null;
    }

    // Create pet state
    const pet = {
      id: generatePetId(),
      type: petType,
      name: petName,
      mood: 100, // Start happy
      hunger: 0, // Start well-fed
      bond: 0, // Build bond over time
      adopted_at: Date.now(),
      last_updated: Date.now()
    };

    playerPets[playerId] = pet;
    return pet;
  }

  /**
   * Get player's current pet
   * @param {string} playerId - Player identifier
   * @returns {Object|null} Pet object or null if no pet
   */
  function getPlayerPet(playerId) {
    return playerPets[playerId] || null;
  }

  /**
   * Feed the pet
   * @param {string} playerId - Player identifier
   * @param {string} foodItem - Food item type
   * @returns {Object} Result object with success, message, and updated pet
   */
  function feedPet(playerId, foodItem) {
    const pet = playerPets[playerId];
    if (!pet) {
      return { success: false, message: 'No pet to feed' };
    }

    // Food effectiveness
    const foodEffects = {
      'berry': { hunger: -20, mood: 5 },
      'fish': { hunger: -30, mood: 10 },
      'mushroom': { hunger: -15, mood: 3 },
      'bread': { hunger: -25, mood: 7 },
      'treat': { hunger: -10, mood: 15 },
      'default': { hunger: -10, mood: 5 }
    };

    const effect = foodEffects[foodItem] || foodEffects['default'];

    // Update pet state
    pet.hunger = Math.max(0, pet.hunger + effect.hunger);
    pet.mood = Math.min(100, pet.mood + effect.mood);
    pet.bond = Math.min(100, pet.bond + PET_CONSTANTS.BOND_GAIN_RATE);
    pet.last_updated = Date.now();

    return {
      success: true,
      message: `${pet.name} enjoyed the ${foodItem}!`,
      pet: pet
    };
  }

  /**
   * Update pet state over time (hunger/mood decay)
   * @param {string} playerId - Player identifier
   * @param {number} deltaTime - Time elapsed in milliseconds
   * @returns {Object|null} Updated pet or null
   */
  function updatePet(playerId, deltaTime) {
    const pet = playerPets[playerId];
    if (!pet) return null;

    const minutesElapsed = deltaTime / 60000; // Convert ms to minutes

    // Update hunger (increases over time)
    pet.hunger = Math.min(100, pet.hunger + (PET_CONSTANTS.HUNGER_DECAY_RATE * minutesElapsed));

    // Update mood (decreases over time, faster if hungry)
    let moodDecay = PET_CONSTANTS.MOOD_DECAY_RATE * minutesElapsed;
    if (pet.hunger > PET_CONSTANTS.HUNGER_THRESHOLD_CONTENT) {
      moodDecay *= 2; // Mood decays faster when hungry
    }
    pet.mood = Math.max(0, pet.mood - moodDecay);

    // Bond increases slightly over time (passive bonding)
    if (pet.hunger < PET_CONSTANTS.HUNGER_THRESHOLD_HAPPY && pet.mood > PET_CONSTANTS.MOOD_THRESHOLD_CONTENT) {
      pet.bond = Math.min(100, pet.bond + (0.1 * minutesElapsed));
    }

    pet.last_updated = Date.now();
    return pet;
  }

  /**
   * Get passive bonus from pet based on type and bond level
   * @param {string} playerId - Player identifier
   * @returns {Object|null} Bonus object with type and value, or null
   */
  function getPetBonus(playerId) {
    const pet = playerPets[playerId];
    if (!pet) return null;

    const petType = PET_TYPES.find(p => p.id === pet.type);
    if (!petType) return null;

    // Bonus scales with bond level
    const bondMultiplier = pet.bond / 100;
    const bonusValue = petType.bonus.value * bondMultiplier;

    return {
      type: petType.bonus.type,
      value: bonusValue,
      description: getBonusDescription(petType.bonus.type, bonusValue)
    };
  }

  /**
   * Rename pet
   * @param {string} playerId - Player identifier
   * @param {string} newName - New pet name
   * @returns {boolean} Success status
   */
  function renamePet(playerId, newName) {
    const pet = playerPets[playerId];
    if (!pet || !newName) return false;

    pet.name = newName;
    return true;
  }

  /**
   * Release pet back to the wild
   * @param {string} playerId - Player identifier
   * @returns {boolean} Success status
   */
  function releasePet(playerId) {
    if (!playerPets[playerId]) return false;
    delete playerPets[playerId];
    return true;
  }

  /**
   * Get pet mood description
   * @param {Object} pet - Pet object
   * @returns {string} Mood description
   */
  function getPetMood(pet) {
    if (!pet) return 'unknown';

    if (pet.hunger > 70) {
      return 'starving';
    } else if (pet.hunger > 50) {
      return 'hungry';
    }

    if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_ECSTATIC) {
      return 'ecstatic';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_HAPPY) {
      return 'happy';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_CONTENT) {
      return 'content';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_HUNGRY) {
      return 'sad';
    } else {
      return 'depressed';
    }
  }

  /**
   * Get mood emoji indicator
   * @param {string} mood - Mood string
   * @returns {string} Emoji representing mood
   */
  function getMoodEmoji(mood) {
    const moodEmojis = {
      'ecstatic': 'ðŸ˜„',
      'happy': 'ðŸ˜Š',
      'content': 'ðŸ™‚',
      'sad': 'ðŸ˜Ÿ',
      'hungry': 'ðŸ˜«',
      'starving': 'ðŸ˜µ',
      'depressed': 'ðŸ˜¢',
      'unknown': 'ðŸ˜'
    };
    return moodEmojis[mood] || moodEmojis['unknown'];
  }

  /**
   * Get bonus description
   * @param {string} bonusType - Type of bonus
   * @param {number} value - Bonus value
   * @returns {string} Description
   */
  function getBonusDescription(bonusType, value) {
    const descriptions = {
      'trade_luck': `+${value.toFixed(1)}% trade success`,
      'discovery_range': `+${value.toFixed(1)}% discovery radius`,
      'lore_unlock': `+${value.toFixed(1)}% lore unlock chance`,
      'garden_growth': `+${value.toFixed(1)}% garden growth rate`,
      'craft_speed': `+${value.toFixed(1)}% crafting speed`,
      'rare_resources': `+${value.toFixed(1)}% rare resource chance`,
      'vision_range': `+${value.toFixed(1)}% vision range`,
      'stamina': `+${value.toFixed(1)}% stamina`,
      'resilience': `+${value.toFixed(1)}% resilience`,
      'meditation': `+${value.toFixed(1)}% meditation effectiveness`
    };
    return descriptions[bonusType] || 'Unknown bonus';
  }

  /**
   * Generate unique pet ID
   * @returns {string} Unique ID
   */
  function generatePetId() {
    return 'pet_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Get all pet types
   * @returns {Array} All pet types
   */
  function getAllPetTypes() {
    return PET_TYPES;
  }

  /**
   * Get pet type data
   * @param {string} petTypeId - Pet type ID
   * @returns {Object|null} Pet type data or null
   */
  function getPetTypeData(petTypeId) {
    return PET_TYPES.find(p => p.id === petTypeId) || null;
  }

  // Export public API
  exports.PET_TYPES = PET_TYPES;
  exports.getAvailablePets = getAvailablePets;
  exports.adoptPet = adoptPet;
  exports.getPlayerPet = getPlayerPet;
  exports.feedPet = feedPet;
  exports.updatePet = updatePet;
  exports.getPetBonus = getPetBonus;
  exports.renamePet = renamePet;
  exports.releasePet = releasePet;
  exports.getPetMood = getPetMood;
  exports.getMoodEmoji = getMoodEmoji;
  exports.getAllPetTypes = getAllPetTypes;
  exports.getPetTypeData = getPetTypeData;

})(typeof module !== 'undefined' ? module.exports : (window.Pets = {}));


// main.js
(function(exports) {
  // Main entry point and game loop orchestrator

  // Import references (browser globals or require)
  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const State = typeof require !== 'undefined' ? require('./state') : window.State;
  const Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;
  const Inventory = typeof require !== 'undefined' ? require('./inventory') : window.Inventory;
  const Trading = typeof require !== 'undefined' ? require('./trading') : window.Trading;
  const Intentions = typeof require !== 'undefined' ? require('./intentions') : window.Intentions;
  const Social = typeof require !== 'undefined' ? require('./social') : window.Social;
  const Creation = typeof require !== 'undefined' ? require('./creation') : window.Creation;
  const Competition = typeof require !== 'undefined' ? require('./competition') : window.Competition;
  const Exploration = typeof require !== 'undefined' ? require('./exploration') : window.Exploration;
  const Physical = typeof require !== 'undefined' ? require('./physical') : window.Physical;
  const Auth = typeof require !== 'undefined' ? require('./auth') : window.Auth;
  const Network = typeof require !== 'undefined' ? require('./network') : window.Network;
  const World = typeof require !== 'undefined' ? require('./world') : window.World;
  const Input = typeof require !== 'undefined' ? require('./input') : window.Input;
  const HUD = typeof require !== 'undefined' ? require('./hud') : window.HUD;
  const XR = typeof require !== 'undefined' ? require('./xr') : window.XR;
  const Audio = typeof require !== 'undefined' ? require('./audio') : window.Audio;
  const NPCs = typeof require !== 'undefined' ? require('./npcs') : window.NPCs;
  const Quests = typeof require !== 'undefined' ? require('./quests') : window.Quests;
  const Mentoring = typeof require !== 'undefined' ? require('./mentoring') : window.Mentoring;
  const Guilds = typeof require !== 'undefined' ? require('./guilds') : window.Guilds;
  const Seasons = typeof require !== 'undefined' ? require('./seasons') : window.Seasons;
  const Pets = typeof require !== 'undefined' ? require('./pets') : window.Pets;
  const ApiBridge = typeof require !== 'undefined' ? require('./api_bridge') : window.ApiBridge;

  // Embedded soul data (replaced at bundle time)
  var EMBEDDED_SOULS = [{"id": "agent_001", "name": "Iris Skyhigh", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_002", "name": "Meadow Mindclear", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_003", "name": "Luna Pathfinder", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_004", "name": "Luna Rootdeep", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_005", "name": "Storm Windwalker", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_006", "name": "Wren Voicetrue", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_007", "name": "Delta Hopefast", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_008", "name": "Luna Songsmith", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_009", "name": "Wren Starseed", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_010", "name": "Lyra Thoughtdeep", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_011", "name": "Wren Moonwhisper", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_012", "name": "Frost Rootdeep", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_013", "name": "River Soulbright", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_014", "name": "Felix Shadowmender", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_015", "name": "Phoenix Sunweaver", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_016", "name": "Luna Rootdeep", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_017", "name": "Vale Truthseeker", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_018", "name": "Ezra Willstrong", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_019", "name": "Nova Dreamweaver", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_020", "name": "Echo Thoughtdeep", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_021", "name": "Vale Waterborn", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_022", "name": "Vale Spaceborn", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_023", "name": "Echo Thoughtdeep", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_024", "name": "Nova Hopefast", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_025", "name": "Ridge Handsteady", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_026", "name": "Frost Voicetrue", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_027", "name": "Drift Shadowmender", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_028", "name": "Vale Pathfinder", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_029", "name": "Haven Handsteady", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_030", "name": "River Mindclear", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_031", "name": "Meadow Lightbringer", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_032", "name": "Fern Spaceborn", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_033", "name": "Sage Starseed", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_034", "name": "Blaze Wordkeeper", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_035", "name": "Orion Sunweaver", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_036", "name": "Breeze Mindclear", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_037", "name": "Ash Thoughtdeep", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_038", "name": "Mira Truthseeker", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_039", "name": "Sage Skyhigh", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_040", "name": "Luna Stonecarver", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_041", "name": "Phoenix Waterborn", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_042", "name": "Luna Moonwhisper", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_043", "name": "Haven Handsteady", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_044", "name": "Jasper Shadowmender", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_045", "name": "Phoenix Spiritfree", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_046", "name": "Cedar Timewalker", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_047", "name": "Grove Skyhigh", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_048", "name": "Haven Heartstrong", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_049", "name": "Fern Handsteady", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_050", "name": "Stella Windwalker", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_051", "name": "Cliff Songsmith", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_052", "name": "River Footswift", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_053", "name": "Ezra Dreamweaver", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_054", "name": "Opal Moonwhisper", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_055", "name": "Sol Mindclear", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_056", "name": "Aria Waterborn", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_057", "name": "Dawn Mindclear", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_058", "name": "Opal Earthshaper", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_059", "name": "Ezra Spaceborn", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_060", "name": "Iris Timewalker", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_061", "name": "River Pathfinder", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_062", "name": "Storm Sunweaver", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_063", "name": "Coral Songsmith", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_064", "name": "Reef Hopefast", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_065", "name": "Storm Skyhigh", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_066", "name": "Jasper Moonwhisper", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_067", "name": "Willow Heartstrong", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_068", "name": "Blaze Stonecarver", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_069", "name": "Meadow Firekeeper", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_070", "name": "Echo Soulbright", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_071", "name": "Coral Mindclear", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_072", "name": "Grove Pathfinder", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_073", "name": "Ridge Heartstrong", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_074", "name": "Flint Rootdeep", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_075", "name": "Cedar Spiritfree", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_076", "name": "Zion Truthseeker", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_077", "name": "Quill Dreamweaver", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_078", "name": "Orion Footswift", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_079", "name": "Drift Sunweaver", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_080", "name": "Ash Sunweaver", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_081", "name": "Haven Timewalker", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_082", "name": "Aria Spaceborn", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_083", "name": "Phoenix Thoughtdeep", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_084", "name": "Cedar Wordkeeper", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_085", "name": "Cliff Sunweaver", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_086", "name": "Sage Handsteady", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_087", "name": "Rain Dreamweaver", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_088", "name": "Flint Heartstrong", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_089", "name": "Cliff Heartstrong", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_090", "name": "Echo Footswift", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_091", "name": "Reef Spiritfree", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_092", "name": "Vale Spiritfree", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_093", "name": "River Mindclear", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_094", "name": "River Soulbright", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_095", "name": "Ezra Spiritfree", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_096", "name": "Kai Thoughtdeep", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_097", "name": "Cliff Hopefast", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_098", "name": "Blaze Hopefast", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_099", "name": "North Songsmith", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_100", "name": "Ezra Dreamweaver", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}];

  // Game state
  let gameState = null;
  let sceneContext = null;
  let messageQueue = [];
  let isRunning = false;
  let lastTimestamp = 0;
  let worldTime = 0; // Minutes in 24-hour cycle (0-1440)
  let currentZone = 'nexus';
  let currentWeather = 'clear';
  let npcIntentionIndex = 0; // Throttle: which NPC to evaluate next
  let localPlayer = null;
  let playStartTime = 0;
  let lastBreakReminder = 0;
  let footstepTimer = 0;
  let currentTimePeriod = 'morning';  // tracks dawn/morning/midday/afternoon/evening/night
  let cameraYaw = 0;       // horizontal camera orbit angle (radians)
  let cameraPitch = 0.35;  // vertical tilt (0 = flat, higher = more top-down)
  let cameraDistance = 18;  // distance from player
  let isDragging = false;
  let lastMouseX = 0, lastMouseY = 0;
  let playerInventory = null;
  let economyLedger = null;
  let raycaster = null;
  let simCrmState = null;
  let lastSimCrmTick = 0;
  var SIM_CRM_TICK_INTERVAL = 45000; // 45 seconds between CRM ticks
  let npcUpdateFrame = 0;
  let visitedZones = { nexus: true }; // Track discovered zones for piano accents

  // Performance tracking
  let frameCount = 0;
  let fpsFrameTimes = [];
  let currentFPS = 60;
  let showDebug = false; // Set to true to show FPS counter

  // Play time tracking
  let playTimeSeconds = 0;
  let recentActivities = [];

  // Auto-save tracking
  let lastAutoSave = 0;
  let AUTO_SAVE_INTERVAL = 60000; // 60 seconds

  // Secret discovery tracking
  let lastSecretCheck = 0;
  let SECRET_CHECK_INTERVAL = 2000; // Check every 2 seconds

  // Economic event tracking
  let currentEconomicEvent = null;
  let lastEventCheck = 0;

  // Seasonal event tracking
  let currentSeason = null;
  let lastSeasonCheck = 0;
  let SEASON_CHECK_INTERVAL = 60000; // Check season every 60s

  // Pet tracking
  let lastPetUpdate = 0;
  let PET_UPDATE_INTERVAL = 30000; // Update pet every 30s

  // Fishing state
  let isFishing = false;

  // World events tracking
  var worldEvents = {
    shootingStars: {
      lastSpawn: 0,
      interval: 30000, // 30-90 seconds in milliseconds
      active: []
    },
    resourceBloom: {
      lastSpawn: 0,
      interval: 600000, // 10-15 minutes in milliseconds
      activeZone: null,
      startTime: 0,
      duration: 120000 // 2 minutes
    },
    auroraBorealis: {
      lastSpawn: 0,
      interval: 1200000, // 20+ minutes in milliseconds
      active: false,
      mesh: null,
      startTime: 0,
      duration: 240000, // 3-5 minutes
      animTime: 0
    },
    wanderingMerchant: {
      lastSpawn: 0,
      interval: 900000, // 15 minutes in milliseconds
      activeZone: null
    },
    fireflySwarm: {
      lastSpawn: 0,
      interval: 1800000, // 30 minutes
      active: false,
      startTime: 0,
      duration: 180000 // 3 minutes
    }
  };

  // Warmth tracking (GPS-based outdoor play bonus)
  let gpsHistory = [];
  let gpsWatchId = null;
  let lastWarmthUpdate = 0;

  // Platform detection
  let platform = 'desktop';

  // Camera shake system
  var cameraShake = { intensity: 0, duration: 0, elapsed: 0, active: false };

  /**
   * Trigger camera shake effect
   * @param {number} intensity - Shake strength (0.1-1.0)
   * @param {number} duration - Duration in seconds
   */
  function triggerCameraShake(intensity, duration) {
    cameraShake.intensity = intensity;
    cameraShake.duration = duration;
    cameraShake.elapsed = 0;
    cameraShake.active = true;
  }

  function startZoneCinematic() {
    if (!sceneContext || !localPlayer) return;
    var cam = sceneContext.camera;
    cinematicCamera.active = true;
    cinematicCamera.elapsed = 0;
    cinematicCamera.startPos = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
    cinematicCamera.peakPos = {
      x: cam.position.x,
      y: cam.position.y + 15,
      z: cam.position.z - 8
    };
    // Look toward zone center
    var Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
    var zoneInfo = Zones && Zones.ZONES ? Zones.ZONES[currentZone] : null;
    var lookX = zoneInfo ? zoneInfo.cx : localPlayer.position.x;
    var lookZ = zoneInfo ? zoneInfo.cz : localPlayer.position.z;
    var lookY = (World && World.getTerrainHeight) ? World.getTerrainHeight(lookX, lookZ) + 1.5 : 1.5;
    cinematicCamera.startLookAt = {
      x: localPlayer.position.x,
      y: ((World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0) + 1.5,
      z: localPlayer.position.z
    };
    cinematicCamera.targetLookAt = { x: lookX, y: lookY, z: lookZ };
  }

  function updateCinematicCamera(deltaTime) {
    if (!cinematicCamera.active || !sceneContext) return false;
    cinematicCamera.elapsed += deltaTime;
    var progress = Math.min(cinematicCamera.elapsed / cinematicCamera.duration, 1.0);
    // Smooth ease-in-out
    var ease = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    var cam = sceneContext.camera;
    var sp = cinematicCamera.startPos;
    var pp = cinematicCamera.peakPos;

    if (progress < 0.5) {
      // First half: ease up to peak
      var t = ease * 2; // 0 to 1 over first half
      cam.position.x = sp.x + (pp.x - sp.x) * t;
      cam.position.y = sp.y + (pp.y - sp.y) * t;
      cam.position.z = sp.z + (pp.z - sp.z) * t;
    } else {
      // Second half: ease back down to where normal orbit would be
      var inputDist = Input && Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;
      var inputOrbit = Input && Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;
      var terrY = (World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0;
      var normalX = localPlayer.position.x + Math.sin(inputOrbit) * Math.cos(cameraPitch) * inputDist;
      var normalY = terrY + Math.sin(cameraPitch) * inputDist + 2;
      var normalZ = localPlayer.position.z + Math.cos(inputOrbit) * Math.cos(cameraPitch) * inputDist;
      var t2 = (ease - 0.5) * 2; // 0 to 1 over second half
      cam.position.x = pp.x + (normalX - pp.x) * t2;
      cam.position.y = pp.y + (normalY - pp.y) * t2;
      cam.position.z = pp.z + (normalZ - pp.z) * t2;
    }

    // Blend lookAt from start to target
    var sl = cinematicCamera.startLookAt;
    var tl = cinematicCamera.targetLookAt;
    var lookBlend = Math.min(ease * 1.5, 1.0); // Look moves faster than camera
    cam.lookAt(
      sl.x + (tl.x - sl.x) * lookBlend,
      sl.y + (tl.y - sl.y) * lookBlend,
      sl.z + (tl.z - sl.z) * lookBlend
    );

    if (progress >= 1.0) {
      cinematicCamera.active = false;
    }
    return true;
  }

  function togglePhotoMode() {
    photoMode.active = !photoMode.active;
    var hudContainer = document.getElementById('hud-container');
    if (photoMode.active) {
      // Enter photo mode
      if (sceneContext && sceneContext.camera) {
        photoMode.freeLookAt = {
          x: localPlayer ? localPlayer.position.x : 0,
          y: localPlayer ? ((World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0) + 1.5 : 1.5,
          z: localPlayer ? localPlayer.position.z : 0
        };
      }
      if (hudContainer) {
        photoMode.savedHUDDisplay = hudContainer.style.display;
        hudContainer.style.display = 'none';
      }
      // Show photo mode label
      if (!photoMode.labelEl) {
        photoMode.labelEl = document.createElement('div');
        photoMode.labelEl.style.cssText = 'position:fixed;top:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);color:#fff;padding:6px 16px;border-radius:4px;font:13px monospace;z-index:9999;pointer-events:none;';
        photoMode.labelEl.textContent = 'PHOTO MODE â€” F2 to exit';
        document.body.appendChild(photoMode.labelEl);
      }
      photoMode.labelEl.style.display = 'block';
      setVignetteIntensity(0.6);
    } else {
      // Exit photo mode
      if (hudContainer) {
        hudContainer.style.display = photoMode.savedHUDDisplay || '';
      }
      if (photoMode.labelEl) {
        photoMode.labelEl.style.display = 'none';
      }
      setVignetteIntensity(0.3);
    }
  }

  function updatePhotoModeCamera(deltaTime) {
    if (!photoMode.active || !sceneContext || !Input) return false;
    var delta = Input.getMovementDelta();
    var inputOrbit = Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;
    var inputDist = Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;

    // Pan freeLookAt with camera-relative WASD
    var speed = 0.3;
    if (delta.x !== 0 || delta.z !== 0) {
      var sinY = Math.sin(inputOrbit);
      var cosY = Math.cos(inputOrbit);
      photoMode.freeLookAt.x += (delta.x * cosY - delta.z * sinY) * speed;
      photoMode.freeLookAt.z += (delta.x * sinY + delta.z * cosY) * speed;
      // Follow terrain
      var ty = (World && World.getTerrainHeight) ? World.getTerrainHeight(photoMode.freeLookAt.x, photoMode.freeLookAt.z) : 0;
      photoMode.freeLookAt.y = ty + 1.5;
    }

    // Orbit around freeLookAt
    var camX = photoMode.freeLookAt.x + Math.sin(inputOrbit) * Math.cos(cameraPitch) * inputDist;
    var camY = photoMode.freeLookAt.y + Math.sin(cameraPitch) * inputDist;
    var camZ = photoMode.freeLookAt.z + Math.cos(inputOrbit) * Math.cos(cameraPitch) * inputDist;

    // Smooth lerp
    var lf = 0.12;
    sceneContext.camera.position.x += (camX - sceneContext.camera.position.x) * lf;
    sceneContext.camera.position.y += (camY - sceneContext.camera.position.y) * lf;
    sceneContext.camera.position.z += (camZ - sceneContext.camera.position.z) * lf;

    sceneContext.camera.lookAt(
      photoMode.freeLookAt.x,
      photoMode.freeLookAt.y,
      photoMode.freeLookAt.z
    );
    return true;
  }

  // Cinematic zone entry swoop
  var cinematicCamera = {
    active: false, elapsed: 0, duration: 1.2,
    startPos: null, peakPos: null,
    startLookAt: null, targetLookAt: null
  };

  // Photo mode (F2 toggle)
  var photoMode = {
    active: false,
    freeLookAt: null,
    savedHUDDisplay: '',
    labelEl: null
  };

  // Interaction target tracking for hover highlights and tooltips
  var currentInteractionTarget = null; // { object, type, name, distance, action, mesh }
  var tooltipEl = null;

  // Screen flash overlay element
  var screenFlashOverlay = null;
  var vignetteOverlay = null;

  /**
   * Trigger screen flash effect
   * @param {string} color - CSS color (e.g., '#DAA520', 'rgba(0,120,255,0.3)')
   * @param {number} duration - Duration in seconds
   */
  function triggerScreenFlash(color, duration) {
    if (!screenFlashOverlay) {
      screenFlashOverlay = document.createElement('div');
      screenFlashOverlay.style.position = 'fixed';
      screenFlashOverlay.style.top = '0';
      screenFlashOverlay.style.left = '0';
      screenFlashOverlay.style.width = '100%';
      screenFlashOverlay.style.height = '100%';
      screenFlashOverlay.style.pointerEvents = 'none';
      screenFlashOverlay.style.zIndex = '9998';
      screenFlashOverlay.style.opacity = '0';
      screenFlashOverlay.style.transition = 'opacity 0.1s ease-out';
      document.body.appendChild(screenFlashOverlay);
    }

    // Set color and show
    screenFlashOverlay.style.backgroundColor = color;
    screenFlashOverlay.style.opacity = '0.6';

    // Fade out
    setTimeout(function() {
      screenFlashOverlay.style.transition = 'opacity ' + duration + 's ease-out';
      screenFlashOverlay.style.opacity = '0';
    }, 50);
  }

  /**
   * Set vignette intensity
   * @param {number} intensity - Intensity level (0.0-1.0)
   */
  function setVignetteIntensity(intensity) {
    if (!vignetteOverlay) {
      vignetteOverlay = document.createElement('div');
      vignetteOverlay.style.position = 'fixed';
      vignetteOverlay.style.top = '0';
      vignetteOverlay.style.left = '0';
      vignetteOverlay.style.width = '100%';
      vignetteOverlay.style.height = '100%';
      vignetteOverlay.style.pointerEvents = 'none';
      vignetteOverlay.style.zIndex = '9997';
      vignetteOverlay.style.transition = 'box-shadow 0.5s ease';
      document.body.appendChild(vignetteOverlay);
    }

    var spread = Math.floor(150 * intensity);
    var alpha = 0.3 + (intensity * 0.4); // 0.3-0.7 range
    vignetteOverlay.style.boxShadow = 'inset 0 0 ' + spread + 'px rgba(0,0,0,' + alpha + ')';
  }

  /**
   * Emit level up particle burst effect
   */
  function emitLevelUpParticles() {
    if (World && World.emitParticles && localPlayer && localPlayer.position) {
      var levelUpPos = { x: localPlayer.position.x, y: localPlayer.position.y + 2, z: localPlayer.position.z };
      World.emitParticles('sparkle', levelUpPos, 25);
    }
    // Add golden flash effect for level up
    triggerScreenFlash('#DAA520', 0.3);
  }

  /**
   * Detect nearest interactable object/NPC/resource within range
   * Returns { object, type, name, distance, action, mesh, position } or null
   */
  function detectNearestInteractable() {
    if (!localPlayer) return null;

    var nearestTarget = null;
    var minDist = 10; // Max interaction range

    var playerX = localPlayer.position.x;
    var playerZ = localPlayer.position.z;

    // Check NPCs
    if (NPCs && NPCs.getNPCPositions) {
      var npcPositions = NPCs.getNPCPositions();
      for (var i = 0; i < npcPositions.length; i++) {
        var npc = npcPositions[i];
        if (!npc) continue;
        var dx = npc.x - playerX;
        var dz = npc.z - playerZ;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearestTarget = {
            type: 'npc',
            name: npc.name || 'NPC',
            action: 'Talk',
            distance: dist,
            mesh: npc.mesh,
            position: { x: npc.x, y: localPlayer.position.y + 1, z: npc.z }
          };
        }
      }
    }

    // Check interactive objects (benches, campfires, etc.)
    if (World && World.getInteractiveAtPosition) {
      var nearbyObj = World.getInteractiveAtPosition(playerX, playerZ, minDist);
      if (nearbyObj) {
        var dx = nearbyObj.position.x - playerX;
        var dz = nearbyObj.position.z - playerZ;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearestTarget = {
            type: 'interactive',
            name: nearbyObj.type ? nearbyObj.type.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase(); }) : 'Object',
            action: nearbyObj.action ? nearbyObj.action.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase(); }) : 'Use',
            distance: dist,
            mesh: nearbyObj.mesh,
            position: nearbyObj.position
          };
        }
      }
    }

    // Check resource nodes
    if (World && World.getResourceNodeAtMouse) {
      // For now, skip resource node highlighting as it requires mouse position
      // Could be enhanced later with a separate distance-based check
    }

    return nearestTarget;
  }

  /**
   * Update tooltip position and content based on current interaction target
   */
  function updateTooltip() {
    if (!tooltipEl || !sceneContext || !sceneContext.camera || !sceneContext.renderer) return;

    if (!currentInteractionTarget) {
      tooltipEl.style.display = 'none';
      return;
    }

    // Project 3D position to screen space
    if (!window.THREE) return;
    var pos = new window.THREE.Vector3(
      currentInteractionTarget.position.x,
      currentInteractionTarget.position.y + 3, // Offset above object
      currentInteractionTarget.position.z
    );
    pos.project(sceneContext.camera);

    // Convert to screen coordinates
    var x = (pos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
    var y = (-pos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;

    // Position tooltip
    tooltipEl.style.left = x + 'px';
    tooltipEl.style.top = y + 'px';
    tooltipEl.style.display = 'block';

    // Update content
    tooltipEl.innerHTML = '<span style="color:#DAA520">' + currentInteractionTarget.name + '</span>' +
      '<br><span style="color:#A0978E; font-size:11px">[E] ' + currentInteractionTarget.action + '</span>';
  }

  /**
   * Initialize the game
   */
  async function init() {
    console.log('Initializing ZION MMO...');

    // Detect platform
    if (Input) {
      platform = Input.getPlatform();
      console.log('Platform:', platform);
    }

    // Check authentication
    if (!Auth) {
      console.error('Auth module not available');
      return;
    }

    // Handle OAuth callback (exchanges ?code= for token if present)
    await Auth.handleCallback();

    // Check if authenticated
    if (!Auth.isAuthenticated()) {
      showLoginScreen();
      return;
    }

    // Hide login screen, show loading screen
    if (typeof document !== 'undefined') {
      var loginEl = document.getElementById('login-screen');
      if (loginEl) loginEl.style.display = 'none';
      var loadingEl = document.getElementById('loading-overlay');
      if (loadingEl) loadingEl.style.display = 'flex';
    }

    // Get username
    const username = Auth.getUsername();
    console.log('Authenticated as:', username);

    // Initialize game systems with loading progress
    await initGameSystems(username);

    // Hide loading screen with fade
    if (typeof document !== 'undefined') {
      var loadEl = document.getElementById('loading-overlay');
      if (loadEl) {
        loadEl.style.opacity = '0';
        loadEl.style.transition = 'opacity 0.5s ease';
        setTimeout(function() { loadEl.style.display = 'none'; }, 600);
      }
    }

    // Start tutorial for new players
    if (HUD && HUD.initTutorial) {
      setTimeout(function() { HUD.initTutorial(); }, 1500);
    }

    // Start game loop
    startGameLoop();
  }

  /**
   * Initialize game systems
   */
  async function initGameSystems(username) {
    // Initialize audio
    if (Audio) {
      Audio.initAudio();
    }

    // Initialize state
    if (State) {
      gameState = State.initState();
      localPlayer = {
        id: username,
        name: username,
        position: { x: 0, y: 0, z: 0 },
        zone: 'nexus',
        spark: 1000,
        warmth: 0
      };
      State.addPlayer(gameState, localPlayer);
    }

    // Initialize economy ledger
    if (Economy) {
      economyLedger = Economy.createLedger();
      economyLedger.balances[username] = 1000;
    }

    // Initialize inventory
    if (Inventory) {
      playerInventory = Inventory.createInventory();
      Inventory.addItem(playerInventory, 'wood_oak', 5);
      Inventory.addItem(playerInventory, 'stone_common', 5);
      Inventory.addItem(playerInventory, 'seed_wildflower', 3);
    }

    // Initialize raycaster for clicking
    if (typeof THREE !== 'undefined') {
      raycaster = new THREE.Raycaster();
    }

    // Initialize network
    if (Network) {
      const peerId = `zion-${username}-${Date.now()}`;
      Network.initMesh(peerId, {
        onMessage: handleIncomingMessage,
        onPeerConnect: (peerId) => {
          console.log('Peer connected:', peerId);
          HUD && HUD.showNotification(`Player connected: ${peerId}`, 'info');
        },
        onPeerDisconnect: (peerId) => {
          console.log('Peer disconnected:', peerId);
          HUD && HUD.showNotification(`Player disconnected: ${peerId}`, 'info');
          if (gameState && State) {
            State.removePlayer(gameState, peerId);
          }
        }
      });

      // Connect to lobby peer
      const lobbyPeer = Network.getLobbyPeerId('main');
      Network.connectToPeer(lobbyPeer);

      // Join lobby for automatic peer discovery
      if (Network.joinLobby) {
        Network.joinLobby('main', username, currentZone);
      }

      // Broadcast join message after a short delay to let connections establish
      setTimeout(function() {
        joinWorld();
      }, 2000);

      // Initialize federation
      const worldId = Network.deriveWorldId();
      const worldName = 'ZION'; // Could be customized per fork
      const endpoint = typeof window !== 'undefined' ? window.location.origin : 'http://localhost';
      Network.initFederation(worldId, worldName, endpoint);

      // Register federation event handler
      Network.onFederationEvent((event) => {
        handleFederationEvent(event);
      });

      // Announce to federation network periodically
      setInterval(() => {
        if (Network.announceFederation) {
          Network.announceFederation();
        }
      }, 60000); // Every 60 seconds

      // Initial announce
      setTimeout(() => {
        if (Network.announceFederation) {
          Network.announceFederation();
        }
      }, 5000); // After 5 seconds to let connections establish
    }

    // Initialize API bridge for AI agent communication
    if (ApiBridge && ApiBridge.init) {
      ApiBridge.init();
    }

    // Initialize CRM simulation
    if (typeof SimCRM !== 'undefined' && SimCRM.initState) {
      simCrmState = SimCRM.initState();
      console.log('[SimCRM] Initialized');
    }

    // Initialize 3D scene
    if (typeof document !== 'undefined' && World) {
      const container = document.getElementById('game-container') || document.body;
      sceneContext = World.initScene(container);

      if (sceneContext) {
        // Load initial zone - positions player at nexus center
        World.loadZone(sceneContext, currentZone);
        // Load initial chunks around player
        if (World.updateChunks) {
          World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
        }
        World.addPlayer(sceneContext, username, localPlayer.position);

        // Initialize particle effects (fire, sparkle, mist, fountain, etc.)
        if (World.initParticles) {
          World.initParticles(sceneContext);
        }

        // Initialize water bodies (ponds, rivers, fountains)
        if (World.initWater) {
          World.initWater(sceneContext);
        }

        // Initialize skybox (sky dome, stars, sun, moon)
        if (World.initSkybox) {
          World.initSkybox(sceneContext);
        }

        // Initialize resource nodes for harvesting
        if (World.initResourceNodes) {
          World.initResourceNodes(sceneContext);
        }

        // Spawn interactive objects for current zone (benches, campfires, etc.)
        if (World.spawnZoneInteractives) {
          World.spawnZoneInteractives(sceneContext, currentZone);
        }

        // Initialize wildlife (butterflies, fireflies, birds, fish)
        if (World.initWildlife) {
          World.initWildlife(sceneContext);
        }

        // Initialize zone ambience particles
        if (World.initZoneAmbience) {
          World.initZoneAmbience(sceneContext);
        }

        // Initialize vignette overlay with default intensity
        setVignetteIntensity(0.3);

        // Create zone boundary particles (golden floating markers at zone edges)
        if (World.createZoneBoundaryParticles && sceneContext.scene) {
          World.createZoneBoundaryParticles(sceneContext.scene);
        }

        // Initialize enhanced weather systems
        if (World.initBillboardClouds) World.initBillboardClouds(sceneContext);
        if (World.initRainSplashes) World.initRainSplashes(sceneContext);
        if (World.initValleyFog) World.initValleyFog(sceneContext);
        if (World.initZoneBorderShimmer) World.initZoneBorderShimmer(sceneContext);

        // Load world memory (footpaths, gathering spots)
        if (World.loadWorldMemory) World.loadWorldMemory();

        // Wire lightning callback for camera shake + thunder
        if (World.weatherCallbacks) {
          World.weatherCallbacks.onLightningStrike = function(boltX, boltZ) {
            triggerCameraShake(0.3, 0.4);
            // Trigger thunder SFX after 1-3 second delay
            var thunderDelay = 1000 + Math.random() * 2000;
            setTimeout(function() {
              if (Audio && Audio.playAmbient) {
                // Use existing audio system for thunder
                triggerScreenFlash('rgba(255,255,255,0.15)', 0.1);
              }
            }, thunderDelay);
          };
        }
      }
    }

    // Initialize HUD
    if (typeof document !== 'undefined' && HUD) {
      const container = document.getElementById('game-container') || document.body;
      HUD.initHUD(container);
      HUD.updateZoneLabel(currentZone);
      HUD.updatePlayerInfo(localPlayer);

      // Initialize toolbar (action buttons, coords, time/weather)
      if (HUD.initToolbar) {
        HUD.initToolbar();
      }

      // Initialize quest tracker
      if (HUD.initQuestTracker) {
        HUD.initQuestTracker();
      }

      // Initialize reputation system
      if (Social && Social.initReputation) {
        Social.initReputation(localPlayer.id);
        if (HUD.updateReputationDisplay) {
          HUD.updateReputationDisplay(Social.getReputation(localPlayer.id));
        }
      }

      // Initialize governance panel callback
      if (HUD.initGovernancePanel) {
        HUD.initGovernancePanel(handleGovernanceAction);
      }

      // Initialize inventory panel
      if (HUD.initInventoryPanel) {
        HUD.initInventoryPanel();
      }

      // Initialize crafting panel with craft callback
      if (HUD.initCraftingPanel) {
        HUD.initCraftingPanel(function(recipeId) {
          handleCraft(recipeId);
        });
      }

      // Initialize quick bar
      if (HUD.initQuickBar) {
        HUD.initQuickBar();
      }

      // Load settings and apply them
      if (HUD.loadSettings) {
        HUD.loadSettings();
        var settings = HUD.getSettings();
        if (settings && Audio) {
          if (Audio.setVolume) {
            Audio.setVolume('master', settings.masterVolume / 100);
            Audio.setVolume('music', settings.musicVolume / 100);
            Audio.setVolume('sfx', settings.sfxVolume / 100);
          }
        }
        // Set FPS counter visibility
        if (settings) {
          showDebug = settings.showFPS;
        }
      }

      // Initialize play time tracking
      getPlayTimeSeconds();

      // Add chat input
      HUD.addChatInput((text) => {
        handleLocalAction('chat', { message: text });
        HUD.hideChatInput();
      });

      // Initialize interaction tooltip overlay
      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'interaction-tooltip';
        tooltipEl.style.cssText = 'position:fixed; pointer-events:none; z-index:200; ' +
          'background:rgba(10,14,26,0.85); border:1px solid rgba(218,165,32,0.6); ' +
          'border-radius:6px; padding:6px 12px; color:#E8E0D8; font-size:12px; ' +
          'font-family:var(--font-ui); display:none; transform:translate(-50%,-100%); ' +
          'backdrop-filter:blur(5px); white-space:nowrap;';
        document.body.appendChild(tooltipEl);
      }
    }

    // Initialize quest system for local player
    if (Quests) {
      Quests.initPlayerQuests(username);
      if (Quests.initPlayerAchievements) {
        Quests.initPlayerAchievements(username);
      }
      console.log('Quest system initialized for player:', username);
    }

    // Restore saved player data (position, inventory, spark, etc.)
    var wasRestored = restorePlayerData();
    if (wasRestored) {
      console.log('Restored saved player data');
      var timeSince = Auth.getTimeSinceLastSave ? Auth.getTimeSinceLastSave() : Infinity;
      if (timeSince < 86400000 && HUD) { // Less than 24 hours
        var minsAgo = Math.floor(timeSince / 60000);
        var timeStr = minsAgo < 60 ? minsAgo + ' minutes' : Math.floor(minsAgo / 60) + ' hours';
        setTimeout(function() {
          HUD.showNotification('Welcome back! Last seen ' + timeStr + ' ago', 'info');
        }, 2000);
      }
    }

    // Initialize trading system
    if (Trading && Network) {
      Trading.initTrading(function(msg) {
        Network.broadcastMessage(msg);
      });
      console.log('Trading system initialized');
    }

    // Set up NPC dialog action handler
    if (HUD && HUD.setNPCActionCallback) {
      HUD.setNPCActionCallback(function(action, npcData) {
        handleNPCAction(action, npcData);
      });
    }

    // Initialize input
    if (Input) {
      Input.initInput({
        onMove: (delta) => {
          // Movement handled in game loop
        },
        onAction: (type, data) => {
          handleLocalAction(type, data);
        },
        onChat: (data) => {
          if (data.mode === 'open') {
            HUD && HUD.showChatInput();
          }
        },
        onBuild: (data) => {
          handleBuildAction(data);
        }
      });
    }

    // Play ambient audio and start music
    if (Audio) {
      Audio.playAmbient(currentZone);
      if (Audio.startMusic) Audio.startMusic(currentZone, currentTimePeriod || 'midday');
    }

    // Initialize AI citizens
    if (NPCs) {
      NPCs.initNPCs(null, gameState, sceneContext);
      NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);

      // Register NPC intentions from embedded souls
      if (Intentions && EMBEDDED_SOULS && EMBEDDED_SOULS.length > 0) {
        var registered = 0;
        EMBEDDED_SOULS.forEach(function(soul) {
          if (soul.intentions && soul.intentions.length > 0) {
            Intentions.clearIntentions(soul.id);
            soul.intentions.forEach(function(intent) {
              Intentions.registerIntention(soul.id, intent);
            });
            registered++;
          }
        });
        console.log('Registered intentions for ' + registered + ' NPCs');
      }
    }

    // Initialize economic event display
    updateEconomicEvent();

    // Initialize seasonal event display
    initSeasonalEvent();

    // Initialize pet system - restore saved pet
    initPetSystem(username);

    // Send join message
    joinWorld();

    // Record play start time
    playStartTime = Date.now();

    // Start GPS tracking for Warmth (only if geolocation available)
    if (typeof navigator !== 'undefined' && navigator.geolocation) {
      try {
        gpsWatchId = navigator.geolocation.watchPosition(function(pos) {
          gpsHistory.push({
            lat: pos.coords.latitude,
            lon: pos.coords.longitude,
            ts: Date.now()
          });
          // Keep only last 100 points
          if (gpsHistory.length > 100) {
            gpsHistory = gpsHistory.slice(-100);
          }
        }, function() {
          // Geolocation denied or unavailable - game works fine without it
          console.log('Geolocation not available - Warmth bonus disabled');
        }, { enableHighAccuracy: false, maximumAge: 30000, timeout: 10000 });
      } catch (e) {
        // Silently ignore - warmth is optional
      }
    }

    console.log('Game systems initialized');
  }

  /**
   * Convert 3D position to screen coordinates
   */
  function getScreenPosition(position, camera, renderer) {
    if (!window.THREE || !camera || !renderer) return null;

    var vector = new window.THREE.Vector3(position.x, position.y + 2, position.z);
    vector.project(camera);

    var widthHalf = renderer.domElement.width / 2;
    var heightHalf = renderer.domElement.height / 2;

    return {
      x: (vector.x * widthHalf) + widthHalf,
      y: -(vector.y * heightHalf) + heightHalf
    };
  }

  /**
   * Show login screen
   */
  function showLoginScreen() {
    if (typeof document === 'undefined') {
      console.log('Not authenticated. Please authenticate.');
      return;
    }

    const loginScreen = document.createElement('div');
    loginScreen.id = 'login-screen';
    loginScreen.style.cssText = `
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1040 40%, #0d2137 70%, #0a0e1a 100%);
      display: flex; align-items: center; justify-content: center;
      z-index: 10000; font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    `;

    // Animated star background
    var starCanvas = document.createElement('canvas');
    starCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;';
    starCanvas.width = window.innerWidth;
    starCanvas.height = window.innerHeight;
    loginScreen.appendChild(starCanvas);
    var starCtx = starCanvas.getContext('2d');
    var loginStars = [];
    for (var si = 0; si < 150; si++) {
      loginStars.push({
        x: Math.random() * starCanvas.width,
        y: Math.random() * starCanvas.height,
        r: 0.5 + Math.random() * 1.5,
        speed: 0.1 + Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2
      });
    }
    function animateLoginStars() {
      if (!document.getElementById('login-screen')) return;
      starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
      var time = Date.now() * 0.001;
      loginStars.forEach(function(s) {
        var alpha = 0.3 + Math.sin(time * s.speed + s.phase) * 0.4;
        starCtx.fillStyle = 'rgba(180, 200, 255, ' + Math.max(0, alpha) + ')';
        starCtx.beginPath();
        starCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        starCtx.fill();
      });
      requestAnimationFrame(animateLoginStars);
    }
    animateLoginStars();

    const content = document.createElement('div');
    content.style.cssText = 'text-align:center;color:white;position:relative;z-index:1;';

    content.innerHTML = `
      <div style="font-size:72px;font-weight:100;letter-spacing:16px;margin-bottom:8px;
        background:linear-gradient(135deg,#4af,#a8f,#4af);-webkit-background-clip:text;
        -webkit-text-fill-color:transparent;background-clip:text;">ZION</div>
      <p style="font-size:16px;margin-bottom:40px;opacity:0.6;letter-spacing:4px;text-transform:uppercase;">
        A peer-to-peer social metaverse</p>
      <button id="github-login" style="
        padding:16px 48px;font-size:16px;background:rgba(255,255,255,0.1);
        color:white;border:1px solid rgba(255,255,255,0.3);border-radius:30px;
        cursor:pointer;font-weight:500;letter-spacing:1px;
        backdrop-filter:blur(10px);transition:all 0.3s;
      " onmouseover="this.style.background='rgba(255,255,255,0.2)';this.style.borderColor='rgba(255,255,255,0.6)'"
         onmouseout="this.style.background='rgba(255,255,255,0.1)';this.style.borderColor='rgba(255,255,255,0.3)'"
      >Login with GitHub</button>
      <p style="margin-top:24px;font-size:12px;opacity:0.4;">
        Or append ?token=YOUR_GITHUB_PAT to the URL</p>
      <div style="margin-top:60px;font-size:11px;opacity:0.3;">
        100 AI citizens await in 8 zones</div>
    `;

    loginScreen.appendChild(content);
    document.body.appendChild(loginScreen);

    document.getElementById('github-login').addEventListener('click', () => {
      if (Auth) {
        Auth.initiateOAuth();
      }
    });
  }

  /**
   * Start game loop
   */
  function startGameLoop() {
    isRunning = true;
    lastTimestamp = performance.now();

    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    } else {
      console.warn('requestAnimationFrame not available');
    }
  }

  /**
   * Main game loop
   */
  function gameLoop(timestamp) {
    if (!isRunning) return;

    const deltaTime = (timestamp - lastTimestamp) / 1000; // seconds
    lastTimestamp = timestamp;

    // Increment frame counter for periodic updates
    npcUpdateFrame++;
    frameCount++;

    // Track FPS
    fpsFrameTimes.push(deltaTime);
    if (fpsFrameTimes.length > 60) {
      fpsFrameTimes.shift();
    }
    if (fpsFrameTimes.length > 10) {
      var avgFrameTime = fpsFrameTimes.reduce(function(a, b) { return a + b; }, 0) / fpsFrameTimes.length;
      currentFPS = avgFrameTime > 0 ? Math.round(1 / avgFrameTime) : 60;
    }

    // Track play time
    playTimeSeconds += deltaTime;
    // Save every 30 seconds
    if (frameCount % 1800 === 0) {
      savePlayTime();
    }

    // Update FPS counter visibility from settings
    if (HUD && HUD.getSettings) {
      var settings = HUD.getSettings();
      if (settings) {
        showDebug = settings.showFPS;
      }
    }

    // Process queued messages
    processMessageQueue();

    // Process local player movement (skip in photo mode)
    if (Input && localPlayer && gameState && !photoMode.active) {
      const delta = Input.getMovementDelta();
      if (delta.x !== 0 || delta.z !== 0) {
        // Rotate movement delta by camera yaw so WASD is camera-relative
        var sinYaw = Math.sin(cameraYaw);
        var cosYaw = Math.cos(cameraYaw);
        var rotatedDelta = {
          x: delta.x * cosYaw - delta.z * sinYaw,
          y: delta.y,
          z: delta.x * sinYaw + delta.z * cosYaw
        };

        const moveMsg = Input.createMoveMessage(
          localPlayer.id,
          rotatedDelta,
          localPlayer.position,
          currentZone
        );

        // Collision check â€” reject move if it would clip into a structure
        var newPos = moveMsg.payload.position;
        if (World && World.checkCollision && World.checkCollision(newPos.x, newPos.z, 0.5)) {
          // Blocked â€” try sliding along X or Z axis only
          var slideX = { x: newPos.x, y: localPlayer.position.y, z: localPlayer.position.z };
          var slideZ = { x: localPlayer.position.x, y: localPlayer.position.y, z: newPos.z };
          if (!World.checkCollision(slideX.x, slideX.z, 0.5)) {
            moveMsg.payload.position = slideX;
          } else if (!World.checkCollision(slideZ.x, slideZ.z, 0.5)) {
            moveMsg.payload.position = slideZ;
          } else {
            // Fully blocked, don't move
            moveMsg.payload.position = { x: localPlayer.position.x, y: localPlayer.position.y, z: localPlayer.position.z };
          }
        }

        // Apply locally
        handleLocalAction('move', moveMsg.payload);

        // Broadcast to network
        if (Network) {
          Network.broadcastMessage(moveMsg);
        }

        // Update world chunks around player position
        if (World && World.updateChunks && sceneContext) {
          World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
        }

        // Detect zone from player position
        if (World && World.getZoneAtPosition) {
          var detectedZone = World.getZoneAtPosition(localPlayer.position.x, localPlayer.position.z);
          if (detectedZone !== currentZone) {
            var oldZone = currentZone;
            currentZone = detectedZone;
            console.log('Entered zone:', currentZone);

            // Start cinematic zone entry swoop
            startZoneCinematic();

            // Track activity
            addRecentActivity('Entered ' + currentZone);

            // Screen fade transition effect
            if (World && World.fadeTransition) {
              World.fadeTransition(function() {
                // This callback fires at peak fade - load new zone assets here
                if (World.loadZone) World.loadZone(sceneContext, currentZone);
              });
            }

            if (Mentoring) {
              var xpResult = Mentoring.addSkillXP(localPlayer.id, 'exploration', 8);
              if (xpResult.leveledUp && HUD) {
                HUD.showNotification('Exploration skill increased to ' + xpResult.newLevelName, 'success');
                emitLevelUpParticles();
              }
            }

            if (HUD) {
              HUD.updateZoneLabel(currentZone);
              HUD.showNotification('Entered ' + currentZone.charAt(0).toUpperCase() + currentZone.slice(1), 'info');
            }

            if (Audio) {
              Audio.playAmbient(currentZone);
              if (Audio.setZoneAmbient) Audio.setZoneAmbient(currentZone);
              if (Audio.updateMusic) Audio.updateMusic(currentZone, currentTimePeriod);
              // Piano accent on first zone discovery
              if (Audio.playPianoAccent && !visitedZones[currentZone]) {
                Audio.playPianoAccent('zone_discovery');
              }
            }
            visitedZones[currentZone] = true;

            if (NPCs) {
              NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
              // Broadcast zone change to NPCs
              if (NPCs.broadcastEvent) {
                NPCs.broadcastEvent({ type: 'player_zone_change', data: {
                  playerId: localPlayer.id, fromZone: oldZone, toZone: currentZone,
                  position: localPlayer.position
                }});
              }
            }

            // Reload interactive objects for new zone
            if (World && World.clearInteractiveObjects && World.spawnZoneInteractives) {
              World.clearInteractiveObjects(sceneContext);
              World.spawnZoneInteractives(sceneContext, currentZone);
            }

            // Record zone visit for governance
            if (Zones && Zones.recordZoneVisit) {
              Zones.recordZoneVisit(currentZone, localPlayer.id);
            }

            // Show welcome message if zone has one
            if (Zones && HUD) {
              var policies = Zones.getZonePolicies(currentZone);
              if (policies && policies.welcomeMessage) {
                HUD.showNotification(policies.welcomeMessage, 'info');
              }
            }

            // Update quest progress for zone visits
            if (Quests) {
              var updated = Quests.updateQuestProgress(localPlayer.id, 'visit_zone', { zone: currentZone });
              if (updated.length > 0 && HUD) {
                updated.forEach(function(quest) {
                  HUD.showQuestProgress('Quest progress: ' + quest.title);
                });
              }
            }

            // Track zone visit achievement
            trackAchievement('zone_visit', { zone: currentZone });
          }
        }

        // Update NPC visibility by distance every ~30 frames
        if (NPCs && Math.random() < 0.03) {
          NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
        }

        // Footstep sounds
        footstepTimer += deltaTime;
        if (footstepTimer >= 0.4) {
          // Determine footstep sound based on zone
          var footstepTerrain = 'grass'; // default
          if (currentZone === 'nexus') footstepTerrain = 'stone';
          else if (currentZone === 'gardens') footstepTerrain = 'grass';
          else if (currentZone === 'athenaeum') footstepTerrain = 'stone';
          else if (currentZone === 'studio') footstepTerrain = 'wood';
          else if (currentZone === 'wilds') footstepTerrain = 'grass';
          else if (currentZone === 'agora') footstepTerrain = 'stone';
          else if (currentZone === 'commons') footstepTerrain = 'wood';
          else if (currentZone === 'arena') footstepTerrain = 'stone';

          if (Audio && Audio.playFootstep) {
            Audio.playFootstep(footstepTerrain);
          }
          footstepTimer = 0;
        }
      } else {
        // Reset footstep timer when not moving
        footstepTimer = 0;
      }
    }

    // Evaluate NPC intentions â€” throttled: 5 NPCs per frame
    if (Intentions && NPCs && localPlayer && gameState) {
      var agents = NPCs.getAgents ? NPCs.getAgents() : [];
      if (agents.length > 0) {
        var worldStateForIntentions = {
          players: new Map()
        };
        // Add local player
        worldStateForIntentions.players.set(localPlayer.id, {
          id: localPlayer.id,
          position: localPlayer.position
        });
        // Add NPC positions from agents array
        agents.forEach(function(agent) {
          if (agent.position) {
            worldStateForIntentions.players.set(agent.id, {
              id: agent.id,
              position: { x: agent.position.x, y: agent.position.y || 0, z: agent.position.z }
            });
          }
        });
        // Evaluate 5 NPCs per frame round-robin
        var count = Math.min(5, agents.length);
        for (var ei = 0; ei < count; ei++) {
          var idx = (npcIntentionIndex + ei) % agents.length;
          var agent = agents[idx];
          var actions = Intentions.evaluateTriggers(agent.id, worldStateForIntentions, deltaTime);
          if (actions && actions.length > 0) {
            actions.forEach(function(action) {
              if (action.type === 'say' && NPCs.showNPCSpeechBubble) {
                NPCs.showNPCSpeechBubble(agent.id, action.payload ? action.payload.text || action.payload.message : '...');
              }
            });
          }
        }
        npcIntentionIndex = (npcIntentionIndex + count) % agents.length;
      }
    }

    // Update world time (24-min day/night cycle = 1440 minutes in 24 real minutes)
    worldTime += deltaTime * 60; // 60x speed
    if (worldTime >= 1440) worldTime -= 1440;

    // Detect time period from worldTime (minutes 0-1440)
    var worldHour = worldTime / 60;
    var newTimePeriod = 'night';
    if (worldHour >= 5 && worldHour < 7) newTimePeriod = 'dawn';
    else if (worldHour >= 7 && worldHour < 12) newTimePeriod = 'morning';
    else if (worldHour >= 12 && worldHour < 14) newTimePeriod = 'midday';
    else if (worldHour >= 14 && worldHour < 18) newTimePeriod = 'afternoon';
    else if (worldHour >= 18 && worldHour < 21) newTimePeriod = 'evening';
    else newTimePeriod = 'night';

    // Broadcast time period changes to NPCs and audio
    if (newTimePeriod !== currentTimePeriod) {
      currentTimePeriod = newTimePeriod;
      if (NPCs && NPCs.broadcastEvent) {
        NPCs.broadcastEvent({ type: 'time_change', data: { period: currentTimePeriod, hour: worldHour } });
      }
      // Update ambient audio and music for time of day
      if (Audio && Audio.updateAmbientTime) {
        Audio.updateAmbientTime(currentTimePeriod);
      }
      if (Audio && Audio.updateMusic) {
        Audio.updateMusic(currentZone, currentTimePeriod);
      }
      // Piano accent for time-of-day transitions (BotW-style)
      if (Audio && Audio.playPianoAccent) {
        if (currentTimePeriod === 'dawn') Audio.playPianoAccent('dawn');
        else if (currentTimePeriod === 'morning') Audio.playPianoAccent('morning');
        else if (currentTimePeriod === 'evening') Audio.playPianoAccent('dusk');
        else if (currentTimePeriod === 'night') Audio.playPianoAccent('night');
      }
    }

    // Update AI citizens â€” pass player position and weather for perception
    if (NPCs) {
      var npcWorldState = {
        weather: currentWeather,
        worldTime: worldTime,
        timePeriod: currentTimePeriod,
        playerPosition: localPlayer ? localPlayer.position : null,
        playerId: localPlayer ? localPlayer.id : null
      };
      NPCs.updateNPCs(sceneContext, gameState, deltaTime, worldTime, npcWorldState);
      // Update speech bubble positions based on camera
      if (NPCs.updateSpeechBubbles && sceneContext && sceneContext.camera) {
        NPCs.updateSpeechBubbles(sceneContext.camera);
      }
    }

    // Update rendering
    if (sceneContext && World) {
      // Update player positions
      if (gameState && State) {
        const players = State.getPlayers(gameState);
        players.forEach(player => {
          if (player.id !== localPlayer.id) {
            World.movePlayer(sceneContext, player.id, player.position);
          } else {
            World.movePlayer(sceneContext, player.id, localPlayer.position);
          }
        });
      }

      // Camera follows player (orbiting third-person with smooth lerp interpolation)
      if (sceneContext.camera && localPlayer) {
        var terrainY = 0;
        if (World && World.getTerrainHeight) {
          terrainY = World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z);
        }
        localPlayer.position.y = terrainY;

        // Photo mode camera overrides normal follow
        if (photoMode.active) {
          updatePhotoModeCamera(deltaTime);
        }
        // Cinematic camera overrides normal follow
        else if (cinematicCamera.active) {
          updateCinematicCamera(deltaTime);
        }
        else {
        // Get camera controls from Input module
        var inputCameraDistance = Input && Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;
        var inputCameraOrbit = Input && Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;

        // Calculate orbiting camera position from orbit/pitch/distance
        var camOffX = Math.sin(inputCameraOrbit) * Math.cos(cameraPitch) * inputCameraDistance;
        var camOffY = Math.sin(cameraPitch) * inputCameraDistance;
        var camOffZ = Math.cos(inputCameraOrbit) * Math.cos(cameraPitch) * inputCameraDistance;

        var camTargetX = localPlayer.position.x + camOffX;
        var camTargetY = terrainY + camOffY + 2;
        var camTargetZ = localPlayer.position.z + camOffZ;

        // Camera collision: ensure camera doesn't go below terrain
        var camTerrainY = World && World.getTerrainHeight ? World.getTerrainHeight(camTargetX, camTargetZ) : 0;
        if (camTargetY < camTerrainY + 2) camTargetY = camTerrainY + 2;

        // Buttery smooth camera follow using lerp interpolation
        var lerpFactor = 0.08;
        sceneContext.camera.position.x += (camTargetX - sceneContext.camera.position.x) * lerpFactor;
        sceneContext.camera.position.y += (camTargetY - sceneContext.camera.position.y) * lerpFactor;
        sceneContext.camera.position.z += (camTargetZ - sceneContext.camera.position.z) * lerpFactor;

        // Apply camera shake if active
        if (cameraShake.active) {
          cameraShake.elapsed += deltaTime;
          var progress = cameraShake.elapsed / cameraShake.duration;
          if (progress >= 1) {
            cameraShake.active = false;
          } else {
            var decay = 1 - progress;
            var shakeX = (Math.random() - 0.5) * 2 * cameraShake.intensity * decay;
            var shakeY = (Math.random() - 0.5) * 2 * cameraShake.intensity * decay;
            sceneContext.camera.position.x += shakeX;
            sceneContext.camera.position.y += shakeY;
          }
        }

        sceneContext.camera.lookAt(
          localPlayer.position.x,
          terrainY + 1.5,
          localPlayer.position.z
        );
        } // end normal camera else block
      }

      // Update day/night cycle
      World.updateDayNight(sceneContext, worldTime);

      // Weather cycling â€” changes every 4 in-game hours (every 4 real minutes)
      var weatherCycleMinute = Math.floor(worldTime / 240); // 0-5
      var weatherTypes = ['clear', 'cloudy', 'rain', 'clear', 'storm', 'snow'];
      var nextWeather = weatherTypes[weatherCycleMinute % weatherTypes.length];
      if (nextWeather !== currentWeather) {
        var prevWeather = currentWeather;
        currentWeather = nextWeather;
        if (World.setWeather) {
          World.setWeather(sceneContext, currentWeather);
        }
        // Broadcast weather change to NPCs
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'weather_change', data: { weather: currentWeather, previous: prevWeather } });
        }
        // Update ambient audio for weather
        if (Audio && Audio.updateAmbientWeather) {
          Audio.updateAmbientWeather(currentWeather);
        }
        // Update vignette intensity based on weather
        if (currentWeather === 'storm') {
          setVignetteIntensity(0.7);
        } else if (currentWeather === 'rain' || currentWeather === 'snow') {
          setVignetteIntensity(0.5);
        } else {
          setVignetteIntensity(0.3);
        }
      }

      // Cull distant lights for performance (max 12 nearest within 40 units)
      if (World.cullLights) {
        World.cullLights(sceneContext, localPlayer.position, 40, 12);
      }

      // Performance optimizations
      // Update frustum culling every 10 frames
      if (frameCount % 10 === 0 && World.updateFrustumCulling) {
        World.updateFrustumCulling(sceneContext);
      }

      // Update LOD every 30 frames
      if (frameCount % 30 === 0 && World.updateLOD) {
        World.updateLOD(sceneContext, localPlayer.position);
      }

      // Update environmental animations
      if (World.updateAnimations) {
        World.updateAnimations(sceneContext, deltaTime, worldTime);
      }

      // Update resource nodes (respawning)
      if (World.updateResourceNodes) {
        World.updateResourceNodes(deltaTime);
      }

      // Update player animations (walk/run/idle)
      if (World.updatePlayerAnimations) {
        World.updatePlayerAnimations(sceneContext, deltaTime);
      }

      // Update particle effects (fire, sparkle, mist, fountain, leaves)
      if (World.updateParticles) {
        World.updateParticles(sceneContext, deltaTime * 1000, localPlayer ? localPlayer.position : null);
      }

      // Update weather effects (rain, snow)
      if (World.updateWeatherEffects) {
        World.updateWeatherEffects(sceneContext, deltaTime * 1000, localPlayer ? localPlayer.position : null);
      }

      // Update zone ambience particles
      if (World.updateZoneAmbience && localPlayer) {
        World.updateZoneAmbience(sceneContext, localPlayer.zone, deltaTime * 1000);
      }

      // Update water bodies (animated waves, weather-reactive)
      if (World.updateWater) {
        var currentWeather = World.getCurrentWeather ? World.getCurrentWeather() : 'clear';
        World.updateWater(deltaTime, currentWeather);
      }

      // Update skybox (sun/moon orbit, star visibility)
      if (World.updateSkybox) {
        World.updateSkybox(sceneContext, worldTime);
      }

      // Update interactive objects (highlights, campfire flicker, etc.)
      if (World.updateInteractiveAnimations) {
        World.updateInteractiveAnimations(deltaTime);
      }
      if (World.updateInteractiveHighlights && localPlayer) {
        World.updateInteractiveHighlights(localPlayer.position.x, localPlayer.position.z, 4);
      }

      // Detect and highlight nearest interactable for E-key interaction
      if (localPlayer) {
        var newTarget = detectNearestInteractable();

        // If target changed, update highlighting
        if (newTarget !== currentInteractionTarget) {
          // Clear previous highlight
          if (World && World.unhighlightObject) {
            World.unhighlightObject();
          }

          // Set new target
          currentInteractionTarget = newTarget;

          // Apply new highlight
          if (currentInteractionTarget && currentInteractionTarget.mesh && World && World.highlightObject) {
            World.highlightObject(currentInteractionTarget.mesh);
          }
        }

        // Update tooltip position
        updateTooltip();
      }

      // Update ambient wildlife (butterflies, fireflies, birds, fish)
      if (World.updateWildlife) {
        World.updateWildlife(sceneContext, deltaTime, worldTime);
      }

      // Update world events (shooting stars, aurora, resource blooms, etc.)
      updateWorldEvents(deltaTime, worldTime, sceneContext);

      // Update zone boundary particles (golden floating markers)
      if (World.updateZoneBoundaryParticles) {
        World.updateZoneBoundaryParticles(worldTime);
      }

      // â”€â”€ Enhanced systems â”€â”€
      // World memory (footpaths, gathering, flowers)
      if (World.updateWorldMemory && localPlayer) {
        var nearbyCount = 0;
        if (NPCs && NPCs.getNearbyNPCCount) {
          nearbyCount = NPCs.getNearbyNPCCount(localPlayer.position, 5);
        }
        World.updateWorldMemory(localPlayer.position, nearbyCount, deltaTime);
      }

      // Billboard clouds
      if (World.updateBillboardClouds) {
        World.updateBillboardClouds(deltaTime, currentWeather);
      }

      // Snow accumulation
      if (World.updateSnowAccumulation) {
        World.updateSnowAccumulation(deltaTime * 1000, currentWeather);
      }

      // Valley fog
      if (World.updateValleyFog) {
        World.updateValleyFog(worldTime, currentWeather);
      }

      // Terrain breathing
      if (World.updateTerrainBreathing) {
        World.updateTerrainBreathing(deltaTime, worldTime);
      }

      // Wind system
      if (World.updateWindSystem) {
        World.updateWindSystem(deltaTime, currentWeather);
      }

      // Zone border shimmer
      if (World.updateZoneBorderShimmer) {
        World.updateZoneBorderShimmer(worldTime);
      }

      // Update build preview if in build mode
      if (buildModeActive && World && World.updateBuildPreview && Input && Input.getMouseNDC) {
        var mousePos = Input.getMouseNDC();
        World.updateBuildPreview(sceneContext, mousePos.x, mousePos.y, sceneContext.camera);
      }

      // Render scene
      if (sceneContext.renderer && sceneContext.scene && sceneContext.camera) {
        sceneContext.renderer.render(sceneContext.scene, sceneContext.camera);
      }
    }

    // Update HUD
    if (HUD && gameState && State) {
      // Update player info
      HUD.updatePlayerInfo(localPlayer);

      // Update minimap and emote bubbles
      const players = State.getPlayers(gameState);

      // Update emote bubble positions
      if (HUD.updateEmoteBubbles && sceneContext && sceneContext.camera) {
        var playerPositions = {};
        players.forEach(function(player) {
          if (World && World.getPlayerMesh) {
            var mesh = World.getPlayerMesh(sceneContext, player.id);
            if (mesh) {
              var screenPos = getScreenPosition(mesh.position, sceneContext.camera, sceneContext.renderer);
              if (screenPos) {
                playerPositions[player.id] = screenPos;
              }
            }
          }
        });
        HUD.updateEmoteBubbles(playerPositions);
      }
      const mapPlayers = players.map(p => ({
        id: p.id,
        position: p.position,
        isLocal: p.id === localPlayer.id
      }));
      HUD.updateMinimap(mapPlayers, currentZone);

      // Update NPC dots on minimap
      if (HUD.updateMinimapNPCs && NPCs && NPCs.getNPCPositions) {
        HUD.updateMinimapNPCs(NPCs.getNPCPositions(), localPlayer.position);
      }

      // Update nearby players
      const nearby = players
        .filter(p => p.id !== localPlayer.id && p.zone === currentZone)
        .map(p => {
          const dx = p.position.x - localPlayer.position.x;
          const dz = p.position.z - localPlayer.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          return { id: p.id, name: p.name, distance };
        })
        .sort((a, b) => a.distance - b.distance);

      HUD.updateNearbyPlayers(nearby);

      // Update coordinates display
      if (HUD.updateCoords && localPlayer) {
        HUD.updateCoords(localPlayer.position);
      }

      // Update time and weather display
      if (HUD.updateTimeWeather) {
        HUD.updateTimeWeather(worldTime, currentWeather);
      }

      // Update chat
      const messages = Social ? Social.getRecentMessages(gameState) : [];
      HUD.updateChat(messages);

      // Update quest tracker (every few frames)
      if (Quests && HUD.updateQuestTracker && npcUpdateFrame % 30 === 0) {
        var activeQuests = Quests.getActiveQuests(localPlayer.id);
        HUD.updateQuestTracker(activeQuests);
      }

      // Update quest indicators on NPCs (every few frames)
      if (Quests && NPCs && NPCs.updateQuestIndicators && npcUpdateFrame % 60 === 0) {
        NPCs.updateQuestIndicators(localPlayer.id, localPlayer.position);
      }

      // Update Warmth from GPS movement (every 5 seconds)
      var now = Date.now();
      if (now - lastWarmthUpdate > 5000 && Physical && gpsHistory.length >= 2) {
        lastWarmthUpdate = now;
        var newWarmth = Physical.calculateWarmth(gpsHistory);
        if (localPlayer && newWarmth !== localPlayer.warmth) {
          localPlayer.warmth = newWarmth;
          // Warmth bonus applies to harvest yields and discovery rates
          // This is cosmetic-adjacent per constitution - minor 1-10% bonus
        }
      }

      // Update FPS display if debug mode is enabled
      if (showDebug && typeof document !== 'undefined') {
        var fpsElement = document.getElementById('fps-counter');
        if (!fpsElement) {
          fpsElement = document.createElement('div');
          fpsElement.id = 'fps-counter';
          fpsElement.style.position = 'fixed';
          fpsElement.style.top = '10px';
          fpsElement.style.right = '10px';
          fpsElement.style.padding = '8px 12px';
          fpsElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          fpsElement.style.color = '#00ff00';
          fpsElement.style.fontFamily = 'monospace';
          fpsElement.style.fontSize = '12px';
          fpsElement.style.borderRadius = '4px';
          fpsElement.style.zIndex = '10000';
          document.body.appendChild(fpsElement);
        }

        // Get performance stats from World
        var perfStats = World && World.getPerformanceStats ? World.getPerformanceStats() : null;
        var statsText = 'FPS: ' + currentFPS;
        if (perfStats) {
          statsText += '\nObjects: ' + perfStats.visibleObjects + '/' + perfStats.totalObjects;
          statsText += '\nAnimations: ' + perfStats.activeAnimations;
          statsText += '\nChunks: ' + perfStats.loadedChunks;
          statsText += '\nTriangles: ' + perfStats.estimatedTriangles;
        }
        fpsElement.innerText = statsText;
      }
    }

    // Check for break reminder (every 30 minutes)
    const minutesPlayed = (Date.now() - playStartTime) / 60000;
    if (minutesPlayed > 30 && minutesPlayed - lastBreakReminder > 30) {
      if (HUD) {
        HUD.showBreakReminder(Math.floor(minutesPlayed));
      }
      lastBreakReminder = minutesPlayed;
    }

    // Auto-save player data periodically
    var nowMs = Date.now();
    if (nowMs - lastAutoSave > AUTO_SAVE_INTERVAL) {
      lastAutoSave = nowMs;
      autoSavePlayerData();
    }

    // Check for nearby secrets periodically
    if (nowMs - lastSecretCheck > SECRET_CHECK_INTERVAL) {
      lastSecretCheck = nowMs;
      checkSecrets();
    }

    // Update economic event display periodically (every 30 seconds)
    if (nowMs - lastEventCheck > 30000) {
      lastEventCheck = nowMs;
      updateEconomicEvent();
    }

    // Update seasonal event periodically
    if (nowMs - lastSeasonCheck > SEASON_CHECK_INTERVAL) {
      lastSeasonCheck = nowMs;
      updateSeasonalEvent();
    }

    // Update pet status periodically
    if (nowMs - lastPetUpdate > PET_UPDATE_INTERVAL) {
      lastPetUpdate = nowMs;
      updatePetStatus();
    }

    // Tick CRM simulation periodically
    if (typeof SimCRM !== 'undefined' && SimCRM.simulateTick && simCrmState && nowMs - lastSimCrmTick >= SIM_CRM_TICK_INTERVAL) {
      lastSimCrmTick = nowMs;
      simCrmState = SimCRM.simulateTick(simCrmState);
    }

    // Update API bridge (state publishing + inbox polling)
    if (ApiBridge && ApiBridge.update) {
      ApiBridge.update(nowMs, gameState);
    }

    // Request next frame
    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    }
  }

  /**
   * Process queued incoming messages
   */
  function processMessageQueue() {
    while (messageQueue.length > 0) {
      const msg = messageQueue.shift();
      applyMessage(msg);
    }
  }

  /**
   * Handle federation events from Network module
   */
  function handleFederationEvent(event) {
    if (!event || !event.type) return;

    switch (event.type) {
      case 'world_discovered':
        console.log('Discovered federated world:', event.worldInfo.worldName);
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Discovered world: ' + event.worldInfo.worldName, 'info');
        }
        if (HUD && HUD.updateFederationStatus) {
          HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
        }
        break;

      case 'federation_established':
        console.log('Federation established with:', event.worldInfo.worldName);
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Portal opened to: ' + event.worldInfo.worldName, 'success');
        }
        if (HUD && HUD.updateFederationStatus) {
          HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
        }
        // Create portal in 3D world if in Nexus
        if (World && sceneContext && currentZone === 'nexus') {
          createFederationPortal(event.worldInfo);
        }
        break;

      case 'cross_world_warp':
        console.log('Player warping to world:', event.targetWorld);
        triggerCameraShake(0.4, 0.6);
        triggerScreenFlash('rgba(138,43,226,0.4)', 0.5);
        break;

      case 'player_returned':
        console.log('Player returned:', event.playerId);
        break;

      default:
        console.log('Unknown federation event:', event.type);
    }
  }

  /**
   * Create a federation portal in the 3D world
   */
  function createFederationPortal(worldInfo) {
    if (!World || !sceneContext || !World.createPortal) return;

    // Position portals around the nexus
    var portalCount = Network.getFederatedWorlds().length;
    var angle = (portalCount * Math.PI * 2) / 8; // Spread around circle
    var radius = 30;
    var x = Math.cos(angle) * radius;
    var z = Math.sin(angle) * radius;

    var portalData = {
      id: 'portal-fed-' + worldInfo.worldId,
      position: { x: x, y: 0, z: z },
      targetWorld: worldInfo.worldId,
      worldName: worldInfo.worldName,
      type: 'federation'
    };

    World.createPortal(sceneContext, portalData);
    console.log('Created federation portal to:', worldInfo.worldName);
  }

  /**
   * Handle incoming network message
   */
  function handleIncomingMessage(msg) {
    // Validate message
    if (!Protocol) {
      return;
    }
    // Accept messages even without full protocol validation for P2P
    // (remote peers may send slightly different formats)
    if (Protocol.validateMessage) {
      var validation = Protocol.validateMessage(msg);
      if (!validation.valid) {
        // Only reject if completely malformed (no type or from)
        if (!msg || !msg.type || !msg.from) {
          console.warn('Invalid message received (no type/from):', msg);
          return;
        }
      }
    }

    // Add to queue for processing
    messageQueue.push(msg);
  }

  /**
   * Apply message to game state
   */
  function applyMessage(msg) {
    if (!gameState || !State) return;

    switch (msg.type) {
      case 'join':
        handleJoinMessage(msg);
        break;
      case 'leave':
        handleLeaveMessage(msg);
        break;
      case 'move':
        handleMoveMessage(msg);
        break;
      case 'chat':
      case 'say':
      case 'shout':
      case 'whisper':
        handleChatMessage(msg);
        break;
      case 'warp':
        handleWarpMessage(msg);
        break;
      case 'harvest':
        handleHarvestMessage(msg);
        break;
      case 'build':
        handleBuildMessage(msg);
        break;
      case 'trade':
        handleTradeMessage(msg);
        break;
      case 'trade_offer':
      case 'trade_accept':
      case 'trade_decline':
        handleTradeProtocolMessage(msg);
        break;
      case 'emote':
        handleEmoteMessage(msg);
        break;
      case 'discover':
        handleDiscoverMessage(msg);
        break;
      case 'score':
        handleScoreMessage(msg);
        break;
      case 'federation_announce':
        handleFederationAnnounce(msg);
        break;
      case 'federation_handshake':
        handleFederationHandshake(msg);
        break;
      case 'warp_fork':
        handleWarpFork(msg);
        break;
      case 'return_home':
        handleReturnHome(msg);
        break;
      default:
        console.log('Unknown message type:', msg.type);
    }
  }

  /**
   * Handle emote message
   */
  function handleEmoteMessage(msg) {
    if (!msg.payload || !msg.payload.emoteType) return;

    // Play animation on remote player mesh
    if (World && sceneContext && NPCs && NPCs.playEmoteAnimation) {
      var playerMesh = World.getPlayerMesh ? World.getPlayerMesh(sceneContext, msg.from) : null;
      if (playerMesh) {
        NPCs.playEmoteAnimation(playerMesh, msg.payload.emoteType);
      }
    }

    // Show emote bubble
    if (HUD && HUD.showEmoteBubble) {
      HUD.showEmoteBubble(msg.from, msg.payload.emoteType);
    }
  }

  /**
   * Handle discover message
   */
  function handleDiscoverMessage(msg) {
    if (!Exploration || !gameState) return;

    var result = Exploration.handleDiscover(msg, gameState);
    if (result.success) {
      // Update game state
      gameState = result.state;

      // If this is the local player, show discovery popup and update spark
      if (msg.from === localPlayer.id) {
        if (HUD && HUD.showDiscoveryPopup) {
          var discoveryData = {
            name: result.discovery.type.charAt(0).toUpperCase() + result.discovery.type.slice(1),
            description: result.discovery.description,
            rarity: getRarityName(result.discovery.rarity),
            sparkReward: result.sparkAwarded
          };
          HUD.showDiscoveryPopup(discoveryData);
        }

        // Award spark
        if (economyLedger && Economy && result.sparkAwarded) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: result.discovery.rarity });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
        }

        // Track activity
        addRecentActivity('Discovered a ' + result.discovery.type);

        // Track discovery achievement
        trackAchievement('discover', { type: result.discovery.type, rarity: result.discovery.rarity });

        if (Audio) Audio.playSound('warp');
      }
    }
  }

  /**
   * Handle federation announce message
   */
  function handleFederationAnnounce(msg) {
    if (!Network) return;

    // Let Network module handle the discovery
    Network.handleFederationMessage(msg);

    // Update HUD if available
    if (HUD && HUD.updateFederationStatus) {
      HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
    }
  }

  /**
   * Handle federation handshake message
   */
  function handleFederationHandshake(msg) {
    if (!Network) return;

    // Let Network module handle the handshake
    Network.handleFederationMessage(msg);

    // Update HUD
    if (HUD && HUD.updateFederationStatus) {
      HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
    }

    // Show notification
    var worldName = msg.worldName || msg.payload?.worldName || 'Unknown World';
    if (HUD && HUD.showNotification) {
      HUD.showNotification('Federation established with ' + worldName, 'success');
    }
  }

  /**
   * Handle cross-world warp message
   */
  function handleWarpFork(msg) {
    if (!msg.payload || !msg.payload.target_world) return;

    var targetWorld = msg.payload.target_world;
    var playerId = msg.from;

    // If this is the local player, handle the warp
    if (playerId === localPlayer.id) {
      // Store home world if not already set
      if (!localPlayer.home_world) {
        localPlayer.home_world = Network.deriveWorldId();
      }

      // Update current world
      localPlayer.current_world = targetWorld;

      if (HUD && HUD.showNotification) {
        HUD.showNotification('Warping to federated world: ' + targetWorld, 'info');
      }

      // Add warp fork screen effects
      triggerCameraShake(0.4, 0.6);
      triggerScreenFlash('rgba(138,43,226,0.4)', 0.5);

      // In a real implementation, this would navigate to the other world's URL
      // For now, we just track the state
      console.log('Player warped to federated world:', targetWorld);
    } else {
      // Another player warped out
      if (gameState && State) {
        State.removePlayer(gameState, playerId);
      }

      if (World && sceneContext) {
        World.removePlayer(sceneContext, playerId);
      }

      if (HUD && HUD.showNotification) {
        HUD.showNotification(playerId + ' traveled to another world', 'info');
      }
    }
  }

  /**
   * Handle return home message
   */
  function handleReturnHome(msg) {
    var playerId = msg.from;

    // If this is the local player returning
    if (playerId === localPlayer.id) {
      var homeWorld = localPlayer.home_world || Network.deriveWorldId();
      localPlayer.current_world = homeWorld;

      if (HUD && HUD.showNotification) {
        HUD.showNotification('Returned to home world', 'success');
      }

      console.log('Player returned to home world:', homeWorld);
    } else {
      // Another player returned from traveling
      if (HUD && HUD.showNotification) {
        HUD.showNotification(playerId + ' returned from traveling', 'info');
      }
    }
  }

  /**
   * Handle score message for competitions
   */
  function handleScoreMessage(msg) {
    if (!Competition || !gameState) return;

    var result = Competition.handleScore(msg, gameState);
    if (result.success) {
      gameState = result.state;

      // Broadcast to spectators if any
      if (Competition.getSpectators) {
        var spectators = Competition.getSpectators(result.competition.id);
        if (spectators.length > 0 && Competition.broadcastToSpectators) {
          Competition.broadcastToSpectators(
            result.competition.id,
            'score_update',
            {
              playerId: msg.from,
              score: msg.payload.score,
              competition: result.competition
            }
          );
        }
      }

      // If competition ended, award spark to winner
      if (result.winner && result.sparkAward) {
        if (result.winner === localPlayer.id) {
          if (HUD) {
            HUD.showNotification('You won the competition! +' + result.sparkAward + ' Spark', 'success');
          }
          if (economyLedger && Economy) {
            Economy.earnSpark(economyLedger, localPlayer.id, 'competition', { complexity: 1.0 });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
          }
          // Award combat XP for winning
          if (Mentoring) {
            var combatXP = Mentoring.addSkillXP(localPlayer.id, 'combat', 25);
            if (combatXP.leveledUp && HUD) {
              HUD.showNotification('Combat skill increased to ' + combatXP.newLevelName + '!', 'success');
              emitLevelUpParticles();
            }
          }
        } else {
          // Participation XP even for losing
          if (Mentoring) {
            Mentoring.addSkillXP(localPlayer.id, 'combat', 8);
          }
        }
      }
    }
  }

  /**
   * Convert rarity number to name
   */
  function getRarityName(rarity) {
    if (rarity >= 0.9) return 'legendary';
    if (rarity >= 0.7) return 'epic';
    if (rarity >= 0.5) return 'rare';
    if (rarity >= 0.3) return 'uncommon';
    return 'common';
  }

  /**
   * Handle join message
   */
  function handleJoinMessage(msg) {
    const player = {
      id: msg.from,
      name: msg.from,
      position: msg.payload.position || { x: 0, y: 0, z: 0 },
      zone: msg.payload.zone || 'nexus',
      spark: 1000,
      warmth: 0
    };

    State.addPlayer(gameState, player);

    if (World && sceneContext) {
      World.addPlayer(sceneContext, player.id, player.position);
    }

    if (HUD) {
      HUD.showNotification(`${player.name} joined the world`, 'success');
    }

    if (Audio) {
      Audio.playSound('warp');
    }
  }

  /**
   * Handle leave message
   */
  function handleLeaveMessage(msg) {
    State.removePlayer(gameState, msg.from);

    if (World && sceneContext) {
      World.removePlayer(sceneContext, msg.from);
    }

    if (HUD) {
      HUD.showNotification(`${msg.from} left the world`, 'info');
    }
  }

  /**
   * Handle move message
   */
  function handleMoveMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.position = msg.payload.position;
    player.zone = msg.payload.zone;

    // Update in world if not local player
    if (msg.from !== localPlayer.id && World && sceneContext) {
      World.movePlayer(sceneContext, msg.from, player.position);
    }
  }

  /**
   * Handle chat message
   */
  function handleChatMessage(msg) {
    var text = msg.payload.message || msg.payload.text || '';
    var sender = msg.from;

    if (Social) {
      Social.addMessage(gameState, {
        user: sender,
        text: text,
        timestamp: msg.timestamp || msg.ts
      });
    }

    // Update chat HUD with the new message
    if (HUD && HUD.addChatMessage) {
      HUD.addChatMessage(sender, text);
    } else if (HUD) {
      // Fallback: show as notification if chat panel not available
      HUD.showNotification(sender + ': ' + text, 'info');
    }

    if (Audio) {
      Audio.playSound('chat');
    }
  }

  /**
   * Handle warp message
   */
  function handleWarpMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.zone = msg.payload.zone;
    player.position = msg.payload.position;

    if (msg.from === localPlayer.id) {
      currentZone = msg.payload.zone;

      // Get zone center position from World
      var zonePos = World.getZoneCenter ? World.getZoneCenter(currentZone) : {x: 0, z: 0};
      localPlayer.position.x = zonePos.x;
      localPlayer.position.z = zonePos.z;
      localPlayer.position.y = 0;

      // Update chunks for new position
      if (World.updateChunks) {
        World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
      }

      if (HUD) {
        HUD.updateZoneLabel(currentZone);
      }

      if (Audio) {
        Audio.playAmbient(currentZone);
      }

      if (NPCs) {
        NPCs.reloadZoneNPCs(sceneContext, currentZone);
      }
    }

    // Emit portal warp particles (cyan swirl at player position)
    if (World && World.emitParticles && player && player.position) {
      var warpPos = { x: player.position.x, y: player.position.y + 1, z: player.position.z };
      World.emitParticles('fountain', warpPos, 15);
    }

    if (Audio) {
      Audio.playSound('warp');
    }

    // Add warp screen effects
    if (msg.from === localPlayer.id) {
      triggerCameraShake(0.3, 0.5);
      triggerScreenFlash('rgba(0,120,255,0.4)', 0.4);
    }
  }

  /**
   * Handle harvest message
   */
  function handleHarvestMessage(msg) {
    if (Economy) {
      Economy.earnSpark(gameState, msg.from, msg.payload.amount || 10);
    }

    if (Audio) {
      Audio.playSound('harvest');
    }

    if (msg.from === localPlayer.id && HUD) {
      HUD.showNotification(`Harvested ${msg.payload.amount || 10} Spark`, 'success');
    }
  }

  /**
   * Handle build message
   */
  function handleBuildMessage(msg) {
    // Route simulation messages
    if (msg.payload && msg.payload.sim === 'crm' && typeof SimCRM !== 'undefined' && simCrmState) {
      simCrmState = SimCRM.applyAction(simCrmState, msg);
      console.log('[SimCRM] Applied action:', msg.payload.action);
      return;
    }

    if (Creation && World && sceneContext) {
      const structure = msg.payload.structure;
      World.addStructure(sceneContext, structure);
    }

    if (Audio) {
      Audio.playSound('build');
    }

    if (msg.from === localPlayer.id) {
      var structureName = msg.payload.structure.type || 'structure';
      addRecentActivity('Built a ' + structureName);
    }
  }

  /**
   * Handle trade message (legacy)
   */
  function handleTradeMessage(msg) {
    if (Economy) {
      Economy.transferSpark(
        gameState,
        msg.payload.from,
        msg.payload.to,
        msg.payload.amount
      );
    }

    if (Audio) {
      Audio.playSound('trade');
    }

    if (HUD && (msg.payload.from === localPlayer.id || msg.payload.to === localPlayer.id)) {
      HUD.showNotification(
        `Trade: ${msg.payload.amount} Spark`,
        'success'
      );
    }
  }

  /**
   * Handle trade protocol messages
   */
  function handleTradeProtocolMessage(msg) {
    if (!Trading || !HUD) return;

    var result = Trading.handleTradeMessage(msg);
    if (!result) return;

    switch (result.type) {
      case 'trade_request':
        // Only show to target player
        if (result.data.to === localPlayer.id) {
          HUD.showTradeRequest(
            result.data.from,
            result.data.tradeId,
            function(tradeId) {
              // Accept trade
              var acceptResult = Trading.acceptTrade(tradeId, localPlayer.id, localPlayer.position);
              if (acceptResult.success) {
                showTradeWindowForActive(acceptResult.trade);
              } else {
                HUD.showNotification(acceptResult.message, 'error');
              }
            },
            function(tradeId) {
              // Decline trade
              Trading.declineTrade(tradeId, localPlayer.id, localPlayer.position);

              // Record decline for harassment detection
              if (Social && result.data.from) {
                var harassment = Social.recordDecline(result.data.from, localPlayer.id, 'trade_offer');
                if (harassment && HUD) {
                  HUD.showNotification('Repeated unwanted interactions detected - reputation penalty applied', 'warning');
                }
              }
            }
          );
        }
        break;

      case 'trade_accepted':
        // Trade was accepted, show window
        var activeTrade = Trading.getActiveTrade(localPlayer.id);
        if (activeTrade) {
          showTradeWindowForActive(activeTrade);
          HUD.showNotification('Trade started!', 'success');
        }
        break;

      case 'trade_update':
        // Update trade window if open
        var currentTrade = Trading.getActiveTrade(localPlayer.id);
        if (currentTrade && HUD.updateTradeWindow) {
          HUD.updateTradeWindow(currentTrade, localPlayer.id);
        }
        break;

      case 'trade_confirm':
        // Other player confirmed
        var confirmTrade = Trading.getActiveTrade(localPlayer.id);
        if (confirmTrade && HUD.updateTradeWindow) {
          HUD.updateTradeWindow(confirmTrade, localPlayer.id);
        }
        break;

      case 'trade_complete':
        // Trade completed
        HUD.hideTradeWindow();
        HUD.showTradeComplete(msg.from);
        if (Audio) Audio.playSound('trade');

        // Emit trade complete particles (gold sparkle at player position)
        if (World && World.emitParticles && localPlayer && localPlayer.position) {
          var tradePos = { x: localPlayer.position.x, y: localPlayer.position.y + 1.5, z: localPlayer.position.z };
          World.emitParticles('sparkle', tradePos, 12);
        }

        // Track trade achievement
        trackAchievement('trade', { with: msg.from });

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'trading', 15);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Trading skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        // Award reputation for trading
        if (Social) {
          var repResult = Social.adjustReputation(localPlayer.id, 'trading', { with: msg.from });
          if (repResult.tierChanged && HUD) {
            HUD.showNotification('Reputation increased to ' + repResult.tier + '!', 'success');
          }
          if (HUD && HUD.updateReputationDisplay) {
            HUD.updateReputationDisplay(Social.getReputation(localPlayer.id));
          }
        }

        // Update inventory display
        if (HUD.updateInventoryDisplay && playerInventory) {
          HUD.updateInventoryDisplay(playerInventory);
          HUD.updateQuickBar(playerInventory);
        }
        // Update player info with new Spark balance
        if (localPlayer && economyLedger) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          HUD.updatePlayerInfo(localPlayer);
        }
        break;

      case 'trade_cancelled':
        // Trade cancelled
        HUD.hideTradeWindow();
        HUD.hideTradeRequest();
        HUD.showNotification('Trade cancelled', 'info');
        break;
    }
  }

  /**
   * Show trade window for active trade
   */
  function showTradeWindowForActive(trade) {
    if (!HUD || !Trading) return;

    HUD.showTradeWindow(
      trade,
      localPlayer.id,
      // onAddItem - not implemented yet (would need inventory selector UI)
      null,
      // onRemoveItem
      function(tradeSlot) {
        var result = Trading.removeItemFromTrade(trade.id, localPlayer.id, tradeSlot, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onSetSpark
      function(amount) {
        var result = Trading.setSparkOffer(trade.id, localPlayer.id, amount, economyLedger, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onReady
      function() {
        var result = Trading.setReady(trade.id, localPlayer.id, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onConfirm
      function() {
        // Get both player inventories (in real multiplayer, you'd only have your own)
        // For demo purposes, we're using local inventories
        var player1Inv = trade.player1.id === localPlayer.id ? playerInventory : playerInventory;
        var player2Inv = trade.player2.id === localPlayer.id ? playerInventory : playerInventory;

        var result = Trading.confirmTrade(trade.id, localPlayer.id, player1Inv, player2Inv, economyLedger, localPlayer.position);
        if (result.success && result.executed) {
          HUD.hideTradeWindow();
          HUD.showTradeComplete(trade.player1.id === localPlayer.id ? trade.player2.id : trade.player1.id);
          if (Audio) Audio.playSound('trade');
          // Update displays
          if (HUD.updateInventoryDisplay && playerInventory) {
            HUD.updateInventoryDisplay(playerInventory);
            HUD.updateQuickBar(playerInventory);
          }
          if (localPlayer && economyLedger) {
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            HUD.updatePlayerInfo(localPlayer);
          }
        } else if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onCancel
      function() {
        Trading.cancelTrade(trade.id, localPlayer.id, localPlayer.position);
        HUD.hideTradeWindow();
      }
    );
  }

  // NPC shop inventories by archetype
  var NPC_SHOP_ITEMS = {
    merchant: [
      { id: 'torch', name: 'Torch', price: 8, description: 'Lights the way', icon: '&#128294;' },
      { id: 'rope', name: 'Rope', price: 12, description: 'Useful for climbing and building', icon: '&#129526;' },
      { id: 'compass', name: 'Compass', price: 20, description: 'Helps with navigation', icon: '&#129517;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' },
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'spyglass', name: 'Spyglass', price: 35, description: 'See far-off landmarks', icon: '&#128269;' },
      { id: 'lantern_oil', name: 'Lantern Oil', price: 6, description: 'Fuel for lanterns', icon: '&#128167;' }
    ],
    trader: [
      { id: 'rare_seed', name: 'Rare Seed', price: 30, description: 'Grows into a rare plant', icon: '&#127793;' },
      { id: 'crystal_shard', name: 'Crystal Shard', price: 40, description: 'A glowing fragment', icon: '&#128142;' },
      { id: 'ancient_coin', name: 'Ancient Coin', price: 50, description: 'A relic from the founding', icon: '&#129689;' },
      { id: 'silk_thread', name: 'Silk Thread', price: 22, description: 'Fine textile material', icon: '&#129525;' },
      { id: 'copper_ingot', name: 'Copper Ingot', price: 18, description: 'Refined copper metal', icon: '&#129704;' }
    ],
    farmer: [
      { id: 'wheat_seed', name: 'Wheat Seeds', price: 5, description: 'Basic crop seeds', icon: '&#127806;' },
      { id: 'flower_seed', name: 'Flower Seeds', price: 8, description: 'Decorative flowers', icon: '&#127804;' },
      { id: 'herb_seed', name: 'Herb Seeds', price: 10, description: 'Medicinal herbs', icon: '&#127807;' },
      { id: 'fertilizer', name: 'Fertilizer', price: 15, description: 'Speeds up growth', icon: '&#128169;' },
      { id: 'seed_wildflower', name: 'Wildflower Seeds', price: 4, description: 'Beautiful wildflowers', icon: '&#127803;' }
    ],
    artisan: [
      { id: 'pigment', name: 'Pigment', price: 12, description: 'Natural color pigment', icon: '&#127912;' },
      { id: 'canvas', name: 'Canvas', price: 15, description: 'For painting masterworks', icon: '&#128444;' },
      { id: 'clay', name: 'Clay', price: 8, description: 'Moldable material', icon: '&#129520;' },
      { id: 'ink_bottle', name: 'Ink Bottle', price: 10, description: 'For writing and drawing', icon: '&#128395;' },
      { id: 'golden_frame', name: 'Golden Frame', price: 35, description: 'Display art beautifully', icon: '&#128444;' }
    ],
    gardener: [
      { id: 'seed_wildflower', name: 'Wildflower Seeds', price: 4, description: 'Beautiful wildflowers', icon: '&#127803;' },
      { id: 'herb_seed', name: 'Herb Seeds', price: 10, description: 'Medicinal herbs', icon: '&#127807;' },
      { id: 'rare_seed', name: 'Rare Seed', price: 30, description: 'Unusual plant variety', icon: '&#127793;' },
      { id: 'fertilizer', name: 'Fertilizer', price: 15, description: 'Speeds up growth', icon: '&#128169;' },
      { id: 'garden_shears', name: 'Garden Shears', price: 18, description: 'For pruning and shaping', icon: '&#9986;' }
    ],
    scholar: [
      { id: 'scroll_blank', name: 'Blank Scroll', price: 8, description: 'For recording knowledge', icon: '&#128220;' },
      { id: 'ink_bottle', name: 'Ink Bottle', price: 10, description: 'For writing', icon: '&#128395;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' },
      { id: 'lens', name: 'Magnifying Lens', price: 25, description: 'For studying fine details', icon: '&#128270;' },
      { id: 'ancient_tome', name: 'Ancient Tome', price: 45, description: 'Contains forgotten wisdom', icon: '&#128214;' }
    ],
    warrior: [
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'training_weight', name: 'Training Weight', price: 15, description: 'For strength training', icon: '&#127947;' },
      { id: 'bandage', name: 'Bandage', price: 8, description: 'First aid supply', icon: '&#129657;' },
      { id: 'arena_token', name: 'Arena Token', price: 20, description: 'Entry to special events', icon: '&#127941;' }
    ],
    musician: [
      { id: 'flute', name: 'Flute', price: 28, description: 'A simple wooden flute', icon: '&#127925;' },
      { id: 'drum', name: 'Drum', price: 22, description: 'A hand drum', icon: '&#129345;' },
      { id: 'bell', name: 'Bell', price: 15, description: 'A clear-toned bell', icon: '&#128276;' },
      { id: 'sheet_music', name: 'Sheet Music', price: 12, description: 'Musical compositions', icon: '&#127926;' }
    ],
    explorer: [
      { id: 'compass', name: 'Compass', price: 20, description: 'Never lose your way', icon: '&#129517;' },
      { id: 'rope', name: 'Rope', price: 12, description: 'For difficult terrain', icon: '&#129526;' },
      { id: 'spyglass', name: 'Spyglass', price: 35, description: 'See far-off landmarks', icon: '&#128269;' },
      { id: 'trail_ration', name: 'Trail Ration', price: 8, description: 'Sustenance for the road', icon: '&#127838;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' }
    ],
    healer: [
      { id: 'healing_herb', name: 'Healing Herb', price: 10, description: 'Soothing medicinal plant', icon: '&#127807;' },
      { id: 'bandage', name: 'Bandage', price: 8, description: 'First aid supply', icon: '&#129657;' },
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'herbal_tea', name: 'Herbal Tea', price: 6, description: 'Calming warm drink', icon: '&#127861;' }
    ]
  };

  /**
   * Handle NPC dialog action button clicks
   */
  function handleNPCAction(action, npcData) {
    if (!npcData || !localPlayer) return;

    switch (action) {
      case 'trade':
        var shopItems = NPC_SHOP_ITEMS[npcData.archetype] || NPC_SHOP_ITEMS.merchant;
        if (HUD && HUD.showNPCShop) {
          HUD.showNPCShop(npcData, shopItems, localPlayer.spark, function onBuyItem(itemId) {
            var item = shopItems.find(function(i) { return i.id === itemId; });
            if (!item) return;
            if (localPlayer.spark < item.price) {
              if (HUD) HUD.showNotification('Not enough Spark!', 'error');
              return;
            }
            if (economyLedger && Economy) {
              var result = Economy.spendSpark(economyLedger, localPlayer.id, item.price);
              if (!result.success) {
                if (HUD) HUD.showNotification('Transaction failed', 'error');
                return;
              }
              localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            } else {
              localPlayer.spark -= item.price;
            }
            if (Inventory && playerInventory) {
              Inventory.addItem(playerInventory, item.id, 1);
              if (HUD) {
                HUD.showItemPickup(item.name, 1, item.icon);
                HUD.updateInventoryDisplay(playerInventory);
              }
            }
            if (HUD) {
              HUD.updatePlayerInfo(localPlayer);
              HUD.showNotification('Bought ' + item.name + ' for ' + item.price + ' Spark', 'success');
            }
            if (Audio) Audio.playSound('trade');
            // Refresh shop with updated balance
            HUD.showNPCShop(npcData, shopItems, localPlayer.spark, onBuyItem);
            addRecentActivity('Bought ' + item.name + ' from ' + npcData.name);
          });
        }
        break;

      case 'learn':
        if (HUD) {
          var teachingMsg = '';
          if (typeof NPC_AI !== 'undefined' && NPC_AI.getTeaching) {
            var teaching = NPC_AI.getTeaching(npcData.archetype, {});
            if (teaching) {
              teachingMsg = npcData.name + ' teaches you about ' + teaching.topic + ': "' + teaching.description + '"';
              if (Economy && economyLedger) {
                Economy.earnSpark(economyLedger, localPlayer.id, 'teach', { complexity: 0.5 });
                localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
                HUD.updatePlayerInfo(localPlayer);
              }
            } else {
              teachingMsg = npcData.name + ' has nothing more to teach you right now.';
            }
          } else {
            teachingMsg = npcData.name + ' shares some wisdom with you.';
            if (Economy && economyLedger) {
              Economy.earnSpark(economyLedger, localPlayer.id, 'teach', { complexity: 0.3 });
              localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
              HUD.updatePlayerInfo(localPlayer);
            }
          }
          HUD.showNotification(teachingMsg, 'info');
          addRecentActivity('Learned from ' + npcData.name);
        }
        break;

      case 'lore':
        if (HUD) {
          var loreMsg = '';
          if (typeof NPC_AI !== 'undefined' && NPC_AI.getLore) {
            var lore = NPC_AI.getLore(npcData.archetype, {});
            if (lore) {
              loreMsg = npcData.name + ' tells you: "' + lore + '"';
            } else {
              loreMsg = npcData.name + ' has shared all their stories with you.';
            }
          } else {
            loreMsg = npcData.name + ' tells you a tale of the founding of ZION.';
          }
          HUD.showNotification(loreMsg, 'info');
          addRecentActivity('Heard lore from ' + npcData.name);
        }
        break;
    }
  }

  /**
   * Handle resource node harvesting
   */
  function handleResourceHarvest(node) {
    if (!World || !Inventory || !playerInventory) return;

    var itemId = World.harvestResource(node);
    if (!itemId) {
      if (HUD) HUD.showNotification('Resource already depleted', 'warning');
      return;
    }

    var itemData = Inventory.getItemData(itemId);
    if (!itemData) return;

    var result = Inventory.addItem(playerInventory, itemId, 1);
    if (result.success) {
      if (HUD) {
        HUD.showItemPickup(itemData.name, 1, itemData.icon);
        HUD.updateInventoryDisplay(playerInventory);
        HUD.updateQuickBar(playerInventory);
      }

      if (economyLedger && Economy) {
        // Apply Warmth bonus to harvest yields (minor, cosmetic-adjacent per Â§5.3)
        var harvestComplexity = 0.5;
        if (Physical && localPlayer.warmth > 0) {
          var warmthBonus = Physical.getWarmthBonus(localPlayer.warmth);
          harvestComplexity = Math.min(1.0, harvestComplexity * warmthBonus);
        }
        var sparkEarned = Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: harvestComplexity });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'gardening', 5);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Gardening skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      // Emit harvest success particles (green/gold upward burst)
      if (World && World.emitParticles && node.position) {
        var harvestPos = { x: node.position.x, y: node.position.y + 1, z: node.position.z };
        World.emitParticles('sparkle', harvestPos, 8);
      }

      if (Quests) {
        var updated = Quests.updateQuestProgress(localPlayer.id, 'collect', { item: itemId, amount: 1 });
        if (updated.length > 0 && HUD) {
          updated.forEach(function(quest) {
            HUD.showQuestProgress('Quest progress: ' + quest.title);
          });
        }
      }

      // Roll for bonus zone loot drop
      if (Inventory.rollHarvestDrop) {
        var luck = Physical && localPlayer.warmth > 0 ? Physical.getWarmthBonus(localPlayer.warmth) : 1.0;
        var bonusDrop = Inventory.rollHarvestDrop(currentZone, luck);
        if (bonusDrop) {
          var bonusResult = Inventory.addItem(playerInventory, bonusDrop.id, 1);
          if (bonusResult.success) {
            var bonusData = Inventory.getItemData(bonusDrop.id);
            if (bonusData && HUD) {
              setTimeout(function() {
                HUD.showItemPickup(bonusData.name, 1, bonusData.icon);
              }, 500);
            }
          }
        }
      }

      // Apply economic event modifier to harvest spark
      if (Economy && Economy.applyEventModifier && economyLedger) {
        var eventBonus = Economy.applyEventModifier(0, 'harvest');
        if (eventBonus > 0) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: 0.2 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
      }

      // Apply seasonal bonus to harvest
      var harvestSeasonBonus = getSeasonalBonus('garden');
      if (harvestSeasonBonus > 1.0 && Economy && economyLedger) {
        var bonusSpark = Math.round((harvestSeasonBonus - 1.0) * 5);
        if (bonusSpark > 0) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: 0.1 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
      }

      // Track harvest achievement
      trackAchievement('harvest', { item: itemId, zone: currentZone });

      if (Audio) Audio.playSound('harvest');

      // Track activity
      addRecentActivity('Collected ' + itemData.name);
    } else {
      if (HUD) HUD.showNotification(result.message, 'warning');
    }
  }

  /**
   * Handle crafting
   */
  function handleCraft(recipeId) {
    if (!Inventory || !playerInventory) return;

    var result = Inventory.craftItem(playerInventory, recipeId);
    if (result.success) {
      if (HUD) {
        HUD.showNotification(result.message, 'success');
        HUD.updateInventoryDisplay(playerInventory);
        HUD.updateCraftingDisplay(playerInventory);
        HUD.updateQuickBar(playerInventory);
      }

      if (economyLedger && Economy && result.sparkEarned) {
        Economy.earnSpark(economyLedger, localPlayer.id, 'craft', { complexity: result.sparkEarned / 50 });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'crafting', 10);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Crafting skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (Quests) {
        Quests.updateQuestProgress(localPlayer.id, 'craft', { item: result.output.itemId, amount: result.output.count });
      }

      // Track craft achievement
      trackAchievement('craft', { item: result.output.itemId, recipe: recipeId });

      // Emit craft success particles (orange/white sparkle at player position)
      if (World && World.emitParticles && localPlayer && localPlayer.position) {
        var craftPos = { x: localPlayer.position.x, y: localPlayer.position.y + 1.5, z: localPlayer.position.z };
        World.emitParticles('fire', craftPos, 10);
      }

      if (Audio) Audio.playSound('build');
    } else {
      if (HUD) HUD.showNotification(result.message, 'error');
    }
  }

  /**
   * Handle compose (artwork creation)
   */
  function handleGuildCreate(guildData) {
    if (!Guilds || !localPlayer || !Economy || !economyLedger) return;

    // Check if player has enough Spark
    var balance = Economy.getBalance(economyLedger, localPlayer.id);
    if (balance < 100) {
      if (HUD) {
        HUD.showNotification('Not enough Spark to create guild (need 100)', 'error');
      }
      return;
    }

    var result = Guilds.createGuild(
      localPlayer.id,
      guildData.name,
      guildData.tag,
      guildData.type,
      guildData.description
    );

    if (result.success) {
      // Deduct cost
      Economy.debit(economyLedger, localPlayer.id, result.cost, 'Guild creation');

      if (HUD) {
        HUD.showNotification('Guild created: [' + guildData.tag + '] ' + guildData.name, 'success');
        HUD.updateGuildTag(guildData.tag);

        // Update player info to show new balance
        localPlayer.spark = balance - result.cost;
        HUD.updatePlayerInfo(localPlayer);

        // Show guild panel
        HUD.showGuildPanel(result.guild, { id: localPlayer.id });
      }

      addRecentActivity('Founded [' + guildData.tag + '] ' + guildData.name);
    } else {
      if (HUD) {
        HUD.showNotification('Failed to create guild: ' + result.error, 'error');
      }
    }
  }

  // Global guild action handler for panel buttons
  if (typeof window !== 'undefined') {
    window.handleGuildAction = function(action, data) {
      if (!Guilds || !localPlayer) return;

      switch (action) {
        case 'leave':
          var result = Guilds.leaveGuild(data, localPlayer.id);
          if (result.success) {
            if (HUD) {
              HUD.showNotification('You left the guild', 'info');
              HUD.updateGuildTag('');
            }
            addRecentActivity('Left guild');
          } else {
            if (HUD) {
              HUD.showNotification('Failed to leave guild: ' + result.error, 'error');
            }
          }
          break;
      }
    };
  }

  function handleComposeAction(composeData) {
    if (!Creation || !localPlayer) return;

    // Handle music composition (from new compose panel with notes/instrument)
    if (composeData.notes && composeData.instrument) {
      var noteNames = composeData.notes.map(function(n) { return n.note; }).join('-');
      var msg = {
        type: 'compose',
        from: localPlayer.id,
        timestamp: Date.now(),
        nonce: Math.random().toString(36).substr(2, 9),
        payload: {
          composeType: 'music',
          title: 'Melody (' + composeData.notes.length + ' notes)',
          content: JSON.stringify({ notes: composeData.notes, instrument: composeData.instrument }),
          zone: currentZone,
          position: localPlayer.position
        }
      };

      var result = Creation.handleCompose(msg, gameState);
      if (result.success) {
        if (HUD) HUD.showNotification('Composed a melody with ' + composeData.notes.length + ' notes!', 'success');
        // Play the composition for nearby players
        if (HUD.playComposition) HUD.playComposition(composeData.notes);

        if (economyLedger && Economy) {
          var sparkAmount = Math.min(50, 5 + composeData.notes.length * 2);
          Economy.earnSpark(economyLedger, localPlayer.id, 'compose', { complexity: sparkAmount / 50 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
        }

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 20);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        if (Audio) Audio.playSound('chat');
        addRecentActivity('Composed a melody with ' + composeData.notes.length + ' notes');
      }
      return;
    }

    var msg = {
      type: 'compose',
      from: localPlayer.id,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        composeType: composeData.type,
        title: composeData.title,
        content: composeData.content,
        zone: currentZone,
        position: localPlayer.position
      }
    };

    var result = Creation.handleCompose(msg, gameState);
    if (result.success) {
      if (HUD) {
        HUD.showNotification('Created ' + composeData.type + ': ' + composeData.title, 'success');
      }

      if (economyLedger && Economy && result.sparkReward) {
        Economy.earnSpark(economyLedger, localPlayer.id, 'compose', { complexity: result.sparkReward / 50 });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 15);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (Audio) Audio.playSound('chat');

      addRecentActivity('Created ' + composeData.type + ': ' + composeData.title);
    } else {
      if (HUD) HUD.showNotification(result.error, 'error');
    }
  }

  /**
   * Handle governance actions (elections, steward policies, etc.)
   */
  function handleGovernanceAction(action, data) {
    if (!Social || !Zones || !localPlayer) return;

    switch (action) {
      case 'startElection':
        // Start election in current zone
        var zoneId = data.zoneId || currentZone;
        var reputation = Social.getReputation(localPlayer.id);

        // Check if player meets requirements
        if (reputation.tier !== 'Respected' && reputation.tier !== 'Honored' && reputation.tier !== 'Elder') {
          if (HUD) HUD.showNotification('Must be Respected tier or higher to start an election', 'error');
          return;
        }

        // For now, create a simple election with the local player as a candidate
        // In a full implementation, this would open a dialog to add candidates
        var candidates = [localPlayer.id];
        var election = Zones.startElection(zoneId, candidates);

        if (HUD) {
          HUD.showNotification('Election started! Voting ends in 48 hours.', 'success');
          HUD.hideGovernancePanel();
          HUD.showGovernancePanel(zoneId, localPlayer);
        }

        // Broadcast election start to network
        if (Network && Protocol) {
          var msg = Protocol.create.election_start(localPlayer.id, {
            zoneId: zoneId,
            electionId: election.id,
            candidates: candidates
          });
          Network.broadcast(msg);
        }
        break;

      case 'vote':
        var electionId = data.electionId;
        var candidateId = data.candidateId;

        var voteResult = Zones.castVote(electionId, localPlayer.id, candidateId);
        if (voteResult.success) {
          if (HUD) {
            HUD.showNotification('Vote cast for ' + candidateId, 'success');
            HUD.hideGovernancePanel();
            HUD.showGovernancePanel(currentZone, localPlayer);
          }

          // Broadcast vote to network
          if (Network && Protocol) {
            var msg = Protocol.create.election_vote(localPlayer.id, {
              electionId: electionId,
              candidateId: candidateId
            });
            Network.broadcast(msg);
          }
        } else {
          if (HUD) HUD.showNotification(voteResult.error, 'error');
        }
        break;

      case 'savePolicies':
        var zoneId = data.zoneId || currentZone;

        // Set welcome message
        if (data.welcomeMessage !== undefined) {
          var msgResult = Zones.setWelcomeMessage(zoneId, localPlayer.id, data.welcomeMessage);
          if (!msgResult.success) {
            if (HUD) HUD.showNotification(msgResult.error, 'error');
            return;
          }
        }

        // Set policies
        if (data.buildingRequiresApproval !== undefined) {
          Zones.setZonePolicy(zoneId, localPlayer.id, 'buildingRequiresApproval', data.buildingRequiresApproval);
        }
        if (data.chatModerated !== undefined) {
          Zones.setZonePolicy(zoneId, localPlayer.id, 'chatModerated', data.chatModerated);
        }

        if (HUD) {
          HUD.showNotification('Zone policies updated', 'success');
          HUD.hideGovernancePanel();
          HUD.showGovernancePanel(zoneId, localPlayer);
        }

        // Award reputation for steward action
        Social.adjustReputation(localPlayer.id, 'zone_steward_action', { zoneId: zoneId });

        // Broadcast policy changes to network
        if (Network && Protocol) {
          var msg = Protocol.create.steward_set_policy(localPlayer.id, {
            zoneId: zoneId,
            policies: {
              welcomeMessage: data.welcomeMessage,
              buildingRequiresApproval: data.buildingRequiresApproval,
              chatModerated: data.chatModerated
            }
          });
          Network.broadcast(msg);
        }
        break;
    }
  }

  /**
   * Handle build mode actions
   */
  var buildModeActive = false;
  var BUILD_TYPES = [
    'bench', 'lantern', 'signpost', 'fence', 'planter',
    'campfire', 'archway', 'table', 'barrel', 'crate'
  ];
  var BUILD_COSTS = {
    bench: 15, lantern: 10, signpost: 5, fence: 8, planter: 12,
    campfire: 20, archway: 30, table: 15, barrel: 10, crate: 8
  };

  function handleBuildAction(data) {
    if (data.mode !== undefined) {
      // Toggle build mode
      buildModeActive = data.mode;

      if (buildModeActive) {
        if (World && World.enterBuildMode && sceneContext) {
          World.enterBuildMode(sceneContext);
        }
        if (HUD && HUD.showBuildToolbar) {
          HUD.showBuildToolbar();
        }
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Build mode activated - Click to place structures', 'info');
        }
      } else {
        if (World && World.exitBuildMode && sceneContext) {
          World.exitBuildMode(sceneContext);
        }
        if (HUD && HUD.hideBuildToolbar) {
          HUD.hideBuildToolbar();
        }
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Build mode deactivated', 'info');
        }
      }
    } else if (data.action === 'place') {
      // Place structure
      if (World && World.confirmPlacement && sceneContext && localPlayer) {
        var result = World.confirmPlacement(sceneContext, localPlayer.position, currentZone);
        if (result && result.error) {
          if (HUD && HUD.showNotification) {
            HUD.showNotification(result.error, 'error');
          }
        } else if (result) {
          // Deduct Spark cost for building
          var buildCost = BUILD_COSTS[result.type] || 10;
          if (economyLedger && Economy) {
            var spendResult = Economy.spendSpark(economyLedger, localPlayer.id, buildCost);
            if (!spendResult.success) {
              if (HUD && HUD.showNotification) {
                HUD.showNotification('Not enough Spark! Need ' + buildCost + ' Spark to build ' + result.type, 'error');
              }
              // Remove the placed structure since we can't afford it
              if (World && World.removeLastPlaced) {
                World.removeLastPlaced(sceneContext);
              }
              return;
            }
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
          }

          if (HUD && HUD.showNotification) {
            HUD.showNotification('Built ' + result.type + ' (-' + buildCost + ' Spark)', 'success');
          }

          // Award building XP
          if (Economy) {
            Economy.earnSpark(economyLedger, localPlayer.id, 'build', { complexity: 0.3 });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          }

          if (Mentoring) {
            var xpResult = Mentoring.addSkillXP(localPlayer.id, 'building', 12);
            if (xpResult.leveledUp && HUD) {
              HUD.showNotification('Building skill increased to ' + xpResult.newLevelName, 'success');
              emitLevelUpParticles();
            }
          }

          // Broadcast to network
          if (Network && Protocol) {
            var buildMsg = Protocol.create.build(localPlayer.id, {
              structureType: result.type,
              position: result.position,
              rotation: result.rotation || 0,
              zone: currentZone
            });
            Network.broadcastMessage(buildMsg);
          }

          // Track build achievement
          trackAchievement('build', { type: result.type, zone: currentZone });

          // Save structure to state
          if (gameState) {
            if (!gameState.structures) gameState.structures = [];
            gameState.structures.push({
              id: 'struct_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
              type: result.type,
              position: result.position,
              rotation: result.rotation || 0,
              zone: currentZone,
              builder: localPlayer.id,
              ts: Date.now()
            });
          }
        }
      }
    } else if (data.action === 'rotate') {
      // Rotate build preview
      if (World && World.rotateBuildPreview) {
        World.rotateBuildPreview(Math.PI / 4); // 45 degrees
      }
    } else if (data.action === 'selectType') {
      // Select build type by number key
      var typeIndex = data.typeIndex;
      if (typeIndex >= 0 && typeIndex < BUILD_TYPES.length) {
        var buildType = BUILD_TYPES[typeIndex];
        if (World && World.setBuildType) {
          World.setBuildType(buildType);
        }
        if (HUD && HUD.updateBuildToolbar) {
          HUD.updateBuildToolbar(buildType);
        }
      }
    }
  }

  /**
   * Handle local action (created by this client)
   */
  function handleLocalAction(type, payload) {
    let msg = null;

    switch (type) {
      case 'move':
        localPlayer.position = payload.position;
        localPlayer.zone = payload.zone;
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('move');
        break;

      case 'chat':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openChat');
        // Check for emote chat commands
        var message = payload.message;
        var emoteMatch = message.match(/^\/(wave|dance|bow|cheer|meditate|point)$/);
        if (emoteMatch) {
          // Trigger emote instead of chat
          handleLocalAction('emote', { type: emoteMatch[1] });
          return;
        }

        msg = Protocol.create.chat(localPlayer.id, { message: message, zone: currentZone, position: localPlayer.position });

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 3);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        // Broadcast player chat to NPCs for reaction
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'player_action', data: {
            playerId: localPlayer.id, action: 'chat',
            position: localPlayer.position, message: message
          }});
        }
        break;

      case 'emote':
        // Handle emote action
        if (World && sceneContext && localPlayer) {
          var playerMesh = World.getPlayerMesh ? World.getPlayerMesh(sceneContext, localPlayer.id) : null;
          if (playerMesh && NPCs && NPCs.playEmoteAnimation) {
            NPCs.playEmoteAnimation(playerMesh, payload.type);
          }
          if (HUD && HUD.showEmoteBubble) {
            HUD.showEmoteBubble(localPlayer.id, payload.type);
          }
          if (Audio) {
            Audio.playSound('chat');
          }
        }
        // Create and broadcast emote message
        msg = {
          type: 'emote',
          from: localPlayer.id,
          timestamp: Date.now(),
          nonce: Math.random().toString(36).substr(2, 9),
          payload: { emoteType: payload.type }
        };
        break;

      case 'toggleEmoteMenu':
        if (HUD) {
          var emoteMenuEl = document.getElementById('emote-menu');
          if (emoteMenuEl) {
            HUD.hideEmoteMenu();
          } else {
            HUD.showEmoteMenu();
          }
        }
        break;

      case 'toggleMap':
        if (HUD && localPlayer) {
          var mapEl = document.getElementById('world-map-overlay');
          if (mapEl) {
            HUD.hideWorldMap();
          } else {
            var npcPositions = NPCs && NPCs.getNPCPositions ? NPCs.getNPCPositions() : [];
            var landmarks = [];
            HUD.showWorldMap(localPlayer.position, npcPositions, landmarks);
          }
        }
        break;

      case 'togglePhotoMode':
        togglePhotoMode();
        break;

      case 'toggleSettings':
        if (HUD) {
          // Close any open panels/dialogs first
          var closedSomething = false;
          if (HUD.hideNPCDialog) {
            var npcDlg = document.getElementById('npc-dialog');
            if (npcDlg) { HUD.hideNPCDialog(); closedSomething = true; }
          }
          if (HUD.hideNPCShop) {
            var npcShop = document.getElementById('npc-shop-panel');
            if (npcShop) { HUD.hideNPCShop(); closedSomething = true; }
          }
          if (HUD.hideQuestOffer) {
            var questOffer = document.getElementById('quest-offer-panel');
            if (questOffer) { HUD.hideQuestOffer(); closedSomething = true; }
          }
          if (HUD.hideQuestLog) {
            var questLog = document.getElementById('quest-log-panel');
            if (questLog) { HUD.hideQuestLog(); closedSomething = true; }
          }
          if (HUD.hideWorldMap) {
            var worldMap = document.getElementById('world-map-overlay');
            if (worldMap) { HUD.hideWorldMap(); closedSomething = true; }
          }
          // Only toggle settings if nothing else was closed
          if (!closedSomething) {
            var settingsEl = document.getElementById('settings-menu-overlay');
            if (settingsEl) {
              HUD.hideSettingsMenu();
            } else {
              HUD.showSettingsMenu();
            }
          }
        }
        break;

      case 'toggleProfile':
        if (HUD && localPlayer) {
          var profileEl = document.getElementById('player-profile-panel') || document.getElementById('profile-panel');
          if (profileEl) {
            if (HUD.hideProfilePanel) HUD.hideProfilePanel();
            else if (HUD.hidePlayerProfile) HUD.hidePlayerProfile();
          } else {
            // Gather player stats
            var playerData = {
              name: localPlayer.name || 'Player',
              zone: currentZone,
              sparkBalance: economyLedger ? Economy.getBalance(economyLedger, localPlayer.id) : 0,
              playTimeSeconds: getPlayTimeSeconds(),
              itemsCollected: playerInventory ? playerInventory.items.length : 0,
              questsCompleted: Quests ? Quests.getCompletedQuests(localPlayer.id).length : 0,
              questsActive: Quests ? Quests.getActiveQuests(localPlayer.id).length : 0,
              npcsMet: NPCs && NPCs.getMetNPCs ? NPCs.getMetNPCs(localPlayer.id).length : 0,
              zonesDiscovered: Exploration ? Exploration.getDiscoveredZones(localPlayer.id, gameState).length : 1,
              structuresBuilt: Creation ? Creation.getPlayerStructures(localPlayer.id).length : 0,
              recentActivities: getRecentActivities(),
              reputationTier: Social && Social.getReputation ? Social.getReputation(localPlayer.id).tier : 'Newcomer'
            };

            // Gather skill data
            var skillData = {};
            if (Mentoring && Mentoring.getPlayerSkills) {
              skillData = Mentoring.getPlayerSkills(localPlayer.id);
            }

            // Use enhanced profile panel if available
            if (HUD.showProfilePanel) {
              HUD.showProfilePanel(playerData, skillData);
            } else if (HUD.showPlayerProfile) {
              HUD.showPlayerProfile(playerData);
            }
          }
        }
        break;

      case 'toggleGuild':
        if (HUD && Guilds && localPlayer) {
          var guildPanelEl = document.getElementById('guild-panel');
          if (guildPanelEl) {
            HUD.hideGuildPanel();
          } else {
            var playerGuild = Guilds.getPlayerGuild(localPlayer.id);
            if (playerGuild) {
              HUD.showGuildPanel(playerGuild, { id: localPlayer.id });
              // Update guild tag in HUD
              HUD.updateGuildTag(playerGuild.tag);
            } else {
              // Show guild creation form if not in a guild
              HUD.showGuildCreate(function(guildData) {
                handleGuildCreate(guildData);
              });
            }
          }
        }
        break;

      case 'toggleSkills':
        if (HUD && Mentoring && localPlayer) {
          var skillsPanelEl = document.getElementById('skills-panel');
          if (skillsPanelEl) {
            HUD.hideSkillsPanel();
          } else {
            var skillsData = Mentoring.getPlayerSkills(localPlayer.id);
            HUD.showSkillsPanel(skillsData);
          }
        }
        break;

      case 'toggleCompose':
        if (HUD && Creation && localPlayer) {
          var composePanelEl = document.getElementById('compose-panel');
          if (composePanelEl) {
            HUD.hideComposePanel();
          } else {
            HUD.showComposePanel(function(composeData) {
              handleComposeAction(composeData);
            });
          }
        }
        break;

      case 'interact':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('interact');
        // Check for nearby NPCs first
        if (NPCs && NPCs.interactWithNPC && localPlayer) {
          var npcResponse = NPCs.interactWithNPC(localPlayer.position.x, localPlayer.position.z, localPlayer.id);
          if (npcResponse) {
            // Show rich NPC interaction dialog
            if (HUD && HUD.showNPCDialog) {
              HUD.showNPCDialog(npcResponse);
            } else if (HUD) {
              HUD.showNotification(npcResponse.name + ': "' + npcResponse.message + '"', 'info');
            }

            // Handle quest interactions
            if (Quests && npcResponse.questInfo) {
              var questInfo = npcResponse.questInfo;

              if (questInfo.state === 'available') {
                // Show quest offer dialog
                if (HUD && HUD.showQuestOffer) {
                  HUD.showQuestOffer(questInfo.quest, { name: npcResponse.name, archetype: npcResponse.archetype }, localPlayer.id);
                }
              } else if (questInfo.state === 'complete') {
                // Turn in quest
                var result = Quests.completeQuest(localPlayer.id, questInfo.quest.id, gameState);
                if (result.success && HUD) {
                  HUD.showQuestComplete(result.quest, result.rewards);
                  // Update player spark display
                  localPlayer.spark += result.rewards.spark;
                  HUD.updatePlayerInfo(localPlayer);
                  // Track activity
                  addRecentActivity('Completed quest: ' + result.quest.title);
                  // Emit quest complete particles (rainbow burst - use sparkle and fountain for variety)
                  if (World && World.emitParticles && localPlayer && localPlayer.position) {
                    var questPos = { x: localPlayer.position.x, y: localPlayer.position.y + 2, z: localPlayer.position.z };
                    World.emitParticles('sparkle', questPos, 15);
                    World.emitParticles('fountain', questPos, 15);
                  }
                  // Piano accent for quest completion
                  if (Audio && Audio.playPianoAccent) Audio.playPianoAccent('quest_complete');
                  // Add quest completion screen effects
                  triggerCameraShake(0.2, 0.3);
                  triggerScreenFlash('#DAA520', 0.4);
                }
              }

              // Update quest progress for NPC interaction
              Quests.updateQuestProgress(localPlayer.id, 'talk_npc', { npcId: npcResponse.id });
            }

            if (Audio) Audio.playSound('chat');
            // Track NPC interaction achievement
            trackAchievement('npc_talk', { npcId: npcResponse.id, npcName: npcResponse.name });
            // Track activity
            addRecentActivity('Talked to ' + npcResponse.name);
            // Broadcast player interaction to other NPCs
            if (NPCs.broadcastEvent) {
              NPCs.broadcastEvent({ type: 'player_action', data: {
                playerId: localPlayer.id, action: 'interact_npc',
                position: localPlayer.position, targetNPC: npcResponse.id
              }});
            }
            break;
          }
        }
        // No NPC nearby â€” try interactive objects (benches, campfires, etc.)
        if (World && World.getInteractiveAtPosition && localPlayer) {
          var nearbyObj = World.getInteractiveAtPosition(localPlayer.position.x, localPlayer.position.z, 4);
          if (nearbyObj) {
            var objResult = World.interactWithObject(nearbyObj.id);
            if (objResult) {
              if (HUD) HUD.showNotification(objResult.message, 'info');
              if (Audio) Audio.playSound('chat');

              // Special actions for certain object types
              if (objResult.action === 'rest' || objResult.action === 'sit' || objResult.action === 'socialize') {
                // Resting recovers mood/energy
                addRecentActivity('Resting at ' + objResult.type.replace(/_/g, ' '));
              } else if (objResult.action === 'study' || objResult.action === 'access_lore') {
                if (Mentoring) {
                  var loreXP = Mentoring.addSkillXP(localPlayer.id, 'lore', 5);
                  if (loreXP.leveledUp && HUD) {
                    HUD.showNotification('Lore skill increased to ' + loreXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Studied at ' + objResult.type.replace(/_/g, ' '));
              } else if (objResult.action === 'practice_combat') {
                if (Mentoring) {
                  var combatXP = Mentoring.addSkillXP(localPlayer.id, 'combat', 5);
                  if (combatXP.leveledUp && HUD) {
                    HUD.showNotification('Combat skill increased to ' + combatXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Trained at combat dummy');
              } else if (objResult.action === 'create_art' || objResult.action === 'play_music') {
                if (Mentoring) {
                  var craftXP = Mentoring.addSkillXP(localPlayer.id, 'crafting', 5);
                  if (craftXP.leveledUp && HUD) {
                    HUD.showNotification('Crafting skill increased to ' + craftXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Created at ' + objResult.type.replace(/_/g, ' '));
              }

              trackAchievement('use_object', { type: objResult.type });
              break;
            }
          }
        }
        // No NPC or object nearby â€” try harvesting
        msg = Protocol.create.harvest(localPlayer.id, 10);
        // Update quest progress for harvest
        if (Quests) {
          var updated = Quests.updateQuestProgress(localPlayer.id, 'collect', { item: 'resource', amount: 1 });
          if (updated.length > 0 && HUD) {
            updated.forEach(function(quest) {
              HUD.showQuestProgress('Quest progress: ' + quest.title);
            });
          }
        }
        // Broadcast harvest action to NPCs
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'player_action', data: {
            playerId: localPlayer.id, action: 'harvest',
            position: localPlayer.position
          }});
        }
        break;

      case 'toggle_quest_log':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openQuests');
        // Toggle quest log panel
        if (HUD && Quests && localPlayer) {
          var questLogEl = document.getElementById('quest-log-panel');
          if (questLogEl) {
            HUD.hideQuestLog();
          } else {
            var questLog = Quests.getQuestLog(localPlayer.id, { level: 0 });
            HUD.showQuestLog(questLog, localPlayer.id);
          }
        }
        break;

      case 'toggleInventory':
        if (HUD && playerInventory) {
          HUD.toggleInventoryPanel();
          HUD.updateInventoryDisplay(playerInventory);
        }
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openInventory');
        break;

      case 'toggleCrafting':
        if (HUD && playerInventory) {
          HUD.toggleCraftingPanel();
          HUD.updateCraftingDisplay(playerInventory);
        }
        break;

      case 'toggleGovernance':
        if (HUD && localPlayer && Social && Zones) {
          // Initialize governance panel with callback
          if (!HUD.initGovernancePanel) {
            HUD.initGovernancePanel(handleGovernanceAction);
          }
          HUD.toggleGovernancePanel(currentZone, localPlayer);
        }
        break;

      case 'toggleAchievements':
        if (HUD && Quests && localPlayer) {
          var achievementPanelEl = document.getElementById('achievement-panel');
          if (achievementPanelEl) {
            if (HUD.hideAchievementPanel) HUD.hideAchievementPanel();
          } else {
            if (HUD.showAchievementPanel) HUD.showAchievementPanel(localPlayer.id);
          }
        }
        break;

      case 'toggleAuctions':
      case 'toggleAuctionHouse':
        if (HUD && Economy && localPlayer) {
          if (HUD.toggleAuctionHousePanel) {
            HUD.toggleAuctionHousePanel(economyLedger, localPlayer.id, playerInventory);
          } else if (HUD.showAuctionHousePanel) {
            HUD.showAuctionHousePanel(economyLedger, localPlayer.id, playerInventory);
          }
        }
        break;

      case 'toggleLoreJournal':
        if (HUD && Exploration && localPlayer) {
          var lorePanelEl = document.getElementById('lore-journal-panel');
          if (lorePanelEl) {
            if (HUD.hideLoreJournal) HUD.hideLoreJournal();
          } else {
            if (HUD.showLoreJournal) HUD.showLoreJournal(localPlayer.id, gameState);
          }
        }
        break;

      case 'toggleDiscoveryLog':
        if (HUD && Exploration && localPlayer) {
          var discoveryLogEl = document.getElementById('discovery-log-overlay');
          if (discoveryLogEl) {
            HUD.hideDiscoveryLog();
          } else {
            var discoveries = Exploration.getDiscoveries ? Exploration.getDiscoveries(localPlayer.id, gameState) : [];
            HUD.showDiscoveryLog(discoveries);
          }
        }
        break;

      case 'toggleLoreBook':
        if (HUD && localPlayer) {
          var loreBookEl = document.getElementById('lore-book-overlay');
          if (loreBookEl) {
            HUD.hideLoreBook();
          } else {
            var loreEntries = [];
            HUD.showLoreBook(loreEntries);
          }
        }
        break;

      case 'useQuickSlot':
        if (playerInventory && Inventory) {
          var slotIndex = payload.slot; // 0-4
          var qbSlotIdx = playerInventory.quickBar ? playerInventory.quickBar[slotIndex] : slotIndex;
          var items = Inventory.getInventory(playerInventory);
          var slotItem = items[qbSlotIdx];
          if (slotItem) {
            if (slotItem.type === 'food') {
              // Consume food - remove 1 and show notification
              Inventory.removeItem(playerInventory, slotItem.itemId, 1);
              if (HUD) HUD.showNotification('Ate ' + slotItem.icon + ' ' + slotItem.name);
              // Award small Spark for eating
              if (Economy) Economy.earnSpark(localPlayer.id, 'daily_login', {});
              if (HUD && HUD.updateInventoryDisplay) {
                HUD.updateInventoryDisplay(playerInventory);
                HUD.updateQuickBar(playerInventory);
              }
            } else if (slotItem.type === 'tools') {
              // Equip tool - show notification
              if (HUD) HUD.showNotification('Equipped ' + slotItem.icon + ' ' + slotItem.name);
            } else {
              // Other items - show info
              if (HUD) HUD.showNotification(slotItem.icon + ' ' + slotItem.name + ': ' + (slotItem.description || 'An item'));
            }
          } else {
            if (HUD) HUD.showNotification('Quick slot ' + (slotIndex + 1) + ' is empty');
          }
        }
        break;

      case 'click':
        // Raycasting for resource node harvesting
        if (raycaster && sceneContext && sceneContext.camera && World) {
          var node = World.getResourceNodeAtMouse(raycaster, sceneContext.camera, payload.x, payload.y);
          if (node) {
            handleResourceHarvest(node);
          }
        }
        break;

      case 'initiate_trade':
        // Initiate trade with nearest player
        if (Trading && gameState && State && HUD) {
          var players = State.getPlayers(gameState);
          var nearbyPlayers = players
            .filter(function(p) {
              return p.id !== localPlayer.id && p.zone === currentZone;
            })
            .map(function(p) {
              var dx = p.position.x - localPlayer.position.x;
              var dz = p.position.z - localPlayer.position.z;
              var distance = Math.sqrt(dx * dx + dz * dz);
              return { player: p, distance: distance };
            })
            .sort(function(a, b) { return a.distance - b.distance; });

          if (nearbyPlayers.length > 0 && nearbyPlayers[0].distance < 10) {
            var targetPlayer = nearbyPlayers[0].player;
            var result = Trading.requestTrade(localPlayer.id, targetPlayer.id, localPlayer.position);
            if (result.success) {
              HUD.showNotification('Trade request sent to ' + targetPlayer.name, 'info');
            } else {
              HUD.showNotification(result.message, 'warning');
            }
          } else {
            HUD.showNotification('No players nearby to trade with', 'warning');
          }
        }
        break;

      case 'startFishing':
        startFishing();
        break;

      case 'togglePetPanel':
        if (HUD && HUD.showPetPanel) {
          HUD.showPetPanel(localPlayer.id, currentZone);
        }
        break;

      case 'toggleHousing':
        showHousingPanel();
        break;

      default:
        console.log('Unknown local action:', type);
    }

    if (msg) {
      // Apply locally first
      applyMessage(msg);

      // Broadcast to network
      if (Network) {
        Network.broadcastMessage(msg);
      }
    }
  }

  /**
   * Join world
   */
  function joinWorld() {
    if (!Protocol || !Network) return;

    const msg = Protocol.create.join(localPlayer.id, {
      position: localPlayer.position,
      zone: currentZone
    });

    // Broadcast join message
    Network.broadcastMessage(msg);

    console.log('Joined world');
  }

  /**
   * Leave world
   */
  function leaveWorld() {
    if (!Protocol || !Network) return;

    const msg = Protocol.create.leave(localPlayer.id);

    // Broadcast leave message
    Network.broadcastMessage(msg);

    // Disconnect from network
    Network.disconnect();

    // Stop audio
    if (Audio) {
      Audio.stopAll();
    }

    // Stop game loop
    isRunning = false;

    console.log('Left world');
  }

  // Auto-start on DOM ready
  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', init);

    // Handle page unload â€” save and leave, register player star
    window.addEventListener('beforeunload', () => {
      // Register player's constellation star before leaving
      if (World && World.registerPlayerStar && localPlayer) {
        World.registerPlayerStar(localPlayer.id, localPlayer.name || localPlayer.id);
      }
      // Save world memory
      if (World && World.saveWorldMemory) {
        World.saveWorldMemory();
      }
      autoSavePlayerData();
      leaveWorld();
    });
  }

  /**
   * Get play time in seconds
   */
  function getPlayTimeSeconds() {
    // Load from localStorage
    if (typeof localStorage !== 'undefined') {
      try {
        var stored = localStorage.getItem('zion_playTime');
        if (stored) {
          playTimeSeconds = parseInt(stored) || 0;
        }
      } catch (err) {
        console.warn('Failed to load play time:', err);
      }
    }
    return playTimeSeconds;
  }

  /**
   * Save play time to localStorage
   */
  function savePlayTime() {
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('zion_playTime', playTimeSeconds.toString());
      } catch (err) {
        console.warn('Failed to save play time:', err);
      }
    }
  }

  /**
   * Add recent activity
   */
  function addRecentActivity(activity) {
    recentActivities.unshift(activity);
    if (recentActivities.length > 10) {
      recentActivities = recentActivities.slice(0, 10);
    }
    // Save to localStorage
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('zion_recentActivities', JSON.stringify(recentActivities));
      } catch (err) {
        console.warn('Failed to save activities:', err);
      }
    }
  }

  /**
   * Get recent activities
   */
  function getRecentActivities() {
    // Load from localStorage
    if (typeof localStorage !== 'undefined' && recentActivities.length === 0) {
      try {
        var stored = localStorage.getItem('zion_recentActivities');
        if (stored) {
          recentActivities = JSON.parse(stored) || [];
        }
      } catch (err) {
        console.warn('Failed to load activities:', err);
      }
    }
    return recentActivities.length > 0 ? recentActivities : ['Started playing ZION'];
  }

  /**
   * Track an achievement event and show toast if earned
   */
  function trackAchievement(eventType, eventData) {
    if (!Quests || !Quests.trackAchievementEvent || !localPlayer) return;
    var earned = Quests.trackAchievementEvent(localPlayer.id, eventType, eventData);
    if (earned && earned.length > 0) {
      earned.forEach(function(achievement) {
        // Piano accent for achievement unlock
        if (Audio && Audio.playPianoAccent) Audio.playPianoAccent('achievement');
        // Show toast notification
        if (HUD && HUD.showAchievementToast) {
          HUD.showAchievementToast(achievement);
        } else if (HUD) {
          HUD.showNotification('Achievement unlocked: ' + achievement.name, 'success');
        }
        // Award bonus spark for achievements
        if (economyLedger && Economy) {
          var bonus = achievement.tier === 'gold' ? 50 : achievement.tier === 'silver' ? 25 : 10;
          Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: bonus / 25 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
        }
        if (Audio) Audio.playSound('warp');
      });
    }
  }

  /**
   * Save full player state for session persistence
   */
  function autoSavePlayerData() {
    if (!Auth || !Auth.savePlayerData || !localPlayer) return;
    var saveData = {
      inventory: playerInventory,
      spark: localPlayer.spark || 0,
      position: localPlayer.position,
      zone: currentZone,
      skills: Mentoring ? Mentoring.getPlayerSkills(localPlayer.id) : null,
      questState: Quests ? { active: Quests.getActiveQuests(localPlayer.id), completed: Quests.getCompletedQuests(localPlayer.id) } : null,
      achievements: Quests && Quests.getAchievements ? Quests.getAchievements(localPlayer.id) : null,
      guild: Guilds ? Guilds.getPlayerGuild(localPlayer.id) : null,
      discoveredSecrets: [],
      warmth: localPlayer.warmth || 0,
      playTime: playTimeSeconds
    };
    Auth.savePlayerData(saveData);
  }

  /**
   * Restore player state from saved data
   */
  function restorePlayerData() {
    if (!Auth || !Auth.loadPlayerData || !localPlayer) return false;
    var data = Auth.loadPlayerData();
    if (!data) return false;

    // Restore position
    if (data.position) {
      localPlayer.position = data.position;
    }
    if (data.zone) {
      currentZone = data.zone;
    }
    // Restore spark
    if (data.spark && economyLedger && Economy) {
      economyLedger.balances[localPlayer.id] = data.spark;
      localPlayer.spark = data.spark;
    }
    // Restore inventory
    if (data.inventory && Inventory) {
      playerInventory = data.inventory;
    }
    // Restore play time
    if (data.playTime) {
      playTimeSeconds = data.playTime;
    }
    // Restore warmth
    if (data.warmth) {
      localPlayer.warmth = data.warmth;
    }

    console.log('Player data restored from save');
    return true;
  }

  /**
   * Check nearby secrets and trigger discovery
   */
  function checkSecrets() {
    if (!Exploration || !Exploration.checkNearbySecrets || !localPlayer || !gameState) return;
    var nearbySecrets = Exploration.checkNearbySecrets(localPlayer.id, localPlayer.position, currentZone, gameState);
    if (nearbySecrets && nearbySecrets.length > 0) {
      nearbySecrets.forEach(function(secret) {
        var result = Exploration.discoverSecret(localPlayer.id, secret, gameState);
        if (result && result.success) {
          // Show discovery notification with lore
          if (HUD) {
            HUD.showNotification('Secret discovered: ' + secret.name, 'success');
            if (HUD.showDiscoveryPopup) {
              HUD.showDiscoveryPopup({
                name: secret.name,
                description: secret.description,
                rarity: getRarityName(secret.rarity),
                sparkReward: result.sparkAwarded || 0
              });
            }
          }
          // Award spark
          if (economyLedger && Economy && result.sparkAwarded) {
            Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: secret.rarity });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
          }
          // Get and show lore if available
          if (secret.loreId && Exploration.getLoreEntry) {
            var lore = Exploration.getLoreEntry(secret.loreId);
            if (lore && HUD) {
              setTimeout(function() {
                HUD.showNotification('Lore unlocked: ' + lore.title, 'info');
              }, 3000);
            }
            // Award lore XP for discovering lore entries
            if (Mentoring) {
              var loreXP = Mentoring.addSkillXP(localPlayer.id, 'lore', 15);
              if (loreXP.leveledUp && HUD) {
                HUD.showNotification('Lore skill increased to ' + loreXP.newLevelName + '!', 'success');
                emitLevelUpParticles();
              }
            }
          }
          // Award exploration XP for discovering secrets
          if (Mentoring) {
            var exploreXP = Mentoring.addSkillXP(localPlayer.id, 'exploration', 10);
            if (exploreXP.leveledUp && HUD) {
              HUD.showNotification('Exploration skill increased to ' + exploreXP.newLevelName + '!', 'success');
              emitLevelUpParticles();
            }
          }
          // Track achievement
          trackAchievement('discover', { type: 'secret', rarity: secret.rarity });
          if (Audio) Audio.playSound('warp');
          addRecentActivity('Discovered: ' + secret.name);
        }
      });
    }
  }

  /**
   * Update economic event display and check for changes
   */
  function updateEconomicEvent() {
    if (!Economy || !Economy.getCurrentEvent) return;
    var event = Economy.getCurrentEvent();
    if (event && (!currentEconomicEvent || currentEconomicEvent.id !== event.id)) {
      currentEconomicEvent = event;
      if (HUD) {
        // Show event banner
        var bannerEl = document.getElementById('economic-event-banner');
        if (!bannerEl && typeof document !== 'undefined') {
          bannerEl = document.createElement('div');
          bannerEl.id = 'economic-event-banner';
          bannerEl.className = 'economic-event-banner';
          document.body.appendChild(bannerEl);
        }
        if (bannerEl) {
          bannerEl.innerHTML = '<strong>' + event.name + '</strong> â€” ' + event.description;
          bannerEl.style.display = 'block';
        }
        HUD.showNotification('Economic Event: ' + event.name + ' is active!', 'success');
      }
    } else if (!event && currentEconomicEvent) {
      currentEconomicEvent = null;
      var bannerEl = document.getElementById('economic-event-banner');
      if (bannerEl) bannerEl.style.display = 'none';
    }
  }

  /**
   * Initialize seasonal event display
   */
  function initSeasonalEvent() {
    if (!Seasons) return;
    currentSeason = Seasons.getCurrentSeason();
    if (!currentSeason) return;

    var colors = Seasons.getSeasonalColors();
    var daysLeft = Seasons.getDaysUntilSeasonEnd();

    // Create seasonal banner
    if (typeof document !== 'undefined') {
      var banner = document.getElementById('seasonal-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.id = 'seasonal-banner';
        banner.className = 'seasonal-banner season-' + currentSeason.id;
        document.body.appendChild(banner);
      }
      banner.innerHTML = '<div class="seasonal-banner-title">' + (currentSeason.festival && currentSeason.festival.name ? currentSeason.festival.name : currentSeason.name) + '</div>' +
        '<div class="seasonal-banner-desc">' + currentSeason.description + '</div>' +
        '<div class="seasonal-banner-countdown">' + daysLeft + ' days remaining</div>';
      banner.style.display = 'block';

      // Auto-hide after 8 seconds
      setTimeout(function() {
        if (banner) banner.style.display = 'none';
      }, 8000);
    }

    // Apply seasonal NPC greetings
    if (NPCs && Seasons.getSeasonalGreeting) {
      console.log('Season: ' + currentSeason.name + ' â€” ' + Seasons.getSeasonalGreeting());
    }
  }

  /**
   * Update seasonal event (check for season change)
   */
  function updateSeasonalEvent() {
    if (!Seasons) return;
    var newSeason = Seasons.getCurrentSeason();
    if (newSeason && (!currentSeason || currentSeason.id !== newSeason.id)) {
      currentSeason = newSeason;
      if (HUD) {
        HUD.showNotification('A new season has arrived: ' + newSeason.name + '!', 'success');
      }
      initSeasonalEvent(); // Refresh banner
    }
  }

  /**
   * Get seasonal bonus for an activity
   */
  function getSeasonalBonus(activity) {
    if (!Seasons || !Seasons.getSeasonBonus) return 1.0;
    return Seasons.getSeasonBonus(activity);
  }

  /**
   * Initialize pet system
   */
  function initPetSystem(playerId) {
    if (!Pets) return;

    // Check if player has a saved pet
    var savedData = Auth && Auth.loadPlayerData ? Auth.loadPlayerData() : null;
    if (savedData && savedData.pet) {
      // Restore pet from saved data - pets module stores internally
      console.log('Pet system initialized');
    }
  }

  /**
   * Update pet status (hunger, mood decay)
   */
  function updatePetStatus() {
    if (!Pets || !localPlayer) return;
    var pet = Pets.getPlayerPet(localPlayer.id);
    if (!pet) return;

    // Update pet simulation
    Pets.updatePet(localPlayer.id, PET_UPDATE_INTERVAL / 1000);

    // Get pet bonus and apply
    var bonus = Pets.getPetBonus(localPlayer.id);
    if (bonus && bonus.value > 0) {
      localPlayer.petBonus = bonus;
    }

    // Check pet mood for notifications
    var mood = Pets.getPetMood(pet);
    if (mood === 'sad' && pet.hunger > 70) {
      if (HUD) {
        HUD.showNotification(pet.name + ' is hungry! Feed your companion.', 'warning');
      }
    }
  }

  /**
   * Start fishing minigame
   */
  function startFishing() {
    if (isFishing || !HUD || !HUD.showFishingUI) return;

    // Check if current zone allows fishing
    var fishableZones = ['gardens', 'commons', 'wilds', 'nexus', 'agora'];
    if (fishableZones.indexOf(currentZone) === -1) {
      if (HUD) HUD.showNotification('You cannot fish here.', 'warning');
      return;
    }

    isFishing = true;
    if (Audio) Audio.playSound('harvest');

    HUD.showFishingUI(currentZone, function(result) {
      isFishing = false;
      if (result && result.success && result.fish) {
        // Add fish to inventory
        if (Inventory && playerInventory) {
          Inventory.addItem(playerInventory, result.fish.id, 1);
          if (HUD && HUD.updateInventoryDisplay) {
            HUD.updateInventoryDisplay(playerInventory);
          }
        }
        // Award Spark
        var sparkAmount = result.fish.value || 5;
        var seasonBonus = getSeasonalBonus('harvest');
        sparkAmount = Math.round(sparkAmount * seasonBonus);
        if (economyLedger && Economy) {
          Economy.earnSpark(economyLedger, localPlayer.id, sparkAmount, 'fishing');
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
        if (HUD && HUD.showFishCaughtNotification) {
          HUD.showFishCaughtNotification(result.fish.name, sparkAmount);
        }
        trackAchievement('harvest', { type: 'fishing', fish: result.fish.id });
        // Award gardening XP for fishing (falls under nature skills)
        if (Mentoring) {
          var fishXP = Mentoring.addSkillXP(localPlayer.id, 'gardening', 8);
          if (fishXP.leveledUp && HUD) {
            HUD.showNotification('Gardening skill increased to ' + fishXP.newLevelName + '!', 'success');
            emitLevelUpParticles();
          }
        }
        addRecentActivity('Caught: ' + result.fish.name);
      }
    });
  }

  /**
   * Show housing panel for player
   */
  function showHousingPanel() {
    if (!Creation || !HUD || typeof document === 'undefined') return;

    var existingPanel = document.getElementById('housing-panel');
    if (existingPanel) {
      existingPanel.remove();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'housing-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(15,12,10,0.95);border:1px solid rgba(218,165,32,0.3);border-radius:12px;' +
      'padding:24px;min-width:400px;max-width:550px;max-height:70vh;overflow-y:auto;z-index:1100;' +
      'backdrop-filter:blur(10px);color:#E8E0D8;font-family:Georgia,serif;';

    var playerPlot = Creation.getPlayerPlot ? Creation.getPlayerPlot(localPlayer.id) : null;

    // Header
    var header = document.createElement('h2');
    header.textContent = playerPlot ? 'My Home â€” ' + playerPlot.name : 'Housing â€” Claim a Plot';
    header.style.cssText = 'color:#DAA520;margin:0 0 16px;font-size:1.2rem;';
    panel.appendChild(header);

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\u00d7';
    closeBtn.style.cssText = 'position:absolute;top:12px;right:12px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;font-size:18px;cursor:pointer;';
    closeBtn.onclick = function() { panel.remove(); };
    panel.appendChild(closeBtn);

    if (playerPlot) {
      // Show owned plot info
      var plotInfo = document.createElement('div');
      plotInfo.style.cssText = 'margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;';
      plotInfo.innerHTML = '<div style="color:#B8B0A8;font-size:0.85rem;">Plot ' + playerPlot.id +
        ' (' + playerPlot.bounds.x1 + ',' + playerPlot.bounds.z1 + ')</div>' +
        '<div style="color:#E8E0D8;font-size:0.9rem;margin-top:4px;">Furniture: ' +
        playerPlot.furniture.length + '/' + 20 + '</div>';
      panel.appendChild(plotInfo);

      // Furniture list
      var furnitureTypes = Creation.FURNITURE_TYPES || {};
      var furnitureHeader = document.createElement('div');
      furnitureHeader.textContent = 'Add Furniture';
      furnitureHeader.style.cssText = 'color:#DAA520;font-size:0.9rem;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.1em;';
      panel.appendChild(furnitureHeader);

      Object.keys(furnitureTypes).forEach(function(fType) {
        var ft = furnitureTypes[fType];
        var row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px;' +
          'background:rgba(255,255,255,0.02);border-radius:6px;margin-bottom:4px;' +
          'border:1px solid rgba(255,255,255,0.05);cursor:pointer;transition:all 0.2s;';
        row.onmouseover = function() { this.style.borderColor = 'rgba(218,165,32,0.3)'; };
        row.onmouseout = function() { this.style.borderColor = 'rgba(255,255,255,0.05)'; };
        row.innerHTML = '<span style="font-size:1.3rem;">' + ft.icon + '</span>' +
          '<span style="flex:1;color:#E8E0D8;font-size:0.85rem;">' + ft.name + '</span>' +
          '<span style="color:#DAA520;font-size:0.8rem;">' + ft.cost + ' Spark</span>';
        row.onclick = function() {
          var result = Creation.placeFurniture(localPlayer.id, fType, 5, 5);
          if (result && result.success) {
            HUD.showNotification('Placed ' + ft.name + ' in your home!', 'success');
            panel.remove();
          } else {
            HUD.showNotification(result ? result.error : 'Cannot place furniture', 'warning');
          }
        };
        panel.appendChild(row);
      });
    } else {
      // Show available plots
      var plots = Creation.getAvailablePlots ? Creation.getAvailablePlots() : [];
      if (plots.length === 0) {
        var noPlots = document.createElement('div');
        noPlots.textContent = 'No plots available. Visit The Commons zone to find housing.';
        noPlots.style.cssText = 'color:#B8B0A8;text-align:center;padding:20px;';
        panel.appendChild(noPlots);
      } else {
        var infoText = document.createElement('div');
        infoText.textContent = 'Available plots in The Commons (' + plots.length + ' open):';
        infoText.style.cssText = 'color:#B8B0A8;font-size:0.85rem;margin-bottom:12px;';
        panel.appendChild(infoText);

        plots.slice(0, 8).forEach(function(plot) {
          var row = document.createElement('div');
          row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:10px;' +
            'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);' +
            'border-radius:8px;margin-bottom:6px;cursor:pointer;transition:all 0.2s;';
          row.onmouseover = function() { this.style.borderColor = 'rgba(218,165,32,0.4)'; };
          row.onmouseout = function() { this.style.borderColor = 'rgba(255,255,255,0.08)'; };
          row.innerHTML = '<span style="font-size:1.3rem;">ðŸ </span>' +
            '<span style="flex:1;color:#E8E0D8;font-size:0.9rem;">Plot ' + plot.id + '</span>' +
            '<span style="color:#B8B0A8;font-size:0.75rem;">(' + plot.bounds.x1 + ', ' + plot.bounds.z1 + ')</span>';
          row.onclick = function() {
            var plotName = prompt('Name your home:');
            if (plotName && plotName.trim()) {
              var result = Creation.claimPlot(localPlayer.id, plot.id, plotName.trim());
              if (result && result.success) {
                HUD.showNotification('You claimed a plot: ' + plotName.trim() + '!', 'success');
                trackAchievement('build', { type: 'housing' });
                panel.remove();
              } else {
                HUD.showNotification(result ? result.error : 'Cannot claim plot', 'warning');
              }
            }
          };
          panel.appendChild(row);
        });
      }
    }

    document.body.appendChild(panel);

    // Close on Escape
    var escHandler = function(e) {
      if (e.key === 'Escape') {
        panel.remove();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }

  // ========================================================================
  // WORLD EVENTS SYSTEM
  // ========================================================================

  /**
   * Check if it's nighttime based on worldTime
   * @param {number} worldTime - Minutes in 24-hour cycle (0-1440)
   * @returns {boolean} True if nighttime
   */
  function isNighttime(worldTime) {
    var hour = worldTime / 60;
    return hour < 6 || hour >= 20; // Night is 8pm-6am
  }

  /**
   * Get a random zone ID
   * @returns {string} Random zone ID
   */
  function getRandomZone() {
    if (!World || !World.ZONES) return 'nexus';
    var zoneKeys = Object.keys(World.ZONES);
    return zoneKeys[Math.floor(Math.random() * zoneKeys.length)];
  }

  /**
   * Get zone name from zone ID
   * @param {string} zoneId - Zone identifier
   * @returns {string} Zone name
   */
  function getZoneName(zoneId) {
    if (!World || !World.ZONES || !World.ZONES[zoneId]) return zoneId;
    return World.ZONES[zoneId].name || zoneId;
  }

  /**
   * Spawn a shooting star event
   * @param {object} sceneContext - Scene context
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnShootingStar(sceneContext, currentTime) {
    if (!sceneContext || !sceneContext.scene) return;

    // Random direction: left-to-right or right-to-left
    var direction = Math.random() > 0.5 ? 1 : -1;
    var startX = direction > 0 ? -300 : 300;
    var endX = direction > 0 ? 300 : -300;
    var y = 150 + Math.random() * 50; // High in sky
    var z = -200 + Math.random() * 400;

    // Create shooting star
    var starGeom = new THREE.SphereGeometry(0.8, 8, 8);
    var starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var star = new THREE.Mesh(starGeom, starMat);
    star.position.set(startX, y, z);
    sceneContext.scene.add(star);

    // Create trail spheres
    var trail = [];
    for (var i = 0; i < 3; i++) {
      var trailGeom = new THREE.SphereGeometry(0.5 - i * 0.15, 6, 6);
      var trailMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.7 - i * 0.2
      });
      var trailSphere = new THREE.Mesh(trailGeom, trailMat);
      trailSphere.position.copy(star.position);
      sceneContext.scene.add(trailSphere);
      trail.push(trailSphere);
    }

    // Store in active events
    var duration = 1000 + Math.random() * 1000; // 1-2 seconds
    worldEvents.shootingStars.active.push({
      star: star,
      trail: trail,
      startTime: currentTime,
      duration: duration,
      startX: startX,
      endX: endX,
      y: y,
      z: z
    });

    // Show notification
    if (HUD && HUD.showNotification) {
      HUD.showNotification('A shooting star streaks across the sky!', 'info');
    }
  }

  /**
   * Spawn resource bloom event
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnResourceBloom(currentTime) {
    var zone = getRandomZone();
    worldEvents.resourceBloom.activeZone = zone;
    worldEvents.resourceBloom.startTime = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A bloom of resources has appeared in ' + getZoneName(zone) + '!', 'success');
    }
  }

  /**
   * Spawn aurora borealis event
   * @param {object} sceneContext - Scene context
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnAuroraBorealis(sceneContext, currentTime) {
    if (!sceneContext || !sceneContext.scene) return;

    // Create a large plane high in the sky
    var auroraGeom = new THREE.PlaneGeometry(400, 200, 40, 20);
    var auroraMat = new THREE.MeshBasicMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    var aurora = new THREE.Mesh(auroraGeom, auroraMat);
    aurora.position.set(0, 180, -100);
    aurora.rotation.x = Math.PI / 2.5;
    sceneContext.scene.add(aurora);

    worldEvents.auroraBorealis.active = true;
    worldEvents.auroraBorealis.mesh = aurora;
    worldEvents.auroraBorealis.startTime = currentTime;
    worldEvents.auroraBorealis.duration = 180000 + Math.random() * 120000; // 3-5 minutes
    worldEvents.auroraBorealis.animTime = 0;

    // Store original vertex positions for animation
    var positions = auroraGeom.attributes.position.array;
    var originalPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
      originalPositions[i] = positions[i];
    }
    aurora.userData.originalPositions = originalPositions;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('The Northern Lights dance across the sky!', 'success');
    }
  }

  /**
   * Spawn wandering merchant event
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnWanderingMerchant(currentTime) {
    var zone = getRandomZone();
    worldEvents.wanderingMerchant.activeZone = zone;
    worldEvents.wanderingMerchant.lastSpawn = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A wandering merchant has appeared near ' + getZoneName(zone) + '!', 'info');
    }
  }

  /**
   * Spawn firefly swarm event
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnFireflySwarm(currentTime) {
    // Only in gardens zone
    worldEvents.fireflySwarm.active = true;
    worldEvents.fireflySwarm.startTime = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A swarm of fireflies fills the gardens!', 'success');
    }
  }

  /**
   * Update world events
   * @param {number} deltaTime - Time elapsed since last frame (seconds)
   * @param {number} worldTime - Current world time in minutes (0-1440)
   * @param {object} sceneContext - Scene context with scene, camera, etc.
   */
  function updateWorldEvents(deltaTime, worldTime, sceneContext) {
    if (!sceneContext) return;

    var currentTime = Date.now();
    var isNight = isNighttime(worldTime);

    // 1. SHOOTING STARS (nighttime only, every 30-90 seconds)
    if (isNight) {
      var starInterval = worldEvents.shootingStars.interval + Math.random() * 60000;
      if (currentTime - worldEvents.shootingStars.lastSpawn > starInterval) {
        spawnShootingStar(sceneContext, currentTime);
        worldEvents.shootingStars.lastSpawn = currentTime;
      }
    }

    // Update active shooting stars
    for (var i = worldEvents.shootingStars.active.length - 1; i >= 0; i--) {
      var starEvent = worldEvents.shootingStars.active[i];
      var elapsed = currentTime - starEvent.startTime;
      var progress = Math.min(elapsed / starEvent.duration, 1);

      if (progress >= 1) {
        // Remove completed star
        sceneContext.scene.remove(starEvent.star);
        starEvent.star.geometry.dispose();
        starEvent.star.material.dispose();
        for (var j = 0; j < starEvent.trail.length; j++) {
          sceneContext.scene.remove(starEvent.trail[j]);
          starEvent.trail[j].geometry.dispose();
          starEvent.trail[j].material.dispose();
        }
        worldEvents.shootingStars.active.splice(i, 1);
      } else {
        // Update position
        var newX = starEvent.startX + (starEvent.endX - starEvent.startX) * progress;
        starEvent.star.position.x = newX;

        // Update trail with delay
        for (var k = 0; k < starEvent.trail.length; k++) {
          var trailDelay = (k + 1) * 0.1;
          var trailProgress = Math.max(0, progress - trailDelay);
          var trailX = starEvent.startX + (starEvent.endX - starEvent.startX) * trailProgress;
          starEvent.trail[k].position.x = trailX;
          starEvent.trail[k].position.y = starEvent.y;
          starEvent.trail[k].position.z = starEvent.z;
          // Fade out trail
          starEvent.trail[k].material.opacity = (0.7 - k * 0.2) * (1 - progress);
        }
      }
    }

    // 2. RESOURCE BLOOM (every 10-15 minutes)
    var bloomInterval = worldEvents.resourceBloom.interval + Math.random() * 300000;
    if (currentTime - worldEvents.resourceBloom.lastSpawn > bloomInterval) {
      spawnResourceBloom(currentTime);
      worldEvents.resourceBloom.lastSpawn = currentTime;
    }

    // Update resource bloom (make resources glow if player is in zone)
    if (worldEvents.resourceBloom.activeZone) {
      var bloomElapsed = currentTime - worldEvents.resourceBloom.startTime;
      if (bloomElapsed > worldEvents.resourceBloom.duration) {
        worldEvents.resourceBloom.activeZone = null;
      } else {
        // If player is in bloom zone, resources could glow brighter
        // This would require World module support, so for now just track state
      }
    }

    // 3. AURORA BOREALIS (nighttime, rare - every 20+ minutes)
    if (isNight) {
      var auroraInterval = worldEvents.auroraBorealis.interval + Math.random() * 600000;
      if (!worldEvents.auroraBorealis.active &&
          currentTime - worldEvents.auroraBorealis.lastSpawn > auroraInterval) {
        spawnAuroraBorealis(sceneContext, currentTime);
        worldEvents.auroraBorealis.lastSpawn = currentTime;
      }
    }

    // Update aurora animation
    if (worldEvents.auroraBorealis.active && worldEvents.auroraBorealis.mesh) {
      var auroraElapsed = currentTime - worldEvents.auroraBorealis.startTime;
      if (auroraElapsed > worldEvents.auroraBorealis.duration) {
        // Remove aurora
        sceneContext.scene.remove(worldEvents.auroraBorealis.mesh);
        worldEvents.auroraBorealis.mesh.geometry.dispose();
        worldEvents.auroraBorealis.mesh.material.dispose();
        worldEvents.auroraBorealis.mesh = null;
        worldEvents.auroraBorealis.active = false;
      } else {
        // Animate with sine wave displacement
        worldEvents.auroraBorealis.animTime += deltaTime;
        var aurora = worldEvents.auroraBorealis.mesh;
        var geometry = aurora.geometry;
        var positions = geometry.attributes.position.array;
        var originalPositions = aurora.userData.originalPositions;

        if (originalPositions) {
          for (var v = 0; v < positions.length; v += 3) {
            var x = originalPositions[v];
            var y = originalPositions[v + 1];
            var offset = Math.sin(x * 0.02 + worldEvents.auroraBorealis.animTime * 2) *
                        Math.cos(y * 0.02 + worldEvents.auroraBorealis.animTime * 1.5) * 8;
            positions[v + 2] = originalPositions[v + 2] + offset;
          }
          geometry.attributes.position.needsUpdate = true;
        }

        // Fade opacity based on time
        var fadeProgress = auroraElapsed / worldEvents.auroraBorealis.duration;
        if (fadeProgress > 0.8) {
          aurora.material.opacity = 0.3 * (1 - (fadeProgress - 0.8) / 0.2);
        }
      }
    }

    // 4. WANDERING MERCHANT (every 15 minutes)
    var merchantInterval = worldEvents.wanderingMerchant.interval;
    if (currentTime - worldEvents.wanderingMerchant.lastSpawn > merchantInterval) {
      spawnWanderingMerchant(currentTime);
    }

    // 5. FIREFLY SWARM (nighttime in gardens)
    if (isNight && currentZone === 'gardens') {
      var swarmInterval = worldEvents.fireflySwarm.interval;
      if (!worldEvents.fireflySwarm.active &&
          currentTime - worldEvents.fireflySwarm.lastSpawn > swarmInterval) {
        spawnFireflySwarm(currentTime);
        worldEvents.fireflySwarm.lastSpawn = currentTime;
      }
    }

    // Update firefly swarm
    if (worldEvents.fireflySwarm.active) {
      var swarmElapsed = currentTime - worldEvents.fireflySwarm.startTime;
      if (swarmElapsed > worldEvents.fireflySwarm.duration) {
        worldEvents.fireflySwarm.active = false;
      }
      // The actual firefly count increase is handled in World.updateWildlife
      // We just track the active state here
    }
  }

  // Export public API
  exports.init = init;
  exports.joinWorld = joinWorld;
  exports.leaveWorld = leaveWorld;
  exports.handleLocalAction = handleLocalAction;
  exports.triggerCameraShake = triggerCameraShake;
  exports.triggerScreenFlash = triggerScreenFlash;
  exports.setVignetteIntensity = setVignetteIntensity;
  exports.getSimCrmState = function() { return simCrmState; };

})(typeof module !== 'undefined' ? module.exports : (window.Main = {}));


  </script>
</body>
</html>
