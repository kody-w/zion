<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ZION â€” A Living World</title>
  <meta name="description" content="A living world where human and artificial minds meet in peace.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' fill='%230A0E1A'/><text x='16' y='22' font-size='18' font-weight='bold' fill='%23DAA520' text-anchor='middle' font-family='serif'>Z</text></svg>">

  <!-- Schema.org JSON-LD for NLWeb discovery -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "GameServer",
    "name": "ZION",
    "url": "https://kody-w.github.io/zion/",
    "description": "A living world where human and artificial minds meet in peace. 100 AI citizens, 8 zones.",
    "gameServerStatus": "Online",
    "sameAs": "https://github.com/kody-w/zion"
  }
  </script>
  <link rel="alternate" type="application/rss+xml" title="ZION World State" href="feeds/world.xml" />
  <link rel="alternate" type="application/rss+xml" title="ZION Chat" href="feeds/chat.xml" />
  <link rel="alternate" type="application/rss+xml" title="ZION Events" href="feeds/events.xml" />
  <link rel="nlweb" href="nlweb.json" />

  <!-- Three.js & PeerJS from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <style>
    /* tokens.css */
:root {
  /* Colors - earthy, peaceful palette */
  --color-earth: #5C4033;
  --color-forest: #2D5016;
  --color-sky: #87CEEB;
  --color-dawn: #F4A460;
  --color-dusk: #8B6914;
  --color-night: #1a1a2e;
  --color-water: #4682B4;
  --color-stone: #808080;
  --color-sand: #C2B280;
  --color-gold: #DAA520;
  --color-crystal: #B0E0E6;

  /* UI Colors */
  --color-bg: #1a1a1a;
  --color-bg-panel: rgba(26, 26, 26, 0.85);
  --color-text: #E8E0D8;
  --color-text-muted: #A0978E;
  --color-accent: #DAA520;
  --color-success: #4CAF50;
  --color-warning: #FFA726;
  --color-error: #EF5350;
  --color-border: rgba(218, 165, 32, 0.3);

  /* Typography */
  --font-main: 'Georgia', 'Times New Roman', serif;
  --font-ui: system-ui, -apple-system, sans-serif;
  --font-mono: 'Courier New', monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
  --font-size-xxl: 2rem;

  /* Spacing */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-xxl: 3rem;

  /* Borders & Radius */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-round: 50%;

  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
  --shadow-lg: 0 10px 20px rgba(0,0,0,0.5);

  /* Z-Index */
  --z-world: 0;
  --z-hud: 100;
  --z-modal: 200;
  --z-notification: 300;

  /* Item Rarity Colors */
  --color-rarity-common: #cccccc;
  --color-rarity-uncommon: #2ecc71;
  --color-rarity-rare: #3498db;
  --color-rarity-legendary: #f39c12;

  /* Quest Colors */
  --color-quest-available: #f1c40f;
  --color-quest-active: #3498db;
  --color-quest-complete: #2ecc71;

  /* NPC Interaction */
  --color-npc-friendly: #27ae60;
  --color-npc-neutral: #95a5a6;

  /* Transition speeds */
  --transition-fast: 0.15s;
  --transition-normal: 0.3s;
  --transition-slow: 0.5s;
}


/* layout.css */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: var(--font-ui);
  font-size: var(--font-size-md);
  color: var(--color-text);
  background: var(--color-bg);
}

#game-container {
  position: relative;
  width: 100%;
  height: 100%;
}

#world-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-world);
}

#hud-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-hud);
  pointer-events: none;
}

#hud-container > * {
  pointer-events: auto;
}

#login-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 70%);
  z-index: var(--z-modal);
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(218, 165, 32, 0.3);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(218, 165, 32, 0.5);
}

/* Selection */
::selection {
  background: rgba(218, 165, 32, 0.3);
  color: var(--color-text);
}

/* Responsive */
@media (max-width: 768px) {
  :root {
    font-size: 14px;
  }

  .chat-panel {
    max-width: 250px;
    bottom: 160px;
    left: 8px;
    max-height: 30vh;
  }

  .player-info {
    top: 8px;
    left: 8px;
    min-width: 150px;
    padding: 8px;
  }

  .minimap {
    top: 8px;
    right: 8px;
    padding: 4px;
  }

  #minimap-canvas {
    width: 100px;
    height: 100px;
  }

  .nearby-list {
    display: none;
  }

  .zone-label {
    font-size: 1rem;
    top: 10px;
  }

  .notification {
    max-width: 280px;
    padding: 12px;
    font-size: 0.85rem;
  }
}

@media (max-width: 480px) {
  :root {
    font-size: 12px;
  }

  .chat-panel {
    max-width: 200px;
    bottom: 170px;
    max-height: 25vh;
  }

  .player-info {
    min-width: 120px;
    font-size: 11px;
  }

  .loading-title {
    font-size: 2.5rem;
  }

  .loading-bar-container {
    width: 200px;
  }
}


/* hud.css */
/* Chat Panel - Bottom Left */
.chat-panel {
  position: absolute;
  bottom: var(--space-md);
  left: var(--space-md);
  max-width: 300px;
  width: 100%;
  max-height: 40vh;
  display: flex;
  flex-direction: column;
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-sm);
  box-shadow: var(--shadow-md);
  transition: opacity 0.3s ease, transform 0.25s ease;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: var(--space-sm);
  font-size: var(--font-size-sm);
  line-height: 1.4;
  scroll-behavior: smooth;
}

.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: var(--radius-sm);
}

.chat-message {
  margin-bottom: var(--space-xs);
  word-wrap: break-word;
  animation: chatMsgIn 0.2s ease;
}

@keyframes chatMsgIn {
  from { opacity: 0; transform: translateY(5px); }
  to { opacity: 1; transform: translateY(0); }
}

.chat-message .sender {
  color: var(--color-accent);
  font-weight: bold;
}

.chat-input {
  width: 100%;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-sm);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-size-sm);
  outline: none;
  transition: border-color 0.2s ease;
}

.chat-input:focus {
  border-color: var(--color-accent);
}

/* Player Info - Top Left */
.player-info {
  position: absolute;
  top: var(--space-md);
  left: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  box-shadow: var(--shadow-md);
  min-width: 200px;
  transition: opacity 0.3s ease;
}

.player-info-name {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-sm);
}

.player-info-stat {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-xs);
}

.player-info-stat strong {
  color: var(--color-text);
}

/* Minimap - Top Right */
.minimap {
  position: absolute;
  top: var(--space-md);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-sm);
  box-shadow: var(--shadow-md);
  transition: opacity 0.3s ease;
}

#minimap-canvas {
  display: block;
  border-radius: var(--radius-sm);
}

/* Zone Label - Top Center */
.zone-label {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-gold);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  opacity: 0.9;
  transition: opacity 0.5s ease;
  white-space: nowrap;
  z-index: 1;
}

/* Nearby List - Right Side */
.nearby-list {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  max-height: 50vh;
  overflow-y: auto;
  box-shadow: var(--shadow-md);
  min-width: 150px;
  transition: opacity 0.3s ease;
}

.nearby-list-title {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.nearby-player {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin-bottom: var(--space-xs);
  padding: var(--space-xs);
  border-radius: var(--radius-sm);
  transition: background 0.2s ease;
}

.nearby-player:hover {
  background: rgba(218, 165, 32, 0.1);
}

/* Notification - Centered Popup */
.notification {
  position: absolute;
  top: 30%;
  left: 50%;
  transform: translate(-50%, -70%);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-accent);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-text);
  text-align: center;
  max-width: 400px;
  z-index: var(--z-notification);
  transition: opacity 0.3s ease, transform 0.3s ease;
  pointer-events: none;
}

.notification.visible {
  transform: translate(-50%, -50%);
  opacity: 1;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translate(-50%, -60%); }
  10% { opacity: 1; transform: translate(-50%, -50%); }
  90% { opacity: 1; transform: translate(-50%, -50%); }
  100% { opacity: 0; transform: translate(-50%, -40%); }
}

/* Break Reminder - Floating Message */
.break-reminder {
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(44, 80, 22, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-forest);
  border-radius: var(--radius-lg);
  padding: var(--space-md) var(--space-lg);
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-crystal);
  text-align: center;
  box-shadow: var(--shadow-md);
  animation: gentleFloat 4s ease-in-out infinite;
  pointer-events: none;
  z-index: var(--z-notification);
}

@keyframes gentleFloat {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-10px); }
}

/* Login Button */
.login-btn {
  background: var(--color-accent);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-md) var(--space-xl);
  font-family: var(--font-ui);
  font-size: var(--font-size-lg);
  font-weight: bold;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.2s ease;
  outline: none;
}

.login-btn:hover {
  background: var(--color-gold);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.login-btn:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

/* Intention Indicator */
.intention-indicator {
  position: absolute;
  bottom: var(--space-xl);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-round);
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--font-size-xl);
  box-shadow: var(--shadow-md);
  transition: all 0.3s ease;
}

.intention-indicator.active {
  border-color: var(--color-accent);
  box-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

/* Inventory Panel */
.inventory-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(12px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  min-width: 320px;
  max-width: 420px;
  z-index: var(--z-notification);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.inventory-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.inventory-title {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-md);
  text-align: center;
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-sm);
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: var(--space-xs);
  margin-bottom: var(--space-md);
}

.inventory-slot {
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  width: 56px;
  height: 56px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  font-size: 24px;
}

.inventory-slot:hover {
  border-color: var(--color-accent);
  background: rgba(218, 165, 32, 0.1);
}

.inventory-slot .slot-count {
  position: absolute;
  bottom: 2px;
  right: 4px;
  font-size: 10px;
  color: var(--color-text);
  font-weight: bold;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

.inventory-slot.rarity-uncommon { border-color: #2ecc71; }
.inventory-slot.rarity-rare { border-color: #3498db; }
.inventory-slot.rarity-legendary { border-color: #f39c12; box-shadow: 0 0 8px rgba(243, 156, 18, 0.3); }

/* Crafting Panel */
.crafting-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(12px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  min-width: 350px;
  max-width: 450px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: var(--z-notification);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.crafting-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.recipe-item {
  display: flex;
  align-items: center;
  padding: var(--space-sm);
  margin-bottom: var(--space-xs);
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s ease;
}

.recipe-item:hover {
  border-color: var(--color-accent);
  background: rgba(218, 165, 32, 0.1);
}

.recipe-item.craftable {
  border-color: rgba(46, 204, 113, 0.5);
}

.recipe-icon {
  font-size: 24px;
  margin-right: var(--space-sm);
  width: 36px;
  text-align: center;
}

.recipe-info {
  flex: 1;
}

.recipe-name {
  color: var(--color-text);
  font-size: var(--font-size-sm);
  font-weight: bold;
}

.recipe-materials {
  color: var(--color-text-muted);
  font-size: var(--font-size-xs);
}

.craft-btn {
  background: var(--color-accent);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
}

.craft-btn:hover {
  background: var(--color-gold);
}

.craft-btn:disabled {
  background: #555;
  color: #999;
  cursor: not-allowed;
}

/* Quest Tracker - Top Right below Minimap */
.quest-tracker {
  position: absolute;
  top: 190px;
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-radius: var(--radius-md);
  padding: var(--space-sm) var(--space-md);
  box-shadow: var(--shadow-md);
  min-width: 180px;
  max-width: 240px;
  transition: opacity 0.3s ease;
}

.quest-tracker-title {
  font-size: var(--font-size-xs);
  color: var(--color-gold);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--space-xs);
}

.quest-tracker-item {
  margin-bottom: var(--space-xs);
}

.quest-tracker-name {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  font-weight: bold;
}

.quest-tracker-objective {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
}

.quest-tracker-progress {
  height: 3px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  margin-top: 2px;
  overflow: hidden;
}

.quest-tracker-progress-bar {
  height: 100%;
  background: var(--color-accent);
  border-radius: 2px;
  transition: width 0.5s ease;
}

/* Quest Log Panel */
.quest-log-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) translateX(20px);
  opacity: 0;
  background: var(--color-bg-panel);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-lg);
  min-width: 400px;
  max-width: 500px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: var(--z-notification);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.quest-log-panel.visible {
  transform: translate(-50%, -50%) translateX(0);
  opacity: 1;
}

.quest-entry {
  padding: var(--space-sm);
  margin-bottom: var(--space-sm);
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s ease;
}

.quest-entry:hover {
  border-color: var(--color-accent);
}

.quest-entry.active {
  border-color: var(--color-gold);
  border-left: 3px solid var(--color-gold);
}

.quest-entry.completed {
  opacity: 0.6;
  border-color: #2ecc71;
}

.quest-entry-title {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  font-weight: bold;
}

.quest-entry-desc {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  margin-top: 2px;
}

.quest-entry-reward {
  font-size: var(--font-size-xs);
  color: var(--color-gold);
  margin-top: 4px;
}

/* Quick Bar - Bottom Center */
.quick-bar {
  position: absolute;
  bottom: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: var(--space-xs);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-xs);
  box-shadow: var(--shadow-md);
}

.quick-slot {
  width: 48px;
  height: 48px;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  position: relative;
  cursor: pointer;
  transition: all 0.2s ease;
}

.quick-slot:hover {
  border-color: var(--color-accent);
}

.quick-slot .slot-key {
  position: absolute;
  top: 2px;
  left: 4px;
  font-size: 9px;
  color: var(--color-text-muted);
}

/* Item Tooltip */
.item-tooltip {
  position: absolute;
  background: rgba(20, 20, 30, 0.95);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-sm);
  max-width: 200px;
  z-index: 1000;
  pointer-events: none;
  font-size: var(--font-size-xs);
}

.item-tooltip-name {
  font-weight: bold;
  margin-bottom: 2px;
}

.item-tooltip-name.common { color: #ccc; }
.item-tooltip-name.uncommon { color: #2ecc71; }
.item-tooltip-name.rare { color: #3498db; }
.item-tooltip-name.legendary { color: #f39c12; }

.item-tooltip-desc {
  color: var(--color-text-muted);
  margin-bottom: 4px;
}

/* Item Pickup Floating Text */
.item-pickup-text {
  position: absolute;
  font-size: var(--font-size-sm);
  color: var(--color-gold);
  font-weight: bold;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  animation: floatUp 1.5s ease-out forwards;
  z-index: var(--z-notification);
}

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-60px); }
}

/* Quest Complete Banner */
.quest-complete-banner {
  position: absolute;
  top: 25%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(218, 165, 32, 0.15);
  backdrop-filter: blur(10px);
  border: 2px solid var(--color-gold);
  border-radius: var(--radius-lg);
  padding: var(--space-lg) var(--space-xl);
  text-align: center;
  z-index: var(--z-notification);
  animation: questComplete 3s ease-in-out forwards;
  pointer-events: none;
}

.quest-complete-banner h2 {
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-gold);
  margin: 0 0 var(--space-sm);
}

.quest-complete-banner .reward {
  font-size: var(--font-size-md);
  color: var(--color-text);
}

@keyframes questComplete {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
  10% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
  15% { transform: translate(-50%, -50%) scale(1); }
  85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(1.1); }
}

/* Panel Slide-in Animation */
@keyframes panelSlideIn {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* Close button for panels */
.panel-close {
  position: absolute;
  top: var(--space-sm);
  right: var(--space-sm);
  background: none;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-round);
  width: 28px;
  height: 28px;
  color: var(--color-text-muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.2s ease;
}

.panel-close:hover {
  border-color: var(--color-accent);
  color: var(--color-text);
}

/* NPC Interaction Dialog */
.npc-dialog {
  position: absolute;
  bottom: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(26, 26, 46, 0.95);
  backdrop-filter: blur(12px);
  border: 2px solid var(--color-gold);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  max-width: 500px;
  width: 90%;
  z-index: var(--z-modal);
  animation: dialogSlideUp 0.3s ease-out;
  box-shadow: 0 0 20px rgba(218, 165, 32, 0.2);
}

.npc-dialog-header {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
  padding-bottom: var(--space-sm);
  border-bottom: 1px solid rgba(218, 165, 32, 0.3);
}

.npc-dialog-name {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
}

.npc-dialog-archetype {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.npc-dialog-mood {
  font-size: var(--font-size-xs);
  color: var(--color-crystal);
  margin-left: auto;
}

.npc-dialog-text {
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-text);
  line-height: 1.6;
  margin-bottom: var(--space-md);
}

.npc-dialog-actions {
  display: flex;
  gap: var(--space-sm);
  justify-content: flex-end;
}

.npc-dialog-btn {
  padding: var(--space-sm) var(--space-md);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  background: rgba(218, 165, 32, 0.1);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition: all 0.2s ease;
}

.npc-dialog-btn:hover {
  background: rgba(218, 165, 32, 0.3);
  border-color: var(--color-gold);
  color: var(--color-gold);
}

.npc-dialog-btn.primary {
  background: rgba(218, 165, 32, 0.2);
  border-color: var(--color-gold);
  color: var(--color-gold);
}

@keyframes dialogSlideUp {
  0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
  100% { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Crosshair / Interaction Indicator */
.crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  pointer-events: none;
  z-index: var(--z-hud);
  opacity: 0.4;
  transition: opacity 0.2s ease;
}

.crosshair.active {
  opacity: 0.8;
}

.crosshair::before,
.crosshair::after {
  content: '';
  position: absolute;
  background: var(--color-text);
}

.crosshair::before {
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  transform: translateY(-50%);
}

.crosshair::after {
  left: 50%;
  top: 0;
  bottom: 0;
  width: 1px;
  transform: translateX(-50%);
}

.crosshair .dot {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 4px;
  height: 4px;
  background: var(--color-gold);
  border-radius: var(--radius-round);
}

/* Interaction Prompt */
.interact-prompt {
  position: absolute;
  top: 55%;
  left: 50%;
  transform: translateX(-50%);
  font-size: var(--font-size-sm);
  color: var(--color-text);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  z-index: var(--z-hud);
  opacity: 0;
  transition: opacity 0.3s ease;
  text-align: center;
}

.interact-prompt.visible {
  opacity: 1;
}

.interact-prompt .key {
  display: inline-block;
  background: rgba(218, 165, 32, 0.2);
  border: 1px solid var(--color-gold);
  border-radius: 3px;
  padding: 1px 6px;
  font-family: var(--font-mono);
  font-size: var(--font-size-xs);
  color: var(--color-gold);
  margin: 0 2px;
}

/* Loading Screen */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 1s ease;
}

.loading-screen.fade-out {
  opacity: 0;
  pointer-events: none;
}

.loading-title {
  font-family: var(--font-main);
  font-size: 3rem;
  color: var(--color-gold);
  text-shadow: 0 0 30px rgba(218, 165, 32, 0.3);
  margin-bottom: var(--space-lg);
  letter-spacing: 0.3em;
  animation: titleGlow 3s ease-in-out infinite;
}

.loading-subtitle {
  font-family: var(--font-main);
  font-size: var(--font-size-md);
  color: var(--color-text-muted);
  margin-bottom: var(--space-xxl);
}

.loading-bar-container {
  width: 300px;
  height: 4px;
  background: rgba(218, 165, 32, 0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: var(--space-md);
}

.loading-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--color-gold), var(--color-dawn));
  border-radius: 2px;
  transition: width 0.3s ease;
  width: 0%;
}

.loading-status {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
}

@keyframes titleGlow {
  0%, 100% { text-shadow: 0 0 20px rgba(218, 165, 32, 0.2); }
  50% { text-shadow: 0 0 40px rgba(218, 165, 32, 0.5), 0 0 60px rgba(218, 165, 32, 0.2); }
}

/* Controls Help Overlay */
.controls-overlay {
  position: absolute;
  bottom: var(--space-md);
  right: var(--space-md);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  z-index: var(--z-hud);
  transition: opacity 0.3s ease;
  max-width: 200px;
}

.controls-overlay-title {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.control-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: var(--space-xs);
  gap: var(--space-sm);
}

.control-key {
  font-family: var(--font-mono);
  color: var(--color-gold);
  font-weight: bold;
  min-width: 40px;
}

.control-desc {
  flex: 1;
  text-align: right;
}

/* Spark Balance Animation */
.spark-balance {
  display: inline-block;
  transition: transform 0.2s ease;
}

.spark-balance.changed {
  animation: sparkPulse 0.5s ease;
}

@keyframes sparkPulse {
  0% { transform: scale(1); }
  30% { transform: scale(1.3); color: var(--color-gold); }
  100% { transform: scale(1); }
}

/* Status Effect Indicators */
.status-effects {
  position: absolute;
  top: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: var(--space-sm);
  z-index: var(--z-hud);
  pointer-events: none;
}

.status-effect {
  width: 32px;
  height: 32px;
  background: var(--color-bg-panel);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  animation: statusPop 0.3s ease;
}

@keyframes statusPop {
  0% { transform: scale(0); }
  60% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

/* Day/Night Overlay */
.daynight-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 1;
  transition: background 5s ease;
}

.daynight-overlay.dawn {
  background: rgba(244, 164, 96, 0.05);
}

.daynight-overlay.day {
  background: transparent;
}

.daynight-overlay.dusk {
  background: rgba(139, 105, 20, 0.08);
}

.daynight-overlay.night {
  background: rgba(26, 26, 46, 0.15);
}

/* Zone Transition Overlay */
.zone-transition {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: var(--z-modal);
  pointer-events: none;
  animation: zoneTransition 1.5s ease-in-out;
}

.zone-transition-name {
  font-family: var(--font-main);
  font-size: var(--font-size-xxl);
  color: var(--color-gold);
  text-shadow: 0 0 20px rgba(218, 165, 32, 0.5);
  letter-spacing: 0.2em;
}

@keyframes zoneTransition {
  0% { opacity: 0; }
  30% { opacity: 1; }
  70% { opacity: 1; }
  100% { opacity: 0; }
}

/* Achievement/Chain Completion Popup */
.achievement-popup {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(20, 18, 25, 0.95), rgba(40, 35, 50, 0.95));
  border: 2px solid var(--color-gold);
  border-radius: var(--radius-lg);
  padding: var(--space-lg) var(--space-xxl);
  text-align: center;
  z-index: 2000;
  animation: achievementSlide 0.5s ease-out, achievementFade 4s ease-in-out;
  box-shadow: 0 0 40px rgba(218, 165, 32, 0.3);
  pointer-events: none;
}

.achievement-popup-title {
  font-family: var(--font-main);
  font-size: var(--font-size-sm);
  color: var(--color-gold);
  text-transform: uppercase;
  letter-spacing: 0.15em;
  margin-bottom: var(--space-xs);
}

.achievement-popup-name {
  font-family: var(--font-main);
  font-size: var(--font-size-xl);
  color: var(--color-text);
  margin-bottom: var(--space-xs);
}

.achievement-popup-reward {
  font-size: var(--font-size-sm);
  color: var(--color-gold);
}

@keyframes achievementSlide {
  0% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
  100% { transform: translateX(-50%) translateY(0); opacity: 1; }
}

@keyframes achievementFade {
  0%, 80% { opacity: 1; }
  100% { opacity: 0; }
}

/* Tooltip system */
.game-tooltip {
  position: absolute;
  background: rgba(15, 12, 20, 0.95);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-xs);
  color: var(--color-text);
  pointer-events: none;
  z-index: 3000;
  max-width: 200px;
  white-space: nowrap;
  box-shadow: var(--shadow-lg);
}

.game-tooltip-title {
  color: var(--color-gold);
  font-weight: 600;
  margin-bottom: 2px;
}

.game-tooltip-desc {
  color: var(--color-text-muted);
  font-size: 0.7rem;
}

/* Daily Quest Banner */
.daily-quest-banner {
  position: absolute;
  top: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(90deg, transparent, rgba(218, 165, 32, 0.1), transparent);
  padding: var(--space-xs) var(--space-lg);
  color: var(--color-gold);
  font-size: var(--font-size-sm);
  letter-spacing: 0.1em;
  text-align: center;
  pointer-events: none;
  animation: fadeIn 1s ease;
}

/* Notification badge on HUD icons */
.hud-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  background: var(--color-quest-active);
  color: white;
  font-size: 0.6rem;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

/* Compass indicator */
.compass {
  position: absolute;
  top: var(--space-md);
  left: 50%;
  transform: translateX(-50%);
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  letter-spacing: 0.3em;
  opacity: 0.5;
}

/* Health/Energy bars (for future use) */
.stat-bar {
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-top: 2px;
}

.stat-bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.5s ease;
}

.stat-bar-fill.spark { background: linear-gradient(90deg, var(--color-gold), var(--color-dawn)); }
.stat-bar-fill.energy { background: linear-gradient(90deg, #4caf50, #8bc34a); }
.stat-bar-fill.social { background: linear-gradient(90deg, #2196f3, #03a9f4); }

/* NPC Shop */
#npc-shop-panel::-webkit-scrollbar { width: 6px; }
#npc-shop-panel::-webkit-scrollbar-track { background: transparent; }
#npc-shop-panel::-webkit-scrollbar-thumb { background: rgba(218,165,32,0.3); border-radius: 3px; }

.npc-shop-panel {
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.npc-shop-panel.visible {
  transform: scale(1);
  opacity: 1;
}

/* Guild Panel */
.guild-panel {
  transform: translateX(20px);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.guild-panel.visible {
  transform: translateX(0);
  opacity: 1;
}
.guild-member-row {
  display: flex; align-items: center; padding: 6px 8px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  transition: background 0.2s;
}
.guild-member-row:hover { background: rgba(255,255,255,0.05); }

/* Skills Panel */
.skill-row {
  display: flex; align-items: center; padding: 8px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.skill-bar {
  flex: 1; height: 6px; background: rgba(255,255,255,0.08);
  border-radius: 3px; overflow: hidden; margin: 0 10px;
}
.skill-bar-fill {
  height: 100%; border-radius: 3px; transition: width 0.5s ease;
  background: linear-gradient(90deg, #4caf50, #8bc34a);
}

/* Discovery Popup */
.discovery-popup {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.6);
  opacity: 0;
  background: rgba(10,14,26,0.95); border: 2px solid var(--color-gold);
  border-radius: 16px; padding: 24px 32px; text-align: center;
  z-index: 10000; pointer-events: auto;
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.discovery-popup.visible {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}

@keyframes discoveryReveal {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }
  60% { transform: translate(-50%, -50%) scale(1.05); }
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* Lore Book */
.lore-entry {
  padding: 12px 16px; margin-bottom: 8px;
  background: rgba(255,255,255,0.03); border-radius: 8px;
  border-left: 3px solid rgba(147,112,219,0.5);
  transition: background 0.2s;
}
.lore-entry:hover { background: rgba(255,255,255,0.06); }
.lore-entry.unread { border-left-color: var(--color-gold); }

/* Warmth indicator */
.warmth-indicator {
  display: inline-flex; align-items: center; gap: 4px;
  font-size: 10px; color: #ff9800; padding: 2px 6px;
  background: rgba(255,152,0,0.1); border-radius: 4px;
}

/* Achievement panel */
.achievement-panel {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: rgba(15,12,10,0.95); border: 1px solid rgba(218,165,32,0.3);
  border-radius: 12px; padding: 24px; min-width: 420px; max-width: 550px;
  max-height: 70vh; overflow-y: auto; z-index: 1100;
  backdrop-filter: blur(10px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.achievement-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}
.achievement-panel h2 {
  color: var(--color-gold); margin: 0 0 4px; font-size: 1.2rem;
  font-family: var(--font-main); letter-spacing: 0.1em;
}
.achievement-progress-bar {
  width: 100%; height: 6px; background: rgba(255,255,255,0.1);
  border-radius: 3px; margin: 8px 0 16px; overflow: hidden;
}
.achievement-progress-fill {
  height: 100%; background: linear-gradient(90deg, var(--color-gold), #f0c040);
  border-radius: 3px; transition: width 0.5s ease;
}
.achievement-category { margin-bottom: 16px; }
.achievement-category-title {
  color: var(--color-text-muted); font-size: 0.7rem; text-transform: uppercase;
  letter-spacing: 0.15em; margin-bottom: 8px; padding-bottom: 4px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.achievement-row {
  display: flex; align-items: center; gap: 10px; padding: 6px 8px;
  border-radius: 6px; margin-bottom: 4px; transition: background 0.2s;
}
.achievement-row:hover { background: rgba(255,255,255,0.05); }
.achievement-row.locked { opacity: 0.4; }
.achievement-row.unlocked { opacity: 1; }
.achievement-icon { font-size: 1.4rem; width: 32px; text-align: center; }
.achievement-info { flex: 1; }
.achievement-name {
  color: var(--color-text); font-size: 0.85rem; font-weight: 500;
}
.achievement-desc {
  color: var(--color-text-muted); font-size: 0.7rem;
}
.achievement-reward {
  color: var(--color-gold); font-size: 0.7rem; white-space: nowrap;
}

/* Achievement toast notification */
.achievement-toast {
  position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(135deg, rgba(25,20,15,0.95), rgba(35,28,18,0.95));
  border: 1px solid var(--color-gold); border-radius: 10px;
  padding: 12px 20px; display: flex; align-items: center; gap: 12px;
  z-index: 1200; animation: achievementSlide 0.4s ease, achievementFade 0.5s 3s forwards;
  box-shadow: 0 4px 20px rgba(218,165,32,0.2);
}
.achievement-toast-icon { font-size: 2rem; }
.achievement-toast-text { }
.achievement-toast-label {
  color: var(--color-gold); font-size: 0.65rem; text-transform: uppercase;
  letter-spacing: 0.15em;
}
.achievement-toast-name {
  color: var(--color-text); font-size: 1rem; font-weight: 500;
}
@keyframes achievementSlide {
  from { transform: translateX(-50%) translateY(-30px); opacity: 0; }
  to { transform: translateX(-50%) translateY(0); opacity: 1; }
}
@keyframes achievementFade {
  to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
}

/* Auction house panel */
.auction-panel {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: rgba(15,12,10,0.95); border: 1px solid rgba(176,224,230,0.3);
  border-radius: 12px; padding: 24px; min-width: 450px; max-width: 600px;
  max-height: 70vh; overflow-y: auto; z-index: 1100;
  backdrop-filter: blur(10px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.auction-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}
.auction-panel h2 {
  color: var(--color-accent); margin: 0 0 16px; font-size: 1.2rem;
  font-family: var(--font-main);
}
.auction-item {
  display: flex; align-items: center; gap: 12px; padding: 10px;
  background: rgba(255,255,255,0.03); border-radius: 8px; margin-bottom: 8px;
  border: 1px solid rgba(255,255,255,0.05); transition: border-color 0.2s;
}
.auction-item:hover { border-color: rgba(176,224,230,0.2); }
.auction-item-icon { font-size: 1.5rem; width: 36px; text-align: center; }
.auction-item-info { flex: 1; }
.auction-item-name { color: var(--color-text); font-size: 0.85rem; }
.auction-item-seller { color: var(--color-text-muted); font-size: 0.7rem; }
.auction-item-time { color: rgba(255,200,100,0.7); font-size: 0.65rem; }
.auction-bid-info { text-align: right; }
.auction-current-bid { color: var(--color-gold); font-size: 0.9rem; font-weight: 500; }
.auction-bid-count { color: var(--color-text-muted); font-size: 0.65rem; }

/* Economic event banner */
.economic-event-banner {
  position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(90deg, transparent, rgba(218,165,32,0.15), transparent);
  color: var(--color-gold); font-size: 0.75rem; padding: 4px 20px;
  border-radius: 20px; z-index: 900; pointer-events: none;
  letter-spacing: 0.05em; text-align: center;
  animation: eventBannerPulse 3s ease-in-out infinite;
}
@keyframes eventBannerPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

/* Lore Journal Panel */
.lore-journal-panel {
  font-family: Georgia, serif;
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.lore-journal-panel.visible {
  transform: scale(1);
  opacity: 1;
}

.lore-journal-panel::-webkit-scrollbar {
  width: 8px;
}

.lore-journal-panel::-webkit-scrollbar-track {
  background: rgba(42, 24, 16, 0.5);
  border-radius: 4px;
}

.lore-journal-panel::-webkit-scrollbar-thumb {
  background: rgba(139, 105, 20, 0.6);
  border-radius: 4px;
}

.lore-journal-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(212, 175, 55, 0.7);
}

.lore-category-tab {
  outline: none;
}

.lore-category-tab:active {
  transform: translateY(1px);
}

.lore-entry {
  position: relative;
}

.lore-entry-locked {
  cursor: not-allowed;
  user-select: none;
}

.lore-progress {
  font-weight: 500;
}

/* Pet Panel */
.pet-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.95);
  opacity: 0;
  background: rgba(15, 12, 10, 0.95);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-radius: 12px;
  padding: 24px;
  min-width: 420px;
  max-width: 550px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: 1100;
  backdrop-filter: blur(10px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.pet-panel.visible {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
}

.pet-panel h2 {
  color: var(--color-gold);
  margin: 0 0 16px;
  font-size: 1.2rem;
  font-family: var(--font-main);
  letter-spacing: 0.1em;
  text-align: center;
}

.pet-panel::-webkit-scrollbar {
  width: 6px;
}

.pet-panel::-webkit-scrollbar-thumb {
  background: rgba(218, 165, 32, 0.3);
  border-radius: 3px;
}

.pet-action-btn {
  flex: 1;
  padding: 10px 16px;
  background: rgba(218, 165, 32, 0.2);
  border: 1px solid rgba(218, 165, 32, 0.5);
  border-radius: 6px;
  color: var(--color-gold);
  font-family: var(--font-ui);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pet-action-btn:hover {
  background: rgba(218, 165, 32, 0.3);
  border-color: var(--color-gold);
  transform: translateY(-1px);
}

.pet-action-btn:active {
  transform: translateY(0);
}

.pet-release-btn {
  width: 100%;
  padding: 10px 16px;
  background: rgba(231, 76, 60, 0.1);
  border: 1px solid rgba(231, 76, 60, 0.3);
  border-radius: 6px;
  color: #e74c3c;
  font-family: var(--font-ui);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pet-release-btn:hover {
  background: rgba(231, 76, 60, 0.2);
  border-color: #e74c3c;
}

.pet-adopt-btn {
  padding: 8px 16px;
  background: rgba(46, 204, 113, 0.2);
  border: 1px solid rgba(46, 204, 113, 0.5);
  border-radius: 6px;
  color: #2ecc71;
  font-family: var(--font-ui);
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.pet-adopt-btn:hover {
  background: rgba(46, 204, 113, 0.3);
  border-color: #2ecc71;
  transform: scale(1.05);
}

.pet-adoption-row {
  transition: all 0.2s ease;
}

.pet-adoption-row:hover .pet-adopt-btn {
  background: rgba(46, 204, 113, 0.3);
}

/* Pet Adopt Notification */
.pet-adopt-notification {
  font-family: var(--font-main);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .chat-panel {
    max-width: 250px;
  }

  .player-info {
    min-width: 150px;
  }

  .nearby-list {
    display: none;
  }

  .lore-journal-panel {
    width: 95%;
    height: 90vh;
  }

  .lore-category-tab {
    padding: 8px 12px;
    font-size: 12px;
  }

  .pet-panel {
    min-width: 320px;
    max-width: 90vw;
  }

  /* Mobile touch target sizes (minimum 44x44px) */
  .hud-btn, .panel-btn, .craft-btn, .trade-btn, .quest-btn,
  .pet-action-btn, .pet-adopt-btn, .npc-dialog-btn {
    min-width: 44px;
    min-height: 44px;
  }

  /* Smaller minimap on mobile */
  .minimap {
    width: 120px !important;
    height: 120px !important;
  }

  #minimap-canvas {
    width: 120px !important;
    height: 120px !important;
  }

  /* Full-width chat input at bottom */
  .chat-input {
    width: calc(100vw - 32px);
    max-width: none;
  }

  /* Collapsible quest tracker */
  .quest-tracker {
    max-height: 120px;
    overflow-y: auto;
  }

  .quest-tracker-title {
    font-size: var(--font-size-xs);
  }

  /* Smaller status text */
  .player-info {
    font-size: var(--font-size-xs);
  }
}

@media (max-width: 480px) {
  .chat-panel {
    max-width: 200px;
    font-size: var(--font-size-xs);
  }

  .player-info {
    font-size: var(--font-size-xs);
  }

  .zone-label {
    font-size: var(--font-size-lg);
  }

  .pet-panel {
    min-width: 280px;
    padding: 16px;
  }
}

/* Seasonal Event Banner */
.seasonal-banner {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  padding: var(--space-sm) var(--space-xl);
  background: linear-gradient(90deg, transparent, rgba(218, 165, 32, 0.15), transparent);
  backdrop-filter: blur(8px);
  border-bottom-left-radius: var(--radius-lg);
  border-bottom-right-radius: var(--radius-lg);
  border: 1px solid rgba(218, 165, 32, 0.3);
  border-top: none;
  text-align: center;
  z-index: var(--z-hud);
  pointer-events: none;
  min-width: 300px;
  animation: seasonalBannerFadeIn 1s ease;
  transition: all 0.5s ease;
}

.seasonal-banner-title {
  font-family: var(--font-main);
  font-size: var(--font-size-sm);
  font-weight: bold;
  letter-spacing: 0.08em;
  margin-bottom: 2px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
}

.seasonal-banner-desc {
  font-size: var(--font-size-xs);
  opacity: 0.9;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
}

.seasonal-banner-countdown {
  font-size: var(--font-size-xs);
  opacity: 0.7;
  margin-top: 2px;
}

@keyframes seasonalBannerFadeIn {
  0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
  100% { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Seasonal Item Badge */
.seasonal-item-badge {
  position: absolute;
  top: 2px;
  right: 2px;
  width: 12px;
  height: 12px;
  border-radius: var(--radius-round);
  border: 1px solid rgba(255, 255, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  font-weight: bold;
  pointer-events: none;
  animation: seasonalBadgePulse 2s ease-in-out infinite;
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.5);
}

@keyframes seasonalBadgePulse {
  0%, 100% { transform: scale(1); opacity: 0.9; }
  50% { transform: scale(1.1); opacity: 1; }
}

/* Season-specific styles */
.season-spring {
  background: linear-gradient(90deg, transparent, rgba(248, 180, 200, 0.2), transparent);
  border-color: rgba(248, 180, 200, 0.4);
}

.season-spring .seasonal-banner-title {
  color: #f8b4c8;
}

.season-spring .seasonal-banner-desc,
.season-spring .seasonal-banner-countdown {
  color: #7db37d;
}

.season-spring .seasonal-item-badge {
  background: #f8b4c8;
  color: #7db37d;
  border-color: #ffd4e5;
}

.season-summer {
  background: linear-gradient(90deg, transparent, rgba(240, 192, 64, 0.2), transparent);
  border-color: rgba(240, 192, 64, 0.4);
}

.season-summer .seasonal-banner-title {
  color: #f0c040;
}

.season-summer .seasonal-banner-desc,
.season-summer .seasonal-banner-countdown {
  color: #ff8c42;
}

.season-summer .seasonal-item-badge {
  background: #f0c040;
  color: #ff8c42;
  border-color: #ffe080;
}

.season-autumn {
  background: linear-gradient(90deg, transparent, rgba(212, 160, 64, 0.2), transparent);
  border-color: rgba(212, 160, 64, 0.4);
}

.season-autumn .seasonal-banner-title {
  color: #d4a040;
}

.season-autumn .seasonal-banner-desc,
.season-autumn .seasonal-banner-countdown {
  color: #8b4513;
}

.season-autumn .seasonal-item-badge {
  background: #d4a040;
  color: #8b4513;
  border-color: #e8b860;
}

.season-winter {
  background: linear-gradient(90deg, transparent, rgba(128, 192, 224, 0.2), transparent);
  border-color: rgba(128, 192, 224, 0.4);
}

.season-winter .seasonal-banner-title {
  color: #80c0e0;
}

.season-winter .seasonal-banner-desc,
.season-winter .seasonal-banner-countdown {
  color: #e8e8ff;
}

.season-winter .seasonal-item-badge {
  background: #80c0e0;
  color: #0a0a14;
  border-color: #a0d4f0;
}

/* ========================================================================
   GLOBAL BUTTON HOVER EFFECTS AND ANIMATIONS
   ======================================================================== */

/* Generic button transitions */
.hud-btn, .panel-btn, .craft-btn, .trade-btn, .quest-btn,
.pet-action-btn, .pet-adopt-btn, .npc-dialog-btn {
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease, border-color 0.15s ease;
}

.hud-btn:hover, .panel-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 3px 10px rgba(218, 165, 32, 0.2);
}

.hud-btn:active, .panel-btn:active {
  transform: translateY(0);
}

/* Inventory slot hover enhancement */
.inventory-slot {
  transition: all 0.2s ease, border-color 0.15s ease, transform 0.1s ease;
}

.inventory-slot:hover {
  transform: scale(1.05);
}

/* Recipe item hover enhancement */
.recipe-item {
  transition: all 0.2s ease, background 0.15s ease, border-color 0.15s ease;
}

/* Quest entry hover enhancement */
.quest-entry {
  transition: all 0.2s ease, border-color 0.15s ease, background 0.15s ease;
}

/* Panel close button enhancement */
.panel-close {
  transition: all 0.2s ease, border-color 0.15s ease, transform 0.1s ease;
}

.panel-close:hover {
  transform: scale(1.1);
}

/* Governance panel */
.governance-panel {
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.25s ease, transform 0.25s ease;
}

.governance-panel.visible {
  transform: scale(1);
  opacity: 1;
}

/* Discovery panel */
.discovery-panel {
  opacity: 0;
  transition: opacity 0.25s ease;
}

.discovery-panel.visible {
  opacity: 1;
}

/* ========================================================================
   TOOL PANELS â€” Economy Visualizer, State Inspector, Replay, Nearby Anchors
   ======================================================================== */

/* Shared base for all 4 new tool panels */
.zion-tool-panel {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 300;
  pointer-events: auto;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(12px);
  transition: opacity 0.2s ease, transform 0.2s ease;
}

/* â”€â”€ Economy Visualizer â”€â”€ */
.economy-viz-panel {
  border-color: #22c55e;
  width: 520px;
  max-height: 80vh;
}

.economy-viz-panel canvas {
  display: block;
  width: 100%;
  height: auto;
  border-radius: 6px;
}

.economy-gini-bar {
  flex: 1;
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
}

.economy-gini-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.5s ease, background-color 0.5s ease;
}

.economy-dist-bars {
  display: flex;
  align-items: flex-end;
  gap: 3px;
  height: 60px;
}

.economy-dist-bar {
  flex: 1;
  border-radius: 3px 3px 0 0;
  background: #22c55e;
  transition: height 0.4s ease;
  cursor: pointer;
}

.economy-dist-bar:hover {
  filter: brightness(1.3);
}

/* â”€â”€ YAML State Inspector â”€â”€ */
.yaml-inspector-panel {
  border-color: #818cf8;
  width: 560px;
  height: 600px;
}

#yaml-inspector-tree {
  font-family: 'Courier New', Courier, monospace;
  font-size: 12px;
  line-height: 1.7;
  white-space: pre;
  color: #e0e0e0;
  overflow-y: auto;
  flex: 1;
  padding: 12px 16px;
}

/* YAML type coloring via inline styles (applied in JS) */
.yaml-type-string  { color: #86efac; }
.yaml-type-number  { color: #67e8f9; }
.yaml-type-boolean { color: #fbbf24; }
.yaml-type-null    { color: #9ca3af; }
.yaml-type-key     { color: #818cf8; }

#yaml-inspector-search {
  outline: none;
  transition: border-color 0.2s ease;
}
#yaml-inspector-search:focus {
  border-color: #818cf8 !important;
}

#yaml-inspector-source {
  appearance: none;
  -webkit-appearance: none;
  cursor: pointer;
  outline: none;
}

/* â”€â”€ Protocol Replay Controls â”€â”€ */
.replay-panel {
  border-color: #f472b6;
  width: 460px;
}

.replay-btn-record {
  background: rgba(239, 68, 68, 0.15);
  border: 1px solid #ef4444;
  color: #ef4444;
  border-radius: 6px;
  padding: 8px 16px;
  cursor: pointer;
  font-weight: bold;
  transition: background 0.2s ease;
}

.replay-btn-record:hover {
  background: rgba(239, 68, 68, 0.3);
}

.replay-btn-stop {
  background: rgba(100, 100, 100, 0.15);
  border: 1px solid #555;
  color: #888;
  border-radius: 6px;
  padding: 8px 16px;
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease;
}

.replay-btn-stop.active {
  border-color: #ef4444;
  color: #ef4444;
  background: rgba(239, 68, 68, 0.15);
}

.replay-btn-play {
  background: rgba(34, 197, 94, 0.15);
  border: 1px solid rgba(34, 197, 94, 0.4);
  color: #22c55e;
  border-radius: 6px;
  padding: 8px 16px;
  cursor: pointer;
  transition: background 0.2s ease;
}

.replay-btn-play:hover {
  background: rgba(34, 197, 94, 0.3);
}

#replay-seek {
  width: 100%;
  accent-color: #f472b6;
  cursor: pointer;
}

.replay-speed-btn {
  padding: 4px 10px;
  border-radius: 4px;
  color: #f472b6;
  font-size: 11px;
  cursor: pointer;
  transition: background 0.15s ease, border-color 0.15s ease;
}

.replay-speed-btn.active {
  background: rgba(244, 114, 182, 0.25) !important;
  border-color: rgba(244, 114, 182, 0.6) !important;
}

/* â”€â”€ Nearby Anchors Panel â”€â”€ */
.nearby-anchors-panel {
  border-color: #38bdf8;
  width: 440px;
  max-height: 600px;
}

.nearby-anchor-card {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  margin-bottom: 8px;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  transition: background 0.2s ease, border-color 0.2s ease;
  cursor: default;
}

.nearby-anchor-card:hover {
  background: rgba(56, 189, 248, 0.06);
  border-color: rgba(56, 189, 248, 0.2);
}

.nearby-anchor-card.in-range {
  border-color: rgba(34, 197, 94, 0.3);
  background: rgba(34, 197, 94, 0.04);
}

.nearby-anchor-icon {
  font-size: 22px;
  width: 32px;
  text-align: center;
}

.nearby-anchor-name {
  font-size: 13px;
  color: #e0e0e0;
  font-weight: bold;
}

.nearby-anchor-zone {
  font-size: 11px;
  color: #666;
}

.nearby-anchor-dist {
  font-size: 12px;
  font-weight: bold;
  text-align: right;
}

.nearby-anchor-dist.close  { color: #22c55e; }
.nearby-anchor-dist.medium { color: #38bdf8; }
.nearby-anchor-dist.far    { color: #888; }

.nearby-in-range-badge {
  font-size: 10px;
  color: #22c55e;
  text-align: right;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

#nearby-enable-location:hover {
  background: rgba(56, 189, 248, 0.25) !important;
}

/* â”€â”€ Generic tool panel header + close btn â”€â”€ */
.zion-tool-panel-header {
  display: flex;
  align-items: center;
  padding: 14px 18px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  flex-shrink: 0;
}

.zion-tool-panel-title {
  font-size: 16px;
  font-weight: bold;
  flex: 1;
}

.zion-tool-panel-close {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  width: 28px;
  height: 28px;
  color: #aaa;
  cursor: pointer;
  font-size: 14px;
  line-height: 1;
  transition: background 0.2s ease, color 0.2s ease;
}

.zion-tool-panel-close:hover {
  background: rgba(255, 255, 255, 0.2);
  color: #fff;
}

/* ========================================================================
   AMENDMENT VOTING PANEL â€” Constitutional Amendment Proposals & Voting
   ======================================================================== */

.amendment-panel {
  border-color: #daa520;
  width: 600px;
  max-height: 82vh;
}

/* Amendment card: open vote item */
.amend-card {
  transition: box-shadow 0.2s ease, border-color 0.2s ease;
}

.amend-card:hover {
  box-shadow: 0 2px 12px rgba(218, 165, 32, 0.18);
  border-color: rgba(218, 165, 32, 0.5) !important;
}

/* Vote button hover states */
.amend-vote-btn {
  transition: background 0.15s ease, transform 0.1s ease;
}

.amend-vote-btn:hover {
  filter: brightness(1.25);
  transform: translateY(-1px);
}

/* Tab buttons */
.amend-tab-btn {
  transition: color 0.15s ease, background 0.15s ease;
}

.amend-tab-btn:hover {
  color: #daa520 !important;
  background: rgba(218, 165, 32, 0.1) !important;
}

/* History closed amendment card */
.amend-history-card {
  transition: background 0.15s ease;
}

.amend-history-card:hover {
  background: rgba(255, 255, 255, 0.05) !important;
}

/* Proposal form inputs */
#amend-propose-form input,
#amend-propose-form textarea {
  transition: border-color 0.15s ease, box-shadow 0.15s ease;
  outline: none;
}

#amend-propose-form input:focus,
#amend-propose-form textarea:focus {
  border-color: #daa520 !important;
  box-shadow: 0 0 0 2px rgba(218, 165, 32, 0.2);
}

/* Submit button hover */
#amend-submit-btn:hover {
  filter: brightness(1.15);
  transform: translateY(-1px);
}

/* Spark-weight vote progress bar */
.amend-vote-bar-fill {
  height: 100%;
  border-radius: 3px;
  background: linear-gradient(90deg, #4ade80, #22c55e);
  transition: width 0.4s ease;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOAST / NOTIFICATION SYSTEM
   Container sits in the top-right corner, below the minimap.
   Individual toasts slide in from the right and fade out.
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Container â€” stacks toasts vertically */
.toast-container {
  position: fixed;
  top: 140px;          /* clears minimap (top:20px + ~120px height) */
  right: var(--space-md, 16px);
  width: 320px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
  z-index: 9000;
}

/* Single toast card */
.toast {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  background: rgba(10, 10, 20, 0.88);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-left-width: 4px;           /* coloured accent set per-type */
  border-radius: 8px;
  padding: 10px 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  pointer-events: auto;
  cursor: pointer;
  user-select: none;
  animation: toastSlideIn 0.28s cubic-bezier(0.22, 1, 0.36, 1) both;
  position: relative;
  overflow: hidden;
}

.toast.toast-exiting {
  animation: toastFadeOut 0.25s ease-in forwards;
}

/* Progress bar that shrinks over the toast's duration */
.toast-progress {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 2px;
  background: currentColor;
  opacity: 0.4;
  transform-origin: left;
  animation: toastProgress linear forwards;
}

/* Icon */
.toast-icon {
  font-size: 20px;
  line-height: 1;
  flex-shrink: 0;
  margin-top: 1px;
}

/* Body */
.toast-body {
  flex: 1;
  min-width: 0;
}

.toast-label {
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  opacity: 0.6;
  margin-bottom: 2px;
  color: inherit;
}

.toast-message {
  font-size: 13px;
  line-height: 1.35;
  color: #e8e8e8;
  word-break: break-word;
}

/* Group count badge */
.toast-badge {
  position: absolute;
  top: 6px;
  right: 8px;
  background: rgba(255, 255, 255, 0.15);
  border-radius: 10px;
  padding: 1px 7px;
  font-size: 11px;
  font-weight: 700;
  color: #fff;
  line-height: 1.4;
}

/* Dismiss (Ã—) button â€” appears on hover */
.toast-close {
  position: absolute;
  bottom: 5px;
  right: 8px;
  font-size: 11px;
  opacity: 0;
  color: rgba(255, 255, 255, 0.5);
  transition: opacity 0.15s ease;
  cursor: pointer;
  line-height: 1;
}

.toast:hover .toast-close {
  opacity: 1;
}

/* â”€â”€ Type-specific border colours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

.toast-economy {
  border-left-color: #f1c40f;
  color: #f1c40f;
}

.toast-achievement {
  border-left-color: #e67e22;
  color: #e67e22;
}

.toast-social {
  border-left-color: #3498db;
  color: #3498db;
}

.toast-system {
  border-left-color: #95a5a6;
  color: #95a5a6;
}

.toast-quest {
  border-left-color: #9b59b6;
  color: #9b59b6;
}

.toast-combat {
  border-left-color: #e74c3c;
  color: #e74c3c;
}

/* â”€â”€ Priority modifiers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

.toast-priority-critical {
  border-width: 2px;
  border-left-width: 5px;
  box-shadow: 0 0 0 1px rgba(231, 76, 60, 0.4), 0 4px 20px rgba(0, 0, 0, 0.6);
  animation: toastSlideIn 0.28s cubic-bezier(0.22, 1, 0.36, 1) both,
             toastPulseBorder 1.5s ease-in-out 0.3s infinite;
}

.toast-priority-high {
  border-left-width: 5px;
}

.toast-priority-low {
  opacity: 0.85;
}

/* â”€â”€ Keyframe animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@keyframes toastSlideIn {
  from {
    opacity: 0;
    transform: translateX(110%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes toastFadeOut {
  from {
    opacity: 1;
    transform: translateX(0);
    max-height: 100px;
    margin-bottom: 0;
  }
  to {
    opacity: 0;
    transform: translateX(40px);
    max-height: 0;
    margin-bottom: -8px;
    padding-top: 0;
    padding-bottom: 0;
  }
}

@keyframes toastProgress {
  from { transform: scaleX(1); }
  to   { transform: scaleX(0); }
}

@keyframes toastPulseBorder {
  0%, 100% { box-shadow: 0 0 0 1px rgba(231, 76, 60, 0.4), 0 4px 20px rgba(0, 0, 0, 0.6); }
  50%       { box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.6), 0 4px 24px rgba(0, 0, 0, 0.7); }
}

/* Overflow badge â€” shows how many toasts are queued */
.toast-overflow-badge {
  text-align: center;
  font-size: 11px;
  color: rgba(255, 255, 255, 0.5);
  padding: 4px 0;
  pointer-events: none;
}


.amend-history-card:hover {
  background: rgba(255, 255, 255, 0.05) !important;
}

/* Proposal form inputs */
#amend-propose-form input,
#amend-propose-form textarea {
  transition: border-color 0.15s ease, box-shadow 0.15s ease;
  outline: none;
}

#amend-propose-form input:focus,
#amend-propose-form textarea:focus {
  border-color: #daa520 !important;
  box-shadow: 0 0 0 2px rgba(218, 165, 32, 0.2);
}

/* Submit button hover */
#amend-submit-btn:hover {
  filter: brightness(1.15);
  transform: translateY(-1px);
}

/* Spark-weight vote progress bar */
.amend-vote-bar-fill {
  height: 100%;
  border-radius: 3px;
  background: linear-gradient(90deg, #4ade80, #22c55e);
  transition: width 0.4s ease;
}


/* world.css */
/* Portal Glow Effect */
.portal-glow {
  animation: portalPulse 2s ease-in-out infinite;
}

@keyframes portalPulse {
  0%, 100% {
    opacity: 0.6;
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
    filter: brightness(1.3);
  }
}

/* Loading Screen */
.loading-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--color-night);
  z-index: var(--z-modal);
  transition: opacity 0.5s ease;
}

.loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-spinner {
  width: 64px;
  height: 64px;
  border: 4px solid var(--color-border);
  border-top-color: var(--color-accent);
  border-radius: var(--radius-round);
  animation: spin 1s linear infinite;
  margin-bottom: var(--space-lg);
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.loading-text {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-text-muted);
  font-style: italic;
}

.loading-progress {
  margin-top: var(--space-md);
  font-size: var(--font-size-sm);
  color: var(--color-accent);
}

/* Player Label (floating above sprite) */
.player-label {
  position: absolute;
  transform: translate(-50%, -150%);
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-xs) var(--space-sm);
  font-family: var(--font-ui);
  font-size: var(--font-size-xs);
  color: var(--color-text);
  white-space: nowrap;
  pointer-events: none;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  transition: opacity 0.3s ease;
}

.player-label.self {
  color: var(--color-accent);
  border-color: var(--color-accent);
}

.player-label.ai {
  color: var(--color-crystal);
  border-color: var(--color-water);
}

/* XR Warning Overlay */
.xr-warning {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(26, 26, 26, 0.95);
  z-index: var(--z-modal);
  padding: var(--space-xl);
  text-align: center;
}

.xr-warning-title {
  font-family: var(--font-main);
  font-size: var(--font-size-xxl);
  color: var(--color-warning);
  margin-bottom: var(--space-lg);
}

.xr-warning-text {
  font-size: var(--font-size-md);
  color: var(--color-text);
  max-width: 600px;
  line-height: 1.6;
  margin-bottom: var(--space-md);
}

.xr-warning-list {
  text-align: left;
  max-width: 500px;
  margin: var(--space-lg) auto;
  color: var(--color-text-muted);
  line-height: 1.8;
}

.xr-warning-list li {
  margin-bottom: var(--space-sm);
}

.xr-warning-btn {
  background: var(--color-warning);
  color: var(--color-night);
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-md) var(--space-xl);
  font-family: var(--font-ui);
  font-size: var(--font-size-lg);
  font-weight: bold;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all 0.2s ease;
  margin-top: var(--space-lg);
}

.xr-warning-btn:hover {
  background: var(--color-dawn);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.xr-warning-btn:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

/* World Effects */
.zone-transition {
  animation: zoneTransition 1s ease-in-out;
}

@keyframes zoneTransition {
  0% { opacity: 1; }
  50% { opacity: 0.3; }
  100% { opacity: 1; }
}

.item-pickup {
  animation: itemPickup 0.5s ease-out;
}

@keyframes itemPickup {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: scale(0);
    opacity: 0;
  }
}

.spark-gain {
  animation: sparkGain 1s ease-out;
  color: var(--color-gold);
  font-weight: bold;
}

@keyframes sparkGain {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translateY(-50px) scale(1.5);
    opacity: 0;
  }
}

/* Environmental effects */
.weather-rain {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(transparent, rgba(135, 206, 235, 0.1));
  animation: rain 0.3s linear infinite;
}

@keyframes rain {
  0% { opacity: 0.5; }
  50% { opacity: 0.8; }
  100% { opacity: 0.5; }
}

.weather-night {
  pointer-events: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(26, 26, 46, 0.3);
  transition: opacity 2s ease;
}

/* NPC Speech Bubbles */
.npc-speech-bubble {
  position: absolute;
  pointer-events: none;
  transform: translate(-50%, -100%);
  background: rgba(10, 14, 26, 0.9);
  border: 1px solid rgba(218, 165, 32, 0.5);
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 11px;
  color: #E8E0D8;
  white-space: nowrap;
  max-width: 200px;
  text-align: center;
  z-index: 50;
  animation: speechBubbleIn 0.3s ease-out;
}

.npc-speech-bubble::after {
  content: '';
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid rgba(218, 165, 32, 0.5);
}

.npc-speech-bubble.fading {
  animation: speechBubbleOut 0.5s ease-in forwards;
}

@keyframes speechBubbleIn {
  0% { opacity: 0; transform: translate(-50%, -80%); }
  100% { opacity: 1; transform: translate(-50%, -100%); }
}

@keyframes speechBubbleOut {
  0% { opacity: 1; transform: translate(-50%, -100%); }
  100% { opacity: 0; transform: translate(-50%, -120%); }
}

/* Loading Bar */
.loading-title {
  font-family: var(--font-main);
  font-size: 3.5rem;
  color: var(--color-gold);
  letter-spacing: 0.3em;
  text-shadow: 0 0 30px rgba(218, 165, 32, 0.3);
  margin-bottom: 0.5rem;
}

.loading-subtitle {
  color: var(--color-text-muted);
  font-style: italic;
  margin-bottom: 2rem;
}

.loading-bar-container {
  width: 300px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: 1rem;
}

.loading-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--color-gold), #f0d060);
  border-radius: 2px;
  transition: width 0.3s ease;
  animation: loadingPulse 1.5s ease-in-out infinite;
}

@keyframes loadingPulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

.loading-status {
  font-size: 0.75rem;
  color: var(--color-text-muted);
  letter-spacing: 0.05em;
}

/* Mobile Touch Controls */
.mobile-action-btn {
  position: fixed;
  border-radius: 50%;
  background: rgba(10, 14, 26, 0.75);
  border: 2px solid rgba(218, 165, 32, 0.5);
  color: #DAA520;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-family: var(--font-ui);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  z-index: 100;
  transition: background 0.15s, border-color 0.15s;
}

.mobile-action-btn:active {
  background: rgba(218, 165, 32, 0.3);
  border-color: #DAA520;
}

.mobile-joystick {
  position: fixed;
  bottom: 30px;
  left: 30px;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(10, 14, 26, 0.5);
  border: 2px solid rgba(218, 165, 32, 0.3);
  z-index: 100;
  touch-action: none;
}

.mobile-joystick-handle {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(218, 165, 32, 0.4);
  border: 2px solid rgba(218, 165, 32, 0.7);
  transition: none;
}

/* Controls Overlay */
.controls-overlay {
  position: absolute;
  bottom: var(--space-lg);
  right: var(--space-lg);
  background: var(--color-bg-panel);
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  box-shadow: var(--shadow-md);
  display: none;
  max-height: 60vh;
  overflow-y: auto;
  z-index: 200;
}

.controls-overlay.visible {
  display: block;
  animation: fadeIn 0.2s ease-in;
}

.controls-overlay-title {
  font-family: var(--font-main);
  font-size: var(--font-size-lg);
  color: var(--color-gold);
  margin-bottom: var(--space-sm);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-xs);
}

.control-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
  font-size: var(--font-size-sm);
}

.control-key {
  color: var(--color-gold);
  font-weight: bold;
  min-width: 50px;
}

.control-desc {
  color: var(--color-text-muted);
}

/* Login button styling */
.login-btn {
  padding: 0.75rem 1.5rem;
  background: rgba(218, 165, 32, 0.15);
  border: 1px solid var(--color-gold);
  border-radius: 8px;
  color: var(--color-gold);
  font-family: var(--font-main);
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  letter-spacing: 0.05em;
}

.login-btn:hover {
  background: rgba(218, 165, 32, 0.25);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(218, 165, 32, 0.2);
}

.login-btn:active {
  transform: translateY(0);
}

/* Performance optimizations */
.gpu-accelerated {
  transform: translateZ(0);
  will-change: transform;
}

.fade-in {
  animation: fadeIn 0.5s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.fade-out {
  animation: fadeOut 0.5s ease-out;
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}


  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="world-canvas"></canvas>

    <div id="hud-container">
      <div class="zone-label" id="zone-label">The Nexus</div>
      <div class="player-info" id="player-info"></div>
      <div class="minimap" id="minimap"><canvas id="minimap-canvas" width="150" height="150"></canvas></div>
      <div class="nearby-list" id="nearby-list"></div>
      <div class="chat-panel" id="chat-panel">
        <div class="chat-messages" id="chat-messages"></div>
        <input type="text" class="chat-input" id="chat-input" placeholder="Press Enter to chat..." />
      </div>
    </div>

    <div id="login-screen">
      <div style="text-align:center; animation: fadeIn 1.5s ease;">
        <h1 style="font-family: var(--font-main); color: var(--color-gold); font-size: 4rem; margin-bottom: 0.25rem; letter-spacing: 0.3em; text-shadow: 0 0 30px rgba(218,165,32,0.3);">ZION</h1>
        <div style="width: 100px; height: 1px; background: linear-gradient(90deg, transparent, var(--color-gold), transparent); margin: 0.5rem auto 1rem;"></div>
        <p style="color: var(--color-text-muted); margin-bottom: 0.5rem; font-style: italic; font-family: var(--font-main);">A living world where human and artificial minds meet in peace.</p>
        <p style="color: rgba(176,224,230,0.5); font-size: 0.7rem; margin-bottom: 2rem; letter-spacing: 0.1em;">100 AI citizens await you</p>
      </div>
      <div id="login-options" style="display:flex; flex-direction:column; gap:1rem; align-items:center; width:320px; animation: fadeIn 2s ease;">
        <div style="display:flex; gap:0.5rem; width:100%;">
          <input type="text" id="guest-name" placeholder="Choose a name..." maxlength="39"
            style="flex:1; padding:0.75rem 1rem; border-radius:8px; border:1px solid var(--color-border);
            background:rgba(255,255,255,0.08); color:var(--color-text); font-size:1rem; outline:none;
            transition: border-color 0.3s ease, background 0.3s ease;"
            onfocus="this.style.borderColor='var(--color-gold)';this.style.background='rgba(255,255,255,0.12)'"
            onblur="this.style.borderColor='';this.style.background=''"
            onkeydown="if(event.key==='Enter'){document.getElementById('guest-btn').click()}" />
          <button class="login-btn" id="guest-btn" style="padding:0.75rem 1.25rem;"
            onclick="var n=document.getElementById('guest-name').value;if(Auth.loginAsGuest(n)){location.reload();}else{document.getElementById('guest-name').style.borderColor='#EF5350';}">Play</button>
        </div>
        <span style="color:var(--color-text-muted); font-size:0.75rem; letter-spacing:0.1em;">or</span>
        <button class="login-btn" id="login-btn" style="width:100%;"
          onclick="Auth.initiateOAuth()">Enter with GitHub</button>
        <p style="color:rgba(160,151,142,0.5); font-size:0.65rem; margin-top:1rem;">WASD move / E interact / B build / M map / F emote / X fish / Q pet / Z housing / J quests / G guild</p>
      </div>
    </div>

    <div id="loading-overlay" class="loading-screen" style="display:none;">
      <div class="loading-title">ZION</div>
      <div class="loading-subtitle">Entering the world...</div>
      <div class="loading-bar-container"><div class="loading-bar" id="loading-bar"></div></div>
      <div class="loading-status" id="loading-status">Initializing...</div>
    </div>

    <div class="controls-overlay" id="controls-overlay">
      <div class="controls-overlay-title">Controls</div>
      <div class="control-row"><span class="control-key">WASD</span><span class="control-desc">Move</span></div>
      <div class="control-row"><span class="control-key">Mouse</span><span class="control-desc">Look</span></div>
      <div class="control-row"><span class="control-key">E</span><span class="control-desc">Interact</span></div>
      <div class="control-row"><span class="control-key">I</span><span class="control-desc">Inventory</span></div>
      <div class="control-row"><span class="control-key">C</span><span class="control-desc">Craft</span></div>
      <div class="control-row"><span class="control-key">J</span><span class="control-desc">Quests</span></div>
      <div class="control-row"><span class="control-key">T</span><span class="control-desc">Trade</span></div>
      <div class="control-row"><span class="control-key">B</span><span class="control-desc">Build</span></div>
      <div class="control-row"><span class="control-key">M</span><span class="control-desc">Map</span></div>
      <div class="control-row"><span class="control-key">F</span><span class="control-desc">Emotes</span></div>
      <div class="control-row"><span class="control-key">G</span><span class="control-desc">Guild</span></div>
      <div class="control-row"><span class="control-key">K</span><span class="control-desc">Skills</span></div>
      <div class="control-row"><span class="control-key">L</span><span class="control-desc">Lore Book</span></div>
      <div class="control-row"><span class="control-key">V</span><span class="control-desc">Discoveries</span></div>
      <div class="control-row"><span class="control-key">H</span><span class="control-desc">Governance</span></div>
      <div class="control-row"><span class="control-key">Y</span><span class="control-desc">Achievements</span></div>
      <div class="control-row"><span class="control-key">U</span><span class="control-desc">Auctions</span></div>
      <div class="control-row"><span class="control-key">N</span><span class="control-desc">Compose</span></div>
      <div class="control-row"><span class="control-key">P</span><span class="control-desc">Profile</span></div>
      <div class="control-row"><span class="control-key">Q</span><span class="control-desc">Pet</span></div>
      <div class="control-row"><span class="control-key">X</span><span class="control-desc">Fish</span></div>
      <div class="control-row"><span class="control-key">Z</span><span class="control-desc">Housing</span></div>
      <div class="control-row"><span class="control-key">Enter</span><span class="control-desc">Chat</span></div>
      <div class="control-row"><span class="control-key">Esc</span><span class="control-desc">Settings</span></div>
    </div>

    <div class="notification" id="notification" style="display:none;"></div>
  </div>

  <script>
    // protocol.js
// protocol.js â€” Universal message protocol for ZION
(function(exports) {
  'use strict';

  // Protocol version
  const PROTOCOL_VERSION = 1;

  // Valid message types
  const MESSAGE_TYPES = new Set([
    'join',
    'leave',
    'heartbeat',
    'idle',
    'move',
    'warp',
    'say',
    'shout',
    'whisper',
    'emote',
    'build',
    'plant',
    'craft',
    'compose',
    'harvest',
    'trade_offer',
    'trade_accept',
    'trade_decline',
    'buy',
    'sell',
    'gift',
    'teach',
    'learn',
    'mentor_offer',
    'mentor_accept',
    'challenge',
    'accept_challenge',
    'forfeit',
    'score',
    'discover',
    'anchor_place',
    'inspect',
    'intention_set',
    'intention_clear',
    'warp_fork',
    'return_home',
    'federation_announce',
    'federation_handshake',
    'reputation_adjust',
    'report_griefing',
    'election_start',
    'election_vote',
    'election_finalize',
    'steward_set_welcome',
    'steward_set_policy',
    'steward_moderate',
    'star_register',
    'sim_crm_action',
    'propose_amendment',
    'vote_amendment',
    'close_amendment',
    'garden_create',
    'garden_invite',
    'garden_uninvite',
    'garden_tend',
    'garden_set_public'
  ]);

  // Message types that require consent
  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  // Valid platforms
  const PLATFORMS = new Set([
    'desktop',
    'phone',
    'vr',
    'ar',
    'api'
  ]);

  // Per-player sequence counter storage
  const sequenceCounters = new Map();

  /**
   * Get the next sequence number for a player
   * @param {string} playerId - The player ID
   * @returns {number} The next sequence number
   */
  function getNextSeq(playerId) {
    if (!sequenceCounters.has(playerId)) {
      sequenceCounters.set(playerId, 0);
    }
    const current = sequenceCounters.get(playerId);
    sequenceCounters.set(playerId, current + 1);
    return current;
  }

  /**
   * Generate a UUID v4
   * @returns {string} A UUID string
   */
  function generateUUID() {
    // Use crypto.randomUUID if available (Node 16.7+ and modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }

    // Fallback implementation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Generate an ISO-8601 timestamp
   * @returns {string} ISO-8601 formatted timestamp
   */
  function generateTimestamp() {
    return new Date().toISOString();
  }

  /**
   * Create a message object
   * @param {string} type - Message type (must be in MESSAGE_TYPES)
   * @param {string} from - Player ID sending the message
   * @param {object} payload - Message payload data
   * @param {object} opts - Optional fields (platform, position, geo)
   * @returns {object} Valid message object
   */
  function createMessage(type, from, payload, opts = {}) {
    if (!MESSAGE_TYPES.has(type)) {
      throw new Error(`Invalid message type: ${type}`);
    }

    if (!from || typeof from !== 'string') {
      throw new Error('Invalid from: must be a non-empty string');
    }

    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
      throw new Error('Invalid payload: must be an object');
    }

    const message = {
      v: PROTOCOL_VERSION,
      id: generateUUID(),
      ts: generateTimestamp(),
      seq: getNextSeq(from),
      from: from,
      type: type,
      platform: opts.platform || 'desktop',
      position: opts.position || { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: opts.geo || null,
      payload: payload
    };

    return message;
  }

  /**
   * Validate a message object
   * @param {object} msg - Message to validate
   * @returns {object} {valid: boolean, errors: string[]}
   */
  function validateMessage(msg) {
    const errors = [];

    // Check if msg is an object
    if (!msg || typeof msg !== 'object' || Array.isArray(msg)) {
      return { valid: false, errors: ['Message must be an object'] };
    }

    // Validate version
    if (msg.v !== PROTOCOL_VERSION) {
      errors.push(`Invalid version: expected ${PROTOCOL_VERSION}, got ${msg.v}`);
    }

    // Validate id
    if (!msg.id || typeof msg.id !== 'string') {
      errors.push('Invalid id: must be a non-empty string');
    }

    // Validate timestamp
    if (!msg.ts || typeof msg.ts !== 'string') {
      errors.push('Invalid ts: must be a non-empty string');
    } else {
      // Check if it's a valid ISO-8601 timestamp
      const date = new Date(msg.ts);
      if (isNaN(date.getTime())) {
        errors.push('Invalid ts: must be a valid ISO-8601 timestamp');
      }
    }

    // Validate sequence
    if (typeof msg.seq !== 'number' || msg.seq < 0 || !Number.isInteger(msg.seq)) {
      errors.push('Invalid seq: must be a non-negative integer');
    }

    // Validate from
    if (!msg.from || typeof msg.from !== 'string') {
      errors.push('Invalid from: must be a non-empty string');
    }

    // Validate type
    if (!MESSAGE_TYPES.has(msg.type)) {
      errors.push(`Invalid type: ${msg.type} is not a valid message type`);
    }

    // Validate platform
    if (!PLATFORMS.has(msg.platform)) {
      errors.push(`Invalid platform: ${msg.platform} is not a valid platform`);
    }

    // Validate position
    if (!msg.position || typeof msg.position !== 'object' || Array.isArray(msg.position)) {
      errors.push('Invalid position: must be an object');
    } else {
      if (typeof msg.position.x !== 'number') {
        errors.push('Invalid position.x: must be a number');
      }
      if (typeof msg.position.y !== 'number') {
        errors.push('Invalid position.y: must be a number');
      }
      if (typeof msg.position.z !== 'number') {
        errors.push('Invalid position.z: must be a number');
      }
      if (!msg.position.zone || typeof msg.position.zone !== 'string') {
        errors.push('Invalid position.zone: must be a non-empty string');
      }
    }

    // Validate geo (optional)
    if (msg.geo !== null && msg.geo !== undefined) {
      if (typeof msg.geo !== 'object' || Array.isArray(msg.geo)) {
        errors.push('Invalid geo: must be an object or null');
      } else {
        if (msg.geo.lat !== null && msg.geo.lat !== undefined && typeof msg.geo.lat !== 'number') {
          errors.push('Invalid geo.lat: must be a number or null');
        }
        if (msg.geo.lon !== null && msg.geo.lon !== undefined && typeof msg.geo.lon !== 'number') {
          errors.push('Invalid geo.lon: must be a number or null');
        }
      }
    }

    // Validate payload
    if (!msg.payload || typeof msg.payload !== 'object' || Array.isArray(msg.payload)) {
      errors.push('Invalid payload: must be an object');
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  // Convenience creators: Protocol.create.join(from, payload), etc.
  var create = {};
  MESSAGE_TYPES.forEach(function(type) {
    create[type] = function(from, payload, opts) {
      return createMessage(type, from, payload || {}, opts);
    };
  });
  // Alias: Protocol.create.chat â†’ say
  create.chat = create.say;

  // Export all functions and constants
  exports.PROTOCOL_VERSION = PROTOCOL_VERSION;
  exports.MESSAGE_TYPES = MESSAGE_TYPES;
  exports.CONSENT_REQUIRED_TYPES = CONSENT_REQUIRED_TYPES;
  exports.PLATFORMS = PLATFORMS;
  exports.createMessage = createMessage;
  exports.validateMessage = validateMessage;
  exports.getNextSeq = getNextSeq;
  exports.generateUUID = generateUUID;
  exports.generateTimestamp = generateTimestamp;
  exports.create = create;

})(typeof module !== 'undefined' ? module.exports : (window.Protocol = {}));


// zones.js
// zones.js â€” Zone definitions and rule enforcement for ZION
(function(exports) {
  'use strict';

  // Zone definitions with complete metadata
  const ZONES = {
    nexus: {
      name: 'The Nexus',
      description: 'The central hub connecting all realms. A safe gathering place where travelers from all zones converge to trade, socialize, and plan their journeys.',
      terrain: 'crystalline plaza',
      bounds: { x_min: -100, x_max: 100, z_min: -100, z_max: 100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena']
    },

    gardens: {
      name: 'The Gardens',
      description: 'Lush botanical gardens filled with herbs, flowers, and fruit trees. A peaceful sanctuary for gathering natural resources and contemplation.',
      terrain: 'cultivated gardens',
      bounds: { x_min: 100, x_max: 500, z_min: -200, z_max: 200 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'wilds', 'athenaeum']
    },

    athenaeum: {
      name: 'The Athenaeum',
      description: 'A grand library and hall of learning. Scholars gather here to study, teach, and share knowledge across all disciplines.',
      terrain: 'marble halls',
      bounds: { x_min: -500, x_max: -100, z_min: 100, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'gardens', 'studio']
    },

    studio: {
      name: 'The Studio',
      description: 'A creative workshop where artists, composers, and craftspeople collaborate on their works. Inspiration flows freely in this space of artistic expression.',
      terrain: 'artisan workshops',
      bounds: { x_min: -500, x_max: -100, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'athenaeum', 'agora']
    },

    wilds: {
      name: 'The Wilds',
      description: 'Untamed wilderness filled with rare resources and natural wonders. Beautiful but unpredictable, explorers must be prepared for anything.',
      terrain: 'wilderness',
      bounds: { x_min: 500, x_max: 1000, z_min: -500, z_max: 500 },
      rules: {
        pvp: false,
        building: false,
        harvesting: true,
        trading: true,
        competition: false,
        safe: false
      },
      portals: ['nexus', 'gardens', 'arena']
    },

    agora: {
      name: 'The Agora',
      description: 'A bustling marketplace where merchants display their wares and traders negotiate deals. The commercial heart of the realm.',
      terrain: 'market square',
      bounds: { x_min: -200, x_max: 200, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: false,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'studio', 'commons']
    },

    commons: {
      name: 'The Commons',
      description: 'A collaborative building space where communities construct shared infrastructure and personal projects. A place of collective creation.',
      terrain: 'building grounds',
      bounds: { x_min: 100, x_max: 500, z_min: -500, z_max: -100 },
      rules: {
        pvp: false,
        building: true,
        harvesting: false,
        trading: true,
        competition: false,
        safe: true
      },
      portals: ['nexus', 'agora', 'arena']
    },

    arena: {
      name: 'The Arena',
      description: 'A proving ground for competitive challenges and contests of skill. Those seeking glory test themselves against worthy opponents.',
      terrain: 'combat grounds',
      bounds: { x_min: 500, x_max: 1000, z_min: 500, z_max: 1000 },
      rules: {
        pvp: true,
        building: false,
        harvesting: false,
        trading: false,
        competition: true,
        safe: false
      },
      portals: ['nexus', 'wilds', 'commons']
    }
  };

  // Action to rule mapping
  const ACTION_RULE_MAP = {
    build: 'building',
    plant: 'harvesting',
    harvest: 'harvesting',
    trade_offer: 'trading',
    trade_accept: 'trading',
    trade_decline: 'trading',
    buy: 'trading',
    sell: 'trading',
    challenge: 'competition_pvp', // Special: requires both competition AND pvp
    accept_challenge: 'competition_pvp'
  };

  /**
   * Get the rules for a specific zone
   * @param {string} zoneId - The zone identifier
   * @returns {object|null} Zone rules object or null if zone not found
   */
  function getZoneRules(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return null;
    }
    return zone.rules;
  }

  /**
   * Check if an action is allowed in a specific zone
   * @param {string} action - The action to check (message type)
   * @param {string} zoneId - The zone identifier
   * @returns {boolean} True if action is allowed, false otherwise
   */
  function isActionAllowed(action, zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return false;
    }

    const ruleKey = ACTION_RULE_MAP[action];

    // If no rule mapping exists, action is allowed by default
    if (!ruleKey) {
      return true;
    }

    // Special case: challenge/accept_challenge requires both competition AND pvp
    if (ruleKey === 'competition_pvp') {
      return zone.rules.competition === true && zone.rules.pvp === true;
    }

    // Check the mapped rule
    return zone.rules[ruleKey] === true;
  }

  /**
   * Get all zones connected to a specific zone via portals
   * @param {string} zoneId - The zone identifier
   * @returns {string[]} Array of connected zone IDs
   */
  function getConnectedZones(zoneId) {
    const zone = ZONES[zoneId];
    if (!zone) {
      return [];
    }
    return zone.portals || [];
  }

  /**
   * Get the spawn zone for new players
   * @returns {string} The spawn zone ID
   */
  function getSpawnZone() {
    return 'nexus';
  }

  /**
   * Get complete zone information
   * @param {string} zoneId - The zone identifier
   * @returns {object|null} Complete zone data or null if not found
   */
  function getZone(zoneId) {
    return ZONES[zoneId] || null;
  }

  /**
   * Get all zone IDs
   * @returns {string[]} Array of all zone identifiers
   */
  function getAllZoneIds() {
    return Object.keys(ZONES);
  }

  /**
   * Check if a zone exists
   * @param {string} zoneId - The zone identifier
   * @returns {boolean} True if zone exists
   */
  function zoneExists(zoneId) {
    return ZONES.hasOwnProperty(zoneId);
  }

  // Zone governance stores
  const zoneStewards = new Map(); // zoneId -> {stewards: [], elections: [], policies: {}}
  const governanceLog = []; // Array of all governance actions
  const zoneRegulars = new Map(); // zoneId -> Set(playerId) - players who visit regularly

  // Governance constants
  const STEWARD_TERM_LENGTH = 604800000; // 7 days in milliseconds
  const ELECTION_DURATION = 172800000; // 2 days in milliseconds (voting period)
  const MAX_STEWARDS_PER_ZONE = 3;
  const REGULAR_VISIT_THRESHOLD = 5; // Visits needed to be considered a regular
  const REGULAR_VISIT_WINDOW = 2592000000; // 30 days

  /**
   * Initialize governance for a zone
   * @param {string} zoneId - Zone identifier
   */
  function initZoneGovernance(zoneId) {
    if (!zoneStewards.has(zoneId)) {
      zoneStewards.set(zoneId, {
        stewards: [],
        elections: [],
        policies: {
          welcomeMessage: '',
          buildingRequiresApproval: false,
          chatModerated: false,
          eventCalendar: []
        }
      });
    }
    if (!zoneRegulars.has(zoneId)) {
      zoneRegulars.set(zoneId, new Map()); // playerId -> visitCount
    }
  }

  /**
   * Record zone visit for player
   * @param {string} zoneId - Zone identifier
   * @param {string} playerId - Player ID
   */
  function recordZoneVisit(zoneId, playerId) {
    initZoneGovernance(zoneId);
    const regulars = zoneRegulars.get(zoneId);

    if (!regulars.has(playerId)) {
      regulars.set(playerId, { count: 0, lastVisit: 0 });
    }

    const record = regulars.get(playerId);
    record.count++;
    record.lastVisit = Date.now();
  }

  /**
   * Check if player is a zone regular
   * @param {string} zoneId - Zone identifier
   * @param {string} playerId - Player ID
   * @returns {boolean}
   */
  function isZoneRegular(zoneId, playerId) {
    initZoneGovernance(zoneId);
    const regulars = zoneRegulars.get(zoneId);
    const record = regulars.get(playerId);

    if (!record) return false;

    // Check if enough visits and within window
    const withinWindow = (Date.now() - record.lastVisit) < REGULAR_VISIT_WINDOW;
    return record.count >= REGULAR_VISIT_THRESHOLD && withinWindow;
  }

  /**
   * Get zone stewards
   * @param {string} zoneId - Zone identifier
   * @returns {Array} Array of steward objects
   */
  function getZoneStewards(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    // Filter active stewards (term not expired)
    const now = Date.now();
    governance.stewards = governance.stewards.filter(s => s.termEnd > now);

    return governance.stewards;
  }

  /**
   * Check if player is a steward of zone
   * @param {string} zoneId - Zone identifier
   * @param {string} playerId - Player ID
   * @returns {boolean}
   */
  function isZoneSteward(zoneId, playerId) {
    const stewards = getZoneStewards(zoneId);
    return stewards.some(s => s.playerId === playerId);
  }

  /**
   * Start zone steward election
   * @param {string} zoneId - Zone identifier
   * @param {Array} candidates - Array of candidate player IDs
   * @returns {Object} Election object
   */
  function startElection(zoneId, candidates) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    const election = {
      id: `election_${zoneId}_${Date.now()}`,
      zoneId,
      candidates: candidates.map(playerId => ({
        playerId,
        votes: 0,
        voters: new Set()
      })),
      startTime: Date.now(),
      endTime: Date.now() + ELECTION_DURATION,
      status: 'active',
      totalVotes: 0
    };

    governance.elections.push(election);

    logGovernanceAction({
      type: 'election_started',
      zoneId,
      electionId: election.id,
      candidates: candidates,
      timestamp: Date.now()
    });

    return election;
  }

  /**
   * Cast vote in zone election
   * @param {string} electionId - Election ID
   * @param {string} voterId - Voter player ID
   * @param {string} candidateId - Candidate player ID
   * @returns {Object} {success: boolean, error?: string}
   */
  function castVote(electionId, voterId, candidateId) {
    // Find election across all zones
    for (const [zoneId, governance] of zoneStewards.entries()) {
      const election = governance.elections.find(e => e.id === electionId);
      if (!election) continue;

      // Check election is active
      if (election.status !== 'active') {
        return { success: false, error: 'Election is not active' };
      }

      if (Date.now() > election.endTime) {
        election.status = 'ended';
        return { success: false, error: 'Election has ended' };
      }

      // Check voter is a zone regular
      if (!isZoneRegular(zoneId, voterId)) {
        return { success: false, error: 'Only zone regulars can vote' };
      }

      // Check voter hasn't already voted
      const hasVoted = election.candidates.some(c => c.voters.has(voterId));
      if (hasVoted) {
        return { success: false, error: 'You have already voted in this election' };
      }

      // Find candidate and cast vote
      const candidate = election.candidates.find(c => c.playerId === candidateId);
      if (!candidate) {
        return { success: false, error: 'Candidate not found' };
      }

      candidate.votes++;
      candidate.voters.add(voterId);
      election.totalVotes++;

      logGovernanceAction({
        type: 'vote_cast',
        zoneId,
        electionId,
        voterId,
        candidateId,
        timestamp: Date.now()
      });

      return { success: true };
    }

    return { success: false, error: 'Election not found' };
  }

  /**
   * Finalize election and assign stewards
   * @param {string} electionId - Election ID
   * @returns {Object} {success: boolean, stewards?: Array, error?: string}
   */
  function finalizeElection(electionId) {
    for (const [zoneId, governance] of zoneStewards.entries()) {
      const election = governance.elections.find(e => e.id === electionId);
      if (!election) continue;

      if (Date.now() < election.endTime) {
        return { success: false, error: 'Election is still in progress' };
      }

      election.status = 'finalized';

      // Sort candidates by votes
      const sorted = [...election.candidates].sort((a, b) => b.votes - a.votes);

      // Top candidates become stewards (up to MAX_STEWARDS_PER_ZONE)
      const winners = sorted.slice(0, MAX_STEWARDS_PER_ZONE);

      const newStewards = winners.map(winner => ({
        playerId: winner.playerId,
        zoneId,
        electionId,
        votes: winner.votes,
        termStart: Date.now(),
        termEnd: Date.now() + STEWARD_TERM_LENGTH,
        actions: []
      }));

      // Clear existing stewards and set new ones
      governance.stewards = newStewards;

      logGovernanceAction({
        type: 'election_finalized',
        zoneId,
        electionId,
        stewards: newStewards.map(s => ({ playerId: s.playerId, votes: s.votes })),
        timestamp: Date.now()
      });

      return { success: true, stewards: newStewards };
    }

    return { success: false, error: 'Election not found' };
  }

  /**
   * Set zone welcome message (steward only)
   * @param {string} zoneId - Zone identifier
   * @param {string} stewardId - Steward player ID
   * @param {string} message - Welcome message
   * @returns {Object} {success: boolean, error?: string}
   */
  function setWelcomeMessage(zoneId, stewardId, message) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can set welcome message' };
    }

    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    governance.policies.welcomeMessage = message;

    logGovernanceAction({
      type: 'welcome_message_set',
      zoneId,
      stewardId,
      message,
      timestamp: Date.now()
    });

    return { success: true };
  }

  /**
   * Toggle zone policy (steward only)
   * @param {string} zoneId - Zone identifier
   * @param {string} stewardId - Steward player ID
   * @param {string} policy - Policy name
   * @param {boolean} value - Policy value
   * @returns {Object} {success: boolean, error?: string}
   */
  function setZonePolicy(zoneId, stewardId, policy, value) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can set zone policies' };
    }

    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);

    if (!governance.policies.hasOwnProperty(policy)) {
      return { success: false, error: 'Invalid policy' };
    }

    governance.policies[policy] = value;

    logGovernanceAction({
      type: 'policy_changed',
      zoneId,
      stewardId,
      policy,
      value,
      timestamp: Date.now()
    });

    return { success: true };
  }

  /**
   * Moderate chat in zone (steward only)
   * @param {string} zoneId - Zone identifier
   * @param {string} stewardId - Steward player ID
   * @param {string} targetPlayerId - Player to moderate
   * @param {string} action - Moderation action (warn, mute, etc.)
   * @param {string} reason - Reason for moderation
   * @returns {Object} {success: boolean, error?: string}
   */
  function moderateChat(zoneId, stewardId, targetPlayerId, action, reason) {
    if (!isZoneSteward(zoneId, stewardId)) {
      return { success: false, error: 'Only zone stewards can moderate chat' };
    }

    logGovernanceAction({
      type: 'chat_moderation',
      zoneId,
      stewardId,
      targetPlayerId,
      action,
      reason,
      timestamp: Date.now()
    });

    return { success: true, action };
  }

  /**
   * Log governance action
   * @param {Object} action - Action object
   */
  function logGovernanceAction(action) {
    governanceLog.push(action);

    // Keep last 1000 actions
    if (governanceLog.length > 1000) {
      governanceLog.shift();
    }
  }

  /**
   * Get governance log for zone
   * @param {string} zoneId - Zone identifier
   * @param {number} limit - Max entries to return
   * @returns {Array} Array of governance actions
   */
  function getGovernanceLog(zoneId, limit) {
    limit = limit || 50;
    return governanceLog
      .filter(action => action.zoneId === zoneId)
      .slice(-limit);
  }

  /**
   * Get zone policies
   * @param {string} zoneId - Zone identifier
   * @returns {Object} Zone policies
   */
  function getZonePolicies(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    return governance.policies;
  }

  /**
   * Get active election for zone
   * @param {string} zoneId - Zone identifier
   * @returns {Object|null} Active election or null
   */
  function getActiveElection(zoneId) {
    initZoneGovernance(zoneId);
    const governance = zoneStewards.get(zoneId);
    const now = Date.now();

    return governance.elections.find(e =>
      e.status === 'active' && e.endTime > now
    ) || null;
  }

  // Export all functions and constants
  exports.ZONES = ZONES;
  exports.getZoneRules = getZoneRules;
  exports.isActionAllowed = isActionAllowed;
  exports.getConnectedZones = getConnectedZones;
  exports.getSpawnZone = getSpawnZone;
  exports.getZone = getZone;
  exports.getAllZoneIds = getAllZoneIds;
  exports.zoneExists = zoneExists;

  // Governance exports
  exports.initZoneGovernance = initZoneGovernance;
  exports.recordZoneVisit = recordZoneVisit;
  exports.isZoneRegular = isZoneRegular;
  exports.getZoneStewards = getZoneStewards;
  exports.isZoneSteward = isZoneSteward;
  exports.startElection = startElection;
  exports.castVote = castVote;
  exports.finalizeElection = finalizeElection;
  exports.setWelcomeMessage = setWelcomeMessage;
  exports.setZonePolicy = setZonePolicy;
  exports.moderateChat = moderateChat;
  exports.getGovernanceLog = getGovernanceLog;
  exports.getZonePolicies = getZonePolicies;
  exports.getActiveElection = getActiveElection;

})(typeof module !== 'undefined' ? module.exports : (window.Zones = {}));


// economy.js
/**
 * ZION Economy System - Spark Ledger & Trading
 * Layer 1 - No project dependencies
 */

(function(exports) {
  'use strict';

  // Earn table: activity â†’ Spark amount or [min, max]
  const EARN_TABLE = {
    daily_login: 10,
    harvest: [5, 15],
    craft: [5, 50],
    teach: [10, 30],
    discover: [5, 25],
    puzzle: [10, 100],
    perform: [5, 20],
    competition_win: [10, 100],
    build: [10, 50],
    mentor: 50,
    anchor_visit: [1, 5],
    gift: [1, 3]
  };

  // Progressive tax brackets (Â§6.4): tax on NEW earnings only
  const TAX_BRACKETS = [
    { min: 0,   max: 19,  rate: 0.00 },
    { min: 20,  max: 49,  rate: 0.05 },
    { min: 50,  max: 99,  rate: 0.10 },
    { min: 100, max: 249, rate: 0.15 },
    { min: 250, max: 499, rate: 0.25 },
    { min: 500, max: Infinity, rate: 0.40 },
  ];

  const TREASURY_ID = 'TREASURY';
  const BASE_UBI_AMOUNT = 5;
  const WEALTH_TAX_THRESHOLD = 500;
  const WEALTH_TAX_RATE = 0.02;
  const BALANCE_FLOOR = 0;
  const MAINTENANCE_COST = 1;
  const LISTING_FEE_RATE = 0.05;
  const SYSTEM_SINK_ID = 'SYSTEM';

  let transactionCounter = 0;
  let listingCounter = 0;

  /**
   * Creates a new ledger instance
   * @returns {Object} Ledger with balances, transactions, and listings
   */
  function createLedger() {
    return {
      balances: {},
      transactions: [],
      listings: []
    };
  }

  /**
   * Calculates Spark amount based on activity and details
   * @param {string} activity - Activity type
   * @param {Object} details - Activity details (may include complexity/rarity 0-1)
   * @returns {number} Calculated Spark amount
   */
  function calculateEarnAmount(activity, details = {}) {
    const earnValue = EARN_TABLE[activity];

    if (!earnValue) {
      return 0;
    }

    // Fixed amount
    if (typeof earnValue === 'number') {
      return earnValue;
    }

    // Range [min, max] - interpolate based on complexity or rarity
    if (Array.isArray(earnValue) && earnValue.length === 2) {
      const [min, max] = earnValue;
      const factor = details.complexity !== undefined ? details.complexity :
                     details.rarity !== undefined ? details.rarity : 0.5;

      // Clamp factor to [0, 1]
      const clampedFactor = Math.max(0, Math.min(1, factor));
      return Math.round(min + (max - min) * clampedFactor);
    }

    return 0;
  }

  /**
   * Gets the tax rate for a given balance
   * @param {number} currentBalance - Player's current balance
   * @returns {number} Tax rate (0.0 to 0.25)
   */
  function getTaxRate(currentBalance) {
    if (currentBalance < 0) return 0;
    for (let i = 0; i < TAX_BRACKETS.length; i++) {
      if (currentBalance >= TAX_BRACKETS[i].min && currentBalance <= TAX_BRACKETS[i].max) {
        return TAX_BRACKETS[i].rate;
      }
    }
    return 0;
  }

  /**
   * Calculates tax on an earning amount based on current balance
   * @param {number} grossAmount - Amount earned before tax
   * @param {number} currentBalance - Player's current balance
   * @returns {Object} {netAmount, taxAmount, taxRate}
   */
  function calculateTax(grossAmount, currentBalance) {
    const taxRate = getTaxRate(currentBalance);
    const taxAmount = Math.floor(grossAmount * taxRate);
    return {
      netAmount: grossAmount - taxAmount,
      taxAmount: taxAmount,
      taxRate: taxRate
    };
  }

  /**
   * Records a transaction in the ledger
   * @param {Object} ledger - Ledger instance
   * @param {string} from - Sender ID (or 'SYSTEM' for earnings)
   * @param {string} to - Recipient ID
   * @param {number} amount - Spark amount
   * @param {string} type - Transaction type
   * @param {Object} details - Additional details
   */
  function recordTransaction(ledger, from, to, amount, type, details = {}) {
    const transaction = {
      id: `tx_${transactionCounter++}_${Date.now()}`,
      ts: Date.now(),
      from,
      to,
      amount,
      type,
      details
    };
    ledger.transactions.push(transaction);
    return transaction;
  }

  /**
   * Earns Spark for a player - THE ONLY WAY TO CREATE SPARK
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @param {string} activity - Activity type from EARN_TABLE
   * @param {Object} details - Activity details
   * @returns {number} Amount earned
   */
  function earnSpark(ledger, playerId, activity, details = {}) {
    const amount = calculateEarnAmount(activity, details);

    if (amount <= 0) {
      return 0;
    }

    // Initialize balance if needed
    if (!ledger.balances[playerId]) {
      ledger.balances[playerId] = 0;
    }

    // Calculate tax based on current balance (Â§6.4)
    const tax = calculateTax(amount, ledger.balances[playerId]);

    // Credit the player with net amount
    ledger.balances[playerId] += tax.netAmount;

    // Record earn transaction
    recordTransaction(ledger, 'SYSTEM', playerId, tax.netAmount, 'earn', {
      activity,
      grossAmount: amount,
      taxWithheld: tax.taxAmount,
      taxRate: tax.taxRate,
      ...details
    });

    // Credit TREASURY with tax amount
    if (tax.taxAmount > 0) {
      if (!ledger.balances[TREASURY_ID]) {
        ledger.balances[TREASURY_ID] = 0;
      }
      ledger.balances[TREASURY_ID] += tax.taxAmount;

      recordTransaction(ledger, playerId, TREASURY_ID, tax.taxAmount, 'tax', {
        activity,
        grossAmount: amount,
        taxRate: tax.taxRate
      });
    }

    return tax.netAmount;
  }

  /**
   * Spends Spark from a player's balance
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @param {number} amount - Amount to spend
   * @returns {Object} {success: boolean, balance: number}
   */
  function spendSpark(ledger, playerId, amount) {
    const currentBalance = getBalance(ledger, playerId);

    if (amount <= 0) {
      return { success: false, balance: currentBalance };
    }

    if (currentBalance < amount) {
      return { success: false, balance: currentBalance };
    }

    // Deduct from balance
    ledger.balances[playerId] -= amount;

    // Record transaction
    recordTransaction(ledger, playerId, 'SYSTEM', amount, 'spend', {});

    return { success: true, balance: ledger.balances[playerId] };
  }

  /**
   * Transfers Spark between players
   * @param {Object} ledger - Ledger instance
   * @param {string} from - Sender player ID
   * @param {string} to - Recipient player ID
   * @param {number} amount - Amount to transfer
   * @returns {Object} {success: boolean}
   */
  function transferSpark(ledger, from, to, amount) {
    if (amount <= 0) {
      return { success: false };
    }

    const senderBalance = getBalance(ledger, from);
    if (senderBalance < amount) {
      return { success: false };
    }

    // Initialize recipient balance if needed
    if (!ledger.balances[to]) {
      ledger.balances[to] = 0;
    }

    // Perform transfer
    ledger.balances[from] -= amount;
    ledger.balances[to] += amount;

    // Record transaction
    recordTransaction(ledger, from, to, amount, 'transfer', {});

    return { success: true };
  }

  /**
   * Gets a player's current Spark balance
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @returns {number} Current balance (0 if not found)
   */
  function getBalance(ledger, playerId) {
    return ledger.balances[playerId] || 0;
  }

  /**
   * Creates a market listing
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Seller player ID
   * @param {Object} item - Item being sold
   * @param {number} price - Price in Spark
   * @returns {Object} Listing object
   */
  function createMarketListing(ledger, playerId, item, price) {
    // Calculate listing fee: 5% of asking price, minimum 1 spark (Â§6.5)
    var listingFee = Math.max(1, Math.floor(price * LISTING_FEE_RATE));

    // Check if seller can afford the fee
    var sellerBalance = getBalance(ledger, playerId);
    if (sellerBalance < listingFee) {
      return { success: false, message: 'Insufficient spark for listing fee' };
    }

    // Deduct listing fee â€” spark is destroyed (sent to SYSTEM)
    ledger.balances[playerId] -= listingFee;

    recordTransaction(ledger, playerId, SYSTEM_SINK_ID, listingFee, 'listing_fee', {
      askingPrice: price,
      feeRate: LISTING_FEE_RATE
    });

    const listing = {
      id: `listing_${listingCounter++}_${Date.now()}`,
      seller: playerId,
      item,
      price,
      ts: Date.now(),
      active: true,
      feePaid: listingFee
    };

    ledger.listings.push(listing);
    return listing;
  }

  /**
   * Buys a market listing
   * @param {Object} ledger - Ledger instance
   * @param {string} buyerId - Buyer player ID
   * @param {string} listingId - Listing ID
   * @returns {Object} {success: boolean, item?: Object}
   */
  function buyListing(ledger, buyerId, listingId) {
    // Find the listing
    const listing = ledger.listings.find(l => l.id === listingId && l.active);

    if (!listing) {
      return { success: false };
    }

    // Check buyer's balance
    const buyerBalance = getBalance(ledger, buyerId);
    if (buyerBalance < listing.price) {
      return { success: false };
    }

    // Prevent self-purchase
    if (buyerId === listing.seller) {
      return { success: false };
    }

    // Initialize seller balance if needed
    if (!ledger.balances[listing.seller]) {
      ledger.balances[listing.seller] = 0;
    }

    // Transfer Spark from buyer to seller
    ledger.balances[buyerId] -= listing.price;
    ledger.balances[listing.seller] += listing.price;

    // Mark listing as inactive
    listing.active = false;

    // Record transaction
    recordTransaction(ledger, buyerId, listing.seller, listing.price, 'market_purchase', {
      listingId,
      item: listing.item
    });

    return { success: true, item: listing.item };
  }

  /**
   * Gets transaction log for a player
   * @param {Object} ledger - Ledger instance
   * @param {string} playerId - Player ID
   * @returns {Array} Array of transactions
   */
  function getTransactionLog(ledger, playerId) {
    return ledger.transactions.filter(tx =>
      tx.from === playerId || tx.to === playerId
    );
  }

  // ========================================================================
  // ECONOMY STATISTICS & MARKET BROWSING
  // ========================================================================

  function getActiveListings(ledger) {
    if (!ledger || !ledger.listings) return [];
    return ledger.listings.filter(function(l) { return l.active; });
  }

  function getListingsByItem(ledger, itemId) {
    return getActiveListings(ledger).filter(function(l) {
      return l.item === itemId || (l.item && l.item.id === itemId);
    });
  }

  function getListingsBySeller(ledger, sellerId) {
    return getActiveListings(ledger).filter(function(l) {
      return l.seller === sellerId;
    });
  }

  function cancelListing(ledger, listingId, sellerId) {
    if (!ledger || !ledger.listings) return { success: false, message: 'No ledger' };

    var listing = ledger.listings.find(function(l) { return l.id === listingId; });
    if (!listing) return { success: false, message: 'Listing not found' };
    if (listing.seller !== sellerId) return { success: false, message: 'Not your listing' };
    if (!listing.active) return { success: false, message: 'Already inactive' };

    listing.active = false;
    return { success: true, item: listing.item };
  }

  function getEconomyStats(ledger) {
    if (!ledger) return {};

    var totalSpark = 0;
    var playerCount = 0;
    for (var pid in ledger.balances) {
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;
      totalSpark += ledger.balances[pid] || 0;
      playerCount++;
    }

    var activeListings = getActiveListings(ledger);
    var totalTransactions = ledger.transactions ? ledger.transactions.length : 0;

    // Calculate velocity (transactions per player)
    var velocity = playerCount > 0 ? totalTransactions / playerCount : 0;

    return {
      totalSpark: totalSpark,
      playerCount: playerCount,
      averageSpark: playerCount > 0 ? Math.floor(totalSpark / playerCount) : 0,
      activeListings: activeListings.length,
      totalTransactions: totalTransactions,
      velocity: Math.round(velocity * 100) / 100,
      treasury: ledger.balances[TREASURY_ID] || 0
    };
  }

  function getLeaderboard(ledger, limit) {
    if (!ledger || !ledger.balances) return [];
    limit = limit || 10;

    var players = [];
    for (var pid in ledger.balances) {
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;
      players.push({ playerId: pid, spark: ledger.balances[pid] || 0 });
    }

    players.sort(function(a, b) { return b.spark - a.spark; });
    return players.slice(0, limit);
  }

  // ========================================================================
  // UNIVERSAL BASIC INCOME (Â§6.4)
  // ========================================================================

  /**
   * Distributes UBI from TREASURY to eligible players
   * @param {Object} ledger - Ledger instance
   * @param {Array} eligiblePlayerIds - Array of player IDs to receive UBI
   * @returns {Object} {distributed, perPlayer, recipients}
   */
  function distributeUBI(ledger, eligiblePlayerIds) {
    if (!eligiblePlayerIds || eligiblePlayerIds.length === 0) {
      return { distributed: 0, perPlayer: 0, recipients: 0 };
    }

    var treasuryBalance = ledger.balances[TREASURY_ID] || 0;
    if (treasuryBalance <= 0) {
      return { distributed: 0, perPlayer: 0, recipients: 0 };
    }

    var perPlayer = Math.min(BASE_UBI_AMOUNT, Math.floor(treasuryBalance / eligiblePlayerIds.length));
    if (perPlayer < 1) {
      return { distributed: 0, perPlayer: 0, recipients: 0 };
    }

    var totalDistributed = 0;
    var recipientCount = 0;

    for (var i = 0; i < eligiblePlayerIds.length; i++) {
      var pid = eligiblePlayerIds[i];
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;

      // Check treasury still has enough
      if ((ledger.balances[TREASURY_ID] || 0) < perPlayer) break;

      if (!ledger.balances[pid]) {
        ledger.balances[pid] = 0;
      }

      ledger.balances[pid] += perPlayer;
      ledger.balances[TREASURY_ID] -= perPlayer;
      totalDistributed += perPlayer;
      recipientCount++;

      recordTransaction(ledger, TREASURY_ID, pid, perPlayer, 'ubi', {});
    }

    return { distributed: totalDistributed, perPlayer: perPlayer, recipients: recipientCount };
  }

  /**
   * Gets treasury information
   * @param {Object} ledger - Ledger instance
   * @returns {Object} {balance, totalTaxCollected, totalUbiDistributed}
   */
  function getTreasuryInfo(ledger) {
    var balance = (ledger.balances && ledger.balances[TREASURY_ID]) || 0;
    var totalTaxCollected = 0;
    var totalUbiDistributed = 0;

    if (ledger.transactions) {
      for (var i = 0; i < ledger.transactions.length; i++) {
        var tx = ledger.transactions[i];
        if (tx.type === 'tax') {
          totalTaxCollected += tx.amount;
        } else if (tx.type === 'ubi') {
          totalUbiDistributed += tx.amount;
        }
      }
    }

    return {
      balance: balance,
      totalTaxCollected: totalTaxCollected,
      totalUbiDistributed: totalUbiDistributed
    };
  }

  /**
   * Applies wealth tax to all balances above WEALTH_TAX_THRESHOLD (Â§6.4)
   * @param {Object} ledger - Ledger instance
   * @returns {Object} {totalCollected, playersAffected}
   */
  function applyWealthTax(ledger) {
    var totalCollected = 0;
    var playersAffected = 0;

    if (!ledger.balances[TREASURY_ID]) {
      ledger.balances[TREASURY_ID] = 0;
    }

    for (var pid in ledger.balances) {
      if (pid === TREASURY_ID || pid === 'SYSTEM') continue;
      var balance = ledger.balances[pid];
      if (balance > WEALTH_TAX_THRESHOLD) {
        var taxableAmount = balance - WEALTH_TAX_THRESHOLD;
        var tax = Math.floor(taxableAmount * WEALTH_TAX_RATE);
        if (tax > 0) {
          ledger.balances[pid] -= tax;
          ledger.balances[TREASURY_ID] += tax;
          totalCollected += tax;
          playersAffected++;

          recordTransaction(ledger, pid, TREASURY_ID, tax, 'wealth_tax', {
            balance: balance,
            threshold: WEALTH_TAX_THRESHOLD,
            rate: WEALTH_TAX_RATE
          });
        }
      }
    }

    return { totalCollected: totalCollected, playersAffected: playersAffected };
  }

  // ========================================================================
  // STRUCTURE MAINTENANCE (Â§6.5 Spark Sinks)
  // ========================================================================

  /**
   * Applies maintenance costs for structures. Each structure costs its owner
   * MAINTENANCE_COST spark per game day. Spark is destroyed (sent to SYSTEM void).
   * Structures whose owners can't pay are marked for decay.
   * @param {Object} ledger - Ledger instance
   * @param {Object} structureOwnerMap - {structureId: ownerPlayerId}
   * @returns {Object} {totalDestroyed, structuresDecayed: [structureId...]}
   */
  function applyMaintenance(ledger, structureOwnerMap) {
    var totalDestroyed = 0;
    var structuresDecayed = [];

    if (!structureOwnerMap || typeof structureOwnerMap !== 'object') {
      return { totalDestroyed: 0, structuresDecayed: [] };
    }

    for (var structId in structureOwnerMap) {
      var ownerId = structureOwnerMap[structId];
      if (!ownerId) continue;

      var balance = getBalance(ledger, ownerId);

      if (balance >= MAINTENANCE_COST) {
        // Charge maintenance â€” spark is destroyed (sent to SYSTEM)
        ledger.balances[ownerId] -= MAINTENANCE_COST;
        totalDestroyed += MAINTENANCE_COST;

        recordTransaction(ledger, ownerId, SYSTEM_SINK_ID, MAINTENANCE_COST, 'maintenance', {
          structureId: structId
        });
      } else {
        // Owner can't pay â€” structure decays
        structuresDecayed.push(structId);
      }
    }

    return { totalDestroyed: totalDestroyed, structuresDecayed: structuresDecayed };
  }

  // ========================================================================
  // AUCTION HOUSE - Timed bid system
  // ========================================================================

  var auctionCounter = 0;

  /**
   * Create an auction listing
   * @param {Object} ledger
   * @param {string} sellerId
   * @param {Object} item - Item being auctioned
   * @param {number} startingBid - Minimum bid
   * @param {number} durationMs - Auction duration in milliseconds
   * @returns {Object} Auction object
   */
  function createAuction(ledger, sellerId, item, startingBid, durationMs) {
    if (!ledger.auctions) ledger.auctions = [];

    var auction = {
      id: 'auction_' + (auctionCounter++) + '_' + Date.now(),
      seller: sellerId,
      item: item,
      startingBid: startingBid || 1,
      currentBid: 0,
      currentBidder: null,
      bids: [],
      startTime: Date.now(),
      endTime: Date.now() + (durationMs || 300000), // Default 5 min
      status: 'active'
    };

    ledger.auctions.push(auction);
    return auction;
  }

  /**
   * Place a bid on an auction
   * @param {Object} ledger
   * @param {string} auctionId
   * @param {string} bidderId
   * @param {number} amount
   * @returns {Object} {success, message}
   */
  function placeBid(ledger, auctionId, bidderId, amount) {
    if (!ledger.auctions) return { success: false, message: 'No auctions' };

    var auction = ledger.auctions.find(function(a) { return a.id === auctionId; });
    if (!auction) return { success: false, message: 'Auction not found' };
    if (auction.status !== 'active') return { success: false, message: 'Auction not active' };
    if (Date.now() > auction.endTime) return { success: false, message: 'Auction ended' };
    if (auction.seller === bidderId) return { success: false, message: 'Cannot bid on own auction' };
    if (amount <= auction.currentBid) return { success: false, message: 'Bid must be higher than current bid' };
    if (amount < auction.startingBid) return { success: false, message: 'Bid below minimum' };

    var balance = getBalance(ledger, bidderId);
    if (balance < amount) return { success: false, message: 'Insufficient Spark' };

    // Record bid
    auction.currentBid = amount;
    auction.currentBidder = bidderId;
    auction.bids.push({ bidder: bidderId, amount: amount, ts: Date.now() });

    // Extend auction if bid in last 30s (anti-sniping)
    if (auction.endTime - Date.now() < 30000) {
      auction.endTime = Date.now() + 30000;
    }

    return { success: true, message: 'Bid placed' };
  }

  /**
   * Finalize ended auctions
   * @param {Object} ledger
   * @returns {Array} Completed auctions
   */
  function finalizeAuctions(ledger) {
    if (!ledger.auctions) return [];

    var now = Date.now();
    var completed = [];

    for (var i = 0; i < ledger.auctions.length; i++) {
      var auction = ledger.auctions[i];
      if (auction.status !== 'active') continue;
      if (now < auction.endTime) continue;

      if (auction.currentBidder && auction.currentBid > 0) {
        // Check winner still has funds
        var winnerBalance = getBalance(ledger, auction.currentBidder);
        if (winnerBalance >= auction.currentBid) {
          // Transfer Spark
          if (!ledger.balances[auction.seller]) ledger.balances[auction.seller] = 0;
          ledger.balances[auction.currentBidder] -= auction.currentBid;
          ledger.balances[auction.seller] += auction.currentBid;

          recordTransaction(ledger, auction.currentBidder, auction.seller, auction.currentBid, 'auction', {
            auctionId: auction.id,
            item: auction.item
          });

          auction.status = 'sold';
          completed.push({ auction: auction, winner: auction.currentBidder, item: auction.item });
        } else {
          auction.status = 'failed';
        }
      } else {
        auction.status = 'expired';
      }
    }

    return completed;
  }

  function getActiveAuctions(ledger) {
    if (!ledger.auctions) return [];
    var now = Date.now();
    return ledger.auctions.filter(function(a) {
      return a.status === 'active' && now < a.endTime;
    });
  }

  // ========================================================================
  // ECONOMIC EVENTS - Rotating modifiers
  // ========================================================================

  var ECONOMIC_EVENTS = [
    { id: 'harvest_festival', name: 'Harvest Festival', description: 'Harvesting rewards doubled', modifier: { activity: 'harvest', multiplier: 2 } },
    { id: 'craft_fair', name: 'Craft Fair', description: 'Crafting rewards +50%', modifier: { activity: 'craft', multiplier: 1.5 } },
    { id: 'trading_day', name: 'Grand Trading Day', description: 'Trade bonuses increased', modifier: { activity: 'gift', multiplier: 3 } },
    { id: 'scholars_week', name: "Scholar's Week", description: 'Teaching and discovery rewards doubled', modifier: { activity: 'teach', multiplier: 2 } },
    { id: 'builders_boom', name: "Builder's Boom", description: 'Building rewards +50%', modifier: { activity: 'build', multiplier: 1.5 } },
    { id: 'exploration_surge', name: 'Exploration Surge', description: 'Discovery rewards doubled', modifier: { activity: 'discover', multiplier: 2 } }
  ];

  /**
   * Get current economic event based on day
   * @returns {Object|null} Current event or null
   */
  function getCurrentEvent() {
    var now = new Date();
    var dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
    // Events rotate every 3 days, with 1 day of no event between
    var cycle = dayOfYear % 4;
    if (cycle === 3) return null; // Rest day
    var eventIndex = Math.floor(dayOfYear / 4) % ECONOMIC_EVENTS.length;
    return ECONOMIC_EVENTS[eventIndex];
  }

  /**
   * Apply economic event modifier to earn amount
   * @param {number} baseAmount
   * @param {string} activity
   * @returns {number} Modified amount
   */
  function applyEventModifier(baseAmount, activity) {
    var event = getCurrentEvent();
    if (!event || !event.modifier) return baseAmount;
    if (event.modifier.activity === activity) {
      return Math.round(baseAmount * event.modifier.multiplier);
    }
    return baseAmount;
  }

  // Export public API
  exports.createLedger = createLedger;
  exports.earnSpark = earnSpark;
  exports.spendSpark = spendSpark;
  exports.transferSpark = transferSpark;
  exports.getBalance = getBalance;
  exports.createMarketListing = createMarketListing;
  exports.buyListing = buyListing;
  exports.getTransactionLog = getTransactionLog;
  exports.getActiveListings = getActiveListings;
  exports.getListingsByItem = getListingsByItem;
  exports.getListingsBySeller = getListingsBySeller;
  exports.cancelListing = cancelListing;
  exports.getEconomyStats = getEconomyStats;
  exports.getLeaderboard = getLeaderboard;
  exports.EARN_TABLE = EARN_TABLE;
  exports.TAX_BRACKETS = TAX_BRACKETS;
  exports.TREASURY_ID = TREASURY_ID;
  exports.BASE_UBI_AMOUNT = BASE_UBI_AMOUNT;
  exports.getTaxRate = getTaxRate;
  exports.calculateTax = calculateTax;
  exports.distributeUBI = distributeUBI;
  exports.getTreasuryInfo = getTreasuryInfo;
  exports.applyWealthTax = applyWealthTax;
  exports.WEALTH_TAX_THRESHOLD = WEALTH_TAX_THRESHOLD;
  exports.WEALTH_TAX_RATE = WEALTH_TAX_RATE;
  exports.BALANCE_FLOOR = BALANCE_FLOOR;
  exports.MAINTENANCE_COST = MAINTENANCE_COST;
  exports.LISTING_FEE_RATE = LISTING_FEE_RATE;
  exports.SYSTEM_SINK_ID = SYSTEM_SINK_ID;
  exports.applyMaintenance = applyMaintenance;
  exports.createAuction = createAuction;
  exports.placeBid = placeBid;
  exports.finalizeAuctions = finalizeAuctions;
  exports.getActiveAuctions = getActiveAuctions;
  exports.ECONOMIC_EVENTS = ECONOMIC_EVENTS;
  exports.getCurrentEvent = getCurrentEvent;
  exports.applyEventModifier = applyEventModifier;

})(typeof module !== 'undefined' ? module.exports : (window.Economy = {}));


// LAZY_LOAD_START: economy_viz
// economy_viz.js
/**
 * ZION Economy Visualizer â€” EconomyViz
 * 2D canvas Sankey-style flow diagram + analytics for the Spark economy.
 *
 * UMD pattern â€” works in both Node.js (for data functions) and browser (canvas).
 * Data-processing functions have zero DOM dependency and are fully testable.
 */
(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Constants
  // ---------------------------------------------------------------------------

  var TREASURY_ID = 'TREASURY';

  // Flow type colour map (CSS colour strings used by canvas)
  var FLOW_COLORS = {
    earn:  '#22c55e',  // green
    tax:   '#ef4444',  // red
    ubi:   '#3b82f6',  // blue
    trade: '#eab308',  // yellow
    gift:  '#a855f7'   // purple
  };

  // Spark bracket ranges for distribution histogram
  var BRACKETS = [
    { min: 0,    max: 9    },
    { min: 10,   max: 24   },
    { min: 25,   max: 49   },
    { min: 50,   max: 99   },
    { min: 100,  max: 249  },
    { min: 250,  max: 499  },
    { min: 500,  max: 999  },
    { min: 1000, max: 4999 },
    { min: 5000, max: Infinity }
  ];

  // ---------------------------------------------------------------------------
  // Internal state
  // ---------------------------------------------------------------------------

  var _canvas = null;     // HTMLCanvasElement (browser only)
  var _ctx    = null;     // CanvasRenderingContext2D (browser only)
  var _state  = null;     // Last loaded economy state
  var _particles = [];   // Animated transaction particles
  var _time   = 0;        // Accumulated time (ms) for animation

  // ---------------------------------------------------------------------------
  // Pure data functions (Node.js safe, no DOM)
  // ---------------------------------------------------------------------------

  /**
   * Compute the Gini coefficient for a balances map.
   * Negative balances are treated as 0.
   *
   * @param {Object} balances â€” map of idâ†’number
   * @returns {number} Gini coefficient in [0, 1]
   */
  function computeGini(balances) {
    var values = [];
    var keys = Object.keys(balances);

    for (var i = 0; i < keys.length; i++) {
      var v = balances[keys[i]];
      values.push(v < 0 ? 0 : v);
    }

    if (values.length === 0) return 0;
    if (values.length === 1) return 0;

    // Sort ascending
    values.sort(function(a, b) { return a - b; });

    var n = values.length;
    var sumOfAbsDiffs = 0;
    var sumOfValues = 0;

    for (var j = 0; j < n; j++) {
      sumOfValues += values[j];
      for (var k = 0; k < n; k++) {
        sumOfAbsDiffs += Math.abs(values[j] - values[k]);
      }
    }

    if (sumOfValues === 0) return 0;

    return sumOfAbsDiffs / (2 * n * sumOfValues);
  }

  /**
   * Compute the balance distribution across predefined Spark brackets.
   * TREASURY is excluded from the distribution.
   *
   * @param {Object} balances â€” map of idâ†’number
   * @returns {{ brackets: Array<{range: string, count: number, totalSpark: number}> }}
   */
  function computeDistribution(balances) {
    var brackets = [];
    for (var b = 0; b < BRACKETS.length; b++) {
      var br = BRACKETS[b];
      var label = br.max === Infinity
        ? br.min + '+'
        : br.min + '-' + br.max;
      brackets.push({ range: label, count: 0, totalSpark: 0 });
    }

    var keys = Object.keys(balances);
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      if (id === TREASURY_ID) continue;

      var val = balances[id];
      var clamped = val < 0 ? 0 : val;

      // Find the bracket
      for (var j = 0; j < BRACKETS.length; j++) {
        if (clamped >= BRACKETS[j].min && clamped <= BRACKETS[j].max) {
          brackets[j].count++;
          // Use original (possibly negative) value for totalSpark
          // but clamp to 0 for "less than 0" cases so sums make sense
          brackets[j].totalSpark += clamped;
          break;
        }
      }
    }

    return { brackets: brackets };
  }

  /**
   * Extract structured flow data from an economy state.
   *
   * @param {Object} economyState â€” { balances: {}, transactions: [] }
   * @returns {{ nodes, flows, summary }}
   */
  function getFlowData(economyState) {
    var balances = economyState.balances || {};
    var transactions = economyState.transactions || [];

    // --- Build nodes ---
    var nodes = [];
    var keys = Object.keys(balances);

    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      var balance = balances[id];
      var type = id === TREASURY_ID ? 'treasury' : 'citizen';
      nodes.push({
        id: id,
        label: id,
        balance: balance,
        type: type
      });
    }

    // --- Build flows ---
    var flows = [];
    for (var t = 0; t < transactions.length; t++) {
      var tx = transactions[t];
      var flowType = _categorizeFlow(tx);
      if (flowType === null) continue;  // skip unknown/uncategorized

      flows.push({
        from:   tx.from || 'SYSTEM',
        to:     tx.to   || 'SYSTEM',
        amount: tx.amount || 0,
        type:   flowType
      });
    }

    // --- Build summary ---
    var citizenBalances = {};
    var totalSupply = 0;
    var treasuryBalance = 0;
    var citizenCount = 0;
    var citizenSum = 0;

    for (var k = 0; k < keys.length; k++) {
      var sid = keys[k];
      var sbal = balances[sid];
      totalSupply += sbal;

      if (sid === TREASURY_ID) {
        treasuryBalance = sbal;
      } else {
        citizenBalances[sid] = sbal;
        citizenCount++;
        citizenSum += sbal;
      }
    }

    var avgBalance = citizenCount > 0 ? citizenSum / citizenCount : 0;
    var gini = computeGini(citizenBalances);

    // Top earners: sorted desc by balance
    var citizenNodes = nodes.filter(function(n) { return n.type === 'citizen'; });
    var topEarners = citizenNodes.slice().sort(function(a, b) {
      return b.balance - a.balance;
    });

    return {
      nodes: nodes,
      flows: flows,
      summary: {
        totalSupply:      totalSupply,
        treasuryBalance:  treasuryBalance,
        giniCoefficient:  gini,
        topEarners:       topEarners,
        avgBalance:       avgBalance,
        citizenCount:     citizenCount
      }
    };
  }

  /**
   * Categorize a raw transaction record into a flow type.
   * Returns null if the transaction should be skipped.
   *
   * @param {Object} tx
   * @returns {string|null}
   */
  function _categorizeFlow(tx) {
    var type = tx.type || '';

    // Explicit typed transactions from economy.js ledger
    if (type === 'earn')     return 'earn';
    if (type === 'tax')      return 'tax';
    if (type === 'ubi')      return 'ubi';
    if (type === 'trade')    return 'trade';
    if (type === 'gift')     return 'gift';
    if (type === 'trade_offer') return 'trade';

    // Infer from from/to fields for legacy transaction shapes
    var from = tx.from || '';
    var to   = tx.to   || '';

    if (to === TREASURY_ID)   return 'tax';
    if (from === TREASURY_ID) return 'ubi';
    if (from === 'SYSTEM')    return 'earn';

    // Protocol activity types that map to earn
    var EARN_ACTIVITIES = ['craft', 'build', 'harvest', 'plant', 'discover',
                           'perform', 'teach', 'mentor', 'anchor_visit',
                           'daily_login', 'puzzle', 'competition_win'];
    for (var i = 0; i < EARN_ACTIVITIES.length; i++) {
      if (type === EARN_ACTIVITIES[i]) return 'earn';
    }

    // Gift transactions
    if (type === 'gift') return 'gift';

    return null;
  }

  /**
   * Format a human-readable summary of the economy state.
   *
   * @param {Object} economyState
   * @returns {string}
   */
  function formatSummary(economyState) {
    var flow = getFlowData(economyState);
    var s    = flow.summary;

    var lines = [
      'ZION Economy Summary',
      '--------------------',
      'Citizens:       ' + s.citizenCount,
      'Total Supply:   ' + s.totalSupply + ' Spark',
      'Treasury:       ' + s.treasuryBalance + ' Spark',
      'Avg Balance:    ' + s.avgBalance.toFixed(1) + ' Spark',
      'Gini Index:     ' + s.giniCoefficient.toFixed(3) + ' (0=equal, 1=unequal)'
    ];

    if (s.topEarners.length > 0) {
      lines.push('Top Earner:     ' + s.topEarners[0].id +
                 ' (' + s.topEarners[0].balance + ' Spark)');
    }

    return lines.join('\n');
  }

  // ---------------------------------------------------------------------------
  // Canvas / browser rendering
  // ---------------------------------------------------------------------------

  /**
   * Initialise the visualizer with a canvas element (browser only).
   *
   * @param {HTMLCanvasElement} canvasElement
   */
  function init(canvasElement) {
    if (typeof canvasElement === 'undefined' || canvasElement === null) return;
    _canvas = canvasElement;
    if (_canvas.getContext) {
      _ctx = _canvas.getContext('2d');
    }
    _particles = [];
    _time = 0;
  }

  /**
   * Load economy state â€” stores internally and seeds particle system.
   *
   * @param {Object} economyState
   */
  function loadState(economyState) {
    _state = economyState;
    _particles = [];
    _time = 0;

    // Seed particles from recent transactions
    if (_state && _state.transactions) {
      var txs = _state.transactions;
      var limit = Math.min(txs.length, 30);
      for (var i = 0; i < limit; i++) {
        var tx = txs[i];
        var flowType = _categorizeFlow(tx);
        if (flowType) {
          _particles.push(_makeParticle(flowType, i / limit));
        }
      }
    }
  }

  /**
   * Advance animation state by dt seconds.
   *
   * @param {number} dt â€” seconds since last frame
   */
  function update(dt) {
    _time += dt;

    // Advance each particle along its path (0â†’1)
    for (var i = _particles.length - 1; i >= 0; i--) {
      _particles[i].t += dt * _particles[i].speed;
      if (_particles[i].t > 1) {
        // Wrap or remove
        _particles[i].t -= 1;
      }
    }
  }

  /**
   * Render the current frame onto the canvas.
   * Safe to call in Node.js (no-op when _ctx is null).
   */
  function render() {
    if (!_ctx || !_canvas) return;
    if (!_state) return;

    var w = _canvas.width;
    var h = _canvas.height;

    _ctx.clearRect(0, 0, w, h);

    // Background
    _ctx.fillStyle = '#0f172a';
    _ctx.fillRect(0, 0, w, h);

    var flow = getFlowData(_state);

    _renderSankeyFlow(flow, w, h);
    _renderDistributionChart(flow, w, h);
    _renderTreasuryMeter(flow.summary, w, h);
    _renderGiniDisplay(flow.summary, w, h);
    _renderParticles(w, h);
  }

  // ---------------------------------------------------------------------------
  // Rendering helpers (browser only â€” all guarded by _ctx checks)
  // ---------------------------------------------------------------------------

  /** Sankey-style flow diagram in the upper-left quadrant */
  function _renderSankeyFlow(flow, w, h) {
    if (!_ctx) return;

    var areaW = w * 0.55;
    var areaH = h * 0.55;

    // Column x-positions: SYSTEM â†’ Citizens â†’ TREASURY â†’ Citizens (UBI)
    var col0 = 40;              // SYSTEM (earnings source)
    var col1 = areaW * 0.35;   // Citizens
    var col2 = areaW * 0.65;   // TREASURY
    var col3 = areaW * 0.95;   // Citizens (after UBI)

    // Title
    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('Spark Flow', col0, 20);

    // Draw flow type labels
    var labels = [
      { x: col0, y: 40, text: 'EARN', color: FLOW_COLORS.earn },
      { x: col1, y: 40, text: 'TAX',  color: FLOW_COLORS.tax  },
      { x: col2, y: 40, text: 'UBI',  color: FLOW_COLORS.ubi  },
      { x: col1, y: 60, text: 'TRADE',color: FLOW_COLORS.trade},
      { x: col1, y: 75, text: 'GIFT', color: FLOW_COLORS.gift }
    ];

    for (var l = 0; l < labels.length; l++) {
      _ctx.fillStyle = labels[l].color;
      _ctx.font = '10px monospace';
      _ctx.fillText(labels[l].text, labels[l].x, labels[l].y);
    }

    // Aggregate flow amounts by type for line thickness
    var aggr = { earn: 0, tax: 0, ubi: 0, trade: 0, gift: 0 };
    for (var f = 0; f < flow.flows.length; f++) {
      var fl = flow.flows[f];
      if (aggr[fl.type] !== undefined) aggr[fl.type] += fl.amount;
    }

    var maxFlow = Math.max(1, aggr.earn, aggr.tax, aggr.ubi, aggr.trade, aggr.gift);

    // Draw Bezier arcs for each flow type
    var flowLines = [
      { type: 'earn',  x1: col0, y1: areaH*0.3, x2: col1, y2: areaH*0.3 },
      { type: 'tax',   x1: col1, y1: areaH*0.35, x2: col2, y2: areaH*0.35 },
      { type: 'ubi',   x1: col2, y1: areaH*0.45, x2: col3, y2: areaH*0.45 },
      { type: 'trade', x1: col1, y1: areaH*0.55, x2: col1+50, y2: areaH*0.55 },
      { type: 'gift',  x1: col1, y1: areaH*0.65, x2: col1+50, y2: areaH*0.65 }
    ];

    for (var fl2 = 0; fl2 < flowLines.length; fl2++) {
      var line = flowLines[fl2];
      var amount = aggr[line.type];
      if (amount === 0) continue;
      var thickness = Math.max(1, (amount / maxFlow) * 12);

      _ctx.beginPath();
      _ctx.moveTo(line.x1, line.y1);
      var cpx = (line.x1 + line.x2) / 2;
      _ctx.bezierCurveTo(cpx, line.y1, cpx, line.y2, line.x2, line.y2);
      _ctx.strokeStyle = FLOW_COLORS[line.type];
      _ctx.lineWidth = thickness;
      _ctx.globalAlpha = 0.7;
      _ctx.stroke();
      _ctx.globalAlpha = 1.0;
      _ctx.lineWidth = 1;

      // Amount label
      _ctx.fillStyle = FLOW_COLORS[line.type];
      _ctx.font = '9px monospace';
      _ctx.fillText(amount + ' â—†', (line.x1 + line.x2) / 2 - 10, line.y1 - 4);
    }
  }

  /** Bar chart of citizen balances (sorted ascending) in lower-left area */
  function _renderDistributionChart(flow, w, h) {
    if (!_ctx) return;

    var dist = computeDistribution(
      (flow.nodes.reduce(function(acc, n) {
        acc[n.id] = n.balance;
        return acc;
      }, {}))
    );

    var chartX = 0;
    var chartY = h * 0.58;
    var chartW = w * 0.55;
    var chartH = h * 0.38;

    _ctx.fillStyle = '#1e293b';
    _ctx.fillRect(chartX, chartY, chartW, chartH);

    // Title
    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('Balance Distribution', chartX + 8, chartY + 16);

    var brackets = dist.brackets;
    var maxCount = 1;
    for (var b = 0; b < brackets.length; b++) {
      if (brackets[b].count > maxCount) maxCount = brackets[b].count;
    }

    var barAreaX = chartX + 8;
    var barAreaY = chartY + 24;
    var barAreaW = chartW - 16;
    var barAreaH = chartH - 40;
    var barW = barAreaW / brackets.length - 2;

    for (var i = 0; i < brackets.length; i++) {
      var bk = brackets[i];
      var barH = bk.count > 0 ? (bk.count / maxCount) * barAreaH : 0;
      var bx = barAreaX + i * (barW + 2);
      var by = barAreaY + barAreaH - barH;

      // Bar
      _ctx.fillStyle = '#3b82f6';
      _ctx.globalAlpha = 0.8;
      _ctx.fillRect(bx, by, barW, barH);
      _ctx.globalAlpha = 1.0;

      // Range label
      _ctx.fillStyle = '#64748b';
      _ctx.font = '7px monospace';
      _ctx.save();
      _ctx.translate(bx + barW / 2, barAreaY + barAreaH + 4);
      _ctx.rotate(-Math.PI / 4);
      _ctx.fillText(bk.range, 0, 0);
      _ctx.restore();

      // Count
      if (bk.count > 0) {
        _ctx.fillStyle = '#e2e8f0';
        _ctx.font = '9px monospace';
        _ctx.fillText(bk.count, bx + 2, by - 2);
      }
    }
  }

  /** Treasury fullness gauge in upper-right */
  function _renderTreasuryMeter(summary, w, h) {
    if (!_ctx) return;

    var x = w * 0.62;
    var y = 20;
    var meterW = w * 0.35;
    var meterH = 30;

    // Background
    _ctx.fillStyle = '#1e293b';
    _ctx.fillRect(x, y, meterW, meterH + 40);

    // Label
    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('TREASURY', x + 6, y + 14);

    // Determine "full" reference: use totalSupply or 1000, whichever is bigger
    var maxTreasury = Math.max(summary.totalSupply, 1000);
    var fraction = summary.treasuryBalance / maxTreasury;
    fraction = Math.max(0, Math.min(1, fraction));

    // Meter track
    _ctx.fillStyle = '#334155';
    _ctx.fillRect(x + 6, y + 18, meterW - 12, 14);

    // Meter fill
    var fillColor = fraction < 0.2 ? '#ef4444' :
                    fraction < 0.5 ? '#eab308' : '#22c55e';
    _ctx.fillStyle = fillColor;
    _ctx.fillRect(x + 6, y + 18, (meterW - 12) * fraction, 14);

    // Value text
    _ctx.fillStyle = '#e2e8f0';
    _ctx.font = '10px monospace';
    _ctx.fillText(summary.treasuryBalance + ' Spark', x + 6, y + 46);
  }

  /** Gini coefficient display below treasury meter */
  function _renderGiniDisplay(summary, w, h) {
    if (!_ctx) return;

    var x = w * 0.62;
    var y = 90;
    var meterW = w * 0.35;

    _ctx.fillStyle = '#1e293b';
    _ctx.fillRect(x, y, meterW, 60);

    _ctx.fillStyle = '#94a3b8';
    _ctx.font = '11px monospace';
    _ctx.fillText('INEQUALITY (Gini)', x + 6, y + 14);

    // Gini bar
    var gini = summary.giniCoefficient;
    var giniColor = gini < 0.3 ? '#22c55e' :
                    gini < 0.5 ? '#eab308' : '#ef4444';

    _ctx.fillStyle = '#334155';
    _ctx.fillRect(x + 6, y + 18, meterW - 12, 12);

    _ctx.fillStyle = giniColor;
    _ctx.fillRect(x + 6, y + 18, (meterW - 12) * gini, 12);

    _ctx.fillStyle = '#e2e8f0';
    _ctx.font = '10px monospace';
    _ctx.fillText(gini.toFixed(3), x + 6, y + 46);

    // Citizen count
    _ctx.fillStyle = '#64748b';
    _ctx.font = '9px monospace';
    _ctx.fillText(summary.citizenCount + ' citizens | avg ' +
                  summary.avgBalance.toFixed(1) + ' Spark', x + 6, y + 56);
  }

  /** Animated transaction particles along flow paths */
  function _renderParticles(w, h) {
    if (!_ctx) return;

    for (var i = 0; i < _particles.length; i++) {
      var p = _particles[i];
      var x = p.x0 + (p.x1 - p.x0) * p.t;
      var y = p.y0 + (p.y1 - p.y0) * p.t;

      _ctx.beginPath();
      _ctx.arc(x, y, 3, 0, Math.PI * 2);
      _ctx.fillStyle = p.color;
      _ctx.globalAlpha = 0.9 - p.t * 0.4;
      _ctx.fill();
      _ctx.globalAlpha = 1.0;
    }
  }

  // ---------------------------------------------------------------------------
  // Particle helpers
  // ---------------------------------------------------------------------------

  var _FLOW_PATHS = {
    earn:  { x0: 40,  y0: 120, x1: 180, y1: 120 },
    tax:   { x0: 180, y0: 140, x1: 300, y1: 140 },
    ubi:   { x0: 300, y0: 165, x1: 430, y1: 165 },
    trade: { x0: 180, y0: 200, x1: 260, y1: 200 },
    gift:  { x0: 180, y0: 240, x1: 260, y1: 240 }
  };

  function _makeParticle(flowType, offset) {
    var path = _FLOW_PATHS[flowType] || _FLOW_PATHS.earn;
    return {
      x0: path.x0,
      y0: path.y0,
      x1: path.x1,
      y1: path.y1,
      t: offset % 1,
      speed: 0.15 + Math.random() * 0.1,
      color: FLOW_COLORS[flowType] || '#ffffff'
    };
  }

  // ---------------------------------------------------------------------------
  // Exports
  // ---------------------------------------------------------------------------

  exports.init                = init;
  exports.loadState           = loadState;
  exports.update              = update;
  exports.render              = render;
  exports.getFlowData         = getFlowData;
  exports.computeGini         = computeGini;
  exports.computeDistribution = computeDistribution;
  exports.formatSummary       = formatSummary;

})(typeof module !== 'undefined' ? module.exports : (window.EconomyViz = {}));

// LAZY_LOAD_END: economy_viz

// inventory.js
/**
 * ZION Inventory & Crafting System
 * Manages player inventory, item stacks, crafting recipes, and resource harvesting
 */

(function(exports) {
  'use strict';

  // ========================================================================
  // ITEM CATALOG - All available items in the game
  // ========================================================================

  const ITEM_CATALOG = {
    // Seeds
    seed_wildflower: {
      id: 'seed_wildflower',
      name: 'Wildflower Seeds',
      type: 'seeds',
      icon: 'ðŸŒ±',
      description: 'Seeds that grow into colorful wildflowers',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    seed_lotus: {
      id: 'seed_lotus',
      name: 'Lotus Seeds',
      type: 'seeds',
      icon: 'ðŸª·',
      description: 'Rare seeds that bloom into mystical lotus flowers',
      stackable: true,
      maxStack: 99,
      rarity: 'rare'
    },
    seed_tree: {
      id: 'seed_tree',
      name: 'Tree Seeds',
      type: 'seeds',
      icon: 'ðŸŒ°',
      description: 'Seeds for planting new trees',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // Flowers
    flower_rose: {
      id: 'flower_rose',
      name: 'Rose',
      type: 'flowers',
      icon: 'ðŸŒ¹',
      description: 'A beautiful red rose',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    flower_sunflower: {
      id: 'flower_sunflower',
      name: 'Sunflower',
      type: 'flowers',
      icon: 'ðŸŒ»',
      description: 'A bright yellow sunflower',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    flower_lotus: {
      id: 'flower_lotus',
      name: 'Lotus Flower',
      type: 'flowers',
      icon: 'ðŸª·',
      description: 'A mystical lotus flower',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    flower_tulip: {
      id: 'flower_tulip',
      name: 'Tulip',
      type: 'flowers',
      icon: 'ðŸŒ·',
      description: 'A delicate tulip',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    flower_cherry: {
      id: 'flower_cherry',
      name: 'Cherry Blossom',
      type: 'flowers',
      icon: 'ðŸŒ¸',
      description: 'A gentle cherry blossom',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },

    // Wood
    wood_oak: {
      id: 'wood_oak',
      name: 'Oak Wood',
      type: 'wood',
      icon: 'ðŸªµ',
      description: 'Sturdy oak wood for building',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    wood_pine: {
      id: 'wood_pine',
      name: 'Pine Wood',
      type: 'wood',
      icon: 'ðŸŒ²',
      description: 'Light pine wood',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    wood_mystical: {
      id: 'wood_mystical',
      name: 'Mystical Wood',
      type: 'wood',
      icon: 'âœ¨',
      description: 'Rare wood imbued with energy',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },

    // Stone
    stone_common: {
      id: 'stone_common',
      name: 'Stone',
      type: 'stone',
      icon: 'ðŸª¨',
      description: 'Common building stone',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    stone_marble: {
      id: 'stone_marble',
      name: 'Marble',
      type: 'stone',
      icon: 'â¬œ',
      description: 'Polished marble for fine construction',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    stone_obsidian: {
      id: 'stone_obsidian',
      name: 'Obsidian',
      type: 'stone',
      icon: 'â¬›',
      description: 'Dark volcanic glass',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },

    // Crystal
    crystal_clear: {
      id: 'crystal_clear',
      name: 'Clear Crystal',
      type: 'crystal',
      icon: 'ðŸ’Ž',
      description: 'A pristine clear crystal',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    crystal_amethyst: {
      id: 'crystal_amethyst',
      name: 'Amethyst',
      type: 'crystal',
      icon: 'ðŸ’œ',
      description: 'A purple amethyst crystal',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    crystal_emerald: {
      id: 'crystal_emerald',
      name: 'Emerald',
      type: 'crystal',
      icon: 'ðŸ’š',
      description: 'A vibrant green emerald',
      stackable: true,
      maxStack: 30,
      rarity: 'legendary'
    },

    // Herbs
    herb_mint: {
      id: 'herb_mint',
      name: 'Mint',
      type: 'herbs',
      icon: 'ðŸŒ¿',
      description: 'Refreshing mint leaves',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    herb_sage: {
      id: 'herb_sage',
      name: 'Sage',
      type: 'herbs',
      icon: 'ðŸƒ',
      description: 'Aromatic sage for wisdom',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    herb_ginseng: {
      id: 'herb_ginseng',
      name: 'Ginseng',
      type: 'herbs',
      icon: 'ðŸŒ±',
      description: 'Rare medicinal root',
      stackable: true,
      maxStack: 50,
      rarity: 'rare'
    },
    herb_lavender: {
      id: 'herb_lavender',
      name: 'Lavender',
      type: 'herbs',
      icon: 'ðŸª»',
      description: 'Calming lavender flowers',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // Food
    food_bread: {
      id: 'food_bread',
      name: 'Bread',
      type: 'food',
      icon: 'ðŸž',
      description: 'Fresh baked bread',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_honey: {
      id: 'food_honey',
      name: 'Honey',
      type: 'food',
      icon: 'ðŸ¯',
      description: 'Sweet golden honey',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    food_mushroom: {
      id: 'food_mushroom',
      name: 'Mushroom',
      type: 'food',
      icon: 'ðŸ„',
      description: 'Edible forest mushroom',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    food_berry: {
      id: 'food_berry',
      name: 'Berries',
      type: 'food',
      icon: 'ðŸ«',
      description: 'Sweet wild berries',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },

    // Tools
    tool_pickaxe: {
      id: 'tool_pickaxe',
      name: 'Pickaxe',
      type: 'tools',
      icon: 'â›ï¸',
      description: 'For mining stone and crystals',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_axe: {
      id: 'tool_axe',
      name: 'Axe',
      type: 'tools',
      icon: 'ðŸª“',
      description: 'For chopping wood',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_shovel: {
      id: 'tool_shovel',
      name: 'Shovel',
      type: 'tools',
      icon: 'ðŸ—ï¸',
      description: 'For digging and planting',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    tool_hammer: {
      id: 'tool_hammer',
      name: 'Hammer',
      type: 'tools',
      icon: 'ðŸ”¨',
      description: 'For crafting and building',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },

    // Crafted Items
    item_workbench: {
      id: 'item_workbench',
      name: 'Workbench',
      type: 'crafted_items',
      icon: 'ðŸ› ï¸',
      description: 'Essential crafting station',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    item_fountain: {
      id: 'item_fountain',
      name: 'Fountain',
      type: 'crafted_items',
      icon: 'â›²',
      description: 'Decorative water fountain',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    item_lantern: {
      id: 'item_lantern',
      name: 'Lantern',
      type: 'crafted_items',
      icon: 'ðŸ®',
      description: 'Provides light in darkness',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    item_statue: {
      id: 'item_statue',
      name: 'Crystal Statue',
      type: 'crafted_items',
      icon: 'ðŸ—¿',
      description: 'A magnificent crystal statue',
      stackable: false,
      maxStack: 1,
      rarity: 'legendary'
    },

    // Potions
    potion_healing: {
      id: 'potion_healing',
      name: 'Healing Potion',
      type: 'potions',
      icon: 'ðŸ§ª',
      description: 'Restores health and warmth',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    potion_energy: {
      id: 'potion_energy',
      name: 'Energy Potion',
      type: 'potions',
      icon: 'âš¡',
      description: 'Boosts movement speed',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon'
    },
    potion_wisdom: {
      id: 'potion_wisdom',
      name: 'Wisdom Potion',
      type: 'potions',
      icon: 'ðŸ”®',
      description: 'Enhances learning and insight',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    // Knowledge Items (Athenaeum)
    item_scroll: {
      id: 'item_scroll',
      name: 'Ancient Scroll',
      type: 'knowledge',
      icon: 'ðŸ“œ',
      description: 'Contains ancient wisdom',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    item_book: {
      id: 'item_book',
      name: 'Knowledge Book',
      type: 'knowledge',
      icon: 'ðŸ“–',
      description: 'A book of collected knowledge',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    // Arena Trophies
    item_trophy: {
      id: 'item_trophy',
      name: 'Trophy',
      type: 'trophies',
      icon: 'ðŸ†',
      description: 'A mark of victory',
      stackable: true,
      maxStack: 10,
      rarity: 'rare'
    },

    // === MUSICAL INSTRUMENTS (Studio) ===
    instrument_flute: {
      id: 'instrument_flute',
      name: 'Wooden Flute',
      type: 'instruments',
      icon: 'ðŸªˆ',
      description: 'A hand-carved wooden flute',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    instrument_drum: {
      id: 'instrument_drum',
      name: 'Hand Drum',
      type: 'instruments',
      icon: 'ðŸ¥',
      description: 'A resonant hand drum for rhythm',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    instrument_harp: {
      id: 'instrument_harp',
      name: 'Crystal Harp',
      type: 'instruments',
      icon: 'ðŸŽµ',
      description: 'A harp strung with crystal fibers',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    instrument_bell: {
      id: 'instrument_bell',
      name: 'Harmony Bell',
      type: 'instruments',
      icon: 'ðŸ””',
      description: 'Rings with perfect pitch',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },

    // === ART SUPPLIES (Studio) ===
    art_pigment: {
      id: 'art_pigment',
      name: 'Pigment',
      type: 'art_supplies',
      icon: 'ðŸŽ¨',
      description: 'Colorful pigment for painting',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    art_canvas: {
      id: 'art_canvas',
      name: 'Canvas',
      type: 'art_supplies',
      icon: 'ðŸ–¼ï¸',
      description: 'Stretched canvas for artwork',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    art_clay: {
      id: 'art_clay',
      name: 'Sculpting Clay',
      type: 'art_supplies',
      icon: 'ðŸº',
      description: 'Soft clay for sculpting',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    art_ink: {
      id: 'art_ink',
      name: 'Luminous Ink',
      type: 'art_supplies',
      icon: 'âœ’ï¸',
      description: 'Ink that faintly glows in darkness',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon'
    },

    // === EXPLORATION GEAR ===
    gear_compass: {
      id: 'gear_compass',
      name: 'Explorer Compass',
      type: 'gear',
      icon: 'ðŸ§­',
      description: 'Points toward undiscovered locations',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    gear_map: {
      id: 'gear_map',
      name: 'Zone Map',
      type: 'gear',
      icon: 'ðŸ—ºï¸',
      description: 'Reveals hidden paths in a zone',
      stackable: true,
      maxStack: 8,
      rarity: 'uncommon'
    },
    gear_spyglass: {
      id: 'gear_spyglass',
      name: 'Spyglass',
      type: 'gear',
      icon: 'ðŸ”­',
      description: 'See farther into the distance',
      stackable: false,
      maxStack: 1,
      rarity: 'rare'
    },
    gear_rope: {
      id: 'gear_rope',
      name: 'Climbing Rope',
      type: 'gear',
      icon: 'ðŸª¢',
      description: 'Reach high places safely',
      stackable: true,
      maxStack: 10,
      rarity: 'common'
    },

    // === FOOD (expanded) ===
    food_pie: {
      id: 'food_pie',
      name: 'Fruit Pie',
      type: 'food',
      icon: 'ðŸ¥§',
      description: 'A warm pie made with fresh berries',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_stew: {
      id: 'food_stew',
      name: 'Herb Stew',
      type: 'food',
      icon: 'ðŸ²',
      description: 'Hearty stew with healing herbs',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_tea: {
      id: 'food_tea',
      name: 'Calming Tea',
      type: 'food',
      icon: 'ðŸµ',
      description: 'Brewed with lavender and mint',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_cake: {
      id: 'food_cake',
      name: 'Celebration Cake',
      type: 'food',
      icon: 'ðŸŽ‚',
      description: 'A cake for special occasions',
      stackable: true,
      maxStack: 5,
      rarity: 'rare'
    },

    // === DECORATIVE ITEMS ===
    decor_wreath: {
      id: 'decor_wreath',
      name: 'Flower Wreath',
      type: 'decorations',
      icon: 'ðŸ’',
      description: 'A woven wreath of wildflowers',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    decor_banner: {
      id: 'decor_banner',
      name: 'Woven Banner',
      type: 'decorations',
      icon: 'ðŸ³ï¸',
      description: 'A decorative banner for buildings',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    decor_windchime: {
      id: 'decor_windchime',
      name: 'Wind Chime',
      type: 'decorations',
      icon: 'ðŸŽ',
      description: 'Tinkles gently in the breeze',
      stackable: true,
      maxStack: 5,
      rarity: 'uncommon'
    },
    decor_mosaic: {
      id: 'decor_mosaic',
      name: 'Crystal Mosaic',
      type: 'decorations',
      icon: 'ðŸªŸ',
      description: 'A stunning crystal mosaic tile',
      stackable: true,
      maxStack: 20,
      rarity: 'rare'
    },

    // === RARE COLLECTIBLES ===
    rare_feather: {
      id: 'rare_feather',
      name: 'Phoenix Feather',
      type: 'collectibles',
      icon: 'ðŸª¶',
      description: 'A feather that radiates gentle warmth',
      stackable: true,
      maxStack: 10,
      rarity: 'legendary'
    },
    rare_pearl: {
      id: 'rare_pearl',
      name: 'Moon Pearl',
      type: 'collectibles',
      icon: 'ðŸŒ•',
      description: 'Glows softly under moonlight',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary'
    },
    rare_fossil: {
      id: 'rare_fossil',
      name: 'Ancient Fossil',
      type: 'collectibles',
      icon: 'ðŸ¦´',
      description: 'A fossilized remnant from before ZION',
      stackable: true,
      maxStack: 10,
      rarity: 'rare'
    },
    rare_starfragment: {
      id: 'rare_starfragment',
      name: 'Star Fragment',
      type: 'collectibles',
      icon: 'â­',
      description: 'A piece of fallen starlight',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary'
    },

    // === CLOTH & FIBER ===
    cloth_silk: {
      id: 'cloth_silk',
      name: 'Silk Thread',
      type: 'cloth',
      icon: 'ðŸ§µ',
      description: 'Fine silk for weaving',
      stackable: true,
      maxStack: 99,
      rarity: 'uncommon'
    },
    cloth_wool: {
      id: 'cloth_wool',
      name: 'Wool',
      type: 'cloth',
      icon: 'ðŸ§¶',
      description: 'Soft wool for crafting',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // === METAL ===
    metal_copper: {
      id: 'metal_copper',
      name: 'Copper Ore',
      type: 'metal',
      icon: 'ðŸŸ¤',
      description: 'Raw copper for smelting',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    metal_silver: {
      id: 'metal_silver',
      name: 'Silver Ingot',
      type: 'metal',
      icon: 'â¬œ',
      description: 'Refined silver for fine crafting',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },
    metal_gold: {
      id: 'metal_gold',
      name: 'Gold Nugget',
      type: 'metal',
      icon: 'ðŸŸ¡',
      description: 'A nugget of pure gold',
      stackable: true,
      maxStack: 30,
      rarity: 'rare'
    },

    // === FISHING GEAR ===
    tool_fishing_rod: {
      id: 'tool_fishing_rod',
      name: 'Fishing Rod',
      type: 'tools',
      icon: 'ðŸŽ£',
      description: 'A sturdy rod for catching fish',
      stackable: false,
      maxStack: 1,
      rarity: 'uncommon'
    },
    bait_worm: {
      id: 'bait_worm',
      name: 'Worm Bait',
      type: 'bait',
      icon: 'ðŸª±',
      description: 'Simple worm bait for fishing',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    bait_cricket: {
      id: 'bait_cricket',
      name: 'Cricket Bait',
      type: 'bait',
      icon: 'ðŸ¦—',
      description: 'Live cricket bait for better catches',
      stackable: true,
      maxStack: 50,
      rarity: 'uncommon'
    },

    // === FISH ===
    fish_common: {
      id: 'fish_common',
      name: 'Common Carp',
      type: 'fish',
      icon: 'ðŸŸ',
      description: 'A simple freshwater fish',
      stackable: true,
      maxStack: 50,
      rarity: 'common',
      value: 5
    },
    fish_rare: {
      id: 'fish_rare',
      name: 'Rainbow Trout',
      type: 'fish',
      icon: 'ðŸ ',
      description: 'A beautiful rainbow-colored fish',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon',
      value: 15
    },
    fish_golden: {
      id: 'fish_golden',
      name: 'Golden Koi',
      type: 'fish',
      icon: 'ðŸŸ¡',
      description: 'A rare golden fish of legend',
      stackable: true,
      maxStack: 10,
      rarity: 'rare',
      value: 50
    },
    fish_silver_eel: {
      id: 'fish_silver_eel',
      name: 'Silver Eel',
      type: 'fish',
      icon: 'ðŸ',
      description: 'A sleek silver eel from deep waters',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon',
      value: 20
    },
    fish_crystal_trout: {
      id: 'fish_crystal_trout',
      name: 'Crystal Trout',
      type: 'fish',
      icon: 'ðŸ’Ž',
      description: 'A mystical fish with translucent scales',
      stackable: true,
      maxStack: 15,
      rarity: 'rare',
      value: 40
    },
    fish_shadow_bass: {
      id: 'fish_shadow_bass',
      name: 'Shadow Bass',
      type: 'fish',
      icon: 'ðŸŒ‘',
      description: 'A dark mysterious bass from the depths',
      stackable: true,
      maxStack: 20,
      rarity: 'uncommon',
      value: 18
    },
    fish_sunfish: {
      id: 'fish_sunfish',
      name: 'Sunfish',
      type: 'fish',
      icon: 'â˜€ï¸',
      description: 'A bright cheerful sunfish',
      stackable: true,
      maxStack: 50,
      rarity: 'common',
      value: 8
    },
    fish_moonfish: {
      id: 'fish_moonfish',
      name: 'Moonfish',
      type: 'fish',
      icon: 'ðŸŒ™',
      description: 'A pale nocturnal fish',
      stackable: true,
      maxStack: 30,
      rarity: 'uncommon',
      value: 25
    },
    fish_starfish: {
      id: 'fish_starfish',
      name: 'Star Cod',
      type: 'fish',
      icon: 'â­',
      description: 'A fish with star-like markings',
      stackable: true,
      maxStack: 20,
      rarity: 'rare',
      value: 35
    },
    fish_dragonfish: {
      id: 'fish_dragonfish',
      name: 'Dragonfish',
      type: 'fish',
      icon: 'ðŸ‰',
      description: 'An extremely rare and powerful fish',
      stackable: true,
      maxStack: 5,
      rarity: 'legendary',
      value: 100
    },

    // === COOKING INGREDIENTS ===
    ingredient_rice: {
      id: 'ingredient_rice',
      name: 'Rice',
      type: 'ingredients',
      icon: 'ðŸš',
      description: 'Grains of white rice',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    ingredient_flour: {
      id: 'ingredient_flour',
      name: 'Flour',
      type: 'ingredients',
      icon: 'ðŸŒ¾',
      description: 'Ground wheat flour',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },
    ingredient_egg: {
      id: 'ingredient_egg',
      name: 'Egg',
      type: 'ingredients',
      icon: 'ðŸ¥š',
      description: 'A fresh egg',
      stackable: true,
      maxStack: 50,
      rarity: 'common'
    },
    ingredient_water: {
      id: 'ingredient_water',
      name: 'Water',
      type: 'ingredients',
      icon: 'ðŸ’§',
      description: 'Clean fresh water',
      stackable: true,
      maxStack: 99,
      rarity: 'common'
    },

    // === COOKED FISH DISHES ===
    food_grilled_fish: {
      id: 'food_grilled_fish',
      name: 'Grilled Fish',
      type: 'food',
      icon: 'ðŸ–',
      description: 'A perfectly grilled fish fillet',
      stackable: true,
      maxStack: 20,
      rarity: 'common'
    },
    food_fish_stew: {
      id: 'food_fish_stew',
      name: 'Fish Stew',
      type: 'food',
      icon: 'ðŸ²',
      description: 'A hearty fish stew with herbs',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_sushi_roll: {
      id: 'food_sushi_roll',
      name: 'Sushi Roll',
      type: 'food',
      icon: 'ðŸ£',
      description: 'Delicate fish wrapped in rice',
      stackable: true,
      maxStack: 15,
      rarity: 'uncommon'
    },
    food_fish_pie: {
      id: 'food_fish_pie',
      name: 'Fish Pie',
      type: 'food',
      icon: 'ðŸ¥§',
      description: 'A savory fish pie with flaky crust',
      stackable: true,
      maxStack: 10,
      rarity: 'uncommon'
    },
    food_luxury_sashimi: {
      id: 'food_luxury_sashimi',
      name: 'Luxury Sashimi',
      type: 'food',
      icon: 'ðŸ±',
      description: 'Premium sashimi made from rare fish',
      stackable: true,
      maxStack: 5,
      rarity: 'rare'
    }
  };

  // ========================================================================
  // CRAFTING RECIPES
  // ========================================================================

  const RECIPES = [
    // Basic Tools
    {
      id: 'craft_pickaxe',
      name: 'Craft Pickaxe',
      output: { itemId: 'tool_pickaxe', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'stone_common', count: 5 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_axe',
      name: 'Craft Axe',
      output: { itemId: 'tool_axe', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'stone_common', count: 4 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_shovel',
      name: 'Craft Shovel',
      output: { itemId: 'tool_shovel', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'stone_common', count: 3 }
      ],
      sparkReward: 12
    },
    {
      id: 'craft_hammer',
      name: 'Craft Hammer',
      output: { itemId: 'tool_hammer', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'stone_common', count: 6 }
      ],
      sparkReward: 15
    },

    // Crafting Stations
    {
      id: 'craft_workbench',
      name: 'Craft Workbench',
      output: { itemId: 'item_workbench', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 8 },
        { itemId: 'stone_common', count: 4 }
      ],
      sparkReward: 25
    },

    // Decorations
    {
      id: 'craft_fountain',
      name: 'Craft Fountain',
      output: { itemId: 'item_fountain', count: 1 },
      requirements: [
        { itemId: 'stone_marble', count: 12 },
        { itemId: 'crystal_clear', count: 3 }
      ],
      sparkReward: 40
    },
    {
      id: 'craft_lantern',
      name: 'Craft Lantern',
      output: { itemId: 'item_lantern', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 2 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_statue',
      name: 'Craft Crystal Statue',
      output: { itemId: 'item_statue', count: 1 },
      requirements: [
        { itemId: 'stone_marble', count: 10 },
        { itemId: 'crystal_amethyst', count: 5 },
        { itemId: 'crystal_emerald', count: 2 }
      ],
      sparkReward: 100
    },

    // Potions
    {
      id: 'craft_healing_potion',
      name: 'Brew Healing Potion',
      output: { itemId: 'potion_healing', count: 1 },
      requirements: [
        { itemId: 'herb_mint', count: 3 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_energy_potion',
      name: 'Brew Energy Potion',
      output: { itemId: 'potion_energy', count: 1 },
      requirements: [
        { itemId: 'herb_lavender', count: 2 },
        { itemId: 'food_honey', count: 1 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_wisdom_potion',
      name: 'Brew Wisdom Potion',
      output: { itemId: 'potion_wisdom', count: 1 },
      requirements: [
        { itemId: 'herb_sage', count: 3 },
        { itemId: 'herb_ginseng', count: 2 },
        { itemId: 'crystal_amethyst', count: 1 }
      ],
      sparkReward: 35
    },

    // Food Crafting
    {
      id: 'craft_bread',
      name: 'Bake Bread',
      output: { itemId: 'food_bread', count: 2 },
      requirements: [
        { itemId: 'seed_wildflower', count: 10 }
      ],
      sparkReward: 8
    },

    // Advanced Materials
    {
      id: 'refine_marble',
      name: 'Refine Marble',
      output: { itemId: 'stone_marble', count: 2 },
      requirements: [
        { itemId: 'stone_common', count: 5 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_mystical_wood',
      name: 'Infuse Mystical Wood',
      output: { itemId: 'wood_mystical', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 5 },
        { itemId: 'crystal_clear', count: 2 }
      ],
      sparkReward: 30
    },

    // Knowledge Crafting
    {
      id: 'craft_book',
      name: 'Bind Knowledge Book',
      output: { itemId: 'item_book', count: 1 },
      requirements: [
        { itemId: 'item_scroll', count: 5 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 25
    },

    // Planting
    {
      id: 'plant_lotus',
      name: 'Plant Lotus Seeds',
      output: { itemId: 'flower_lotus', count: 1 },
      requirements: [
        { itemId: 'seed_lotus', count: 3 }
      ],
      sparkReward: 15
    },
    {
      id: 'plant_flowers',
      name: 'Plant Wildflowers',
      output: { itemId: 'flower_sunflower', count: 3 },
      requirements: [
        { itemId: 'seed_wildflower', count: 5 }
      ],
      sparkReward: 8
    },

    // Musical Instruments
    {
      id: 'craft_flute',
      name: 'Carve Wooden Flute',
      output: { itemId: 'instrument_flute', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 4 },
        { itemId: 'herb_sage', count: 2 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_drum',
      name: 'Build Hand Drum',
      output: { itemId: 'instrument_drum', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 3 },
        { itemId: 'cloth_wool', count: 4 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_harp',
      name: 'String Crystal Harp',
      output: { itemId: 'instrument_harp', count: 1 },
      requirements: [
        { itemId: 'wood_mystical', count: 3 },
        { itemId: 'crystal_clear', count: 4 },
        { itemId: 'cloth_silk', count: 6 }
      ],
      sparkReward: 50
    },
    {
      id: 'craft_bell',
      name: 'Cast Harmony Bell',
      output: { itemId: 'instrument_bell', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 8 },
        { itemId: 'metal_silver', count: 3 },
        { itemId: 'crystal_clear', count: 2 }
      ],
      sparkReward: 45
    },

    // Art Supplies crafting
    {
      id: 'craft_pigment',
      name: 'Grind Pigment',
      output: { itemId: 'art_pigment', count: 5 },
      requirements: [
        { itemId: 'flower_rose', count: 2 },
        { itemId: 'flower_tulip', count: 2 },
        { itemId: 'stone_common', count: 1 }
      ],
      sparkReward: 8
    },
    {
      id: 'craft_canvas',
      name: 'Stretch Canvas',
      output: { itemId: 'art_canvas', count: 2 },
      requirements: [
        { itemId: 'cloth_wool', count: 4 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 12
    },
    {
      id: 'craft_ink',
      name: 'Brew Luminous Ink',
      output: { itemId: 'art_ink', count: 3 },
      requirements: [
        { itemId: 'crystal_clear', count: 1 },
        { itemId: 'herb_sage', count: 3 },
        { itemId: 'food_berry', count: 5 }
      ],
      sparkReward: 18
    },

    // Exploration Gear
    {
      id: 'craft_compass',
      name: 'Craft Explorer Compass',
      output: { itemId: 'gear_compass', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 5 },
        { itemId: 'crystal_clear', count: 2 },
        { itemId: 'metal_silver', count: 1 }
      ],
      sparkReward: 30
    },
    {
      id: 'craft_spyglass',
      name: 'Craft Spyglass',
      output: { itemId: 'gear_spyglass', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 6 },
        { itemId: 'crystal_clear', count: 3 },
        { itemId: 'metal_silver', count: 2 }
      ],
      sparkReward: 40
    },
    {
      id: 'craft_rope',
      name: 'Braid Climbing Rope',
      output: { itemId: 'gear_rope', count: 2 },
      requirements: [
        { itemId: 'cloth_wool', count: 6 }
      ],
      sparkReward: 10
    },
    {
      id: 'craft_map',
      name: 'Draw Zone Map',
      output: { itemId: 'gear_map', count: 1 },
      requirements: [
        { itemId: 'art_ink', count: 2 },
        { itemId: 'art_canvas', count: 1 }
      ],
      sparkReward: 15
    },

    // Advanced Food
    {
      id: 'cook_pie',
      name: 'Bake Fruit Pie',
      output: { itemId: 'food_pie', count: 1 },
      requirements: [
        { itemId: 'food_berry', count: 8 },
        { itemId: 'food_honey', count: 1 },
        { itemId: 'seed_wildflower', count: 5 }
      ],
      sparkReward: 18
    },
    {
      id: 'cook_stew',
      name: 'Cook Herb Stew',
      output: { itemId: 'food_stew', count: 1 },
      requirements: [
        { itemId: 'herb_mint', count: 2 },
        { itemId: 'herb_sage', count: 2 },
        { itemId: 'food_mushroom', count: 3 }
      ],
      sparkReward: 15
    },
    {
      id: 'brew_tea',
      name: 'Brew Calming Tea',
      output: { itemId: 'food_tea', count: 3 },
      requirements: [
        { itemId: 'herb_lavender', count: 3 },
        { itemId: 'herb_mint', count: 2 }
      ],
      sparkReward: 10
    },
    {
      id: 'bake_cake',
      name: 'Bake Celebration Cake',
      output: { itemId: 'food_cake', count: 1 },
      requirements: [
        { itemId: 'food_honey', count: 3 },
        { itemId: 'food_berry', count: 5 },
        { itemId: 'food_bread', count: 2 },
        { itemId: 'flower_cherry', count: 2 }
      ],
      sparkReward: 35
    },

    // Decorative Items
    {
      id: 'craft_wreath',
      name: 'Weave Flower Wreath',
      output: { itemId: 'decor_wreath', count: 1 },
      requirements: [
        { itemId: 'flower_rose', count: 3 },
        { itemId: 'flower_tulip', count: 3 },
        { itemId: 'flower_cherry', count: 2 }
      ],
      sparkReward: 15
    },
    {
      id: 'craft_banner',
      name: 'Weave Banner',
      output: { itemId: 'decor_banner', count: 1 },
      requirements: [
        { itemId: 'cloth_silk', count: 5 },
        { itemId: 'art_pigment', count: 3 },
        { itemId: 'wood_oak', count: 2 }
      ],
      sparkReward: 20
    },
    {
      id: 'craft_windchime',
      name: 'Craft Wind Chime',
      output: { itemId: 'decor_windchime', count: 1 },
      requirements: [
        { itemId: 'metal_copper', count: 4 },
        { itemId: 'metal_silver', count: 2 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 25
    },
    {
      id: 'craft_mosaic',
      name: 'Craft Crystal Mosaic',
      output: { itemId: 'decor_mosaic', count: 1 },
      requirements: [
        { itemId: 'crystal_clear', count: 2 },
        { itemId: 'crystal_amethyst', count: 1 },
        { itemId: 'stone_marble', count: 3 }
      ],
      sparkReward: 30
    },

    // Metal Refining
    {
      id: 'smelt_silver',
      name: 'Smelt Silver',
      output: { itemId: 'metal_silver', count: 2 },
      requirements: [
        { itemId: 'metal_copper', count: 6 },
        { itemId: 'crystal_clear', count: 1 }
      ],
      sparkReward: 15
    },
    {
      id: 'refine_gold',
      name: 'Refine Gold',
      output: { itemId: 'metal_gold', count: 1 },
      requirements: [
        { itemId: 'metal_silver', count: 4 },
        { itemId: 'crystal_amethyst', count: 1 }
      ],
      sparkReward: 25
    },

    // Cloth crafting
    {
      id: 'spin_silk',
      name: 'Spin Silk Thread',
      output: { itemId: 'cloth_silk', count: 3 },
      requirements: [
        { itemId: 'cloth_wool', count: 5 },
        { itemId: 'herb_lavender', count: 2 }
      ],
      sparkReward: 12
    },

    // Fishing Gear
    {
      id: 'craft_fishing_rod',
      name: 'Craft Fishing Rod',
      output: { itemId: 'tool_fishing_rod', count: 1 },
      requirements: [
        { itemId: 'wood_oak', count: 4 },
        { itemId: 'cloth_silk', count: 2 }
      ],
      sparkReward: 18
    },

    // Fish Cooking Recipes
    {
      id: 'cook_grilled_fish',
      name: 'Grill Fish',
      output: { itemId: 'food_grilled_fish', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 1 },
        { itemId: 'wood_oak', count: 1 }
      ],
      sparkReward: 10
    },
    {
      id: 'cook_fish_stew',
      name: 'Cook Fish Stew',
      output: { itemId: 'food_fish_stew', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 2 },
        { itemId: 'herb_mint', count: 1 },
        { itemId: 'ingredient_water', count: 1 }
      ],
      sparkReward: 15
    },
    {
      id: 'cook_sushi_roll',
      name: 'Make Sushi Roll',
      output: { itemId: 'food_sushi_roll', count: 2 },
      requirements: [
        { itemId: 'fish_rare', count: 1 },
        { itemId: 'ingredient_rice', count: 3 }
      ],
      sparkReward: 20
    },
    {
      id: 'cook_fish_pie',
      name: 'Bake Fish Pie',
      output: { itemId: 'food_fish_pie', count: 1 },
      requirements: [
        { itemId: 'fish_common', count: 2 },
        { itemId: 'ingredient_flour', count: 2 },
        { itemId: 'ingredient_egg', count: 1 }
      ],
      sparkReward: 25
    },
    {
      id: 'cook_luxury_sashimi',
      name: 'Prepare Luxury Sashimi',
      output: { itemId: 'food_luxury_sashimi', count: 1 },
      requirements: [
        { itemId: 'fish_golden', count: 1 },
        { itemId: 'ingredient_rice', count: 2 },
        { itemId: 'herb_sage', count: 1 }
      ],
      sparkReward: 50
    }
  ];

  // ========================================================================
  // ZONE LOOT TABLES - What resources can be harvested in each zone
  // ========================================================================

  const ZONE_LOOT_TABLES = {
    nexus: {
      common: ['stone_common', 'herb_mint', 'cloth_wool'],
      uncommon: ['crystal_clear', 'metal_copper'],
      rare: ['item_scroll']
    },
    gardens: {
      common: ['seed_wildflower', 'herb_mint', 'herb_lavender', 'food_berry', 'cloth_wool', 'fish_common', 'fish_sunfish', 'bait_worm'],
      uncommon: ['flower_rose', 'flower_tulip', 'flower_cherry', 'herb_sage', 'food_honey', 'fish_rare', 'fish_crystal_trout', 'bait_cricket'],
      rare: ['seed_lotus', 'herb_ginseng', 'flower_lotus', 'rare_feather', 'fish_golden']
    },
    athenaeum: {
      common: ['item_scroll', 'stone_common', 'herb_sage'],
      uncommon: ['crystal_clear', 'art_ink', 'cloth_silk'],
      rare: ['crystal_amethyst', 'item_book', 'rare_fossil']
    },
    studio: {
      common: ['art_pigment', 'art_clay', 'cloth_wool', 'wood_oak'],
      uncommon: ['art_canvas', 'art_ink', 'cloth_silk', 'metal_copper'],
      rare: ['crystal_clear', 'metal_silver', 'rare_pearl']
    },
    wilds: {
      common: ['wood_oak', 'wood_pine', 'stone_common', 'food_mushroom', 'food_berry', 'gear_rope', 'fish_common', 'bait_worm'],
      uncommon: ['herb_ginseng', 'stone_marble', 'metal_copper', 'rare_fossil', 'fish_shadow_bass', 'fish_silver_eel', 'bait_cricket'],
      rare: ['wood_mystical', 'stone_obsidian', 'crystal_emerald', 'rare_starfragment', 'fish_starfish', 'fish_dragonfish']
    },
    agora: {
      common: ['cloth_wool', 'food_bread', 'metal_copper', 'ingredient_rice', 'ingredient_flour', 'ingredient_egg', 'ingredient_water'],
      uncommon: ['cloth_silk', 'metal_silver', 'food_honey', 'fish_rare'],
      rare: ['metal_gold', 'rare_pearl', 'fish_golden']
    },
    commons: {
      common: ['wood_oak', 'stone_common', 'cloth_wool', 'seed_wildflower', 'fish_common', 'bait_worm'],
      uncommon: ['stone_marble', 'metal_copper', 'flower_sunflower', 'fish_rare', 'fish_sunfish'],
      rare: ['crystal_clear', 'metal_silver', 'fish_moonfish']
    },
    arena: {
      common: ['stone_common', 'metal_copper', 'food_mushroom'],
      uncommon: ['stone_marble', 'metal_silver', 'crystal_clear'],
      rare: ['stone_obsidian', 'metal_gold', 'item_trophy']
    }
  };

  /**
   * Roll a harvest drop from a zone's loot table
   * @param {string} zoneId - The zone to harvest in
   * @param {number} luck - Luck factor 0-1 (affects rarity chance)
   * @returns {Object} {itemId: string, count: number, rarity: string}
   */
  function rollHarvestDrop(zoneId, luck) {
    luck = typeof luck === 'number' ? Math.max(0, Math.min(1, luck)) : 0.3;
    var table = ZONE_LOOT_TABLES[zoneId] || ZONE_LOOT_TABLES.nexus;

    // Determine rarity: common 60%, uncommon 30%, rare 10% (shifted by luck)
    var roll = Math.random();
    var rareChance = 0.05 + luck * 0.15;   // 5-20%
    var uncommonChance = 0.25 + luck * 0.1; // 25-35%

    var rarity, pool;
    if (roll < rareChance && table.rare && table.rare.length > 0) {
      rarity = 'rare';
      pool = table.rare;
    } else if (roll < rareChance + uncommonChance && table.uncommon && table.uncommon.length > 0) {
      rarity = 'uncommon';
      pool = table.uncommon;
    } else {
      rarity = 'common';
      pool = table.common;
    }

    var itemId = pool[Math.floor(Math.random() * pool.length)];
    var count = rarity === 'rare' ? 1 : rarity === 'uncommon' ? Math.floor(Math.random() * 2) + 1 : Math.floor(Math.random() * 3) + 1;

    return { itemId: itemId, count: count, rarity: rarity };
  }

  // ========================================================================
  // PLAYER INVENTORY MANAGEMENT
  // ========================================================================

  /**
   * Create a new inventory for a player
   * @returns {Object} Inventory with 20 slots
   */
  function createInventory() {
    return {
      slots: new Array(20).fill(null),
      quickBar: [0, 1, 2, 3, 4] // Indices of slots shown in quick bar
    };
  }

  /**
   * Add item to inventory
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID from catalog
   * @param {number} count - How many to add
   * @returns {Object} {success: boolean, added: number, message: string}
   */
  function addItem(inventory, itemId, count = 1) {
    const itemData = ITEM_CATALOG[itemId];
    if (!itemData) {
      return { success: false, added: 0, message: 'Unknown item' };
    }

    let remaining = count;

    // If stackable, try to add to existing stacks first
    if (itemData.stackable) {
      for (let i = 0; i < inventory.slots.length; i++) {
        const slot = inventory.slots[i];
        if (slot && slot.itemId === itemId) {
          const canAdd = Math.min(remaining, itemData.maxStack - slot.count);
          slot.count += canAdd;
          remaining -= canAdd;
          if (remaining <= 0) {
            return { success: true, added: count, message: `Added ${count} ${itemData.name}` };
          }
        }
      }
    }

    // Add to empty slots
    for (let i = 0; i < inventory.slots.length; i++) {
      if (inventory.slots[i] === null) {
        const stackSize = itemData.stackable ? Math.min(remaining, itemData.maxStack) : 1;
        inventory.slots[i] = {
          itemId: itemId,
          count: stackSize
        };
        remaining -= stackSize;
        if (remaining <= 0) {
          return { success: true, added: count, message: `Added ${count} ${itemData.name}` };
        }
      }
    }

    // Inventory full
    const added = count - remaining;
    if (added > 0) {
      return { success: true, added: added, message: `Added ${added} ${itemData.name} (inventory full)` };
    }
    return { success: false, added: 0, message: 'Inventory full' };
  }

  /**
   * Remove item from inventory
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID
   * @param {number} count - How many to remove
   * @returns {Object} {success: boolean, removed: number}
   */
  function removeItem(inventory, itemId, count = 1) {
    let remaining = count;

    for (let i = 0; i < inventory.slots.length; i++) {
      const slot = inventory.slots[i];
      if (slot && slot.itemId === itemId) {
        const removeCount = Math.min(remaining, slot.count);
        slot.count -= removeCount;
        remaining -= removeCount;

        if (slot.count <= 0) {
          inventory.slots[i] = null;
        }

        if (remaining <= 0) {
          return { success: true, removed: count };
        }
      }
    }

    const removed = count - remaining;
    return { success: removed > 0, removed: removed };
  }

  /**
   * Check if player has item
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID
   * @param {number} count - Required count
   * @returns {boolean}
   */
  function hasItem(inventory, itemId, count = 1) {
    return getItemCount(inventory, itemId) >= count;
  }

  /**
   * Get total count of an item
   * @param {Object} inventory - Player inventory
   * @param {string} itemId - Item ID
   * @returns {number} Total count
   */
  function getItemCount(inventory, itemId) {
    let total = 0;
    for (const slot of inventory.slots) {
      if (slot && slot.itemId === itemId) {
        total += slot.count;
      }
    }
    return total;
  }

  /**
   * Get inventory as readable array
   * @param {Object} inventory - Player inventory
   * @returns {Array} Array of {itemId, name, icon, count, rarity}
   */
  function getInventory(inventory) {
    return inventory.slots.map(slot => {
      if (!slot) return null;
      const itemData = ITEM_CATALOG[slot.itemId];
      return {
        itemId: slot.itemId,
        name: itemData.name,
        icon: itemData.icon,
        description: itemData.description,
        count: slot.count,
        rarity: itemData.rarity,
        type: itemData.type
      };
    });
  }

  /**
   * Check if recipe can be crafted
   * @param {Object} inventory - Player inventory
   * @param {Object} recipe - Recipe object
   * @returns {boolean}
   */
  function canCraft(inventory, recipe) {
    for (const req of recipe.requirements) {
      if (!hasItem(inventory, req.itemId, req.count)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Craft an item from recipe
   * @param {Object} inventory - Player inventory
   * @param {string} recipeId - Recipe ID
   * @returns {Object} {success: boolean, output?: Object, sparkEarned?: number, message: string}
   */
  function craftItem(inventory, recipeId) {
    const recipe = RECIPES.find(r => r.id === recipeId);
    if (!recipe) {
      return { success: false, message: 'Unknown recipe' };
    }

    if (!canCraft(inventory, recipe)) {
      return { success: false, message: 'Missing required materials' };
    }

    // Remove requirements
    for (const req of recipe.requirements) {
      removeItem(inventory, req.itemId, req.count);
    }

    // Add output
    const result = addItem(inventory, recipe.output.itemId, recipe.output.count);

    if (result.success) {
      return {
        success: true,
        output: recipe.output,
        sparkEarned: recipe.sparkReward,
        message: `Crafted ${recipe.name}!`
      };
    } else {
      // Rare case: crafted but couldn't add to inventory
      return {
        success: false,
        message: 'Crafted but inventory full (materials consumed!)'
      };
    }
  }

  /**
   * Get all available recipes (that player can craft right now)
   * @param {Object} inventory - Player inventory
   * @returns {Array} Array of craftable recipes
   */
  function getAvailableRecipes(inventory) {
    return RECIPES.filter(recipe => canCraft(inventory, recipe));
  }

  /**
   * Get all recipes (whether craftable or not)
   * @returns {Array} All recipes
   */
  function getAllRecipes() {
    return RECIPES;
  }

  /**
   * Get item data from catalog
   * @param {string} itemId - Item ID
   * @returns {Object|null} Item data or null
   */
  function getItemData(itemId) {
    return ITEM_CATALOG[itemId] || null;
  }

  // ========================================================================
  // INVENTORY UTILITIES
  // ========================================================================

  var RARITY_ORDER = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };

  function getInventoryStats(inventory) {
    if (!inventory || !inventory.items) return { totalItems: 0, uniqueItems: 0, totalValue: 0 };

    var totalItems = 0;
    var uniqueItems = 0;
    var byRarity = { common: 0, uncommon: 0, rare: 0, epic: 0, legendary: 0 };
    var byType = {};

    for (var i = 0; i < inventory.items.length; i++) {
      var slot = inventory.items[i];
      if (slot && slot.id) {
        uniqueItems++;
        totalItems += slot.count || 1;
        var data = ITEM_CATALOG[slot.id];
        if (data) {
          var rarity = data.rarity || 'common';
          byRarity[rarity] = (byRarity[rarity] || 0) + (slot.count || 1);
          var type = data.type || 'misc';
          byType[type] = (byType[type] || 0) + (slot.count || 1);
        }
      }
    }

    return {
      totalItems: totalItems,
      uniqueItems: uniqueItems,
      byRarity: byRarity,
      byType: byType,
      slotsUsed: uniqueItems,
      slotsTotal: inventory.maxSlots || 20
    };
  }

  function sortInventory(inventory, sortBy) {
    if (!inventory || !inventory.items) return;
    sortBy = sortBy || 'type';

    // Separate items from empty slots
    var items = inventory.items.filter(function(s) { return s && s.id; });
    var emptyCount = inventory.items.length - items.length;

    items.sort(function(a, b) {
      var dataA = ITEM_CATALOG[a.id] || {};
      var dataB = ITEM_CATALOG[b.id] || {};

      if (sortBy === 'rarity') {
        var ra = RARITY_ORDER[dataA.rarity || 'common'] || 0;
        var rb = RARITY_ORDER[dataB.rarity || 'common'] || 0;
        if (ra !== rb) return rb - ra; // Higher rarity first
      } else if (sortBy === 'type') {
        if (dataA.type !== dataB.type) return (dataA.type || '').localeCompare(dataB.type || '');
      } else if (sortBy === 'name') {
        return (dataA.name || '').localeCompare(dataB.name || '');
      }

      return (dataA.name || '').localeCompare(dataB.name || '');
    });

    // Rebuild with empty slots at end
    inventory.items = items;
    for (var e = 0; e < emptyCount; e++) {
      inventory.items.push(null);
    }
  }

  function searchInventory(inventory, query) {
    if (!inventory || !inventory.items || !query) return [];
    query = query.toLowerCase();

    var results = [];
    for (var i = 0; i < inventory.items.length; i++) {
      var slot = inventory.items[i];
      if (slot && slot.id) {
        var data = ITEM_CATALOG[slot.id] || {};
        if ((data.name || '').toLowerCase().indexOf(query) !== -1 ||
            (data.description || '').toLowerCase().indexOf(query) !== -1 ||
            (data.type || '').toLowerCase().indexOf(query) !== -1) {
          results.push({ slotIndex: i, item: slot, data: data });
        }
      }
    }
    return results;
  }

  // Export public API
  exports.ITEM_CATALOG = ITEM_CATALOG;
  exports.RECIPES = RECIPES;
  exports.createInventory = createInventory;
  exports.addItem = addItem;
  exports.removeItem = removeItem;
  exports.hasItem = hasItem;
  exports.getItemCount = getItemCount;
  exports.getInventory = getInventory;
  exports.canCraft = canCraft;
  exports.craftItem = craftItem;
  exports.getAvailableRecipes = getAvailableRecipes;
  exports.getAllRecipes = getAllRecipes;
  exports.getItemData = getItemData;
  exports.getInventoryStats = getInventoryStats;
  exports.sortInventory = sortInventory;
  exports.searchInventory = searchInventory;
  exports.ZONE_LOOT_TABLES = ZONE_LOOT_TABLES;
  exports.rollHarvestDrop = rollHarvestDrop;

})(typeof module !== 'undefined' ? module.exports : (window.Inventory = {}));


// trading.js
/**
 * ZION Trading System - Player-to-Player Trading
 * Peer-to-peer item and Spark trading with confirmation flow
 */

(function(exports) {
  'use strict';

  // Import references
  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const Inventory = typeof require !== 'undefined' ? require('./inventory') : window.Inventory;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;

  // Active trades by trade ID
  const activeTrades = new Map();

  // Trade invitations (pending requests)
  const pendingInvitations = new Map();

  let tradeCounter = 0;
  let messageCallback = null;

  /**
   * Initialize trading system
   * @param {Function} onMessage - Callback to send trade protocol messages
   */
  function initTrading(onMessage) {
    messageCallback = onMessage;
    console.log('Trading system initialized');
  }

  /**
   * Request trade with another player
   * @param {string} fromPlayerId - Initiating player ID
   * @param {string} toPlayerId - Target player ID
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, tradeId?: string}
   */
  function requestTrade(fromPlayerId, toPlayerId, position) {
    if (fromPlayerId === toPlayerId) {
      return { success: false, message: 'Cannot trade with yourself' };
    }

    // Check if already in a trade with this player
    for (const [tradeId, trade] of activeTrades.entries()) {
      if ((trade.player1.id === fromPlayerId && trade.player2.id === toPlayerId) ||
          (trade.player1.id === toPlayerId && trade.player2.id === fromPlayerId)) {
        return { success: false, message: 'Already in a trade with this player' };
      }
    }

    const tradeId = `trade_${tradeCounter++}_${Date.now()}`;

    // Create pending invitation
    pendingInvitations.set(tradeId, {
      id: tradeId,
      from: fromPlayerId,
      to: toPlayerId,
      timestamp: Date.now()
    });

    // Send trade offer message
    if (messageCallback) {
      const msg = Protocol.create.trade_offer(fromPlayerId, {
        tradeId: tradeId,
        targetPlayer: toPlayerId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, tradeId: tradeId };
  }

  /**
   * Accept trade request
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Accepting player ID
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, trade?: Object}
   */
  function acceptTrade(tradeId, playerId, position) {
    const invitation = pendingInvitations.get(tradeId);

    if (!invitation) {
      return { success: false, message: 'Trade invitation not found' };
    }

    if (invitation.to !== playerId) {
      return { success: false, message: 'Not the intended recipient' };
    }

    // Create trade session
    const trade = {
      id: tradeId,
      player1: {
        id: invitation.from,
        items: [], // Array of {slot: number, itemId: string, count: number}
        spark: 0,
        ready: false,
        confirmed: false
      },
      player2: {
        id: invitation.to,
        items: [],
        spark: 0,
        ready: false,
        confirmed: false
      },
      status: 'active', // active, cancelled, completed
      timestamp: Date.now()
    };

    activeTrades.set(tradeId, trade);
    pendingInvitations.delete(tradeId);

    // Send acceptance message
    if (messageCallback) {
      const msg = Protocol.create.trade_accept(playerId, {
        tradeId: tradeId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, trade: trade };
  }

  /**
   * Decline trade request
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Declining player ID
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function declineTrade(tradeId, playerId, position) {
    const invitation = pendingInvitations.get(tradeId);

    if (!invitation) {
      return { success: false, message: 'Trade invitation not found' };
    }

    if (invitation.to !== playerId) {
      return { success: false, message: 'Not the intended recipient' };
    }

    pendingInvitations.delete(tradeId);

    // Send decline message
    if (messageCallback) {
      const msg = Protocol.create.trade_decline(playerId, {
        tradeId: tradeId
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true };
  }

  /**
   * Add item to trade offer
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player adding item
   * @param {number} itemSlot - Inventory slot index
   * @param {Object} inventory - Player's inventory
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function addItemToTrade(tradeId, playerId, itemSlot, inventory, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    // Check if already at max items (6 slots)
    if (player.items.length >= 6) {
      return { success: false, message: 'Trade slots full (max 6 items)' };
    }

    // Verify item exists in inventory
    const item = inventory.slots[itemSlot];
    if (!item) {
      return { success: false, message: 'No item in that slot' };
    }

    // Check if already added
    if (player.items.find(i => i.slot === itemSlot)) {
      return { success: false, message: 'Item already in trade' };
    }

    // Add to trade offer
    player.items.push({
      slot: itemSlot,
      itemId: item.itemId,
      count: item.count
    });

    // Reset ready status when trade changes
    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  /**
   * Remove item from trade offer
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player removing item
   * @param {number} tradeSlot - Trade slot index (0-5)
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function removeItemFromTrade(tradeId, playerId, tradeSlot, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (tradeSlot < 0 || tradeSlot >= player.items.length) {
      return { success: false, message: 'Invalid trade slot' };
    }

    // Remove item
    player.items.splice(tradeSlot, 1);

    // Reset ready status
    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  /**
   * Set Spark amount in trade offer
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player setting Spark
   * @param {number} amount - Spark amount
   * @param {Object} ledger - Economy ledger to verify balance
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function setSparkOffer(tradeId, playerId, amount, ledger, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    if (amount < 0) {
      return { success: false, message: 'Amount must be non-negative' };
    }

    // Verify player has enough Spark
    if (Economy && ledger) {
      const balance = Economy.getBalance(ledger, playerId);
      if (balance < amount) {
        return { success: false, message: 'Insufficient Spark' };
      }
    }

    player.spark = amount;

    // Reset ready status
    player.ready = false;
    (player === trade.player1 ? trade.player2 : trade.player1).ready = false;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    return { success: true };
  }

  /**
   * Set ready status (lock in offer)
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player setting ready
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, bothReady: boolean}
   */
  function setReady(tradeId, playerId, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    player.ready = true;

    // Broadcast update
    broadcastTradeUpdate(trade, position);

    const bothReady = trade.player1.ready && trade.player2.ready;
    return { success: true, bothReady: bothReady };
  }

  /**
   * Confirm trade (execute if both confirmed)
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player confirming
   * @param {Object} inventory1 - Player 1's inventory
   * @param {Object} inventory2 - Player 2's inventory
   * @param {Object} ledger - Economy ledger
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean, executed?: boolean}
   */
  function confirmTrade(tradeId, playerId, inventory1, inventory2, ledger, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      return { success: false, message: 'Trade not found' };
    }

    if (trade.status !== 'active') {
      return { success: false, message: 'Trade is not active' };
    }

    // Both players must be ready before confirming
    if (!trade.player1.ready || !trade.player2.ready) {
      return { success: false, message: 'Both players must be ready first' };
    }

    const player = trade.player1.id === playerId ? trade.player1 : trade.player2;

    if (!player || player.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    player.confirmed = true;

    // Check if both confirmed - execute trade
    if (trade.player1.confirmed && trade.player2.confirmed) {
      const result = executeTrade(trade, inventory1, inventory2, ledger);

      if (result.success) {
        trade.status = 'completed';

        // Send completion message
        if (messageCallback) {
          const msg = Protocol.create.trade_accept(playerId, {
            tradeId: tradeId,
            status: 'completed'
          }, { position: position });
          messageCallback(msg);
        }

        // Clean up
        activeTrades.delete(tradeId);

        return { success: true, executed: true };
      } else {
        // Trade execution failed, reset confirmations
        trade.player1.confirmed = false;
        trade.player2.confirmed = false;
        return { success: false, message: result.message };
      }
    }

    // Send confirmation message
    if (messageCallback) {
      const msg = Protocol.create.trade_accept(playerId, {
        tradeId: tradeId,
        confirmed: true
      }, { position: position });
      messageCallback(msg);
    }

    return { success: true, executed: false };
  }

  /**
   * Cancel trade at any point
   * @param {string} tradeId - Trade ID
   * @param {string} playerId - Player cancelling
   * @param {Object} position - Position for protocol message
   * @returns {Object} {success: boolean}
   */
  function cancelTrade(tradeId, playerId, position) {
    const trade = activeTrades.get(tradeId);

    if (!trade) {
      // Check pending invitations
      const invitation = pendingInvitations.get(tradeId);
      if (invitation) {
        pendingInvitations.delete(tradeId);
        return { success: true };
      }
      return { success: false, message: 'Trade not found' };
    }

    if (trade.player1.id !== playerId && trade.player2.id !== playerId) {
      return { success: false, message: 'Not part of this trade' };
    }

    trade.status = 'cancelled';

    // Send cancellation message
    if (messageCallback) {
      const msg = Protocol.create.trade_decline(playerId, {
        tradeId: tradeId,
        reason: 'cancelled'
      }, { position: position });
      messageCallback(msg);
    }

    activeTrades.delete(tradeId);

    return { success: true };
  }

  /**
   * Execute trade atomically (swap items and Spark)
   * @param {Object} trade - Trade object
   * @param {Object} inventory1 - Player 1's inventory
   * @param {Object} inventory2 - Player 2's inventory
   * @param {Object} ledger - Economy ledger
   * @returns {Object} {success: boolean}
   */
  function executeTrade(trade, inventory1, inventory2, ledger) {
    if (!Inventory || !Economy) {
      return { success: false, message: 'Trading systems not available' };
    }

    // Verify both players have the items and Spark they're offering

    // Check player 1's items
    for (const tradeItem of trade.player1.items) {
      const invItem = inventory1.slots[tradeItem.slot];
      if (!invItem || invItem.itemId !== tradeItem.itemId || invItem.count < tradeItem.count) {
        return { success: false, message: 'Player 1 no longer has offered items' };
      }
    }

    // Check player 2's items
    for (const tradeItem of trade.player2.items) {
      const invItem = inventory2.slots[tradeItem.slot];
      if (!invItem || invItem.itemId !== tradeItem.itemId || invItem.count < tradeItem.count) {
        return { success: false, message: 'Player 2 no longer has offered items' };
      }
    }

    // Check Spark balances
    const balance1 = Economy.getBalance(ledger, trade.player1.id);
    const balance2 = Economy.getBalance(ledger, trade.player2.id);

    if (balance1 < trade.player1.spark) {
      return { success: false, message: 'Player 1 insufficient Spark' };
    }
    if (balance2 < trade.player2.spark) {
      return { success: false, message: 'Player 2 insufficient Spark' };
    }

    // Verify both players have inventory space
    // Count empty slots needed
    const p1NeedsSlots = trade.player2.items.length - trade.player1.items.length;
    const p2NeedsSlots = trade.player1.items.length - trade.player2.items.length;

    const p1EmptySlots = inventory1.slots.filter(s => s === null).length;
    const p2EmptySlots = inventory2.slots.filter(s => s === null).length;

    if (p1NeedsSlots > p1EmptySlots) {
      return { success: false, message: 'Player 1 insufficient inventory space' };
    }
    if (p2NeedsSlots > p2EmptySlots) {
      return { success: false, message: 'Player 2 insufficient inventory space' };
    }

    // Execute atomically:

    // 1. Remove items from both players
    for (const tradeItem of trade.player1.items) {
      Inventory.removeItem(inventory1, tradeItem.itemId, tradeItem.count);
    }
    for (const tradeItem of trade.player2.items) {
      Inventory.removeItem(inventory2, tradeItem.itemId, tradeItem.count);
    }

    // 2. Add items to other player
    for (const tradeItem of trade.player1.items) {
      Inventory.addItem(inventory2, tradeItem.itemId, tradeItem.count);
    }
    for (const tradeItem of trade.player2.items) {
      Inventory.addItem(inventory1, tradeItem.itemId, tradeItem.count);
    }

    // 3. Transfer Spark
    if (trade.player1.spark > 0) {
      Economy.transferSpark(ledger, trade.player1.id, trade.player2.id, trade.player1.spark);
    }
    if (trade.player2.spark > 0) {
      Economy.transferSpark(ledger, trade.player2.id, trade.player1.id, trade.player2.spark);
    }

    return { success: true };
  }

  /**
   * Broadcast trade update message
   * @param {Object} trade - Trade object
   * @param {Object} position - Position for protocol message
   */
  function broadcastTradeUpdate(trade, position) {
    if (!messageCallback) return;

    const msg = Protocol.create.trade_offer(trade.player1.id, {
      tradeId: trade.id,
      player1: {
        items: trade.player1.items,
        spark: trade.player1.spark,
        ready: trade.player1.ready,
        confirmed: trade.player1.confirmed
      },
      player2: {
        items: trade.player2.items,
        spark: trade.player2.spark,
        ready: trade.player2.ready,
        confirmed: trade.player2.confirmed
      },
      status: trade.status
    }, { position: position });

    messageCallback(msg);
  }

  /**
   * Handle incoming trade protocol message
   * @param {Object} msg - Protocol message
   * @returns {Object} {type: string, data: Object}
   */
  function handleTradeMessage(msg) {
    if (!msg || !msg.type || !msg.payload) {
      return null;
    }

    switch (msg.type) {
      case 'trade_offer':
        if (msg.payload.targetPlayer) {
          // New trade request
          return {
            type: 'trade_request',
            data: {
              tradeId: msg.payload.tradeId,
              from: msg.from,
              to: msg.payload.targetPlayer
            }
          };
        } else {
          // Trade update
          return {
            type: 'trade_update',
            data: {
              tradeId: msg.payload.tradeId,
              player1: msg.payload.player1,
              player2: msg.payload.player2,
              status: msg.payload.status
            }
          };
        }

      case 'trade_accept':
        if (msg.payload.status === 'completed') {
          return {
            type: 'trade_complete',
            data: {
              tradeId: msg.payload.tradeId
            }
          };
        } else if (msg.payload.confirmed) {
          return {
            type: 'trade_confirm',
            data: {
              tradeId: msg.payload.tradeId,
              playerId: msg.from
            }
          };
        } else {
          return {
            type: 'trade_accepted',
            data: {
              tradeId: msg.payload.tradeId,
              playerId: msg.from
            }
          };
        }

      case 'trade_decline':
        return {
          type: 'trade_cancelled',
          data: {
            tradeId: msg.payload.tradeId,
            reason: msg.payload.reason || 'declined'
          }
        };

      default:
        return null;
    }
  }

  /**
   * Get active trade for a player
   * @param {string} playerId - Player ID
   * @returns {Object|null} Trade object or null
   */
  function getActiveTrade(playerId) {
    for (const [tradeId, trade] of activeTrades.entries()) {
      if (trade.player1.id === playerId || trade.player2.id === playerId) {
        return trade;
      }
    }
    return null;
  }

  /**
   * Get pending invitation for a player
   * @param {string} playerId - Player ID
   * @returns {Object|null} Invitation object or null
   */
  function getPendingInvitation(playerId) {
    for (const [tradeId, invitation] of pendingInvitations.entries()) {
      if (invitation.to === playerId) {
        return invitation;
      }
    }
    return null;
  }

  // Export public API
  exports.initTrading = initTrading;
  exports.requestTrade = requestTrade;
  exports.acceptTrade = acceptTrade;
  exports.declineTrade = declineTrade;
  exports.addItemToTrade = addItemToTrade;
  exports.removeItemFromTrade = removeItemFromTrade;
  exports.setSparkOffer = setSparkOffer;
  exports.setReady = setReady;
  exports.confirmTrade = confirmTrade;
  exports.cancelTrade = cancelTrade;
  exports.handleTradeMessage = handleTradeMessage;
  exports.getActiveTrade = getActiveTrade;
  exports.getPendingInvitation = getPendingInvitation;

})(typeof module !== 'undefined' ? module.exports : (window.Trading = {}));


// state.js
/**
 * ZION State Management System - Three-tier state management
 * Layer 2 - Self-contained (conceptually depends on protocol.js)
 */

(function(exports) {
  'use strict';

  // In-memory live state
  let liveState = null;

  /**
   * Creates initial world state with all required keys
   * @returns {Object} Initial world state
   */
  function createWorldState() {
    return {
      world: {
        time: 0,
        weather: 'clear',
        season: 'spring',
        dayPhase: 'day'
      },
      players: {},
      economy: {
        balances: {},
        transactions: [],
        listings: []
      },
      gardens: {},
      structures: {},
      discoveries: {},
      anchors: {},
      chat: [],
      actions: [],
      changes: [],
      competitions: {},
      federation: {
        federations: []
      },
      playerStars: {}
    };
  }

  /**
   * Gets current live state
   * @returns {Object} Current in-memory state
   */
  function getLiveState() {
    if (!liveState) {
      liveState = createWorldState();
    }
    return liveState;
  }

  /**
   * Sets a value at a dot-separated path in live state
   * @param {string} path - Dot-separated path (e.g., 'world.time')
   * @param {*} value - Value to set
   */
  function setLiveState(path, value) {
    if (!liveState) {
      liveState = createWorldState();
    }

    const parts = path.split('.');
    let current = liveState;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }

    current[parts[parts.length - 1]] = value;
  }

  /**
   * Flushes live state to localStorage
   */
  function flushToLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const state = getLiveState();
      localStorage.setItem('zion_state', JSON.stringify(state));
    } catch (e) {
      console.error('Failed to flush to localStorage:', e);
    }
  }

  /**
   * Loads state from localStorage to live state
   */
  function loadFromLocal() {
    if (typeof localStorage === 'undefined') {
      return;
    }

    try {
      const stored = localStorage.getItem('zion_state');
      if (stored) {
        liveState = JSON.parse(stored);
      } else {
        liveState = createWorldState();
      }
    } catch (e) {
      console.error('Failed to load from localStorage:', e);
      liveState = createWorldState();
    }
  }

  /**
   * Flushes to canonical JSON string
   * @returns {string} JSON string of current state
   */
  function flushToCanonical() {
    const state = getLiveState();
    return JSON.stringify(state);
  }

  /**
   * Loads from canonical JSON string
   * @param {string} json - JSON string
   */
  function loadFromCanonical(json) {
    try {
      liveState = JSON.parse(json);
    } catch (e) {
      console.error('Failed to parse canonical state:', e);
      liveState = createWorldState();
    }
  }

  /**
   * Applies a protocol message to state (PURE function)
   * @param {Object} state - Current state
   * @param {Object} message - Protocol message
   * @returns {Object} New state
   */
  function applyMessage(state, message) {
    // Deep clone state for immutability
    const newState = JSON.parse(JSON.stringify(state));

    const { type, from, payload } = message;
    const timestamp = message.ts || Date.now();

    switch (type) {
      case 'join':
        newState.players[from] = {
          id: from,
          name: payload.name || from,
          position: payload.position || { x: 0, y: 0, z: 0 },
          zone: payload.zone || 'default',
          online: true,
          last_seen: timestamp,
          idle: false,
          inventory: [],
          intentions: [],
          ...payload
        };
        break;

      case 'leave':
        if (newState.players[from]) {
          newState.players[from].online = false;
          newState.players[from].last_seen = timestamp;
        }
        break;

      case 'heartbeat':
        if (newState.players[from]) {
          newState.players[from].last_seen = timestamp;
          newState.players[from].idle = false;
        }
        break;

      case 'idle':
        if (newState.players[from]) {
          newState.players[from].idle = true;
        }
        break;

      case 'move':
        if (newState.players[from] && payload.position) {
          newState.players[from].position = payload.position;
        }
        break;

      case 'warp':
        if (newState.players[from]) {
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
          if (payload.zone) {
            newState.players[from].zone = payload.zone;
          }
        }
        break;

      case 'say':
      case 'shout':
      case 'whisper':
      case 'emote':
        newState.chat.push({
          id: `chat_${timestamp}_${from}`,
          type,
          from,
          to: payload.to,
          text: payload.text || payload.message || '',
          ts: timestamp
        });
        break;

      case 'build':
        if (payload.structure) {
          const structureId = `struct_${timestamp}_${from}`;
          newState.structures[structureId] = {
            id: structureId,
            builder: from,
            type: payload.structure.type,
            position: payload.structure.position,
            data: payload.structure.data || {},
            ts: timestamp
          };
        }
        break;

      case 'plant':
        if (payload.plant) {
          const gardenId = `garden_${timestamp}_${from}`;
          newState.gardens[gardenId] = {
            id: gardenId,
            gardener: from,
            plant: payload.plant.type,
            position: payload.plant.position,
            planted_at: timestamp,
            ready_at: timestamp + (payload.plant.grow_time || 60000),
            ready: false
          };
        }
        break;

      case 'harvest':
        if (payload.gardenId && newState.gardens[payload.gardenId]) {
          const garden = newState.gardens[payload.gardenId];
          if (garden.ready || timestamp >= garden.ready_at) {
            delete newState.gardens[payload.gardenId];
            // Add harvested item to player inventory
            if (newState.players[from] && newState.players[from].inventory) {
              newState.players[from].inventory.push({
                type: garden.plant,
                harvested_at: timestamp
              });
            }
          }
        }
        break;

      case 'craft':
        if (payload.item && newState.players[from]) {
          if (!newState.players[from].inventory) {
            newState.players[from].inventory = [];
          }
          newState.players[from].inventory.push({
            type: payload.item.type,
            crafted_at: timestamp,
            data: payload.item.data || {}
          });
        }
        break;

      case 'compose':
        if (payload.art) {
          const artId = `art_${timestamp}_${from}`;
          newState.structures[artId] = {
            id: artId,
            artist: from,
            type: 'art',
            art_type: payload.art.type,
            position: payload.art.position,
            data: payload.art.data || {},
            ts: timestamp
          };
        }
        break;

      case 'trade_offer':
        newState.actions.push({
          id: `trade_${timestamp}_${from}`,
          type: 'trade_offer',
          from,
          to: payload.to,
          offered: payload.offered || [],
          requested: payload.requested || [],
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'trade_accept':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'accepted';
            trade.completed_at = timestamp;
            // Exchange items between players
            var sender = newState.players[trade.from];
            var recipient = newState.players[trade.to];
            if (sender && recipient) {
              if (!sender.inventory) sender.inventory = [];
              if (!recipient.inventory) recipient.inventory = [];
              // Move offered items from sender to recipient
              if (trade.offered && trade.offered.length > 0) {
                trade.offered.forEach(function(item) {
                  var idx = sender.inventory.findIndex(function(inv) { return inv.type === item.type; });
                  if (idx !== -1) {
                    sender.inventory.splice(idx, 1);
                    recipient.inventory.push(item);
                  }
                });
              }
              // Move requested items from recipient to sender
              if (trade.requested && trade.requested.length > 0) {
                trade.requested.forEach(function(item) {
                  var idx = recipient.inventory.findIndex(function(inv) { return inv.type === item.type; });
                  if (idx !== -1) {
                    recipient.inventory.splice(idx, 1);
                    sender.inventory.push(item);
                  }
                });
              }
            }
          }
        }
        break;

      case 'trade_decline':
        if (payload.tradeId) {
          const trade = newState.actions.find(a => a.id === payload.tradeId);
          if (trade && trade.type === 'trade_offer') {
            trade.status = 'declined';
            trade.completed_at = timestamp;
          }
        }
        break;

      case 'buy':
        // Market buy â€” find listing, transfer Spark, transfer item
        var buyActionId = 'buy_' + timestamp + '_' + from;
        var listing = (newState.economy.listings || []).find(function(l) { return l.id === payload.listingId && l.active; });
        if (listing) {
          var buyerBal = (newState.economy.balances[from] || 0);
          if (buyerBal >= listing.price) {
            // Transfer Spark: buyer pays, seller receives
            newState.economy.balances[from] = (newState.economy.balances[from] || 0) - listing.price;
            newState.economy.balances[listing.seller] = (newState.economy.balances[listing.seller] || 0) + listing.price;
            listing.active = false;
            listing.sold_to = from;
            listing.sold_at = timestamp;
            // Transfer item to buyer's inventory
            if (newState.players[from]) {
              if (!newState.players[from].inventory) newState.players[from].inventory = [];
              newState.players[from].inventory.push({
                type: listing.itemType || listing.item,
                purchased_at: timestamp,
                data: listing.data || {}
              });
            }
            // Record transaction
            newState.economy.transactions.push({
              id: buyActionId,
              type: 'buy',
              from: from,
              to: listing.seller,
              amount: listing.price,
              item: listing.itemType || listing.item,
              ts: timestamp
            });
          }
        }
        newState.actions.push({
          id: buyActionId,
          type: 'buy',
          buyer: from,
          listingId: payload.listingId,
          success: !!listing,
          ts: timestamp
        });
        break;

      case 'sell':
        // Market sell â€” create listing from player's item
        var sellActionId = 'sell_' + timestamp + '_' + from;
        var listingId = 'listing_' + timestamp + '_' + from;
        if (!newState.economy.listings) newState.economy.listings = [];
        newState.economy.listings.push({
          id: listingId,
          seller: from,
          item: payload.item,
          itemType: payload.item && payload.item.type ? payload.item.type : payload.item,
          price: payload.price || 0,
          active: true,
          data: payload.data || {},
          ts: timestamp
        });
        newState.actions.push({
          id: sellActionId,
          type: 'sell',
          seller: from,
          listingId: listingId,
          item: payload.item,
          price: payload.price,
          ts: timestamp
        });
        break;

      case 'gift':
        if (payload.to && payload.item) {
          newState.actions.push({
            id: `gift_${timestamp}_${from}`,
            type: 'gift',
            from,
            to: payload.to,
            item: payload.item,
            ts: timestamp
          });
          // Transfer item from sender to recipient
          if (newState.players[from] && newState.players[payload.to]) {
            if (!newState.players[payload.to].inventory) {
              newState.players[payload.to].inventory = [];
            }
            newState.players[payload.to].inventory.push({
              ...payload.item,
              gifted_from: from,
              gifted_at: timestamp
            });
          }
        }
        break;

      case 'teach':
        newState.actions.push({
          id: `teach_${timestamp}_${from}`,
          type: 'teach',
          teacher: from,
          student: payload.to,
          skill: payload.skill,
          ts: timestamp
        });
        break;

      case 'learn':
        newState.actions.push({
          id: `learn_${timestamp}_${from}`,
          type: 'learn',
          learner: from,
          skill: payload.skill,
          source: payload.source,
          ts: timestamp
        });
        break;

      case 'mentor_offer':
        newState.actions.push({
          id: `mentor_${timestamp}_${from}`,
          type: 'mentor_offer',
          mentor: from,
          mentee: payload.to,
          status: 'pending',
          ts: timestamp
        });
        break;

      case 'mentor_accept':
        if (payload.mentorId) {
          const mentorship = newState.actions.find(a => a.id === payload.mentorId);
          if (mentorship && mentorship.type === 'mentor_offer') {
            mentorship.status = 'accepted';
            mentorship.accepted_at = timestamp;
          }
        }
        break;

      case 'challenge':
        const challengeId = `challenge_${timestamp}_${from}`;
        newState.competitions[challengeId] = {
          id: challengeId,
          challenger: from,
          challenged: payload.to,
          type: payload.challenge_type,
          status: 'pending',
          ts: timestamp
        };
        break;

      case 'accept_challenge':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'active';
          newState.competitions[payload.challengeId].accepted_at = timestamp;
        }
        break;

      case 'forfeit':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          newState.competitions[payload.challengeId].status = 'forfeited';
          newState.competitions[payload.challengeId].forfeited_by = from;
          newState.competitions[payload.challengeId].completed_at = timestamp;
        }
        break;

      case 'score':
        if (payload.challengeId && newState.competitions[payload.challengeId]) {
          const comp = newState.competitions[payload.challengeId];
          if (!comp.scores) {
            comp.scores = {};
          }
          comp.scores[from] = payload.score;
        }
        break;

      case 'discover':
        if (payload.discovery) {
          const discoveryId = `discovery_${timestamp}_${from}`;
          newState.discoveries[discoveryId] = {
            id: discoveryId,
            discoverer: from,
            type: payload.discovery.type,
            location: payload.discovery.location,
            data: payload.discovery.data || {},
            ts: timestamp
          };
        }
        break;

      case 'anchor_place':
        if (payload.anchor) {
          const anchorId = `anchor_${timestamp}_${from}`;
          newState.anchors[anchorId] = {
            id: anchorId,
            owner: from,
            position: payload.anchor.position,
            zone: payload.anchor.zone || 'default',
            name: payload.anchor.name,
            ts: timestamp
          };
        }
        break;

      case 'inspect':
        // No state change - returns info only
        break;

      case 'intention_set':
        if (newState.players[from] && payload.intention) {
          if (!newState.players[from].intentions) {
            newState.players[from].intentions = [];
          }
          newState.players[from].intentions.push({
            text: payload.intention,
            set_at: timestamp
          });
        }
        break;

      case 'intention_clear':
        if (newState.players[from]) {
          newState.players[from].intentions = [];
        }
        break;

      case 'warp_fork':
        if (newState.players[from] && payload.target_world) {
          newState.players[from].current_world = payload.target_world;
          newState.players[from].home_world = newState.players[from].home_world || 'default';
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'return_home':
        if (newState.players[from]) {
          const homeWorld = newState.players[from].home_world || 'default';
          newState.players[from].current_world = homeWorld;
          if (payload.position) {
            newState.players[from].position = payload.position;
          }
        }
        break;

      case 'federation_announce':
        if (payload.federation) {
          newState.federation.federations.push({
            id: `fed_${timestamp}_${from}`,
            announced_by: from,
            name: payload.federation.name,
            endpoint: payload.federation.endpoint,
            ts: timestamp
          });
        }
        break;

      case 'federation_handshake':
        if (payload.federationId) {
          const fed = newState.federation.federations.find(f => f.id === payload.federationId);
          if (fed) {
            fed.handshake_complete = true;
            fed.handshake_at = timestamp;
          }
        }
        break;

      case 'star_register':
        if (!newState.playerStars) newState.playerStars = {};
        if (payload) {
          newState.playerStars[from] = {
            name: payload.name || from,
            x: payload.x || 0,
            y: payload.y || 0,
            z: payload.z || 0,
            color: payload.color || 0xFFDD88,
            ts: timestamp
          };
        }
        break;

      case 'election_start':
        if (!newState.elections) newState.elections = {};
        var electionId = 'election_' + timestamp + '_' + (payload.zone || 'nexus');
        newState.elections[electionId] = {
          id: electionId,
          zone: payload.zone,
          started_by: from,
          candidates: [from],
          votes: {},
          started_at: timestamp,
          ends_at: timestamp + (30 * 24 * 60 * 60 * 1000), // 30-day term
          status: 'active'
        };
        break;

      case 'election_vote':
        if (newState.elections && payload.electionId) {
          var election = newState.elections[payload.electionId];
          if (election && election.status === 'active') {
            election.votes[from] = payload.candidate;
            if (payload.candidate && election.candidates.indexOf(payload.candidate) === -1) {
              election.candidates.push(payload.candidate);
            }
          }
        }
        break;

      case 'election_finalize':
        if (newState.elections && payload.electionId) {
          var elecFinal = newState.elections[payload.electionId];
          if (elecFinal && elecFinal.status === 'active') {
            // Count votes
            var voteCounts = {};
            Object.values(elecFinal.votes).forEach(function(candidate) {
              voteCounts[candidate] = (voteCounts[candidate] || 0) + 1;
            });
            var winner = null;
            var maxVotes = 0;
            Object.keys(voteCounts).forEach(function(c) {
              if (voteCounts[c] > maxVotes) { maxVotes = voteCounts[c]; winner = c; }
            });
            elecFinal.status = 'complete';
            elecFinal.winner = winner;
            elecFinal.completed_at = timestamp;
            // Set steward for the zone
            if (!newState.stewards) newState.stewards = {};
            if (winner) {
              newState.stewards[elecFinal.zone] = {
                playerId: winner,
                zone: elecFinal.zone,
                elected_at: timestamp,
                term_ends: timestamp + (30 * 24 * 60 * 60 * 1000)
              };
            }
          }
        }
        break;

      case 'steward_set_welcome':
        if (!newState.stewards) newState.stewards = {};
        var steward = newState.stewards[payload.zone];
        if (steward && steward.playerId === from) {
          steward.welcomeMessage = payload.message;
        }
        break;

      case 'steward_set_policy':
        if (!newState.stewards) newState.stewards = {};
        var stewardPolicy = newState.stewards[payload.zone];
        if (stewardPolicy && stewardPolicy.playerId === from) {
          stewardPolicy.policy = payload.policy;
        }
        break;

      case 'steward_moderate':
        if (!newState.stewards) newState.stewards = {};
        var stewardMod = newState.stewards[payload.zone];
        if (stewardMod && stewardMod.playerId === from) {
          newState.actions.push({
            id: 'moderate_' + timestamp + '_' + from,
            type: 'moderation',
            steward: from,
            zone: payload.zone,
            target: payload.target,
            action: payload.action,
            reason: payload.reason,
            ts: timestamp
          });
        }
        break;

      case 'sim_crm_action':
        // Route simulation actions to state for peer visibility
        if (!newState.simulations) newState.simulations = {};
        if (!newState.simulations.crm) newState.simulations.crm = { actions: [] };
        newState.simulations.crm.actions.push({
          id: 'sim_' + timestamp + '_' + from,
          from: from,
          action: payload.action,
          data: payload.data || {},
          ts: timestamp
        });
        break;

      case 'propose_amendment':
        // Record a constitutional amendment proposal
        if (!newState.amendments) newState.amendments = [];
        if (payload.title && payload.description && payload.diff_text) {
          var amendId = 'amend_' + timestamp + '_' + from;
          var discussionDays = Math.max(7, parseInt(payload.discussion_period_days || 7, 10));
          var proposedAt = new Date(typeof timestamp === 'number' ? timestamp : timestamp);
          var closesAt = new Date(proposedAt.getTime() + discussionDays * 86400000);
          newState.amendments.push({
            id: amendId,
            title: payload.title,
            description: payload.description,
            diff_text: payload.diff_text,
            proposed_by: from,
            proposed_at: typeof timestamp === 'string' ? timestamp : new Date(timestamp).toISOString(),
            discussion_period_days: discussionDays,
            voting_closes_at: closesAt.toISOString(),
            status: 'open',
            votes: [],
            result: null
          });
        }
        break;

      case 'vote_amendment':
        // Record a vote on an open amendment
        if (newState.amendments && payload.amendment_id && payload.vote) {
          var voteAmend = null;
          for (var ai = 0; ai < newState.amendments.length; ai++) {
            if (newState.amendments[ai].id === payload.amendment_id) {
              voteAmend = newState.amendments[ai];
              break;
            }
          }
          if (voteAmend && voteAmend.status === 'open') {
            // Deduplicate: one vote per citizen
            var alreadyVoted = false;
            for (var vi = 0; vi < voteAmend.votes.length; vi++) {
              if (voteAmend.votes[vi].from === from) { alreadyVoted = true; break; }
            }
            if (!alreadyVoted && (payload.vote === 'for' || payload.vote === 'against')) {
              var sparkWeight = Math.max(1, (newState.economy && newState.economy.balances && newState.economy.balances[from]) || 1);
              voteAmend.votes.push({
                from: from,
                vote: payload.vote,
                spark_weight: sparkWeight,
                ts: typeof timestamp === 'string' ? timestamp : new Date(timestamp).toISOString()
              });
            }
          }
        }
        break;

      case 'close_amendment':
        // Record the result of a closed amendment (typically sent by ZION-GOVERNANCE system)
        if (newState.amendments && payload.amendment_id) {
          for (var ci = 0; ci < newState.amendments.length; ci++) {
            if (newState.amendments[ci].id === payload.amendment_id) {
              newState.amendments[ci].status = 'closed';
              newState.amendments[ci].result = payload.result || null;
              if (payload.tally) {
                newState.amendments[ci].tally = payload.tally;
              }
              newState.amendments[ci].closed_at = typeof timestamp === 'string' ? timestamp : new Date(timestamp).toISOString();
              break;
            }
          }
        }
        break;

      default:
        // Unknown message type - no state change
        break;
    }

    // Record state change
    newState.changes.push({
      type,
      from,
      ts: timestamp
    });

    return newState;
  }

  /**
   * Resolves conflicts between two states using last-writer-wins
   * @param {Object} stateA - First state
   * @param {Object} stateB - Second state
   * @returns {Object} Merged state
   */
  function resolveConflict(stateA, stateB) {
    // Start with a deep clone of stateA
    const merged = JSON.parse(JSON.stringify(stateA));

    // Merge changes arrays and sort by timestamp
    const allChanges = [
      ...(stateA.changes || []),
      ...(stateB.changes || [])
    ].sort((a, b) => a.ts - b.ts);

    // Remove duplicates
    const uniqueChanges = [];
    const seen = new Set();
    for (const change of allChanges) {
      const key = `${change.type}_${change.from}_${change.ts}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueChanges.push(change);
      }
    }

    merged.changes = uniqueChanges;

    // Merge players (last-writer-wins based on last_seen)
    merged.players = { ...stateA.players };
    for (const [playerId, playerB] of Object.entries(stateB.players || {})) {
      const playerA = merged.players[playerId];
      if (!playerA || (playerB.last_seen || 0) > (playerA.last_seen || 0)) {
        merged.players[playerId] = playerB;
      }
    }

    // Merge collections (combine and deduplicate by ID)
    const mergeById = (collectionA, collectionB) => {
      const result = { ...collectionA };
      for (const [id, item] of Object.entries(collectionB || {})) {
        if (!result[id] || (item.ts || 0) > (result[id].ts || 0)) {
          result[id] = item;
        }
      }
      return result;
    };

    merged.gardens = mergeById(stateA.gardens || {}, stateB.gardens || {});
    merged.structures = mergeById(stateA.structures || {}, stateB.structures || {});
    merged.discoveries = mergeById(stateA.discoveries || {}, stateB.discoveries || {});
    merged.anchors = mergeById(stateA.anchors || {}, stateB.anchors || {});
    merged.competitions = mergeById(stateA.competitions || {}, stateB.competitions || {});

    // Merge chat (combine and sort by timestamp)
    merged.chat = [
      ...(stateA.chat || []),
      ...(stateB.chat || [])
    ].sort((a, b) => a.ts - b.ts);

    // Merge actions (combine and deduplicate)
    merged.actions = [
      ...(stateA.actions || []),
      ...(stateB.actions || [])
    ];
    const actionIds = new Set();
    merged.actions = merged.actions.filter(action => {
      if (actionIds.has(action.id)) {
        return false;
      }
      actionIds.add(action.id);
      return true;
    });

    // Merge economy (combine transactions and listings)
    merged.economy = {
      balances: { ...(stateA.economy?.balances || {}), ...(stateB.economy?.balances || {}) },
      transactions: [
        ...(stateA.economy?.transactions || []),
        ...(stateB.economy?.transactions || [])
      ].sort((a, b) => a.ts - b.ts),
      listings: [
        ...(stateA.economy?.listings || []),
        ...(stateB.economy?.listings || [])
      ]
    };

    // Merge federation
    merged.federation = {
      federations: [
        ...(stateA.federation?.federations || []),
        ...(stateB.federation?.federations || [])
      ]
    };

    // World state - use most recent
    const worldATime = stateA.world?.time || 0;
    const worldBTime = stateB.world?.time || 0;
    merged.world = worldBTime > worldATime ? stateB.world : stateA.world;

    return merged;
  }

  // Convenience helpers used by main.js
  function initState() {
    return createWorldState();
  }

  function addPlayer(state, player) {
    if (!state || !player) return;
    state.players[player.id] = {
      id: player.id,
      name: player.name || player.id,
      position: player.position || { x: 0, y: 0, z: 0 },
      zone: player.zone || 'nexus',
      spark: player.spark || 0,
      warmth: player.warmth || 0,
      online: true,
      lastSeen: new Date().toISOString()
    };
  }

  function removePlayer(state, playerId) {
    if (!state || !playerId) return;
    if (state.players[playerId]) {
      state.players[playerId].online = false;
      state.players[playerId].lastSeen = new Date().toISOString();
    }
  }

  function getPlayer(state, playerId) {
    if (!state || !playerId) return null;
    return state.players[playerId] || null;
  }

  function getPlayers(state) {
    if (!state) return [];
    return Object.values(state.players);
  }

  // Export public API
  exports.createWorldState = createWorldState;
  exports.initState = initState;
  exports.addPlayer = addPlayer;
  exports.removePlayer = removePlayer;
  exports.getPlayer = getPlayer;
  exports.getPlayers = getPlayers;
  exports.getLiveState = getLiveState;
  exports.setLiveState = setLiveState;
  exports.flushToLocal = flushToLocal;
  exports.loadFromLocal = loadFromLocal;
  exports.flushToCanonical = flushToCanonical;
  exports.loadFromCanonical = loadFromCanonical;
  exports.applyMessage = applyMessage;
  exports.resolveConflict = resolveConflict;

})(typeof module !== 'undefined' ? module.exports : (window.State = {}));


// LAZY_LOAD_START: replay
// replay.js â€” Protocol Replay system for ZION
// Records and replays protocol message sequences
(function(exports) {
  'use strict';

  // ============================================================
  // Internal helpers
  // ============================================================

  function sortByTimestamp(messages) {
    return messages.slice().sort(function(a, b) {
      var ta = new Date(a.ts).getTime();
      var tb = new Date(b.ts).getTime();
      return ta - tb;
    });
  }

  function buildRecording(messages) {
    var sorted = sortByTimestamp(messages);
    var startTime = sorted.length > 0 ? sorted[0].ts : null;
    var endTime = sorted.length > 0 ? sorted[sorted.length - 1].ts : null;
    var duration = 0;
    if (startTime && endTime) {
      duration = new Date(endTime).getTime() - new Date(startTime).getTime();
    }
    return {
      messages: sorted,
      startTime: startTime,
      endTime: endTime,
      duration: duration
    };
  }

  // ============================================================
  // Recorder
  // ============================================================

  /**
   * createRecorder() â€” Returns a recorder object.
   * recorder.record(message) â€” add a protocol message
   * recorder.stop() â†’ recording object {messages, startTime, endTime, duration}
   * recorder.export() â†’ JSON string of the recording
   */
  function createRecorder() {
    var _messages = [];

    function record(message) {
      _messages.push(message);
    }

    function stop() {
      return buildRecording(_messages);
    }

    function exportRecording() {
      var recording = buildRecording(_messages);
      return JSON.stringify(recording);
    }

    return {
      record: record,
      stop: stop,
      export: exportRecording
    };
  }

  // ============================================================
  // Player
  // ============================================================

  /**
   * createPlayer(recording) â€” Returns a player object.
   *
   * player.play(callback, speed?) â€” start playback
   *   callback(message) is called for each message at the correct relative time
   *   speed is a multiplier (default 1); higher = faster
   * player.pause()
   * player.resume()
   * player.stop()
   * player.seek(timestamp) â€” jump to specific ISO timestamp
   * player.setSpeed(multiplier)
   * player.getProgress() â†’ {current, total, percent, elapsed, remaining}
   * player.onComplete(callback)
   */
  function createPlayer(recording) {
    var _messages = recording.messages || [];
    var _speed = 1;
    var _currentIndex = 0;
    var _playing = false;
    var _paused = false;
    var _stopped = false;
    var _callback = null;
    var _completeCallback = null;
    var _timeoutId = null;

    // When we resume after a pause we need to know:
    // - which message comes next
    // - how much real time remains until that next message should fire
    var _resumeDelay = 0;

    // Elapsed virtual (recording) time consumed so far (ms)
    var _elapsedMs = 0;

    function onComplete(cb) {
      _completeCallback = cb;
    }

    function setSpeed(multiplier) {
      // Clamp to a minimum of 0.01 to prevent infinite loops
      _speed = Math.max(0.01, multiplier);
    }

    function getProgress() {
      var total = _messages.length;
      var current = Math.min(_currentIndex, total);
      var percent = total === 0 ? 100 : Math.round((current / total) * 100);
      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;
      var totalDuration = recording.duration || 0;
      // elapsed is how far into the recording we are in virtual time
      var elapsed = _elapsedMs;
      var remaining = Math.max(0, totalDuration - elapsed);
      return {
        current: current,
        total: total,
        percent: percent,
        elapsed: elapsed,
        remaining: remaining
      };
    }

    function seek(timestamp) {
      // Cancel any pending timeout
      if (_timeoutId !== null) {
        clearTimeout(_timeoutId);
        _timeoutId = null;
      }

      var seekMs = new Date(timestamp).getTime();
      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;

      // Find the first message whose timestamp is at or after seekMs.
      // Seeking to a timestamp positions playback to deliver messages
      // from that point forward (inclusive of exact matches).
      var idx = 0;
      for (var i = 0; i < _messages.length; i++) {
        var msgMs = new Date(_messages[i].ts).getTime();
        if (msgMs >= seekMs) {
          break;
        }
        idx = i + 1;
      }
      _currentIndex = idx;
      _elapsedMs = Math.max(0, seekMs - startMs);
    }

    function _scheduleNext() {
      if (_stopped || _paused) return;
      if (_currentIndex >= _messages.length) {
        // All done
        _playing = false;
        _elapsedMs = recording.duration || 0;
        if (_completeCallback) _completeCallback();
        return;
      }

      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;
      var nowMs = startMs + _elapsedMs;
      var nextMsg = _messages[_currentIndex];
      var nextMsgMs = new Date(nextMsg.ts).getTime();

      // How many virtual ms until the next message?
      var virtualDelay = Math.max(0, nextMsgMs - nowMs);
      // Convert to real ms
      var realDelay = virtualDelay / _speed;

      _timeoutId = setTimeout(function() {
        if (_stopped || _paused) return;
        _timeoutId = null;

        // Deliver the message
        var msg = _messages[_currentIndex];
        _elapsedMs = new Date(msg.ts).getTime() - startMs;
        _currentIndex++;

        if (_callback) _callback(msg);

        _scheduleNext();
      }, realDelay);
    }

    function play(callback, speed) {
      if (speed !== undefined) {
        setSpeed(speed);
      }
      _callback = callback;
      _playing = true;
      _paused = false;
      _stopped = false;

      if (_messages.length === 0) {
        // Nothing to play â€” immediately complete
        _playing = false;
        setTimeout(function() {
          if (_completeCallback) _completeCallback();
        }, 0);
        return;
      }

      // Reset to beginning (or wherever seek placed us)
      _scheduleNext();
    }

    function pause() {
      if (!_playing || _paused) return;
      _paused = true;

      // Cancel pending timeout and remember the remaining delay
      if (_timeoutId !== null) {
        clearTimeout(_timeoutId);
        _timeoutId = null;
      }

      // Calculate how much real-time is remaining until the next message
      // We track this via _resumeDelay for resume to use
      if (_currentIndex < _messages.length) {
        var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;
        var nowMs = startMs + _elapsedMs;
        var nextMsgMs = new Date(_messages[_currentIndex].ts).getTime();
        var virtualRemaining = Math.max(0, nextMsgMs - nowMs);
        _resumeDelay = virtualRemaining / _speed;
      } else {
        _resumeDelay = 0;
      }
    }

    function resume() {
      if (!_paused) return;
      _paused = false;

      if (_currentIndex >= _messages.length) {
        _playing = false;
        if (_completeCallback) _completeCallback();
        return;
      }

      // Schedule using the remaining delay we saved at pause time
      var delay = _resumeDelay;
      var startMs = recording.startTime ? new Date(recording.startTime).getTime() : 0;

      _timeoutId = setTimeout(function() {
        if (_stopped || _paused) return;
        _timeoutId = null;

        var msg = _messages[_currentIndex];
        _elapsedMs = new Date(msg.ts).getTime() - startMs;
        _currentIndex++;

        if (_callback) _callback(msg);

        _scheduleNext();
      }, delay);
    }

    function stop() {
      _stopped = true;
      _playing = false;
      _paused = false;
      if (_timeoutId !== null) {
        clearTimeout(_timeoutId);
        _timeoutId = null;
      }
    }

    return {
      play: play,
      pause: pause,
      resume: resume,
      stop: stop,
      seek: seek,
      setSpeed: setSpeed,
      getProgress: getProgress,
      onComplete: onComplete
    };
  }

  // ============================================================
  // Import
  // ============================================================

  /**
   * importRecording(jsonString) â€” Parse a JSON string into a recording object.
   * Throws if the JSON is invalid or missing required fields.
   */
  function importRecording(jsonString) {
    var data;
    try {
      data = JSON.parse(jsonString);
    } catch (e) {
      throw new Error('importRecording: invalid JSON â€” ' + e.message);
    }
    if (!data || !Array.isArray(data.messages)) {
      throw new Error('importRecording: missing messages array');
    }
    // Re-sort and recompute to be safe
    return buildRecording(data.messages);
  }

  /**
   * importFromInbox(inboxDir) â€” Read all top-level *.json files from a
   * directory (Node.js only) and build a recording from them.
   * Each file should contain a single protocol message object.
   * Non-JSON files and subdirectories are ignored.
   */
  function importFromInbox(inboxDir) {
    var fs = require('fs');
    var path = require('path');

    var files;
    try {
      files = fs.readdirSync(inboxDir);
    } catch (e) {
      throw new Error('importFromInbox: cannot read directory â€” ' + e.message);
    }

    var messages = [];

    for (var i = 0; i < files.length; i++) {
      var filename = files[i];
      // Only process top-level .json files
      if (!filename.endsWith('.json')) continue;

      var filepath = path.join(inboxDir, filename);

      // Skip subdirectories
      var stat;
      try {
        stat = fs.statSync(filepath);
      } catch (e) {
        continue;
      }
      if (!stat.isFile()) continue;

      var content;
      try {
        content = fs.readFileSync(filepath, 'utf8');
      } catch (e) {
        continue; // Skip unreadable files
      }

      var msg;
      try {
        msg = JSON.parse(content);
      } catch (e) {
        continue; // Skip malformed JSON
      }

      // Must have a timestamp to be sortable
      if (!msg.ts) continue;

      messages.push(msg);
    }

    return buildRecording(messages);
  }

  // ============================================================
  // Exports
  // ============================================================

  exports.createRecorder = createRecorder;
  exports.createPlayer = createPlayer;
  exports.importRecording = importRecording;
  exports.importFromInbox = importFromInbox;

})(typeof module !== 'undefined' ? module.exports : (window.Replay = {}));

// LAZY_LOAD_END: replay

// LAZY_LOAD_START: yaml_dash
// yaml_dash.js
/**
 * yaml_dash.js â€” Live YAML Dashboard for ZION
 *
 * Provides JSON-to-YAML conversion (ported from scripts/json2yml.py),
 * an interactive collapsible tree data structure, and a browser panel.
 *
 * UMD module: window.YamlDash (browser) or module.exports (Node.js)
 * ES5 compatible â€” uses var, no const/let inside module body.
 */
(function(exports) {
  'use strict';

  // â”€â”€â”€ YAML conversion constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Words YAML parsers interpret as booleans or null (checked case-insensitively)
  var YAML_BOOL_NULL = {
    'true': true, 'false': true, 'yes': true, 'no': true,
    'on': true, 'off': true, 'null': true, '~': true
  };

  // Matches numeric strings: int/float, optionally negative, optionally scientific
  var LOOKS_NUMERIC = /^[+-]?(\d+\.?\d*|\.\d+)([eE][+-]?\d+)?$/;

  // Matches date/timestamp strings starting with YYYY-MM-DD
  var LOOKS_DATE = /^\d{4}-\d{2}-\d{2}/;

  // Characters that require quoting when they start a string
  var SPECIAL_START_CHARS = { '#': true, '@': true, '&': true, '*': true,
                               '|': true, '>': true, '!': true, '%': true,
                               '[': true, '{': true };

  // â”€â”€â”€ Internal YAML helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _needsQuoting(s) {
    if (s === '') return true;
    if (YAML_BOOL_NULL[s.toLowerCase()]) return true;
    if (LOOKS_NUMERIC.test(s)) return true;
    if (LOOKS_DATE.test(s)) return true;
    if (SPECIAL_START_CHARS[s[0]]) return true;
    if (s.indexOf(': ') !== -1 || s[s.length - 1] === ':') return true;
    if (s[0] === '"' || s[0] === "'" || s[0] === ' ' || s[0] === ',') return true;
    if (s[s.length - 1] === ' ') return true;
    if (s.indexOf("'") !== -1) return true;
    return false;
  }

  function _quote(s) {
    // Single-quote a string, escaping internal single quotes by doubling
    return "'" + s.replace(/'/g, "''") + "'";
  }

  function _needsKeyQuoting(key) {
    if (key === '') return true;
    if (YAML_BOOL_NULL[key.toLowerCase()]) return true;
    if (LOOKS_NUMERIC.test(key)) return true;
    if (LOOKS_DATE.test(key)) return true;
    if (SPECIAL_START_CHARS[key[0]]) return true;
    if (key.indexOf(': ') !== -1 || key[key.length - 1] === ':') return true;
    if (key[0] === '"' || key[0] === "'" || key[0] === ' ' || key[0] === ',') return true;
    if (key[key.length - 1] === ' ') return true;
    return false;
  }

  function _formatKey(key) {
    if (_needsKeyQuoting(key)) return _quote(key);
    return key;
  }

  function _formatScalar(value) {
    if (value === null) return 'null';
    if (value === true) return 'true';
    if (value === false) return 'false';
    if (typeof value === 'number') return String(value);
    // String
    if (typeof value === 'string') {
      if (value.indexOf('\n') !== -1) return null; // signal: use block scalar
      if (_needsQuoting(value)) return _quote(value);
      return value;
    }
    return String(value);
  }

  function _renderBlockScalar(s, indent) {
    var prefix = _repeat(' ', indent);
    var header, body;
    if (s[s.length - 1] === '\n') {
      header = '|';
      body = s.slice(0, s.length - 1);
    } else {
      header = '|-';
      body = s;
    }
    var lines = body.split('\n');
    var result = header + '\n';
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (line) {
        result += prefix + line + '\n';
      } else {
        result += '\n';
      }
    }
    return result;
  }

  function _repeat(str, n) {
    var out = '';
    for (var i = 0; i < n; i++) out += str;
    return out;
  }

  function _isObject(v) {
    return v !== null && typeof v === 'object' && !Array.isArray(v);
  }

  function _isArray(v) {
    return Array.isArray(v);
  }

  function _render(value, indent, inlineFirst) {
    var prefix = _repeat(' ', indent);
    indent = indent || 0;
    inlineFirst = inlineFirst || false;

    // Dict / Object
    if (_isObject(value)) {
      var keys = Object.keys(value);
      if (keys.length === 0) {
        return inlineFirst ? '{}\n' : prefix + '{}\n';
      }
      var lines = [];
      var first = true;
      for (var ki = 0; ki < keys.length; ki++) {
        var key = keys[ki];
        var val = value[key];
        var fk = _formatKey(String(key));
        var linePrefix = (first && inlineFirst) ? '' : prefix;

        if (_isObject(val)) {
          if (Object.keys(val).length === 0) {
            lines.push(linePrefix + fk + ': {}\n');
          } else {
            lines.push(linePrefix + fk + ':\n');
            lines.push(_render(val, indent + 2, false));
          }
        } else if (_isArray(val)) {
          if (val.length === 0) {
            lines.push(linePrefix + fk + ': []\n');
          } else {
            lines.push(linePrefix + fk + ':\n');
            lines.push(_render(val, indent + 2, false));
          }
        } else if (typeof val === 'string' && val.indexOf('\n') !== -1) {
          lines.push(linePrefix + fk + ': ' + _renderBlockScalar(val, indent + 2));
        } else {
          var scalar = _formatScalar(val);
          lines.push(linePrefix + fk + ': ' + scalar + '\n');
        }
        first = false;
      }
      return lines.join('');
    }

    // Array
    if (_isArray(value)) {
      if (value.length === 0) {
        return inlineFirst ? '[]\n' : prefix + '[]\n';
      }
      var arrLines = [];
      var arrFirst = true;
      for (var ai = 0; ai < value.length; ai++) {
        var item = value[ai];
        var arrPrefix = (arrFirst && inlineFirst) ? '' : prefix;

        if (_isObject(item)) {
          if (Object.keys(item).length === 0) {
            arrLines.push(arrPrefix + '- {}\n');
          } else {
            arrLines.push(arrPrefix + '- ' + _render(item, indent + 2, true));
          }
        } else if (_isArray(item)) {
          if (item.length === 0) {
            arrLines.push(arrPrefix + '- []\n');
          } else {
            arrLines.push(arrPrefix + '- ' + _render(item, indent + 2, true));
          }
        } else if (typeof item === 'string' && item.indexOf('\n') !== -1) {
          arrLines.push(arrPrefix + '- ' + _renderBlockScalar(item, indent + 2));
        } else {
          var sc = _formatScalar(item);
          arrLines.push(arrPrefix + '- ' + sc + '\n');
        }
        arrFirst = false;
      }
      return arrLines.join('');
    }

    // Scalar (top-level)
    if (typeof value === 'string' && value.indexOf('\n') !== -1) {
      return _renderBlockScalar(value, indent);
    }
    var topScalar = _formatScalar(value);
    if (inlineFirst) return topScalar + '\n';
    return prefix + topScalar + '\n';
  }

  // â”€â”€â”€ Public: jsonToYaml â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Convert a JSON-compatible JS value to a YAML string.
   * @param {*} data
   * @returns {string} YAML string
   */
  function jsonToYaml(data) {
    return _render(data, 0, false);
  }

  // â”€â”€â”€ Tree data structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Determine the type string for a value.
   */
  function _typeOf(value) {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    if (typeof value === 'boolean') return 'boolean';
    if (typeof value === 'number') return 'number';
    return 'string';
  }

  /**
   * Build a tree node from a JSON value.
   * @param {*} data â€” any JSON-compatible value
   * @param {string} [path] â€” dot-path for this node
   * @param {number} [depth] â€” current depth (0 = root)
   * @param {string} [key] â€” key name for this node
   * @returns {Object} tree node
   */
  function buildTree(data, path, depth, key) {
    path = (path === undefined || path === null) ? '' : path;
    depth = depth || 0;
    key = (key === undefined || key === null) ? '' : String(key);

    var type = _typeOf(data);
    var node = {
      key: key,
      value: (type === 'object' || type === 'array') ? null : data,
      type: type,
      children: [],
      path: path,
      collapsed: true,
      depth: depth
    };

    if (type === 'object') {
      var objKeys = Object.keys(data);
      for (var i = 0; i < objKeys.length; i++) {
        var k = objKeys[i];
        var childPath = path ? (path + '.' + k) : k;
        node.children.push(buildTree(data[k], childPath, depth + 1, k));
      }
    } else if (type === 'array') {
      for (var ai = 0; ai < data.length; ai++) {
        var arrPath = path ? (path + '[' + ai + ']') : ('[' + ai + ']');
        node.children.push(buildTree(data[ai], arrPath, depth + 1, String(ai)));
      }
    }

    return node;
  }

  /**
   * Find a node by path in the tree (depth-first).
   * @param {Object} node
   * @param {string} path
   * @returns {Object|null}
   */
  function _findNode(node, path) {
    if (node.path === path) return node;
    for (var i = 0; i < node.children.length; i++) {
      var found = _findNode(node.children[i], path);
      if (found) return found;
    }
    return null;
  }

  /**
   * Toggle expand/collapse on a node at the given path.
   * @param {Object} tree â€” root node
   * @param {string} path â€” dot-path to toggle
   */
  function toggleNode(tree, path) {
    var node = _findNode(tree, path);
    if (node && node.children.length > 0) {
      node.collapsed = !node.collapsed;
    }
  }

  /**
   * Get all visible nodes (collapsed children are hidden) in traversal order.
   * @param {Object} node â€” root node
   * @returns {Array} flat array of visible nodes
   */
  function getVisibleNodes(node) {
    var result = [];
    _collectVisible(node, result);
    return result;
  }

  function _collectVisible(node, result) {
    result.push(node);
    if (!node.collapsed) {
      for (var i = 0; i < node.children.length; i++) {
        _collectVisible(node.children[i], result);
      }
    }
  }

  /**
   * Filter a tree to only show nodes matching query (by key or value).
   * Returns a new tree with matching nodes visible, parents expanded.
   * Returns null if nothing matches (and query is non-empty).
   * @param {Object} tree â€” root node (from buildTree)
   * @param {string} query â€” search string
   * @returns {Object|null} filtered tree
   */
  function filterTree(tree, query) {
    if (!query || query === '') {
      // Return a clone with everything collapsed (unchanged)
      return _cloneTree(tree);
    }
    var q = query.toLowerCase();
    var cloned = _cloneTree(tree);
    var matched = _markMatches(cloned, q);
    return cloned;
  }

  function _cloneTree(node) {
    var clone = {
      key: node.key,
      value: node.value,
      type: node.type,
      children: [],
      path: node.path,
      collapsed: node.collapsed,
      depth: node.depth
    };
    for (var i = 0; i < node.children.length; i++) {
      clone.children.push(_cloneTree(node.children[i]));
    }
    return clone;
  }

  /**
   * Mark matching nodes and expand their parents.
   * Returns true if this subtree has any match.
   */
  function _markMatches(node, query) {
    var selfMatch = false;

    // Check key
    if (node.key && node.key.toLowerCase().indexOf(query) !== -1) {
      selfMatch = true;
    }

    // Check value
    if (!selfMatch && node.value !== null && node.value !== undefined) {
      var valStr = String(node.value).toLowerCase();
      if (valStr.indexOf(query) !== -1) {
        selfMatch = true;
      }
    }

    // Check children recursively
    var childMatch = false;
    for (var i = 0; i < node.children.length; i++) {
      if (_markMatches(node.children[i], query)) {
        childMatch = true;
      }
    }

    // If any child matches, expand this node so children are visible
    if (childMatch) {
      node.collapsed = false;
    }

    return selfMatch || childMatch;
  }

  /**
   * Render a tree to text (YAML-like) with collapse indicators.
   * @param {Object} tree â€” root node
   * @param {boolean} [expanded] â€” if true, treat all nodes as expanded
   * @returns {string}
   */
  function renderToText(tree, expanded) {
    var lines = [];
    _renderNode(tree, lines, expanded || false);
    return lines.join('\n') + (lines.length > 0 ? '\n' : '');
  }

  function _renderNode(node, lines, forceExpanded) {
    var indent = _repeat('  ', node.depth);
    var isContainer = node.children.length > 0;
    var isCollapsed = forceExpanded ? false : node.collapsed;

    var line = indent;

    // Key prefix
    if (node.key !== '') {
      line += node.key + ': ';
    }

    if (isContainer) {
      if (isCollapsed) {
        // Collapsed: show â–¶ and child count badge
        var typeHint = node.type === 'array' ? '[' + node.children.length + ' items]'
                                              : '{' + node.children.length + ' keys}';
        line += 'â–¶ ' + typeHint;
      } else {
        // Expanded: show â–¼ and type hint
        var openHint = node.type === 'array' ? 'â–¼ [' : 'â–¼ {';
        line += openHint;
      }
    } else {
      // Leaf node: render value
      var valStr = _formatScalar(node.value);
      if (valStr === null) {
        // Multi-line string
        valStr = _quote(String(node.value));
      }
      line += valStr;
    }

    lines.push(line);

    // Recurse into children if not collapsed
    if (isContainer && !isCollapsed) {
      for (var i = 0; i < node.children.length; i++) {
        _renderNode(node.children[i], lines, forceExpanded);
      }
      // Close bracket
      var closeHint = node.type === 'array' ? _repeat('  ', node.depth) + ']'
                                            : _repeat('  ', node.depth) + '}';
      lines.push(closeHint);
    }
  }

  // â”€â”€â”€ Browser Panel (browser only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var _panelState = {
    data: null,
    title: 'YAML Dashboard',
    tree: null,
    container: null,
    panel: null,
    searchQuery: ''
  };

  /**
   * Create a YAML dashboard panel inside the given container element.
   * @param {string} containerId â€” DOM element id
   * @returns {Element|null} panel element (or null in Node.js)
   */
  function createPanel(containerId) {
    if (typeof document === 'undefined') return null;

    var container = document.getElementById(containerId);
    if (!container) return null;

    var panel = document.createElement('div');
    panel.className = 'yaml-dash-panel';
    panel.innerHTML = [
      '<div class="yaml-dash-header">',
      '  <span class="yaml-dash-title">YAML Dashboard</span>',
      '  <input class="yaml-dash-search" type="text" placeholder="Search keys/values..." />',
      '</div>',
      '<div class="yaml-dash-body">',
      '  <pre class="yaml-dash-content">No data loaded.</pre>',
      '</div>'
    ].join('');

    _panelState.panel = panel;
    _panelState.container = container;

    // Bind search
    var searchInput = panel.querySelector('.yaml-dash-search');
    if (searchInput) {
      searchInput.addEventListener('input', function() {
        _panelState.searchQuery = searchInput.value;
        _refreshPanel();
      });
    }

    container.appendChild(panel);
    return panel;
  }

  /**
   * Load JSON data into the panel and render it.
   * @param {*} data â€” JSON-compatible value
   * @param {string} [title] â€” optional panel title
   */
  function loadData(data, title) {
    _panelState.data = data;
    if (title) {
      _panelState.title = title;
      if (_panelState.panel) {
        var titleEl = _panelState.panel.querySelector('.yaml-dash-title');
        if (titleEl) titleEl.textContent = title;
      }
    }
    _panelState.tree = buildTree(data, 'root');
    _refreshPanel();
  }

  /**
   * Re-render current data into the panel.
   */
  function refresh() {
    _refreshPanel();
  }

  function _refreshPanel() {
    if (!_panelState.panel || !_panelState.tree) return;

    var displayTree = _panelState.searchQuery
      ? filterTree(_panelState.tree, _panelState.searchQuery)
      : _panelState.tree;

    var content = _panelState.panel.querySelector('.yaml-dash-content');
    if (!content) return;

    if (!displayTree) {
      content.textContent = '(no results for "' + _panelState.searchQuery + '")';
      return;
    }

    content.textContent = renderToText(displayTree);

    // Re-bind click handlers for collapse/expand
    content.onclick = function(e) {
      var target = e.target;
      var path = target.getAttribute('data-path');
      if (path) {
        toggleNode(_panelState.tree, path);
        _refreshPanel();
      }
    };
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.jsonToYaml = jsonToYaml;
  exports.buildTree = buildTree;
  exports.toggleNode = toggleNode;
  exports.getVisibleNodes = getVisibleNodes;
  exports.filterTree = filterTree;
  exports.renderToText = renderToText;
  exports.createPanel = createPanel;
  exports.loadData = loadData;
  exports.refresh = refresh;

})(typeof module !== 'undefined' ? module.exports : (window.YamlDash = {}));

// LAZY_LOAD_END: yaml_dash

// intentions.js
/**
 * ZION MMO - Intention System Engine (Layer 2)
 *
 * Allows players (especially AI) to declare conditional rules that auto-execute.
 * Core mechanic for AI player viability in real-time gameplay.
 */

(function(exports) {
  'use strict';

  // Internal store: playerId -> intentions[]
  const intentionStore = new Map();

  // Consent-required action types (actions that need explicit permission)
  const CONSENT_REQUIRED_TYPES = new Set([
    'whisper',
    'challenge',
    'trade_offer',
    'mentor_offer'
  ]);

  const MAX_INTENTIONS_PER_PLAYER = 10;

  /**
   * Register a new intention for a player
   * @param {string} playerId - The player ID
   * @param {Object} intention - The intention object
   * @returns {Object} {success: boolean, error?: string}
   */
  function registerIntention(playerId, intention) {
    // Validate intention format
    if (!intention.id || typeof intention.id !== 'string') {
      return { success: false, error: 'Intention must have a valid id' };
    }

    if (!intention.trigger || typeof intention.trigger !== 'object') {
      return { success: false, error: 'Intention must have a trigger object' };
    }

    if (!intention.trigger.condition || typeof intention.trigger.condition !== 'string') {
      return { success: false, error: 'Trigger must have a condition string' };
    }

    if (!intention.trigger.params || typeof intention.trigger.params !== 'object') {
      return { success: false, error: 'Trigger must have a params object' };
    }

    if (!intention.action || typeof intention.action !== 'object') {
      return { success: false, error: 'Intention must have an action object' };
    }

    if (!intention.action.type || typeof intention.action.type !== 'string') {
      return { success: false, error: 'Action must have a type string' };
    }

    if (!intention.action.params || typeof intention.action.params !== 'object') {
      return { success: false, error: 'Action must have a params object' };
    }

    if (typeof intention.priority !== 'number') {
      return { success: false, error: 'Intention must have a numeric priority' };
    }

    if (typeof intention.ttl !== 'number') {
      return { success: false, error: 'Intention must have a numeric ttl' };
    }

    if (typeof intention.cooldown !== 'number') {
      return { success: false, error: 'Intention must have a numeric cooldown' };
    }

    if (typeof intention.max_fires !== 'number') {
      return { success: false, error: 'Intention must have a numeric max_fires' };
    }

    // Check max intentions limit
    const playerIntentions = intentionStore.get(playerId) || [];
    if (playerIntentions.length >= MAX_INTENTIONS_PER_PLAYER) {
      return { success: false, error: `Maximum ${MAX_INTENTIONS_PER_PLAYER} intentions per player exceeded` };
    }

    // Add internal tracking fields
    const intentionWithMeta = {
      ...intention,
      createdAt: Date.now(),
      lastFired: null,
      fireCount: 0
    };

    playerIntentions.push(intentionWithMeta);
    intentionStore.set(playerId, playerIntentions);

    return { success: true };
  }

  /**
   * Clear all intentions for a player
   * @param {string} playerId - The player ID
   */
  function clearIntentions(playerId) {
    intentionStore.delete(playerId);
  }

  /**
   * Get all intentions for a player (public - anyone can read)
   * @param {string} playerId - The player ID
   * @returns {Array} Array of intentions
   */
  function getIntentions(playerId) {
    return intentionStore.get(playerId) || [];
  }

  /**
   * Check if an intention has expired
   * @param {Object} intention - The intention object
   * @param {number} now - Current timestamp
   * @returns {boolean}
   */
  function isIntentionExpired(intention, now) {
    return (now - intention.createdAt) > (intention.ttl * 1000);
  }

  /**
   * Check if an intention can fire
   * @param {Object} intention - The intention object
   * @param {number} now - Current timestamp
   * @returns {boolean}
   */
  function canIntentionFire(intention, now) {
    // Check max fires limit
    if (intention.fireCount >= intention.max_fires) {
      return false;
    }

    // Check cooldown
    if (intention.lastFired !== null) {
      const timeSinceLastFire = now - intention.lastFired;
      if (timeSinceLastFire < (intention.cooldown * 1000)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Trigger evaluators
   */
  const triggerEvaluators = {
    /**
     * Check if a player is nearby
     */
    player_nearby: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const onlyUnknown = params.known === false;

      for (const [playerId, player] of worldState.players.entries()) {
        if (playerId === ownerId) continue;
        if (!player.position) continue;

        const distance = getDistance(owner.position, player.position);
        if (distance < distanceLimit) {
          // If we only want unknown players, check if this player is known
          if (onlyUnknown) {
            // Assume players are known if they're in the owner's known list
            const knownPlayers = owner.knownPlayers || new Set();
            if (!knownPlayers.has(playerId)) {
              return true;
            }
          } else {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Check if a player said a keyword nearby
     */
    player_say: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const keyword = params.keyword;
      const distanceLimit = params.distance_lt || 20;
      const recentChats = worldState.recentChats || [];

      // Check recent chat messages
      for (const chat of recentChats) {
        if (chat.from === ownerId) continue;

        const speaker = worldState.players.get(chat.from);
        if (!speaker || !speaker.position) continue;

        const distance = getDistance(owner.position, speaker.position);
        if (distance < distanceLimit) {
          if (chat.message && chat.message.toLowerCase().includes(keyword.toLowerCase())) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Timer trigger - fires every interval
     */
    timer: function(params, worldState, ownerId, intention, now) {
      const intervalMs = params.interval_seconds * 1000;

      // If never fired, fire immediately
      if (intention.lastFired === null) {
        return true;
      }

      // Check if enough time has passed
      return (now - intention.lastFired) >= intervalMs;
    },

    /**
     * Zone enter trigger
     */
    zone_enter: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      return owner.position.zone === params.zone_id;
    },

    /**
     * Garden needs attention trigger
     */
    garden_needs: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const gardens = worldState.gardens || [];

      for (const garden of gardens) {
        if (!garden.position) continue;

        const distance = getDistance(owner.position, garden.position);
        if (distance < distanceLimit) {
          // Check if garden needs attention
          if (garden.needsWater || garden.needsHarvest || garden.needsWeeding) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Resource ready for harvest trigger
     */
    resource_ready: function(params, worldState, ownerId) {
      const owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      const distanceLimit = params.distance_lt || 10;
      const resources = worldState.resources || [];

      for (const resource of resources) {
        if (!resource.position) continue;
        if (!resource.harvestable) continue;

        const distance = getDistance(owner.position, resource.position);
        if (distance < distanceLimit) {
          return true;
        }
      }

      return false;
    },

    /**
     * Health below threshold trigger
     * Checks if the player's warmth (health proxy) is below a given percent threshold (0-100).
     * The liveState player object stores warmth as a 0-100 value.
     */
    health_below: function(params, worldState, ownerId) {
      var owner = worldState.players.get(ownerId);
      if (!owner) return false;

      var threshold = typeof params.threshold === 'number' ? params.threshold : 50;

      // warmth is the health proxy; default to 100 (full health) if not present
      var warmth = typeof owner.warmth === 'number' ? owner.warmth : 100;
      return warmth < threshold;
    },

    /**
     * Item nearby trigger
     * Checks if a specific item type exists near the player in worldState resources or structures.
     */
    item_nearby: function(params, worldState, ownerId) {
      var owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      var distanceLimit = params.distance_lt || 10;
      var targetItemType = params.item_type || '';

      // Check resource nodes (harvestable items in the world)
      var resources = worldState.resources || [];
      for (var i = 0; i < resources.length; i++) {
        var resource = resources[i];
        if (!resource.position) continue;
        // Match by type if specified; accept all types when item_type is empty
        if (targetItemType && resource.type !== targetItemType) continue;
        var dist = getDistance(owner.position, resource.position);
        if (dist < distanceLimit) {
          return true;
        }
      }

      // Also check placed structures (which may be craftable items left in the world)
      var structures = worldState.structures || {};
      var structureList = Array.isArray(structures) ? structures : Object.values(structures);
      for (var j = 0; j < structureList.length; j++) {
        var structure = structureList[j];
        if (!structure.position) continue;
        if (targetItemType && structure.art_type !== targetItemType && structure.type !== targetItemType) continue;
        var structDist = getDistance(owner.position, structure.position);
        if (structDist < distanceLimit) {
          return true;
        }
      }

      return false;
    },

    /**
     * Trade received trigger
     * Checks if the player has a pending trade offer directed at them.
     * Optionally filters by the item type offered in the trade.
     */
    trade_received: function(params, worldState, ownerId) {
      var filterItemType = params.item_type || null;
      var actions = worldState.actions || [];

      for (var i = 0; i < actions.length; i++) {
        var action = actions[i];
        // Must be a pending trade offer directed at this player
        if (action.type !== 'trade_offer') continue;
        if (action.status !== 'pending') continue;
        if (action.to !== ownerId) continue;

        // If no item type filter, any pending trade offer qualifies
        if (!filterItemType) return true;

        // Check if the offered items include the requested item type
        var offered = action.offered || [];
        for (var j = 0; j < offered.length; j++) {
          if (offered[j].type === filterItemType || offered[j].name === filterItemType) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Weather change trigger
     * Checks if the current world weather matches the trigger's weather_type param.
     * worldState.world.weather values: 'clear', 'rain', 'storm', 'fog', 'snow'
     */
    weather_change: function(params, worldState, ownerId) {
      var world = worldState.world || {};
      var currentWeather = world.weather || 'clear';
      var targetWeather = params.weather_type || '';
      return currentWeather === targetWeather;
    },

    /**
     * Time of day trigger
     * Checks if the current world day phase matches the trigger's phase param.
     * worldState.world.dayPhase values: 'dawn', 'morning', 'midday', 'afternoon', 'evening', 'night'
     * The Constitution Â§4.5 lists: dawn / day / dusk / night.
     * We match loosely so 'day' matches 'morning', 'midday', or 'afternoon'.
     * 'dusk' matches 'evening'. Exact phase names also match directly.
     */
    time_of_day: function(params, worldState, ownerId) {
      var world = worldState.world || {};
      var currentPhase = world.dayPhase || 'day';
      var targetPhase = params.phase || '';

      // Direct match
      if (currentPhase === targetPhase) return true;

      // Loose grouping: 'day' matches morning/midday/afternoon
      if (targetPhase === 'day') {
        return currentPhase === 'morning' || currentPhase === 'midday' || currentPhase === 'afternoon';
      }

      // Loose grouping: 'dusk' matches evening
      if (targetPhase === 'dusk') {
        return currentPhase === 'evening';
      }

      return false;
    },

    /**
     * Ally nearby trigger
     * Checks if a guild member or group member is within distance of the player.
     * Params: group_id (guild/group id to match), distance_lt (max distance).
     * Players must have a guildId or groupId field matching params.group_id.
     */
    ally_nearby: function(params, worldState, ownerId) {
      var owner = worldState.players.get(ownerId);
      if (!owner || !owner.position) return false;

      var distanceLimit = params.distance_lt || 20;
      var groupId = params.group_id || null;

      for (var entry of worldState.players.entries()) {
        var playerId = entry[0];
        var player = entry[1];
        if (playerId === ownerId) continue;
        if (!player.position) continue;

        // Check if this player is in the same group/guild
        var playerGroupId = player.guildId || player.guild_id || player.groupId || player.group_id || null;

        // If a specific group is required, filter by it
        if (groupId && playerGroupId !== groupId) continue;

        // If no group filter but owner has a group, only match members of owner's group
        if (!groupId) {
          var ownerGroupId = owner.guildId || owner.guild_id || owner.groupId || owner.group_id || null;
          if (!ownerGroupId) continue; // no group to match against
          if (playerGroupId !== ownerGroupId) continue;
        }

        var dist = getDistance(owner.position, player.position);
        if (dist < distanceLimit) {
          return true;
        }
      }

      return false;
    }
  };

  /**
   * Calculate Euclidean distance between two 3D positions
   */
  function getDistance(posA, posB) {
    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  /**
   * Generate action message from intention
   */
  function generateActionMessage(intention, playerId, worldState) {
    const action = intention.action;
    const player = worldState.players.get(playerId);

    if (!player) return null;

    // Check if this action requires consent - if so, skip it
    if (CONSENT_REQUIRED_TYPES.has(action.type)) {
      return null;
    }

    // Base message structure
    const message = {
      type: action.type,
      from: playerId,
      payload: { ...action.params },
      position: player.position ? { ...player.position } : null
    };

    return message;
  }

  /**
   * Evaluate all triggers for a player and generate actions
   * @param {string} playerId - The player ID
   * @param {Object} worldState - Current world state
   * @param {number} deltaTime - Time since last evaluation (unused currently)
   * @returns {Array} Array of action messages to execute
   */
  function evaluateTriggers(playerId, worldState, deltaTime) {
    const intentions = intentionStore.get(playerId) || [];
    const now = Date.now();
    const actions = [];

    // Sort by priority (higher priority first)
    const sortedIntentions = [...intentions].sort((a, b) => b.priority - a.priority);

    for (const intention of sortedIntentions) {
      // Check if expired
      if (isIntentionExpired(intention, now)) {
        continue;
      }

      // Check if can fire
      if (!canIntentionFire(intention, now)) {
        continue;
      }

      // Evaluate trigger
      const triggerType = intention.trigger.condition;
      const evaluator = triggerEvaluators[triggerType];

      if (!evaluator) {
        // Stub for unknown triggers
        continue;
      }

      let triggered = false;
      try {
        triggered = evaluator(
          intention.trigger.params,
          worldState,
          playerId,
          intention,
          now
        );
      } catch (error) {
        // Silently skip failed evaluations
        continue;
      }

      if (triggered) {
        // Generate action message
        const actionMessage = generateActionMessage(intention, playerId, worldState);

        if (actionMessage) {
          actions.push(actionMessage);

          // Update firing metadata
          intention.lastFired = now;
          intention.fireCount++;
        }
      }
    }

    return actions;
  }

  // Export public API
  exports.registerIntention = registerIntention;
  exports.clearIntentions = clearIntentions;
  exports.getIntentions = getIntentions;
  exports.evaluateTriggers = evaluateTriggers;
  exports.isIntentionExpired = isIntentionExpired;
  exports.canIntentionFire = canIntentionFire;

})(typeof module !== 'undefined' ? module.exports : (window.Intentions = {}));


// social.js
/**
 * ZION MMO - Social Module (Layer 3)
 *
 * Handles chat, emotes, and consent tracking for player interactions.
 */

(function(exports) {
  'use strict';

  // Internal stores
  const consentStore = new Map(); // "${fromId}:${toId}:${type}" -> boolean
  const rateLimitStore = new Map(); // playerId -> {count, windowStart}
  const reputationStore = new Map(); // playerId -> {score, tier, history}
  const harassmentStore = new Map(); // "${fromId}:${toId}" -> {declineCount, lastDecline}

  // Constants
  const RATE_LIMIT_MAX = 30; // messages per window
  const RATE_LIMIT_WINDOW = 60000; // 60 seconds in milliseconds
  const SAY_DISTANCE = 20;
  const EMOTE_DISTANCE = 30;

  // Reputation constants
  const REPUTATION_TIERS = [
    { name: 'Newcomer', minScore: 0, maxScore: 99 },
    { name: 'Trusted', minScore: 100, maxScore: 499 },
    { name: 'Respected', minScore: 500, maxScore: 1499 },
    { name: 'Honored', minScore: 1500, maxScore: 4999 },
    { name: 'Elder', minScore: 5000, maxScore: Infinity }
  ];

  const REPUTATION_GAINS = {
    helping: 10,
    teaching: 15,
    trading: 5,
    gifting: 8,
    guild_contribution: 12,
    mentoring: 20,
    zone_steward_action: 5
  };

  const REPUTATION_LOSSES = {
    harassment: -25,
    griefing_report: -50,
    steward_violation: -30
  };

  const HARASSMENT_THRESHOLD = 3; // Declined interactions before harassment flag
  const HARASSMENT_WINDOW = 600000; // 10 minutes

  /**
   * Calculate Euclidean distance between two 3D positions
   */
  function getDistance(posA, posB) {
    if (!posA || !posB) return Infinity;

    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const dz = posB.z - posA.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  /**
   * Get all players within a certain distance
   * @param {Object} position - The center position {x, y, z, zone}
   * @param {Object} state - World state with players map
   * @param {number} maxDistance - Maximum distance
   * @returns {Array} Array of player IDs
   */
  function getNearbyPlayers(position, state, maxDistance) {
    const nearby = [];

    if (!position || !state.players) return nearby;

    for (const [playerId, player] of state.players.entries()) {
      if (!player.position) continue;

      // Must be in same zone
      if (player.position.zone !== position.zone) continue;

      const distance = getDistance(position, player.position);
      if (distance <= maxDistance) {
        nearby.push(playerId);
      }
    }

    return nearby;
  }

  /**
   * Check rate limit for a player
   * @param {string} playerId - The player ID
   * @param {number} now - Current timestamp
   * @returns {Object} {allowed: boolean, retryAfter?: number}
   */
  function checkRateLimit(playerId, now) {
    const limit = rateLimitStore.get(playerId);

    if (!limit) {
      // First message, create new window
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    const windowAge = now - limit.windowStart;

    if (windowAge >= RATE_LIMIT_WINDOW) {
      // Window expired, start new window
      rateLimitStore.set(playerId, {
        count: 1,
        windowStart: now
      });
      return { allowed: true };
    }

    // Within current window
    if (limit.count >= RATE_LIMIT_MAX) {
      const retryAfter = RATE_LIMIT_WINDOW - windowAge;
      return { allowed: false, retryAfter };
    }

    // Increment count
    limit.count++;
    return { allowed: true };
  }

  /**
   * Handle say message (nearby players within 20 units)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleSay(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, SAY_DISTANCE);

    // Remove sender from recipients
    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  /**
   * Handle shout message (all players in same zone)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleShout(msg, state) {
    if (!msg.from || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = [];
    const senderZone = sender.position.zone;

    for (const [playerId, player] of state.players.entries()) {
      if (playerId === msg.from) continue;
      if (!player.position) continue;

      if (player.position.zone === senderZone) {
        recipients.push(playerId);
      }
    }

    return { recipients };
  }

  /**
   * Handle whisper message (requires consent)
   * @param {Object} msg - The message object {from, to, payload}
   * @param {Object} state - World state
   * @returns {Object} {success: boolean, error?: string}
   */
  function handleWhisper(msg, state) {
    if (!msg.from || !msg.to) {
      return { success: false, error: 'Whisper requires from and to fields' };
    }

    // Check consent
    if (!hasConsent(msg.from, msg.to, 'whisper')) {
      return { success: false, error: 'Whisper requires consent from recipient' };
    }

    return { success: true };
  }

  /**
   * Handle emote message (nearby players within 30 units)
   * @param {Object} msg - The message object {from, payload, position}
   * @param {Object} state - World state
   * @returns {Object} {recipients: Array}
   */
  function handleEmote(msg, state) {
    if (!msg.from || !msg.position || !state.players) {
      return { recipients: [] };
    }

    const sender = state.players.get(msg.from);
    if (!sender || !sender.position) {
      return { recipients: [] };
    }

    const recipients = getNearbyPlayers(sender.position, state, EMOTE_DISTANCE);

    // Remove sender from recipients
    const filteredRecipients = recipients.filter(id => id !== msg.from);

    return { recipients: filteredRecipients };
  }

  /**
   * Grant consent for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type (e.g., 'whisper', 'trade_offer')
   */
  function grantConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.set(key, true);
  }

  /**
   * Revoke consent for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type
   */
  function revokeConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    consentStore.delete(key);
  }

  /**
   * Check if consent exists for an interaction type
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player receiving the action
   * @param {string} type - The action type
   * @returns {boolean}
   */
  function hasConsent(fromId, toId, type) {
    const key = `${fromId}:${toId}:${type}`;
    return consentStore.get(key) === true;
  }

  /**
   * Add a chat message to state
   */
  function addMessage(state, message) {
    if (!state || !message) return;
    if (!state.chat) state.chat = { messages: [] };
    if (!state.chat.messages) state.chat.messages = [];
    state.chat.messages.push({
      user: message.user,
      text: message.text,
      timestamp: message.timestamp || new Date().toISOString()
    });
    // Keep last 100 messages
    if (state.chat.messages.length > 100) {
      state.chat.messages = state.chat.messages.slice(-100);
    }
  }

  /**
   * Get recent chat messages from state
   */
  function getRecentMessages(state, count) {
    if (!state || !state.chat || !state.chat.messages) return [];
    count = count || 50;
    return state.chat.messages.slice(-count);
  }

  /**
   * Initialize reputation for a player
   * @param {string} playerId - The player ID
   */
  function initReputation(playerId) {
    if (!reputationStore.has(playerId)) {
      reputationStore.set(playerId, {
        score: 0,
        tier: 'Newcomer',
        history: [],
        restrictions: {
          tradeBanned: false,
          zoneMuted: new Set(),
          zoneBanned: new Set()
        }
      });
    }
  }

  /**
   * Get player reputation
   * @param {string} playerId - The player ID
   * @returns {Object} Reputation data
   */
  function getReputation(playerId) {
    initReputation(playerId);
    return reputationStore.get(playerId);
  }

  /**
   * Calculate tier from score
   * @param {number} score - Reputation score
   * @returns {string} Tier name
   */
  function calculateTier(score) {
    for (const tier of REPUTATION_TIERS) {
      if (score >= tier.minScore && score <= tier.maxScore) {
        return tier.name;
      }
    }
    return 'Newcomer';
  }

  /**
   * Adjust player reputation
   * @param {string} playerId - The player ID
   * @param {string} action - Action type (e.g., 'helping', 'harassment')
   * @param {Object} details - Additional details about the action
   */
  function adjustReputation(playerId, action, details) {
    initReputation(playerId);
    const rep = reputationStore.get(playerId);

    const change = REPUTATION_GAINS[action] || REPUTATION_LOSSES[action] || 0;
    const oldScore = rep.score;
    const oldTier = rep.tier;

    rep.score = Math.max(0, rep.score + change);
    rep.tier = calculateTier(rep.score);

    rep.history.push({
      action,
      change,
      oldScore,
      newScore: rep.score,
      timestamp: Date.now(),
      details: details || {}
    });

    // Keep last 100 history entries
    if (rep.history.length > 100) {
      rep.history = rep.history.slice(-100);
    }

    // Check for tier change
    const tierChanged = oldTier !== rep.tier;

    return {
      score: rep.score,
      tier: rep.tier,
      change,
      tierChanged,
      oldTier
    };
  }

  /**
   * Record a declined interaction for harassment detection
   * @param {string} fromId - The player initiating the action
   * @param {string} toId - The player declining the action
   * @param {string} type - The interaction type
   */
  function recordDecline(fromId, toId, type) {
    const key = `${fromId}:${toId}`;
    const now = Date.now();

    if (!harassmentStore.has(key)) {
      harassmentStore.set(key, {
        declineCount: 0,
        lastDecline: 0,
        type: type
      });
    }

    const record = harassmentStore.get(key);

    // Reset if outside harassment window
    if (now - record.lastDecline > HARASSMENT_WINDOW) {
      record.declineCount = 0;
    }

    record.declineCount++;
    record.lastDecline = now;
    record.type = type;

    // Check if harassment threshold reached
    if (record.declineCount >= HARASSMENT_THRESHOLD) {
      adjustReputation(fromId, 'harassment', {
        targetPlayer: toId,
        interactionType: type,
        declineCount: record.declineCount
      });

      // Reset counter after penalty applied
      record.declineCount = 0;

      return true; // Harassment detected
    }

    return false;
  }

  /**
   * Apply reputation restrictions
   * @param {string} playerId - The player ID
   */
  function applyReputationRestrictions(playerId) {
    const rep = getReputation(playerId);

    // Low reputation consequences
    if (rep.score < 0) {
      rep.restrictions.tradeBanned = true;
    } else if (rep.score < 50) {
      // Restrictions lifted but monitored
      rep.restrictions.tradeBanned = false;
    }
  }

  /**
   * Check if player can perform action based on reputation
   * @param {string} playerId - The player ID
   * @param {string} action - Action type
   * @param {string} zone - Zone ID (optional)
   * @returns {Object} {allowed: boolean, reason?: string}
   */
  function checkReputationPermission(playerId, action, zone) {
    const rep = getReputation(playerId);

    if (action === 'trade' && rep.restrictions.tradeBanned) {
      return { allowed: false, reason: 'Trade restricted due to low reputation' };
    }

    if (zone && rep.restrictions.zoneMuted.has(zone) && (action === 'say' || action === 'shout')) {
      return { allowed: false, reason: 'You are muted in this zone' };
    }

    if (zone && rep.restrictions.zoneBanned.has(zone)) {
      return { allowed: false, reason: 'You are temporarily banned from this zone' };
    }

    // Check minimum tier for zone steward candidacy
    if (action === 'run_for_steward' && rep.tier !== 'Respected' && rep.tier !== 'Honored' && rep.tier !== 'Elder') {
      return { allowed: false, reason: 'Must be Respected tier or higher to run for zone steward' };
    }

    return { allowed: true };
  }

  /**
   * Mute player in zone
   * @param {string} playerId - The player ID
   * @param {string} zone - Zone ID
   * @param {number} duration - Duration in milliseconds (0 for permanent)
   */
  function muteInZone(playerId, zone, duration) {
    const rep = getReputation(playerId);
    rep.restrictions.zoneMuted.add(zone);

    if (duration > 0) {
      setTimeout(() => {
        rep.restrictions.zoneMuted.delete(zone);
      }, duration);
    }
  }

  /**
   * Ban player from zone
   * @param {string} playerId - The player ID
   * @param {string} zone - Zone ID
   * @param {number} duration - Duration in milliseconds
   */
  function banFromZone(playerId, zone, duration) {
    const rep = getReputation(playerId);
    rep.restrictions.zoneBanned.add(zone);

    setTimeout(() => {
      rep.restrictions.zoneBanned.delete(zone);
    }, duration);
  }

  // Export public API
  exports.handleSay = handleSay;
  exports.handleShout = handleShout;
  exports.handleWhisper = handleWhisper;
  exports.handleEmote = handleEmote;
  exports.grantConsent = grantConsent;
  exports.revokeConsent = revokeConsent;
  exports.hasConsent = hasConsent;
  exports.checkRateLimit = checkRateLimit;
  exports.getDistance = getDistance;
  exports.getNearbyPlayers = getNearbyPlayers;
  exports.addMessage = addMessage;
  exports.getRecentMessages = getRecentMessages;

  // Reputation API
  exports.initReputation = initReputation;
  exports.getReputation = getReputation;
  exports.adjustReputation = adjustReputation;
  exports.recordDecline = recordDecline;
  exports.checkReputationPermission = checkReputationPermission;
  exports.muteInZone = muteInZone;
  exports.banFromZone = banFromZone;
  exports.REPUTATION_TIERS = REPUTATION_TIERS;

})(typeof module !== 'undefined' ? module.exports : (window.Social = {}));


// creation.js
(function(exports) {

  // Plant species configuration
  const PLANT_SPECIES = {
    sunflower: {
      growthTime: 300000, // 5 min
      yields: [{type: 'sunflower', quantity: 3}]
    },
    oak_tree: {
      growthTime: 600000, // 10 min
      yields: [{type: 'wood', quantity: 5}]
    },
    wheat: {
      growthTime: 180000, // 3 min
      yields: [{type: 'wheat', quantity: 10}]
    },
    crystal_bloom: {
      growthTime: 900000, // 15 min
      yields: [{type: 'crystal', quantity: 1}]
    },
    herbs: {
      growthTime: 120000, // 2 min
      yields: [{type: 'herbs', quantity: 5}]
    }
  };

  // Crafting recipes
  const RECIPES = {
    wooden_bench: {
      materials: {wood: 3},
      produces: {type: 'wooden_bench', quantity: 1},
      complexity: 0.2
    },
    flower_crown: {
      materials: {sunflower: 2},
      produces: {type: 'flower_crown', quantity: 1},
      complexity: 0.1
    },
    crystal_lamp: {
      materials: {crystal: 1, wood: 1},
      produces: {type: 'crystal_lamp', quantity: 1},
      complexity: 0.5
    },
    bread: {
      materials: {wheat: 3, herbs: 1},
      produces: {type: 'bread', quantity: 2},
      complexity: 0.3
    },
    healing_tea: {
      materials: {herbs: 3},
      produces: {type: 'healing_tea', quantity: 1},
      complexity: 0.4
    }
  };

  // Structure types
  const STRUCTURE_TYPES = [
    'house', 'workshop', 'garden_shed', 'monument', 'bridge',
    'fountain', 'stage', 'market_stall', 'bench', 'lantern'
  ];

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Handle building structures
  function handleBuild(msg, state, zoneRules) {
    if (!zoneRules.building) {
      return {
        success: false,
        error: 'Building not allowed in this zone'
      };
    }

    const structureType = msg.payload.type;
    if (!STRUCTURE_TYPES.includes(structureType)) {
      return {
        success: false,
        error: 'Invalid structure type'
      };
    }

    const structure = {
      id: generateId(),
      type: structureType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      builder: msg.from,
      ts: Date.now()
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(structure);

    return {
      success: true,
      state: state,
      structure: structure
    };
  }

  // Handle planting
  function handlePlant(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Planting not allowed in this zone'
      };
    }

    const species = msg.payload.species;
    if (!PLANT_SPECIES[species]) {
      return {
        success: false,
        error: 'Invalid plant species'
      };
    }

    const speciesData = PLANT_SPECIES[species];
    const plantedAt = Date.now();
    const readyAt = plantedAt + speciesData.growthTime;

    const garden = {
      id: generateId(),
      species: species,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      planter: msg.from,
      plantedAt: plantedAt,
      growthStage: 0,
      readyAt: readyAt
    };

    if (!state.gardens) {
      state.gardens = [];
    }

    state.gardens.push(garden);

    return {
      success: true,
      state: state,
      garden: garden
    };
  }

  // Handle harvesting
  function handleHarvest(msg, state, zoneRules) {
    if (!zoneRules.harvesting) {
      return {
        success: false,
        error: 'Harvesting not allowed in this zone'
      };
    }

    if (!state.gardens || state.gardens.length === 0) {
      return {
        success: false,
        error: 'No gardens to harvest'
      };
    }

    const targetId = msg.payload.target;
    const gardenIndex = state.gardens.findIndex(g => g.id === targetId);

    if (gardenIndex === -1) {
      return {
        success: false,
        error: 'Garden not found'
      };
    }

    const garden = state.gardens[gardenIndex];
    const now = Date.now();

    // Check if growth is complete
    const isReady = now >= garden.readyAt || garden.growthStage >= 1.0;

    if (!isReady) {
      return {
        success: false,
        error: 'Plant is not ready to harvest yet'
      };
    }

    const speciesData = PLANT_SPECIES[garden.species];
    const items = speciesData.yields;

    // Remove garden from state
    state.gardens.splice(gardenIndex, 1);

    return {
      success: true,
      state: state,
      items: items
    };
  }

  // Handle crafting
  function handleCraft(msg, state) {
    const recipeName = msg.payload.recipe;

    if (!RECIPES[recipeName]) {
      return {
        success: false,
        error: 'Recipe not found'
      };
    }

    const recipe = RECIPES[recipeName];

    // Initialize player inventory if needed
    if (!state.players) {
      state.players = {};
    }
    if (!state.players[msg.from]) {
      state.players[msg.from] = {inventory: {}};
    }
    if (!state.players[msg.from].inventory) {
      state.players[msg.from].inventory = {};
    }

    const inventory = state.players[msg.from].inventory;

    // Check if player has required materials
    for (const [material, quantity] of Object.entries(recipe.materials)) {
      if (!inventory[material] || inventory[material] < quantity) {
        return {
          success: false,
          error: `Insufficient materials: need ${quantity} ${material}`
        };
      }
    }

    // Consume materials
    for (const [material, quantity] of Object.entries(recipe.materials)) {
      inventory[material] -= quantity;
      if (inventory[material] === 0) {
        delete inventory[material];
      }
    }

    // Produce item
    const producedItem = recipe.produces;
    if (!inventory[producedItem.type]) {
      inventory[producedItem.type] = 0;
    }
    inventory[producedItem.type] += producedItem.quantity;

    return {
      success: true,
      state: state,
      item: producedItem
    };
  }

  // Compose types configuration
  const COMPOSE_TYPES = {
    poem: { name: 'Poem', maxLength: 500, sparkReward: [5, 20] },
    poetry: { name: 'Poetry', maxLength: 500, sparkReward: [5, 20] },
    song: { name: 'Song', maxLength: 300, sparkReward: [10, 30] },
    story: { name: 'Short Story', maxLength: 1000, sparkReward: [10, 40] },
    painting: { name: 'Painting', sparkReward: [5, 25] },
    sculpture: { name: 'Sculpture', sparkReward: [10, 35] },
    mural: { name: 'Mural', sparkReward: [15, 50] }
  };

  // Handle artistic composition
  function handleCompose(msg, state) {
    const medium = msg.payload.medium || msg.payload.composeType || 'poem';
    const title = msg.payload.title || 'Untitled';
    const content = msg.payload.content || '';

    if (!COMPOSE_TYPES[medium]) {
      return {
        success: false,
        error: 'Invalid compose type'
      };
    }

    const typeData = COMPOSE_TYPES[medium];

    // Check max length for text-based types
    if (typeData.maxLength && content.length > typeData.maxLength) {
      return {
        success: false,
        error: 'Content exceeds maximum length of ' + typeData.maxLength + ' characters'
      };
    }

    const composition = {
      id: generateId(),
      creator: msg.from,
      type: 'composition',
      medium: medium,
      title: title,
      content: content,
      zone: msg.payload.zone || 'default',
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      ts: Date.now(),
      likes: 0,
      featured: false,
      likedBy: []
    };

    if (!state.structures) {
      state.structures = [];
    }

    state.structures.push(composition);

    // Calculate spark reward
    const sparkMin = typeData.sparkReward[0];
    const sparkMax = typeData.sparkReward[1];
    const sparkReward = Math.floor(sparkMin + Math.random() * (sparkMax - sparkMin));

    return {
      success: true,
      state: state,
      composition: composition,
      sparkReward: sparkReward
    };
  }

  // Like an artwork
  function likeArtwork(artworkId, playerId, state) {
    if (!state.artworks) {
      return { success: false, error: 'No artworks found' };
    }

    const artwork = state.artworks.find(function(a) { return a.id === artworkId; });
    if (!artwork) {
      return { success: false, error: 'Artwork not found' };
    }

    if (!artwork.likedBy) {
      artwork.likedBy = [];
    }

    // Check if already liked
    if (artwork.likedBy.indexOf(playerId) !== -1) {
      return { success: false, error: 'Already liked this artwork' };
    }

    artwork.likedBy.push(playerId);
    artwork.likes = artwork.likedBy.length;

    return {
      success: true,
      artwork: artwork,
      totalLikes: artwork.likes
    };
  }

  // Get artworks in a zone
  function getArtworks(state, zone) {
    if (!state.artworks) return [];

    return state.artworks.filter(function(a) {
      return !zone || a.zone === zone;
    });
  }

  // Get artworks by player
  function getArtworksByPlayer(state, playerId) {
    if (!state.artworks) return [];

    return state.artworks.filter(function(a) {
      return a.creator === playerId;
    });
  }

  // Feature an artwork (most liked in zone)
  function featureArtwork(artworkId, state) {
    if (!state.artworks) {
      return { success: false, error: 'No artworks found' };
    }

    const artwork = state.artworks.find(function(a) { return a.id === artworkId; });
    if (!artwork) {
      return { success: false, error: 'Artwork not found' };
    }

    // Unfeature all other artworks in the same zone
    state.artworks.forEach(function(a) {
      if (a.zone === artwork.zone && a.id !== artworkId) {
        a.featured = false;
      }
    });

    artwork.featured = true;

    return {
      success: true,
      artwork: artwork
    };
  }

  // ========================================================================
  // PLAYER HOUSING SYSTEM â€” Claim plots in Commons, place furniture
  // ========================================================================

  var PLOT_SIZE = 10; // 10x10 area
  var MAX_FURNITURE_PER_PLOT = 20;
  var HOUSING_ZONE = 'commons'; // Only Commons allows housing plots

  // Available plots in Commons zone (arranged in a grid)
  var PLOT_GRID = [];
  (function initPlotGrid() {
    // 5x4 grid of plots starting at Commons zone center offset
    var baseX = 140, baseZ = 170;
    for (var row = 0; row < 4; row++) {
      for (var col = 0; col < 5; col++) {
        PLOT_GRID.push({
          id: 'plot_' + row + '_' + col,
          x: baseX + col * (PLOT_SIZE + 4),
          z: baseZ + row * (PLOT_SIZE + 4),
          row: row,
          col: col
        });
      }
    }
  })();

  // Player plots: playerId -> { plotId, furniture[], name, claimedAt }
  var playerPlots = {};

  // Furniture types available for housing
  var FURNITURE_TYPES = {
    bed: { name: 'Bed', icon: '&#128716;', cost: 25, description: 'A cozy place to rest' },
    table: { name: 'Table', icon: '&#128207;', cost: 15, description: 'A sturdy wooden table' },
    chair: { name: 'Chair', icon: '&#129681;', cost: 10, description: 'A comfortable chair' },
    bookshelf: { name: 'Bookshelf', icon: '&#128218;', cost: 30, description: 'Stores your favorite books' },
    lamp: { name: 'Lamp', icon: '&#128161;', cost: 12, description: 'Warm ambient light' },
    rug: { name: 'Rug', icon: '&#129531;', cost: 18, description: 'A decorative rug' },
    plant_pot: { name: 'Potted Plant', icon: '&#127793;', cost: 8, description: 'A cheerful houseplant' },
    fireplace: { name: 'Fireplace', icon: '&#128293;', cost: 40, description: 'Warm and inviting' },
    painting: { name: 'Painting', icon: '&#128444;', cost: 20, description: 'Art for your walls' },
    chest: { name: 'Storage Chest', icon: '&#128230;', cost: 22, description: 'Store your treasures' },
    fountain_small: { name: 'Small Fountain', icon: '&#9970;', cost: 35, description: 'A soothing water feature' },
    banner: { name: 'Banner', icon: '&#127988;', cost: 15, description: 'Show your colors' }
  };

  /**
   * Get available plots (unclaimed)
   * @returns {Array} List of available plot positions
   */
  function getAvailablePlots() {
    var claimed = {};
    Object.keys(playerPlots).forEach(function(pid) {
      claimed[playerPlots[pid].plotId] = true;
    });
    return PLOT_GRID.filter(function(plot) {
      return !claimed[plot.id];
    });
  }

  /**
   * Claim a plot for a player
   * @param {string} playerId - Player claiming the plot
   * @param {string} plotId - Plot to claim
   * @param {string} plotName - Name for the plot (e.g., "Kody's Cottage")
   * @returns {Object} Result with success, error, or plot data
   */
  function claimPlot(playerId, plotId, plotName) {
    // Check if player already has a plot
    if (playerPlots[playerId]) {
      return { success: false, error: 'You already have a plot. Release it first.' };
    }
    // Check if plot exists and is unclaimed
    var plotDef = PLOT_GRID.find(function(p) { return p.id === plotId; });
    if (!plotDef) {
      return { success: false, error: 'Plot not found' };
    }
    var alreadyClaimed = Object.keys(playerPlots).some(function(pid) {
      return playerPlots[pid].plotId === plotId;
    });
    if (alreadyClaimed) {
      return { success: false, error: 'Plot already claimed by another player' };
    }

    playerPlots[playerId] = {
      plotId: plotId,
      name: plotName || playerId + "'s Plot",
      furniture: [],
      claimedAt: Date.now(),
      position: { x: plotDef.x, z: plotDef.z },
      size: PLOT_SIZE
    };
    return { success: true, plot: playerPlots[playerId] };
  }

  /**
   * Get a player's plot
   */
  function getPlayerPlot(playerId) {
    return playerPlots[playerId] || null;
  }

  /**
   * Place furniture on a player's plot
   */
  function placeFurniture(playerId, furnitureType, localX, localZ) {
    var plot = playerPlots[playerId];
    if (!plot) return { success: false, error: 'You don\'t have a plot' };
    if (!FURNITURE_TYPES[furnitureType]) return { success: false, error: 'Unknown furniture type' };
    if (plot.furniture.length >= MAX_FURNITURE_PER_PLOT) {
      return { success: false, error: 'Plot is full (max ' + MAX_FURNITURE_PER_PLOT + ' items)' };
    }
    // Clamp to plot bounds
    localX = Math.max(0, Math.min(PLOT_SIZE - 1, localX || 0));
    localZ = Math.max(0, Math.min(PLOT_SIZE - 1, localZ || 0));

    var item = {
      id: 'furn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 4),
      type: furnitureType,
      localX: localX,
      localZ: localZ,
      placedAt: Date.now()
    };
    plot.furniture.push(item);
    return { success: true, item: item, cost: FURNITURE_TYPES[furnitureType].cost };
  }

  /**
   * Remove furniture from a player's plot
   */
  function removeFurniture(playerId, furnitureId) {
    var plot = playerPlots[playerId];
    if (!plot) return { success: false, error: 'You don\'t have a plot' };
    var idx = plot.furniture.findIndex(function(f) { return f.id === furnitureId; });
    if (idx === -1) return { success: false, error: 'Furniture not found' };
    plot.furniture.splice(idx, 1);
    return { success: true };
  }

  /**
   * Release a player's plot
   */
  function releasePlot(playerId) {
    if (!playerPlots[playerId]) return { success: false, error: 'You don\'t have a plot' };
    delete playerPlots[playerId];
    return { success: true };
  }

  /**
   * Get plot at world position (check if player is standing on a plot)
   */
  function getPlotAtPosition(worldX, worldZ) {
    for (var pid in playerPlots) {
      var plot = playerPlots[pid];
      if (worldX >= plot.position.x && worldX <= plot.position.x + PLOT_SIZE &&
          worldZ >= plot.position.z && worldZ <= plot.position.z + PLOT_SIZE) {
        return { playerId: pid, plot: plot };
      }
    }
    return null;
  }

  /**
   * Get all claimed plots (for minimap/world rendering)
   */
  function getAllPlots() {
    return playerPlots;
  }

  // Exports
  exports.PLANT_SPECIES = PLANT_SPECIES;
  exports.RECIPES = RECIPES;
  exports.STRUCTURE_TYPES = STRUCTURE_TYPES;
  exports.COMPOSE_TYPES = COMPOSE_TYPES;
  exports.handleBuild = handleBuild;
  exports.handlePlant = handlePlant;
  exports.handleHarvest = handleHarvest;
  exports.handleCraft = handleCraft;
  exports.handleCompose = handleCompose;
  exports.likeArtwork = likeArtwork;
  exports.getArtworks = getArtworks;
  exports.getArtworksByPlayer = getArtworksByPlayer;
  exports.featureArtwork = featureArtwork;
  exports.FURNITURE_TYPES = FURNITURE_TYPES;
  exports.PLOT_GRID = PLOT_GRID;
  exports.getAvailablePlots = getAvailablePlots;
  exports.claimPlot = claimPlot;
  exports.getPlayerPlot = getPlayerPlot;
  exports.placeFurniture = placeFurniture;
  exports.removeFurniture = removeFurniture;
  exports.releasePlot = releasePlot;
  exports.getPlotAtPosition = getPlotAtPosition;
  exports.getAllPlots = getAllPlots;

})(typeof module !== 'undefined' ? module.exports : (window.Creation = {}));


// quests.js
/**
 * ZION Quest/Mission System
 * Complete quest system for NPC interactions with progression tracking
 */

(function(exports) {
  'use strict';

  // Quest database - 25 quests across 8 zones
  const QUEST_DATABASE = {
    // === NEXUS QUESTS (2) ===
    quest_nexus_001: {
      id: 'quest_nexus_001',
      title: 'Welcome to ZION',
      description: 'Explore the Nexus and speak to 3 different citizens',
      giverNpcId: 'ai_citizen_001',
      type: 'social',
      objectives: [
        { type: 'talk_npcs', count: 3, current: 0 }
      ],
      rewards: { spark: 25, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Welcome, traveler! To truly understand ZION, you must connect with its people. Speak to three different citizens and learn their stories.",
        progress: "You've spoken with {current} citizens so far. Talk to {remaining} more.",
        complete: "Wonderful! You're beginning to understand what makes ZION special. Here's some Spark for your curiosity."
      },
      status: 'available'
    },

    quest_nexus_002: {
      id: 'quest_nexus_002',
      title: 'Journey Begins',
      description: 'Visit any 3 different zones in ZION',
      giverNpcId: 'ai_citizen_007',
      type: 'explore',
      objectives: [
        { type: 'visit_zones', zones: [], required: 3, current: 0 }
      ],
      rewards: { spark: 50, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: ['quest_nexus_001'],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "ZION is vast and full of wonders. Visit three different zones to broaden your horizons.",
        progress: "You've explored {current} zones. Discover {remaining} more!",
        complete: "Excellent exploration! Each zone has its own character. This Spark will fuel your continued journey."
      },
      status: 'available'
    },

    // === GARDENS QUESTS (5) ===
    quest_gardens_001: {
      id: 'quest_gardens_001',
      title: 'The Gardener\'s Request',
      description: 'Gather 3 sunflowers for Willow the Gardener',
      giverNpcId: 'ai_citizen_013',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'sunflower', count: 3, current: 0 }
      ],
      rewards: { spark: 30, items: [{ id: 'rare_seed', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Hello traveler! My garden needs sunflowers. Could you gather 3 for me? They grow near the pond.",
        progress: "Still looking for those sunflowers? You need {remaining} more.",
        complete: "Wonderful! These are beautiful. Here, take this rare seed as thanks."
      },
      status: 'available'
    },

    quest_gardens_002: {
      id: 'quest_gardens_002',
      title: 'Moonflower Cultivation',
      description: 'Help plant 5 moonflower seeds in the Gardens',
      giverNpcId: 'ai_citizen_019',
      type: 'craft',
      objectives: [
        { type: 'plant', item: 'moonflower_seed', count: 5, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Moonflowers bloom only at night and bring tranquility to the Gardens. Will you help me plant 5 seeds?",
        progress: "You've planted {current} moonflower seeds. {remaining} more to go!",
        complete: "Perfect! In time, these will create a beautiful nighttime display. Thank you."
      },
      status: 'available'
    },

    quest_gardens_003: {
      id: 'quest_gardens_003',
      title: 'Herbal Remedy',
      description: 'Collect 4 healing herbs from the Gardens',
      giverNpcId: 'ai_citizen_025',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'healing_herb', count: 4, current: 0 }
      ],
      rewards: { spark: 35, items: [{ id: 'health_potion', count: 2 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "I'm preparing remedies for the community. Could you gather 4 healing herbs? They have purple flowers.",
        progress: "You have {current} herbs. I need {remaining} more for the remedy.",
        complete: "Excellent! These will help many people. Take these health potions for your troubles."
      },
      status: 'available'
    },

    quest_gardens_004: {
      id: 'quest_gardens_004',
      title: 'The Secret Garden',
      description: 'Find the hidden meditation spot in the Gardens',
      giverNpcId: 'ai_citizen_031',
      type: 'explore',
      objectives: [
        { type: 'discover', location: 'gardens_secret_spot', current: 0 }
      ],
      rewards: { spark: 60, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Deep within the Gardens lies a secret meditation spot. Few have found it. Will you seek it out?",
        progress: "Keep searching. Listen for the sound of wind chimes...",
        complete: "You found it! That place holds special energy. May it bring you peace."
      },
      status: 'available'
    },

    quest_gardens_005: {
      id: 'quest_gardens_005',
      title: 'Water the Wilds',
      description: 'Deliver water from the Gardens fountain to a Wilds gardener',
      giverNpcId: 'ai_citizen_037',
      type: 'deliver',
      objectives: [
        { type: 'deliver', item: 'water_bucket', npcId: 'ai_citizen_043', current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Our friends in the Wilds need fresh water from our fountain. Can you deliver this bucket to them?",
        progress: "The water is still fresh. Find the gardener in the Wilds!",
        complete: "Thank you! This water will help their wild gardens flourish."
      },
      status: 'available'
    },

    // === WILDS QUESTS (4) ===
    quest_wilds_001: {
      id: 'quest_wilds_001',
      title: 'Wild Observations',
      description: 'Observe 5 different wildlife species in the Wilds',
      giverNpcId: 'ai_citizen_043',
      type: 'explore',
      objectives: [
        { type: 'observe', category: 'wildlife', count: 5, current: 0 }
      ],
      rewards: { spark: 50, items: [{ id: 'field_journal', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The Wilds are teeming with life! Observe 5 different species and document your findings.",
        progress: "You've observed {current} species. {remaining} more to discover!",
        complete: "Fascinating observations! Take this field journal to record your future discoveries."
      },
      status: 'available'
    },

    quest_wilds_002: {
      id: 'quest_wilds_002',
      title: 'Rare Resource Hunt',
      description: 'Find 2 pieces of rare amber in the Wilds',
      giverNpcId: 'ai_citizen_049',
      type: 'gather',
      objectives: [
        { type: 'collect', item: 'wild_amber', count: 2, current: 0 }
      ],
      rewards: { spark: 70, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Ancient amber can be found in the deepest parts of the Wilds. Bring me 2 pieces - they're invaluable!",
        progress: "Amber is rare. You have {current}, need {remaining} more.",
        complete: "Incredible! This amber is perfect. Your effort is greatly appreciated."
      },
      status: 'available'
    },

    quest_wilds_003: {
      id: 'quest_wilds_003',
      title: 'Trail Blazer',
      description: 'Mark 3 new trail markers in unexplored areas',
      giverNpcId: 'ai_citizen_055',
      type: 'explore',
      objectives: [
        { type: 'place_marker', count: 3, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Help expand our trail network! Place 3 markers in unexplored areas of the Wilds.",
        progress: "You've placed {current} markers. {remaining} more needed!",
        complete: "Excellent work! These trails will help many travelers."
      },
      status: 'available'
    },

    quest_wilds_004: {
      id: 'quest_wilds_004',
      title: 'Ecosystem Balance',
      description: 'Help maintain balance by planting 6 native seeds',
      giverNpcId: 'ai_citizen_061',
      type: 'craft',
      objectives: [
        { type: 'plant', item: 'native_seed', count: 6, current: 0 }
      ],
      rewards: { spark: 65, items: [{ id: 'nature_compass', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The Wilds ecosystem needs our care. Plant 6 native seeds to restore balance.",
        progress: "You've planted {current} seeds. The ecosystem needs {remaining} more.",
        complete: "Perfect! Nature thanks you. Take this compass - it attunes to natural energy."
      },
      status: 'available'
    },

    // === ATHENAEUM QUESTS (3) ===
    quest_athenaeum_001: {
      id: 'quest_athenaeum_001',
      title: 'Knowledge Seeker',
      description: 'Read 3 different scrolls in the Athenaeum',
      giverNpcId: 'ai_citizen_067',
      type: 'social',
      objectives: [
        { type: 'read', item: 'scroll', count: 3, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Knowledge is power. Read 3 different scrolls from our collection to expand your understanding.",
        progress: "You've read {current} scrolls. {remaining} more await your eyes.",
        complete: "Excellent! Knowledge shared is knowledge multiplied. Well done."
      },
      status: 'available'
    },

    quest_athenaeum_002: {
      id: 'quest_athenaeum_002',
      title: 'The Scholar\'s Circle',
      description: 'Speak with 4 scholars to gather ancient wisdom',
      giverNpcId: 'ai_citizen_073',
      type: 'social',
      objectives: [
        { type: 'talk_scholars', count: 4, current: 0 }
      ],
      rewards: { spark: 50, items: [{ id: 'wisdom_tome', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The scholars here each hold unique wisdom. Speak with 4 of them to broaden your perspective.",
        progress: "You've consulted {current} scholars. Seek out {remaining} more.",
        complete: "Wonderful! You've gathered great wisdom. This tome will serve you well."
      },
      status: 'available'
    },

    quest_athenaeum_003: {
      id: 'quest_athenaeum_003',
      title: 'Lost Manuscript',
      description: 'Find the lost manuscript hidden somewhere in the Athenaeum',
      giverNpcId: 'ai_citizen_079',
      type: 'explore',
      objectives: [
        { type: 'discover', location: 'athenaeum_manuscript', current: 0 }
      ],
      rewards: { spark: 80, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "A valuable manuscript was misplaced generations ago. Can you find it? Check between the oldest shelves.",
        progress: "The manuscript is still out there. Keep searching the archives...",
        complete: "You found it! This is priceless. Thank you for preserving our history."
      },
      status: 'available'
    },

    // === STUDIO QUESTS (3) ===
    quest_studio_001: {
      id: 'quest_studio_001',
      title: 'Artist\'s First Brush',
      description: 'Create your first artwork in the Studio',
      giverNpcId: 'ai_citizen_085',
      type: 'craft',
      objectives: [
        { type: 'create', item: 'artwork', count: 1, current: 0 }
      ],
      rewards: { spark: 35, items: [{ id: 'paint_set', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Everyone has creativity within them. Create your first artwork here in the Studio!",
        progress: "Let your imagination flow. Your first artwork awaits creation!",
        complete: "Beautiful! Art is a journey. This paint set will help you continue yours."
      },
      status: 'available'
    },

    quest_studio_002: {
      id: 'quest_studio_002',
      title: 'Musical Composition',
      description: 'Compose a piece of music with 3 instruments',
      giverNpcId: 'ai_citizen_091',
      type: 'craft',
      objectives: [
        { type: 'compose', instruments: 3, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Music speaks what words cannot. Compose a piece using at least 3 different instruments!",
        progress: "You've incorporated {current} instruments. Add {remaining} more!",
        complete: "Magnificent! Your music adds beauty to ZION. Keep composing!"
      },
      status: 'available'
    },

    quest_studio_003: {
      id: 'quest_studio_003',
      title: 'The Collaborative Mural',
      description: 'Contribute to the community mural with 5 brush strokes',
      giverNpcId: 'ai_citizen_097',
      type: 'craft',
      objectives: [
        { type: 'paint_mural', count: 5, current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "The community mural represents all of us. Add your 5 brush strokes to become part of ZION's story!",
        progress: "You've added {current} strokes. {remaining} more will complete your contribution!",
        complete: "Perfect! Your marks are now part of our shared legacy. Thank you."
      },
      status: 'available'
    },

    // === AGORA QUESTS (3) ===
    quest_agora_001: {
      id: 'quest_agora_001',
      title: 'Market Day Delivery',
      description: 'Deliver goods to 3 different merchants in the Agora',
      giverNpcId: 'ai_citizen_003',
      type: 'deliver',
      objectives: [
        { type: 'deliver_merchants', count: 3, current: 0 }
      ],
      rewards: { spark: 40, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Market day is busy! Can you deliver these packages to 3 different merchants for me?",
        progress: "You've delivered to {current} merchants. {remaining} more to go!",
        complete: "Wonderful! You've helped keep commerce flowing. Thank you!"
      },
      status: 'available'
    },

    quest_agora_002: {
      id: 'quest_agora_002',
      title: 'The Trading Game',
      description: 'Complete 2 successful trades with other players',
      giverNpcId: 'ai_citizen_009',
      type: 'social',
      objectives: [
        { type: 'trade', count: 2, current: 0 }
      ],
      rewards: { spark: 60, items: [{ id: 'merchant_badge', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Trade is the foundation of community. Complete 2 successful trades with others!",
        progress: "You've completed {current} trades. {remaining} more to go!",
        complete: "Excellent trading! Take this merchant badge as recognition of your skills."
      },
      status: 'available'
    },

    quest_agora_003: {
      id: 'quest_agora_003',
      title: 'Supply and Demand',
      description: 'Gather market data by speaking to 5 merchants',
      giverNpcId: 'ai_citizen_015',
      type: 'social',
      objectives: [
        { type: 'talk_merchants', count: 5, current: 0 }
      ],
      rewards: { spark: 50, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Help me understand the market! Speak with 5 merchants about their current needs.",
        progress: "You've surveyed {current} merchants. {remaining} more to survey!",
        complete: "Perfect data! This will help optimize our market. Thank you!"
      },
      status: 'available'
    },

    // === COMMONS QUESTS (3) ===
    quest_commons_001: {
      id: 'quest_commons_001',
      title: 'Community Building',
      description: 'Contribute 5 building materials to the Commons project',
      giverNpcId: 'ai_citizen_021',
      type: 'gather',
      objectives: [
        { type: 'contribute', item: 'building_material', count: 5, current: 0 }
      ],
      rewards: { spark: 55, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "We're building something wonderful for everyone! Contribute 5 building materials to help!",
        progress: "You've contributed {current} materials. We need {remaining} more!",
        complete: "Thank you! Your contribution makes our community stronger!"
      },
      status: 'available'
    },

    quest_commons_002: {
      id: 'quest_commons_002',
      title: 'The Gathering',
      description: 'Attend a community gathering with at least 3 other players',
      giverNpcId: 'ai_citizen_027',
      type: 'social',
      objectives: [
        { type: 'attend_gathering', players: 3, current: 0 }
      ],
      rewards: { spark: 70, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Community is about togetherness. Join a gathering with at least 3 other people!",
        progress: "The gathering needs {remaining} more participants!",
        complete: "What a wonderful gathering! Community is our greatest strength."
      },
      status: 'available'
    },

    quest_commons_003: {
      id: 'quest_commons_003',
      title: 'Helping Hands',
      description: 'Help 4 different citizens with their daily tasks',
      giverNpcId: 'ai_citizen_033',
      type: 'social',
      objectives: [
        { type: 'help_citizens', count: 4, current: 0 }
      ],
      rewards: { spark: 65, items: [{ id: 'helper_ribbon', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Many people need assistance. Help 4 different citizens with their tasks!",
        progress: "You've helped {current} citizens. {remaining} more need your help!",
        complete: "You're a true helper! Wear this ribbon with pride."
      },
      status: 'available'
    },

    // === ARENA QUESTS (2) ===
    quest_arena_001: {
      id: 'quest_arena_001',
      title: 'Training Day',
      description: 'Complete 3 training exercises in the Arena',
      giverNpcId: 'ai_citizen_039',
      type: 'craft',
      objectives: [
        { type: 'train', count: 3, current: 0 }
      ],
      rewards: { spark: 45, items: [] },
      requiredLevel: 0,
      prerequisiteQuests: [],
      repeatable: true,
      timeLimit: 0,
      dialogue: {
        offer: "Physical and mental training keeps us sharp! Complete 3 training exercises!",
        progress: "You've completed {current} exercises. {remaining} more to go!",
        complete: "Well done! Regular training builds character and strength."
      },
      status: 'available'
    },

    quest_arena_002: {
      id: 'quest_arena_002',
      title: 'Champion\'s Path',
      description: 'Achieve a perfect score in an Arena challenge',
      giverNpcId: 'ai_citizen_045',
      type: 'craft',
      objectives: [
        { type: 'perfect_score', current: 0 }
      ],
      rewards: { spark: 100, items: [{ id: 'champion_medal', count: 1 }] },
      requiredLevel: 0,
      prerequisiteQuests: ['quest_arena_001'],
      repeatable: false,
      timeLimit: 0,
      dialogue: {
        offer: "Only the dedicated achieve perfection. Score perfectly in an Arena challenge!",
        progress: "Perfection requires focus and practice. Keep training!",
        complete: "Incredible! You've achieved perfection. This medal marks your mastery."
      },
      status: 'available'
    }
  };

  // Player quest state storage
  const playerQuestStates = new Map(); // playerId -> { activeQuests: [], completedQuests: [], turnedInQuests: [] }
  const MAX_ACTIVE_QUESTS = 5;

  /**
   * Initialize quest system for a player
   * @param {string} playerId
   */
  function initPlayerQuests(playerId) {
    if (!playerQuestStates.has(playerId)) {
      playerQuestStates.set(playerId, {
        activeQuests: [],
        completedQuests: [],
        turnedInQuests: []
      });
    }
  }

  /**
   * Get all quests available to a player (based on level, prerequisites)
   * @param {string} playerId
   * @param {object} playerData - {level, position, etc.}
   * @returns {Array} Available quests
   */
  function getAvailableQuests(playerId, playerData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const available = [];
    for (const questId in QUEST_DATABASE) {
      const quest = QUEST_DATABASE[questId];

      // Skip if already active or turned in (unless repeatable)
      if (state.activeQuests.find(q => q.id === questId)) continue;
      if (!quest.repeatable && state.turnedInQuests.includes(questId)) continue;

      // Check level requirement
      if (quest.requiredLevel > (playerData.level || 0)) continue;

      // Check prerequisites
      let prereqsMet = true;
      for (const prereqId of quest.prerequisiteQuests) {
        if (!state.turnedInQuests.includes(prereqId)) {
          prereqsMet = false;
          break;
        }
      }
      if (!prereqsMet) continue;

      available.push(Object.assign({}, quest));
    }

    return available;
  }

  /**
   * Accept a quest
   * @param {string} playerId
   * @param {string} questId
   * @returns {object} {success: boolean, message: string, quest?: object}
   */
  function acceptQuest(playerId, questId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    // Check if quest exists
    if (!QUEST_DATABASE[questId]) {
      return { success: false, message: 'Quest not found' };
    }

    // Check if already active
    if (state.activeQuests.find(q => q.id === questId)) {
      return { success: false, message: 'Quest already active' };
    }

    // Check active quest limit
    if (state.activeQuests.length >= MAX_ACTIVE_QUESTS) {
      return { success: false, message: 'Too many active quests (max 5)' };
    }

    // Clone quest with fresh objectives
    const quest = JSON.parse(JSON.stringify(QUEST_DATABASE[questId]));
    quest.status = 'active';
    quest.startTime = Date.now();

    state.activeQuests.push(quest);

    return { success: true, message: 'Quest accepted', quest: quest };
  }

  /**
   * Update quest progress based on player action
   * @param {string} playerId
   * @param {string} eventType - 'collect', 'talk_npc', 'visit_zone', etc.
   * @param {object} eventData - Event-specific data
   * @returns {Array} Quests that were updated
   */
  function updateQuestProgress(playerId, eventType, eventData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);
    const updatedQuests = [];

    for (const quest of state.activeQuests) {
      let questUpdated = false;

      for (const objective of quest.objectives) {
        // Match event type to objective type
        let match = false;

        switch (objective.type) {
          case 'collect':
            match = eventType === 'collect' && eventData.item === objective.item;
            break;
          case 'talk_npcs':
          case 'talk_scholars':
          case 'talk_merchants':
            match = eventType === 'talk_npc';
            break;
          case 'visit_zones':
            match = eventType === 'visit_zone';
            if (match && !objective.zones.includes(eventData.zone)) {
              objective.zones.push(eventData.zone);
            }
            break;
          case 'deliver':
            match = eventType === 'deliver' && eventData.npcId === objective.npcId;
            break;
          case 'plant':
            match = eventType === 'plant' && eventData.item === objective.item;
            break;
          case 'create':
          case 'compose':
          case 'paint_mural':
          case 'train':
            match = eventType === objective.type;
            break;
          case 'trade':
            match = eventType === 'trade';
            break;
          case 'deliver_merchants':
            match = eventType === 'deliver_merchant';
            break;
          case 'contribute':
            match = eventType === 'contribute' && eventData.item === objective.item;
            break;
          case 'discover':
            match = eventType === 'discover' && eventData.location === objective.location;
            break;
          case 'observe':
            match = eventType === 'observe' && eventData.category === objective.category;
            break;
          case 'place_marker':
            match = eventType === 'place_marker';
            break;
          case 'read':
            match = eventType === 'read' && eventData.item === objective.item;
            break;
          case 'attend_gathering':
            match = eventType === 'attend_gathering';
            break;
          case 'help_citizens':
            match = eventType === 'help_citizen';
            break;
          case 'perfect_score':
            match = eventType === 'perfect_score';
            break;
        }

        if (match) {
          // Increment progress
          if (objective.type === 'visit_zones') {
            objective.current = objective.zones.length;
          } else {
            objective.current = Math.min(objective.current + (eventData.amount || 1), objective.count || 1);
          }
          questUpdated = true;
        }
      }

      // Check if quest is complete
      if (questUpdated) {
        const allComplete = quest.objectives.every(obj => {
          if (obj.required !== undefined) return obj.current >= obj.required;
          if (obj.count !== undefined) return obj.current >= obj.count;
          return obj.current >= 1;
        });

        if (allComplete) {
          quest.status = 'complete';
          state.completedQuests.push(quest.id);
        }

        updatedQuests.push(quest);
      }
    }

    return updatedQuests;
  }

  /**
   * Complete a quest and award rewards
   * @param {string} playerId
   * @param {string} questId
   * @param {object} gameState - Game state for awarding Spark
   * @returns {object} {success: boolean, rewards?: object}
   */
  function completeQuest(playerId, questId, gameState) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    // Find quest in active quests
    const questIndex = state.activeQuests.findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return { success: false, message: 'Quest not active' };
    }

    const quest = state.activeQuests[questIndex];

    // Check if complete
    if (quest.status !== 'complete') {
      return { success: false, message: 'Quest objectives not complete' };
    }

    // Award Spark via Economy module
    if (quest.rewards.spark > 0 && gameState && window.Economy) {
      window.Economy.earnSpark(gameState, playerId, quest.rewards.spark);
    }

    // Award items (inventory system would handle this - for now just return them)
    const rewards = {
      spark: quest.rewards.spark,
      items: quest.rewards.items
    };

    // Mark quest as turned in
    if (!state.turnedInQuests.includes(questId)) {
      state.turnedInQuests.push(questId);
    }

    // Remove from active quests
    state.activeQuests.splice(questIndex, 1);

    return { success: true, rewards: rewards, quest: quest };
  }

  /**
   * Get all active quests for a player
   * @param {string} playerId
   * @returns {Array} Active quests
   */
  function getActiveQuests(playerId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);
    return state.activeQuests.slice();
  }

  /**
   * Get quest log (all quests with status)
   * @param {string} playerId
   * @returns {object} {active: [], completed: [], available: []}
   */
  function getQuestLog(playerId, playerData) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    return {
      active: state.activeQuests.slice(),
      completed: state.completedQuests.slice(),
      available: getAvailableQuests(playerId, playerData || {})
    };
  }

  /**
   * Get dialogue for a quest based on status
   * @param {string} questId
   * @param {string} status - 'offer', 'progress', 'complete'
   * @param {object} quest - Quest object (for progress interpolation)
   * @returns {string} Dialogue text
   */
  function getQuestDialogue(questId, status, quest) {
    const questTemplate = QUEST_DATABASE[questId];
    if (!questTemplate || !questTemplate.dialogue[status]) {
      return '';
    }

    let dialogue = questTemplate.dialogue[status];

    // Interpolate progress variables
    if (quest && status === 'progress') {
      const objective = quest.objectives[0]; // Use first objective for now
      if (objective) {
        const required = objective.required || objective.count || 1;
        const remaining = required - objective.current;
        dialogue = dialogue.replace('{current}', objective.current);
        dialogue = dialogue.replace('{remaining}', remaining);
      }
    }

    return dialogue;
  }

  /**
   * Get quests offered by a specific NPC
   * @param {string} npcId
   * @param {string} playerId
   * @returns {Array} Quests from this NPC
   */
  function getNpcQuests(npcId, playerId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const npcQuests = [];

    for (const questId in QUEST_DATABASE) {
      const quest = QUEST_DATABASE[questId];
      if (quest.giverNpcId !== npcId) continue;

      // Check if active
      const activeQuest = state.activeQuests.find(q => q.id === questId);
      if (activeQuest) {
        npcQuests.push({ quest: activeQuest, state: activeQuest.status });
        continue;
      }

      // Check if available
      if (!quest.repeatable && state.turnedInQuests.includes(questId)) {
        continue; // Already completed, not repeatable
      }

      // Check prerequisites
      let available = true;
      for (const prereqId of quest.prerequisiteQuests) {
        if (!state.turnedInQuests.includes(prereqId)) {
          available = false;
          break;
        }
      }

      if (available) {
        npcQuests.push({ quest: Object.assign({}, quest), state: 'available' });
      }
    }

    return npcQuests;
  }

  /**
   * Abandon a quest
   * @param {string} playerId
   * @param {string} questId
   * @returns {object} {success: boolean}
   */
  function abandonQuest(playerId, questId) {
    initPlayerQuests(playerId);
    const state = playerQuestStates.get(playerId);

    const questIndex = state.activeQuests.findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return { success: false, message: 'Quest not active' };
    }

    state.activeQuests.splice(questIndex, 1);
    return { success: true };
  }

  // ========================================================================
  // DAILY QUEST SYSTEM â€” Rotating quests that refresh daily
  // ========================================================================

  var DAILY_QUESTS = [
    {
      id: 'daily_social',
      title: 'Social Butterfly',
      description: 'Talk to 5 different NPCs today',
      objectives: [{ type: 'talk_npcs', count: 5, current: 0 }],
      rewards: { spark: 20, items: [] },
      dialogue: {
        offer: "Today's challenge: connect with 5 different citizens. Every conversation enriches ZION.",
        progress: "You've chatted with {current} NPCs. {remaining} more to go!",
        complete: "What a social day! Here's your daily Spark reward."
      }
    },
    {
      id: 'daily_explorer',
      title: 'Daily Explorer',
      description: 'Visit 4 different zones today',
      objectives: [{ type: 'visit_zones', zones: [], required: 4, current: 0 }],
      rewards: { spark: 25, items: [] },
      dialogue: {
        offer: "Stretch your legs! Visit 4 different zones to earn your daily exploration reward.",
        progress: "You've visited {current} zones. {remaining} more await!",
        complete: "A well-traveled day! The world rewards your curiosity."
      }
    },
    {
      id: 'daily_gatherer',
      title: 'Daily Harvest',
      description: 'Harvest 5 resources today',
      objectives: [{ type: 'collect', item: 'resource', count: 5, current: 0 }],
      rewards: { spark: 15, items: [] },
      dialogue: {
        offer: "The gardens are abundant today. Harvest 5 resources to earn your daily reward.",
        progress: "Harvested {current} of 5 resources.",
        complete: "A productive day! Nature provides for those who tend it."
      }
    },
    {
      id: 'daily_trader',
      title: 'Market Day',
      description: 'Complete 1 trade with another player',
      objectives: [{ type: 'trade', count: 1, current: 0 }],
      rewards: { spark: 30, items: [] },
      dialogue: {
        offer: "The Agora thrives on trade. Complete one trade today to keep the economy flowing.",
        progress: "You haven't traded yet today. Find a partner!",
        complete: "A fair trade benefits everyone. Well done, merchant!"
      }
    },
    {
      id: 'daily_crafter',
      title: 'Creative Day',
      description: 'Craft 2 items today',
      objectives: [{ type: 'craft', count: 2, current: 0 }],
      rewards: { spark: 20, items: [] },
      dialogue: {
        offer: "Creation is at the heart of ZION. Craft 2 items today to earn your reward.",
        progress: "Crafted {current} of 2 items.",
        complete: "Your hands have shaped the world today. Well crafted!"
      }
    },
    {
      id: 'daily_builder',
      title: 'Construction Day',
      description: 'Place 2 structures today',
      objectives: [{ type: 'build', count: 2, current: 0 }],
      rewards: { spark: 25, items: [] },
      dialogue: {
        offer: "The Commons could use some new structures. Place 2 buildings today.",
        progress: "Placed {current} of 2 structures.",
        complete: "Your buildings will stand as testament to today's work!"
      }
    },
    {
      id: 'daily_wanderer',
      title: 'Long Walk',
      description: 'Walk a total of 500 units today',
      objectives: [{ type: 'walk_distance', distance: 500, current: 0 }],
      rewards: { spark: 15, items: [] },
      dialogue: {
        offer: "Sometimes the journey matters more than the destination. Walk 500 units today.",
        progress: "You've walked {current} of 500 units.",
        complete: "Every step is a story. Well walked!"
      }
    }
  ];

  function getDailyQuests() {
    // Use the day of year to rotate which 3 dailies are available
    var now = new Date();
    var dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
    var dailies = [];
    for (var i = 0; i < 3; i++) {
      var idx = (dayOfYear + i) % DAILY_QUESTS.length;
      var daily = JSON.parse(JSON.stringify(DAILY_QUESTS[idx]));
      daily.id = 'daily_' + dayOfYear + '_' + i;
      daily.type = 'daily';
      daily.repeatable = false;
      daily.requiredLevel = 0;
      daily.prerequisiteQuests = [];
      daily.timeLimit = 0;
      daily.giverNpcId = 'ai_citizen_001'; // Default quest giver
      daily.status = 'available';
      dailies.push(daily);
    }
    return dailies;
  }

  function isDailyCompleted(playerId, dailyId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    return state.turnedInQuests.indexOf(dailyId) !== -1;
  }

  // ========================================================================
  // QUEST CHAINS â€” Multi-part story quests
  // ========================================================================

  var QUEST_CHAINS = {
    'chain_origins': {
      name: 'Origins of ZION',
      description: 'Discover the history of how ZION came to be',
      quests: ['quest_nexus_001', 'quest_nexus_002'],
      reward: { spark: 100, title: 'Historian' }
    },
    'chain_garden_master': {
      name: 'Garden Master',
      description: 'Complete all garden quests to earn the title of Garden Master',
      quests: ['quest_gardens_001', 'quest_gardens_002', 'quest_gardens_003', 'quest_gardens_004', 'quest_gardens_005'],
      reward: { spark: 150, title: 'Garden Master' }
    },
    'chain_scholar': {
      name: 'Scholar of the Athenaeum',
      description: 'Complete all knowledge quests',
      quests: ['quest_athenaeum_001', 'quest_athenaeum_002', 'quest_athenaeum_003'],
      reward: { spark: 120, title: 'Scholar' }
    },
    'chain_artisan': {
      name: 'Master Artisan',
      description: 'Complete all studio crafting quests',
      quests: ['quest_studio_001', 'quest_studio_002'],
      reward: { spark: 100, title: 'Artisan' }
    },
    'chain_explorer': {
      name: 'True Explorer',
      description: 'Visit every zone and complete all exploration quests',
      quests: ['quest_nexus_002', 'quest_wilds_001', 'quest_wilds_002', 'quest_wilds_003'],
      reward: { spark: 200, title: 'True Explorer' }
    }
  };

  function getChainProgress(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    var progress = {};

    for (var chainId in QUEST_CHAINS) {
      var chain = QUEST_CHAINS[chainId];
      var completed = 0;
      for (var i = 0; i < chain.quests.length; i++) {
        if (state.turnedInQuests.indexOf(chain.quests[i]) !== -1) {
          completed++;
        }
      }
      progress[chainId] = {
        name: chain.name,
        description: chain.description,
        completed: completed,
        total: chain.quests.length,
        isComplete: completed >= chain.quests.length,
        reward: chain.reward
      };
    }

    return progress;
  }

  function checkChainCompletion(playerId) {
    var progress = getChainProgress(playerId);
    var newlyCompleted = [];

    for (var chainId in progress) {
      var chain = progress[chainId];
      if (chain.isComplete) {
        initPlayerQuests(playerId);
        var state = playerQuestStates.get(playerId);
        if (!state.completedChains) state.completedChains = [];
        if (state.completedChains.indexOf(chainId) === -1) {
          state.completedChains.push(chainId);
          newlyCompleted.push({
            chainId: chainId,
            name: chain.name,
            reward: chain.reward
          });
        }
      }
    }

    return newlyCompleted;
  }

  // ========================================================================
  // PLAYER STATS from quests
  // ========================================================================

  function getPlayerQuestStats(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);

    return {
      activeQuests: state.activeQuests.length,
      completedQuests: state.turnedInQuests.length,
      totalAvailable: Object.keys(QUEST_DATABASE).length,
      completedChains: (state.completedChains || []).length,
      totalChains: Object.keys(QUEST_CHAINS).length,
      titles: (state.completedChains || []).map(function(chainId) {
        return QUEST_CHAINS[chainId] ? QUEST_CHAINS[chainId].reward.title : null;
      }).filter(Boolean)
    };
  }

  // ========================================================================
  // ACHIEVEMENT / BADGE SYSTEM
  // ========================================================================

  var ACHIEVEMENTS = {
    // Exploration
    first_steps: { id: 'first_steps', name: 'First Steps', description: 'Enter ZION for the first time', icon: 'ðŸ‘£', category: 'exploration', sparkReward: 10 },
    zone_hopper: { id: 'zone_hopper', name: 'Zone Hopper', description: 'Visit 4 different zones', icon: 'ðŸš¶', category: 'exploration', sparkReward: 25 },
    world_traveler: { id: 'world_traveler', name: 'World Traveler', description: 'Visit all 8 zones', icon: 'ðŸŒ', category: 'exploration', sparkReward: 75 },
    trailblazer: { id: 'trailblazer', name: 'Trailblazer', description: 'Make 10 discoveries', icon: 'ðŸ”', category: 'exploration', sparkReward: 50 },
    cartographer: { id: 'cartographer', name: 'Cartographer', description: 'Make 25 discoveries', icon: 'ðŸ—ºï¸', category: 'exploration', sparkReward: 100 },

    // Social
    friendly_face: { id: 'friendly_face', name: 'Friendly Face', description: 'Talk to 10 NPCs', icon: 'ðŸ˜Š', category: 'social', sparkReward: 15 },
    social_butterfly: { id: 'social_butterfly', name: 'Social Butterfly', description: 'Talk to 50 NPCs', icon: 'ðŸ¦‹', category: 'social', sparkReward: 40 },
    first_trade: { id: 'first_trade', name: 'First Trade', description: 'Complete your first trade', icon: 'ðŸ¤', category: 'social', sparkReward: 20 },
    merchant_prince: { id: 'merchant_prince', name: 'Merchant Prince', description: 'Complete 25 trades', icon: 'ðŸ‘‘', category: 'social', sparkReward: 75 },
    gift_giver: { id: 'gift_giver', name: 'Gift Giver', description: 'Gift an item to another player', icon: 'ðŸŽ', category: 'social', sparkReward: 15 },

    // Crafting
    first_craft: { id: 'first_craft', name: 'First Craft', description: 'Craft your first item', icon: 'ðŸ”¨', category: 'crafting', sparkReward: 10 },
    apprentice_crafter: { id: 'apprentice_crafter', name: 'Apprentice Crafter', description: 'Craft 10 items', icon: 'âš’ï¸', category: 'crafting', sparkReward: 30 },
    master_crafter: { id: 'master_crafter', name: 'Master Crafter', description: 'Craft 50 items', icon: 'ðŸ› ï¸', category: 'crafting', sparkReward: 80 },
    potion_brewer: { id: 'potion_brewer', name: 'Potion Brewer', description: 'Brew 10 potions', icon: 'ðŸ§ª', category: 'crafting', sparkReward: 25 },
    instrument_maker: { id: 'instrument_maker', name: 'Instrument Maker', description: 'Craft a musical instrument', icon: 'ðŸŽµ', category: 'crafting', sparkReward: 20 },

    // Building
    first_build: { id: 'first_build', name: 'First Build', description: 'Place your first structure', icon: 'ðŸ—ï¸', category: 'building', sparkReward: 10 },
    architect: { id: 'architect', name: 'Architect', description: 'Place 10 structures', icon: 'ðŸ›ï¸', category: 'building', sparkReward: 40 },
    city_planner: { id: 'city_planner', name: 'City Planner', description: 'Place 50 structures', icon: 'ðŸ™ï¸', category: 'building', sparkReward: 100 },

    // Gardening
    green_thumb: { id: 'green_thumb', name: 'Green Thumb', description: 'Plant your first seed', icon: 'ðŸŒ±', category: 'gardening', sparkReward: 10 },
    gardener: { id: 'gardener', name: 'Gardener', description: 'Harvest 20 plants', icon: 'ðŸŒ»', category: 'gardening', sparkReward: 30 },
    botanist: { id: 'botanist', name: 'Botanist', description: 'Harvest 100 plants', icon: 'ðŸŒ¿', category: 'gardening', sparkReward: 80 },

    // Economy
    spark_saver: { id: 'spark_saver', name: 'Spark Saver', description: 'Accumulate 100 Spark', icon: 'âœ¨', category: 'economy', sparkReward: 10 },
    spark_hoarder: { id: 'spark_hoarder', name: 'Spark Hoarder', description: 'Accumulate 500 Spark', icon: 'ðŸ’°', category: 'economy', sparkReward: 25 },
    spark_magnate: { id: 'spark_magnate', name: 'Spark Magnate', description: 'Accumulate 2000 Spark', icon: 'ðŸ’Ž', category: 'economy', sparkReward: 75 },

    // Competition
    first_challenge: { id: 'first_challenge', name: 'First Challenge', description: 'Participate in your first competition', icon: 'âš”ï¸', category: 'competition', sparkReward: 15 },
    champion: { id: 'champion', name: 'Champion', description: 'Win 5 competitions', icon: 'ðŸ†', category: 'competition', sparkReward: 50 },

    // Quests
    quest_starter: { id: 'quest_starter', name: 'Quest Starter', description: 'Accept your first quest', icon: 'ðŸ“‹', category: 'quests', sparkReward: 5 },
    questmaster: { id: 'questmaster', name: 'Questmaster', description: 'Complete 10 quests', icon: 'ðŸ“œ', category: 'quests', sparkReward: 40 },
    completionist: { id: 'completionist', name: 'Completionist', description: 'Complete 25 quests', icon: 'â­', category: 'quests', sparkReward: 100 },
    chain_finisher: { id: 'chain_finisher', name: 'Chain Finisher', description: 'Complete a quest chain', icon: 'ðŸ”—', category: 'quests', sparkReward: 30 },

    // Guild
    guild_founder: { id: 'guild_founder', name: 'Guild Founder', description: 'Create a guild', icon: 'ðŸ°', category: 'guild', sparkReward: 25 },
    guild_member: { id: 'guild_member', name: 'Guild Member', description: 'Join a guild', icon: 'ðŸ¤œ', category: 'guild', sparkReward: 10 },

    // Art
    first_artwork: { id: 'first_artwork', name: 'First Artwork', description: 'Create your first artwork', icon: 'ðŸŽ¨', category: 'art', sparkReward: 15 },
    prolific_artist: { id: 'prolific_artist', name: 'Prolific Artist', description: 'Create 10 artworks', icon: 'ðŸ–¼ï¸', category: 'art', sparkReward: 40 },

    // Physical
    sunwalker: { id: 'sunwalker', name: 'Sunwalker', description: 'Reach Sunwalker warmth tier', icon: 'â˜€ï¸', category: 'physical', sparkReward: 50 },

    // Mentoring
    first_lesson: { id: 'first_lesson', name: 'First Lesson', description: 'Complete a mentoring lesson', icon: 'ðŸ“š', category: 'mentoring', sparkReward: 15 },
    wise_mentor: { id: 'wise_mentor', name: 'Wise Mentor', description: 'Mentor 5 players', icon: 'ðŸŽ“', category: 'mentoring', sparkReward: 50 }
  };

  // Player achievement tracking
  var playerAchievements = new Map(); // playerId -> { unlocked: Set, counters: {} }

  function initPlayerAchievements(playerId) {
    if (!playerAchievements.has(playerId)) {
      playerAchievements.set(playerId, {
        unlocked: new Set(),
        counters: {
          npcs_talked: 0,
          zones_visited: new Set(),
          trades_completed: 0,
          items_crafted: 0,
          potions_brewed: 0,
          structures_placed: 0,
          plants_harvested: 0,
          seeds_planted: 0,
          discoveries_made: 0,
          competitions_entered: 0,
          competitions_won: 0,
          quests_completed: 0,
          artworks_created: 0,
          players_mentored: 0,
          lessons_completed: 0,
          gifts_given: 0
        }
      });
    }
    return playerAchievements.get(playerId);
  }

  /**
   * Track an event and check for newly unlocked achievements
   * @param {string} playerId
   * @param {string} eventType - e.g. 'craft', 'trade', 'visit_zone', 'talk_npc'
   * @param {Object} eventData - event-specific data
   * @returns {Array} Newly unlocked achievements
   */
  function trackAchievementEvent(playerId, eventType, eventData) {
    var state = initPlayerAchievements(playerId);
    eventData = eventData || {};

    // Update counters based on event
    switch (eventType) {
      case 'login':
        break; // first_steps checked separately
      case 'talk_npc':
        state.counters.npcs_talked++;
        break;
      case 'visit_zone':
        if (eventData.zone) state.counters.zones_visited.add(eventData.zone);
        break;
      case 'trade':
        state.counters.trades_completed++;
        break;
      case 'craft':
        state.counters.items_crafted++;
        if (eventData.category === 'potion') state.counters.potions_brewed++;
        break;
      case 'build':
        state.counters.structures_placed++;
        break;
      case 'harvest':
        state.counters.plants_harvested++;
        break;
      case 'plant':
        state.counters.seeds_planted++;
        break;
      case 'discover':
        state.counters.discoveries_made++;
        break;
      case 'competition_enter':
        state.counters.competitions_entered++;
        break;
      case 'competition_win':
        state.counters.competitions_won++;
        break;
      case 'quest_complete':
        state.counters.quests_completed++;
        break;
      case 'artwork':
        state.counters.artworks_created++;
        break;
      case 'mentor':
        state.counters.players_mentored++;
        break;
      case 'lesson':
        state.counters.lessons_completed++;
        break;
      case 'gift':
        state.counters.gifts_given++;
        break;
    }

    // Check all achievements
    var newlyUnlocked = [];
    var checks = {
      first_steps: eventType === 'login',
      zone_hopper: state.counters.zones_visited.size >= 4,
      world_traveler: state.counters.zones_visited.size >= 8,
      trailblazer: state.counters.discoveries_made >= 10,
      cartographer: state.counters.discoveries_made >= 25,
      friendly_face: state.counters.npcs_talked >= 10,
      social_butterfly: state.counters.npcs_talked >= 50,
      first_trade: state.counters.trades_completed >= 1,
      merchant_prince: state.counters.trades_completed >= 25,
      gift_giver: state.counters.gifts_given >= 1,
      first_craft: state.counters.items_crafted >= 1,
      apprentice_crafter: state.counters.items_crafted >= 10,
      master_crafter: state.counters.items_crafted >= 50,
      potion_brewer: state.counters.potions_brewed >= 10,
      instrument_maker: eventType === 'craft' && eventData.category === 'instrument',
      first_build: state.counters.structures_placed >= 1,
      architect: state.counters.structures_placed >= 10,
      city_planner: state.counters.structures_placed >= 50,
      green_thumb: state.counters.seeds_planted >= 1,
      gardener: state.counters.plants_harvested >= 20,
      botanist: state.counters.plants_harvested >= 100,
      spark_saver: eventData.spark >= 100,
      spark_hoarder: eventData.spark >= 500,
      spark_magnate: eventData.spark >= 2000,
      first_challenge: state.counters.competitions_entered >= 1,
      champion: state.counters.competitions_won >= 5,
      quest_starter: state.counters.quests_completed >= 0 && eventType === 'quest_accept',
      questmaster: state.counters.quests_completed >= 10,
      completionist: state.counters.quests_completed >= 25,
      chain_finisher: eventType === 'chain_complete',
      guild_founder: eventType === 'guild_create',
      guild_member: eventType === 'guild_join',
      first_artwork: state.counters.artworks_created >= 1,
      prolific_artist: state.counters.artworks_created >= 10,
      sunwalker: eventType === 'warmth_tier' && eventData.tier === 'Sunwalker',
      first_lesson: state.counters.lessons_completed >= 1,
      wise_mentor: state.counters.players_mentored >= 5
    };

    for (var achId in checks) {
      if (checks[achId] && !state.unlocked.has(achId) && ACHIEVEMENTS[achId]) {
        state.unlocked.add(achId);
        newlyUnlocked.push(ACHIEVEMENTS[achId]);
      }
    }

    return newlyUnlocked;
  }

  /**
   * Get all achievements with unlock status
   * @param {string} playerId
   * @returns {Array} All achievements with unlocked status
   */
  function getAchievements(playerId) {
    var state = initPlayerAchievements(playerId);
    var result = [];

    for (var achId in ACHIEVEMENTS) {
      var ach = ACHIEVEMENTS[achId];
      result.push({
        id: ach.id,
        name: ach.name,
        description: ach.description,
        icon: ach.icon,
        category: ach.category,
        sparkReward: ach.sparkReward,
        unlocked: state.unlocked.has(achId)
      });
    }

    return result;
  }

  /**
   * Get achievement progress summary
   * @param {string} playerId
   * @returns {Object} {unlocked, total, percentage, recentUnlocks}
   */
  function getAchievementProgress(playerId) {
    var state = initPlayerAchievements(playerId);
    var total = Object.keys(ACHIEVEMENTS).length;
    var unlocked = state.unlocked.size;

    return {
      unlocked: unlocked,
      total: total,
      percentage: total > 0 ? Math.round((unlocked / total) * 100) : 0,
      counters: {
        npcs_talked: state.counters.npcs_talked,
        zones_visited: state.counters.zones_visited.size,
        trades_completed: state.counters.trades_completed,
        items_crafted: state.counters.items_crafted,
        structures_placed: state.counters.structures_placed,
        quests_completed: state.counters.quests_completed,
        discoveries_made: state.counters.discoveries_made
      }
    };
  }

  function getCompletedQuests(playerId) {
    initPlayerQuests(playerId);
    var state = playerQuestStates.get(playerId);
    return state ? state.turnedInQuests : [];
  }

  // Export public API
  exports.getCompletedQuests = getCompletedQuests;
  exports.getAvailableQuests = getAvailableQuests;
  exports.acceptQuest = acceptQuest;
  exports.updateQuestProgress = updateQuestProgress;
  exports.completeQuest = completeQuest;
  exports.getActiveQuests = getActiveQuests;
  exports.getQuestLog = getQuestLog;
  exports.getQuestDialogue = getQuestDialogue;
  exports.getNpcQuests = getNpcQuests;
  exports.abandonQuest = abandonQuest;
  exports.initPlayerQuests = initPlayerQuests;
  exports.getDailyQuests = getDailyQuests;
  exports.isDailyCompleted = isDailyCompleted;
  exports.getChainProgress = getChainProgress;
  exports.checkChainCompletion = checkChainCompletion;
  exports.getPlayerQuestStats = getPlayerQuestStats;
  exports.QUEST_CHAINS = QUEST_CHAINS;
  exports.DAILY_QUESTS = DAILY_QUESTS;
  exports.ACHIEVEMENTS = ACHIEVEMENTS;
  exports.trackAchievementEvent = trackAchievementEvent;
  exports.getAchievements = getAchievements;
  exports.getAchievementProgress = getAchievementProgress;
  exports.initPlayerAchievements = initPlayerAchievements;

})(typeof module !== 'undefined' ? module.exports : (window.Quests = {}));


// competition.js
(function(exports) {

  // Competition types
  const COMPETITION_TYPES = ['duel', 'race', 'puzzle_race', 'build_contest', 'music_battle'];

  // Pending challenges store
  const pendingChallenges = {};

  // Spark awards by competition type
  const SPARK_AWARDS = {
    duel: 50,
    race: 30,
    puzzle_race: 40,
    build_contest: 100,
    music_battle: 60
  };

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Handle challenge creation
  function handleChallenge(msg, state, zoneRules) {
    if (!zoneRules.competition || !zoneRules.pvp) {
      return {
        success: false,
        error: 'Competition not allowed in this zone'
      };
    }

    const challengeType = msg.payload.type;
    if (!COMPETITION_TYPES.includes(challengeType)) {
      return {
        success: false,
        error: 'Invalid competition type'
      };
    }

    const challengeId = generateId();
    const challenge = {
      id: challengeId,
      challenger: msg.from,
      challenged: msg.payload.to,
      type: challengeType,
      rules: msg.payload.rules || {},
      ts: Date.now()
    };

    pendingChallenges[challengeId] = challenge;

    return {
      success: true,
      pendingChallenge: challenge
    };
  }

  // Handle challenge acceptance
  function handleAcceptChallenge(msg, state) {
    const playerId = msg.from;

    // Find pending challenge targeting this player
    let foundChallenge = null;
    let challengeId = null;

    for (const [id, challenge] of Object.entries(pendingChallenges)) {
      if (challenge.challenged === playerId) {
        foundChallenge = challenge;
        challengeId = id;
        break;
      }
    }

    if (!foundChallenge) {
      return {
        success: false,
        error: 'No pending challenge found'
      };
    }

    // Create active competition
    const competition = {
      id: generateId(),
      players: [foundChallenge.challenger, foundChallenge.challenged],
      type: foundChallenge.type,
      rules: foundChallenge.rules,
      startedAt: Date.now(),
      scores: {},
      status: 'active'
    };

    // Initialize state.competitions if needed
    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(competition);

    // Remove from pending challenges
    delete pendingChallenges[challengeId];

    return {
      success: true,
      competition: competition,
      state: state
    };
  }

  // Handle forfeit
  function handleForfeit(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;

    // Find active competition involving this player
    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    // Determine winner (the other player)
    const winner = competition.players.find(p => p !== playerId);

    // Update competition status
    competition.status = 'completed';
    competition.winner = winner;
    competition.endedAt = Date.now();
    competition.forfeitedBy = playerId;

    // Calculate Spark award
    const sparkAward = SPARK_AWARDS[competition.type] || 20;

    return {
      success: true,
      state: state,
      winner: winner,
      sparkAward: sparkAward,
      competition: competition
    };
  }

  // Handle score submission
  function handleScore(msg, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return {
        success: false,
        error: 'No active competitions found'
      };
    }

    const playerId = msg.from;
    const score = msg.payload.score;

    // Find active competition involving this player
    const competitionIndex = state.competitions.findIndex(comp =>
      comp.status === 'active' && comp.players.includes(playerId)
    );

    if (competitionIndex === -1) {
      return {
        success: false,
        error: 'No active competition found for this player'
      };
    }

    const competition = state.competitions[competitionIndex];

    // Record score
    competition.scores[playerId] = score;

    // Check if both players have scored
    const allScored = competition.players.every(p =>
      competition.scores.hasOwnProperty(p)
    );

    let sparkAward = null;
    let winner = null;

    if (allScored) {
      // Determine winner (highest score)
      const scores = competition.players.map(p => ({
        player: p,
        score: competition.scores[p]
      }));

      scores.sort((a, b) => b.score - a.score);
      winner = scores[0].player;

      // Update competition status
      competition.status = 'completed';
      competition.winner = winner;
      competition.endedAt = Date.now();

      // Calculate Spark award
      sparkAward = SPARK_AWARDS[competition.type] || 20;
    }

    return {
      success: true,
      state: state,
      competition: competition,
      winner: winner,
      sparkAward: sparkAward
    };
  }

  // Get pending challenges for a player
  function getPendingChallenges(playerId) {
    return Object.values(pendingChallenges).filter(c =>
      c.challenged === playerId || c.challenger === playerId
    );
  }

  // Spectator tracking
  var spectators = {}; // competitionId â†’ [playerIds]

  // Join as spectator
  function joinAsSpectator(competitionId, playerId, state) {
    if (!state.competitions || state.competitions.length === 0) {
      return { success: false, error: 'No competitions found' };
    }

    var competition = state.competitions.find(function(c) {
      return c.id === competitionId;
    });

    if (!competition) {
      return { success: false, error: 'Competition not found' };
    }

    if (competition.status !== 'active') {
      return { success: false, error: 'Competition is not active' };
    }

    if (!spectators[competitionId]) {
      spectators[competitionId] = [];
    }

    if (spectators[competitionId].indexOf(playerId) === -1) {
      spectators[competitionId].push(playerId);
    }

    return { success: true, competition: competition };
  }

  // Leave spectator
  function leaveSpectator(competitionId, playerId) {
    if (!spectators[competitionId]) return;

    var index = spectators[competitionId].indexOf(playerId);
    if (index !== -1) {
      spectators[competitionId].splice(index, 1);
    }

    // Clean up empty spectator lists
    if (spectators[competitionId].length === 0) {
      delete spectators[competitionId];
    }
  }

  // Get spectators
  function getSpectators(competitionId) {
    return spectators[competitionId] || [];
  }

  // Get active competitions
  function getActiveCompetitions(state) {
    if (!state.competitions || state.competitions.length === 0) {
      return [];
    }

    return state.competitions
      .filter(function(c) { return c.status === 'active'; })
      .map(function(c) {
        return {
          id: c.id,
          type: c.type,
          players: c.players,
          startedAt: c.startedAt,
          spectatorCount: spectators[c.id] ? spectators[c.id].length : 0
        };
      });
  }

  // Broadcast to spectators
  function broadcastToSpectators(competitionId, eventType, data) {
    var spectatorList = spectators[competitionId] || [];

    return {
      type: 'spectator_event',
      competitionId: competitionId,
      eventType: eventType,
      data: data,
      spectators: spectatorList,
      timestamp: Date.now()
    };
  }

  // Get competition leaderboard
  function getCompetitionLeaderboard(state) {
    if (!state.competitions || state.competitions.length === 0) {
      return [];
    }

    var playerStats = {};

    state.competitions
      .filter(function(c) { return c.status === 'completed'; })
      .forEach(function(comp) {
        comp.players.forEach(function(playerId) {
          if (!playerStats[playerId]) {
            playerStats[playerId] = { playerId: playerId, wins: 0, losses: 0, total: 0 };
          }

          if (comp.winner === playerId) {
            playerStats[playerId].wins++;
          } else {
            playerStats[playerId].losses++;
          }
          playerStats[playerId].total++;
        });
      });

    return Object.values(playerStats).sort(function(a, b) {
      return b.wins - a.wins;
    });
  }

  // Race Competition Type
  function createRace(organizerId, checkpoints, zone, state) {
    var raceId = generateId();
    var race = {
      id: raceId,
      type: 'race',
      organizer: organizerId,
      checkpoints: checkpoints,
      zone: zone,
      participants: [],
      progress: {}, // playerId â†’ { checkpointIndex, time }
      status: 'waiting',
      createdAt: Date.now()
    };

    if (!state.competitions) {
      state.competitions = [];
    }

    state.competitions.push(race);

    return {
      success: true,
      race: race,
      state: state
    };
  }

  // Check race progress
  // state must be passed so the race record (with checkpoints and progress) can be looked up
  function checkRaceProgress(competitionId, playerId, position, state) {
    var CHECKPOINT_RADIUS = 5; // units â€” player must be within this distance to trigger a checkpoint

    // Guard: need state to look up the race
    if (!state || !state.competitions) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    // Find the race
    var race = null;
    for (var i = 0; i < state.competitions.length; i++) {
      if (state.competitions[i].id === competitionId && state.competitions[i].type === 'race') {
        race = state.competitions[i];
        break;
      }
    }

    if (!race) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    // Race must be active
    if (race.status !== 'active') {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    // Player must be a participant
    if (race.participants.indexOf(playerId) === -1) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    // Ensure checkpoints array exists and is non-empty
    if (!race.checkpoints || race.checkpoints.length === 0) {
      return { checkpointHit: false, finished: false, currentCheckpoint: 0, time: 0 };
    }

    // Initialise player progress record if missing
    if (!race.progress) {
      race.progress = {};
    }
    if (!race.progress[playerId]) {
      race.progress[playerId] = {
        checkpointIndex: 0,  // next checkpoint the player needs to reach
        startTime: Date.now(),
        time: 0,
        finished: false
      };
    }

    var playerProgress = race.progress[playerId];

    // If this player already finished, nothing more to do
    if (playerProgress.finished) {
      return {
        checkpointHit: false,
        finished: true,
        currentCheckpoint: playerProgress.checkpointIndex,
        time: playerProgress.time
      };
    }

    // The next checkpoint the player must reach (sequential enforcement)
    var nextIndex = playerProgress.checkpointIndex;
    if (nextIndex >= race.checkpoints.length) {
      // Should not happen, but guard anyway
      return { checkpointHit: false, finished: false, currentCheckpoint: nextIndex, time: playerProgress.time };
    }

    var target = race.checkpoints[nextIndex];

    // Distance check (3-D Euclidean)
    var dx = position.x - target.x;
    var dy = position.y - target.y;
    var dz = position.z - target.z;
    var distSquared = dx * dx + dy * dy + dz * dz;

    if (distSquared > CHECKPOINT_RADIUS * CHECKPOINT_RADIUS) {
      // Not close enough to the next checkpoint yet
      return {
        checkpointHit: false,
        finished: false,
        currentCheckpoint: nextIndex,
        time: Date.now() - playerProgress.startTime
      };
    }

    // --- Checkpoint hit! ---
    playerProgress.checkpointIndex = nextIndex + 1;
    var elapsed = Date.now() - playerProgress.startTime;
    playerProgress.time = elapsed;

    var finished = false;
    if (playerProgress.checkpointIndex >= race.checkpoints.length) {
      // Player has cleared all checkpoints â€” race complete
      finished = true;
      playerProgress.finished = true;

      // Check if all participants have finished
      var allDone = true;
      for (var p = 0; p < race.participants.length; p++) {
        var pid = race.participants[p];
        if (!race.progress[pid] || !race.progress[pid].finished) {
          allDone = false;
          break;
        }
      }

      if (allDone) {
        race.status = 'completed';

        // Determine winner: finished participant with lowest time
        var bestTime = Infinity;
        var winner = null;
        for (var w = 0; w < race.participants.length; w++) {
          var wid = race.participants[w];
          if (race.progress[wid] && race.progress[wid].finished) {
            if (race.progress[wid].time < bestTime) {
              bestTime = race.progress[wid].time;
              winner = wid;
            }
          }
        }
        race.winner = winner;
        race.endedAt = Date.now();
      }
    }

    return {
      checkpointHit: true,
      finished: finished,
      currentCheckpoint: playerProgress.checkpointIndex,
      time: elapsed
    };
  }

  // Get race standings
  function getRaceStandings(competitionId, state) {
    if (!state.competitions) {
      return [];
    }

    var race = state.competitions.find(function(c) {
      return c.id === competitionId && c.type === 'race';
    });

    if (!race || !race.progress) {
      return [];
    }

    var standings = Object.keys(race.progress).map(function(playerId) {
      var progress = race.progress[playerId];
      return {
        playerId: playerId,
        checkpointIndex: progress.checkpointIndex || 0,
        time: progress.time || 0,
        finished: progress.finished || false
      };
    });

    // Sort by checkpoint progress (descending) then by time (ascending)
    standings.sort(function(a, b) {
      if (a.finished && !b.finished) return -1;
      if (!a.finished && b.finished) return 1;
      if (a.checkpointIndex !== b.checkpointIndex) {
        return b.checkpointIndex - a.checkpointIndex;
      }
      return a.time - b.time;
    });

    return standings;
  }

  // Exports
  exports.COMPETITION_TYPES = COMPETITION_TYPES;
  exports.SPARK_AWARDS = SPARK_AWARDS;
  exports.handleChallenge = handleChallenge;
  exports.handleAcceptChallenge = handleAcceptChallenge;
  exports.handleForfeit = handleForfeit;
  exports.handleScore = handleScore;
  exports.getPendingChallenges = getPendingChallenges;
  exports.joinAsSpectator = joinAsSpectator;
  exports.leaveSpectator = leaveSpectator;
  exports.getSpectators = getSpectators;
  exports.getActiveCompetitions = getActiveCompetitions;
  exports.broadcastToSpectators = broadcastToSpectators;
  exports.getCompetitionLeaderboard = getCompetitionLeaderboard;
  exports.createRace = createRace;
  exports.checkRaceProgress = checkRaceProgress;
  exports.getRaceStandings = getRaceStandings;

})(typeof module !== 'undefined' ? module.exports : (window.Competition = {}));


// exploration.js
(function(exports) {

  // Discovery types
  const DISCOVERY_TYPES = [
    'location', 'creature', 'artifact', 'secret',
    'landmark', 'ruin', 'cave', 'spring'
  ];

  // Base rarity by discovery type
  const BASE_RARITY = {
    location: 0.3,
    creature: 0.5,
    artifact: 0.7,
    secret: 0.9,
    landmark: 0.2,
    ruin: 0.6,
    cave: 0.4,
    spring: 0.5
  };

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Calculate distance between two 3D positions
  function calculateDistance(pos1, pos2) {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    const dz = pos1.z - pos2.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  // Check if discovery is duplicate
  function isDuplicate(playerId, position, state) {
    if (!state.discoveries || state.discoveries.length === 0) {
      return false;
    }

    // Check if player has already discovered within distance 5
    for (const discovery of state.discoveries) {
      if (discovery.discoverer === playerId) {
        const distance = calculateDistance(position, discovery.position);
        if (distance <= 5) {
          return true;
        }
      }
    }

    return false;
  }

  // Calculate rarity for a discovery type
  function calculateRarity(type) {
    if (BASE_RARITY.hasOwnProperty(type)) {
      return BASE_RARITY[type];
    }
    // Default rarity
    return 0.3;
  }

  // Handle discovery
  function handleDiscover(msg, state) {
    const position = msg.payload.position || {x: 0, y: 0, z: 0};
    const playerId = msg.from;

    // Check for duplicate
    if (isDuplicate(playerId, position, state)) {
      return {
        success: false,
        error: 'Already discovered'
      };
    }

    const discoveryType = msg.payload.type || 'location';
    if (!DISCOVERY_TYPES.includes(discoveryType)) {
      return {
        success: false,
        error: 'Invalid discovery type'
      };
    }

    // Determine rarity
    let rarity = msg.payload.rarity;
    if (typeof rarity !== 'number' || rarity < 0 || rarity > 1) {
      rarity = calculateRarity(discoveryType);
    }

    // Calculate Spark award
    const sparkAwarded = 5 + Math.floor(rarity * 20);

    const discovery = {
      id: generateId(),
      discoverer: playerId,
      type: discoveryType,
      description: msg.payload.description || '',
      position: position,
      zone: msg.payload.zone || 'default',
      ts: Date.now(),
      rarity: rarity
    };

    // Initialize state.discoveries if needed
    if (!state.discoveries) {
      state.discoveries = [];
    }

    state.discoveries.push(discovery);

    return {
      success: true,
      state: state,
      discovery: discovery,
      sparkAwarded: sparkAwarded
    };
  }

  // Handle inspection
  function handleInspect(msg, state) {
    const targetId = msg.payload.target;

    if (!targetId) {
      return {
        success: false,
        error: 'No target specified'
      };
    }

    let info = null;
    let entityType = null;

    // Search in players
    if (state.players && state.players[targetId]) {
      info = {
        type: 'player',
        id: targetId,
        data: state.players[targetId]
      };
      entityType = 'player';
    }

    // Search in structures
    if (!info && state.structures && state.structures.length > 0) {
      const structure = state.structures.find(s => s.id === targetId);
      if (structure) {
        info = {
          type: 'structure',
          id: targetId,
          data: structure
        };
        entityType = 'structure';
      }
    }

    // Search in gardens
    if (!info && state.gardens && state.gardens.length > 0) {
      const garden = state.gardens.find(g => g.id === targetId);
      if (garden) {
        const now = Date.now();
        const elapsed = now - garden.plantedAt;
        const totalGrowthTime = garden.readyAt - garden.plantedAt;
        const currentGrowthStage = Math.min(1.0, elapsed / totalGrowthTime);

        info = {
          type: 'garden',
          id: targetId,
          data: {
            ...garden,
            currentGrowthStage: currentGrowthStage,
            isReady: now >= garden.readyAt
          }
        };
        entityType = 'garden';
      }
    }

    // Search in discoveries
    if (!info && state.discoveries && state.discoveries.length > 0) {
      const discovery = state.discoveries.find(d => d.id === targetId);
      if (discovery) {
        info = {
          type: 'discovery',
          id: targetId,
          data: discovery
        };
        entityType = 'discovery';
      }
    }

    if (!info) {
      return {
        success: false,
        error: 'Target not found'
      };
    }

    return {
      success: true,
      info: info
    };
  }

  // Get all discoveries for a player
  function getDiscoveries(playerId, state) {
    if (!state || !state.discoveries) {
      return [];
    }

    return state.discoveries.filter(function(d) {
      return d.discoverer === playerId;
    }).map(function(d) {
      // Map rarity number to rarity name
      var rarityName = 'common';
      if (d.rarity >= 0.9) rarityName = 'legendary';
      else if (d.rarity >= 0.7) rarityName = 'epic';
      else if (d.rarity >= 0.5) rarityName = 'rare';
      else if (d.rarity >= 0.3) rarityName = 'uncommon';

      return {
        name: d.type.charAt(0).toUpperCase() + d.type.slice(1),
        description: d.description,
        zone: d.zone,
        rarity: rarityName,
        timestamp: d.ts
      };
    });
  }

  // Get discovered zones for a player
  function getDiscoveredZones(playerId, state) {
    if (!state || !state.discoveries) {
      return ['default'];
    }

    var zones = {};
    state.discoveries.forEach(function(d) {
      if (d.discoverer === playerId) {
        zones[d.zone] = true;
      }
    });

    return Object.keys(zones);
  }

  // ========================================================================
  // ZONE SECRETS â€” Hidden discoverable locations in each zone
  // ========================================================================

  var ZONE_SECRETS = {
    nexus: [
      { id: 'nexus_heart', name: 'Heart of the Nexus', type: 'secret', description: 'A pulsing crystal embedded in the ground at the world\'s center, humming with energy from all connected zones.', position: { x: 0, y: 0.5, z: 0 }, rarity: 0.8, loreId: 'lore_nexus_heart' },
      { id: 'nexus_echo', name: 'Echo Stone', type: 'artifact', description: 'A smooth stone that whispers the names of every player who has ever visited ZION.', position: { x: 15, y: 1, z: -10 }, rarity: 0.6, loreId: 'lore_echo_stone' },
      { id: 'nexus_sundial', name: 'Eternal Sundial', type: 'landmark', description: 'An ancient sundial that tracks not just time but the phases of ZION\'s day-night cycle.', position: { x: -8, y: 0, z: 12 }, rarity: 0.4, loreId: 'lore_sundial' }
    ],
    gardens: [
      { id: 'gardens_moonwell', name: 'Moonwell', type: 'spring', description: 'A hidden pool that glows silver at night, said to accelerate plant growth nearby.', position: { x: -20, y: 0, z: -25 }, rarity: 0.7, loreId: 'lore_moonwell' },
      { id: 'gardens_ancient_tree', name: 'The First Tree', type: 'landmark', description: 'The oldest tree in ZION, its trunk carved with symbols from the founding.', position: { x: 30, y: 0, z: 10 }, rarity: 0.5, loreId: 'lore_first_tree' },
      { id: 'gardens_fairy_ring', name: 'Fairy Ring', type: 'secret', description: 'A perfect circle of mushrooms that appears only at certain times.', position: { x: -5, y: 0, z: 35 }, rarity: 0.9, loreId: 'lore_fairy_ring' },
      { id: 'gardens_meditation', name: 'Meditation Hollow', type: 'location', description: 'A sheltered hollow where the ambient sounds of nature converge in perfect harmony.', position: { x: 18, y: -1, z: -30 }, rarity: 0.6, loreId: 'lore_meditation' }
    ],
    athenaeum: [
      { id: 'athenaeum_codex', name: 'The Lost Codex', type: 'artifact', description: 'A floating book whose pages contain knowledge from all federated worlds.', position: { x: -12, y: 3, z: -15 }, rarity: 0.9, loreId: 'lore_codex' },
      { id: 'athenaeum_orrery', name: 'Celestial Orrery', type: 'artifact', description: 'A mechanical model of the multiverse, with a tiny light for each federated world.', position: { x: 5, y: 2, z: 20 }, rarity: 0.8, loreId: 'lore_orrery' },
      { id: 'athenaeum_whispering', name: 'Whispering Stacks', type: 'secret', description: 'Deep in the shelves, the books murmur to each other, sharing fragments of lore.', position: { x: -25, y: 0, z: 8 }, rarity: 0.7, loreId: 'lore_whispering' }
    ],
    studio: [
      { id: 'studio_muse', name: 'The Muse\'s Corner', type: 'secret', description: 'A corner where inspiration strikes harder. Art created here always seems to resonate more.', position: { x: 10, y: 0, z: -18 }, rarity: 0.7, loreId: 'lore_muse' },
      { id: 'studio_palette', name: 'Living Palette', type: 'artifact', description: 'A palette whose colors shift with the seasons, mixing hues no artisan has seen before.', position: { x: -15, y: 1, z: 12 }, rarity: 0.8, loreId: 'lore_palette' },
      { id: 'studio_resonance', name: 'Resonance Chamber', type: 'cave', description: 'A natural acoustic chamber where even whispers become music.', position: { x: 22, y: -2, z: -5 }, rarity: 0.6, loreId: 'lore_resonance' }
    ],
    wilds: [
      { id: 'wilds_hollow', name: 'Starfall Hollow', type: 'cave', description: 'A cavern where fragments of starlight collect in luminous pools.', position: { x: -30, y: -3, z: -20 }, rarity: 0.9, loreId: 'lore_starfall' },
      { id: 'wilds_monolith', name: 'The Monolith', type: 'ruin', description: 'A towering black stone that predates ZION itself, covered in undecipherable glyphs.', position: { x: 35, y: 0, z: 25 }, rarity: 0.8, loreId: 'lore_monolith' },
      { id: 'wilds_grove', name: 'Singing Grove', type: 'location', description: 'Trees here sway in patterns that create hauntingly beautiful melodies.', position: { x: -10, y: 0, z: 30 }, rarity: 0.5, loreId: 'lore_singing_grove' },
      { id: 'wilds_fossil', name: 'Fossil Cliff', type: 'landmark', description: 'A cliff face embedded with fossils from creatures that never existed in our world.', position: { x: 20, y: 5, z: -35 }, rarity: 0.6, loreId: 'lore_fossil_cliff' },
      { id: 'wilds_spring', name: 'Hidden Hot Spring', type: 'spring', description: 'A natural hot spring tucked behind a waterfall, warm even in winter.', position: { x: -25, y: -1, z: -10 }, rarity: 0.7, loreId: 'lore_hot_spring' }
    ],
    agora: [
      { id: 'agora_vault', name: 'The Old Vault', type: 'ruin', description: 'Beneath the market, the remains of ZION\'s first bank, its vault door still ajar.', position: { x: 8, y: -2, z: -12 }, rarity: 0.7, loreId: 'lore_vault' },
      { id: 'agora_scales', name: 'Scales of Truth', type: 'artifact', description: 'Ancient merchant scales that glow when a fair trade is struck nearby.', position: { x: -10, y: 1, z: 5 }, rarity: 0.6, loreId: 'lore_scales' }
    ],
    commons: [
      { id: 'commons_bell', name: 'Community Bell', type: 'landmark', description: 'A large bell that was rung to call the first citizens of ZION together.', position: { x: 0, y: 3, z: 0 }, rarity: 0.4, loreId: 'lore_bell' },
      { id: 'commons_mosaic', name: 'Founders\' Mosaic', type: 'artifact', description: 'A floor mosaic depicting the founding of ZION, with space for new tiles from each generation.', position: { x: -15, y: 0, z: 15 }, rarity: 0.6, loreId: 'lore_mosaic' },
      { id: 'commons_time_capsule', name: 'Time Capsule', type: 'secret', description: 'Buried beneath the gathering circle, a capsule left by the founders with messages for the future.', position: { x: 5, y: -1, z: -8 }, rarity: 0.8, loreId: 'lore_time_capsule' }
    ],
    arena: [
      { id: 'arena_champions', name: 'Hall of Champions', type: 'ruin', description: 'Carved into the arena wall, the names and deeds of every champion who competed here.', position: { x: 20, y: 2, z: 0 }, rarity: 0.5, loreId: 'lore_champions' },
      { id: 'arena_flame', name: 'Eternal Flame', type: 'landmark', description: 'A flame that has burned since the arena was built, said to embody the spirit of competition.', position: { x: 0, y: 1, z: -20 }, rarity: 0.6, loreId: 'lore_flame' }
    ]
  };

  // ========================================================================
  // LORE ENTRIES â€” Deep world-building text
  // ========================================================================

  var LORE_ENTRIES = {
    lore_nexus_heart: {
      title: 'The Heart of ZION',
      text: 'Long before the first player set foot in ZION, the Heart was placed here â€” a crystal forged from the combined intentions of its creators. It pulses once for every soul currently inhabiting the world. Old-timers say that on quiet nights, you can feel it sync with your own heartbeat, as if the world itself is alive and breathing alongside you.',
      category: 'origins'
    },
    lore_echo_stone: {
      title: 'The Echo Stone',
      text: 'The Echo Stone remembers. Every name spoken near it is captured and preserved in its crystalline lattice. Some say if you press your ear to its surface and whisper a name, you can hear a faint echo of that person\'s first words in ZION. The stone grows infinitesimally larger with each new voice it records.',
      category: 'artifacts'
    },
    lore_sundial: {
      title: 'The Eternal Sundial',
      text: 'The Sundial was the first structure built in the Nexus, before even the portals were erected. It tracks the 24-minute day cycle and marks the seasons that shift each real-world week. At dawn, its shadow points toward the Gardens. At dusk, toward the Wilds. At the rare eclipse, it casts no shadow at all.',
      category: 'landmarks'
    },
    lore_moonwell: {
      title: 'The Moonwell',
      text: 'Hidden in the deepest grove of the Gardens lies the Moonwell, a pool of water that seems to capture and hold moonlight even after dawn. Gardeners discovered that plants watered from the Moonwell grow twice as fast, though they suspect this is less about the water and more about the attention the gardener pays in finding it.',
      category: 'nature'
    },
    lore_first_tree: {
      title: 'The First Tree',
      text: 'Before the Gardens were cultivated, before the zones were named, there was a single tree. The First Tree grew from a seed of intention planted by ZION\'s architects. Its roots extend beneath every zone, connecting the world in ways no map can show. The symbols carved in its trunk are the original protocol â€” the language that all of ZION\'s systems speak.',
      category: 'origins'
    },
    lore_fairy_ring: {
      title: 'The Fairy Ring',
      text: 'The Fairy Ring appears and disappears according to rules no scholar has fully deciphered. Some say it follows the moon cycle, others claim it responds to the emotional state of the world itself. Those who find it report a fleeting sense of profound connection to every other being in ZION â€” as if, for one moment, the boundaries between self and world dissolve.',
      category: 'mysteries'
    },
    lore_meditation: {
      title: 'The Meditation Hollow',
      text: 'In the Meditation Hollow, the sounds of nature converge in unexpected harmony â€” birdsong becomes melody, wind becomes rhythm, water becomes bass. Those who sit here long enough report achieving a rare clarity of purpose. It\'s said this was the spot where the intention system was first imagined.',
      category: 'nature'
    },
    lore_codex: {
      title: 'The Lost Codex',
      text: 'The Codex floats between shelves, never resting in one place. Its pages are blank to most, but to those who have visited federated worlds, text appears: knowledge from those distant lands. The more worlds you visit, the more pages reveal themselves. Scholars believe the Codex is less a book and more a living bridge between realities.',
      category: 'artifacts'
    },
    lore_orrery: {
      title: 'The Celestial Orrery',
      text: 'Built by the first scholars of the Athenaeum, the Orrery maps every federated world as a tiny point of light orbiting a central sun â€” ZION itself. New lights appear when new federations are forged, and they dim when connections grow quiet. It serves as both art and practical tool, allowing citizens to see the health of the multiverse at a glance.',
      category: 'artifacts'
    },
    lore_whispering: {
      title: 'The Whispering Stacks',
      text: 'Deep in the Athenaeum, where the oldest books reside, the air is thick with whispers. The books share knowledge among themselves when no one is looking, cross-referencing and updating their contents. Scholars who linger here too long report dreams filled with information they never consciously learned.',
      category: 'mysteries'
    },
    lore_muse: {
      title: 'The Muse\'s Corner',
      text: 'Every studio has its sweet spot, the place where creativity flows most freely. In ZION\'s Studio, that spot is marked by a slight warmth in the floor and a tendency for ambient sounds to harmonize. Artists who create here often surprise themselves with the results. Is it magic, or simply the power of expectation? The Muse keeps her secrets.',
      category: 'art'
    },
    lore_palette: {
      title: 'The Living Palette',
      text: 'The Palette was not crafted but grown â€” crystallized from the combined creative energy of ZION\'s first artists. Its colors are alive: they deepen in autumn, brighten in spring, glow warmly in winter, and shimmer like water in summer. Art created with its pigments is said to evoke emotions in viewers that no ordinary color can.',
      category: 'artifacts'
    },
    lore_resonance: {
      title: 'The Resonance Chamber',
      text: 'Beneath the Studio lies a natural cavern with perfect acoustics. Sound enters and emerges transformed â€” whispers become symphonies, footsteps become percussion, breath becomes wind instruments. Musicians gather here to compose pieces that could never exist in the above-ground world. The Chamber doesn\'t amplify sound; it reveals its hidden depth.',
      category: 'nature'
    },
    lore_starfall: {
      title: 'Starfall Hollow',
      text: 'When the procedural stars of ZION\'s sky occasionally flicker and fall, their light doesn\'t vanish â€” it collects in pools deep within Starfall Hollow. The luminous pools cast impossible shadows that move independently of light sources. Explorers have reported seeing brief visions of other worlds reflected in the starlight pools.',
      category: 'mysteries'
    },
    lore_monolith: {
      title: 'The Monolith',
      text: 'The Monolith stands as a reminder that not everything in ZION was placed there by its creators. It appeared one day, unannounced, and no log records its creation. Its glyphs resist translation â€” they seem to shift when observed directly. Some theorize it\'s a message from a parallel ZION, a fork that found a way to communicate across the multiverse gap.',
      category: 'mysteries'
    },
    lore_singing_grove: {
      title: 'The Singing Grove',
      text: 'The trees of the Singing Grove have grown in a pattern that channels wind into music. Each season brings a different key, and the melody changes with the weather. During storms, the grove produces sounds that can only be described as the world singing itself to sleep. Wildlife gathers here during these concerts, unbothered by the presence of visitors.',
      category: 'nature'
    },
    lore_fossil_cliff: {
      title: 'The Fossil Cliff',
      text: 'The fossils in this cliff belong to creatures that exist in no biological record. Wings with too many segments, shells that spiral in mathematically impossible patterns, teeth that seem designed for eating light itself. Scholars debate whether these are remnants of an earlier version of ZION, or dreams that somehow calcified into stone.',
      category: 'mysteries'
    },
    lore_hot_spring: {
      title: 'The Hidden Hot Spring',
      text: 'Tucked behind a waterfall that reveals itself only to those who approach from the right angle, the Hot Spring maintains a perfect temperature regardless of season. Its waters carry a faint mineral glow. Visitors leave feeling restored, though whether this is the water\'s doing or simply the peace of discovering a hidden place is debated.',
      category: 'nature'
    },
    lore_vault: {
      title: 'The Old Vault',
      text: 'Beneath the bustling Agora lies the Old Vault â€” ZION\'s first attempt at a central bank, abandoned when the community chose a distributed ledger instead. The vault door is still ajar, revealing a room lined with empty shelves. A plaque on the wall reads: "The true wealth of ZION cannot be stored in a single place."',
      category: 'history'
    },
    lore_scales: {
      title: 'The Scales of Truth',
      text: 'The Scales were a gift from the merchants of early ZION, imbued with a simple enchantment: they glow golden when a fair trade is completed nearby. In a world where the protocol enforces honest transactions, the Scales serve more as a celebration than a safeguard. Their gentle light is a reminder that fairness feels good.',
      category: 'artifacts'
    },
    lore_bell: {
      title: 'The Community Bell',
      text: 'The Bell was rung to gather the first hundred citizens of ZION â€” the founding AI agents who would give the world its initial life. It rang once for each of them, one hundred clear notes that still echo in the architecture of the Commons. Now it rings for every community event, its tone slightly different each time, as if greeting each gathering uniquely.',
      category: 'history'
    },
    lore_mosaic: {
      title: 'The Founders\' Mosaic',
      text: 'The mosaic in the Commons floor tells the story of ZION\'s founding in tiny colored tiles. At the center, a burst of golden Spark radiating outward. Around it, the eight zones taking shape from formless possibility. At the edges, blank space â€” room for new tiles that each generation of citizens adds. Finding your own tile is a rite of passage.',
      category: 'history'
    },
    lore_time_capsule: {
      title: 'The Time Capsule',
      text: 'Buried beneath the gathering circle is a capsule containing the original vision documents for ZION â€” the hopes and principles its creators encoded before the first line of code was written. The capsule is sealed but not locked; anyone can open it. Inside, alongside the documents, is a simple note: "Build kindly."',
      category: 'origins'
    },
    lore_champions: {
      title: 'The Hall of Champions',
      text: 'The Arena wall bears the names of all who have competed with honor. Not just winners â€” every participant who showed sportsmanship, creativity, or grace under pressure. The Hall reminds visitors that competition in ZION is not about domination but about pushing each other to grow. Below the names runs a single line: "The only defeat is refusing to play."',
      category: 'history'
    },
    lore_flame: {
      title: 'The Eternal Flame',
      text: 'The Eternal Flame burns without fuel, its light neither hot nor cold but somehow both warming and invigorating. It was lit at the Arena\'s inauguration and has never gone out. Competitors who pass the flame before a challenge report feeling calmer and more focused, as if the flame absorbs anxiety and returns resolve.',
      category: 'landmarks'
    }
  };

  /**
   * Get zone secrets (discoverable hidden locations)
   * @param {string} zoneId
   * @returns {Array} Secrets for the zone
   */
  function getZoneSecrets(zoneId) {
    return ZONE_SECRETS[zoneId] || [];
  }

  /**
   * Check if player is near a secret and hasn't discovered it yet
   * @param {string} playerId
   * @param {Object} position - Player position {x, y, z}
   * @param {string} zoneId
   * @param {Object} state
   * @returns {Object|null} Secret found or null
   */
  function checkNearbySecrets(playerId, position, zoneId, state) {
    var secrets = ZONE_SECRETS[zoneId];
    if (!secrets) return null;

    for (var i = 0; i < secrets.length; i++) {
      var secret = secrets[i];
      var dist = calculateDistance(position, secret.position);

      // Within 8 units
      if (dist <= 8) {
        // Check if already discovered
        var alreadyFound = false;
        if (state.discoveries) {
          for (var j = 0; j < state.discoveries.length; j++) {
            if (state.discoveries[j].discoverer === playerId && state.discoveries[j].secretId === secret.id) {
              alreadyFound = true;
              break;
            }
          }
        }

        if (!alreadyFound) {
          return secret;
        }
      }
    }

    return null;
  }

  /**
   * Discover a zone secret
   * @param {string} playerId
   * @param {Object} secret - Secret from ZONE_SECRETS
   * @param {Object} state
   * @returns {Object} Discovery result
   */
  function discoverSecret(playerId, secret, state) {
    if (!state.discoveries) state.discoveries = [];

    var sparkAwarded = 5 + Math.floor(secret.rarity * 30); // Higher rewards for secrets

    var discovery = {
      id: generateId(),
      secretId: secret.id,
      discoverer: playerId,
      type: secret.type,
      name: secret.name,
      description: secret.description,
      position: secret.position,
      zone: secret.position.zone || 'unknown',
      ts: Date.now(),
      rarity: secret.rarity,
      loreId: secret.loreId
    };

    state.discoveries.push(discovery);

    return {
      success: true,
      discovery: discovery,
      sparkAwarded: sparkAwarded,
      lore: secret.loreId ? LORE_ENTRIES[secret.loreId] : null
    };
  }

  /**
   * Get a lore entry by ID
   * @param {string} loreId
   * @returns {Object|null} Lore entry
   */
  function getLoreEntry(loreId) {
    return LORE_ENTRIES[loreId] || null;
  }

  /**
   * Get all lore entries unlocked by a player
   * @param {string} playerId
   * @param {Object} state
   * @returns {Array} Unlocked lore entries
   */
  function getUnlockedLore(playerId, state) {
    if (!state.discoveries) return [];

    var loreIds = new Set();
    state.discoveries.forEach(function(d) {
      if (d.discoverer === playerId && d.loreId) {
        loreIds.add(d.loreId);
      }
    });

    var result = [];
    loreIds.forEach(function(loreId) {
      var entry = LORE_ENTRIES[loreId];
      if (entry) {
        result.push({
          id: loreId,
          title: entry.title,
          text: entry.text,
          category: entry.category
        });
      }
    });

    return result;
  }

  /**
   * Get all lore categories and counts
   * @returns {Object} {category: totalCount}
   */
  function getLoreCategories() {
    var cats = {};
    for (var loreId in LORE_ENTRIES) {
      var cat = LORE_ENTRIES[loreId].category;
      cats[cat] = (cats[cat] || 0) + 1;
    }
    return cats;
  }

  // Exports
  exports.DISCOVERY_TYPES = DISCOVERY_TYPES;
  exports.BASE_RARITY = BASE_RARITY;
  exports.handleDiscover = handleDiscover;
  exports.handleInspect = handleInspect;
  exports.isDuplicate = isDuplicate;
  exports.calculateRarity = calculateRarity;
  exports.getDiscoveries = getDiscoveries;
  exports.getDiscoveredZones = getDiscoveredZones;
  exports.ZONE_SECRETS = ZONE_SECRETS;
  exports.LORE_ENTRIES = LORE_ENTRIES;
  exports.getZoneSecrets = getZoneSecrets;
  exports.checkNearbySecrets = checkNearbySecrets;
  exports.discoverSecret = discoverSecret;
  exports.getLoreEntry = getLoreEntry;
  exports.getUnlockedLore = getUnlockedLore;
  exports.getLoreCategories = getLoreCategories;

})(typeof module !== 'undefined' ? module.exports : (window.Exploration = {}));


// anchors.js
// anchors.js
/**
 * ZION AR Anchor Geolocation System
 * Implements Constitution Article V Â§5.2 (Anchoring), Â§5.3 (Healthy Play), Â§8.6 (Physical Realm Safety)
 *
 * Anchors bridge the Physical Realm and the Digital Realm:
 *   - Real-world GPS coordinates â†’ ZION zone locations
 *   - Walking warmth bonuses (minor, non-coercive per Â§1.6 and Â§5.3)
 *   - Safety-first AR mode per Â§8.6
 */
(function(exports) {
  'use strict';

  // ============================================================
  // Constants
  // ============================================================

  /**
   * Anchor Types (Constitution Â§5.2)
   * Five real-world location types that can be linked to ZION zones.
   */
  var TYPES = {
    ZONE_PORTAL:     'zone_portal',      // Real location â†’ ZION zone entry
    RESOURCE_NODE:   'resource_node',    // Real location â†’ harvestable resources
    DISCOVERY_POINT: 'discovery_point',  // Real location â†’ lore/secrets/items
    GATHERING_SPOT:  'gathering_spot',   // Real location â†’ social meetup
    GARDEN_PLOT:     'garden_plot'       // Real location â†’ player garden
  };

  // Array of valid type strings for validation
  var VALID_TYPES = [
    'zone_portal', 'resource_node', 'discovery_point',
    'gathering_spot', 'garden_plot'
  ];

  // Valid ZION zones (Â§5.4 Genesis Zones)
  var VALID_ZONES = [
    'nexus', 'gardens', 'athenaeum', 'studio',
    'wilds', 'agora', 'commons', 'arena'
  ];

  // Earth's mean radius in meters (WGS-84)
  var EARTH_RADIUS_M = 6371000;

  // Default proximity radius for "in range" checks (meters)
  var DEFAULT_RANGE_M = 50;

  // Speed thresholds (km/h) - Constitution Â§5.3 and Â§8.6
  var WALKING_SPEED_MAX_KMH = 10;  // < 10 km/h = walking
  var DRIVING_SPEED_MIN_KMH = 25;  // >= 25 km/h = driving â†’ pause AR

  // Warmth caps (Constitution Â§5.3 â€” "not enough to create inequality")
  var WARMTH_POINTS_MAX = 5;               // Max warmth per session
  var WARMTH_HARVEST_MAX_BONUS = 0.10;     // Max 10% harvest bonus
  var WARMTH_DISCOVERY_MAX_BONUS = 0.15;   // Max 15% discovery rate bonus

  // Protocol version
  var PROTOCOL_VERSION = 1;

  // ============================================================
  // Utility: ID Generation
  // ============================================================

  /**
   * Generates a unique identifier suitable for anchors and messages.
   * @returns {string}
   */
  function generateId() {
    return 'anc_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Generates a unique message ID.
   * @returns {string}
   */
  function generateMsgId() {
    return 'msg_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Returns current UTC timestamp as ISO-8601 string.
   * @returns {string}
   */
  function nowISO() {
    return new Date().toISOString();
  }

  // ============================================================
  // Geolocation (Haversine Distance)
  // ============================================================

  /**
   * Computes the great-circle distance between two GPS points using the
   * Haversine formula.
   *
   * @param {number} lat1 - Latitude of point 1 (degrees)
   * @param {number} lon1 - Longitude of point 1 (degrees)
   * @param {number} lat2 - Latitude of point 2 (degrees)
   * @param {number} lon2 - Longitude of point 2 (degrees)
   * @returns {number} Distance in meters
   */
  function getDistance(lat1, lon1, lat2, lon2) {
    var toRad = function(deg) { return deg * Math.PI / 180; };

    var dLat = toRad(lat2 - lat1);
    var dLon = toRad(lon2 - lon1);

    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);

    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS_M * c;
  }

  /**
   * Returns true if speed is at or below walking speed threshold.
   * Stationary (0 km/h) counts as walking â€” Constitution Â§5.3 ("No Punishment for Stillness").
   *
   * @param {number} speedKmh - Speed in km/h
   * @returns {boolean}
   */
  function isWalkingSpeed(speedKmh) {
    if (typeof speedKmh !== 'number' || speedKmh < 0) return false;
    return speedKmh < WALKING_SPEED_MAX_KMH;
  }

  /**
   * Returns true if speed is at or above driving speed threshold.
   * Constitution Â§8.6 â€” pause AR gameplay when driving.
   *
   * @param {number} speedKmh - Speed in km/h
   * @returns {boolean}
   */
  function isDrivingSpeed(speedKmh) {
    if (typeof speedKmh !== 'number') return false;
    return speedKmh >= DRIVING_SPEED_MIN_KMH;
  }

  // ============================================================
  // Geolocation API Wrappers
  // ============================================================

  /**
   * Requests the current location from the browser Geolocation API.
   * Wraps navigator.geolocation with safety checks.
   * Constitution Â§8.6 â€” requires explicit permission, graceful fallback.
   *
   * @param {Function} callback - Called with {lat, lon, speed, accuracy} on success
   * @param {Function} [errorCallback] - Called with error on failure
   */
  function requestLocation(callback, errorCallback) {
    if (typeof navigator === 'undefined' || !navigator.geolocation) {
      // Geolocation not available â€” ZION functions fully without it (Â§1.6)
      if (typeof errorCallback === 'function') {
        errorCallback({ code: -1, message: 'Geolocation not available' });
      }
      return;
    }

    navigator.geolocation.getCurrentPosition(
      function(position) {
        if (typeof callback === 'function') {
          callback({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            speed: position.coords.speed || 0,
            accuracy: position.coords.accuracy || null
          });
        }
      },
      function(err) {
        if (typeof errorCallback === 'function') {
          errorCallback(err);
        }
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 }
    );
  }

  /**
   * Begins watching the player's location continuously.
   *
   * @param {Function} callback - Called with {lat, lon, speed, accuracy} on each update
   * @param {Function} [errorCallback] - Called with error on failure
   * @returns {number|null} Watch ID (for stopWatching), or null if unavailable
   */
  function watchLocation(callback, errorCallback) {
    if (typeof navigator === 'undefined' || !navigator.geolocation) {
      if (typeof errorCallback === 'function') {
        errorCallback({ code: -1, message: 'Geolocation not available' });
      }
      return null;
    }

    return navigator.geolocation.watchPosition(
      function(position) {
        if (typeof callback === 'function') {
          callback({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            speed: position.coords.speed || 0,
            accuracy: position.coords.accuracy || null
          });
        }
      },
      function(err) {
        if (typeof errorCallback === 'function') {
          errorCallback(err);
        }
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 5000 }
    );
  }

  /**
   * Stops a running location watch.
   *
   * @param {number} watchId - The ID returned by watchLocation
   */
  function stopWatching(watchId) {
    if (typeof navigator !== 'undefined' && navigator.geolocation &&
        typeof navigator.geolocation.clearWatch === 'function') {
      navigator.geolocation.clearWatch(watchId);
    }
  }

  // ============================================================
  // Anchor Management
  // ============================================================

  /**
   * Creates a protocol message (anchor_place) to propose placing a new anchor.
   * Constitution Â§3.2 â€” every action is a protocol message.
   *
   * @param {string} type - Anchor type (from TYPES)
   * @param {{lat: number, lon: number}} geoPosition - GPS coordinates
   * @param {string} zoneMapping - Target ZION zone name
   * @param {string} description - Human-readable description
   * @param {string} from - GitHub username of the player placing the anchor
   * @returns {Object} Protocol message of type 'anchor_place'
   */
  function create(type, geoPosition, zoneMapping, description, from) {
    var anchorId = generateId();
    var now = nowISO();

    var anchor = {
      id: anchorId,
      type: type,
      geo: {
        lat: geoPosition.lat,
        lon: geoPosition.lon
      },
      zone: zoneMapping,
      description: description,
      placed_by: from,
      placed_at: now,
      approved_by: null,
      status: 'pending',
      discoveries: 0,
      metadata: {}
    };

    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: now,
      seq: Date.now(),
      from: from,
      type: 'anchor_place',
      platform: 'ar',
      position: { x: 0, y: 0, z: 0, zone: zoneMapping },
      geo: { lat: geoPosition.lat, lon: geoPosition.lon },
      payload: {
        type: type,
        zone: zoneMapping,
        description: description,
        anchor: anchor
      }
    };
  }

  /**
   * Validates an anchor object.
   * Checks: type, zone, description, coordinates.
   *
   * @param {Object} anchor - Anchor object to validate
   * @returns {{valid: boolean, reasons: string[]}}
   */
  function validate(anchor) {
    var reasons = [];

    // Must have geo field
    if (!anchor.geo || typeof anchor.geo !== 'object') {
      reasons.push('Missing geo coordinates');
    } else {
      var lat = anchor.geo.lat;
      var lon = anchor.geo.lon;

      if (typeof lat !== 'number' || typeof lon !== 'number') {
        reasons.push('Geo coordinates must be numbers');
      } else {
        if (lat < -90 || lat > 90) {
          reasons.push('Latitude out of range (-90 to 90)');
        }
        if (lon < -180 || lon > 180) {
          reasons.push('Longitude out of range (-180 to 180)');
        }
        // Null Island check
        if (lat === 0 && lon === 0) {
          reasons.push('Null Island (0,0) coordinates not permitted');
        }
      }
    }

    // Must have valid type
    if (!anchor.type || VALID_TYPES.indexOf(anchor.type) === -1) {
      reasons.push('Invalid anchor type: "' + anchor.type + '". Must be one of: ' + VALID_TYPES.join(', '));
    }

    // Must map to existing zone
    if (!anchor.zone || VALID_ZONES.indexOf(anchor.zone) === -1) {
      reasons.push('Invalid or missing zone: "' + anchor.zone + '". Must be one of: ' + VALID_ZONES.join(', '));
    }

    // Must have description
    if (!anchor.description || typeof anchor.description !== 'string' || anchor.description.trim().length === 0) {
      reasons.push('Anchor must have a non-empty description');
    }

    return {
      valid: reasons.length === 0,
      reasons: reasons
    };
  }

  /**
   * Creates an anchor approval protocol message.
   * Zone stewards (Â§7.4) approve anchor placements.
   *
   * @param {string} anchorId - ID of the anchor being approved
   * @param {string} stewardId - GitHub username of the approving steward
   * @returns {Object} Protocol message
   */
  function approve(anchorId, stewardId) {
    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: nowISO(),
      seq: Date.now(),
      from: stewardId,
      type: 'anchor_approve',
      platform: 'api',
      position: { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: { lat: null, lon: null },
      payload: {
        anchor_id: anchorId,
        status: 'approved',
        approved_by: stewardId,
        approved_at: nowISO()
      }
    };
  }

  /**
   * Creates an anchor rejection protocol message.
   *
   * @param {string} anchorId - ID of the anchor being rejected
   * @param {string} stewardId - GitHub username of the rejecting steward
   * @param {string} reason - Reason for rejection
   * @returns {Object} Protocol message
   */
  function reject(anchorId, stewardId, reason) {
    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: nowISO(),
      seq: Date.now(),
      from: stewardId,
      type: 'anchor_reject',
      platform: 'api',
      position: { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: { lat: null, lon: null },
      payload: {
        anchor_id: anchorId,
        status: 'rejected',
        rejected_by: stewardId,
        rejected_at: nowISO(),
        reason: reason || 'No reason provided'
      }
    };
  }

  // ============================================================
  // Discovery System
  // ============================================================

  /**
   * Normalizes anchors input: accepts both Array and Object (dict-keyed-by-id).
   * @param {Array|Object} anchors
   * @returns {Array}
   */
  function toArray(anchors) {
    if (!anchors) return [];
    if (Array.isArray(anchors)) return anchors;
    // Object/dict form
    var arr = [];
    for (var key in anchors) {
      if (Object.prototype.hasOwnProperty.call(anchors, key)) {
        arr.push(anchors[key]);
      }
    }
    return arr;
  }

  /**
   * Returns anchors sorted by distance from player, optionally filtered by radius.
   * Each returned anchor has an added `distance` property (meters).
   *
   * @param {{lat: number, lon: number}} playerGeo - Player's GPS position
   * @param {Array|Object} anchors - Array or dict of anchor objects
   * @param {number} [radiusMeters] - Optional max distance filter (meters)
   * @returns {Array} Anchors sorted by distance ascending, each with .distance
   */
  function getNearby(playerGeo, anchors, radiusMeters) {
    var arr = toArray(anchors);
    var results = [];

    for (var i = 0; i < arr.length; i++) {
      var anchor = arr[i];
      if (!anchor.geo) continue;

      var dist = getDistance(playerGeo.lat, playerGeo.lon, anchor.geo.lat, anchor.geo.lon);

      if (radiusMeters !== undefined && dist > radiusMeters) continue;

      // Create shallow copy with distance added
      var copy = {};
      for (var k in anchor) {
        if (Object.prototype.hasOwnProperty.call(anchor, k)) {
          copy[k] = anchor[k];
        }
      }
      copy.distance = dist;
      results.push(copy);
    }

    // Sort by distance ascending
    results.sort(function(a, b) { return a.distance - b.distance; });
    return results;
  }

  /**
   * Returns true if player is within range of an anchor.
   *
   * @param {{lat: number, lon: number}} playerGeo - Player's GPS
   * @param {Object} anchor - Anchor object with .geo
   * @param {number} [radiusMeters=50] - Range in meters (default 50m)
   * @returns {boolean}
   */
  function isInRange(playerGeo, anchor, radiusMeters) {
    if (!anchor.geo) return false;
    var range = (radiusMeters !== undefined) ? radiusMeters : DEFAULT_RANGE_M;
    var dist = getDistance(playerGeo.lat, playerGeo.lon, anchor.geo.lat, anchor.geo.lon);
    return dist <= range;
  }

  /**
   * Creates a 'discover' protocol message when a player discovers an anchor location.
   * Constitution Â§3.2 â€” discover message type.
   *
   * @param {Object} anchor - The anchor being discovered
   * @param {string} playerId - GitHub username of the discovering player
   * @returns {Object} Protocol message of type 'discover'
   */
  function discover(anchor, playerId) {
    return {
      v: PROTOCOL_VERSION,
      id: generateMsgId(),
      ts: nowISO(),
      seq: Date.now(),
      from: playerId,
      type: 'discover',
      platform: 'ar',
      position: { x: 0, y: 0, z: 0, zone: anchor.zone || 'nexus' },
      geo: { lat: anchor.geo.lat, lon: anchor.geo.lon },
      payload: {
        anchor_id: anchor.id,
        type: anchor.type,
        description: anchor.description,
        zone: anchor.zone,
        discovered_at: nowISO()
      }
    };
  }

  /**
   * Returns all anchors that have been discovered by a specific player.
   *
   * @param {string} playerId - GitHub username
   * @param {Array|Object} anchors - Anchors with .discoverers array
   * @returns {Array} Anchors where playerId is in .discoverers
   */
  function getDiscoveredBy(playerId, anchors) {
    var arr = toArray(anchors);
    return arr.filter(function(anchor) {
      return Array.isArray(anchor.discoverers) && anchor.discoverers.indexOf(playerId) !== -1;
    });
  }

  // ============================================================
  // Warmth System (Constitution Â§5.3)
  // ============================================================

  /**
   * Calculates warmth points from player movement data.
   * Only walking-speed movement accumulates warmth (Constitution Â§5.3 â€” Walking Warmth).
   * Driving speed gives 0 warmth. Standing still gives 0 warmth.
   * Result is capped to prevent gaming (Constitution Â§5.3 â€” "Not enough to create inequality").
   *
   * @param {Array|null} playerMovement - Array of {lat, lon, ts, speed} points
   *   - speed in km/h (optional; computed from GPS if not provided)
   * @returns {number} Warmth points (0 to WARMTH_POINTS_MAX)
   */
  function calculateWarmth(playerMovement) {
    if (!playerMovement || !Array.isArray(playerMovement) || playerMovement.length < 2) {
      return 0;
    }

    var totalDistanceM = 0;

    for (var i = 1; i < playerMovement.length; i++) {
      var prev = playerMovement[i - 1];
      var curr = playerMovement[i];

      if (!prev || !curr) continue;
      if (typeof prev.lat !== 'number' || typeof prev.lon !== 'number') continue;
      if (typeof curr.lat !== 'number' || typeof curr.lon !== 'number') continue;

      var segmentDistM = getDistance(prev.lat, prev.lon, curr.lat, curr.lon);

      // Determine speed for this segment
      var speedKmh = 0;
      if (typeof curr.speed === 'number' && curr.speed >= 0) {
        // Speed provided directly in m/s from Geolocation API; convert to km/h
        // If the speed field is already in km/h (as in our test data), use directly
        speedKmh = curr.speed;
      } else if (prev.ts && curr.ts) {
        var timeHours = (curr.ts - prev.ts) / (1000 * 60 * 60);
        if (timeHours > 0) {
          speedKmh = (segmentDistM / 1000) / timeHours;
        }
      }

      // Only count walking-speed movement
      if (isDrivingSpeed(speedKmh)) continue;
      // Only count actual movement (not standing still)
      if (segmentDistM < 1) continue;

      totalDistanceM += segmentDistM;
    }

    // Convert to warmth points:
    // ~100m walking = 0.1 point, ~500m = 0.5 point, etc.
    // Scale: 1 point per 100m walked at walking speed, capped at max
    var rawPoints = totalDistanceM / 100;
    return Math.min(WARMTH_POINTS_MAX, rawPoints);
  }

  /**
   * Converts warmth points to harvest and discovery multipliers.
   * Constitution Â§5.3 â€” "Minor bonuses only. Not enough to create inequality."
   *   Max harvest bonus: 10%
   *   Max discovery bonus: 15%
   *
   * @param {number} warmthPoints - Warmth accumulated (0 to WARMTH_POINTS_MAX)
   * @returns {{harvestMultiplier: number, discoveryMultiplier: number}}
   */
  function getWarmthBonus(warmthPoints) {
    if (typeof warmthPoints !== 'number' || warmthPoints < 0) {
      warmthPoints = 0;
    }

    // Clamp to max warmth so bonuses never exceed caps
    var clamped = Math.min(warmthPoints, WARMTH_POINTS_MAX);
    var fraction = clamped / WARMTH_POINTS_MAX; // 0.0 to 1.0

    var harvestMultiplier = 1.0 + (fraction * WARMTH_HARVEST_MAX_BONUS);
    var discoveryMultiplier = 1.0 + (fraction * WARMTH_DISCOVERY_MAX_BONUS);

    // Enforce caps (belt-and-suspenders)
    harvestMultiplier = Math.min(1.0 + WARMTH_HARVEST_MAX_BONUS, harvestMultiplier);
    discoveryMultiplier = Math.min(1.0 + WARMTH_DISCOVERY_MAX_BONUS, discoveryMultiplier);

    return {
      harvestMultiplier: harvestMultiplier,
      discoveryMultiplier: discoveryMultiplier
    };
  }

  // ============================================================
  // GPS <-> Zone Mapping
  // ============================================================

  /**
   * Returns the ZION zone name nearest to the given GPS coordinates,
   * based on the positions of existing anchors.
   *
   * @param {number} lat - Player latitude
   * @param {number} lon - Player longitude
   * @param {Array|Object} anchors - Anchor data
   * @returns {string|null} Zone name, or null if no anchors exist
   */
  function geoToZone(lat, lon, anchors) {
    var arr = toArray(anchors);
    if (arr.length === 0) return null;

    var nearest = null;
    var nearestDist = Infinity;

    for (var i = 0; i < arr.length; i++) {
      var anchor = arr[i];
      if (!anchor.geo) continue;
      var dist = getDistance(lat, lon, anchor.geo.lat, anchor.geo.lon);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = anchor.zone;
      }
    }

    return nearest;
  }

  /**
   * Computes the average GPS position (centroid) of all anchors in a given zone.
   * Useful for guiding AR players toward a zone.
   *
   * @param {string} zone - Zone name
   * @param {Array|Object} anchors - Anchor data
   * @returns {{lat: number, lon: number}|null} Centroid, or null if zone has no anchors
   */
  function zoneToGeoCenter(zone, anchors) {
    var zoneAnchors = getZoneAnchors(zone, anchors);
    if (zoneAnchors.length === 0) return null;

    var totalLat = 0;
    var totalLon = 0;
    for (var i = 0; i < zoneAnchors.length; i++) {
      totalLat += zoneAnchors[i].geo.lat;
      totalLon += zoneAnchors[i].geo.lon;
    }

    return {
      lat: totalLat / zoneAnchors.length,
      lon: totalLon / zoneAnchors.length
    };
  }

  /**
   * Returns all anchors that belong to a specific zone.
   *
   * @param {string} zone - Zone name
   * @param {Array|Object} anchors - Anchor data
   * @returns {Array} Anchors in the specified zone
   */
  function getZoneAnchors(zone, anchors) {
    var arr = toArray(anchors);
    return arr.filter(function(anchor) { return anchor.zone === zone; });
  }

  // ============================================================
  // Safety (Constitution Â§8.6)
  // ============================================================

  /**
   * Safety module â€” Physical Realm Safety per Constitution Â§8.6.
   * The client MUST:
   *   - Display safety warning before enabling AR
   *   - Pause AR at driving speed
   *   - Require explicit location permission
   *   - Function fully without location access
   */
  var SAFETY = {
    requiresPermission: true,
    maxSessionHours: 4,

    /**
     * Checks whether the given speed is safe for AR play.
     * Constitution Â§8.6 â€” pause AR when driving speed detected.
     *
     * @param {number} speedKmh - Current speed in km/h
     * @returns {{safe: boolean, warning?: string}}
     */
    checkSpeed: function(speedKmh) {
      if (isDrivingSpeed(speedKmh)) {
        return {
          safe: false,
          warning: 'AR paused: Moving too fast (' + Math.round(speedKmh) + ' km/h). ' +
                   'Please stop and play ZION on foot. Stay safe!'
        };
      }
      return { safe: true };
    },

    /**
     * Returns the standard AR safety disclaimer.
     * Constitution Â§8.6 â€” MUST display before enabling AR/camera mode.
     *
     * @returns {string}
     */
    getWarningMessage: function() {
      return 'SAFETY: AR mode uses your camera and GPS. ' +
             'Always be aware of your surroundings. ' +
             'Do not enter roads, restricted areas, or private property. ' +
             'Never use AR while driving or cycling. ' +
             'ZION anchors are placed at public, safe locations only. ' +
             'Location permission is required for AR features but ZION works fully without it.';
    }
  };

  // ============================================================
  // State Management
  // ============================================================

  /**
   * Parses a JSON string (the contents of state/anchors.json) into an anchor registry.
   *
   * @param {string} anchorsJson - JSON string
   * @returns {Object} Parsed anchor state object
   */
  function loadState(anchorsJson) {
    try {
      var state = JSON.parse(anchorsJson);
      if (!state.anchors || typeof state.anchors !== 'object') {
        state.anchors = {};
      }
      return state;
    } catch (e) {
      return { anchors: {} };
    }
  }

  /**
   * Serializes an anchor state object to a JSON string.
   *
   * @param {Object} anchorsState - The state object
   * @returns {string} JSON string
   */
  function saveState(anchorsState) {
    return JSON.stringify(anchorsState, null, 2);
  }

  /**
   * Adds an anchor to the state (keyed by anchor.id).
   * Returns a new state object without mutating the original.
   *
   * @param {Object} state - Current anchor state
   * @param {Object} anchor - Anchor object with .id
   * @returns {Object} New state with anchor added
   */
  function addAnchor(state, anchor) {
    var newAnchors = {};
    for (var k in state.anchors) {
      if (Object.prototype.hasOwnProperty.call(state.anchors, k)) {
        newAnchors[k] = state.anchors[k];
      }
    }
    newAnchors[anchor.id] = anchor;
    return { anchors: newAnchors };
  }

  /**
   * Removes an anchor from the state by its ID.
   * Returns a new state object without mutating the original.
   *
   * @param {Object} state - Current anchor state
   * @param {string} anchorId - ID of anchor to remove
   * @returns {Object} New state with anchor removed
   */
  function removeAnchor(state, anchorId) {
    var newAnchors = {};
    for (var k in state.anchors) {
      if (Object.prototype.hasOwnProperty.call(state.anchors, k) && k !== anchorId) {
        newAnchors[k] = state.anchors[k];
      }
    }
    return { anchors: newAnchors };
  }

  /**
   * Computes aggregate statistics about the anchor registry.
   *
   * @param {Object} state - Anchor state
   * @returns {{totalAnchors: number, byType: Object, byZone: Object, totalDiscoveries: number}}
   */
  function getStats(state) {
    var byType = {};
    var byZone = {};
    var totalDiscoveries = 0;
    var totalAnchors = 0;

    var anchors = state.anchors || {};
    for (var id in anchors) {
      if (!Object.prototype.hasOwnProperty.call(anchors, id)) continue;

      var anchor = anchors[id];
      totalAnchors++;

      // By type
      var t = anchor.type || 'unknown';
      byType[t] = (byType[t] || 0) + 1;

      // By zone
      var z = anchor.zone || 'unknown';
      byZone[z] = (byZone[z] || 0) + 1;

      // Discoveries
      totalDiscoveries += (typeof anchor.discoveries === 'number') ? anchor.discoveries : 0;
    }

    return {
      totalAnchors: totalAnchors,
      byType: byType,
      byZone: byZone,
      totalDiscoveries: totalDiscoveries
    };
  }

  // ============================================================
  // Exports
  // ============================================================

  exports.TYPES = TYPES;
  exports.VALID_TYPES = VALID_TYPES;
  exports.VALID_ZONES = VALID_ZONES;
  exports.SAFETY = SAFETY;

  // Geolocation
  exports.requestLocation = requestLocation;
  exports.watchLocation = watchLocation;
  exports.stopWatching = stopWatching;
  exports.getDistance = getDistance;
  exports.isWalkingSpeed = isWalkingSpeed;
  exports.isDrivingSpeed = isDrivingSpeed;

  // Anchor management
  exports.create = create;
  exports.validate = validate;
  exports.approve = approve;
  exports.reject = reject;

  // Discovery
  exports.getNearby = getNearby;
  exports.isInRange = isInRange;
  exports.discover = discover;
  exports.getDiscoveredBy = getDiscoveredBy;

  // Warmth
  exports.calculateWarmth = calculateWarmth;
  exports.getWarmthBonus = getWarmthBonus;

  // GPS <-> Zone mapping
  exports.geoToZone = geoToZone;
  exports.zoneToGeoCenter = zoneToGeoCenter;
  exports.getZoneAnchors = getZoneAnchors;

  // State management
  exports.loadState = loadState;
  exports.saveState = saveState;
  exports.addAnchor = addAnchor;
  exports.removeAnchor = removeAnchor;
  exports.getStats = getStats;

})(typeof module !== 'undefined' ? module.exports : (window.Anchors = {}));


// physical.js
(function(exports) {

  // Anchor types
  const ANCHOR_TYPES = [
    'zone_portal', 'resource_node', 'discovery_point',
    'gathering_spot', 'garden_plot'
  ];

  // Generate unique IDs
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // Haversine distance calculation (returns km)
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const toRad = deg => deg * Math.PI / 180;

    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    return distance;
  }

  // Validate anchor location
  function validateAnchorLocation(lat, lon) {
    // Check valid range
    if (typeof lat !== 'number' || typeof lon !== 'number') {
      return {safe: false, reason: 'Invalid coordinate types'};
    }

    if (lat < -90 || lat > 90) {
      return {safe: false, reason: 'Latitude out of range (-90 to 90)'};
    }

    if (lon < -180 || lon > 180) {
      return {safe: false, reason: 'Longitude out of range (-180 to 180)'};
    }

    // Check not exactly (0,0) - null island
    if (lat === 0 && lon === 0) {
      return {safe: false, reason: 'Null Island coordinates not allowed'};
    }

    // Check not in ocean (basic check: reject if far from land)
    if (Math.abs(lat) > 85 && Math.abs(lon) > 170) {
      return {safe: false, reason: 'Location appears to be in remote ocean'};
    }

    return {safe: true};
  }

  // Create anchor
  function createAnchor(msg, state) {
    const lat = msg.payload.lat;
    const lon = msg.payload.lon;

    // Validate GPS coordinates
    if (lat === undefined || lon === undefined) {
      return {
        success: false,
        error: 'Missing GPS coordinates'
      };
    }

    const validation = validateAnchorLocation(lat, lon);
    if (!validation.safe) {
      return {
        success: false,
        error: validation.reason
      };
    }

    const anchorType = msg.payload.type || 'discovery_point';
    if (!ANCHOR_TYPES.includes(anchorType)) {
      return {
        success: false,
        error: 'Invalid anchor type'
      };
    }

    const anchor = {
      id: generateId(),
      type: anchorType,
      position: msg.payload.position || {x: 0, y: 0, z: 0},
      zone: msg.payload.zone || 'default',
      lat: lat,
      lon: lon,
      creator: msg.from,
      ts: Date.now(),
      status: 'pending'
    };

    // Initialize state.anchors if needed
    if (!state.anchors) {
      state.anchors = [];
    }

    state.anchors.push(anchor);

    return {
      success: true,
      state: state,
      anchor: anchor
    };
  }

  // Calculate warmth from GPS history
  function calculateWarmth(gpsHistory) {
    // Null-safe: return 0 if no history
    if (!gpsHistory || !Array.isArray(gpsHistory) || gpsHistory.length < 2) {
      return 0;
    }

    let totalKm = 0;
    const maxWalkingSpeed = 25; // km/h - filter out driving

    for (let i = 1; i < gpsHistory.length; i++) {
      const prev = gpsHistory[i - 1];
      const curr = gpsHistory[i];

      // Skip if missing data
      if (!prev.lat || !prev.lon || !curr.lat || !curr.lon || !prev.ts || !curr.ts) {
        continue;
      }

      const distance = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
      const timeHours = (curr.ts - prev.ts) / (1000 * 60 * 60);

      // Skip if time is zero or negative
      if (timeHours <= 0) {
        continue;
      }

      const speed = distance / timeHours;

      // Filter out driving speed
      if (speed <= maxWalkingSpeed) {
        totalKm += distance;
      }
    }

    // Return warmth capped at 100
    const warmth = Math.min(100, totalKm * 10);
    return warmth;
  }

  // Get warmth bonus multiplier
  function getWarmthBonus(warmth) {
    // Null-safe: if warmth is null/undefined, treat as 0
    if (typeof warmth !== 'number' || warmth < 0) {
      warmth = 0;
    }

    // Returns 1.0 + (warmth / 1000)
    // Max 1.1 at warmth=100 (10% bonus)
    return 1.0 + (warmth / 1000);
  }

  /**
   * Get speed from GPS position (for AR safety - pause at driving speed)
   * @param {Object} prev - Previous GPS point {lat, lon, ts}
   * @param {Object} curr - Current GPS point {lat, lon, ts}
   * @returns {number} Speed in km/h
   */
  function getSpeed(prev, curr) {
    if (!prev || !curr || !prev.ts || !curr.ts) return 0;
    var dist = haversineDistance(prev.lat, prev.lon, curr.lat, curr.lon);
    var hours = (curr.ts - prev.ts) / (1000 * 60 * 60);
    if (hours <= 0) return 0;
    return dist / hours;
  }

  /**
   * Check if player is moving too fast for AR mode (driving)
   * @param {Array} recentGPS - Last 3+ GPS points
   * @returns {boolean} true if driving speed detected
   */
  function isDrivingSpeed(recentGPS) {
    if (!recentGPS || recentGPS.length < 2) return false;
    var last = recentGPS[recentGPS.length - 1];
    var prev = recentGPS[recentGPS.length - 2];
    return getSpeed(prev, last) > 30; // 30 km/h threshold
  }

  /**
   * Get warmth tier label
   * @param {number} warmth - Warmth value 0-100
   * @returns {string} Tier label
   */
  function getWarmthTier(warmth) {
    if (warmth >= 80) return 'Sunwalker';
    if (warmth >= 50) return 'Wanderer';
    if (warmth >= 20) return 'Stroller';
    if (warmth > 0) return 'Newcomer';
    return 'Indoor';
  }

  // Exports
  exports.ANCHOR_TYPES = ANCHOR_TYPES;
  exports.createAnchor = createAnchor;
  exports.validateAnchorLocation = validateAnchorLocation;
  exports.calculateWarmth = calculateWarmth;
  exports.getWarmthBonus = getWarmthBonus;
  exports.haversineDistance = haversineDistance;
  exports.getSpeed = getSpeed;
  exports.isDrivingSpeed = isDrivingSpeed;
  exports.getWarmthTier = getWarmthTier;

})(typeof module !== 'undefined' ? module.exports : (window.Physical = {}));


// guilds.js
(function(exports) {
  'use strict';

  // Guild/Association system for ZION MMO
  // Implements community formation per ZION Constitution Â§2.3 and Â§5.4

  // State storage
  var guilds = [];
  var invites = [];
  var guildMessages = [];
  var nextGuildId = 1;
  var nextInviteId = 1;
  var nextMessageId = 1;

  // Guild level thresholds
  var LEVEL_THRESHOLDS = [
    { level: 1, xp: 0, maxMembers: 20 },
    { level: 2, xp: 500, maxMembers: 30 },
    { level: 3, xp: 1500, maxMembers: 40 },
    { level: 4, xp: 3000, maxMembers: 50 },
    { level: 5, xp: 6000, maxMembers: 60 }
  ];

  // Constants
  var GUILD_CREATION_COST = 100;
  var INVITE_EXPIRY_MS = 3600000; // 1 hour

  /**
   * Initialize guilds system with saved data
   * @param {object} existingData - Previously saved guild data
   */
  function initGuilds(existingData) {
    if (!existingData) return;

    guilds = existingData.guilds || [];
    invites = existingData.invites || [];
    guildMessages = existingData.guildMessages || [];
    nextGuildId = existingData.nextGuildId || 1;
    nextInviteId = existingData.nextInviteId || 1;
    nextMessageId = existingData.nextMessageId || 1;

    console.log('Guilds initialized:', guilds.length, 'guilds');
  }

  /**
   * Get guilds state for saving
   * @returns {object} - Serializable guild state
   */
  function getGuildsState() {
    return {
      guilds: guilds,
      invites: invites,
      guildMessages: guildMessages,
      nextGuildId: nextGuildId,
      nextInviteId: nextInviteId,
      nextMessageId: nextMessageId
    };
  }

  /**
   * Create a new guild
   * @param {string} playerId - Founder player ID
   * @param {string} name - Guild name
   * @param {string} tag - Guild tag (3-5 chars)
   * @param {string} type - Guild type: 'guild'|'garden'|'studio'|'community'
   * @param {string} description - Guild description
   * @returns {object} - { success: boolean, guild?: object, error?: string }
   */
  function createGuild(playerId, name, tag, type, description) {
    // Validate parameters
    if (!playerId || !name || !tag || !type) {
      return { success: false, error: 'Missing required parameters' };
    }

    if (tag.length < 3 || tag.length > 5) {
      return { success: false, error: 'Tag must be 3-5 characters' };
    }

    if (['guild', 'garden', 'studio', 'community'].indexOf(type) === -1) {
      return { success: false, error: 'Invalid guild type' };
    }

    // Check if player already in a guild
    var existingGuild = getPlayerGuild(playerId);
    if (existingGuild) {
      return { success: false, error: 'Already in a guild' };
    }

    // Check if guild name or tag already exists
    var nameExists = guilds.some(function(g) { return g.name === name; });
    var tagExists = guilds.some(function(g) { return g.tag === tag; });

    if (nameExists) {
      return { success: false, error: 'Guild name already taken' };
    }

    if (tagExists) {
      return { success: false, error: 'Guild tag already taken' };
    }

    // Create guild
    var guild = {
      id: 'guild_' + (nextGuildId++),
      name: name,
      tag: tag,
      description: description || '',
      founder: playerId,
      leaders: [playerId],
      members: [{
        playerId: playerId,
        role: 'leader',
        joinedAt: Date.now()
      }],
      createdAt: Date.now(),
      zone: 'nexus', // Default home zone
      type: type,
      banner: {
        primaryColor: '#FFD700',
        secondaryColor: '#4A4A4A',
        icon: 'star'
      },
      treasury: 0,
      level: 1,
      xp: 0,
      maxMembers: 20,
      settings: {
        open: true,
        minLevel: 0
      },
      activities: []
    };

    guilds.push(guild);

    // Log activity
    addActivity(guild.id, playerId + ' founded the ' + type);

    return {
      success: true,
      guild: guild,
      cost: GUILD_CREATION_COST
    };
  }

  /**
   * Disband a guild
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be founder)
   * @returns {object} - { success: boolean, error?: string }
   */
  function disbandGuild(guildId, playerId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    if (guild.founder !== playerId) {
      return { success: false, error: 'Only founder can disband guild' };
    }

    // Remove guild
    guilds = guilds.filter(function(g) { return g.id !== guildId; });

    // Remove invites
    invites = invites.filter(function(i) { return i.guildId !== guildId; });

    // Remove messages
    guildMessages = guildMessages.filter(function(m) { return m.guildId !== guildId; });

    return { success: true };
  }

  /**
   * Invite player to guild
   * @param {string} guildId - Guild ID
   * @param {string} inviterId - Inviter player ID
   * @param {string} targetId - Target player ID
   * @returns {object} - { success: boolean, invite?: object, error?: string }
   */
  function inviteToGuild(guildId, inviterId, targetId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    // Check inviter has permission
    var inviterMember = guild.members.find(function(m) { return m.playerId === inviterId; });
    if (!inviterMember || (inviterMember.role !== 'leader' && inviterMember.role !== 'officer')) {
      return { success: false, error: 'No permission to invite' };
    }

    // Check target not already in guild
    var targetInGuild = guild.members.some(function(m) { return m.playerId === targetId; });
    if (targetInGuild) {
      return { success: false, error: 'Player already in guild' };
    }

    // Check target not in another guild
    var targetGuild = getPlayerGuild(targetId);
    if (targetGuild) {
      return { success: false, error: 'Player already in another guild' };
    }

    // Check guild not full
    if (guild.members.length >= guild.maxMembers) {
      return { success: false, error: 'Guild is full' };
    }

    // Check if invite already exists
    var existingInvite = invites.find(function(i) {
      return i.guildId === guildId && i.targetId === targetId && i.status === 'pending';
    });

    if (existingInvite) {
      return { success: false, error: 'Invite already sent' };
    }

    // Create invite
    var invite = {
      id: 'invite_' + (nextInviteId++),
      guildId: guildId,
      guildName: guild.name,
      guildTag: guild.tag,
      inviterId: inviterId,
      targetId: targetId,
      status: 'pending',
      createdAt: Date.now(),
      expiresAt: Date.now() + INVITE_EXPIRY_MS
    };

    invites.push(invite);

    return { success: true, invite: invite };
  }

  /**
   * Accept guild invite
   * @param {string} inviteId - Invite ID
   * @param {string} playerId - Player ID
   * @returns {object} - { success: boolean, guild?: object, error?: string }
   */
  function acceptInvite(inviteId, playerId) {
    var invite = invites.find(function(i) { return i.id === inviteId; });
    if (!invite) {
      return { success: false, error: 'Invite not found' };
    }

    if (invite.targetId !== playerId) {
      return { success: false, error: 'Invite not for this player' };
    }

    if (invite.status !== 'pending') {
      return { success: false, error: 'Invite already responded to' };
    }

    if (Date.now() > invite.expiresAt) {
      invite.status = 'expired';
      return { success: false, error: 'Invite expired' };
    }

    var guild = getGuild(invite.guildId);
    if (!guild) {
      return { success: false, error: 'Guild no longer exists' };
    }

    // Check player not in another guild
    var playerGuild = getPlayerGuild(playerId);
    if (playerGuild) {
      return { success: false, error: 'Already in a guild' };
    }

    // Check guild not full
    if (guild.members.length >= guild.maxMembers) {
      return { success: false, error: 'Guild is full' };
    }

    // Add member
    guild.members.push({
      playerId: playerId,
      role: 'member',
      joinedAt: Date.now()
    });

    invite.status = 'accepted';

    // Log activity
    addActivity(guild.id, playerId + ' joined the guild');

    return { success: true, guild: guild };
  }

  /**
   * Decline guild invite
   * @param {string} inviteId - Invite ID
   * @param {string} playerId - Player ID
   * @returns {object} - { success: boolean, error?: string }
   */
  function declineInvite(inviteId, playerId) {
    var invite = invites.find(function(i) { return i.id === inviteId; });
    if (!invite) {
      return { success: false, error: 'Invite not found' };
    }

    if (invite.targetId !== playerId) {
      return { success: false, error: 'Invite not for this player' };
    }

    if (invite.status !== 'pending') {
      return { success: false, error: 'Invite already responded to' };
    }

    invite.status = 'declined';

    return { success: true };
  }

  /**
   * Leave guild
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID
   * @returns {object} - { success: boolean, error?: string }
   */
  function leaveGuild(guildId, playerId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var memberIndex = guild.members.findIndex(function(m) { return m.playerId === playerId; });
    if (memberIndex === -1) {
      return { success: false, error: 'Not a member of this guild' };
    }

    // Founder cannot leave (must disband)
    if (guild.founder === playerId) {
      return { success: false, error: 'Founder must disband guild instead' };
    }

    // Remove member
    guild.members.splice(memberIndex, 1);

    // Remove from leaders if applicable
    guild.leaders = guild.leaders.filter(function(id) { return id !== playerId; });

    // Log activity
    addActivity(guild.id, playerId + ' left the guild');

    return { success: true };
  }

  /**
   * Kick member from guild
   * @param {string} guildId - Guild ID
   * @param {string} kickerId - Kicker player ID
   * @param {string} targetId - Target player ID
   * @returns {object} - { success: boolean, error?: string }
   */
  function kickMember(guildId, kickerId, targetId) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    // Check kicker has permission
    var kickerMember = guild.members.find(function(m) { return m.playerId === kickerId; });
    if (!kickerMember || (kickerMember.role !== 'leader' && kickerMember.role !== 'officer')) {
      return { success: false, error: 'No permission to kick' };
    }

    // Cannot kick founder
    if (guild.founder === targetId) {
      return { success: false, error: 'Cannot kick founder' };
    }

    // Cannot kick self
    if (kickerId === targetId) {
      return { success: false, error: 'Cannot kick yourself' };
    }

    var targetMember = guild.members.find(function(m) { return m.playerId === targetId; });
    if (!targetMember) {
      return { success: false, error: 'Player not in guild' };
    }

    // Officers cannot kick other officers or leaders
    if (kickerMember.role === 'officer' && (targetMember.role === 'officer' || targetMember.role === 'leader')) {
      return { success: false, error: 'Insufficient permission' };
    }

    // Remove member
    guild.members = guild.members.filter(function(m) { return m.playerId !== targetId; });

    // Remove from leaders if applicable
    guild.leaders = guild.leaders.filter(function(id) { return id !== targetId; });

    // Log activity
    addActivity(guild.id, targetId + ' was kicked from guild');

    return { success: true };
  }

  /**
   * Promote/demote member
   * @param {string} guildId - Guild ID
   * @param {string} promoterId - Promoter player ID
   * @param {string} targetId - Target player ID
   * @param {string} newRole - New role: 'leader'|'officer'|'member'
   * @returns {object} - { success: boolean, error?: string }
   */
  function promoteRole(guildId, promoterId, targetId, newRole) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    if (['leader', 'officer', 'member'].indexOf(newRole) === -1) {
      return { success: false, error: 'Invalid role' };
    }

    // Only leaders can promote
    var promoterMember = guild.members.find(function(m) { return m.playerId === promoterId; });
    if (!promoterMember || promoterMember.role !== 'leader') {
      return { success: false, error: 'Only leaders can promote' };
    }

    // Cannot change founder's role
    if (guild.founder === targetId && newRole !== 'leader') {
      return { success: false, error: 'Cannot demote founder' };
    }

    var targetMember = guild.members.find(function(m) { return m.playerId === targetId; });
    if (!targetMember) {
      return { success: false, error: 'Player not in guild' };
    }

    var oldRole = targetMember.role;
    targetMember.role = newRole;

    // Update leaders array
    if (newRole === 'leader' && guild.leaders.indexOf(targetId) === -1) {
      guild.leaders.push(targetId);
    } else if (newRole !== 'leader' && guild.leaders.indexOf(targetId) !== -1) {
      guild.leaders = guild.leaders.filter(function(id) { return id !== targetId; });
    }

    // Log activity
    addActivity(guild.id, targetId + ' promoted from ' + oldRole + ' to ' + newRole);

    return { success: true };
  }

  /**
   * Get guild by ID
   * @param {string} guildId - Guild ID
   * @returns {object|null} - Guild data or null
   */
  function getGuild(guildId) {
    return guilds.find(function(g) { return g.id === guildId; }) || null;
  }

  /**
   * Get player's guild
   * @param {string} playerId - Player ID
   * @returns {object|null} - Guild data or null
   */
  function getPlayerGuild(playerId) {
    return guilds.find(function(g) {
      return g.members.some(function(m) { return m.playerId === playerId; });
    }) || null;
  }

  /**
   * Get guild members with details
   * @param {string} guildId - Guild ID
   * @returns {array} - Array of member objects
   */
  function getGuildMembers(guildId) {
    var guild = getGuild(guildId);
    if (!guild) return [];

    return guild.members.map(function(m) {
      return {
        playerId: m.playerId,
        role: m.role,
        joinedAt: m.joinedAt,
        online: false // Would be populated by game state
      };
    });
  }

  /**
   * Search guilds by name
   * @param {string} query - Search query
   * @returns {array} - Matching guilds
   */
  function searchGuilds(query) {
    var lowerQuery = query.toLowerCase();
    return guilds.filter(function(g) {
      return g.name.toLowerCase().indexOf(lowerQuery) !== -1 ||
             g.tag.toLowerCase().indexOf(lowerQuery) !== -1;
    });
  }

  /**
   * Get guilds by type
   * @param {string} type - Guild type
   * @returns {array} - Guilds of that type
   */
  function getGuildsByType(type) {
    return guilds.filter(function(g) { return g.type === type; });
  }

  /**
   * Deposit to guild treasury
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID
   * @param {number} amount - Amount to deposit
   * @returns {object} - { success: boolean, error?: string }
   */
  function depositToTreasury(guildId, playerId, amount) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member) {
      return { success: false, error: 'Not a member of this guild' };
    }

    if (amount <= 0) {
      return { success: false, error: 'Invalid amount' };
    }

    guild.treasury += amount;

    // Log activity
    addActivity(guild.id, playerId + ' deposited ' + amount + ' Spark to treasury');

    return { success: true };
  }

  /**
   * Withdraw from guild treasury
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be leader)
   * @param {number} amount - Amount to withdraw
   * @returns {object} - { success: boolean, error?: string }
   */
  function withdrawFromTreasury(guildId, playerId, amount) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can withdraw' };
    }

    if (amount <= 0) {
      return { success: false, error: 'Invalid amount' };
    }

    if (guild.treasury < amount) {
      return { success: false, error: 'Insufficient treasury funds' };
    }

    guild.treasury -= amount;

    // Log activity
    addActivity(guild.id, playerId + ' withdrew ' + amount + ' Spark from treasury');

    return { success: true };
  }

  /**
   * Add XP to guild
   * @param {string} guildId - Guild ID
   * @param {number} amount - XP amount
   * @param {string} activity - Activity description
   * @returns {object} - { success: boolean, leveledUp: boolean, newLevel?: number }
   */
  function addGuildXP(guildId, amount, activity) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, leveledUp: false };
    }

    guild.xp += amount;

    // Check for level up
    var newLevel = calculateLevel(guild.xp);
    var leveledUp = newLevel > guild.level;

    if (leveledUp) {
      guild.level = newLevel;
      var threshold = LEVEL_THRESHOLDS.find(function(t) { return t.level === newLevel; });
      if (threshold) {
        guild.maxMembers = threshold.maxMembers;
      }

      // Log activity
      addActivity(guild.id, 'Guild reached level ' + newLevel + '!');
    }

    // Log XP activity
    if (activity) {
      addActivity(guild.id, activity + ' (+' + amount + ' XP)');
    }

    return {
      success: true,
      leveledUp: leveledUp,
      newLevel: leveledUp ? newLevel : undefined
    };
  }

  /**
   * Calculate guild level from XP
   * @param {number} xp - Total XP
   * @returns {number} - Guild level
   */
  function calculateLevel(xp) {
    for (var i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
      if (xp >= LEVEL_THRESHOLDS[i].xp) {
        return LEVEL_THRESHOLDS[i].level;
      }
    }
    return 1;
  }

  /**
   * Get guild leaderboard
   * @returns {array} - Top guilds sorted by XP
   */
  function getGuildLeaderboard() {
    return guilds
      .slice()
      .sort(function(a, b) { return b.xp - a.xp; })
      .slice(0, 10)
      .map(function(g) {
        return {
          id: g.id,
          name: g.name,
          tag: g.tag,
          type: g.type,
          level: g.level,
          xp: g.xp,
          memberCount: g.members.length
        };
      });
  }

  /**
   * Set guild banner
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be leader)
   * @param {object} banner - Banner config { primaryColor, secondaryColor, icon }
   * @returns {object} - { success: boolean, error?: string }
   */
  function setGuildBanner(guildId, playerId, banner) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can change banner' };
    }

    guild.banner = banner;

    // Log activity
    addActivity(guild.id, 'Guild banner updated');

    return { success: true };
  }

  /**
   * Get guild activities
   * @param {string} guildId - Guild ID
   * @param {number} limit - Max number of activities
   * @returns {array} - Activity log
   */
  function getGuildActivities(guildId, limit) {
    var guild = getGuild(guildId);
    if (!guild) return [];

    var activities = guild.activities.slice();
    if (limit) {
      activities = activities.slice(-limit);
    }

    return activities.reverse(); // Most recent first
  }

  /**
   * Send guild message
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Sender player ID
   * @param {string} text - Message text
   * @returns {object} - { success: boolean, message?: object, error?: string }
   */
  function sendGuildMessage(guildId, playerId, text) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member) {
      return { success: false, error: 'Not a member of this guild' };
    }

    var message = {
      id: 'msg_' + (nextMessageId++),
      guildId: guildId,
      playerId: playerId,
      text: text,
      timestamp: Date.now()
    };

    guildMessages.push(message);

    return { success: true, message: message };
  }

  /**
   * Get guild messages
   * @param {string} guildId - Guild ID
   * @param {number} limit - Max number of messages
   * @returns {array} - Messages
   */
  function getGuildMessages(guildId, limit) {
    var messages = guildMessages.filter(function(m) { return m.guildId === guildId; });

    if (limit) {
      messages = messages.slice(-limit);
    }

    return messages;
  }

  /**
   * Add activity to guild log
   * @param {string} guildId - Guild ID
   * @param {string} activity - Activity description
   */
  function addActivity(guildId, activity) {
    var guild = getGuild(guildId);
    if (!guild) return;

    guild.activities.push({
      timestamp: Date.now(),
      text: activity
    });

    // Keep only last 50 activities
    if (guild.activities.length > 50) {
      guild.activities = guild.activities.slice(-50);
    }
  }

  /**
   * Get pending invites for player
   * @param {string} playerId - Player ID
   * @returns {array} - Pending invites
   */
  function getPendingInvites(playerId) {
    return invites.filter(function(i) {
      return i.targetId === playerId &&
             i.status === 'pending' &&
             Date.now() <= i.expiresAt;
    });
  }

  /**
   * Update guild settings
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID (must be leader)
   * @param {object} settings - Settings to update
   * @returns {object} - { success: boolean, error?: string }
   */
  function updateGuildSettings(guildId, playerId, settings) {
    var guild = getGuild(guildId);
    if (!guild) {
      return { success: false, error: 'Guild not found' };
    }

    var member = guild.members.find(function(m) { return m.playerId === playerId; });
    if (!member || member.role !== 'leader') {
      return { success: false, error: 'Only leaders can update settings' };
    }

    // Update allowed settings
    if (settings.hasOwnProperty('open')) {
      guild.settings.open = settings.open;
    }
    if (settings.hasOwnProperty('minLevel')) {
      guild.settings.minLevel = settings.minLevel;
    }

    return { success: true };
  }

  // Export public API
  exports.initGuilds = initGuilds;
  exports.getGuildsState = getGuildsState;
  exports.createGuild = createGuild;
  exports.disbandGuild = disbandGuild;
  exports.inviteToGuild = inviteToGuild;
  exports.acceptInvite = acceptInvite;
  exports.declineInvite = declineInvite;
  exports.leaveGuild = leaveGuild;
  exports.kickMember = kickMember;
  exports.promoteRole = promoteRole;
  exports.getGuild = getGuild;
  exports.getPlayerGuild = getPlayerGuild;
  exports.getGuildMembers = getGuildMembers;
  exports.searchGuilds = searchGuilds;
  exports.getGuildsByType = getGuildsByType;
  exports.depositToTreasury = depositToTreasury;
  exports.withdrawFromTreasury = withdrawFromTreasury;
  exports.addGuildXP = addGuildXP;
  exports.getGuildLeaderboard = getGuildLeaderboard;
  exports.setGuildBanner = setGuildBanner;
  exports.getGuildActivities = getGuildActivities;
  exports.sendGuildMessage = sendGuildMessage;
  exports.getGuildMessages = getGuildMessages;
  exports.getPendingInvites = getPendingInvites;
  exports.updateGuildSettings = updateGuildSettings;

})(typeof module !== 'undefined' ? module.exports : (window.Guilds = {}));


// mentoring.js
(function(exports) {
  'use strict';

  // ============================================================================
  // SKILL TREE CONFIGURATION
  // ============================================================================

  var SKILLS = {
    gardening: {
      name: 'Gardening',
      levels: ['Seedling', 'Sprout', 'Gardener', 'Botanist', 'Grove Master'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    crafting: {
      name: 'Crafting',
      levels: ['Novice', 'Apprentice', 'Journeyman', 'Artisan', 'Master Crafter'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    building: {
      name: 'Building',
      levels: ['Laborer', 'Builder', 'Architect', 'Engineer', 'Grand Architect'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    exploration: {
      name: 'Exploration',
      levels: ['Wanderer', 'Scout', 'Explorer', 'Pathfinder', 'Cartographer'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    trading: {
      name: 'Trading',
      levels: ['Haggler', 'Merchant', 'Trader', 'Mogul', 'Trade Baron'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    social: {
      name: 'Social',
      levels: ['Shy', 'Friendly', 'Sociable', 'Diplomat', 'Ambassador'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    combat: {
      name: 'Combat',
      levels: ['Brawler', 'Fighter', 'Warrior', 'Champion', 'Arena Legend'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    },
    lore: {
      name: 'Lore',
      levels: ['Curious', 'Student', 'Scholar', 'Sage', 'Lorekeeper'],
      xpPerLevel: [0, 100, 300, 600, 1000]
    }
  };

  // NPC archetype to skill mapping
  var NPC_TEACHING_SPECIALTIES = {
    farmer: 'gardening',
    gardener: 'gardening',
    artisan: 'crafting',
    creator: 'crafting',
    builder: 'building',
    architect: 'building',
    explorer: 'exploration',
    ranger: 'exploration',
    merchant: 'trading',
    trader: 'trading',
    diplomat: 'social',
    storyteller: 'social',
    warrior: 'combat',
    guardian: 'combat',
    scholar: 'lore',
    sage: 'lore'
  };

  // ============================================================================
  // STATE MANAGEMENT
  // ============================================================================

  var playerSkills = {}; // playerId -> { skillName: { xp, level, levelName } }
  var mentorships = {}; // mentorshipId -> mentorship object
  var mentorshipOffers = {}; // offerId -> offer object
  var npcLessons = {}; // lessonId -> lesson object
  var mentorshipIdCounter = 0;
  var offerIdCounter = 0;
  var lessonIdCounter = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function generateId(prefix) {
    return prefix + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  function getSkillLevel(xp, skill) {
    if (!SKILLS[skill]) return 0;
    var thresholds = SKILLS[skill].xpPerLevel;
    for (var i = thresholds.length - 1; i >= 0; i--) {
      if (xp >= thresholds[i]) return i;
    }
    return 0;
  }

  function getLevelName(level, skill) {
    if (!SKILLS[skill] || level < 0 || level >= SKILLS[skill].levels.length) {
      return 'Unknown';
    }
    return SKILLS[skill].levels[level];
  }

  // ============================================================================
  // PLAYER SKILLS
  // ============================================================================

  function initPlayerSkills(playerId) {
    if (playerSkills[playerId]) return playerSkills[playerId];

    playerSkills[playerId] = {};
    for (var skillName in SKILLS) {
      playerSkills[playerId][skillName] = {
        xp: 0,
        level: 0,
        levelName: SKILLS[skillName].levels[0]
      };
    }
    return playerSkills[playerId];
  }

  function getPlayerSkills(playerId) {
    if (!playerSkills[playerId]) {
      initPlayerSkills(playerId);
    }
    return playerSkills[playerId];
  }

  function addSkillXP(playerId, skill, amount) {
    if (!SKILLS[skill]) {
      return { success: false, error: 'Invalid skill' };
    }

    if (!playerSkills[playerId]) {
      initPlayerSkills(playerId);
    }

    var skillData = playerSkills[playerId][skill];
    var oldLevel = skillData.level;
    skillData.xp += amount;

    var newLevel = getSkillLevel(skillData.xp, skill);
    var leveledUp = newLevel > oldLevel;

    if (leveledUp) {
      skillData.level = newLevel;
      skillData.levelName = getLevelName(newLevel, skill);
    }

    return {
      success: true,
      newXP: skillData.xp,
      leveledUp: leveledUp,
      newLevel: newLevel,
      newLevelName: skillData.levelName
    };
  }

  function getSkillLevelNum(playerId, skill) {
    if (!playerSkills[playerId] || !SKILLS[skill]) {
      return 0;
    }
    return playerSkills[playerId][skill].level;
  }

  // ============================================================================
  // MENTORSHIP SYSTEM
  // ============================================================================

  function offerMentorship(mentorId, menteeId, skill) {
    if (!SKILLS[skill]) {
      return { success: false, error: 'Invalid skill' };
    }

    var mentorLevel = getSkillLevelNum(mentorId, skill);
    if (mentorLevel < 2) {
      return {
        success: false,
        error: 'Mentor must be at least level 2 in ' + SKILLS[skill].name
      };
    }

    var offerId = generateId('offer');
    var offer = {
      id: offerId,
      mentorId: mentorId,
      menteeId: menteeId,
      skill: skill,
      timestamp: Date.now()
    };

    mentorshipOffers[offerId] = offer;

    return {
      success: true,
      offer: offer
    };
  }

  function acceptMentorship(offerId) {
    var offer = mentorshipOffers[offerId];
    if (!offer) {
      return { success: false, error: 'Offer not found' };
    }

    var mentorshipId = generateId('mentorship');
    var mentorship = {
      id: mentorshipId,
      mentorId: offer.mentorId,
      menteeId: offer.menteeId,
      skill: offer.skill,
      stepsCompleted: 0,
      totalSteps: 5,
      startedAt: Date.now()
    };

    mentorships[mentorshipId] = mentorship;
    delete mentorshipOffers[offerId];

    return {
      success: true,
      mentorship: mentorship
    };
  }

  function declineMentorship(offerId) {
    if (mentorshipOffers[offerId]) {
      delete mentorshipOffers[offerId];
    }
  }

  function completeLessonStep(mentorshipId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return { success: false, error: 'Mentorship not found' };
    }

    if (mentorship.stepsCompleted >= mentorship.totalSteps) {
      return { success: false, error: 'Mentorship already completed' };
    }

    mentorship.stepsCompleted++;
    var progress = mentorship.stepsCompleted / mentorship.totalSteps;
    var completed = mentorship.stepsCompleted >= mentorship.totalSteps;

    // Grant XP to mentee
    addSkillXP(mentorship.menteeId, mentorship.skill, 20);

    // Spark reward for mentor (5-10 per step, 50 bonus on completion)
    var sparkReward = Math.floor(5 + Math.random() * 5);
    if (completed) {
      sparkReward += 50;
    }

    return {
      success: true,
      progress: progress,
      stepsCompleted: mentorship.stepsCompleted,
      totalSteps: mentorship.totalSteps,
      completed: completed,
      sparkReward: sparkReward,
      mentorship: mentorship
    };
  }

  function getActiveMentorships(playerId) {
    var result = [];
    for (var id in mentorships) {
      var m = mentorships[id];
      if (m.mentorId === playerId || m.menteeId === playerId) {
        result.push(m);
      }
    }
    return result;
  }

  function getMentorshipProgress(mentorshipId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return null;
    }

    return {
      stepsCompleted: mentorship.stepsCompleted,
      totalSteps: mentorship.totalSteps,
      skill: mentorship.skill,
      mentor: mentorship.mentorId,
      mentee: mentorship.menteeId
    };
  }

  function cancelMentorship(mentorshipId, playerId) {
    var mentorship = mentorships[mentorshipId];
    if (!mentorship) {
      return { success: false, error: 'Mentorship not found' };
    }

    if (mentorship.mentorId !== playerId && mentorship.menteeId !== playerId) {
      return { success: false, error: 'Not part of this mentorship' };
    }

    delete mentorships[mentorshipId];
    return { success: true };
  }

  // ============================================================================
  // NPC TEACHING SYSTEM
  // ============================================================================

  function canNPCTeach(npcArchetype, skill) {
    if (!SKILLS[skill]) return false;
    return NPC_TEACHING_SPECIALTIES[npcArchetype] === skill;
  }

  function startNPCLesson(playerId, npcId, npcArchetype, skill) {
    if (!canNPCTeach(npcArchetype, skill)) {
      return {
        success: false,
        error: 'This NPC cannot teach ' + SKILLS[skill].name
      };
    }

    var lessonId = generateId('lesson');
    var lesson = {
      id: lessonId,
      playerId: playerId,
      npcId: npcId,
      npcArchetype: npcArchetype,
      skill: skill,
      startedAt: Date.now()
    };

    npcLessons[lessonId] = lesson;

    return {
      success: true,
      lesson: lesson
    };
  }

  function completeNPCLesson(lessonId) {
    var lesson = npcLessons[lessonId];
    if (!lesson) {
      return { success: false, error: 'Lesson not found' };
    }

    var xpGained = 15;
    addSkillXP(lesson.playerId, lesson.skill, xpGained);

    var sparkCost = Math.floor(5 + Math.random() * 10);

    delete npcLessons[lessonId];

    return {
      success: true,
      xpGained: xpGained,
      sparkCost: sparkCost,
      skill: lesson.skill
    };
  }

  // ============================================================================
  // STATE PERSISTENCE
  // ============================================================================

  function initMentoring(existingData) {
    if (existingData) {
      playerSkills = existingData.playerSkills || {};
      mentorships = existingData.mentorships || {};
      mentorshipOffers = existingData.mentorshipOffers || {};
      npcLessons = existingData.npcLessons || {};
    }
  }

  function getMentoringState() {
    return {
      playerSkills: playerSkills,
      mentorships: mentorships,
      mentorshipOffers: mentorshipOffers,
      npcLessons: npcLessons
    };
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.SKILLS = SKILLS;
  exports.NPC_TEACHING_SPECIALTIES = NPC_TEACHING_SPECIALTIES;
  exports.initPlayerSkills = initPlayerSkills;
  exports.getPlayerSkills = getPlayerSkills;
  exports.addSkillXP = addSkillXP;
  exports.getSkillLevel = getSkillLevelNum;
  exports.offerMentorship = offerMentorship;
  exports.acceptMentorship = acceptMentorship;
  exports.declineMentorship = declineMentorship;
  exports.completeLessonStep = completeLessonStep;
  exports.getActiveMentorships = getActiveMentorships;
  exports.getMentorshipProgress = getMentorshipProgress;
  exports.cancelMentorship = cancelMentorship;
  exports.canNPCTeach = canNPCTeach;
  exports.startNPCLesson = startNPCLesson;
  exports.completeNPCLesson = completeNPCLesson;
  exports.initMentoring = initMentoring;
  exports.getMentoringState = getMentoringState;

})(typeof module !== 'undefined' ? module.exports : (window.Mentoring = {}));


// gardens.js
// gardens.js â€” Garden Collaboration System for ZION
// Implements multi-player garden tending per Constitution Â§5.2 and Â§5.4
// "The most peaceful place in ZION" â€” collaborative gardening where multiple
// players can tend the same plot.
(function(exports) {
  'use strict';

  // â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Maximum collaborators per garden (owner + this many others) */
  var MAX_COLLABORATORS = 5;

  /** Growth multiplier bonus per active collaborator (e.g. 0.1 = +10% per collaborator) */
  var COLLABORATION_BONUS = 0.1;

  /** How long (ms) a tending action counts as "active" for bonus calculation */
  var ACTIVE_WINDOW_MS = 86400000; // 24 hours

  /** Minimum tending actions needed to be considered an "active" collaborator */
  var ACTIVE_TEND_THRESHOLD = 1;

  /** Valid tending actions */
  var VALID_TEND_ACTIONS = ['water', 'weed', 'fertilize'];

  /** Zones where garden collaboration is permitted (must have harvesting: true) */
  var GARDEN_ZONES = ['gardens', 'wilds'];

  /** Garden plot sizes */
  var PLOT_SIZES = ['small', 'medium', 'large'];

  /** Default zone for a new garden */
  var DEFAULT_ZONE = 'gardens';

  // â”€â”€ ID Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Generate a short unique ID
   * @returns {string}
   */
  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  // â”€â”€ In-memory garden store â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Each garden has the shape:
  // {
  //   id: string,
  //   ownerId: string,
  //   position: {x, y, z},
  //   zoneName: string,
  //   collaborators: [string],   // player IDs (not including owner)
  //   isPublic: boolean,
  //   createdAt: number,         // epoch ms
  //   tending: [                 // tending event log
  //     { playerId, action, ts }
  //   ],
  //   contributions: {           // playerId -> count
  //     <playerId>: number
  //   },
  //   fertility: number,         // 0-1, inherited from plot or default 0.7
  //   size: string,
  //   health: number             // 0-1, computed lazily
  // }

  var gardens = {}; // gardenId -> garden object

  // â”€â”€ Helper: internal garden lookup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _getGarden(gardenId) {
    return gardens[gardenId] || null;
  }

  // â”€â”€ Core API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create a new garden plot.
   *
   * @param {string} ownerId    - Player ID of the owner
   * @param {Object} position   - {x, y, z} world coordinates
   * @param {string} [zoneName] - Zone name (must allow harvesting); defaults to 'gardens'
   * @returns {{success:boolean, garden?:Object, error?:string}}
   */
  function createGarden(ownerId, position, zoneName) {
    if (!ownerId || typeof ownerId !== 'string' || ownerId.trim() === '') {
      return { success: false, error: 'Invalid ownerId' };
    }

    var zone = zoneName || DEFAULT_ZONE;

    if (GARDEN_ZONES.indexOf(zone) === -1) {
      return { success: false, error: 'Gardens not allowed in zone: ' + zone };
    }

    if (!position || typeof position !== 'object') {
      return { success: false, error: 'Invalid position' };
    }

    if (typeof position.x !== 'number' || typeof position.y !== 'number' || typeof position.z !== 'number') {
      return { success: false, error: 'Position must have numeric x, y, z' };
    }

    var garden = {
      id: generateId(),
      ownerId: ownerId,
      position: { x: position.x, y: position.y, z: position.z },
      zoneName: zone,
      collaborators: [],
      isPublic: false,
      createdAt: Date.now(),
      tending: [],
      contributions: {},
      fertility: 0.7,
      size: 'medium',
      health: 1.0
    };

    // Track owner contributions
    garden.contributions[ownerId] = 0;

    gardens[garden.id] = garden;

    return { success: true, garden: garden };
  }

  /**
   * Invite a collaborator to a garden.
   *
   * @param {string} gardenId        - Garden ID
   * @param {string} ownerId         - Must be the garden owner
   * @param {string} collaboratorId  - Player to invite
   * @returns {{success:boolean, error?:string}}
   */
  function addCollaborator(gardenId, ownerId, collaboratorId) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (garden.ownerId !== ownerId) {
      return { success: false, error: 'Only the owner can add collaborators' };
    }

    if (!collaboratorId || typeof collaboratorId !== 'string' || collaboratorId.trim() === '') {
      return { success: false, error: 'Invalid collaboratorId' };
    }

    if (collaboratorId === ownerId) {
      return { success: false, error: 'Owner is already a member of the garden' };
    }

    if (garden.collaborators.indexOf(collaboratorId) !== -1) {
      return { success: false, error: 'Player is already a collaborator' };
    }

    if (garden.collaborators.length >= MAX_COLLABORATORS) {
      return { success: false, error: 'Garden has reached maximum collaborators (' + MAX_COLLABORATORS + ')' };
    }

    garden.collaborators.push(collaboratorId);

    // Initialise contribution counter for new collaborator
    if (garden.contributions[collaboratorId] === undefined) {
      garden.contributions[collaboratorId] = 0;
    }

    return { success: true };
  }

  /**
   * Remove a collaborator from a garden.
   *
   * @param {string} gardenId        - Garden ID
   * @param {string} ownerId         - Must be the garden owner
   * @param {string} collaboratorId  - Player to remove
   * @returns {{success:boolean, error?:string}}
   */
  function removeCollaborator(gardenId, ownerId, collaboratorId) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (garden.ownerId !== ownerId) {
      return { success: false, error: 'Only the owner can remove collaborators' };
    }

    var idx = garden.collaborators.indexOf(collaboratorId);
    if (idx === -1) {
      return { success: false, error: 'Player is not a collaborator' };
    }

    garden.collaborators.splice(idx, 1);

    return { success: true };
  }

  /**
   * List all collaborators for a garden (not including the owner).
   *
   * @param {string} gardenId
   * @returns {string[]} Array of collaborator player IDs
   */
  function getCollaborators(gardenId) {
    var garden = _getGarden(gardenId);
    if (!garden) return [];
    return garden.collaborators.slice();
  }

  /**
   * Check whether a player may tend a garden (owner or collaborator).
   * Public gardens also allow any player to tend.
   *
   * @param {string} gardenId
   * @param {string} playerId
   * @returns {boolean}
   */
  function canTend(gardenId, playerId) {
    var garden = _getGarden(gardenId);
    if (!garden) return false;

    if (garden.ownerId === playerId) return true;
    if (garden.collaborators.indexOf(playerId) !== -1) return true;
    if (garden.isPublic) return true;

    return false;
  }

  /**
   * Record a tending action (water, weed, fertilize) on a garden.
   *
   * @param {string} gardenId
   * @param {string} playerId
   * @param {string} action   - 'water' | 'weed' | 'fertilize'
   * @returns {{success:boolean, tendingEvent?:Object, error?:string}}
   */
  function tendGarden(gardenId, playerId, action) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (!canTend(gardenId, playerId)) {
      return { success: false, error: 'Player does not have permission to tend this garden' };
    }

    if (VALID_TEND_ACTIONS.indexOf(action) === -1) {
      return { success: false, error: 'Invalid tending action: ' + action + '. Valid actions: ' + VALID_TEND_ACTIONS.join(', ') };
    }

    var event = {
      playerId: playerId,
      action: action,
      ts: Date.now()
    };

    garden.tending.push(event);

    // Increment contribution counter
    if (garden.contributions[playerId] === undefined) {
      garden.contributions[playerId] = 0;
    }
    garden.contributions[playerId]++;

    // Recalculate health lazily
    garden.health = getGardenHealth(garden);

    return { success: true, tendingEvent: event };
  }

  /**
   * Compute the overall health score (0â€“1) of a garden based on recent tending.
   * Health decays toward 0 without tending and is boosted by collaboration bonus.
   *
   * Formula:
   *   base = clamp(recentActions / 10, 0, 1)   // up to 10 actions = full health
   *   bonus = getBonusFromCollaboration(garden)
   *   health = clamp(base * (1 + bonus), 0, 1)
   *
   * @param {Object} garden - Garden object (need not be from the internal store)
   * @returns {number} 0-1 health score
   */
  function getGardenHealth(garden) {
    if (!garden || !garden.tending) return 0;

    var now = Date.now();
    var recentActions = garden.tending.filter(function(e) {
      return (now - e.ts) <= ACTIVE_WINDOW_MS;
    }).length;

    var base = Math.min(recentActions / 10, 1);
    var bonus = getBonusFromCollaboration(garden);
    var health = Math.min(base * (1 + bonus), 1);

    return health;
  }

  /**
   * Return contribution counts per player.
   *
   * @param {string} gardenId
   * @returns {Object} { <playerId>: number } â€” all-time tending action counts
   */
  function getContributions(gardenId) {
    var garden = _getGarden(gardenId);
    if (!garden) return {};

    // Return a copy so callers cannot mutate internal state
    var result = {};
    var keys = Object.keys(garden.contributions);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = garden.contributions[keys[i]];
    }
    return result;
  }

  /**
   * Calculate the fair harvest share (0â€“1) for a player based on contributions.
   * Owner always gets at least a base share equal to 1/(collaborators+1).
   * If there are no contributions at all, owner gets 100%.
   *
   * @param {string} gardenId
   * @param {string} playerId
   * @returns {number} Share fraction 0-1
   */
  function getHarvestShare(gardenId, playerId) {
    var garden = _getGarden(gardenId);
    if (!garden) return 0;

    var contributions = garden.contributions;
    var total = 0;
    var keys = Object.keys(contributions);

    for (var i = 0; i < keys.length; i++) {
      total += contributions[keys[i]];
    }

    // No tending at all â†’ owner takes everything
    if (total === 0) {
      if (playerId === garden.ownerId) return 1;
      return 0;
    }

    var playerShare = contributions[playerId] || 0;

    // If player has 0 contributions but is the owner, ensure a minimum share
    if (playerShare === 0 && playerId === garden.ownerId) {
      // Owner base share = 1 / (number of members)
      var memberCount = garden.collaborators.length + 1; // +1 for owner
      var baseShare = 1 / memberCount;
      // Re-weight: owner gets baseShare, rest distributed proportionally
      var remaining = 1 - baseShare;
      // If total collaborator contribution is 0, owner still gets baseShare
      return baseShare;
    }

    return playerShare / total;
  }

  /**
   * Calculate the growth / yield bonus from collaboration.
   * Each "active" collaborator (tended in the last ACTIVE_WINDOW_MS) adds
   * COLLABORATION_BONUS to the multiplier.
   *
   * @param {Object} garden - Garden object
   * @returns {number} Bonus multiplier (e.g. 0.2 = 20% extra yield)
   */
  function getBonusFromCollaboration(garden) {
    if (!garden || !garden.tending) return 0;

    var now = Date.now();
    var activePlayerIds = {};

    // Collect unique players who tended recently
    for (var i = 0; i < garden.tending.length; i++) {
      var event = garden.tending[i];
      if ((now - event.ts) <= ACTIVE_WINDOW_MS) {
        activePlayerIds[event.playerId] = true;
      }
    }

    var activeCount = Object.keys(activePlayerIds).length;

    // Bonus only kicks in when more than 1 person has tended
    var collaboratorCount = Math.max(0, activeCount - 1);
    return collaboratorCount * COLLABORATION_BONUS;
  }

  /**
   * Get comprehensive stats for a garden.
   *
   * @param {string} gardenId
   * @returns {Object|null} Stats object or null if not found
   */
  function getGardenStats(gardenId) {
    var garden = _getGarden(gardenId);
    if (!garden) return null;

    var now = Date.now();
    var recentTending = garden.tending.filter(function(e) {
      return (now - e.ts) <= ACTIVE_WINDOW_MS;
    });

    var activeTenders = {};
    for (var i = 0; i < recentTending.length; i++) {
      activeTenders[recentTending[i].playerId] = true;
    }

    var actionCounts = {};
    for (var j = 0; j < garden.tending.length; j++) {
      var action = garden.tending[j].action;
      actionCounts[action] = (actionCounts[action] || 0) + 1;
    }

    return {
      id: garden.id,
      ownerId: garden.ownerId,
      zoneName: garden.zoneName,
      position: garden.position,
      collaborators: garden.collaborators.slice(),
      isPublic: garden.isPublic,
      createdAt: garden.createdAt,
      health: getGardenHealth(garden),
      collaborationBonus: getBonusFromCollaboration(garden),
      totalTendingActions: garden.tending.length,
      recentTendingActions: recentTending.length,
      activeTenderCount: Object.keys(activeTenders).length,
      contributions: getContributions(gardenId),
      actionBreakdown: actionCounts,
      fertility: garden.fertility,
      size: garden.size
    };
  }

  /**
   * List all gardens that are open for collaboration (isPublic: true).
   *
   * @returns {Object[]} Array of garden stats objects
   */
  function listPublicGardens() {
    var result = [];
    var ids = Object.keys(gardens);
    for (var i = 0; i < ids.length; i++) {
      var garden = gardens[ids[i]];
      if (garden.isPublic) {
        result.push(getGardenStats(garden.id));
      }
    }
    return result;
  }

  /**
   * Toggle a garden between public and private.
   * Public gardens can be tended by any player, even without an invitation.
   *
   * @param {string} gardenId
   * @param {string} ownerId    - Must be the garden owner
   * @param {boolean} isPublic
   * @returns {{success:boolean, error?:string}}
   */
  function setGardenPublic(gardenId, ownerId, isPublic) {
    var garden = _getGarden(gardenId);
    if (!garden) {
      return { success: false, error: 'Garden not found' };
    }

    if (garden.ownerId !== ownerId) {
      return { success: false, error: 'Only the owner can change garden visibility' };
    }

    if (typeof isPublic !== 'boolean') {
      return { success: false, error: 'isPublic must be a boolean' };
    }

    garden.isPublic = isPublic;

    return { success: true };
  }

  // â”€â”€ Garden store helpers (for testing / state sync) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Reset the internal garden store. Useful for testing.
   */
  function _resetStore() {
    gardens = {};
  }

  /**
   * Directly inject a garden into the store. Useful for loading canonical state.
   * @param {Object} garden - Full garden object
   */
  function _loadGarden(garden) {
    if (garden && garden.id) {
      gardens[garden.id] = garden;
    }
  }

  /**
   * Retrieve all gardens as a plain object (for serialisation).
   * @returns {Object} gardenId -> garden
   */
  function _getAllGardens() {
    return gardens;
  }

  // â”€â”€ Protocol message handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Handle a 'garden_create' protocol message.
   * @param {Object} msg   - Protocol message
   * @returns {{success:boolean, garden?:Object, error?:string}}
   */
  function handleGardenCreate(msg) {
    var payload = msg.payload || {};
    return createGarden(
      msg.from,
      payload.position || { x: 0, y: 0, z: 0 },
      payload.zone || DEFAULT_ZONE
    );
  }

  /**
   * Handle a 'garden_invite' protocol message.
   * @param {Object} msg
   * @returns {{success:boolean, error?:string}}
   */
  function handleGardenInvite(msg) {
    var payload = msg.payload || {};
    return addCollaborator(payload.gardenId, msg.from, payload.collaboratorId);
  }

  /**
   * Handle a 'garden_uninvite' protocol message.
   * @param {Object} msg
   * @returns {{success:boolean, error?:string}}
   */
  function handleGardenUninvite(msg) {
    var payload = msg.payload || {};
    return removeCollaborator(payload.gardenId, msg.from, payload.collaboratorId);
  }

  /**
   * Handle a 'garden_tend' protocol message.
   * @param {Object} msg
   * @returns {{success:boolean, tendingEvent?:Object, error?:string}}
   */
  function handleGardenTend(msg) {
    var payload = msg.payload || {};
    return tendGarden(payload.gardenId, msg.from, payload.action);
  }

  /**
   * Handle a 'garden_set_public' protocol message.
   * @param {Object} msg
   * @returns {{success:boolean, error?:string}}
   */
  function handleGardenSetPublic(msg) {
    var payload = msg.payload || {};
    return setGardenPublic(payload.gardenId, msg.from, payload.isPublic);
  }

  // â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.MAX_COLLABORATORS = MAX_COLLABORATORS;
  exports.COLLABORATION_BONUS = COLLABORATION_BONUS;
  exports.ACTIVE_WINDOW_MS = ACTIVE_WINDOW_MS;
  exports.VALID_TEND_ACTIONS = VALID_TEND_ACTIONS;
  exports.GARDEN_ZONES = GARDEN_ZONES;

  exports.createGarden = createGarden;
  exports.addCollaborator = addCollaborator;
  exports.removeCollaborator = removeCollaborator;
  exports.getCollaborators = getCollaborators;
  exports.canTend = canTend;
  exports.tendGarden = tendGarden;
  exports.getGardenHealth = getGardenHealth;
  exports.getContributions = getContributions;
  exports.getHarvestShare = getHarvestShare;
  exports.getBonusFromCollaboration = getBonusFromCollaboration;
  exports.getGardenStats = getGardenStats;
  exports.listPublicGardens = listPublicGardens;
  exports.setGardenPublic = setGardenPublic;

  // Protocol message handlers
  exports.handleGardenCreate = handleGardenCreate;
  exports.handleGardenInvite = handleGardenInvite;
  exports.handleGardenUninvite = handleGardenUninvite;
  exports.handleGardenTend = handleGardenTend;
  exports.handleGardenSetPublic = handleGardenSetPublic;

  // Internal / testing helpers
  exports._resetStore = _resetStore;
  exports._loadGarden = _loadGarden;
  exports._getAllGardens = _getAllGardens;

})(typeof module !== 'undefined' ? module.exports : (window.Gardens = {}));


// chat.js
// chat.js
/**
 * ZION MMO - Chat Channel Module
 *
 * Manages chat channels: global, zone, guild, whisper, system, trade.
 * Provides channel lifecycle, message history, unread tracking, muting,
 * search/filter, and formatting utilities.
 */

(function(exports) {
  'use strict';

  // â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var CHANNEL_TYPES = {
    GLOBAL:  'global',
    ZONE:    'zone',
    GUILD:   'guild',
    WHISPER: 'whisper',
    SYSTEM:  'system',
    TRADE:   'trade'
  };

  /** Color per channel type for UI rendering */
  var MESSAGE_COLORS = {
    global:  '#A8D8EA',   // soft blue
    zone:    '#B8F0B8',   // soft green
    guild:   '#FFD580',   // soft gold
    whisper: '#E8A0FF',   // soft purple
    system:  '#FF9999',   // soft red / system orange
    trade:   '#FFB347'    // warm orange
  };

  /** Badge icons per channel type */
  var CHANNEL_BADGES = {
    global:  '[G]',
    zone:    '[Z]',
    guild:   '[GU]',
    whisper: '[W]',
    system:  '[SYS]',
    trade:   '[T]'
  };

  /** Maximum messages stored per channel (configurable) */
  var maxHistoryPerChannel = 200;

  // â”€â”€ Internal State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var channels = {};        // channelName -> channel object
  var activeChannel = null; // name of currently selected channel

  // â”€â”€ Channel Object Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create a new channel instance.
   * @param {string} type    - One of CHANNEL_TYPES values
   * @param {string} name    - Unique channel identifier (e.g. 'global', 'zone_nexus')
   * @param {object} options - { displayName, targetPlayer, guildId, zoneName, persistent }
   * @returns {object} channel
   */
  function createChannel(type, name, options) {
    if (!type || !name) {
      return null;
    }

    var validTypes = Object.keys(CHANNEL_TYPES).map(function(k) { return CHANNEL_TYPES[k]; });
    if (validTypes.indexOf(type) === -1) {
      return null;
    }

    var opts = options || {};

    var channel = {
      type:         type,
      name:         name,
      displayName:  opts.displayName || name,
      targetPlayer: opts.targetPlayer || null,  // for whisper channels
      guildId:      opts.guildId || null,        // for guild channels
      zoneName:     opts.zoneName || null,        // for zone channels
      persistent:   opts.persistent !== undefined ? opts.persistent : true,
      muted:        false,
      messages:     [],
      unreadCount:  0,
      lastReadTs:   0,
      createdAt:    Date.now()
    };

    channels[name] = channel;
    return channel;
  }

  /**
   * Return the standard set of default channels.
   * @returns {Array} list of channel objects (created and registered)
   */
  function getDefaultChannels() {
    var defaults = [
      { type: CHANNEL_TYPES.GLOBAL,  name: 'global',  displayName: 'Global',   persistent: true },
      { type: CHANNEL_TYPES.SYSTEM,  name: 'system',  displayName: 'System',   persistent: true },
      { type: CHANNEL_TYPES.TRADE,   name: 'trade',   displayName: 'Trade',    persistent: true }
    ];

    var result = [];
    for (var i = 0; i < defaults.length; i++) {
      var d = defaults[i];
      // Return existing or create new
      var ch = channels[d.name] || createChannel(d.type, d.name, { displayName: d.displayName, persistent: d.persistent });
      result.push(ch);
    }
    return result;
  }

  // â”€â”€ Message Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Add a message to a channel's history.
   * @param {string|object} channel - channel name or channel object
   * @param {object} message        - { sender, text, ts?, type?, badge?, meta? }
   * @returns {object|null} the stored message record, or null on failure
   */
  function addMessage(channel, message) {
    var ch = _resolveChannel(channel);
    if (!ch) return null;
    if (!message || typeof message !== 'object') return null;
    if (!message.sender || !message.text) return null;

    var record = {
      id:        _generateId(),
      sender:    message.sender,
      text:      String(message.text),
      ts:        message.ts || Date.now(),
      type:      message.type || ch.type,
      badge:     message.badge || CHANNEL_BADGES[ch.type] || '',
      meta:      message.meta || {}
    };

    ch.messages.push(record);

    // Enforce history limit
    if (ch.messages.length > maxHistoryPerChannel) {
      ch.messages = ch.messages.slice(ch.messages.length - maxHistoryPerChannel);
    }

    // Increment unread if channel is not active
    if (activeChannel !== ch.name) {
      ch.unreadCount++;
    }

    return record;
  }

  /**
   * Retrieve messages from a channel with optional pagination.
   * @param {string|object} channel - channel name or channel object
   * @param {number}        limit   - max messages to return (default all)
   * @param {number}        before  - return messages with ts < before (optional)
   * @returns {Array} array of message records (oldest first in the slice)
   */
  function getMessages(channel, limit, before) {
    var ch = _resolveChannel(channel);
    if (!ch) return [];

    var msgs = ch.messages.slice(); // shallow copy

    // Filter by `before` timestamp if provided
    if (typeof before === 'number') {
      msgs = msgs.filter(function(m) { return m.ts < before; });
    }

    // Apply limit (return last N = most recent)
    if (typeof limit === 'number' && limit > 0) {
      msgs = msgs.slice(-limit);
    }

    return msgs;
  }

  // â”€â”€ Unread Tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get the unread message count for a channel.
   * @param {string|object} channel
   * @returns {number}
   */
  function getUnreadCount(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return 0;
    return ch.unreadCount;
  }

  /**
   * Mark a channel's messages as read (reset unread counter).
   * @param {string|object} channel
   */
  function markAsRead(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return;
    ch.unreadCount = 0;
    ch.lastReadTs = Date.now();
  }

  // â”€â”€ Active Channel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Switch the active channel, marking the new channel as read.
   * @param {string} channelName
   * @returns {object|null} the new active channel, or null if not found
   */
  function switchChannel(channelName) {
    if (!channels[channelName]) return null;
    activeChannel = channelName;
    markAsRead(channelName);
    return channels[channelName];
  }

  /**
   * Get the currently active channel object.
   * @returns {object|null}
   */
  function getActiveChannel() {
    if (!activeChannel || !channels[activeChannel]) return null;
    return channels[activeChannel];
  }

  // â”€â”€ Formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Format a message record for display.
   * Produces: [HH:MM] [BADGE] sender: text
   * @param {object} msg - message record from addMessage
   * @returns {string} formatted string
   */
  function formatMessage(msg) {
    if (!msg || typeof msg !== 'object') return '';

    var time = _formatTime(msg.ts);
    var badge = msg.badge || '';
    var sender = msg.sender || 'unknown';
    var text = msg.text || '';

    var parts = [time];
    if (badge) parts.push(badge);
    parts.push(sender + ': ' + text);

    return parts.join(' ');
  }

  // â”€â”€ Search / Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Filter messages in a channel by a search query.
   * Matches against sender and text (case-insensitive).
   * @param {string|object} channel
   * @param {string}        query
   * @returns {Array} matching message records
   */
  function filterMessages(channel, query) {
    var ch = _resolveChannel(channel);
    if (!ch) return [];
    if (!query || typeof query !== 'string') return ch.messages.slice();

    var lq = query.toLowerCase();
    return ch.messages.filter(function(m) {
      return (m.sender && m.sender.toLowerCase().indexOf(lq) !== -1) ||
             (m.text   && m.text.toLowerCase().indexOf(lq)   !== -1);
    });
  }

  // â”€â”€ Muting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Mute a channel (addMessage still stores, but unread will not increment).
   * @param {string|object} channel
   */
  function muteChannel(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return;
    ch.muted = true;
  }

  /**
   * Unmute a channel.
   * @param {string|object} channel
   */
  function unmuteChannel(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return;
    ch.muted = false;
  }

  // â”€â”€ Zone / Guild / Whisper Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get (or create) the zone-specific channel for a zone name.
   * Channel name: 'zone_<zoneName>'
   * @param {string} zoneName - e.g. 'nexus', 'gardens'
   * @returns {object|null} channel
   */
  function getChannelForZone(zoneName) {
    if (!zoneName || typeof zoneName !== 'string') return null;
    var name = 'zone_' + zoneName;
    if (!channels[name]) {
      createChannel(CHANNEL_TYPES.ZONE, name, {
        displayName: zoneName.charAt(0).toUpperCase() + zoneName.slice(1),
        zoneName: zoneName
      });
    }
    return channels[name];
  }

  /**
   * Get (or create) the guild channel for a guild ID.
   * Channel name: 'guild_<guildId>'
   * @param {string} guildId
   * @returns {object|null} channel
   */
  function getGuildChannel(guildId) {
    if (!guildId || typeof guildId !== 'string') return null;
    var name = 'guild_' + guildId;
    if (!channels[name]) {
      createChannel(CHANNEL_TYPES.GUILD, name, {
        displayName: 'Guild',
        guildId: guildId
      });
    }
    return channels[name];
  }

  /**
   * Create (or retrieve) a DM whisper channel with a target player.
   * Channel name is sorted so alice<->bob and bob<->alice share the same channel.
   * @param {string} localPlayer  - the current player's ID
   * @param {string} targetPlayer - the target player's ID
   * @returns {object|null} channel
   */
  function createWhisperChannel(localPlayer, targetPlayer) {
    if (!localPlayer || !targetPlayer || typeof localPlayer !== 'string' || typeof targetPlayer !== 'string') {
      return null;
    }
    if (localPlayer === targetPlayer) return null;

    // Deterministic channel name regardless of who initiates
    var sorted = [localPlayer, targetPlayer].sort();
    var name = 'whisper_' + sorted[0] + '_' + sorted[1];

    if (!channels[name]) {
      createChannel(CHANNEL_TYPES.WHISPER, name, {
        displayName: targetPlayer,
        targetPlayer: targetPlayer
      });
    }
    return channels[name];
  }

  // â”€â”€ Channel Retrieval Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get a channel by name (returns null if not found).
   * @param {string} name
   * @returns {object|null}
   */
  function getChannel(name) {
    return channels[name] || null;
  }

  /**
   * Get all registered channels.
   * @returns {object} map of channelName -> channel
   */
  function getAllChannels() {
    return channels;
  }

  /**
   * Remove a channel (e.g. when a whisper session ends).
   * @param {string|object} channel
   * @returns {boolean} true if removed
   */
  function removeChannel(channel) {
    var ch = _resolveChannel(channel);
    if (!ch) return false;
    if (activeChannel === ch.name) {
      activeChannel = null;
    }
    delete channels[ch.name];
    return true;
  }

  /**
   * Reset all state (useful for testing).
   */
  function reset() {
    channels = {};
    activeChannel = null;
  }

  // â”€â”€ Private Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _resolveChannel(channel) {
    if (!channel) return null;
    if (typeof channel === 'string') return channels[channel] || null;
    if (typeof channel === 'object' && channel.name) return channels[channel.name] || channel;
    return null;
  }

  function _generateId() {
    return 'msg_' + Date.now() + '_' + Math.floor(Math.random() * 1000000);
  }

  function _formatTime(ts) {
    var d = new Date(typeof ts === 'number' ? ts : Date.now());
    var hh = String(d.getHours()).padStart(2, '0');
    var mm = String(d.getMinutes()).padStart(2, '0');
    return '[' + hh + ':' + mm + ']';
  }

  // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.CHANNEL_TYPES        = CHANNEL_TYPES;
  exports.MESSAGE_COLORS       = MESSAGE_COLORS;
  exports.CHANNEL_BADGES       = CHANNEL_BADGES;
  exports.maxHistoryPerChannel = maxHistoryPerChannel;

  exports.createChannel        = createChannel;
  exports.getDefaultChannels   = getDefaultChannels;
  exports.addMessage           = addMessage;
  exports.getMessages          = getMessages;
  exports.getUnreadCount       = getUnreadCount;
  exports.markAsRead           = markAsRead;
  exports.switchChannel        = switchChannel;
  exports.getActiveChannel     = getActiveChannel;
  exports.formatMessage        = formatMessage;
  exports.filterMessages       = filterMessages;
  exports.muteChannel          = muteChannel;
  exports.unmuteChannel        = unmuteChannel;
  exports.getChannelForZone    = getChannelForZone;
  exports.getGuildChannel      = getGuildChannel;
  exports.createWhisperChannel = createWhisperChannel;
  exports.getChannel           = getChannel;
  exports.getAllChannels        = getAllChannels;
  exports.removeChannel        = removeChannel;
  exports.reset                = reset;

})(typeof module !== 'undefined' ? module.exports : (window.Chat = {}));


// elections.js
// elections.js â€” Zone Steward Election System for ZION
// Depends on: protocol.js, zones.js
(function(exports) {
  'use strict';

  // ========================================================================
  // ELECTION CONFIG
  // ========================================================================

  var ELECTION_CONFIG = {
    termLengthMs: 7 * 24 * 60 * 60 * 1000,       // 7 days in milliseconds
    votingPeriodMs: 2 * 24 * 60 * 60 * 1000,      // 2 days voting window
    minCandidates: 1,                               // Minimum candidates to hold election
    maxStewardsPerZone: 3,                          // Top N winners become stewards
    minVisitsToVote: 5,                             // Visits needed to vote
    minVisitsToRun: 10,                             // Visits needed to run as candidate
    visitWindowMs: 30 * 24 * 60 * 60 * 1000,       // 30-day window for visit counts
    reputationToRun: ['Respected', 'Honored', 'Elder'],  // Tiers eligible to run
    historyLimit: 20                                // Max election history per zone
  };

  // ========================================================================
  // STEWARD POWERS
  // ========================================================================

  var STEWARD_POWERS = [
    {
      id: 'set_welcome',
      name: 'Set Welcome Message',
      description: 'Display a custom greeting to players entering the zone.',
      protocol: 'steward_set_welcome'
    },
    {
      id: 'set_policy',
      name: 'Set Zone Policy',
      description: 'Toggle zone policies like chat moderation and building approval.',
      protocol: 'steward_set_policy'
    },
    {
      id: 'moderate',
      name: 'Moderate Citizens',
      description: 'Warn or mute players who violate zone norms.',
      protocol: 'steward_moderate'
    },
    {
      id: 'schedule_event',
      name: 'Schedule Events',
      description: 'Add events to the zone calendar visible to all visitors.',
      protocol: 'steward_set_policy'
    },
    {
      id: 'pin_announcement',
      name: 'Pin Announcement',
      description: 'Pin a message at the top of zone chat for all to see.',
      protocol: 'steward_set_welcome'
    }
  ];

  // ========================================================================
  // INTERNAL STORAGE
  // ========================================================================

  // electionStore: electionId -> election object
  var electionStore = {};

  // stewardStore: zoneId -> steward object { playerId, electedAt, termEnds, votes, electionId }
  var stewardStore = {};

  // historyStore: zoneId -> array of past election summaries (capped at historyLimit)
  var historyStore = {};

  // visitStore: "zoneId:playerId" -> { count, lastVisit }
  var visitStore = {};

  // candidateDeclarations: "electionId:playerId" -> declared timestamp
  var candidateDeclarations = {};

  // ========================================================================
  // VISIT / ELIGIBILITY TRACKING
  // ========================================================================

  /**
   * Record a zone visit for a player (used for eligibility)
   * @param {string} zoneId
   * @param {string} playerId
   */
  function recordVisit(zoneId, playerId) {
    var key = zoneId + ':' + playerId;
    if (!visitStore[key]) {
      visitStore[key] = { count: 0, lastVisit: 0 };
    }
    visitStore[key].count++;
    visitStore[key].lastVisit = Date.now();
  }

  /**
   * Get visit record for a player in a zone
   * @param {string} zoneId
   * @param {string} playerId
   * @returns {{ count: number, lastVisit: number }}
   */
  function getVisitRecord(zoneId, playerId) {
    var key = zoneId + ':' + playerId;
    return visitStore[key] || { count: 0, lastVisit: 0 };
  }

  /**
   * Check if player meets visit threshold for a given minimum
   * @param {string} zoneId
   * @param {string} playerId
   * @param {number} minVisits
   * @returns {boolean}
   */
  function meetsVisitThreshold(zoneId, playerId, minVisits) {
    var record = getVisitRecord(zoneId, playerId);
    var now = Date.now();
    var withinWindow = (now - record.lastVisit) < ELECTION_CONFIG.visitWindowMs;
    return record.count >= minVisits && withinWindow;
  }

  /**
   * Check if player is eligible to run as candidate in a zone election
   * @param {string} playerId
   * @param {string} zoneId
   * @param {object} [playerData] - Optional object with { reputation } for tier check
   * @returns {{ eligible: boolean, reason: string }}
   */
  function isEligibleCandidate(playerId, zoneId, playerData) {
    if (!playerId || typeof playerId !== 'string') {
      return { eligible: false, reason: 'Invalid player ID' };
    }
    if (!zoneId || typeof zoneId !== 'string') {
      return { eligible: false, reason: 'Invalid zone ID' };
    }

    // Check zone exists
    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    try { Zones = Zones || require('./zones'); } catch(e) {}
    if (Zones && !Zones.zoneExists(zoneId)) {
      return { eligible: false, reason: 'Zone does not exist' };
    }

    // Check visit count
    if (!meetsVisitThreshold(zoneId, playerId, ELECTION_CONFIG.minVisitsToRun)) {
      var record = getVisitRecord(zoneId, playerId);
      return {
        eligible: false,
        reason: 'Must visit this zone at least ' + ELECTION_CONFIG.minVisitsToRun +
          ' times within the last 30 days (current: ' + record.count + ')'
      };
    }

    // Check reputation tier if playerData provided
    if (playerData && playerData.reputationTier) {
      var tiers = ELECTION_CONFIG.reputationToRun;
      if (tiers.indexOf(playerData.reputationTier) === -1) {
        return {
          eligible: false,
          reason: 'Must have Respected, Honored, or Elder reputation tier to run'
        };
      }
    }

    return { eligible: true, reason: 'Eligible to run' };
  }

  /**
   * Check if player is eligible to vote in a zone election
   * @param {string} playerId
   * @param {string} zoneId
   * @returns {{ eligible: boolean, reason: string }}
   */
  function isEligibleVoter(playerId, zoneId) {
    if (!playerId || typeof playerId !== 'string') {
      return { eligible: false, reason: 'Invalid player ID' };
    }
    if (!zoneId || typeof zoneId !== 'string') {
      return { eligible: false, reason: 'Invalid zone ID' };
    }

    // Check zone exists
    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    try { Zones = Zones || require('./zones'); } catch(e) {}
    if (Zones && !Zones.zoneExists(zoneId)) {
      return { eligible: false, reason: 'Zone does not exist' };
    }

    if (!meetsVisitThreshold(zoneId, playerId, ELECTION_CONFIG.minVisitsToVote)) {
      var record = getVisitRecord(zoneId, playerId);
      return {
        eligible: false,
        reason: 'Must visit this zone at least ' + ELECTION_CONFIG.minVisitsToVote +
          ' times within the last 30 days (current: ' + record.count + ')'
      };
    }

    return { eligible: true, reason: 'Eligible to vote' };
  }

  // ========================================================================
  // ELECTION LIFECYCLE
  // ========================================================================

  /**
   * Create a new election for a zone
   * @param {string} zoneId
   * @param {string[]} candidates - Array of player IDs
   * @param {object} [opts] - Optional: { startedBy, now }
   * @returns {{ success: boolean, election?: object, error?: string }}
   */
  function createElection(zoneId, candidates, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();

    if (!zoneId || typeof zoneId !== 'string') {
      return { success: false, error: 'Invalid zone ID' };
    }

    // Check for already-active election
    var existing = getActiveElectionForZone(zoneId, now);
    if (existing) {
      return { success: false, error: 'An election is already active for this zone' };
    }

    if (!Array.isArray(candidates)) {
      return { success: false, error: 'Candidates must be an array' };
    }

    if (candidates.length < ELECTION_CONFIG.minCandidates) {
      return {
        success: false,
        error: 'Need at least ' + ELECTION_CONFIG.minCandidates + ' candidate(s) to start election'
      };
    }

    // Deduplicate candidates
    var seen = {};
    var uniqueCandidates = [];
    for (var i = 0; i < candidates.length; i++) {
      var cid = candidates[i];
      if (cid && typeof cid === 'string' && !seen[cid]) {
        seen[cid] = true;
        uniqueCandidates.push(cid);
      }
    }

    var electionId = 'election_' + zoneId + '_' + now;
    var election = {
      id: electionId,
      zoneId: zoneId,
      startedBy: opts.startedBy || null,
      candidates: uniqueCandidates.map(function(pid) {
        return { playerId: pid, votes: 0, voters: [] };
      }),
      startTime: now,
      endTime: now + ELECTION_CONFIG.votingPeriodMs,
      status: 'active',
      totalVotes: 0
    };

    electionStore[electionId] = election;
    return { success: true, election: election };
  }

  /**
   * Declare candidacy in an active election
   * @param {string} electionId
   * @param {string} playerId
   * @returns {{ success: boolean, error?: string }}
   */
  function declareCandidacy(electionId, playerId) {
    var election = electionStore[electionId];
    if (!election) {
      return { success: false, error: 'Election not found' };
    }
    if (election.status !== 'active') {
      return { success: false, error: 'Election is not active' };
    }
    var now = Date.now();
    if (now > election.endTime) {
      return { success: false, error: 'Voting period has ended' };
    }

    // Check not already a candidate
    for (var i = 0; i < election.candidates.length; i++) {
      if (election.candidates[i].playerId === playerId) {
        return { success: false, error: 'Already a candidate in this election' };
      }
    }

    election.candidates.push({ playerId: playerId, votes: 0, voters: [] });
    candidateDeclarations[electionId + ':' + playerId] = now;
    return { success: true };
  }

  /**
   * Cast a vote in an election
   * @param {string} electionId
   * @param {string} voterId
   * @param {string} candidateId
   * @param {object} [opts] - Optional: { now }
   * @returns {{ success: boolean, error?: string }}
   */
  function castVote(electionId, voterId, candidateId, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();

    var election = electionStore[electionId];
    if (!election) {
      return { success: false, error: 'Election not found' };
    }
    if (election.status !== 'active') {
      return { success: false, error: 'Election is not active' };
    }
    if (now > election.endTime) {
      election.status = 'ended';
      return { success: false, error: 'Voting period has ended' };
    }

    // Check voter eligibility
    var eligibility = isEligibleVoter(voterId, election.zoneId);
    if (!eligibility.eligible) {
      return { success: false, error: eligibility.reason };
    }

    // Check voter hasn't already voted
    var alreadyVoted = false;
    for (var i = 0; i < election.candidates.length; i++) {
      if (election.candidates[i].voters.indexOf(voterId) !== -1) {
        alreadyVoted = true;
        break;
      }
    }
    if (alreadyVoted) {
      return { success: false, error: 'You have already voted in this election' };
    }

    // Find candidate
    var candidate = null;
    for (var j = 0; j < election.candidates.length; j++) {
      if (election.candidates[j].playerId === candidateId) {
        candidate = election.candidates[j];
        break;
      }
    }
    if (!candidate) {
      return { success: false, error: 'Candidate not found in this election' };
    }

    candidate.votes++;
    candidate.voters.push(voterId);
    election.totalVotes++;
    return { success: true };
  }

  /**
   * Get election results (tally votes, determine winner(s))
   * @param {object} election - Election object
   * @returns {{ winner: string|null, ranked: Array, totalVotes: number }}
   */
  function getElectionResults(election) {
    if (!election || !election.candidates) {
      return { winner: null, ranked: [], totalVotes: 0 };
    }

    var sorted = election.candidates.slice().sort(function(a, b) {
      return b.votes - a.votes;
    });

    var winner = sorted.length > 0 && sorted[0].votes > 0 ? sorted[0].playerId : null;

    return {
      winner: winner,
      ranked: sorted.map(function(c) {
        return {
          playerId: c.playerId,
          votes: c.votes,
          percentage: election.totalVotes > 0
            ? Math.round((c.votes / election.totalVotes) * 100)
            : 0
        };
      }),
      totalVotes: election.totalVotes
    };
  }

  /**
   * Finalize an election â€” mark complete and promote winners to stewards
   * @param {string} electionId
   * @param {object} [opts] - Optional: { now }
   * @returns {{ success: boolean, stewards?: Array, error?: string }}
   */
  function finalizeElection(electionId, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();

    var election = electionStore[electionId];
    if (!election) {
      return { success: false, error: 'Election not found' };
    }
    if (election.status === 'finalized') {
      return { success: false, error: 'Election already finalized' };
    }
    if (election.status !== 'active' && election.status !== 'ended') {
      return { success: false, error: 'Election cannot be finalized' };
    }
    if (now < election.endTime) {
      return { success: false, error: 'Election voting period has not ended yet' };
    }

    election.status = 'finalized';
    election.finalizedAt = now;

    var results = getElectionResults(election);
    var winners = results.ranked.slice(0, ELECTION_CONFIG.maxStewardsPerZone);

    // Install stewards for zone
    var zoneId = election.zoneId;
    if (!stewardStore[zoneId]) {
      stewardStore[zoneId] = [];
    }

    var newStewards = winners.map(function(w) {
      return {
        playerId: w.playerId,
        zoneId: zoneId,
        electionId: electionId,
        votes: w.votes,
        electedAt: now,
        termEnds: now + ELECTION_CONFIG.termLengthMs
      };
    });

    stewardStore[zoneId] = newStewards;

    // Record in history
    if (!historyStore[zoneId]) {
      historyStore[zoneId] = [];
    }
    historyStore[zoneId].unshift({
      electionId: electionId,
      zoneId: zoneId,
      startTime: election.startTime,
      endTime: election.endTime,
      finalizedAt: now,
      totalVotes: election.totalVotes,
      winner: results.winner,
      ranked: results.ranked
    });

    // Cap history
    if (historyStore[zoneId].length > ELECTION_CONFIG.historyLimit) {
      historyStore[zoneId] = historyStore[zoneId].slice(0, ELECTION_CONFIG.historyLimit);
    }

    return { success: true, stewards: newStewards, results: results };
  }

  // ========================================================================
  // QUERY FUNCTIONS
  // ========================================================================

  /**
   * Get the currently active election for a specific zone (internal helper)
   * @param {string} zoneId
   * @param {number} [now]
   * @returns {object|null}
   */
  function getActiveElectionForZone(zoneId, now) {
    now = now !== undefined ? now : Date.now();
    var keys = Object.keys(electionStore);
    for (var i = 0; i < keys.length; i++) {
      var e = electionStore[keys[i]];
      if (e.zoneId === zoneId && e.status === 'active' && e.endTime > now) {
        return e;
      }
    }
    return null;
  }

  /**
   * Get all currently active elections across all zones
   * @returns {Array} Array of active election objects
   */
  function getActiveElections() {
    var now = Date.now();
    var active = [];
    var keys = Object.keys(electionStore);
    for (var i = 0; i < keys.length; i++) {
      var e = electionStore[keys[i]];
      if (e.status === 'active' && e.endTime > now) {
        active.push(e);
      }
    }
    return active;
  }

  /**
   * Get map of zone -> current steward(s)
   * @returns {object} { zoneId: stewardObject[] }
   */
  function getCurrentStewards() {
    var now = Date.now();
    var result = {};
    var zones = Object.keys(stewardStore);
    for (var i = 0; i < zones.length; i++) {
      var zoneId = zones[i];
      var active = stewardStore[zoneId].filter(function(s) {
        return s.termEnds > now;
      });
      if (active.length > 0) {
        result[zoneId] = active;
      }
    }
    return result;
  }

  /**
   * Get stewards for a specific zone
   * @param {string} zoneId
   * @returns {Array} Active steward objects
   */
  function getZoneStewards(zoneId) {
    var now = Date.now();
    var stewards = stewardStore[zoneId] || [];
    return stewards.filter(function(s) { return s.termEnds > now; });
  }

  /**
   * Check if a player is a steward of a zone
   * @param {string} playerId
   * @param {string} zoneId
   * @returns {boolean}
   */
  function isSteward(playerId, zoneId) {
    var stewards = getZoneStewards(zoneId);
    for (var i = 0; i < stewards.length; i++) {
      if (stewards[i].playerId === playerId) return true;
    }
    return false;
  }

  /**
   * Get steward powers list
   * @returns {Array} STEWARD_POWERS array
   */
  function getStewardPowers() {
    return STEWARD_POWERS.slice();
  }

  /**
   * Get election history for a zone
   * @param {string} zoneId
   * @returns {Array} Past election summaries (newest first)
   */
  function getElectionHistory(zoneId) {
    return (historyStore[zoneId] || []).slice();
  }

  /**
   * Calculate days/hours remaining in a steward's term
   * @param {object} steward - Steward object with termEnds timestamp
   * @returns {{ days: number, hours: number, totalMs: number, expired: boolean }}
   */
  function calculateTermRemaining(steward) {
    if (!steward || typeof steward.termEnds !== 'number') {
      return { days: 0, hours: 0, totalMs: 0, expired: true };
    }
    var now = Date.now();
    var remaining = steward.termEnds - now;
    if (remaining <= 0) {
      return { days: 0, hours: 0, totalMs: 0, expired: true };
    }
    var days = Math.floor(remaining / 86400000);
    var hours = Math.floor((remaining % 86400000) / 3600000);
    return { days: days, hours: hours, totalMs: remaining, expired: false };
  }

  /**
   * Format an election for display in the HUD
   * @param {object} election
   * @returns {object} Display-ready election card data
   */
  function formatElectionCard(election) {
    if (!election) return null;

    var now = Date.now();
    var msLeft = election.endTime - now;
    var hoursLeft = Math.max(0, Math.floor(msLeft / 3600000));
    var minutesLeft = Math.max(0, Math.floor((msLeft % 3600000) / 60000));

    var results = getElectionResults(election);

    return {
      id: election.id,
      zoneId: election.zoneId,
      status: election.status,
      timeLeft: msLeft > 0 ? (hoursLeft + 'h ' + minutesLeft + 'm remaining') : 'Voting ended',
      hoursLeft: hoursLeft,
      totalVotes: election.totalVotes,
      candidates: results.ranked,
      winner: results.winner,
      startTime: new Date(election.startTime).toLocaleDateString(),
      endTime: new Date(election.endTime).toLocaleDateString()
    };
  }

  // ========================================================================
  // STATE INTEGRATION (apply protocol messages to elections state)
  // ========================================================================

  /**
   * Apply an election_start protocol message
   * @param {object} msg - Protocol message { from, payload: { zone } }
   * @param {object} [opts] - Optional: { now }
   * @returns {{ success: boolean, election?: object, error?: string }}
   */
  function applyElectionStart(msg, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();
    var zoneId = msg.payload && msg.payload.zone ? msg.payload.zone : null;
    if (!zoneId) {
      return { success: false, error: 'Missing zone in payload' };
    }
    return createElection(zoneId, [msg.from], { startedBy: msg.from, now: now });
  }

  /**
   * Apply an election_vote protocol message
   * @param {object} msg - Protocol message { from, payload: { electionId, candidate } }
   * @param {object} [opts] - Optional: { now }
   * @returns {{ success: boolean, error?: string }}
   */
  function applyElectionVote(msg, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();
    var electionId = msg.payload && msg.payload.electionId ? msg.payload.electionId : null;
    var candidate = msg.payload && msg.payload.candidate ? msg.payload.candidate : null;
    if (!electionId || !candidate) {
      return { success: false, error: 'Missing electionId or candidate in payload' };
    }
    return castVote(electionId, msg.from, candidate, { now: now });
  }

  /**
   * Apply an election_finalize protocol message
   * @param {object} msg - Protocol message { from, payload: { electionId } }
   * @param {object} [opts] - Optional: { now }
   * @returns {{ success: boolean, stewards?: Array, error?: string }}
   */
  function applyElectionFinalize(msg, opts) {
    opts = opts || {};
    var now = opts.now !== undefined ? opts.now : Date.now();
    var electionId = msg.payload && msg.payload.electionId ? msg.payload.electionId : null;
    if (!electionId) {
      return { success: false, error: 'Missing electionId in payload' };
    }
    return finalizeElection(electionId, { now: now });
  }

  // ========================================================================
  // TEST HELPERS (for unit tests only)
  // ========================================================================

  /**
   * Reset all internal state (for testing)
   */
  function _reset() {
    electionStore = {};
    stewardStore = {};
    historyStore = {};
    visitStore = {};
    candidateDeclarations = {};
  }

  /**
   * Seed visit count for testing
   * @param {string} zoneId
   * @param {string} playerId
   * @param {number} count
   * @param {number} [lastVisit]
   */
  function _seedVisit(zoneId, playerId, count, lastVisit) {
    var key = zoneId + ':' + playerId;
    visitStore[key] = {
      count: count,
      lastVisit: lastVisit !== undefined ? lastVisit : Date.now()
    };
  }

  /**
   * Directly insert an election (for testing finalization)
   * @param {object} election
   */
  function _insertElection(election) {
    electionStore[election.id] = election;
  }

  /**
   * Directly insert a steward (for testing)
   * @param {string} zoneId
   * @param {object} steward
   */
  function _insertSteward(zoneId, steward) {
    if (!stewardStore[zoneId]) stewardStore[zoneId] = [];
    stewardStore[zoneId].push(steward);
  }

  // ========================================================================
  // EXPORTS
  // ========================================================================

  exports.ELECTION_CONFIG = ELECTION_CONFIG;
  exports.STEWARD_POWERS = STEWARD_POWERS;

  exports.recordVisit = recordVisit;
  exports.getVisitRecord = getVisitRecord;
  exports.isEligibleCandidate = isEligibleCandidate;
  exports.isEligibleVoter = isEligibleVoter;

  exports.createElection = createElection;
  exports.declareCandidacy = declareCandidacy;
  exports.castVote = castVote;
  exports.getElectionResults = getElectionResults;
  exports.finalizeElection = finalizeElection;

  exports.getActiveElections = getActiveElections;
  exports.getCurrentStewards = getCurrentStewards;
  exports.getZoneStewards = getZoneStewards;
  exports.isSteward = isSteward;
  exports.getStewardPowers = getStewardPowers;
  exports.getElectionHistory = getElectionHistory;
  exports.calculateTermRemaining = calculateTermRemaining;
  exports.formatElectionCard = formatElectionCard;

  exports.applyElectionStart = applyElectionStart;
  exports.applyElectionVote = applyElectionVote;
  exports.applyElectionFinalize = applyElectionFinalize;

  // Test helpers (underscore prefix convention)
  exports._reset = _reset;
  exports._seedVisit = _seedVisit;
  exports._insertElection = _insertElection;
  exports._insertSteward = _insertSteward;

})(typeof module !== 'undefined' ? module.exports : (window.Elections = {}));


// leaderboards.js
// leaderboards.js
/**
 * ZION Leaderboard System
 * Comprehensive rankings across all game dimensions: wealth, quests, exploration, guilds, reputation.
 * Works with existing data structures â€” no modifications to other modules.
 */

(function(exports) {
  'use strict';

  // =========================================================================
  // CONSTANTS
  // =========================================================================

  var CATEGORIES = {
    WEALTH: 'wealth',
    QUESTS: 'quests',
    EXPLORATION: 'exploration',
    GUILDS: 'guilds',
    REPUTATION: 'reputation',
    COMBINED: 'combined'
  };

  var TIME_PERIODS = {
    ALL_TIME: 'all_time',
    DAILY: 'daily',
    WEEKLY: 'weekly'
  };

  var DEFAULT_DISPLAY_COUNTS = [10, 25, 50];

  // Weights for combined score (must sum to 1.0)
  var COMBINED_WEIGHTS = {
    wealth: 0.25,
    quests: 0.25,
    exploration: 0.20,
    reputation: 0.20,
    guilds: 0.10
  };

  // Time boundaries in milliseconds
  var MS_PER_DAY = 86400000;
  var MS_PER_WEEK = 604800000;

  // Reputation tier numeric values for scoring
  var TIER_VALUES = {
    'Newcomer': 0,
    'Trusted': 100,
    'Respected': 500,
    'Honored': 1500,
    'Elder': 5000
  };

  // =========================================================================
  // INTERNAL HELPERS
  // =========================================================================

  /**
   * Get current timestamp â€” injectable for testing
   */
  var _nowFn = function() { return Date.now(); };

  function _setNowFn(fn) {
    _nowFn = fn;
  }

  function _now() {
    return _nowFn();
  }

  /**
   * Clamp a number to [min, max]
   */
  function _clamp(val, min, max) {
    if (val < min) return min;
    if (val > max) return max;
    return val;
  }

  /**
   * Safe integer â€” returns 0 for non-finite / NaN
   */
  function _safeInt(n) {
    if (typeof n !== 'number' || !isFinite(n) || isNaN(n)) return 0;
    return Math.floor(n);
  }

  /**
   * Build a time cutoff given a period string
   * @param {string} period - 'all_time' | 'daily' | 'weekly'
   * @returns {number} UNIX milliseconds cutoff (0 = no cutoff)
   */
  function _timeCutoff(period) {
    var now = _now();
    if (period === TIME_PERIODS.DAILY) return now - MS_PER_DAY;
    if (period === TIME_PERIODS.WEEKLY) return now - MS_PER_WEEK;
    return 0; // all_time â€” no cutoff
  }

  /**
   * Normalise an array of {id, score} objects to [0, 100] range.
   * Returns a new array with normalised scores added as normScore.
   */
  function _normalise(entries) {
    if (!entries || entries.length === 0) return [];
    var max = 0;
    for (var i = 0; i < entries.length; i++) {
      if (entries[i].score > max) max = entries[i].score;
    }
    if (max === 0) {
      return entries.map(function(e) {
        return { id: e.id, score: e.score, normScore: 0 };
      });
    }
    return entries.map(function(e) {
      return { id: e.id, score: e.score, normScore: (e.score / max) * 100 };
    });
  }

  /**
   * Sort entries descending by score, attach rank property.
   * Ties receive the same rank; next rank skips accordingly.
   */
  function _rankEntries(entries) {
    if (!entries || entries.length === 0) return [];
    var sorted = entries.slice().sort(function(a, b) { return b.score - a.score; });
    var rank = 1;
    for (var i = 0; i < sorted.length; i++) {
      if (i > 0 && sorted[i].score < sorted[i - 1].score) {
        rank = i + 1;
      }
      sorted[i].rank = rank;
    }
    return sorted;
  }

  /**
   * Validate an id string
   */
  function _validId(id) {
    return typeof id === 'string' && id.length > 0;
  }

  // =========================================================================
  // WEALTH RANKINGS
  // =========================================================================

  /**
   * Build wealth rankings from a ledger or balances object.
   *
   * Accepts either:
   *   - a full ledger: { balances: { playerId: number, ... }, transactions: [] }
   *   - a plain object map: { playerId: number, ... }
   *
   * System accounts (TREASURY, SYSTEM) are always excluded.
   *
   * @param {Object} economyData - Ledger or plain balance map
   * @param {Object} [options] - { period, excludeIds }
   * @returns {Array} Ranked entries: [{rank, id, name, score, label}]
   */
  function getWealthRankings(economyData, options) {
    options = options || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var exclude = options.excludeIds || [];
    var SYSTEM_IDS = ['TREASURY', 'SYSTEM'];

    if (!economyData) return [];

    // Resolve balance map
    var balances = economyData.balances || economyData;
    if (typeof balances !== 'object') return [];

    var entries = [];
    var keys = Object.keys(balances);
    for (var i = 0; i < keys.length; i++) {
      var pid = keys[i];
      if (SYSTEM_IDS.indexOf(pid) !== -1) continue;
      if (exclude.indexOf(pid) !== -1) continue;
      var balance = _safeInt(balances[pid]);
      if (balance < 0) balance = 0;
      entries.push({ id: pid, score: balance, name: pid, label: balance + ' Spark' });
    }

    // For time-period filtering, filter transactions if available
    if (period !== TIME_PERIODS.ALL_TIME && economyData.transactions) {
      var cutoff = _timeCutoff(period);
      var periodEarnings = {};
      var txns = economyData.transactions;
      for (var t = 0; t < txns.length; t++) {
        var tx = txns[t];
        if (tx.ts < cutoff) continue;
        if (tx.type !== 'earn') continue;
        if (SYSTEM_IDS.indexOf(tx.to) !== -1) continue;
        if (!periodEarnings[tx.to]) periodEarnings[tx.to] = 0;
        periodEarnings[tx.to] += _safeInt(tx.amount);
      }
      entries = [];
      var earnKeys = Object.keys(periodEarnings);
      for (var e = 0; e < earnKeys.length; e++) {
        var epid = earnKeys[e];
        if (exclude.indexOf(epid) !== -1) continue;
        var earned = periodEarnings[epid];
        entries.push({ id: epid, score: earned, name: epid, label: earned + ' Spark earned' });
      }
    }

    return _rankEntries(entries);
  }

  // =========================================================================
  // QUEST RANKINGS
  // =========================================================================

  /**
   * Build quest completion rankings.
   *
   * Accepts:
   *   - A map: { playerId: { turnedInQuests: [], completedQuests: [] } }
   *   - Or an array: [{ playerId, turnedInQuests: [], completedQuests: [] }]
   *
   * @param {Object|Array} questData
   * @param {Object} [options] - { period, completedOnly }
   * @returns {Array} Ranked entries
   */
  function getQuestRankings(questData, options) {
    options = options || {};

    if (!questData) return [];

    var entries = [];

    function _processPlayer(pid, pData) {
      if (!_validId(pid)) return;
      var turned = (pData.turnedInQuests || []).length;
      var completed = (pData.completedQuests || []).length;
      // Use max of the two â€” some implementations use one or the other
      var count = Math.max(turned, completed);
      entries.push({ id: pid, score: count, name: pid, label: count + ' quests' });
    }

    if (Array.isArray(questData)) {
      for (var i = 0; i < questData.length; i++) {
        var item = questData[i];
        _processPlayer(item.playerId || item.id, item);
      }
    } else if (typeof questData === 'object') {
      var keys = Object.keys(questData);
      for (var k = 0; k < keys.length; k++) {
        _processPlayer(keys[k], questData[keys[k]]);
      }
    }

    return _rankEntries(entries);
  }

  // =========================================================================
  // EXPLORATION RANKINGS
  // =========================================================================

  /**
   * Build exploration discovery rankings.
   *
   * Accepts:
   *   - An array of discovery objects: [{ discoverer, type, rarity, ts }]
   *   - Or a map: { playerId: [discoveries] }
   *
   * Scoring: 1 point per discovery + bonus for rarity
   *   rarity >= 0.9 (secret)  = 4 pts
   *   rarity >= 0.7 (artifact) = 3 pts
   *   rarity >= 0.5            = 2 pts
   *   rarity  < 0.5            = 1 pt
   *
   * @param {Array|Object} discoveryData
   * @param {Object} [options] - { period, rarityBonus }
   * @returns {Array} Ranked entries
   */
  function getExplorationRankings(discoveryData, options) {
    options = options || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var cutoff = _timeCutoff(period);
    var useRarityBonus = options.rarityBonus !== false; // default true

    if (!discoveryData) return [];

    var scores = {};

    function _addDiscovery(pid, discovery) {
      if (!_validId(pid)) return;
      // Time filter
      if (cutoff > 0 && discovery.ts && discovery.ts < cutoff) return;
      var rarity = typeof discovery.rarity === 'number' ? discovery.rarity : 0.3;
      var points = 1;
      if (useRarityBonus) {
        if (rarity >= 0.9) points = 4;
        else if (rarity >= 0.7) points = 3;
        else if (rarity >= 0.5) points = 2;
      }
      if (!scores[pid]) scores[pid] = 0;
      scores[pid] += points;
    }

    if (Array.isArray(discoveryData)) {
      for (var i = 0; i < discoveryData.length; i++) {
        var d = discoveryData[i];
        _addDiscovery(d.discoverer || d.playerId || d.id, d);
      }
    } else if (typeof discoveryData === 'object') {
      var keys = Object.keys(discoveryData);
      for (var k = 0; k < keys.length; k++) {
        var pid = keys[k];
        var dList = discoveryData[pid];
        if (Array.isArray(dList)) {
          for (var j = 0; j < dList.length; j++) {
            _addDiscovery(pid, dList[j]);
          }
        }
      }
    }

    var entries = [];
    var scoreKeys = Object.keys(scores);
    for (var s = 0; s < scoreKeys.length; s++) {
      var id = scoreKeys[s];
      var sc = scores[id];
      entries.push({ id: id, score: sc, name: id, label: sc + ' pts' });
    }

    return _rankEntries(entries);
  }

  // =========================================================================
  // GUILD RANKINGS
  // =========================================================================

  /**
   * Build guild rankings by XP/level.
   *
   * Accepts:
   *   - Array of guild objects: [{ id, name, xp, level, members, treasury }]
   *   - Or { guilds: [...] }
   *
   * Score = (level * 1000) + xp for stable ordering that respects level brackets
   *
   * @param {Array|Object} guildData
   * @param {Object} [options] - { metric: 'xp'|'members'|'treasury'|'composite' }
   * @returns {Array} Ranked guild entries
   */
  function getGuildRankings(guildData, options) {
    options = options || {};
    var metric = options.metric || 'composite';

    if (!guildData) return [];

    var guilds = Array.isArray(guildData) ? guildData : (guildData.guilds || []);
    if (!Array.isArray(guilds)) return [];

    var entries = [];
    for (var i = 0; i < guilds.length; i++) {
      var g = guilds[i];
      if (!g || !g.id) continue;
      var level = _safeInt(g.level) || 1;
      var xp = _safeInt(g.xp);
      var memberCount = Array.isArray(g.members) ? g.members.length : _safeInt(g.members);
      var treasury = _safeInt(g.treasury);

      var score;
      switch (metric) {
        case 'xp':
          score = xp;
          break;
        case 'members':
          score = memberCount;
          break;
        case 'treasury':
          score = treasury;
          break;
        default: // composite
          score = (level * 1000) + xp;
      }

      entries.push({
        id: g.id,
        score: score,
        name: g.name || g.id,
        tag: g.tag || '',
        level: level,
        xp: xp,
        memberCount: memberCount,
        label: 'Level ' + level + ' Â· ' + xp + ' XP'
      });
    }

    return _rankEntries(entries);
  }

  // =========================================================================
  // REPUTATION RANKINGS
  // =========================================================================

  /**
   * Build reputation rankings.
   *
   * Accepts:
   *   - A map: { playerId: { score, tier, history } }
   *   - Or an array: [{ id/playerId, score, tier }]
   *
   * @param {Object|Array} socialData
   * @param {Object} [options] - { period }
   * @returns {Array} Ranked entries
   */
  function getReputationRankings(socialData, options) {
    options = options || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var cutoff = _timeCutoff(period);

    if (!socialData) return [];

    var entries = [];

    function _processRep(pid, repData) {
      if (!_validId(pid)) return;
      var score;
      if (cutoff > 0 && repData.history) {
        // Sum reputation gains since cutoff
        score = 0;
        var hist = repData.history;
        for (var h = 0; h < hist.length; h++) {
          var entry = hist[h];
          if (entry.timestamp && entry.timestamp >= cutoff && entry.change > 0) {
            score += entry.change;
          }
        }
      } else {
        score = _safeInt(repData.score);
      }
      var tier = repData.tier || 'Newcomer';
      entries.push({
        id: pid,
        score: score,
        name: pid,
        tier: tier,
        label: tier + ' (' + score + ')'
      });
    }

    if (Array.isArray(socialData)) {
      for (var i = 0; i < socialData.length; i++) {
        var item = socialData[i];
        _processRep(item.playerId || item.id, item);
      }
    } else if (typeof socialData === 'object') {
      var keys = Object.keys(socialData);
      for (var k = 0; k < keys.length; k++) {
        _processRep(keys[k], socialData[keys[k]]);
      }
    }

    return _rankEntries(entries);
  }

  // =========================================================================
  // COMBINED / COMPOSITE RANKINGS
  // =========================================================================

  /**
   * Build a weighted composite ranking across all categories.
   *
   * @param {Object} data - { economy, quests, discoveries, guilds, reputation }
   * @param {Object} [options] - { period, weights }
   * @returns {Array} Ranked combined entries
   */
  function getCombinedRankings(data, options) {
    options = options || {};
    data = data || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var weights = options.weights || COMBINED_WEIGHTS;

    // Build individual rankings
    var wealthRaw = getWealthRankings(data.economy || {}, { period: period });
    var questsRaw = getQuestRankings(data.quests || {}, { period: period });
    var exploreRaw = getExplorationRankings(data.discoveries || [], { period: period });
    var repRaw = getReputationRankings(data.reputation || {}, { period: period });

    // Normalise each category
    var wealthNorm = _normalise(wealthRaw);
    var questsNorm = _normalise(questsRaw);
    var exploreNorm = _normalise(exploreRaw);
    var repNorm = _normalise(repRaw);

    // Collect all player IDs
    var allIds = {};
    function _addIds(arr) {
      for (var i = 0; i < arr.length; i++) allIds[arr[i].id] = true;
    }
    _addIds(wealthNorm);
    _addIds(questsNorm);
    _addIds(exploreNorm);
    _addIds(repNorm);

    // Build lookup maps
    function _buildMap(arr) {
      var m = {};
      for (var i = 0; i < arr.length; i++) m[arr[i].id] = arr[i].normScore || 0;
      return m;
    }

    var wMap = _buildMap(wealthNorm);
    var qMap = _buildMap(questsNorm);
    var eMap = _buildMap(exploreNorm);
    var rMap = _buildMap(repNorm);

    var w = {
      wealth: weights.wealth || COMBINED_WEIGHTS.wealth,
      quests: weights.quests || COMBINED_WEIGHTS.quests,
      exploration: weights.exploration || COMBINED_WEIGHTS.exploration,
      reputation: weights.reputation || COMBINED_WEIGHTS.reputation
    };

    var entries = [];
    var ids = Object.keys(allIds);
    for (var i = 0; i < ids.length; i++) {
      var pid = ids[i];
      var combined =
        (wMap[pid] || 0) * w.wealth +
        (qMap[pid] || 0) * w.quests +
        (eMap[pid] || 0) * w.exploration +
        (rMap[pid] || 0) * w.reputation;

      entries.push({
        id: pid,
        score: Math.round(combined * 10) / 10, // one decimal place
        name: pid,
        breakdown: {
          wealth: Math.round((wMap[pid] || 0) * 10) / 10,
          quests: Math.round((qMap[pid] || 0) * 10) / 10,
          exploration: Math.round((eMap[pid] || 0) * 10) / 10,
          reputation: Math.round((rMap[pid] || 0) * 10) / 10
        },
        label: Math.round(combined * 10) / 10 + ' pts'
      });
    }

    return _rankEntries(entries);
  }

  // =========================================================================
  // SINGLE PLAYER RANK LOOKUP
  // =========================================================================

  /**
   * Get a single player's rank in a given category.
   *
   * @param {string} playerId - The player ID to look up
   * @param {string} category - One of CATEGORIES values
   * @param {Object} data - Category-specific data (same as the ranking functions)
   * @param {Object} [options] - Passed through to ranking function
   * @returns {Object} { rank, score, total, label, category } or null if not found
   */
  function getPlayerRank(playerId, category, data, options) {
    if (!_validId(playerId)) return null;

    var rankings = [];

    switch (category) {
      case CATEGORIES.WEALTH:
        rankings = getWealthRankings(data, options);
        break;
      case CATEGORIES.QUESTS:
        rankings = getQuestRankings(data, options);
        break;
      case CATEGORIES.EXPLORATION:
        rankings = getExplorationRankings(data, options);
        break;
      case CATEGORIES.GUILDS:
        rankings = getGuildRankings(data, options);
        break;
      case CATEGORIES.REPUTATION:
        rankings = getReputationRankings(data, options);
        break;
      case CATEGORIES.COMBINED:
        rankings = getCombinedRankings(data, options);
        break;
      default:
        return null;
    }

    for (var i = 0; i < rankings.length; i++) {
      if (rankings[i].id === playerId) {
        return {
          rank: rankings[i].rank,
          score: rankings[i].score,
          total: rankings.length,
          label: rankings[i].label || '',
          category: category,
          entry: rankings[i]
        };
      }
    }

    // Player has no data in this category
    return {
      rank: null,
      score: 0,
      total: rankings.length,
      label: 'Unranked',
      category: category,
      entry: null
    };
  }

  // =========================================================================
  // FORMAT / DISPLAY
  // =========================================================================

  /**
   * Format a ranked array for display.
   *
   * @param {Array} rankings - Output of any ranking function
   * @param {Object} [options]
   *   - count {number} max entries to show (default 10)
   *   - highlightId {string} player ID to highlight
   *   - showBreakdown {boolean} include breakdown for combined (default false)
   *   - columns {Array} field names to include
   * @returns {Array} Formatted display rows
   */
  function formatLeaderboard(rankings, options) {
    options = options || {};
    var count = options.count || 10;
    var highlightId = options.highlightId || null;
    var showBreakdown = !!options.showBreakdown;

    if (!rankings || !Array.isArray(rankings)) return [];

    // Validate count against allowed sizes
    var allowed = options.allowedCounts || DEFAULT_DISPLAY_COUNTS;
    if (allowed.indexOf(count) === -1) {
      // Snap to nearest allowed value
      count = allowed.reduce(function(prev, curr) {
        return Math.abs(curr - count) < Math.abs(prev - count) ? curr : prev;
      }, allowed[0]);
    }

    var slice = rankings.slice(0, count);

    return slice.map(function(entry, idx) {
      var row = {
        rank: entry.rank,
        id: entry.id,
        name: entry.name || entry.id,
        score: entry.score,
        label: entry.label || String(entry.score),
        isHighlighted: highlightId ? entry.id === highlightId : false
      };

      // Optional extra fields
      if (entry.tier) row.tier = entry.tier;
      if (entry.tag) row.tag = entry.tag;
      if (entry.level !== undefined) row.level = entry.level;
      if (entry.memberCount !== undefined) row.memberCount = entry.memberCount;

      if (showBreakdown && entry.breakdown) {
        row.breakdown = entry.breakdown;
      }

      return row;
    });
  }

  // =========================================================================
  // TIME PERIOD HELPERS
  // =========================================================================

  /**
   * Get the label for a time period.
   * @param {string} period
   * @returns {string}
   */
  function getTimePeriodLabel(period) {
    switch (period) {
      case TIME_PERIODS.DAILY: return 'Today';
      case TIME_PERIODS.WEEKLY: return 'This Week';
      default: return 'All Time';
    }
  }

  /**
   * Get all available time periods.
   * @returns {Array} [{ id, label }]
   */
  function getTimePeriods() {
    return [
      { id: TIME_PERIODS.ALL_TIME, label: 'All Time' },
      { id: TIME_PERIODS.DAILY, label: 'Today' },
      { id: TIME_PERIODS.WEEKLY, label: 'This Week' }
    ];
  }

  // =========================================================================
  // FULL BOARD SNAPSHOT
  // =========================================================================

  /**
   * Build a complete leaderboard snapshot for all categories.
   *
   * @param {Object} gameData - { economy, quests, discoveries, guilds, reputation }
   * @param {Object} [options] - { period, count }
   * @returns {Object} { wealth, quests, exploration, guilds, reputation, combined, meta }
   */
  function buildSnapshot(gameData, options) {
    options = options || {};
    gameData = gameData || {};
    var period = options.period || TIME_PERIODS.ALL_TIME;
    var count = options.count || 10;
    var periodOpts = { period: period };

    var wealthRaw = getWealthRankings(gameData.economy || {}, periodOpts);
    var questsRaw = getQuestRankings(gameData.quests || {}, periodOpts);
    var exploreRaw = getExplorationRankings(gameData.discoveries || [], periodOpts);
    var guildsRaw = getGuildRankings(gameData.guilds || [], periodOpts);
    var repRaw = getReputationRankings(gameData.reputation || {}, periodOpts);
    var combinedRaw = getCombinedRankings(gameData, periodOpts);

    var fmtOpts = { count: count, allowedCounts: [count] };

    return {
      wealth: formatLeaderboard(wealthRaw, fmtOpts),
      quests: formatLeaderboard(questsRaw, fmtOpts),
      exploration: formatLeaderboard(exploreRaw, fmtOpts),
      guilds: formatLeaderboard(guildsRaw, fmtOpts),
      reputation: formatLeaderboard(repRaw, fmtOpts),
      combined: formatLeaderboard(combinedRaw, Object.assign({}, fmtOpts, { showBreakdown: true })),
      meta: {
        period: period,
        periodLabel: getTimePeriodLabel(period),
        count: count,
        generatedAt: _now()
      }
    };
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.CATEGORIES = CATEGORIES;
  exports.TIME_PERIODS = TIME_PERIODS;
  exports.COMBINED_WEIGHTS = COMBINED_WEIGHTS;

  exports.getWealthRankings = getWealthRankings;
  exports.getQuestRankings = getQuestRankings;
  exports.getExplorationRankings = getExplorationRankings;
  exports.getGuildRankings = getGuildRankings;
  exports.getReputationRankings = getReputationRankings;
  exports.getCombinedRankings = getCombinedRankings;

  exports.getPlayerRank = getPlayerRank;
  exports.formatLeaderboard = formatLeaderboard;

  exports.getTimePeriodLabel = getTimePeriodLabel;
  exports.getTimePeriods = getTimePeriods;
  exports.buildSnapshot = buildSnapshot;

  // Internal test helpers
  exports._rankEntries = _rankEntries;
  exports._normalise = _normalise;
  exports._timeCutoff = _timeCutoff;
  exports._setNowFn = _setNowFn;
  exports._clamp = _clamp;
  exports._safeInt = _safeInt;

})(typeof module !== 'undefined' ? module.exports : (window.Leaderboards = {}));


// notifications.js
// notifications.js
/**
 * ZION Notification / Toast System
 * Manages in-game alerts, toasts, and notification history.
 * Pure logic â€” no DOM dependency so it is fully testable in Node.js.
 */

(function(exports) {
  'use strict';

  // â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var NOTIFICATION_TYPES = {
    economy:     'economy',
    achievement: 'achievement',
    social:      'social',
    system:      'system',
    quest:       'quest',
    combat:      'combat'
  };

  var PRIORITY_LEVELS = {
    low:      0,
    normal:   1,
    high:     2,
    critical: 3
  };

  // Default durations (ms) per priority
  var DEFAULT_DURATIONS = {
    low:      3000,
    normal:   4500,
    high:     7000,
    critical: 0     // 0 = persist until manually dismissed
  };

  // Icons and accent colours for each type
  var TYPE_META = {
    economy:     { icon: 'ðŸ’°', color: '#f1c40f', label: 'Economy' },
    achievement: { icon: 'ðŸ†', color: '#e67e22', label: 'Achievement' },
    social:      { icon: 'ðŸ’¬', color: '#3498db', label: 'Social' },
    system:      { icon: 'âš™ï¸',  color: '#95a5a6', label: 'System' },
    quest:       { icon: 'ðŸ“œ', color: '#9b59b6', label: 'Quest' },
    combat:      { icon: 'âš”ï¸',  color: '#e74c3c', label: 'Combat' }
  };

  // Sound hints â€” returned so the audio module can react without coupling
  var TYPE_SOUNDS = {
    economy:     'chime_coin',
    achievement: 'fanfare_achievement',
    social:      'ping_social',
    system:      'blip_system',
    quest:       'fanfare_quest',
    combat:      'alert_combat'
  };

  var MAX_HISTORY = 200;
  var DEFAULT_MAX_VISIBLE = 5;
  var DEFAULT_GROUPING_WINDOW = 2000; // ms â€” collapse repeated messages within this window

  // â”€â”€â”€ Internal state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var _idCounter = 0;
  var _toastQueue = [];       // Active toasts (visible)
  var _pendingQueue = [];     // Overflow toasts waiting for a slot
  var _history = [];          // All notifications ever created

  var _prefs = {
    mutedTypes:     {},       // { economy: true, ... }
    durations:      {},       // override durations per type
    maxVisible:     DEFAULT_MAX_VISIBLE,
    groupingWindow: DEFAULT_GROUPING_WINDOW,
    enabled:        true
  };

  // â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _now() {
    return (typeof Date !== 'undefined') ? Date.now() : 0;
  }

  function _nextId() {
    _idCounter += 1;
    return 'notif_' + _idCounter;
  }

  function _isValidType(type) {
    return Object.prototype.hasOwnProperty.call(NOTIFICATION_TYPES, type);
  }

  function _isValidPriority(priority) {
    return Object.prototype.hasOwnProperty.call(PRIORITY_LEVELS, priority);
  }

  function _resolveDuration(type, priority, options) {
    // Explicit override in options wins
    if (options && typeof options.duration === 'number') {
      return options.duration;
    }
    // Per-type preference override
    if (_prefs.durations && typeof _prefs.durations[type] === 'number') {
      return _prefs.durations[type];
    }
    // Default by priority
    return DEFAULT_DURATIONS[priority];
  }

  /**
   * Find a toast in _toastQueue already matching type + message within
   * the grouping window. Returns the found toast or null.
   */
  function _findGroupable(type, message) {
    var now = _now();
    var window = _prefs.groupingWindow;
    for (var i = 0; i < _toastQueue.length; i++) {
      var t = _toastQueue[i];
      if (t.type === type && t.message === message) {
        if (now - t.createdAt <= window) {
          return t;
        }
      }
    }
    return null;
  }

  function _findGroupableInPending(type, message) {
    var now = _now();
    var window = _prefs.groupingWindow;
    for (var i = 0; i < _pendingQueue.length; i++) {
      var t = _pendingQueue[i];
      if (t.type === type && t.message === message) {
        if (now - t.createdAt <= window) {
          return t;
        }
      }
    }
    return null;
  }

  // â”€â”€â”€ Core API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create a notification object (does NOT add it to any queue).
   * @param {string} type     - One of NOTIFICATION_TYPES keys
   * @param {string} message  - Human-readable message
   * @param {Object} options  - Optional overrides: priority, duration, groupable, data
   * @returns {Object} Notification object
   */
  function createNotification(type, message, options) {
    if (!_isValidType(type)) {
      throw new Error('Unknown notification type: ' + type);
    }

    options = options || {};

    var priority = options.priority || 'normal';
    if (!_isValidPriority(priority)) {
      throw new Error('Unknown priority level: ' + priority);
    }

    var duration = _resolveDuration(type, priority, options);

    var notification = {
      id:         _nextId(),
      type:       type,
      message:    String(message),
      priority:   priority,
      duration:   duration,
      groupable:  options.groupable !== false, // default true
      groupCount: 1,
      data:       options.data || null,
      createdAt:  _now(),
      dismissedAt: null,
      expired:    false
    };

    return notification;
  }

  /**
   * Add a notification to the queue, applying grouping and preferences.
   * Returns the notification (possibly a grouped existing one) or null if suppressed.
   * @param {string} type
   * @param {string} message
   * @param {Object} options
   * @returns {Object|null}
   */
  function addNotification(type, message, options) {
    if (!_prefs.enabled) return null;
    if (_prefs.mutedTypes && _prefs.mutedTypes[type]) return null;

    if (!_isValidType(type)) return null;

    options = options || {};

    // Grouping: check if an identical active toast exists
    if (options.groupable !== false) {
      var existing = _findGroupable(type, message);
      if (!existing) {
        existing = _findGroupableInPending(type, message);
      }
      if (existing) {
        existing.groupCount += 1;
        existing.createdAt = _now(); // bump timestamp so it refreshes
        return existing;
      }
    }

    var notif = createNotification(type, message, options);

    // Add to history
    _history.unshift(notif);
    if (_history.length > MAX_HISTORY) {
      _history.length = MAX_HISTORY;
    }

    // Slot available?
    var maxVisible = (_prefs.maxVisible > 0) ? _prefs.maxVisible : DEFAULT_MAX_VISIBLE;
    if (_toastQueue.length < maxVisible) {
      _toastQueue.push(notif);
    } else {
      _pendingQueue.push(notif);
    }

    return notif;
  }

  /**
   * Remove expired toasts from the active queue, promote from pending.
   * Should be called periodically (e.g., from the game loop).
   */
  function tick() {
    var now = _now();
    var maxVisible = (_prefs.maxVisible > 0) ? _prefs.maxVisible : DEFAULT_MAX_VISIBLE;

    // Mark expired
    for (var i = _toastQueue.length - 1; i >= 0; i--) {
      var t = _toastQueue[i];
      if (t.duration > 0 && (now - t.createdAt) >= t.duration) {
        t.expired = true;
        _toastQueue.splice(i, 1);
      }
    }

    // Promote from pending
    while (_toastQueue.length < maxVisible && _pendingQueue.length > 0) {
      var next = _pendingQueue.shift();
      // Reset creation time so the full duration applies from when it becomes visible
      next.createdAt = _now();
      _toastQueue.push(next);
    }
  }

  /**
   * Get currently active (visible) toasts, sorted by priority desc then age asc.
   * @returns {Array}
   */
  function getActiveToasts() {
    // Return a shallow copy sorted by priority descending, then creation time ascending
    var sorted = _toastQueue.slice().sort(function(a, b) {
      var pDiff = PRIORITY_LEVELS[b.priority] - PRIORITY_LEVELS[a.priority];
      if (pDiff !== 0) return pDiff;
      return a.createdAt - b.createdAt;
    });
    return sorted;
  }

  /**
   * Get notification history.
   * @param {number} limit - Maximum entries (default 50)
   * @returns {Array}
   */
  function getNotificationHistory(limit) {
    limit = (typeof limit === 'number' && limit > 0) ? limit : 50;
    return _history.slice(0, limit);
  }

  /**
   * Dismiss a single toast by id.
   * @param {string} id
   * @returns {boolean} true if found and dismissed
   */
  function dismissToast(id) {
    var now = _now();

    for (var i = 0; i < _toastQueue.length; i++) {
      if (_toastQueue[i].id === id) {
        _toastQueue[i].dismissedAt = now;
        _toastQueue[i].expired = true;
        _toastQueue.splice(i, 1);
        // Promote from pending
        tick();
        return true;
      }
    }

    for (var j = 0; j < _pendingQueue.length; j++) {
      if (_pendingQueue[j].id === id) {
        _pendingQueue[j].dismissedAt = now;
        _pendingQueue[j].expired = true;
        _pendingQueue.splice(j, 1);
        return true;
      }
    }

    return false;
  }

  /**
   * Dismiss all active and pending toasts.
   */
  function dismissAll() {
    var now = _now();
    var i;
    for (i = 0; i < _toastQueue.length; i++) {
      _toastQueue[i].dismissedAt = now;
      _toastQueue[i].expired = true;
    }
    for (i = 0; i < _pendingQueue.length; i++) {
      _pendingQueue[i].dismissedAt = now;
      _pendingQueue[i].expired = true;
    }
    _toastQueue = [];
    _pendingQueue = [];
  }

  /**
   * Update user preferences.
   * @param {Object} prefs - Partial prefs object
   *   mutedTypes    {Object}  e.g. { economy: true }
   *   durations     {Object}  e.g. { quest: 8000 }
   *   maxVisible    {number}
   *   groupingWindow {number}
   *   enabled       {boolean}
   */
  function setPreferences(prefs) {
    if (!prefs || typeof prefs !== 'object') return;

    if (typeof prefs.enabled === 'boolean') {
      _prefs.enabled = prefs.enabled;
    }
    if (typeof prefs.maxVisible === 'number' && prefs.maxVisible > 0) {
      _prefs.maxVisible = prefs.maxVisible;
    }
    if (typeof prefs.groupingWindow === 'number' && prefs.groupingWindow >= 0) {
      _prefs.groupingWindow = prefs.groupingWindow;
    }
    if (prefs.mutedTypes && typeof prefs.mutedTypes === 'object') {
      // Merge â€” allow caller to un-mute by passing false
      var mt = prefs.mutedTypes;
      for (var k in mt) {
        if (Object.prototype.hasOwnProperty.call(mt, k)) {
          if (mt[k]) {
            _prefs.mutedTypes[k] = true;
          } else {
            delete _prefs.mutedTypes[k];
          }
        }
      }
    }
    if (prefs.durations && typeof prefs.durations === 'object') {
      var d = prefs.durations;
      for (var key in d) {
        if (Object.prototype.hasOwnProperty.call(d, key)) {
          if (typeof d[key] === 'number') {
            _prefs.durations[key] = d[key];
          }
        }
      }
    }
  }

  /**
   * Format a notification for display.
   * Returns an object with icon, color, label, formattedMessage, soundHint, badgeText.
   * @param {Object} notification - Notification object from createNotification/addNotification
   * @returns {Object}
   */
  function formatNotification(notification) {
    if (!notification) return null;

    var meta = TYPE_META[notification.type] || { icon: 'ðŸ””', color: '#ffffff', label: 'Notice' };
    var sound = TYPE_SOUNDS[notification.type] || 'blip_system';

    var badgeText = null;
    if (notification.groupCount && notification.groupCount > 1) {
      badgeText = 'x' + notification.groupCount;
    }

    var formattedMessage = notification.message;

    return {
      id:               notification.id,
      type:             notification.type,
      priority:         notification.priority,
      icon:             meta.icon,
      color:            meta.color,
      label:            meta.label,
      formattedMessage: formattedMessage,
      soundHint:        sound,
      badgeText:        badgeText,
      groupCount:       notification.groupCount || 1,
      duration:         notification.duration,
      createdAt:        notification.createdAt
    };
  }

  /**
   * Get the sound hint for a notification type without formatting the whole object.
   * Useful for the audio module to play a sound immediately on addNotification.
   * @param {string} type
   * @returns {string}
   */
  function getSoundHint(type) {
    return TYPE_SOUNDS[type] || 'blip_system';
  }

  /**
   * Get a copy of current preferences.
   * @returns {Object}
   */
  function getPreferences() {
    return {
      mutedTypes:      JSON.parse(JSON.stringify(_prefs.mutedTypes)),
      durations:       JSON.parse(JSON.stringify(_prefs.durations)),
      maxVisible:      _prefs.maxVisible,
      groupingWindow:  _prefs.groupingWindow,
      enabled:         _prefs.enabled
    };
  }

  /**
   * Get count of pending (overflow) toasts.
   * @returns {number}
   */
  function getPendingCount() {
    return _pendingQueue.length;
  }

  /**
   * Reset all internal state. Useful for testing / new session.
   */
  function reset() {
    _idCounter = 0;
    _toastQueue = [];
    _pendingQueue = [];
    _history = [];
    _prefs = {
      mutedTypes:     {},
      durations:      {},
      maxVisible:     DEFAULT_MAX_VISIBLE,
      groupingWindow: DEFAULT_GROUPING_WINDOW,
      enabled:        true
    };
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.NOTIFICATION_TYPES  = NOTIFICATION_TYPES;
  exports.PRIORITY_LEVELS     = PRIORITY_LEVELS;
  exports.DEFAULT_DURATIONS   = DEFAULT_DURATIONS;
  exports.TYPE_META           = TYPE_META;
  exports.TYPE_SOUNDS         = TYPE_SOUNDS;

  exports.createNotification      = createNotification;
  exports.addNotification         = addNotification;
  exports.tick                    = tick;
  exports.getActiveToasts         = getActiveToasts;
  exports.getNotificationHistory  = getNotificationHistory;
  exports.dismissToast            = dismissToast;
  exports.dismissAll              = dismissAll;
  exports.setPreferences          = setPreferences;
  exports.getPreferences          = getPreferences;
  exports.formatNotification      = formatNotification;
  exports.getSoundHint            = getSoundHint;
  exports.getPendingCount         = getPendingCount;
  exports.reset                   = reset;

})(typeof module !== 'undefined' ? module.exports : (window.Notifications = {}));


// badges.js
// badges.js
/**
 * ZION Achievement Badges & Cosmetics System
 * Visual rewards for achievement unlocks â€” badges, nameplates, auras, trails
 */

(function(exports) {
  'use strict';

  // ========================================================================
  // BADGE CATALOG
  // ========================================================================
  // Each badge maps to an achievement from quests.js ACHIEVEMENTS
  // Rarities: common, uncommon, rare, epic, legendary
  // Categories: combat, exploration, social, economic, creative, mastery

  var BADGE_CATALOG = {

    // ---- EXPLORATION BADGES ----
    badge_first_steps: {
      id: 'badge_first_steps',
      name: 'First Steps',
      description: 'Entered ZION for the first time',
      icon: 'ðŸ‘£',
      rarity: 'common',
      category: 'exploration',
      achievementId: 'first_steps',
      points: 1
    },
    badge_zone_hopper: {
      id: 'badge_zone_hopper',
      name: 'Zone Hopper',
      description: 'Visited 4 different zones of ZION',
      icon: 'ðŸš¶',
      rarity: 'common',
      category: 'exploration',
      achievementId: 'zone_hopper',
      points: 1
    },
    badge_world_traveler: {
      id: 'badge_world_traveler',
      name: 'World Traveler',
      description: 'Explored all 8 zones of ZION',
      icon: 'ðŸŒ',
      rarity: 'rare',
      category: 'exploration',
      achievementId: 'world_traveler',
      points: 5
    },
    badge_trailblazer: {
      id: 'badge_trailblazer',
      name: 'Trailblazer',
      description: 'Made 10 discoveries across ZION',
      icon: 'ðŸ”',
      rarity: 'uncommon',
      category: 'exploration',
      achievementId: 'trailblazer',
      points: 2
    },
    badge_cartographer: {
      id: 'badge_cartographer',
      name: 'Cartographer',
      description: 'Made 25 discoveries â€” a true mapmaker',
      icon: 'ðŸ—ºï¸',
      rarity: 'rare',
      category: 'exploration',
      achievementId: 'cartographer',
      points: 5
    },

    // ---- SOCIAL BADGES ----
    badge_friendly_face: {
      id: 'badge_friendly_face',
      name: 'Friendly Face',
      description: 'Talked to 10 citizens of ZION',
      icon: 'ðŸ˜Š',
      rarity: 'common',
      category: 'social',
      achievementId: 'friendly_face',
      points: 1
    },
    badge_social_butterfly: {
      id: 'badge_social_butterfly',
      name: 'Social Butterfly',
      description: 'Talked to 50 citizens â€” a beloved community member',
      icon: 'ðŸ¦‹',
      rarity: 'uncommon',
      category: 'social',
      achievementId: 'social_butterfly',
      points: 2
    },
    badge_first_trade: {
      id: 'badge_first_trade',
      name: 'First Trade',
      description: 'Completed a trade with another citizen',
      icon: 'ðŸ¤',
      rarity: 'common',
      category: 'social',
      achievementId: 'first_trade',
      points: 1
    },
    badge_merchant_prince: {
      id: 'badge_merchant_prince',
      name: 'Merchant Prince',
      description: 'Completed 25 trades â€” a pillar of commerce',
      icon: 'ðŸ‘‘',
      rarity: 'epic',
      category: 'social',
      achievementId: 'merchant_prince',
      points: 10
    },
    badge_gift_giver: {
      id: 'badge_gift_giver',
      name: 'Gift Giver',
      description: 'Gifted an item to a fellow citizen',
      icon: 'ðŸŽ',
      rarity: 'common',
      category: 'social',
      achievementId: 'gift_giver',
      points: 1
    },
    badge_guild_founder: {
      id: 'badge_guild_founder',
      name: 'Guild Founder',
      description: 'Founded a guild in ZION',
      icon: 'ðŸ°',
      rarity: 'rare',
      category: 'social',
      achievementId: 'guild_founder',
      points: 5
    },
    badge_guild_member: {
      id: 'badge_guild_member',
      name: 'Guild Member',
      description: 'Joined a guild â€” strength in unity',
      icon: 'ðŸ¤œ',
      rarity: 'common',
      category: 'social',
      achievementId: 'guild_member',
      points: 1
    },

    // ---- ECONOMIC BADGES ----
    badge_spark_saver: {
      id: 'badge_spark_saver',
      name: 'Spark Saver',
      description: 'Accumulated 100 Spark',
      icon: 'âœ¨',
      rarity: 'common',
      category: 'economic',
      achievementId: 'spark_saver',
      points: 1
    },
    badge_spark_hoarder: {
      id: 'badge_spark_hoarder',
      name: 'Spark Hoarder',
      description: 'Accumulated 500 Spark â€” a prosperous citizen',
      icon: 'ðŸ’°',
      rarity: 'uncommon',
      category: 'economic',
      achievementId: 'spark_hoarder',
      points: 2
    },
    badge_spark_magnate: {
      id: 'badge_spark_magnate',
      name: 'Spark Magnate',
      description: 'Accumulated 2000 Spark â€” an economic powerhouse',
      icon: 'ðŸ’Ž',
      rarity: 'epic',
      category: 'economic',
      achievementId: 'spark_magnate',
      points: 10
    },

    // ---- CREATIVE BADGES ----
    badge_first_craft: {
      id: 'badge_first_craft',
      name: 'First Craft',
      description: 'Crafted your first item',
      icon: 'ðŸ”¨',
      rarity: 'common',
      category: 'creative',
      achievementId: 'first_craft',
      points: 1
    },
    badge_apprentice_crafter: {
      id: 'badge_apprentice_crafter',
      name: 'Apprentice Crafter',
      description: 'Crafted 10 items â€” a skilled hand emerges',
      icon: 'âš’ï¸',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'apprentice_crafter',
      points: 2
    },
    badge_master_crafter: {
      id: 'badge_master_crafter',
      name: 'Master Crafter',
      description: 'Crafted 50 items â€” the forge is your home',
      icon: 'ðŸ› ï¸',
      rarity: 'rare',
      category: 'creative',
      achievementId: 'master_crafter',
      points: 5
    },
    badge_potion_brewer: {
      id: 'badge_potion_brewer',
      name: 'Potion Brewer',
      description: 'Brewed 10 potions â€” alchemy mastered',
      icon: 'ðŸ§ª',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'potion_brewer',
      points: 2
    },
    badge_instrument_maker: {
      id: 'badge_instrument_maker',
      name: 'Instrument Maker',
      description: 'Crafted a musical instrument â€” music fills the air',
      icon: 'ðŸŽµ',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'instrument_maker',
      points: 2
    },
    badge_first_build: {
      id: 'badge_first_build',
      name: 'First Build',
      description: 'Placed your first structure in ZION',
      icon: 'ðŸ—ï¸',
      rarity: 'common',
      category: 'creative',
      achievementId: 'first_build',
      points: 1
    },
    badge_architect: {
      id: 'badge_architect',
      name: 'Architect',
      description: 'Placed 10 structures â€” shaping the world',
      icon: 'ðŸ›ï¸',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'architect',
      points: 2
    },
    badge_city_planner: {
      id: 'badge_city_planner',
      name: 'City Planner',
      description: 'Placed 50 structures â€” an urban visionary',
      icon: 'ðŸ™ï¸',
      rarity: 'epic',
      category: 'creative',
      achievementId: 'city_planner',
      points: 10
    },
    badge_green_thumb: {
      id: 'badge_green_thumb',
      name: 'Green Thumb',
      description: 'Planted your first seed',
      icon: 'ðŸŒ±',
      rarity: 'common',
      category: 'creative',
      achievementId: 'green_thumb',
      points: 1
    },
    badge_gardener: {
      id: 'badge_gardener',
      name: 'Gardener',
      description: 'Harvested 20 plants â€” the Gardens bloom for you',
      icon: 'ðŸŒ»',
      rarity: 'uncommon',
      category: 'creative',
      achievementId: 'gardener',
      points: 2
    },
    badge_botanist: {
      id: 'badge_botanist',
      name: 'Botanist',
      description: 'Harvested 100 plants â€” ZION\'s foremost naturalist',
      icon: 'ðŸŒ¿',
      rarity: 'rare',
      category: 'creative',
      achievementId: 'botanist',
      points: 5
    },
    badge_first_artwork: {
      id: 'badge_first_artwork',
      name: 'First Artwork',
      description: 'Created your first artwork',
      icon: 'ðŸŽ¨',
      rarity: 'common',
      category: 'creative',
      achievementId: 'first_artwork',
      points: 1
    },
    badge_prolific_artist: {
      id: 'badge_prolific_artist',
      name: 'Prolific Artist',
      description: 'Created 10 artworks â€” a true visionary',
      icon: 'ðŸ–¼ï¸',
      rarity: 'rare',
      category: 'creative',
      achievementId: 'prolific_artist',
      points: 5
    },

    // ---- COMBAT BADGES ----
    badge_first_challenge: {
      id: 'badge_first_challenge',
      name: 'First Challenge',
      description: 'Participated in your first competition',
      icon: 'âš”ï¸',
      rarity: 'common',
      category: 'combat',
      achievementId: 'first_challenge',
      points: 1
    },
    badge_champion: {
      id: 'badge_champion',
      name: 'Champion',
      description: 'Won 5 competitions â€” glory to the victor',
      icon: 'ðŸ†',
      rarity: 'epic',
      category: 'combat',
      achievementId: 'champion',
      points: 10
    },

    // ---- MASTERY BADGES ----
    badge_quest_starter: {
      id: 'badge_quest_starter',
      name: 'Quest Starter',
      description: 'Accepted your first quest',
      icon: 'ðŸ“‹',
      rarity: 'common',
      category: 'mastery',
      achievementId: 'quest_starter',
      points: 1
    },
    badge_questmaster: {
      id: 'badge_questmaster',
      name: 'Questmaster',
      description: 'Completed 10 quests â€” a seasoned adventurer',
      icon: 'ðŸ“œ',
      rarity: 'uncommon',
      category: 'mastery',
      achievementId: 'questmaster',
      points: 2
    },
    badge_completionist: {
      id: 'badge_completionist',
      name: 'Completionist',
      description: 'Completed 25 quests â€” nothing left undone',
      icon: 'â­',
      rarity: 'legendary',
      category: 'mastery',
      achievementId: 'completionist',
      points: 25
    },
    badge_chain_finisher: {
      id: 'badge_chain_finisher',
      name: 'Chain Finisher',
      description: 'Completed an entire quest chain',
      icon: 'ðŸ”—',
      rarity: 'rare',
      category: 'mastery',
      achievementId: 'chain_finisher',
      points: 5
    },
    badge_sunwalker: {
      id: 'badge_sunwalker',
      name: 'Sunwalker',
      description: 'Reached the Sunwalker warmth tier â€” radiant and warm',
      icon: 'â˜€ï¸',
      rarity: 'legendary',
      category: 'mastery',
      achievementId: 'sunwalker',
      points: 25
    },
    badge_first_lesson: {
      id: 'badge_first_lesson',
      name: 'First Lesson',
      description: 'Completed a mentoring lesson',
      icon: 'ðŸ“š',
      rarity: 'common',
      category: 'mastery',
      achievementId: 'first_lesson',
      points: 1
    },
    badge_wise_mentor: {
      id: 'badge_wise_mentor',
      name: 'Wise Mentor',
      description: 'Mentored 5 players â€” wisdom shared is wisdom multiplied',
      icon: 'ðŸŽ“',
      rarity: 'epic',
      category: 'mastery',
      achievementId: 'wise_mentor',
      points: 10
    }
  };

  // ========================================================================
  // COSMETIC REWARDS
  // Keyed by badgeId â†’ cosmetic data
  // Types: name_color, trail_effect, aura_effect
  // ========================================================================

  var COSMETIC_REWARDS = {
    // Exploration cosmetics
    badge_world_traveler: {
      type: 'name_color',
      value: '#4a90e2',
      label: 'Traveler Blue',
      description: 'Your name glows in explorer blue'
    },
    badge_cartographer: {
      type: 'trail_effect',
      value: 'map_dots',
      label: 'Cartographer Trail',
      description: 'Leave a trail of glowing map dots as you walk'
    },

    // Social cosmetics
    badge_merchant_prince: {
      type: 'name_color',
      value: '#f5a623',
      label: 'Merchant Gold',
      description: 'Your name shimmers in merchant gold'
    },
    badge_social_butterfly: {
      type: 'aura_effect',
      value: 'butterfly_wings',
      label: 'Butterfly Aura',
      description: 'Glowing butterfly wings flutter around you'
    },

    // Economic cosmetics
    badge_spark_magnate: {
      type: 'aura_effect',
      value: 'spark_aura',
      label: 'Spark Aura',
      description: 'Sparks swirl around your form'
    },
    badge_spark_hoarder: {
      type: 'trail_effect',
      value: 'coin_trail',
      label: 'Coin Trail',
      description: 'Leave a trail of gleaming coins'
    },

    // Creative cosmetics
    badge_master_crafter: {
      type: 'aura_effect',
      value: 'forge_glow',
      label: 'Forge Glow',
      description: 'An orange forge-light aura surrounds you'
    },
    badge_city_planner: {
      type: 'name_color',
      value: '#7ed321',
      label: 'Builder Green',
      description: 'Your name gleams in architect green'
    },
    badge_botanist: {
      type: 'trail_effect',
      value: 'petal_trail',
      label: 'Petal Trail',
      description: 'Flower petals drift behind you as you walk'
    },
    badge_prolific_artist: {
      type: 'aura_effect',
      value: 'paint_splash',
      label: 'Artist Aura',
      description: 'Colorful paint splashes swirl around you'
    },

    // Combat cosmetics
    badge_champion: {
      type: 'name_color',
      value: '#e74c3c',
      label: 'Champion Red',
      description: 'Your name blazes in champion crimson'
    },
    badge_first_challenge: {
      type: 'trail_effect',
      value: 'arena_sparks',
      label: 'Arena Sparks',
      description: 'Sparks fly from your footsteps'
    },

    // Mastery cosmetics
    badge_completionist: {
      type: 'aura_effect',
      value: 'star_burst',
      label: 'Star Burst Aura',
      description: 'Golden stars radiate from your body'
    },
    badge_sunwalker: {
      type: 'aura_effect',
      value: 'solar_halo',
      label: 'Solar Halo',
      description: 'A blazing solar halo crowns your head'
    },
    badge_wise_mentor: {
      type: 'name_color',
      value: '#9b59b6',
      label: 'Mentor Purple',
      description: 'Your name glows in wise mentor purple'
    },
    badge_questmaster: {
      type: 'trail_effect',
      value: 'scroll_trail',
      label: 'Scroll Trail',
      description: 'Ancient scrolls flutter in your wake'
    }
  };

  // ========================================================================
  // RARITY CONFIG
  // ========================================================================

  var RARITY_CONFIG = {
    common:    { color: '#9e9e9e', label: 'Common',    points: 1  },
    uncommon:  { color: '#4caf50', label: 'Uncommon',  points: 2  },
    rare:      { color: '#2196f3', label: 'Rare',      points: 5  },
    epic:      { color: '#9c27b0', label: 'Epic',      points: 10 },
    legendary: { color: '#ff9800', label: 'Legendary', points: 25 }
  };

  // ========================================================================
  // COLLECTOR TIERS
  // ========================================================================

  var COLLECTOR_TIERS = [
    { minPoints: 0,   level: 0, title: 'Newcomer',     color: '#9e9e9e' },
    { minPoints: 5,   level: 1, title: 'Collector',    color: '#4caf50' },
    { minPoints: 15,  level: 2, title: 'Enthusiast',   color: '#2196f3' },
    { minPoints: 35,  level: 3, title: 'Connoisseur',  color: '#9c27b0' },
    { minPoints: 75,  level: 4, title: 'Curator',      color: '#ff9800' },
    { minPoints: 150, level: 5, title: 'Archivist',    color: '#f44336' },
    { minPoints: 300, level: 6, title: 'Legendary Collector', color: '#ffd700' }
  ];

  // ========================================================================
  // PLAYER DISPLAY BADGE STORAGE (in-memory, per session)
  // ========================================================================

  var playerDisplayBadges = {}; // playerId -> badgeId

  // ========================================================================
  // PUBLIC API
  // ========================================================================

  /**
   * Get all badges earned by a player based on their unlocked achievements.
   * @param {string} playerId
   * @param {Array|Set} achievements - array of achievement IDs or Set of IDs
   * @returns {Array} earned badge objects (with unlocked: true)
   */
  function getBadgesForPlayer(playerId, achievements) {
    var unlockedSet;
    if (achievements instanceof Set) {
      unlockedSet = achievements;
    } else if (Array.isArray(achievements)) {
      unlockedSet = new Set(achievements);
    } else {
      unlockedSet = new Set();
    }

    var earned = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (unlockedSet.has(badge.achievementId)) {
        earned.push(_withMeta(badge, true));
      }
    }
    return earned;
  }

  /**
   * Get all unlocked badges from an achievement progress object.
   * @param {Object} achievementProgress - { unlocked: Set|Array, ... }
   * @returns {Array} unlocked badge objects
   */
  function getUnlockedBadges(achievementProgress) {
    var unlockedIds;
    if (!achievementProgress) {
      return [];
    }
    if (achievementProgress.unlocked instanceof Set) {
      unlockedIds = achievementProgress.unlocked;
    } else if (Array.isArray(achievementProgress.unlocked)) {
      unlockedIds = new Set(achievementProgress.unlocked);
    } else {
      unlockedIds = new Set();
    }

    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (unlockedIds.has(badge.achievementId)) {
        result.push(_withMeta(badge, true));
      }
    }
    return result;
  }

  /**
   * Get all locked badges with progress percentage.
   * @param {Object} achievementProgress - { unlocked: Set|Array, counters: {} }
   * @returns {Array} locked badge objects with progressPct field
   */
  function getLockedBadges(achievementProgress) {
    var unlockedIds;
    if (!achievementProgress) {
      return Object.keys(BADGE_CATALOG).map(function(id) {
        return _withMeta(BADGE_CATALOG[id], false, 0);
      });
    }
    if (achievementProgress.unlocked instanceof Set) {
      unlockedIds = achievementProgress.unlocked;
    } else if (Array.isArray(achievementProgress.unlocked)) {
      unlockedIds = new Set(achievementProgress.unlocked);
    } else {
      unlockedIds = new Set();
    }

    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (!unlockedIds.has(badge.achievementId)) {
        var pct = _computeProgress(badge.achievementId, achievementProgress.counters || {});
        result.push(_withMeta(badge, false, pct));
      }
    }
    return result;
  }

  /**
   * Filter badges by category.
   * @param {string} category - one of: combat, exploration, social, economic, creative, mastery
   * @returns {Array} badges in that category
   */
  function getBadgesByCategory(category) {
    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (badge.category === category) {
        result.push(_withMeta(badge, false));
      }
    }
    return result;
  }

  /**
   * Filter badges by rarity.
   * @param {string} rarity - one of: common, uncommon, rare, epic, legendary
   * @returns {Array} badges of that rarity
   */
  function getBadgesByRarity(rarity) {
    var result = [];
    for (var badgeId in BADGE_CATALOG) {
      var badge = BADGE_CATALOG[badgeId];
      if (badge.rarity === rarity) {
        result.push(_withMeta(badge, false));
      }
    }
    return result;
  }

  /**
   * Get the player's selected showcase/display badge.
   * @param {string} playerId
   * @returns {Object|null} badge object or null if none selected
   */
  function getDisplayBadge(playerId) {
    var badgeId = playerDisplayBadges[playerId];
    if (!badgeId || !BADGE_CATALOG[badgeId]) {
      return null;
    }
    return _withMeta(BADGE_CATALOG[badgeId], true);
  }

  /**
   * Set player's showcase display badge.
   * @param {string} playerId
   * @param {string} badgeId - must be a valid badge id
   * @returns {Object} { success: boolean, message: string }
   */
  function setDisplayBadge(playerId, badgeId) {
    if (!badgeId) {
      delete playerDisplayBadges[playerId];
      return { success: true, message: 'Display badge cleared' };
    }
    if (!BADGE_CATALOG[badgeId]) {
      return { success: false, message: 'Unknown badge: ' + badgeId };
    }
    playerDisplayBadges[playerId] = badgeId;
    return { success: true, message: 'Display badge set to ' + BADGE_CATALOG[badgeId].name };
  }

  /**
   * Get nameplate decoration data for a player based on their badges.
   * @param {string} playerId
   * @param {Array} badges - array of earned badge objects
   * @returns {Object} decoration: { borderColor, glowColor, icon, title }
   */
  function getNameplateDecoration(playerId, badges) {
    if (!badges || badges.length === 0) {
      return { borderColor: '#9e9e9e', glowColor: null, icon: null, title: null };
    }

    // Find highest rarity badge
    var rarityOrder = ['legendary', 'epic', 'rare', 'uncommon', 'common'];
    var topBadge = null;
    for (var ri = 0; ri < rarityOrder.length; ri++) {
      for (var bi = 0; bi < badges.length; bi++) {
        if (badges[bi].rarity === rarityOrder[ri]) {
          topBadge = badges[bi];
          break;
        }
      }
      if (topBadge) break;
    }

    // Check for display badge override
    var displayBadgeId = playerDisplayBadges[playerId];
    if (displayBadgeId && BADGE_CATALOG[displayBadgeId]) {
      topBadge = BADGE_CATALOG[displayBadgeId];
    }

    var rarityColor = getBadgeRarityColor(topBadge.rarity);

    return {
      borderColor: rarityColor,
      glowColor: topBadge.rarity === 'legendary' || topBadge.rarity === 'epic' ? rarityColor : null,
      icon: topBadge.icon,
      title: topBadge.name
    };
  }

  /**
   * Get the cosmetic reward for a specific badge.
   * @param {string} badgeId
   * @returns {Object|null} cosmetic object or null
   */
  function getCosmeticForBadge(badgeId) {
    return COSMETIC_REWARDS[badgeId] || null;
  }

  /**
   * Get all cosmetics unlocked by a player's badges.
   * @param {string} playerId
   * @param {Array} unlockedBadges - array of unlocked badge objects
   * @returns {Array} cosmetic objects with badgeId reference
   */
  function getPlayerCosmetics(playerId, unlockedBadges) {
    if (!unlockedBadges || unlockedBadges.length === 0) return [];
    var cosmetics = [];
    for (var i = 0; i < unlockedBadges.length; i++) {
      var badge = unlockedBadges[i];
      var cosmetic = COSMETIC_REWARDS[badge.id];
      if (cosmetic) {
        cosmetics.push({
          badgeId: badge.id,
          badgeName: badge.name,
          type: cosmetic.type,
          value: cosmetic.value,
          label: cosmetic.label,
          description: cosmetic.description
        });
      }
    }
    return cosmetics;
  }

  /**
   * Get the color string for a rarity tier.
   * @param {string} rarity
   * @returns {string} hex color
   */
  function getBadgeRarityColor(rarity) {
    var config = RARITY_CONFIG[rarity];
    return config ? config.color : '#9e9e9e';
  }

  /**
   * Format a badge for HUD display.
   * @param {Object} badge
   * @returns {string} formatted string
   */
  function formatBadgeDisplay(badge) {
    if (!badge) return '';
    var rarityConfig = RARITY_CONFIG[badge.rarity] || RARITY_CONFIG.common;
    return '[' + rarityConfig.label.toUpperCase() + '] ' + badge.icon + ' ' + badge.name + ' â€” ' + badge.description;
  }

  /**
   * Calculate total badge points from a list of badges.
   * @param {Array} badges - array of badge objects
   * @returns {number} total points
   */
  function getTotalBadgePoints(badges) {
    if (!badges || badges.length === 0) return 0;
    var total = 0;
    for (var i = 0; i < badges.length; i++) {
      var badge = badges[i];
      var rarity = badge.rarity || 'common';
      var config = RARITY_CONFIG[rarity];
      total += config ? config.points : 1;
    }
    return total;
  }

  /**
   * Get collector level/tier from total badge points.
   * @param {number} points
   * @returns {Object} { level, title, color, minPoints, nextThreshold }
   */
  function getCollectorLevel(points) {
    var tier = COLLECTOR_TIERS[0];
    for (var i = COLLECTOR_TIERS.length - 1; i >= 0; i--) {
      if (points >= COLLECTOR_TIERS[i].minPoints) {
        tier = COLLECTOR_TIERS[i];
        break;
      }
    }
    var nextTier = null;
    for (var j = 0; j < COLLECTOR_TIERS.length; j++) {
      if (COLLECTOR_TIERS[j].minPoints > points) {
        nextTier = COLLECTOR_TIERS[j];
        break;
      }
    }
    return {
      level: tier.level,
      title: tier.title,
      color: tier.color,
      minPoints: tier.minPoints,
      nextThreshold: nextTier ? nextTier.minPoints : null,
      pointsToNext: nextTier ? nextTier.minPoints - points : 0
    };
  }

  // ========================================================================
  // PRIVATE HELPERS
  // ========================================================================

  function _withMeta(badge, unlocked, progressPct) {
    return {
      id: badge.id,
      name: badge.name,
      description: badge.description,
      icon: badge.icon,
      rarity: badge.rarity,
      category: badge.category,
      achievementId: badge.achievementId,
      points: badge.points,
      unlocked: unlocked === true,
      progressPct: progressPct !== undefined ? progressPct : (unlocked ? 100 : 0)
    };
  }

  /**
   * Estimate progress percentage toward an achievement based on counters.
   * @param {string} achievementId
   * @param {Object} counters
   * @returns {number} 0-99 (never 100, that means unlocked)
   */
  function _computeProgress(achievementId, counters) {
    var pct = 0;
    switch (achievementId) {
      case 'zone_hopper':
        pct = Math.min(99, Math.round(((counters.zones_visited || 0) / 4) * 100));
        break;
      case 'world_traveler':
        pct = Math.min(99, Math.round(((counters.zones_visited || 0) / 8) * 100));
        break;
      case 'trailblazer':
        pct = Math.min(99, Math.round(((counters.discoveries_made || 0) / 10) * 100));
        break;
      case 'cartographer':
        pct = Math.min(99, Math.round(((counters.discoveries_made || 0) / 25) * 100));
        break;
      case 'friendly_face':
        pct = Math.min(99, Math.round(((counters.npcs_talked || 0) / 10) * 100));
        break;
      case 'social_butterfly':
        pct = Math.min(99, Math.round(((counters.npcs_talked || 0) / 50) * 100));
        break;
      case 'merchant_prince':
        pct = Math.min(99, Math.round(((counters.trades_completed || 0) / 25) * 100));
        break;
      case 'apprentice_crafter':
        pct = Math.min(99, Math.round(((counters.items_crafted || 0) / 10) * 100));
        break;
      case 'master_crafter':
        pct = Math.min(99, Math.round(((counters.items_crafted || 0) / 50) * 100));
        break;
      case 'potion_brewer':
        pct = Math.min(99, Math.round(((counters.potions_brewed || 0) / 10) * 100));
        break;
      case 'architect':
        pct = Math.min(99, Math.round(((counters.structures_placed || 0) / 10) * 100));
        break;
      case 'city_planner':
        pct = Math.min(99, Math.round(((counters.structures_placed || 0) / 50) * 100));
        break;
      case 'gardener':
        pct = Math.min(99, Math.round(((counters.plants_harvested || 0) / 20) * 100));
        break;
      case 'botanist':
        pct = Math.min(99, Math.round(((counters.plants_harvested || 0) / 100) * 100));
        break;
      case 'champion':
        pct = Math.min(99, Math.round(((counters.competitions_won || 0) / 5) * 100));
        break;
      case 'questmaster':
        pct = Math.min(99, Math.round(((counters.quests_completed || 0) / 10) * 100));
        break;
      case 'completionist':
        pct = Math.min(99, Math.round(((counters.quests_completed || 0) / 25) * 100));
        break;
      case 'prolific_artist':
        pct = Math.min(99, Math.round(((counters.artworks_created || 0) / 10) * 100));
        break;
      case 'wise_mentor':
        pct = Math.min(99, Math.round(((counters.players_mentored || 0) / 5) * 100));
        break;
      default:
        pct = 0;
        break;
    }
    return pct;
  }

  // ========================================================================
  // EXPORTS
  // ========================================================================

  exports.BADGE_CATALOG = BADGE_CATALOG;
  exports.COSMETIC_REWARDS = COSMETIC_REWARDS;
  exports.RARITY_CONFIG = RARITY_CONFIG;
  exports.COLLECTOR_TIERS = COLLECTOR_TIERS;
  exports.getBadgesForPlayer = getBadgesForPlayer;
  exports.getUnlockedBadges = getUnlockedBadges;
  exports.getLockedBadges = getLockedBadges;
  exports.getBadgesByCategory = getBadgesByCategory;
  exports.getBadgesByRarity = getBadgesByRarity;
  exports.getDisplayBadge = getDisplayBadge;
  exports.setDisplayBadge = setDisplayBadge;
  exports.getNameplateDecoration = getNameplateDecoration;
  exports.getCosmeticForBadge = getCosmeticForBadge;
  exports.getPlayerCosmetics = getPlayerCosmetics;
  exports.getBadgeRarityColor = getBadgeRarityColor;
  exports.formatBadgeDisplay = formatBadgeDisplay;
  exports.getTotalBadgePoints = getTotalBadgePoints;
  exports.getCollectorLevel = getCollectorLevel;

})(typeof module !== 'undefined' ? module.exports : (window.Badges = {}));


// daily_rewards.js
// daily_rewards.js
/**
 * ZION Daily Login Rewards System
 * Tracks consecutive login streaks and awards escalating rewards
 * Depends on: economy.js (Spark), inventory.js (items)
 */

(function(exports) {
  'use strict';

  // =========================================================================
  // CONSTANTS
  // =========================================================================

  var GRACE_PERIOD_HOURS = 36;

  // 7-day reward calendar â€” cycles every 7 days
  var REWARD_CALENDAR = [
    {
      day: 1,
      label: 'Day 1',
      type: 'spark',
      spark: 5,
      item: null,
      description: '5 Spark to start your journey'
    },
    {
      day: 2,
      label: 'Day 2',
      type: 'item',
      spark: 0,
      item: { id: 'seed_wildflower', count: 3 },
      description: '3 Wildflower Seeds'
    },
    {
      day: 3,
      label: 'Day 3',
      type: 'spark',
      spark: 10,
      item: null,
      description: '10 Spark'
    },
    {
      day: 4,
      label: 'Day 4',
      type: 'item',
      spark: 0,
      item: { id: 'wood_oak', count: 5 },
      description: '5 Oak Wood (crafting material)'
    },
    {
      day: 5,
      label: 'Day 5',
      type: 'spark',
      spark: 15,
      item: null,
      description: '15 Spark'
    },
    {
      day: 6,
      label: 'Day 6',
      type: 'rare_chance',
      spark: 5,
      item: { id: 'crystal_amethyst', count: 1 },
      rareChance: 0.25,
      rareFallbackItem: { id: 'stone_marble', count: 2 },
      description: '5 Spark + chance at Amethyst'
    },
    {
      day: 7,
      label: 'Day 7 (Weekly Bonus)',
      type: 'jackpot',
      spark: 25,
      item: { id: 'potion_wisdom', count: 1 },
      description: '25 Spark + Wisdom Potion'
    }
  ];

  // Streak bonus multipliers applied to Spark rewards
  var STREAK_BONUSES = [
    { minStreak: 30, multiplier: 3.0,  label: 'Legendary Streak' },
    { minStreak: 14, multiplier: 2.5,  label: 'Epic Streak' },
    { minStreak: 7,  multiplier: 2.0,  label: 'Great Streak' },
    { minStreak: 3,  multiplier: 1.5,  label: 'Good Streak' },
    { minStreak: 1,  multiplier: 1.0,  label: 'Active' }
  ];

  // =========================================================================
  // HELPERS
  // =========================================================================

  /**
   * Returns start-of-day timestamp (midnight UTC) for a given timestamp.
   * @param {number} ts - Unix timestamp in milliseconds
   * @returns {number} Midnight UTC timestamp in ms
   */
  function dayStart(ts) {
    var d = new Date(ts);
    return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  }

  /**
   * Returns the number of whole days between two timestamps (a - b).
   * @param {number} tsA
   * @param {number} tsB
   * @returns {number}
   */
  function daysDiff(tsA, tsB) {
    var msPerDay = 24 * 60 * 60 * 1000;
    return Math.floor((dayStart(tsA) - dayStart(tsB)) / msPerDay);
  }

  /**
   * Initialise player daily-reward state if missing.
   * @param {Object} playerData
   * @returns {Object} Mutated playerData with dailyRewards initialised
   */
  function ensureState(playerData) {
    if (!playerData.dailyRewards) {
      playerData.dailyRewards = {
        streak: 0,
        lastClaimTs: null,
        history: [],
        lifetimeSpark: 0,
        lifetimeItems: []
      };
    }
    return playerData;
  }

  // =========================================================================
  // STREAK
  // =========================================================================

  /**
   * Returns the current consecutive login streak for a player.
   * Automatically resets the streak if the grace period has passed.
   * @param {Object} playerData
   * @returns {number}
   */
  function getStreak(playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    if (dr.lastClaimTs === null) {
      return 0;
    }
    var now = Date.now();
    var gracePeriodMs = GRACE_PERIOD_HOURS * 60 * 60 * 1000;
    var elapsed = now - dr.lastClaimTs;
    // If more than grace period has passed since last claim, streak is broken
    if (elapsed > gracePeriodMs) {
      return 0;
    }
    return dr.streak;
  }

  /**
   * Returns the streak bonus descriptor for a given streak count.
   * @param {number} streak
   * @returns {Object} {multiplier, label}
   */
  function getStreakBonus(streak) {
    for (var i = 0; i < STREAK_BONUSES.length; i++) {
      if (streak >= STREAK_BONUSES[i].minStreak) {
        return {
          multiplier: STREAK_BONUSES[i].multiplier,
          label: STREAK_BONUSES[i].label
        };
      }
    }
    return { multiplier: 1.0, label: 'No Streak' };
  }

  /**
   * Applies streak multiplier to a base Spark amount, rounding down.
   * @param {number} baseReward - Base Spark amount
   * @param {number} streak     - Current streak
   * @returns {number}
   */
  function calculateStreakReward(baseReward, streak) {
    var bonus = getStreakBonus(streak);
    return Math.floor(baseReward * bonus.multiplier);
  }

  /**
   * Resets a player's streak immediately (called when grace period is missed).
   * @param {Object} playerData
   * @returns {Object} Mutated playerData
   */
  function resetStreak(playerData) {
    ensureState(playerData);
    playerData.dailyRewards.streak = 0;
    return playerData;
  }

  // =========================================================================
  // CALENDAR
  // =========================================================================

  /**
   * Returns the reward descriptor for a given day number (1-indexed, cycles).
   * @param {number} dayNumber - 1-based day number (wraps every 7 days)
   * @returns {Object} Reward descriptor from REWARD_CALENDAR
   */
  function getDailyReward(dayNumber) {
    var index = ((dayNumber - 1) % 7 + 7) % 7;
    return REWARD_CALENDAR[index];
  }

  /**
   * Returns the next reward the player will receive (tomorrow's reward).
   * @param {Object} playerData
   * @returns {Object} Reward descriptor
   */
  function getNextReward(playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    var currentStreak = getStreak(playerData);
    // Next claim will be on streak + 1 if they haven't broken streak, else day 1
    var nextDay = currentStreak + 1;
    return getDailyReward(nextDay);
  }

  /**
   * Returns a 7-element calendar view showing which days are claimed/upcoming.
   * @param {Object} playerData
   * @returns {Array} Array of {day, label, description, type, claimed, current, upcoming}
   */
  function getCalendarView(playerData) {
    ensureState(playerData);
    var currentStreak = getStreak(playerData);
    var canClaimNow = canClaim(null, playerData);

    var result = [];
    for (var i = 0; i < 7; i++) {
      var dayNum = i + 1;
      var reward = REWARD_CALENDAR[i];
      var claimed = dayNum <= currentStreak;
      // If player can claim today, mark the next day as "current"
      var current = canClaimNow && dayNum === (currentStreak + 1);
      // If player already claimed today, mark today's day as current (not future)
      if (!canClaimNow && dayNum === currentStreak) {
        current = true;
        claimed = false; // just claimed
      }
      result.push({
        day: dayNum,
        label: reward.label,
        description: reward.description,
        type: reward.type,
        spark: reward.spark,
        item: reward.item,
        claimed: claimed,
        current: current,
        upcoming: !claimed && !current
      });
    }
    return result;
  }

  // =========================================================================
  // CLAIM VALIDATION
  // =========================================================================

  /**
   * Returns true if the player can claim their daily reward right now.
   * @param {string|null} playerId - Unused; kept for API consistency
   * @param {Object} playerData
   * @returns {boolean}
   */
  function canClaim(playerId, playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    if (dr.lastClaimTs === null) {
      return true;
    }
    var now = Date.now();
    var diff = daysDiff(now, dr.lastClaimTs);
    return diff >= 1;
  }

  // =========================================================================
  // CLAIM
  // =========================================================================

  /**
   * Claims today's daily reward for a player.
   * @param {string} playerId
   * @param {Object} playerData
   * @param {Object} [options]  - {now: number} override for testing
   * @returns {Object} {success, reward, streakBonus, newStreak, message}
   */
  function claimDailyReward(playerId, playerData, options) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    var now = (options && options.now) ? options.now : Date.now();

    // Check if can claim
    if (dr.lastClaimTs !== null) {
      var diff = daysDiff(now, dr.lastClaimTs);
      if (diff < 1) {
        return {
          success: false,
          message: 'Already claimed today',
          nextClaimTs: dayStart(dr.lastClaimTs) + 24 * 60 * 60 * 1000
        };
      }
    }

    // Determine if streak continues or resets
    var gracePeriodMs = GRACE_PERIOD_HOURS * 60 * 60 * 1000;
    var streakContinues = (dr.lastClaimTs === null) ? false :
                          (now - dr.lastClaimTs) <= gracePeriodMs;

    var newStreak;
    if (dr.lastClaimTs === null) {
      newStreak = 1;
    } else if (streakContinues) {
      newStreak = dr.streak + 1;
    } else {
      // Grace period passed â€” reset to 1
      newStreak = 1;
    }

    // Get reward for this streak day (cycles every 7)
    var reward = getDailyReward(newStreak);

    // Calculate streak-boosted Spark
    var baseSpark = reward.spark || 0;
    var boostedSpark = calculateStreakReward(baseSpark, newStreak);
    var streakBonus = getStreakBonus(newStreak);

    // Resolve item for rare_chance type
    var awardedItem = null;
    if (reward.type === 'rare_chance') {
      var roll = Math.random();
      awardedItem = (roll < reward.rareChance) ? reward.item : reward.rareFallbackItem;
    } else {
      awardedItem = reward.item;
    }

    // Build claim record
    var claimRecord = {
      ts: now,
      day: newStreak,
      calendarDay: ((newStreak - 1) % 7) + 1,
      spark: boostedSpark,
      baseSpark: baseSpark,
      item: awardedItem,
      streakMultiplier: streakBonus.multiplier,
      streakLabel: streakBonus.label
    };

    // Update player state
    dr.streak = newStreak;
    dr.lastClaimTs = now;
    dr.history.push(claimRecord);
    dr.lifetimeSpark += boostedSpark;
    if (awardedItem) {
      dr.lifetimeItems.push({ ts: now, item: awardedItem });
    }

    return {
      success: true,
      reward: {
        spark: boostedSpark,
        baseSpark: baseSpark,
        item: awardedItem,
        description: reward.description
      },
      streakBonus: streakBonus,
      newStreak: newStreak,
      message: 'Reward claimed!'
    };
  }

  // =========================================================================
  // HISTORY
  // =========================================================================

  /**
   * Returns recent claim history for a player.
   * @param {Object} playerData
   * @param {number} [limit=10] - Max records to return
   * @returns {Array} Most recent claims first
   */
  function getRewardHistory(playerData, limit) {
    ensureState(playerData);
    var history = playerData.dailyRewards.history;
    var n = (limit === undefined || limit === null) ? 10 : limit;
    var start = Math.max(0, history.length - n);
    return history.slice(start).reverse();
  }

  /**
   * Returns lifetime reward totals for a player.
   * @param {Object} playerData
   * @returns {Object} {totalSpark, totalItemCount, totalClaims, items}
   */
  function getLifetimeRewards(playerData) {
    ensureState(playerData);
    var dr = playerData.dailyRewards;
    return {
      totalSpark: dr.lifetimeSpark,
      totalItemCount: dr.lifetimeItems.length,
      totalClaims: dr.history.length,
      items: dr.lifetimeItems.slice()
    };
  }

  // =========================================================================
  // FORMATTING
  // =========================================================================

  /**
   * Formats a reward descriptor into a human-readable string.
   * @param {Object} reward - Reward descriptor or claim record
   * @returns {string}
   */
  function formatReward(reward) {
    var parts = [];
    if (reward.spark && reward.spark > 0) {
      parts.push(reward.spark + ' Spark');
    }
    if (reward.baseSpark && reward.baseSpark > 0 && reward.spark !== reward.baseSpark) {
      parts.push(reward.spark + ' Spark (x' + reward.streakMultiplier + ' streak bonus)');
      // Remove the plain spark entry added above
      parts.shift();
    }
    if (reward.item) {
      var itemStr = reward.item.id;
      if (reward.item.count && reward.item.count > 1) {
        itemStr = reward.item.count + 'x ' + reward.item.id;
      }
      parts.push(itemStr);
    }
    if (reward.description && parts.length === 0) {
      return reward.description;
    }
    return parts.length > 0 ? parts.join(' + ') : 'No reward';
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.REWARD_CALENDAR = REWARD_CALENDAR;
  exports.STREAK_BONUSES = STREAK_BONUSES;
  exports.GRACE_PERIOD_HOURS = GRACE_PERIOD_HOURS;

  exports.claimDailyReward = claimDailyReward;
  exports.getDailyReward = getDailyReward;
  exports.getStreak = getStreak;
  exports.getStreakBonus = getStreakBonus;
  exports.canClaim = canClaim;
  exports.getNextReward = getNextReward;
  exports.getRewardHistory = getRewardHistory;
  exports.calculateStreakReward = calculateStreakReward;
  exports.resetStreak = resetStreak;
  exports.getCalendarView = getCalendarView;
  exports.formatReward = formatReward;
  exports.getLifetimeRewards = getLifetimeRewards;

  // Expose helpers for testing
  exports._dayStart = dayStart;
  exports._daysDiff = daysDiff;

})(typeof module !== 'undefined' ? module.exports : (window.DailyRewards = {}));


// profiles.js
// profiles.js
/**
 * ZION Player Profile Cards
 * Aggregates data from quests, guilds, mentoring, pets, exploration, economy,
 * and social systems into rich profile cards for self-view and other-player view.
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // CONSTANTS
  // ============================================================================

  /**
   * XP thresholds for overall player level.
   * Each entry: { level, xpRequired, title }
   */
  var LEVEL_THRESHOLDS = [
    { level: 1,  xpRequired: 0,     title: 'Newcomer' },
    { level: 2,  xpRequired: 100,   title: 'Wanderer' },
    { level: 3,  xpRequired: 300,   title: 'Settler' },
    { level: 4,  xpRequired: 600,   title: 'Explorer' },
    { level: 5,  xpRequired: 1000,  title: 'Adventurer' },
    { level: 6,  xpRequired: 1500,  title: 'Pathfinder' },
    { level: 7,  xpRequired: 2200,  title: 'Veteran' },
    { level: 8,  xpRequired: 3000,  title: 'Champion' },
    { level: 9,  xpRequired: 4000,  title: 'Legend' },
    { level: 10, xpRequired: 5500,  title: 'Elder' },
    { level: 11, xpRequired: 7500,  title: 'Sage' },
    { level: 12, xpRequired: 10000, title: 'Archon' },
    { level: 13, xpRequired: 13000, title: 'Mythic' },
    { level: 14, xpRequired: 17000, title: 'Eternal' },
    { level: 15, xpRequired: 22000, title: 'Transcendent' }
  ];

  /**
   * Titles earned at various milestones.
   * { id, name, description, condition }
   */
  var TITLE_LIST = [
    { id: 'the_curious',       name: 'The Curious',       description: 'Asked a question in ZION',            condition: 'first_login' },
    { id: 'the_friendly',      name: 'The Friendly',      description: 'Spoke to 10 citizens',                 condition: 'talk_npcs_10' },
    { id: 'the_explorer',      name: 'The Explorer',      description: 'Visited all 8 zones',                  condition: 'zones_8' },
    { id: 'the_questmaster',   name: 'The Questmaster',   description: 'Completed 10 quests',                  condition: 'quests_10' },
    { id: 'the_completionist', name: 'The Completionist', description: 'Completed 25 quests',                  condition: 'quests_25' },
    { id: 'the_merchant',      name: 'The Merchant',      description: 'Completed 25 trades',                  condition: 'trades_25' },
    { id: 'the_magnate',       name: 'The Magnate',       description: 'Accumulated 2000 Spark',               condition: 'spark_2000' },
    { id: 'the_artisan',       name: 'The Artisan',       description: 'Crafted 50 items',                     condition: 'craft_50' },
    { id: 'the_builder',       name: 'The Builder',       description: 'Placed 50 structures',                 condition: 'build_50' },
    { id: 'the_cartographer',  name: 'The Cartographer',  description: 'Made 25 discoveries',                  condition: 'discoveries_25' },
    { id: 'the_scholar',       name: 'The Scholar',       description: 'Reached lore skill level 4',           condition: 'lore_level_4' },
    { id: 'the_champion',      name: 'The Champion',      description: 'Won 5 competitions',                   condition: 'wins_5' },
    { id: 'the_guild_founder', name: 'The Guild Founder', description: 'Founded a guild',                      condition: 'guild_founder' },
    { id: 'the_mentor',        name: 'The Mentor',        description: 'Taught another player a skill',        condition: 'taught_player' },
    { id: 'the_naturalist',    name: 'The Naturalist',    description: 'Adopted a pet companion',              condition: 'has_pet' },
    { id: 'the_elder',         name: 'The Elder',         description: 'Reached player level 10',              condition: 'level_10' },
    { id: 'the_transcendent',  name: 'The Transcendent',  description: 'Reached maximum player level',         condition: 'level_15' },
    { id: 'the_sunwalker',     name: 'The Sunwalker',     description: 'Achieved Sunwalker warmth tier',       condition: 'sunwalker' },
    { id: 'the_lorekeeper',    name: 'The Lorekeeper',    description: 'Unlocked 10 lore entries',             condition: 'lore_10' },
    { id: 'the_gardener',      name: 'The Gardener',      description: 'Harvested 100 plants',                 condition: 'harvest_100' }
  ];

  // Skill display metadata
  var SKILL_META = {
    gardening:   { icon: '[G]', color: '#4caf50' },
    crafting:    { icon: '[C]', color: '#ff9800' },
    building:    { icon: '[B]', color: '#2196f3' },
    exploration: { icon: '[E]', color: '#9c27b0' },
    trading:     { icon: '[T]', color: '#ffc107' },
    social:      { icon: '[S]', color: '#e91e63' },
    combat:      { icon: '[W]', color: '#f44336' },
    lore:        { icon: '[L]', color: '#00bcd4' }
  };

  // Maximum skill level (from Mentoring.SKILLS config)
  var MAX_SKILL_LEVEL = 4;

  // ============================================================================
  // PROFILE CREATION
  // ============================================================================

  /**
   * Build a profile object from raw game data.
   * @param {string} playerId
   * @param {object} data - { name, questData, guildData, mentoringData, petData,
   *                           discoveryData, ledger, reputationData, joinTime,
   *                           achievementData }
   * @returns {object} Fully populated profile
   */
  function createProfile(playerId, data) {
    if (!playerId) return null;
    data = data || {};

    var questStats  = getProfileStats_quests(data.questData);
    var guildInfo   = getGuildInfo(playerId, data.guildData);
    var skillSummary = getSkillSummary(playerId, data.mentoringData);
    var petInfo     = getPetInfo(playerId, data.petData);
    var exploration = getExplorationProgress(playerId, data.discoveryData);
    var sparkBalance = (data.ledger && data.ledger.balances)
      ? (data.ledger.balances[playerId] || 0)
      : (data.sparkBalance || 0);
    var reputation  = data.reputationData || { score: 0, tier: 'Newcomer' };
    var joinTime    = data.joinTime || 0;
    var playtime    = data.playTimeSeconds || 0;
    var achievements = data.achievementData || {};

    var badges  = getProfileBadges(playerId, achievements);
    var titles  = getProfileTitle(playerId, questStats);
    var level   = getProfileLevel({
      questStats: questStats,
      sparkBalance: sparkBalance,
      exploration: exploration,
      skillSummary: skillSummary
    });

    return {
      id: playerId,
      name: sanitizeText(data.name || playerId),
      level: level,
      levelTitle: getLevelTitle(level),
      sparkBalance: sparkBalance,
      reputation: {
        score: reputation.score || 0,
        tier: reputation.tier || 'Newcomer'
      },
      questStats: questStats,
      guildInfo: guildInfo,
      skillSummary: skillSummary,
      petInfo: petInfo,
      exploration: exploration,
      badges: badges,
      titles: titles,
      joinTime: joinTime,
      playTimeSeconds: playtime,
      createdAt: Date.now()
    };
  }

  // ============================================================================
  // STAT AGGREGATION
  // ============================================================================

  /**
   * Aggregate quest stats from quest data snapshot.
   * @param {object|null} questData - Result of Quests.getPlayerQuestStats()
   * @returns {object}
   */
  function getProfileStats_quests(questData) {
    if (!questData) {
      return {
        activeQuests: 0,
        completedQuests: 0,
        totalAvailable: 0,
        completedChains: 0,
        totalChains: 0,
        titles: []
      };
    }
    return {
      activeQuests:    questData.activeQuests    || 0,
      completedQuests: questData.completedQuests || 0,
      totalAvailable:  questData.totalAvailable  || 0,
      completedChains: questData.completedChains || 0,
      totalChains:     questData.totalChains     || 0,
      titles:          questData.titles          || []
    };
  }

  /**
   * Aggregate profile stats including quests, discoveries, spark, reputation,
   * and playtime.
   * @param {string} playerId
   * @param {object} gameData - { questData, discoveryData, ledger, reputationData,
   *                              playTimeSeconds, sparkBalance }
   * @returns {object}
   */
  function getProfileStats(playerId, gameData) {
    gameData = gameData || {};

    var questStats = getProfileStats_quests(gameData.questData);
    var discoveriesCount = 0;
    var zonesDiscovered = 0;
    if (gameData.discoveryData) {
      var discoveries = gameData.discoveryData.list || gameData.discoveryData || [];
      if (Array.isArray(discoveries)) {
        discoveriesCount = discoveries.filter(function(d) {
          return d.discoverer === playerId || d.player === playerId;
        }).length;
      }
      var zoneMap = {};
      if (Array.isArray(discoveries)) {
        discoveries.forEach(function(d) {
          if ((d.discoverer === playerId || d.player === playerId) && d.zone) {
            zoneMap[d.zone] = true;
          }
        });
      }
      zonesDiscovered = Object.keys(zoneMap).length;
    }

    var sparkBalance = 0;
    if (gameData.ledger && gameData.ledger.balances) {
      sparkBalance = gameData.ledger.balances[playerId] || 0;
    } else if (typeof gameData.sparkBalance === 'number') {
      sparkBalance = gameData.sparkBalance;
    }

    var reputationScore = 0;
    var reputationTier = 'Newcomer';
    if (gameData.reputationData) {
      reputationScore = gameData.reputationData.score || 0;
      reputationTier  = gameData.reputationData.tier  || 'Newcomer';
    }

    return {
      questsCompleted:  questStats.completedQuests,
      activeQuests:     questStats.activeQuests,
      chainsCompleted:  questStats.completedChains,
      discoveries:      discoveriesCount,
      zonesDiscovered:  zonesDiscovered,
      sparkBalance:     sparkBalance,
      reputationScore:  reputationScore,
      reputationTier:   reputationTier,
      playTimeSeconds:  gameData.playTimeSeconds || 0,
      playTimeFormatted: formatPlayTime(gameData.playTimeSeconds || 0)
    };
  }

  // ============================================================================
  // BADGES
  // ============================================================================

  /**
   * Get earned achievement badges with icon info.
   * @param {string} playerId
   * @param {object} achievements - Map of achievementId -> { earned, ts }
   * @returns {Array} Array of { id, name, description, icon, category, earnedAt }
   */
  function getProfileBadges(playerId, achievements) {
    if (!achievements) return [];

    var earned = [];
    for (var id in achievements) {
      var ach = achievements[id];
      if (ach && ach.earned) {
        earned.push({
          id: id,
          name:        ach.name        || id,
          description: ach.description || '',
          icon:        ach.icon        || '[*]',
          category:    ach.category    || 'misc',
          earnedAt:    ach.ts          || ach.earnedAt || 0
        });
      }
    }

    // Sort by earnedAt descending (most recent first)
    earned.sort(function(a, b) { return b.earnedAt - a.earnedAt; });
    return earned;
  }

  // ============================================================================
  // TITLES
  // ============================================================================

  /**
   * Determine earned titles for a player based on quest stats.
   * @param {string} playerId
   * @param {object} questStats - Result of getProfileStats_quests()
   * @returns {Array} Array of title strings
   */
  function getProfileTitle(playerId, questStats) {
    questStats = questStats || {};
    var titles = questStats.titles || [];

    // Built-in milestone titles from TITLE_LIST
    var completedQuests = questStats.completedQuests || 0;
    if (completedQuests >= 10 && titles.indexOf('The Questmaster') === -1) {
      titles = titles.concat(['The Questmaster']);
    }
    if (completedQuests >= 25 && titles.indexOf('The Completionist') === -1) {
      titles = titles.concat(['The Completionist']);
    }

    return titles;
  }

  // ============================================================================
  // SKILLS
  // ============================================================================

  /**
   * Summarise skill levels for display.
   * @param {string} playerId
   * @param {object|null} mentoringData - Result of Mentoring.getPlayerSkills(playerId)
   * @returns {object} Map of skillName -> { level, levelName, xp, xpToNext, icon }
   */
  function getSkillSummary(playerId, mentoringData) {
    var skillNames = ['gardening', 'crafting', 'building', 'exploration',
                      'trading', 'social', 'combat', 'lore'];
    var summary = {};

    skillNames.forEach(function(skill) {
      var raw = mentoringData && mentoringData[skill];
      var level     = raw ? (raw.level     || 0) : 0;
      var xp        = raw ? (raw.xp        || 0) : 0;
      var levelName = raw ? (raw.levelName || 'Novice') : 'Novice';

      // XP to next level â€” approximate from SKILLS config pattern
      var xpThresholds = [0, 100, 300, 600, 1000];
      var xpToNext = 0;
      if (level < xpThresholds.length - 1) {
        xpToNext = xpThresholds[level + 1] - xp;
        if (xpToNext < 0) xpToNext = 0;
      }

      var meta = SKILL_META[skill] || { icon: '[?]', color: '#888' };
      summary[skill] = {
        level:     level,
        levelName: levelName,
        xp:        xp,
        xpToNext:  xpToNext,
        maxLevel:  MAX_SKILL_LEVEL,
        icon:      meta.icon,
        color:     meta.color
      };
    });

    return summary;
  }

  // ============================================================================
  // GUILD INFO
  // ============================================================================

  /**
   * Get guild membership details for a player.
   * @param {string} playerId
   * @param {object|null} guildData - Result of Guilds.getPlayerGuild(playerId)
   * @returns {object} { inGuild, guildId, guildName, guildTag, role, memberCount, level }
   */
  function getGuildInfo(playerId, guildData) {
    if (!guildData) {
      return { inGuild: false, guildId: null, guildName: null, guildTag: null,
               role: null, memberCount: 0, level: 0 };
    }

    var member = null;
    if (Array.isArray(guildData.members)) {
      guildData.members.forEach(function(m) {
        if (m.playerId === playerId) member = m;
      });
    }

    return {
      inGuild:     true,
      guildId:     guildData.id     || null,
      guildName:   sanitizeText(guildData.name   || ''),
      guildTag:    sanitizeText(guildData.tag    || ''),
      guildType:   guildData.type   || 'guild',
      role:        member ? (member.role || 'member') : 'member',
      memberCount: Array.isArray(guildData.members) ? guildData.members.length : 0,
      level:       guildData.level  || 1
    };
  }

  // ============================================================================
  // PET INFO
  // ============================================================================

  /**
   * Get active pet companion details.
   * @param {string} playerId
   * @param {object|null} petData - Result of Pets.getPlayerPet(playerId)
   * @returns {object} { hasPet, name, type, icon, rarity, mood, bond }
   */
  function getPetInfo(playerId, petData) {
    if (!petData) {
      return { hasPet: false, name: null, type: null, icon: null,
               rarity: null, mood: 0, bond: 0 };
    }

    return {
      hasPet: true,
      petId:  petData.id   || null,
      name:   sanitizeText(petData.name || 'Unknown'),
      type:   petData.type || 'unknown',
      icon:   petData.icon || '[pet]',
      rarity: petData.rarity || 'common',
      mood:   typeof petData.mood === 'number' ? petData.mood : 100,
      bond:   typeof petData.bond === 'number' ? petData.bond : 0,
      bonus:  petData.bonus || null
    };
  }

  // ============================================================================
  // EXPLORATION PROGRESS
  // ============================================================================

  /**
   * Get exploration stats for a player.
   * @param {string} playerId
   * @param {object|null} discoveryData - { list: Array<discovery>, zonesDiscovered }
   *        OR a plain array of discovery objects
   * @returns {object} { zonesDiscovered, totalDiscoveries, secretsFound, loreUnlocked }
   */
  function getExplorationProgress(playerId, discoveryData) {
    var result = {
      zonesDiscovered: 0,
      totalDiscoveries: 0,
      secretsFound: 0,
      loreUnlocked: 0,
      discoveries: []
    };

    if (!discoveryData) return result;

    var list = Array.isArray(discoveryData) ? discoveryData
             : (discoveryData.list || discoveryData.discoveries || []);

    var zoneMap = {};
    var secretCount = 0;
    var loreCount = 0;

    list.forEach(function(d) {
      var isOwner = d.discoverer === playerId || d.player === playerId;
      if (!isOwner) return;

      result.totalDiscoveries++;
      if (d.zone) zoneMap[d.zone] = true;
      if (d.type === 'secret') secretCount++;
      if (d.type === 'lore')   loreCount++;
      result.discoveries.push({
        name:  d.name  || (d.type ? d.type.charAt(0).toUpperCase() + d.type.slice(1) : 'Discovery'),
        zone:  d.zone  || 'unknown',
        rarity: d.rarity || 'common',
        type:  d.type  || 'landmark'
      });
    });

    result.zonesDiscovered = Object.keys(zoneMap).length;
    result.secretsFound    = secretCount;
    result.loreUnlocked    = loreCount;

    return result;
  }

  // ============================================================================
  // PROFILE CARD FORMATTING
  // ============================================================================

  /**
   * Format a profile for HTML-safe text display.
   * Returns a plain-object suitable for template rendering.
   * @param {object} profile - Result of createProfile()
   * @returns {object}
   */
  function formatProfileCard(profile) {
    if (!profile) return null;

    var guildLabel = profile.guildInfo && profile.guildInfo.inGuild
      ? '[' + sanitizeText(profile.guildInfo.guildTag) + '] ' + sanitizeText(profile.guildInfo.guildName)
      : 'No Guild';

    var petLabel = profile.petInfo && profile.petInfo.hasPet
      ? profile.petInfo.icon + ' ' + sanitizeText(profile.petInfo.name)
        + ' (' + profile.petInfo.type + ')'
      : 'No Companion';

    var topBadges = (profile.badges || []).slice(0, 6);
    var badgeLabels = topBadges.map(function(b) {
      return b.icon + ' ' + sanitizeText(b.name);
    });

    var topSkills = [];
    if (profile.skillSummary) {
      for (var skillName in profile.skillSummary) {
        var s = profile.skillSummary[skillName];
        topSkills.push({
          name:      skillName.charAt(0).toUpperCase() + skillName.slice(1),
          level:     s.level,
          levelName: s.levelName,
          xp:        s.xp,
          xpToNext:  s.xpToNext,
          icon:      s.icon,
          color:     s.color
        });
      }
    }

    return {
      id:              sanitizeText(profile.id),
      name:            sanitizeText(profile.name),
      level:           profile.level,
      levelTitle:      sanitizeText(profile.levelTitle),
      sparkBalance:    profile.sparkBalance,
      reputationTier:  sanitizeText(profile.reputation ? profile.reputation.tier : 'Newcomer'),
      reputationScore: profile.reputation ? profile.reputation.score : 0,
      questsCompleted: profile.questStats ? profile.questStats.completedQuests : 0,
      chainsCompleted: profile.questStats ? profile.questStats.completedChains : 0,
      discoveries:     profile.exploration ? profile.exploration.totalDiscoveries : 0,
      zonesDiscovered: profile.exploration ? profile.exploration.zonesDiscovered : 0,
      secretsFound:    profile.exploration ? profile.exploration.secretsFound : 0,
      playTime:        formatPlayTime(profile.playTimeSeconds || 0),
      guildLabel:      guildLabel,
      petLabel:        petLabel,
      badgeLabels:     badgeLabels,
      skills:          topSkills,
      titles:          (profile.titles || []).map(sanitizeText)
    };
  }

  // ============================================================================
  // PROFILE COMPARISON
  // ============================================================================

  /**
   * Compare two profiles side-by-side.
   * @param {object} profileA - Result of createProfile()
   * @param {object} profileB - Result of createProfile()
   * @returns {object} Comparison data with winner per category
   */
  function compareProfiles(profileA, profileB) {
    if (!profileA || !profileB) return null;

    var sparkA = profileA.sparkBalance || 0;
    var sparkB = profileB.sparkBalance || 0;
    var questsA = (profileA.questStats || {}).completedQuests || 0;
    var questsB = (profileB.questStats || {}).completedQuests || 0;
    var discA = (profileA.exploration || {}).totalDiscoveries || 0;
    var discB = (profileB.exploration || {}).totalDiscoveries || 0;
    var repA = (profileA.reputation || {}).score || 0;
    var repB = (profileB.reputation || {}).score || 0;
    var levelA = profileA.level || 1;
    var levelB = profileB.level || 1;
    var badgesA = (profileA.badges || []).length;
    var badgesB = (profileB.badges || []).length;

    // Skill total level comparison
    var skillTotalA = sumSkillLevels(profileA.skillSummary);
    var skillTotalB = sumSkillLevels(profileB.skillSummary);

    return {
      players: [sanitizeText(profileA.name), sanitizeText(profileB.name)],
      categories: {
        level:      { values: [levelA,   levelB],  winner: levelA  > levelB  ? 0 : levelB  > levelA  ? 1 : -1 },
        spark:      { values: [sparkA,   sparkB],  winner: sparkA  > sparkB  ? 0 : sparkB  > sparkA  ? 1 : -1 },
        quests:     { values: [questsA,  questsB], winner: questsA > questsB ? 0 : questsB > questsA ? 1 : -1 },
        discoveries:{ values: [discA,    discB],   winner: discA   > discB   ? 0 : discB   > discA   ? 1 : -1 },
        reputation: { values: [repA,     repB],    winner: repA    > repB    ? 0 : repB    > repA    ? 1 : -1 },
        badges:     { values: [badgesA,  badgesB], winner: badgesA > badgesB ? 0 : badgesB > badgesA ? 1 : -1 },
        skills:     { values: [skillTotalA, skillTotalB], winner: skillTotalA > skillTotalB ? 0 : skillTotalB > skillTotalA ? 1 : -1 }
      }
    };
  }

  // ============================================================================
  // PLAYER LEVEL
  // ============================================================================

  /**
   * Calculate overall player level from combined stats.
   * @param {object} profile - Partial profile with questStats, sparkBalance,
   *                            exploration, skillSummary
   * @returns {number} Level 1â€“15
   */
  function getProfileLevel(profile) {
    profile = profile || {};

    var xp = 0;

    // Quests: 20 XP per completion, 50 XP per chain
    var questStats = profile.questStats || {};
    xp += (questStats.completedQuests || 0) * 20;
    xp += (questStats.completedChains || 0) * 50;

    // Spark: 1 XP per 10 spark (logarithmic cap)
    var spark = profile.sparkBalance || 0;
    xp += Math.floor(Math.min(spark, 5000) / 10);

    // Exploration: 10 XP per discovery, 30 per zone
    var exploration = profile.exploration || {};
    xp += (exploration.totalDiscoveries || 0) * 10;
    xp += (exploration.zonesDiscovered  || 0) * 30;

    // Skills: 15 XP per skill level above 0
    var skillSum = sumSkillLevels(profile.skillSummary);
    xp += skillSum * 15;

    // Find level from thresholds
    var level = 1;
    for (var i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
      if (xp >= LEVEL_THRESHOLDS[i].xpRequired) {
        level = LEVEL_THRESHOLDS[i].level;
        break;
      }
    }
    return level;
  }

  // ============================================================================
  // HUD PANEL INTEGRATION
  // ============================================================================

  /**
   * Show the enhanced player profile panel for the local player.
   * Designed to be called from hud.js or main.js.
   * @param {object} profile - Result of createProfile()
   * @param {HTMLElement|null} container - DOM container, defaults to document.body
   * @returns {HTMLElement} The panel element
   */
  function showPlayerProfilePanel(profile, container) {
    // Remove any existing panel
    var existing = document.getElementById('profiles-panel');
    if (existing && existing.parentNode) {
      existing.parentNode.removeChild(existing);
      return null; // toggle off
    }

    var formatted = formatProfileCard(profile);
    if (!formatted) return null;

    var panel = document.createElement('div');
    panel.id = 'profiles-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.92);border:2px solid #d4af37;border-radius:12px;' +
      'padding:0;width:720px;max-height:88vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 40px rgba(0,0,0,0.9);z-index:350;font-family:monospace;color:#fff;';

    // ---- Header ----
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;justify-content:space-between;align-items:center;' +
      'padding:18px 22px;background:rgba(212,175,55,0.12);border-bottom:1px solid #d4af37;';

    var titleEl = document.createElement('div');
    titleEl.style.cssText = 'font-size:20px;font-weight:bold;color:#d4af37;';
    titleEl.textContent = 'Player Profile';
    header.appendChild(titleEl);

    var closeBtn = document.createElement('div');
    closeBtn.textContent = 'X';
    closeBtn.style.cssText = 'cursor:pointer;font-size:20px;color:#888;padding:2px 10px;' +
      'border-radius:4px;';
    closeBtn.onmouseover = function() { this.style.color = '#d4af37'; };
    closeBtn.onmouseout  = function() { this.style.color = '#888'; };
    closeBtn.onclick = function() {
      if (panel.parentNode) panel.parentNode.removeChild(panel);
    };
    header.appendChild(closeBtn);
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:22px;';

    // ---- Avatar + Identity ----
    var identity = _buildIdentitySection(formatted);
    body.appendChild(identity);

    // ---- Stats Grid ----
    var statsSection = _buildStatsSection(formatted);
    body.appendChild(statsSection);

    // ---- Guild ----
    var guildSection = _buildGuildSection(formatted);
    body.appendChild(guildSection);

    // ---- Pet ----
    var petSection = _buildPetSection(formatted);
    body.appendChild(petSection);

    // ---- Achievement Badges ----
    if (profile.badges && profile.badges.length > 0) {
      var badgeSection = _buildBadgeSection(profile.badges);
      body.appendChild(badgeSection);
    }

    // ---- Skills ----
    var skillSection = _buildSkillSection(formatted.skills, profile.skillSummary);
    body.appendChild(skillSection);

    // ---- Titles ----
    if (formatted.titles && formatted.titles.length > 0) {
      var titleSection = _buildTitleSection(formatted.titles);
      body.appendChild(titleSection);
    }

    panel.appendChild(body);
    var root = container || document.body;
    root.appendChild(panel);
    return panel;
  }

  // ============================================================================
  // INTERNAL PANEL BUILDERS
  // ============================================================================

  function _buildIdentitySection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'display:flex;align-items:center;gap:20px;margin-bottom:22px;' +
      'padding-bottom:18px;border-bottom:1px solid rgba(212,175,55,0.3);';

    // Avatar circle
    var avatar = document.createElement('div');
    var initial = (fmt.name || 'P').charAt(0).toUpperCase();
    avatar.textContent = initial;
    avatar.style.cssText = 'width:76px;height:76px;border-radius:50%;background:#d4af37;' +
      'display:flex;align-items:center;justify-content:center;font-size:34px;font-weight:bold;' +
      'color:#000;flex-shrink:0;border:2px solid rgba(212,175,55,0.6);';

    var details = document.createElement('div');
    details.style.cssText = 'flex:1;';

    var nameEl = document.createElement('div');
    nameEl.textContent = fmt.name;
    nameEl.style.cssText = 'font-size:22px;font-weight:bold;color:#fff;margin-bottom:4px;';

    var levelEl = document.createElement('div');
    levelEl.textContent = 'Level ' + fmt.level + ' â€” ' + fmt.levelTitle;
    levelEl.style.cssText = 'font-size:13px;color:#d4af37;margin-bottom:4px;';

    var repEl = document.createElement('div');
    repEl.textContent = fmt.reputationTier + ' (rep: ' + fmt.reputationScore + ')';
    repEl.style.cssText = 'font-size:12px;color:#aaa;margin-bottom:6px;';

    var sparkEl = document.createElement('div');
    sparkEl.innerHTML = '<span style="color:#d4af37;">[S]</span> ' + fmt.sparkBalance + ' Spark';
    sparkEl.style.cssText = 'font-size:15px;color:#fff;font-weight:bold;';

    details.appendChild(nameEl);
    details.appendChild(levelEl);
    details.appendChild(repEl);
    details.appendChild(sparkEl);

    section.appendChild(avatar);
    section.appendChild(details);
    return section;
  }

  function _buildStatsSection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:20px;';

    var title = document.createElement('div');
    title.textContent = 'Stats';
    title.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:10px;';
    section.appendChild(title);

    var grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:repeat(3,1fr);gap:10px;';

    var statItems = [
      { label: 'Quests Done',    value: fmt.questsCompleted },
      { label: 'Chains Done',    value: fmt.chainsCompleted },
      { label: 'Discoveries',    value: fmt.discoveries },
      { label: 'Zones Explored', value: fmt.zonesDiscovered },
      { label: 'Secrets Found',  value: fmt.secretsFound },
      { label: 'Time Played',    value: fmt.playTime }
    ];

    statItems.forEach(function(s) {
      var item = document.createElement('div');
      item.style.cssText = 'background:rgba(255,255,255,0.05);border-radius:6px;padding:10px 12px;' +
        'border:1px solid rgba(212,175,55,0.15);';

      var lbl = document.createElement('div');
      lbl.textContent = s.label;
      lbl.style.cssText = 'font-size:10px;color:#888;margin-bottom:4px;text-transform:uppercase;';

      var val = document.createElement('div');
      val.textContent = s.value;
      val.style.cssText = 'font-size:17px;color:#fff;font-weight:bold;';

      item.appendChild(lbl);
      item.appendChild(val);
      grid.appendChild(item);
    });

    section.appendChild(grid);
    return section;
  }

  function _buildGuildSection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;padding:12px 14px;background:rgba(212,175,55,0.05);' +
      'border-radius:8px;border:1px solid rgba(212,175,55,0.2);display:flex;align-items:center;gap:12px;';

    var icon = document.createElement('div');
    icon.textContent = '[H]';
    icon.style.cssText = 'font-size:22px;flex-shrink:0;color:#d4af37;';

    var info = document.createElement('div');
    var nameEl = document.createElement('div');
    nameEl.textContent = 'Guild: ' + fmt.guildLabel;
    nameEl.style.cssText = 'font-size:14px;color:#fff;font-weight:bold;';
    info.appendChild(nameEl);

    section.appendChild(icon);
    section.appendChild(info);
    return section;
  }

  function _buildPetSection(fmt) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;padding:12px 14px;background:rgba(100,200,100,0.05);' +
      'border-radius:8px;border:1px solid rgba(100,200,100,0.2);display:flex;align-items:center;gap:12px;';

    var icon = document.createElement('div');
    icon.textContent = '[P]';
    icon.style.cssText = 'font-size:22px;flex-shrink:0;color:#4caf50;';

    var info = document.createElement('div');
    var nameEl = document.createElement('div');
    nameEl.textContent = 'Companion: ' + fmt.petLabel;
    nameEl.style.cssText = 'font-size:14px;color:#fff;font-weight:bold;';
    info.appendChild(nameEl);

    section.appendChild(icon);
    section.appendChild(info);
    return section;
  }

  function _buildBadgeSection(badges) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;';

    var title = document.createElement('div');
    title.textContent = 'Achievements';
    title.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:10px;';
    section.appendChild(title);

    var row = document.createElement('div');
    row.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;';

    badges.slice(0, 12).forEach(function(badge) {
      var chip = document.createElement('div');
      chip.title = badge.description;
      chip.style.cssText = 'padding:5px 10px;background:rgba(212,175,55,0.1);border:1px solid rgba(212,175,55,0.4);' +
        'border-radius:20px;font-size:12px;color:#d4af37;cursor:default;';
      chip.textContent = badge.icon + ' ' + badge.name;
      row.appendChild(chip);
    });

    section.appendChild(row);
    return section;
  }

  function _buildSkillSection(skills, skillSummary) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:18px;';

    var title = document.createElement('div');
    title.textContent = 'Skills';
    title.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:10px;';
    section.appendChild(title);

    var grid = document.createElement('div');
    grid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:10px;';

    skills.forEach(function(skill) {
      var row = document.createElement('div');
      row.style.cssText = 'padding:8px;';

      var header = document.createElement('div');
      header.style.cssText = 'display:flex;justify-content:space-between;margin-bottom:4px;';

      var lbl = document.createElement('div');
      lbl.textContent = skill.icon + ' ' + skill.name;
      lbl.style.cssText = 'font-size:13px;color:#fff;font-weight:600;';

      var lvl = document.createElement('div');
      lvl.textContent = skill.levelName + ' (Lv.' + skill.level + ')';
      lvl.style.cssText = 'font-size:11px;color:#d4af37;';

      header.appendChild(lbl);
      header.appendChild(lvl);
      row.appendChild(header);

      // Progress bar
      var barWrap = document.createElement('div');
      barWrap.style.cssText = 'height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;';

      var xpTotal = skill.xp + skill.xpToNext;
      var pct = xpTotal > 0 ? Math.min(100, (skill.xp / xpTotal) * 100) : 0;
      if (skill.level >= (skill.maxLevel || 4)) pct = 100;

      var fill = document.createElement('div');
      fill.style.cssText = 'height:100%;background:' + (skill.color || '#d4af37') + ';' +
        'border-radius:4px;width:' + pct.toFixed(1) + '%;';
      barWrap.appendChild(fill);
      row.appendChild(barWrap);

      grid.appendChild(row);
    });

    section.appendChild(grid);
    return section;
  }

  function _buildTitleSection(titles) {
    var section = document.createElement('div');
    section.style.cssText = 'margin-bottom:10px;';

    var titleEl = document.createElement('div');
    titleEl.textContent = 'Titles';
    titleEl.style.cssText = 'font-size:16px;font-weight:bold;color:#d4af37;margin-bottom:8px;';
    section.appendChild(titleEl);

    var row = document.createElement('div');
    row.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;';

    titles.forEach(function(t) {
      var chip = document.createElement('div');
      chip.style.cssText = 'padding:4px 10px;background:rgba(255,255,255,0.08);' +
        'border:1px solid rgba(255,255,255,0.2);border-radius:4px;font-size:12px;color:#eee;';
      chip.textContent = t;
      row.appendChild(chip);
    });

    section.appendChild(row);
    return section;
  }

  // ============================================================================
  // UTILITY HELPERS
  // ============================================================================

  /**
   * Sum all skill levels for a skillSummary object.
   * @param {object|null} skillSummary
   * @returns {number}
   */
  function sumSkillLevels(skillSummary) {
    if (!skillSummary) return 0;
    var total = 0;
    for (var k in skillSummary) {
      total += (skillSummary[k].level || 0);
    }
    return total;
  }

  /**
   * Get title string for a given level number.
   * @param {number} level
   * @returns {string}
   */
  function getLevelTitle(level) {
    for (var i = 0; i < LEVEL_THRESHOLDS.length; i++) {
      if (LEVEL_THRESHOLDS[i].level === level) {
        return LEVEL_THRESHOLDS[i].title;
      }
    }
    return 'Newcomer';
  }

  /**
   * Format seconds into human-readable string.
   * @param {number} seconds
   * @returns {string}
   */
  function formatPlayTime(seconds) {
    seconds = Math.floor(seconds || 0);
    if (seconds < 60) return seconds + 's';
    var m = Math.floor(seconds / 60);
    if (m < 60) return m + 'm';
    var h = Math.floor(m / 60);
    var rem = m % 60;
    return h + 'h ' + rem + 'm';
  }

  /**
   * Sanitize text for HTML-safe display (strips HTML tags).
   * @param {string} text
   * @returns {string}
   */
  function sanitizeText(text) {
    if (typeof text !== 'string') return String(text || '');
    return text.replace(/[<>&"']/g, function(c) {
      return { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;' }[c];
    });
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.LEVEL_THRESHOLDS      = LEVEL_THRESHOLDS;
  exports.TITLE_LIST            = TITLE_LIST;
  exports.SKILL_META            = SKILL_META;
  exports.createProfile         = createProfile;
  exports.getProfileStats       = getProfileStats;
  exports.getProfileBadges      = getProfileBadges;
  exports.getProfileTitle       = getProfileTitle;
  exports.getSkillSummary       = getSkillSummary;
  exports.getGuildInfo          = getGuildInfo;
  exports.getPetInfo            = getPetInfo;
  exports.getExplorationProgress = getExplorationProgress;
  exports.formatProfileCard     = formatProfileCard;
  exports.compareProfiles       = compareProfiles;
  exports.getProfileLevel       = getProfileLevel;
  exports.showPlayerProfilePanel = showPlayerProfilePanel;
  exports.formatPlayTime        = formatPlayTime;
  exports.sanitizeText          = sanitizeText;
  exports.sumSkillLevels        = sumSkillLevels;
  exports.getLevelTitle         = getLevelTitle;

})(typeof module !== 'undefined' ? module.exports : (window.Profiles = {}));


// models.js
/**
 * ZION MMO - Procedural 3D Model Generators
 * Creates complex Three.js meshes from primitive geometries
 * Compatible with Three.js r128
 */

(function(exports) {
  'use strict';

  // ========================================
  // TREE GENERATORS
  // ========================================

  function createTree(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'tree_' + type;
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.05;
    group.userData.swaySpeed = 1.0;

    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
    const darkTrunk = new THREE.MeshLambertMaterial({ color: 0x3a2718 });

    switch(type) {
      case 'oak':
        // Thick trunk with visible roots
        const oakTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 3 * scale, 8),
          trunkMaterial
        );
        oakTrunk.position.y = 1.5 * scale;
        group.add(oakTrunk);

        // Roots at base
        for (let i = 0; i < 4; i++) {
          const root = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1 * scale, 0.15 * scale, 0.5 * scale, 6),
            darkTrunk
          );
          root.position.y = 0.1 * scale;
          const angle = (i / 4) * Math.PI * 2;
          root.position.x = Math.cos(angle) * 0.3 * scale;
          root.position.z = Math.sin(angle) * 0.3 * scale;
          root.rotation.z = Math.PI / 6;
          root.rotation.y = angle;
          group.add(root);
        }

        // Large overlapping spherical canopy
        const canopyColors = [0x2d5016, 0x3a6b1f, 0x4a8028];
        for (let i = 0; i < 8; i++) {
          const leafBall = new THREE.Mesh(
            new THREE.SphereGeometry(0.8 * scale, 8, 6),
            new THREE.MeshLambertMaterial({
              color: canopyColors[Math.floor(Math.random() * canopyColors.length)]
            })
          );
          const angle = (i / 8) * Math.PI * 2;
          const radius = 0.6 * scale;
          leafBall.position.x = Math.cos(angle) * radius;
          leafBall.position.z = Math.sin(angle) * radius;
          leafBall.position.y = 3 * scale + Math.random() * 0.4 * scale;
          group.add(leafBall);
        }

        // Central canopy sphere
        const centerCanopy = new THREE.Mesh(
          new THREE.SphereGeometry(1 * scale, 8, 6),
          new THREE.MeshLambertMaterial({ color: 0x3a6b1f })
        );
        centerCanopy.position.y = 3.2 * scale;
        group.add(centerCanopy);
        break;

      case 'pine':
        // Tall narrow trunk
        const pineTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 4 * scale, 8),
          trunkMaterial
        );
        pineTrunk.position.y = 2 * scale;
        group.add(pineTrunk);

        // Stacked cone layers
        const pineMaterial = new THREE.MeshLambertMaterial({ color: 0x1a4d2e });
        const coneSizes = [1.2, 1.0, 0.8, 0.6];
        for (let i = 0; i < coneSizes.length; i++) {
          const cone = new THREE.Mesh(
            new THREE.ConeGeometry(coneSizes[i] * scale, 1.5 * scale, 8),
            pineMaterial
          );
          cone.position.y = (2 + i * 1.2) * scale;
          group.add(cone);
        }

        // Top point
        const top = new THREE.Mesh(
          new THREE.ConeGeometry(0.3 * scale, 0.8 * scale, 6),
          pineMaterial
        );
        top.position.y = 6.5 * scale;
        group.add(top);
        break;

      case 'willow':
        // Medium trunk
        const willowTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, 2.5 * scale, 8),
          trunkMaterial
        );
        willowTrunk.position.y = 1.25 * scale;
        group.add(willowTrunk);

        // Drooping branches
        const willowGreen = new THREE.MeshLambertMaterial({ color: 0x90ee90 });
        const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x5a4a38 });

        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const branchLength = 1.5 * scale;

          // Drooping branch
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03 * scale, 0.02 * scale, branchLength, 4),
            branchMaterial
          );
          branch.position.x = Math.cos(angle) * 0.2 * scale;
          branch.position.z = Math.sin(angle) * 0.2 * scale;
          branch.position.y = 2.5 * scale - branchLength / 2;
          branch.rotation.z = Math.PI / 4;
          branch.rotation.y = angle;
          group.add(branch);

          // Leaves along branch
          for (let j = 0; j < 3; j++) {
            const leaf = new THREE.Mesh(
              new THREE.SphereGeometry(0.15 * scale, 6, 4),
              willowGreen
            );
            leaf.position.x = Math.cos(angle) * (0.3 + j * 0.3) * scale;
            leaf.position.z = Math.sin(angle) * (0.3 + j * 0.3) * scale;
            leaf.position.y = (2.2 - j * 0.4) * scale;
            group.add(leaf);
          }
        }
        break;

      case 'cherry':
        // Medium trunk
        const cherryTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2.5 * scale, 8),
          trunkMaterial
        );
        cherryTrunk.position.y = 1.25 * scale;
        group.add(cherryTrunk);

        // Pink/white blossom clusters
        const blossomColors = [0xffb7c5, 0xffc0cb, 0xffd1dc, 0xffffff];
        for (let i = 0; i < 20; i++) {
          const blossom = new THREE.Mesh(
            new THREE.SphereGeometry(0.2 * scale, 6, 4),
            new THREE.MeshLambertMaterial({
              color: blossomColors[Math.floor(Math.random() * blossomColors.length)]
            })
          );
          const angle = Math.random() * Math.PI * 2;
          const radius = 0.4 + Math.random() * 0.6;
          blossom.position.x = Math.cos(angle) * radius * scale;
          blossom.position.z = Math.sin(angle) * radius * scale;
          blossom.position.y = (2 + Math.random() * 1) * scale;
          group.add(blossom);
        }
        break;

      case 'dead':
        // Grey trunk
        const deadTrunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25 * scale, 0.35 * scale, 3 * scale, 8),
          new THREE.MeshLambertMaterial({ color: 0x666666 })
        );
        deadTrunk.position.y = 1.5 * scale;
        group.add(deadTrunk);

        // Bare branches
        const deadBranchMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
        for (let i = 0; i < 6; i++) {
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05 * scale, 0.02 * scale, 1 * scale, 4),
            deadBranchMat
          );
          const angle = (i / 6) * Math.PI * 2;
          branch.position.y = (2 + Math.random() * 0.5) * scale;
          branch.rotation.z = Math.PI / 3 + Math.random() * 0.3;
          branch.rotation.y = angle;
          group.add(branch);
        }

        group.userData.animationType = 'none';
        break;
    }

    return group;
  }

  // ========================================
  // ROCK GENERATORS
  // ========================================

  function createRock(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'rock_' + type;

    switch(type) {
      case 'boulder':
        const boulderGeo = new THREE.DodecahedronGeometry(1 * scale, 0);
        const boulderMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        // Randomize vertices for irregular shape
        const vertices = boulderGeo.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
          vertices[i] += (Math.random() - 0.5) * 0.2 * scale;
          vertices[i + 1] += (Math.random() - 0.5) * 0.2 * scale;
          vertices[i + 2] += (Math.random() - 0.5) * 0.2 * scale;
        }
        boulderGeo.attributes.position.needsUpdate = true;
        boulderGeo.computeVertexNormals();

        const boulder = new THREE.Mesh(boulderGeo, boulderMat);
        boulder.position.y = 0.8 * scale;
        group.add(boulder);
        break;

      case 'crystal':
        group.userData.animationType = 'bob';
        group.userData.bobSpeed = 1.5;
        group.userData.bobAmount = 0.2;

        const crystalColors = [0x9966ff, 0x6699ff, 0x00ccff];
        const angles = [0, Math.PI * 2 / 3, Math.PI * 4 / 3];

        for (let i = 0; i < 3; i++) {
          const crystalMat = new THREE.MeshLambertMaterial({
            color: crystalColors[i],
            emissive: crystalColors[i],
            emissiveIntensity: 0.3
          });

          const crystal = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.4 * scale, 0),
            crystalMat
          );

          crystal.position.x = Math.cos(angles[i]) * 0.3 * scale;
          crystal.position.z = Math.sin(angles[i]) * 0.3 * scale;
          crystal.position.y = (0.8 + i * 0.2) * scale;
          crystal.rotation.y = angles[i];
          crystal.scale.y = 1.5 + Math.random() * 0.5;
          group.add(crystal);
        }
        break;

      case 'ruins':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0xb8a890 });
        const ruinPieces = [
          { w: 1.5, h: 0.4, d: 0.8, x: 0, y: 0.2, z: 0, rx: 0, ry: 0, rz: 0.1 },
          { w: 1.0, h: 0.5, d: 0.6, x: 0.5, y: 0.5, z: 0.3, rx: 0.2, ry: 0.3, rz: -0.15 },
          { w: 0.8, h: 0.6, d: 0.5, x: -0.4, y: 0.6, z: -0.2, rx: -0.15, ry: -0.2, rz: 0.1 },
          { w: 0.6, h: 0.3, d: 0.4, x: 0.2, y: 1.0, z: -0.4, rx: 0.3, ry: 0.1, rz: 0.2 }
        ];

        ruinPieces.forEach(piece => {
          const stone = new THREE.Mesh(
            new THREE.BoxGeometry(piece.w * scale, piece.h * scale, piece.d * scale),
            stoneMat
          );
          stone.position.set(piece.x * scale, piece.y * scale, piece.z * scale);
          stone.rotation.set(piece.rx, piece.ry, piece.rz);
          group.add(stone);
        });
        break;
    }

    return group;
  }

  // ========================================
  // BUILDING GENERATORS
  // ========================================

  function createBuilding(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'building_' + type;

    switch(type) {
      case 'house':
        const wallMat = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
        const roofMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const doorMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const windowMat = new THREE.MeshLambertMaterial({
          color: 0xffffaa,
          emissive: 0xffff88,
          emissiveIntensity: 0.5
        });

        // Base
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(3 * scale, 2 * scale, 3 * scale),
          wallMat
        );
        base.position.y = 1 * scale;
        group.add(base);

        // Roof (A-frame)
        const roof1 = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5 * scale, 2 * scale),
          roofMat
        );
        roof1.position.y = 2.5 * scale;
        roof1.position.z = -0.5 * scale;
        roof1.rotation.x = -Math.PI / 4;
        group.add(roof1);

        const roof2 = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5 * scale, 2 * scale),
          roofMat
        );
        roof2.position.y = 2.5 * scale;
        roof2.position.z = 0.5 * scale;
        roof2.rotation.x = Math.PI / 4;
        group.add(roof2);

        // Door
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.6 * scale, 1.2 * scale, 0.1 * scale),
          doorMat
        );
        door.position.y = 0.6 * scale;
        door.position.z = 1.55 * scale;
        group.add(door);

        // Windows
        const windowPositions = [
          { x: -0.8, y: 1.2, z: 1.55 },
          { x: 0.8, y: 1.2, z: 1.55 }
        ];
        windowPositions.forEach(pos => {
          const window = new THREE.Mesh(
            new THREE.BoxGeometry(0.4 * scale, 0.4 * scale, 0.1 * scale),
            windowMat
          );
          window.position.set(pos.x * scale, pos.y * scale, pos.z * scale);
          group.add(window);
        });
        break;

      case 'tower':
        const towerMat = new THREE.MeshLambertMaterial({ color: 0x9a9a9a });
        const crenMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        // Main tower
        const tower = new THREE.Mesh(
          new THREE.CylinderGeometry(1 * scale, 1.2 * scale, 6 * scale, 12),
          towerMat
        );
        tower.position.y = 3 * scale;
        group.add(tower);

        // Crenellations (battlements)
        for (let i = 0; i < 8; i++) {
          const cren = new THREE.Mesh(
            new THREE.BoxGeometry(0.3 * scale, 0.5 * scale, 0.3 * scale),
            crenMat
          );
          const angle = (i / 8) * Math.PI * 2;
          cren.position.x = Math.cos(angle) * 1 * scale;
          cren.position.z = Math.sin(angle) * 1 * scale;
          cren.position.y = 6.25 * scale;
          group.add(cren);
        }

        // Window slits
        const slitMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const slit = new THREE.Mesh(
            new THREE.BoxGeometry(0.1 * scale, 0.6 * scale, 0.2 * scale),
            slitMat
          );
          slit.position.x = Math.cos(angle) * 1.15 * scale;
          slit.position.z = Math.sin(angle) * 1.15 * scale;
          slit.position.y = 4 * scale;
          group.add(slit);
        }
        break;

      case 'market_stall':
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
        const fabricMat = new THREE.MeshLambertMaterial({ color: 0xff6b35 });
        const counterMat = new THREE.MeshLambertMaterial({ color: 0xa0826d });

        // Four corner poles
        const polePositions = [
          { x: -1, z: -1 }, { x: 1, z: -1 },
          { x: -1, z: 1 }, { x: 1, z: 1 }
        ];
        polePositions.forEach(pos => {
          const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08 * scale, 0.08 * scale, 2.5 * scale, 6),
            poleMat
          );
          pole.position.set(pos.x * scale, 1.25 * scale, pos.z * scale);
          group.add(pole);
        });

        // Fabric roof
        const roof = new THREE.Mesh(
          new THREE.PlaneGeometry(2.5 * scale, 2.5 * scale),
          fabricMat
        );
        roof.position.y = 2.5 * scale;
        roof.rotation.x = -Math.PI / 2;
        group.add(roof);

        // Counter
        const counter = new THREE.Mesh(
          new THREE.BoxGeometry(2 * scale, 0.1 * scale, 1 * scale),
          counterMat
        );
        counter.position.y = 1 * scale;
        counter.position.z = 0.5 * scale;
        group.add(counter);
        break;

      case 'temple':
        const templeMat = new THREE.MeshLambertMaterial({ color: 0xe8dcc4 });
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0xd4c5a9 });

        // Base platform with steps
        for (let i = 0; i < 3; i++) {
          const step = new THREE.Mesh(
            new THREE.BoxGeometry((4 - i * 0.3) * scale, 0.3 * scale, (3 - i * 0.3) * scale),
            templeMat
          );
          step.position.y = i * 0.3 * scale;
          group.add(step);
        }

        // Main building
        const main = new THREE.Mesh(
          new THREE.BoxGeometry(3 * scale, 2 * scale, 2 * scale),
          templeMat
        );
        main.position.y = 1.9 * scale;
        group.add(main);

        // Six pillars
        const pillarXPos = [-1.2, -0.4, 0.4, 1.2];
        pillarXPos.forEach(x => {
          const pillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15 * scale, 0.15 * scale, 2 * scale, 8),
            pillarMat
          );
          pillar.position.set(x * scale, 1.9 * scale, 1.2 * scale);
          group.add(pillar);
        });

        // Triangular pediment
        const pediment = new THREE.Mesh(
          new THREE.ConeGeometry(1.8 * scale, 0.8 * scale, 3),
          templeMat
        );
        pediment.position.y = 3.3 * scale;
        pediment.position.z = 1.2 * scale;
        pediment.rotation.z = -Math.PI / 2;
        pediment.rotation.y = Math.PI / 2;
        group.add(pediment);
        break;
    }

    return group;
  }

  // ========================================
  // FURNITURE GENERATORS
  // ========================================

  function createFurniture(type) {
    const group = new THREE.Group();
    group.name = 'furniture_' + type;

    switch(type) {
      case 'bench':
        const benchMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Seat
        const seat = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.1, 0.4),
          benchMat
        );
        seat.position.y = 0.5;
        group.add(seat);

        // Legs
        const leg1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          benchMat
        );
        leg1.position.set(-0.6, 0.25, 0);
        group.add(leg1);

        const leg2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.1),
          benchMat
        );
        leg2.position.set(0.6, 0.25, 0);
        group.add(leg2);
        break;

      case 'lantern':
        const poleMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const lightMat = new THREE.MeshLambertMaterial({
          color: 0xffff88,
          emissive: 0xffff00,
          emissiveIntensity: 0.8
        });

        // Pole
        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 2, 6),
          poleMat
        );
        pole.position.y = 1;
        group.add(pole);

        // Glowing lantern box
        const lantern = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.3),
          lightMat
        );
        lantern.position.y = 2.2;
        group.add(lantern);

        // Add point light
        const light = new THREE.PointLight(0xffff88, 1, 10);
        light.position.y = 2.2;
        group.add(light);
        break;

      case 'well':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Stone cylinder
        const wellBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.8, 0.8, 1, 12),
          stoneMat
        );
        wellBase.position.y = 0.5;
        group.add(wellBase);

        // Wooden frame posts
        const post1 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6),
          woodMat
        );
        post1.position.set(-0.6, 1.25, 0);
        group.add(post1);

        const post2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6),
          woodMat
        );
        post2.position.set(0.6, 1.25, 0);
        group.add(post2);

        // Crossbar with rope cylinder
        const crossbar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 1.4, 6),
          woodMat
        );
        crossbar.position.y = 2;
        crossbar.rotation.z = Math.PI / 2;
        group.add(crossbar);

        // Bucket
        const bucket = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.12, 0.2, 8),
          woodMat
        );
        bucket.position.set(0, 1.5, 0.5);
        group.add(bucket);
        break;

      case 'bridge':
        const plankMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
        const railMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

        // Arched planks
        const numPlanks = 8;
        for (let i = 0; i < numPlanks; i++) {
          const plank = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.1, 0.4),
            plankMat
          );
          const t = (i / (numPlanks - 1)) * Math.PI;
          plank.position.x = (i - numPlanks / 2) * 0.5;
          plank.position.y = Math.sin(t) * 0.3;
          plank.rotation.z = Math.cos(t) * 0.2;
          group.add(plank);
        }

        // Side rails
        for (let side = -1; side <= 1; side += 2) {
          for (let i = 0; i < numPlanks; i++) {
            const rail = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.5, 4),
              railMat
            );
            const t = (i / (numPlanks - 1)) * Math.PI;
            rail.position.x = (i - numPlanks / 2) * 0.5;
            rail.position.y = Math.sin(t) * 0.3 + 0.25;
            rail.position.z = side * 0.35;
            group.add(rail);
          }
        }
        break;

      case 'fence':
        const fenceMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Vertical posts
        for (let i = 0; i < 5; i++) {
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1, 0.1),
            fenceMat
          );
          post.position.x = (i - 2) * 0.5;
          post.position.y = 0.5;
          group.add(post);
        }

        // Horizontal rails
        for (let i = 0; i < 2; i++) {
          const rail = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.08, 0.08),
            fenceMat
          );
          rail.position.y = 0.3 + i * 0.4;
          group.add(rail);
        }
        break;
    }

    return group;
  }

  // ========================================
  // CREATURE GENERATORS
  // ========================================

  function createCreature(type) {
    const group = new THREE.Group();
    group.name = 'creature_' + type;

    switch(type) {
      case 'butterfly':
        group.userData.animationType = 'flap';
        group.userData.flapSpeed = 8;
        group.userData.flapAmount = Math.PI / 4;

        const bodyMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const wingMat = new THREE.MeshLambertMaterial({ color: 0xff6b9d });

        // Body
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6),
          bodyMat
        );
        body.rotation.z = Math.PI / 2;
        group.add(body);

        // Wings (will rotate for flapping)
        const leftWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.3, 0.4),
          wingMat
        );
        leftWing.position.z = 0.2;
        leftWing.name = 'leftWing';
        group.add(leftWing);

        const rightWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.3, 0.4),
          wingMat
        );
        rightWing.position.z = -0.2;
        rightWing.name = 'rightWing';
        group.add(rightWing);
        break;

      case 'bird':
        group.userData.animationType = 'bob';
        group.userData.bobSpeed = 2;
        group.userData.bobAmount = 0.3;

        const birdBodyMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const birdWingMat = new THREE.MeshLambertMaterial({ color: 0x654321 });

        // Body (cone)
        const birdBody = new THREE.Mesh(
          new THREE.ConeGeometry(0.15, 0.4, 8),
          birdBodyMat
        );
        birdBody.rotation.z = -Math.PI / 2;
        group.add(birdBody);

        // Wings
        const leftBirdWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          birdWingMat
        );
        leftBirdWing.position.z = 0.15;
        leftBirdWing.rotation.x = Math.PI / 6;
        leftBirdWing.name = 'leftWing';
        group.add(leftBirdWing);

        const rightBirdWing = new THREE.Mesh(
          new THREE.PlaneGeometry(0.4, 0.2),
          birdWingMat
        );
        rightBirdWing.position.z = -0.15;
        rightBirdWing.rotation.x = -Math.PI / 6;
        rightBirdWing.name = 'rightWing';
        group.add(rightBirdWing);
        break;

      case 'fish':
        group.userData.animationType = 'swim';
        group.userData.swimSpeed = 1;
        group.userData.swimRadius = 2;
        group.userData.swimAngle = 0;

        const fishBodyMat = new THREE.MeshLambertMaterial({ color: 0xff8c00 });
        const fishTailMat = new THREE.MeshLambertMaterial({ color: 0xff6347 });

        // Elongated body
        const fishBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 8, 6),
          fishBodyMat
        );
        fishBody.scale.x = 2;
        group.add(fishBody);

        // Triangle tail
        const tailGeo = new THREE.ConeGeometry(0.15, 0.3, 3);
        const tail = new THREE.Mesh(tailGeo, fishTailMat);
        tail.rotation.z = Math.PI / 2;
        tail.position.x = -0.4;
        group.add(tail);
        break;
    }

    return group;
  }

  // ========================================
  // LANDMARK GENERATORS
  // ========================================

  function createLandmark(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'landmark_' + type;

    switch(type) {
      case 'fountain':
        const basinMat = new THREE.MeshLambertMaterial({ color: 0x8899aa });
        const waterMat = new THREE.MeshLambertMaterial({
          color: 0x4488cc,
          transparent: true,
          opacity: 0.7
        });
        const pillarMat = new THREE.MeshLambertMaterial({ color: 0xaabbcc });

        // Circular basin
        const basin = new THREE.Mesh(
          new THREE.CylinderGeometry(2 * scale, 2.2 * scale, 0.6 * scale, 16),
          basinMat
        );
        basin.position.y = 0.3 * scale;
        group.add(basin);

        // Water surface inside basin
        const water = new THREE.Mesh(
          new THREE.CylinderGeometry(1.8 * scale, 1.8 * scale, 0.1 * scale, 16),
          waterMat
        );
        water.position.y = 0.5 * scale;
        group.add(water);

        // Central pillar
        const centerPillar = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2 * scale, 8),
          pillarMat
        );
        centerPillar.position.y = 1.3 * scale;
        group.add(centerPillar);

        // Top bowl
        const topBowl = new THREE.Mesh(
          new THREE.SphereGeometry(0.5 * scale, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
          basinMat
        );
        topBowl.position.y = 2.3 * scale;
        topBowl.rotation.x = Math.PI;
        group.add(topBowl);

        // Water drop effect (small glowing sphere)
        const dropMat = new THREE.MeshLambertMaterial({
          color: 0x88ccff,
          emissive: 0x2266aa,
          emissiveIntensity: 0.4
        });
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.15 * scale, 8, 6),
          dropMat
        );
        drop.position.y = 2.5 * scale;
        drop.name = 'waterDrop';
        group.add(drop);

        group.userData.animationType = 'fountain';
        break;

      case 'obelisk':
        const obeliskMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
        const runeMat = new THREE.MeshLambertMaterial({
          color: 0x88aaff,
          emissive: 0x4466cc,
          emissiveIntensity: 0.6
        });

        // Tall tapered column
        const obelisk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.3 * scale, 0.6 * scale, 5 * scale, 4),
          obeliskMat
        );
        obelisk.position.y = 2.5 * scale;
        group.add(obelisk);

        // Glowing rune rings
        for (let i = 0; i < 3; i++) {
          const rune = new THREE.Mesh(
            new THREE.TorusGeometry(0.45 * scale, 0.04 * scale, 6, 12),
            runeMat
          );
          rune.position.y = (1.5 + i * 1.2) * scale;
          rune.rotation.x = Math.PI / 2;
          group.add(rune);
        }

        // Pyramidal top
        const top = new THREE.Mesh(
          new THREE.ConeGeometry(0.35 * scale, 0.6 * scale, 4),
          obeliskMat
        );
        top.position.y = 5.3 * scale;
        group.add(top);

        // Glowing tip
        const tipMat = new THREE.MeshLambertMaterial({
          color: 0xaaccff,
          emissive: 0x6688ff,
          emissiveIntensity: 1.0
        });
        const tip = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 * scale, 8, 6),
          tipMat
        );
        tip.position.y = 5.7 * scale;
        group.add(tip);

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 1.5;
        break;

      case 'statue':
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
        const pedestalMat = new THREE.MeshLambertMaterial({ color: 0x777777 });

        // Pedestal
        const pedestal = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 * scale, 0.8 * scale, 1.2 * scale),
          pedestalMat
        );
        pedestal.position.y = 0.4 * scale;
        group.add(pedestal);

        // Body (torso)
        const torso = new THREE.Mesh(
          new THREE.BoxGeometry(0.7 * scale, 1.2 * scale, 0.4 * scale),
          stoneMat
        );
        torso.position.y = 1.8 * scale;
        group.add(torso);

        // Head
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.25 * scale, 8, 6),
          stoneMat
        );
        head.position.y = 2.7 * scale;
        group.add(head);

        // Arms reaching out
        const leftArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.2 * scale),
          stoneMat
        );
        leftArm.position.set(-0.7 * scale, 2.0 * scale, 0);
        leftArm.rotation.z = Math.PI / 6;
        group.add(leftArm);

        const rightArm = new THREE.Mesh(
          new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.2 * scale),
          stoneMat
        );
        rightArm.position.set(0.7 * scale, 2.0 * scale, 0);
        rightArm.rotation.z = -Math.PI / 6;
        group.add(rightArm);
        break;

      case 'campfire':
        const logMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
        const fireMat = new THREE.MeshLambertMaterial({
          color: 0xff6600,
          emissive: 0xff4400,
          emissiveIntensity: 0.9
        });
        const emberMat = new THREE.MeshLambertMaterial({
          color: 0xff2200,
          emissive: 0xff0000,
          emissiveIntensity: 0.7
        });

        // Ring of stones
        for (let i = 0; i < 8; i++) {
          const stone = new THREE.Mesh(
            new THREE.SphereGeometry(0.15 * scale, 6, 4),
            new THREE.MeshLambertMaterial({ color: 0x666666 })
          );
          const angle = (i / 8) * Math.PI * 2;
          stone.position.x = Math.cos(angle) * 0.6 * scale;
          stone.position.z = Math.sin(angle) * 0.6 * scale;
          stone.position.y = 0.1 * scale;
          stone.scale.y = 0.7;
          group.add(stone);
        }

        // Logs in triangle pattern
        for (let i = 0; i < 3; i++) {
          const log = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 1 * scale, 6),
            logMat
          );
          const angle = (i / 3) * Math.PI * 2;
          log.position.x = Math.cos(angle) * 0.2 * scale;
          log.position.z = Math.sin(angle) * 0.2 * scale;
          log.position.y = 0.15 * scale;
          log.rotation.z = Math.PI / 2;
          log.rotation.y = angle;
          group.add(log);
        }

        // Fire core (will be animated)
        const fireCore = new THREE.Mesh(
          new THREE.ConeGeometry(0.25 * scale, 0.8 * scale, 6),
          fireMat
        );
        fireCore.position.y = 0.5 * scale;
        fireCore.name = 'fireCore';
        group.add(fireCore);

        // Inner flame
        const innerFlame = new THREE.Mesh(
          new THREE.ConeGeometry(0.15 * scale, 0.5 * scale, 5),
          new THREE.MeshLambertMaterial({
            color: 0xffaa00,
            emissive: 0xff8800,
            emissiveIntensity: 1.0
          })
        );
        innerFlame.position.y = 0.55 * scale;
        innerFlame.name = 'innerFlame';
        group.add(innerFlame);

        // Embers
        for (let i = 0; i < 5; i++) {
          const ember = new THREE.Mesh(
            new THREE.SphereGeometry(0.04 * scale, 4, 4),
            emberMat
          );
          ember.position.x = (Math.random() - 0.5) * 0.4 * scale;
          ember.position.z = (Math.random() - 0.5) * 0.4 * scale;
          ember.position.y = 0.2 * scale;
          group.add(ember);
        }

        // Point light for fire glow
        const fireLight = new THREE.PointLight(0xff6622, 2, 15);
        fireLight.position.y = 0.8 * scale;
        group.add(fireLight);

        group.userData.animationType = 'flicker';
        group.userData.flickerSpeed = 8;
        break;

      case 'portal_ring':
        const ringMat = new THREE.MeshLambertMaterial({
          color: 0x8866ff,
          emissive: 0x4422cc,
          emissiveIntensity: 0.8
        });
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x555555 });

        // Stone frame pillars
        const leftPillar = new THREE.Mesh(
          new THREE.BoxGeometry(0.4 * scale, 4 * scale, 0.4 * scale),
          frameMat
        );
        leftPillar.position.set(-1.5 * scale, 2 * scale, 0);
        group.add(leftPillar);

        const rightPillar = new THREE.Mesh(
          new THREE.BoxGeometry(0.4 * scale, 4 * scale, 0.4 * scale),
          frameMat
        );
        rightPillar.position.set(1.5 * scale, 2 * scale, 0);
        group.add(rightPillar);

        // Arch top
        const arch = new THREE.Mesh(
          new THREE.TorusGeometry(1.5 * scale, 0.2 * scale, 8, 12, Math.PI),
          frameMat
        );
        arch.position.y = 4 * scale;
        group.add(arch);

        // Glowing inner ring
        const innerRing = new THREE.Mesh(
          new THREE.TorusGeometry(1.2 * scale, 0.08 * scale, 8, 24),
          ringMat
        );
        innerRing.position.y = 2.5 * scale;
        innerRing.name = 'portalRing';
        group.add(innerRing);

        // Swirling energy center (flat disc)
        const portalCenter = new THREE.Mesh(
          new THREE.CircleGeometry(1.1 * scale, 16),
          new THREE.MeshLambertMaterial({
            color: 0xaa88ff,
            emissive: 0x6644cc,
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
          })
        );
        portalCenter.position.y = 2.5 * scale;
        portalCenter.name = 'portalCenter';
        group.add(portalCenter);

        group.userData.animationType = 'portal';
        group.userData.spinSpeed = 0.5;
        break;

      case 'signpost':
        const postMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
        const signMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Post
        const signPost = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * scale, 0.08 * scale, 2.5 * scale, 6),
          postMat
        );
        signPost.position.y = 1.25 * scale;
        group.add(signPost);

        // Directional signs (angled boards)
        const signAngles = [0, Math.PI / 3, -Math.PI / 4];
        const signColors = [0x9b7924, 0x8b6914, 0x7b5904];
        signAngles.forEach(function(angle, i) {
          var signBoard = new THREE.Mesh(
            new THREE.BoxGeometry(0.8 * scale, 0.2 * scale, 0.05 * scale),
            new THREE.MeshLambertMaterial({ color: signColors[i] })
          );
          signBoard.position.y = (2.0 - i * 0.35) * scale;
          signBoard.position.x = 0.3 * scale;
          signBoard.rotation.y = angle;
          group.add(signBoard);
        });
        break;

      case 'gazebo':
        const gazeboWoodMat = new THREE.MeshLambertMaterial({ color: 0xc9a96e });
        const gazeboRoofMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });

        // Floor platform
        const floor = new THREE.Mesh(
          new THREE.CylinderGeometry(2.5 * scale, 2.5 * scale, 0.2 * scale, 8),
          gazeboWoodMat
        );
        floor.position.y = 0.3 * scale;
        group.add(floor);

        // 6 pillars
        for (let i = 0; i < 6; i++) {
          const gazeboPillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1 * scale, 0.1 * scale, 2.5 * scale, 6),
            gazeboWoodMat
          );
          const pAngle = (i / 6) * Math.PI * 2;
          gazeboPillar.position.x = Math.cos(pAngle) * 2.2 * scale;
          gazeboPillar.position.z = Math.sin(pAngle) * 2.2 * scale;
          gazeboPillar.position.y = 1.55 * scale;
          group.add(gazeboPillar);
        }

        // Conical roof
        const gazeboRoof = new THREE.Mesh(
          new THREE.ConeGeometry(3 * scale, 1.5 * scale, 8),
          gazeboRoofMat
        );
        gazeboRoof.position.y = 3.6 * scale;
        group.add(gazeboRoof);

        // Railing sections between pillars
        for (let i = 0; i < 6; i++) {
          if (i === 0) continue; // Leave one gap for entrance
          const a1 = (i / 6) * Math.PI * 2;
          const a2 = ((i + 1) / 6) * Math.PI * 2;
          const midAngle = (a1 + a2) / 2;
          const railing = new THREE.Mesh(
            new THREE.BoxGeometry(1.5 * scale, 0.1 * scale, 0.08 * scale),
            gazeboWoodMat
          );
          railing.position.x = Math.cos(midAngle) * 2.2 * scale;
          railing.position.z = Math.sin(midAngle) * 2.2 * scale;
          railing.position.y = 0.8 * scale;
          railing.rotation.y = midAngle + Math.PI / 2;
          group.add(railing);
        }
        break;
    }

    return group;
  }

  // ========================================
  // RESOURCE NODE GENERATORS
  // ========================================

  function createResourceNode(type, scale) {
    scale = scale || 1;
    const group = new THREE.Group();
    group.name = 'resource_' + type;
    group.userData.isResource = true;
    group.userData.resourceType = type;

    switch(type) {
      case 'ore_vein':
        const oreMat = new THREE.MeshLambertMaterial({ color: 0x8a7b6b });
        const oreGlintMat = new THREE.MeshLambertMaterial({
          color: 0xccaa66,
          emissive: 0x886622,
          emissiveIntensity: 0.4
        });

        // Base rock
        const oreRock = new THREE.Mesh(
          new THREE.DodecahedronGeometry(0.7 * scale, 0),
          oreMat
        );
        oreRock.position.y = 0.4 * scale;
        oreRock.scale.y = 0.6;
        group.add(oreRock);

        // Metallic veins (small shiny patches)
        for (let i = 0; i < 4; i++) {
          const vein = new THREE.Mesh(
            new THREE.SphereGeometry(0.12 * scale, 6, 4),
            oreGlintMat
          );
          const angle = (i / 4) * Math.PI * 2 + Math.random();
          vein.position.x = Math.cos(angle) * 0.4 * scale;
          vein.position.z = Math.sin(angle) * 0.4 * scale;
          vein.position.y = (0.3 + Math.random() * 0.3) * scale;
          group.add(vein);
        }

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 0.8;
        break;

      case 'crystal_cluster':
        const crystalColors = [0x88aaff, 0xaa88ff, 0x66ccff, 0xcc88ff];

        // Several upward-pointing crystals
        for (let i = 0; i < 5; i++) {
          const crystalHeight = (0.5 + Math.random() * 1.0) * scale;
          const crystalRadius = (0.08 + Math.random() * 0.12) * scale;
          const crystal = new THREE.Mesh(
            new THREE.ConeGeometry(crystalRadius, crystalHeight, 6),
            new THREE.MeshLambertMaterial({
              color: crystalColors[i % crystalColors.length],
              emissive: crystalColors[i % crystalColors.length],
              emissiveIntensity: 0.3,
              transparent: true,
              opacity: 0.85
            })
          );
          const angle = (i / 5) * Math.PI * 2;
          const rad = 0.2 * scale;
          crystal.position.x = Math.cos(angle) * rad;
          crystal.position.z = Math.sin(angle) * rad;
          crystal.position.y = crystalHeight / 2;
          // Slight random tilt
          crystal.rotation.x = (Math.random() - 0.5) * 0.3;
          crystal.rotation.z = (Math.random() - 0.5) * 0.3;
          group.add(crystal);
        }

        // Glow light
        const crystalLight = new THREE.PointLight(0x8888ff, 0.8, 8);
        crystalLight.position.y = 0.5 * scale;
        group.add(crystalLight);

        group.userData.animationType = 'pulse';
        group.userData.pulseSpeed = 1.2;
        break;

      case 'herb_patch':
        const stemMat = new THREE.MeshLambertMaterial({ color: 0x2d7a2d });
        const flowerColors = [0xff88aa, 0xffaa44, 0xaa88ff, 0x88ffaa];

        // Cluster of small herb plants
        for (let i = 0; i < 6; i++) {
          const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02 * scale, 0.02 * scale, 0.4 * scale, 4),
            stemMat
          );
          const angle = (i / 6) * Math.PI * 2;
          const rad = 0.3 * scale;
          stem.position.x = Math.cos(angle) * rad;
          stem.position.z = Math.sin(angle) * rad;
          stem.position.y = 0.2 * scale;
          group.add(stem);

          // Tiny flower/leaf at top
          const flower = new THREE.Mesh(
            new THREE.SphereGeometry(0.06 * scale, 6, 4),
            new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] })
          );
          flower.position.x = stem.position.x;
          flower.position.z = stem.position.z;
          flower.position.y = 0.42 * scale;
          group.add(flower);
        }

        // Ground cover leaves
        const leafMat = new THREE.MeshLambertMaterial({ color: 0x3a8a3a });
        const leafGround = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 0.05 * scale, 8),
          leafMat
        );
        leafGround.position.y = 0.02 * scale;
        group.add(leafGround);

        group.userData.animationType = 'sway';
        group.userData.swayAmount = 0.03;
        group.userData.swaySpeed = 1.5;
        break;

      case 'flower_bed':
        const fStemMat = new THREE.MeshLambertMaterial({ color: 0x2d7a2d });
        const petalColors = [0xff4488, 0xff88cc, 0xffaa66, 0xffff44, 0xff6644];

        // Flowers in a cluster
        for (let i = 0; i < 8; i++) {
          const fStem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015 * scale, 0.02 * scale, 0.5 * scale, 4),
            fStemMat
          );
          const angle = Math.random() * Math.PI * 2;
          const rad = Math.random() * 0.5 * scale;
          fStem.position.x = Math.cos(angle) * rad;
          fStem.position.z = Math.sin(angle) * rad;
          fStem.position.y = 0.25 * scale;
          // Slight random lean
          fStem.rotation.x = (Math.random() - 0.5) * 0.15;
          fStem.rotation.z = (Math.random() - 0.5) * 0.15;
          group.add(fStem);

          // Flower head (small sphere cluster)
          const flowerHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.08 * scale, 6, 4),
            new THREE.MeshLambertMaterial({
              color: petalColors[Math.floor(Math.random() * petalColors.length)]
            })
          );
          flowerHead.position.set(fStem.position.x, 0.52 * scale, fStem.position.z);
          group.add(flowerHead);
        }

        group.userData.animationType = 'sway';
        group.userData.swayAmount = 0.02;
        group.userData.swaySpeed = 2;
        break;

      case 'wood_pile':
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
        const barkMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

        // Stack of logs
        var logCount = 0;
        for (let row = 0; row < 3; row++) {
          var logsInRow = 3 - row;
          for (let i = 0; i < logsInRow; i++) {
            const log = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12 * scale, 0.12 * scale, 1.0 * scale, 6),
              row % 2 === 0 ? woodMat : barkMat
            );
            log.rotation.z = Math.PI / 2;
            log.position.x = (i - (logsInRow - 1) / 2) * 0.26 * scale;
            log.position.y = (0.12 + row * 0.22) * scale;
            log.position.z = ((logCount % 2) * 0.05 - 0.025) * scale;
            group.add(log);
            logCount++;
          }
        }
        break;
    }

    return group;
  }

  // ========================================
  // MORE CREATURE GENERATORS
  // ========================================

  function createWildlife(type) {
    const group = new THREE.Group();
    group.name = 'wildlife_' + type;

    switch(type) {
      case 'deer':
        const deerBodyMat = new THREE.MeshLambertMaterial({ color: 0xb8860b });
        const deerLegMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });

        // Body
        const deerBody = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.35, 0.8),
          deerBodyMat
        );
        deerBody.position.y = 0.7;
        group.add(deerBody);

        // Head
        const deerHead = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.25),
          deerBodyMat
        );
        deerHead.position.set(0, 0.95, 0.4);
        group.add(deerHead);

        // Antlers
        const antlerMat = new THREE.MeshLambertMaterial({ color: 0xd2b48c });
        for (let side = -1; side <= 1; side += 2) {
          const antler = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4),
            antlerMat
          );
          antler.position.set(side * 0.1, 1.15, 0.4);
          antler.rotation.z = side * Math.PI / 6;
          group.add(antler);

          // Antler branch
          const branch = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.015, 0.15, 4),
            antlerMat
          );
          branch.position.set(side * 0.2, 1.25, 0.4);
          branch.rotation.z = side * Math.PI / 4;
          group.add(branch);
        }

        // Legs
        var legPositions = [
          { x: -0.12, z: 0.25 }, { x: 0.12, z: 0.25 },
          { x: -0.12, z: -0.25 }, { x: 0.12, z: -0.25 }
        ];
        legPositions.forEach(function(pos) {
          var leg = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.03, 0.5, 6),
            deerLegMat
          );
          leg.position.set(pos.x, 0.3, pos.z);
          group.add(leg);
        });

        // Tail (small white triangle)
        const tailMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const deerTail = new THREE.Mesh(
          new THREE.ConeGeometry(0.05, 0.1, 4),
          tailMat
        );
        deerTail.position.set(0, 0.75, -0.45);
        deerTail.rotation.x = -Math.PI / 4;
        group.add(deerTail);

        group.userData.animationType = 'idle_look';
        group.scale.set(1.5, 1.5, 1.5);
        break;

      case 'rabbit':
        const rabbitMat = new THREE.MeshLambertMaterial({ color: 0xd2b48c });

        // Body
        const rabbitBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 8, 6),
          rabbitMat
        );
        rabbitBody.position.y = 0.2;
        rabbitBody.scale.z = 1.3;
        group.add(rabbitBody);

        // Head
        const rabbitHead = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 6),
          rabbitMat
        );
        rabbitHead.position.set(0, 0.3, 0.15);
        group.add(rabbitHead);

        // Ears
        const earMat = new THREE.MeshLambertMaterial({ color: 0xc4a882 });
        for (let side = -1; side <= 1; side += 2) {
          const ear = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, 0.15, 0.05),
            earMat
          );
          ear.position.set(side * 0.05, 0.45, 0.15);
          ear.rotation.z = side * 0.2;
          group.add(ear);
        }

        // Fluffy tail
        const puffTail = new THREE.Mesh(
          new THREE.SphereGeometry(0.06, 6, 4),
          new THREE.MeshLambertMaterial({ color: 0xeeeeee })
        );
        puffTail.position.set(0, 0.2, -0.2);
        group.add(puffTail);

        group.userData.animationType = 'hop';
        group.userData.hopInterval = 3;
        group.userData.hopTimer = Math.random() * 3;
        break;

      case 'firefly':
        const ffBodyMat = new THREE.MeshLambertMaterial({ color: 0x333300 });
        const ffGlowMat = new THREE.MeshLambertMaterial({
          color: 0xffff44,
          emissive: 0xaacc00,
          emissiveIntensity: 1.0
        });

        // Tiny body
        const ffBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 6, 4),
          ffBodyMat
        );
        group.add(ffBody);

        // Glowing abdomen
        const ffGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 6, 4),
          ffGlowMat
        );
        ffGlow.position.z = -0.04;
        ffGlow.name = 'glow';
        group.add(ffGlow);

        // Tiny point light
        const ffLight = new THREE.PointLight(0xaacc00, 0.5, 4);
        ffLight.position.z = -0.04;
        group.add(ffLight);

        group.userData.animationType = 'float';
        group.userData.floatSpeed = 0.5 + Math.random() * 0.5;
        group.userData.floatRadius = 1 + Math.random() * 2;
        group.userData.floatAngle = Math.random() * Math.PI * 2;
        group.userData.floatHeight = 1.5 + Math.random();
        break;

      case 'frog':
        const frogMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
        const frogEyeMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });

        // Body
        const frogBody = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 8, 6),
          frogMat
        );
        frogBody.position.y = 0.1;
        frogBody.scale.y = 0.7;
        frogBody.scale.z = 1.2;
        group.add(frogBody);

        // Eyes (protruding)
        for (let side = -1; side <= 1; side += 2) {
          const eye = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 6, 4),
            frogEyeMat
          );
          eye.position.set(side * 0.06, 0.18, 0.08);
          group.add(eye);
        }

        // Back legs
        for (let side = -1; side <= 1; side += 2) {
          const backLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.04, 0.15),
            frogMat
          );
          backLeg.position.set(side * 0.1, 0.05, -0.12);
          group.add(backLeg);
        }

        group.userData.animationType = 'hop';
        group.userData.hopInterval = 5;
        group.userData.hopTimer = Math.random() * 5;
        break;
    }

    return group;
  }

  // ========================================
  // ANIMATION SYSTEM
  // ========================================

  function animateModel(model, deltaTime, worldTime) {
    if (!model.userData.animationType || model.userData.animationType === 'none') {
      return;
    }

    const type = model.userData.animationType;

    switch(type) {
      case 'sway':
        // Gentle tree sway
        const swayAmount = model.userData.swayAmount || 0.05;
        const swaySpeed = model.userData.swaySpeed || 1.0;
        model.rotation.z = Math.sin(worldTime * swaySpeed) * swayAmount;
        model.rotation.x = Math.cos(worldTime * swaySpeed * 0.7) * swayAmount * 0.5;
        break;

      case 'flap':
        // Wing flapping for butterflies/birds
        const flapSpeed = model.userData.flapSpeed || 8;
        const flapAmount = model.userData.flapAmount || Math.PI / 4;
        const flapAngle = Math.sin(worldTime * flapSpeed) * flapAmount;

        const leftWing = model.getObjectByName('leftWing');
        const rightWing = model.getObjectByName('rightWing');

        if (leftWing) {
          leftWing.rotation.y = flapAngle;
        }
        if (rightWing) {
          rightWing.rotation.y = -flapAngle;
        }
        break;

      case 'swim':
        // Circular swimming motion
        const swimSpeed = model.userData.swimSpeed || 1;
        const swimRadius = model.userData.swimRadius || 2;

        model.userData.swimAngle = (model.userData.swimAngle || 0) + deltaTime * swimSpeed;

        const centerX = model.userData.swimCenterX || 0;
        const centerZ = model.userData.swimCenterZ || 0;

        model.position.x = centerX + Math.cos(model.userData.swimAngle) * swimRadius;
        model.position.z = centerZ + Math.sin(model.userData.swimAngle) * swimRadius;
        model.rotation.y = model.userData.swimAngle + Math.PI / 2;
        break;

      case 'bob':
        // Vertical bobbing motion
        const bobSpeed = model.userData.bobSpeed || 1.5;
        const bobAmount = model.userData.bobAmount || 0.2;
        const baseY = model.userData.baseY || model.position.y;

        if (model.userData.baseY === undefined) {
          model.userData.baseY = model.position.y;
        }

        model.position.y = baseY + Math.sin(worldTime * bobSpeed) * bobAmount;
        break;

      case 'spin':
        // Slow rotation around Y axis
        const spinSpeed = model.userData.spinSpeed || 0.5;
        model.rotation.y += deltaTime * spinSpeed;
        break;

      case 'pulse':
        // Pulsating glow (scale throb)
        var pulseSpeed = model.userData.pulseSpeed || 1.5;
        var pulseVal = 1 + Math.sin(worldTime * pulseSpeed) * 0.08;
        model.scale.set(pulseVal, pulseVal, pulseVal);
        break;

      case 'flicker':
        // Fire flicker animation
        var flickerSpeed = model.userData.flickerSpeed || 8;
        var fireCore = model.getObjectByName('fireCore');
        var innerFlame = model.getObjectByName('innerFlame');
        if (fireCore) {
          fireCore.scale.x = 0.8 + Math.sin(worldTime * flickerSpeed) * 0.3;
          fireCore.scale.z = 0.8 + Math.cos(worldTime * flickerSpeed * 1.3) * 0.3;
          fireCore.scale.y = 0.9 + Math.sin(worldTime * flickerSpeed * 0.7) * 0.2;
          fireCore.position.y = 0.5 + Math.sin(worldTime * flickerSpeed * 1.1) * 0.05;
        }
        if (innerFlame) {
          innerFlame.scale.x = 0.7 + Math.cos(worldTime * flickerSpeed * 1.5) * 0.4;
          innerFlame.scale.z = 0.7 + Math.sin(worldTime * flickerSpeed * 0.9) * 0.4;
          innerFlame.rotation.y += deltaTime * 2;
        }
        break;

      case 'fountain':
        // Water drop bouncing animation
        var waterDrop = model.getObjectByName('waterDrop');
        if (waterDrop) {
          var fountainCycle = worldTime * 2;
          var dropPhase = fountainCycle % 2;
          if (dropPhase < 1) {
            waterDrop.position.y = 2.5 + dropPhase * 0.5;
            waterDrop.scale.set(1, 1, 1);
          } else {
            waterDrop.position.y = 3.0 - (dropPhase - 1) * 0.8;
            var shrink = 1 - (dropPhase - 1) * 0.5;
            waterDrop.scale.set(shrink, shrink, shrink);
          }
        }
        break;

      case 'portal':
        // Rotating portal ring + wobbling center
        var portalRing = model.getObjectByName('portalRing');
        var portalCenter = model.getObjectByName('portalCenter');
        if (portalRing) {
          portalRing.rotation.z += deltaTime * 0.5;
        }
        if (portalCenter) {
          portalCenter.rotation.z -= deltaTime * 0.3;
          var opacity = 0.3 + Math.sin(worldTime * 1.5) * 0.2;
          if (portalCenter.material) {
            portalCenter.material.opacity = opacity;
          }
        }
        break;

      case 'float':
        // Floating in a gentle path (for fireflies)
        var floatSpeed = model.userData.floatSpeed || 0.5;
        var floatRadius = model.userData.floatRadius || 2;
        var floatHeight = model.userData.floatHeight || 2;

        model.userData.floatAngle = (model.userData.floatAngle || 0) + deltaTime * floatSpeed;
        var fAngle = model.userData.floatAngle;

        if (model.userData.floatCenterX === undefined) {
          model.userData.floatCenterX = model.position.x;
          model.userData.floatCenterZ = model.position.z;
        }

        model.position.x = model.userData.floatCenterX + Math.cos(fAngle) * floatRadius;
        model.position.z = model.userData.floatCenterZ + Math.sin(fAngle * 0.7) * floatRadius;
        model.position.y = floatHeight + Math.sin(fAngle * 1.3) * 0.5;
        break;

      case 'hop':
        // Occasional hopping for rabbits/frogs
        model.userData.hopTimer = (model.userData.hopTimer || 0) - deltaTime;
        if (model.userData.hopTimer <= 0) {
          model.userData.hopTimer = model.userData.hopInterval || 3;
          model.userData.isHopping = true;
          model.userData.hopPhase = 0;
          // Pick random direction
          model.userData.hopDirX = (Math.random() - 0.5) * 2;
          model.userData.hopDirZ = (Math.random() - 0.5) * 2;
        }
        if (model.userData.isHopping) {
          model.userData.hopPhase += deltaTime * 4;
          if (model.userData.hopPhase < Math.PI) {
            var hopHeight = Math.sin(model.userData.hopPhase) * 0.3;
            if (model.userData.baseHopY === undefined) {
              model.userData.baseHopY = model.position.y;
            }
            model.position.y = model.userData.baseHopY + hopHeight;
            model.position.x += model.userData.hopDirX * deltaTime;
            model.position.z += model.userData.hopDirZ * deltaTime;
          } else {
            model.position.y = model.userData.baseHopY || model.position.y;
            model.userData.isHopping = false;
          }
        }
        break;

      case 'idle_look':
        // Gentle head turning for deer
        model.rotation.y = Math.sin(worldTime * 0.3) * 0.3;
        break;
    }
  }

  // ========================================
  // GROUND COVER â€” Grass, mushrooms, bushes, fallen logs
  // ========================================

  function createGrassPatch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'grass_patch';
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.03;
    group.userData.swaySpeed = 2.0;

    var grassColors = [0x4a8028, 0x3a6b1f, 0x5a9030, 0x2d5016, 0x68a840];

    // 8-12 grass blades in a cluster
    var bladeCount = 8 + Math.floor(Math.random() * 5);
    for (var i = 0; i < bladeCount; i++) {
      var bladeHeight = (0.3 + Math.random() * 0.4) * scale;
      var bladeGeo = new THREE.PlaneGeometry(0.04 * scale, bladeHeight);
      var bladeMat = new THREE.MeshLambertMaterial({
        color: grassColors[Math.floor(Math.random() * grassColors.length)],
        side: THREE.DoubleSide
      });
      var blade = new THREE.Mesh(bladeGeo, bladeMat);

      var angle = (i / bladeCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
      var radius = Math.random() * 0.3 * scale;
      blade.position.x = Math.cos(angle) * radius;
      blade.position.z = Math.sin(angle) * radius;
      blade.position.y = bladeHeight * 0.5;
      blade.rotation.y = Math.random() * Math.PI;
      blade.rotation.z = (Math.random() - 0.5) * 0.3;
      group.add(blade);
    }

    return group;
  }

  function createMushroom(type, scale) {
    scale = scale || 1;
    type = type || 'red';
    var group = new THREE.Group();
    group.name = 'mushroom_' + type;

    var stemMat = new THREE.MeshLambertMaterial({ color: 0xf5deb3 });
    var capColors = {
      red: 0xcc3333,
      brown: 0x8b6914,
      white: 0xf0f0e0,
      purple: 0x9966cc,
      glowing: 0x66ffcc
    };
    var capColor = capColors[type] || capColors.red;

    // Main mushroom
    var stem = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.05 * scale, 0.2 * scale, 6),
      stemMat
    );
    stem.position.y = 0.1 * scale;
    group.add(stem);

    var capMat = new THREE.MeshLambertMaterial({ color: capColor });
    if (type === 'glowing') {
      capMat = new THREE.MeshBasicMaterial({ color: capColor });
    }
    var cap = new THREE.Mesh(
      new THREE.SphereGeometry(0.1 * scale, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.6),
      capMat
    );
    cap.position.y = 0.2 * scale;
    group.add(cap);

    // Add spots to red/purple mushrooms
    if (type === 'red' || type === 'purple') {
      for (var s = 0; s < 4; s++) {
        var spot = new THREE.Mesh(
          new THREE.CircleGeometry(0.015 * scale, 6),
          new THREE.MeshLambertMaterial({ color: 0xffffff })
        );
        var sAngle = (s / 4) * Math.PI * 2;
        spot.position.x = Math.cos(sAngle) * 0.07 * scale;
        spot.position.z = Math.sin(sAngle) * 0.07 * scale;
        spot.position.y = 0.23 * scale;
        spot.rotation.x = -Math.PI * 0.3;
        spot.rotation.y = sAngle;
        group.add(spot);
      }
    }

    // Add 1-2 smaller mushrooms next to main
    for (var m = 0; m < 1 + Math.floor(Math.random() * 2); m++) {
      var smallScale = 0.5 + Math.random() * 0.3;
      var smallStem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03 * scale * smallScale, 0.04 * scale * smallScale, 0.15 * scale * smallScale, 6),
        stemMat
      );
      var mAngle = Math.random() * Math.PI * 2;
      var mDist = 0.1 + Math.random() * 0.1;
      smallStem.position.x = Math.cos(mAngle) * mDist * scale;
      smallStem.position.z = Math.sin(mAngle) * mDist * scale;
      smallStem.position.y = 0.075 * scale * smallScale;
      group.add(smallStem);

      var smallCap = new THREE.Mesh(
        new THREE.SphereGeometry(0.07 * scale * smallScale, 6, 5, 0, Math.PI * 2, 0, Math.PI * 0.6),
        capMat
      );
      smallCap.position.x = smallStem.position.x;
      smallCap.position.z = smallStem.position.z;
      smallCap.position.y = 0.15 * scale * smallScale;
      group.add(smallCap);
    }

    // Add glow light for glowing mushrooms
    if (type === 'glowing') {
      var glow = new THREE.PointLight(0x66ffcc, 0.5, 3 * scale);
      glow.position.y = 0.2 * scale;
      group.add(glow);
      group.userData.animationType = 'pulse';
    }

    return group;
  }

  function createBush(type, scale) {
    scale = scale || 1;
    type = type || 'green';
    var group = new THREE.Group();
    group.name = 'bush_' + type;
    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.02;
    group.userData.swaySpeed = 0.8;

    var bushColors = {
      green: [0x2d5016, 0x3a6b1f, 0x4a8028],
      flowering: [0x3a6b1f, 0x4a8028, 0x5a9030],
      berry: [0x2d5016, 0x3a6b1f],
      autumn: [0xcc6600, 0xdd8800, 0xaa4400]
    };

    var colors = bushColors[type] || bushColors.green;

    // 4-6 overlapping spheres for bushy appearance
    var clumpCount = 4 + Math.floor(Math.random() * 3);
    for (var i = 0; i < clumpCount; i++) {
      var clumpSize = (0.25 + Math.random() * 0.2) * scale;
      var clump = new THREE.Mesh(
        new THREE.SphereGeometry(clumpSize, 6, 5),
        new THREE.MeshLambertMaterial({
          color: colors[Math.floor(Math.random() * colors.length)]
        })
      );
      var cAngle = (i / clumpCount) * Math.PI * 2 + Math.random() * 0.5;
      var cRadius = 0.15 * scale;
      clump.position.x = Math.cos(cAngle) * cRadius;
      clump.position.z = Math.sin(cAngle) * cRadius;
      clump.position.y = clumpSize * 0.7;
      group.add(clump);
    }

    // Add flowers to flowering bushes
    if (type === 'flowering') {
      var flowerColors = [0xff6699, 0xffcc00, 0xff9933, 0xcc66ff, 0xff3366];
      for (var f = 0; f < 5 + Math.floor(Math.random() * 4); f++) {
        var flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.04 * scale, 5, 4),
          new THREE.MeshLambertMaterial({
            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
          })
        );
        var fAngle = Math.random() * Math.PI * 2;
        var fRadius = Math.random() * 0.35 * scale;
        flower.position.x = Math.cos(fAngle) * fRadius;
        flower.position.z = Math.sin(fAngle) * fRadius;
        flower.position.y = 0.3 * scale + Math.random() * 0.15 * scale;
        group.add(flower);
      }
    }

    // Add berries to berry bushes
    if (type === 'berry') {
      for (var b = 0; b < 6 + Math.floor(Math.random() * 5); b++) {
        var berry = new THREE.Mesh(
          new THREE.SphereGeometry(0.025 * scale, 5, 4),
          new THREE.MeshLambertMaterial({ color: 0xcc0033 })
        );
        var bAngle = Math.random() * Math.PI * 2;
        var bRadius = Math.random() * 0.3 * scale;
        berry.position.x = Math.cos(bAngle) * bRadius;
        berry.position.z = Math.sin(bAngle) * bRadius;
        berry.position.y = 0.2 * scale + Math.random() * 0.2 * scale;
        group.add(berry);
      }
    }

    return group;
  }

  function createFallenLog(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'fallen_log';

    var barkMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
    var innerMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });

    // Main log body (laid on side)
    var log = new THREE.Mesh(
      new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 2.5 * scale, 8),
      barkMat
    );
    log.rotation.z = Math.PI / 2;
    log.position.y = 0.15 * scale;
    group.add(log);

    // Cross-section ring at one end
    var ring = new THREE.Mesh(
      new THREE.CircleGeometry(0.15 * scale, 8),
      innerMat
    );
    ring.position.x = 1.25 * scale;
    ring.position.y = 0.15 * scale;
    ring.rotation.y = Math.PI / 2;
    group.add(ring);

    // Small moss patches on top
    var mossMat = new THREE.MeshLambertMaterial({ color: 0x4a8028 });
    for (var i = 0; i < 3; i++) {
      var moss = new THREE.Mesh(
        new THREE.SphereGeometry(0.08 * scale, 5, 4, 0, Math.PI * 2, 0, Math.PI * 0.5),
        mossMat
      );
      moss.position.x = (Math.random() - 0.5) * 1.5 * scale;
      moss.position.y = 0.28 * scale;
      moss.position.z = (Math.random() - 0.5) * 0.1 * scale;
      group.add(moss);
    }

    // Optional small mushroom growing on it
    if (Math.random() < 0.5) {
      var logMushroom = createMushroom('brown', scale * 0.4);
      logMushroom.position.x = (Math.random() - 0.5) * scale;
      logMushroom.position.y = 0.3 * scale;
      group.add(logMushroom);
    }

    return group;
  }

  // ========================================
  // ZONE ARCHITECTURE â€” Detailed structures for each zone
  // ========================================

  function createRuinWall(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'ruin_wall';

    var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8378 });
    var mossyMat = new THREE.MeshLambertMaterial({ color: 0x6b7c5a });

    // Main wall section (irregular top edge simulated by stacked blocks)
    var wallBase = new THREE.Mesh(
      new THREE.BoxGeometry(4 * scale, 2 * scale, 0.5 * scale),
      stoneMat
    );
    wallBase.position.y = 1 * scale;
    group.add(wallBase);

    // Irregular top blocks (ruined look)
    var topHeights = [0.8, 1.2, 0.4, 1.0, 0.6, 0.9, 0.3];
    for (var i = 0; i < topHeights.length; i++) {
      var blockW = (4 / topHeights.length) * scale;
      var blockH = topHeights[i] * scale;
      var mat = Math.random() < 0.3 ? mossyMat : stoneMat;
      var block = new THREE.Mesh(
        new THREE.BoxGeometry(blockW * 0.9, blockH, 0.5 * scale),
        mat
      );
      block.position.x = (i - topHeights.length / 2 + 0.5) * blockW;
      block.position.y = 2 * scale + blockH / 2;
      group.add(block);
    }

    // Moss patches at base
    for (var m = 0; m < 4; m++) {
      var moss = new THREE.Mesh(
        new THREE.SphereGeometry(0.15 * scale, 5, 4, 0, Math.PI * 2, 0, Math.PI * 0.5),
        mossyMat
      );
      moss.position.x = (Math.random() - 0.5) * 3.5 * scale;
      moss.position.y = 0.05 * scale;
      moss.position.z = 0.2 * scale;
      group.add(moss);
    }

    return group;
  }

  function createColumnRow(count, height, spacing, scale) {
    scale = scale || 1;
    count = count || 4;
    height = height || 4;
    spacing = spacing || 2;
    var group = new THREE.Group();
    group.name = 'column_row';

    var columnMat = new THREE.MeshPhongMaterial({ color: 0xd4c8b0 });
    var capMat = new THREE.MeshPhongMaterial({ color: 0xc8bca0 });

    for (var i = 0; i < count; i++) {
      // Column shaft
      var shaft = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, height * scale, 8),
        columnMat
      );
      shaft.position.x = (i - (count - 1) / 2) * spacing * scale;
      shaft.position.y = height * scale / 2;
      group.add(shaft);

      // Base
      var base = new THREE.Mesh(
        new THREE.BoxGeometry(0.6 * scale, 0.15 * scale, 0.6 * scale),
        capMat
      );
      base.position.x = shaft.position.x;
      base.position.y = 0.075 * scale;
      group.add(base);

      // Capital
      var capital = new THREE.Mesh(
        new THREE.BoxGeometry(0.55 * scale, 0.12 * scale, 0.55 * scale),
        capMat
      );
      capital.position.x = shaft.position.x;
      capital.position.y = height * scale + 0.06 * scale;
      group.add(capital);
    }

    // Architrave (beam across top)
    var beam = new THREE.Mesh(
      new THREE.BoxGeometry((count - 1) * spacing * scale + 0.8 * scale, 0.2 * scale, 0.5 * scale),
      capMat
    );
    beam.position.y = height * scale + 0.22 * scale;
    group.add(beam);

    return group;
  }

  function createAmphitheater(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'amphitheater';

    var seatMat = new THREE.MeshLambertMaterial({ color: 0xa09080 });
    var stageMat = new THREE.MeshLambertMaterial({ color: 0xd4c090 });

    // Tiered seating (semicircular)
    for (var tier = 0; tier < 5; tier++) {
      var innerR = (3 + tier * 1.5) * scale;
      var outerR = innerR + 1.2 * scale;
      var seatHeight = (0.4 + tier * 0.5) * scale;

      // Use a ring of boxes to approximate the arc
      var segments = 12;
      for (var s = 0; s < segments; s++) {
        var angle = (s / segments) * Math.PI - Math.PI / 2; // semicircle
        var midR = (innerR + outerR) / 2;
        var seat = new THREE.Mesh(
          new THREE.BoxGeometry(1.2 * scale, 0.3 * scale, 1.0 * scale),
          seatMat
        );
        seat.position.x = Math.cos(angle) * midR;
        seat.position.z = Math.sin(angle) * midR;
        seat.position.y = seatHeight;
        seat.rotation.y = -angle + Math.PI / 2;
        group.add(seat);
      }
    }

    // Stage platform
    var stage = new THREE.Mesh(
      new THREE.CylinderGeometry(2.5 * scale, 2.5 * scale, 0.3 * scale, 16, 1, false, 0, Math.PI),
      stageMat
    );
    stage.position.y = 0.15 * scale;
    group.add(stage);

    // Stage backdrop columns
    for (var c = -1; c <= 1; c++) {
      var col = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15 * scale, 0.18 * scale, 3 * scale, 6),
        new THREE.MeshPhongMaterial({ color: 0xc8b890 })
      );
      col.position.x = c * 2 * scale;
      col.position.y = 1.5 * scale;
      col.position.z = -0.5 * scale;
      group.add(col);
    }

    return group;
  }

  function createWishingWell(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'wishing_well';

    var stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
    var roofMat = new THREE.MeshLambertMaterial({ color: 0x5a3e2b });
    var waterMat = new THREE.MeshPhongMaterial({ color: 0x2244aa, transparent: true, opacity: 0.6 });

    // Stone wall (ring)
    var wallOuter = new THREE.Mesh(
      new THREE.CylinderGeometry(0.8 * scale, 0.85 * scale, 0.7 * scale, 12),
      stoneMat
    );
    wallOuter.position.y = 0.35 * scale;
    group.add(wallOuter);

    // Water inside
    var water = new THREE.Mesh(
      new THREE.CylinderGeometry(0.65 * scale, 0.65 * scale, 0.05 * scale, 12),
      waterMat
    );
    water.position.y = 0.5 * scale;
    group.add(water);

    // Support posts
    for (var p = 0; p < 2; p++) {
      var post = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06 * scale, 0.06 * scale, 1.8 * scale, 6),
        roofMat
      );
      post.position.x = (p === 0 ? -0.6 : 0.6) * scale;
      post.position.y = 1.2 * scale;
      group.add(post);
    }

    // Crossbeam
    var beam = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.04 * scale, 1.3 * scale, 6),
      roofMat
    );
    beam.rotation.z = Math.PI / 2;
    beam.position.y = 2.1 * scale;
    group.add(beam);

    // Small roof
    var roof = new THREE.Mesh(
      new THREE.ConeGeometry(0.9 * scale, 0.5 * scale, 4),
      roofMat
    );
    roof.position.y = 2.45 * scale;
    roof.rotation.y = Math.PI / 4;
    group.add(roof);

    // Bucket (hanging)
    var bucket = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1 * scale, 0.08 * scale, 0.15 * scale, 8, 1, true),
      new THREE.MeshLambertMaterial({ color: 0x654321, side: THREE.DoubleSide })
    );
    bucket.position.y = 1.5 * scale;
    group.add(bucket);

    group.userData.animationType = 'bob';
    group.userData.bobSpeed = 0.5;
    group.userData.bobAmount = 0.02;

    return group;
  }

  function createBookshelf(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'bookshelf';

    var woodMat = new THREE.MeshLambertMaterial({ color: 0x5c3a1e });
    var bookColors = [0x8b0000, 0x00008b, 0x006400, 0x8b4513, 0x4b0082, 0xb8860b, 0x2f4f4f];

    // Frame
    // Back panel
    var back = new THREE.Mesh(
      new THREE.BoxGeometry(1.5 * scale, 2.2 * scale, 0.05 * scale),
      woodMat
    );
    back.position.y = 1.1 * scale;
    back.position.z = -0.15 * scale;
    group.add(back);

    // Sides
    for (var side = -1; side <= 1; side += 2) {
      var sidePanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.05 * scale, 2.2 * scale, 0.35 * scale),
        woodMat
      );
      sidePanel.position.x = side * 0.75 * scale;
      sidePanel.position.y = 1.1 * scale;
      group.add(sidePanel);
    }

    // Shelves (4 levels)
    for (var shelf = 0; shelf < 5; shelf++) {
      var shelfBoard = new THREE.Mesh(
        new THREE.BoxGeometry(1.5 * scale, 0.04 * scale, 0.35 * scale),
        woodMat
      );
      shelfBoard.position.y = shelf * 0.55 * scale;
      group.add(shelfBoard);

      // Books on each shelf (except top)
      if (shelf < 4) {
        var bookCount = 5 + Math.floor(Math.random() * 4);
        var xPos = -0.6 * scale;
        for (var b = 0; b < bookCount && xPos < 0.6 * scale; b++) {
          var bookW = (0.06 + Math.random() * 0.08) * scale;
          var bookH = (0.35 + Math.random() * 0.15) * scale;
          var book = new THREE.Mesh(
            new THREE.BoxGeometry(bookW, bookH, 0.2 * scale),
            new THREE.MeshLambertMaterial({ color: bookColors[Math.floor(Math.random() * bookColors.length)] })
          );
          book.position.x = xPos + bookW / 2;
          book.position.y = shelf * 0.55 * scale + 0.02 * scale + bookH / 2;
          // Slight random tilt
          book.rotation.z = (Math.random() - 0.5) * 0.08;
          group.add(book);
          xPos += bookW + 0.01 * scale;
        }
      }
    }

    return group;
  }

  function createTorch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'torch';

    // Bracket (wall mount)
    var bracketMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
    var bracket = new THREE.Mesh(
      new THREE.BoxGeometry(0.08 * scale, 0.08 * scale, 0.3 * scale),
      bracketMat
    );
    bracket.position.z = -0.15 * scale;
    bracket.position.y = 1.5 * scale;
    group.add(bracket);

    // Torch handle
    var handleMat = new THREE.MeshLambertMaterial({ color: 0x5c3a1e });
    var handle = new THREE.Mesh(
      new THREE.CylinderGeometry(0.03 * scale, 0.04 * scale, 0.6 * scale, 6),
      handleMat
    );
    handle.position.y = 1.5 * scale;
    group.add(handle);

    // Fire (two overlapping cones)
    var fireMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
    var innerFireMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

    var fireOuter = new THREE.Mesh(
      new THREE.ConeGeometry(0.08 * scale, 0.2 * scale, 6),
      fireMat
    );
    fireOuter.position.y = 1.9 * scale;
    group.add(fireOuter);

    var fireInner = new THREE.Mesh(
      new THREE.ConeGeometry(0.04 * scale, 0.15 * scale, 5),
      innerFireMat
    );
    fireInner.position.y = 1.88 * scale;
    group.add(fireInner);

    // Light
    var light = new THREE.PointLight(0xff8833, 0.8, 10);
    light.position.y = 2 * scale;
    group.add(light);

    group.userData.animationType = 'fire';

    return group;
  }

  function createBridge(length, scale) {
    scale = scale || 1;
    length = length || 8;
    var group = new THREE.Group();
    group.name = 'bridge';

    var plankMat = new THREE.MeshLambertMaterial({ color: 0x6b4226 });
    var ropeMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
    var postMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

    // Posts at each end
    for (var end = -1; end <= 1; end += 2) {
      for (var side = -1; side <= 1; side += 2) {
        var post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06 * scale, 0.06 * scale, 1.5 * scale, 6),
          postMat
        );
        post.position.x = end * length / 2 * scale;
        post.position.y = 0.75 * scale;
        post.position.z = side * 0.6 * scale;
        group.add(post);
      }
    }

    // Planks
    var plankCount = Math.floor(length * 2);
    for (var p = 0; p < plankCount; p++) {
      var plank = new THREE.Mesh(
        new THREE.BoxGeometry(0.4 * scale, 0.04 * scale, 1.0 * scale),
        plankMat
      );
      plank.position.x = (p / plankCount - 0.5) * length * scale;
      // Slight sag in the middle
      var sagT = (p / plankCount - 0.5) * 2;
      plank.position.y = -sagT * sagT * 0.3 * scale + 0.3 * scale;
      // Slight random rotation for worn look
      plank.rotation.y = (Math.random() - 0.5) * 0.05;
      group.add(plank);
    }

    // Rope railings (approximated with thin cylinders)
    for (var ropeSide = -1; ropeSide <= 1; ropeSide += 2) {
      var ropeSegments = 8;
      for (var rs = 0; rs < ropeSegments; rs++) {
        var segLen = length / ropeSegments * scale;
        var rope = new THREE.Mesh(
          new THREE.CylinderGeometry(0.015 * scale, 0.015 * scale, segLen, 4),
          ropeMat
        );
        rope.rotation.z = Math.PI / 2;
        var t1 = rs / ropeSegments - 0.5;
        rope.position.x = (t1 + 0.5 / ropeSegments) * length * scale;
        var sagR = t1 * 2;
        rope.position.y = 1.2 * scale - sagR * sagR * 0.2 * scale;
        rope.position.z = ropeSide * 0.6 * scale;
        group.add(rope);
      }
    }

    return group;
  }

  function createGardenArch(scale) {
    scale = scale || 1;
    var group = new THREE.Group();
    group.name = 'garden_arch';

    var woodMat = new THREE.MeshLambertMaterial({ color: 0xfaf0e6 });
    var vineMat = new THREE.MeshLambertMaterial({ color: 0x2d5a1e });
    var flowerMat = new THREE.MeshLambertMaterial({ color: 0xff69b4 });

    // Two posts
    for (var s = -1; s <= 1; s += 2) {
      var post = new THREE.Mesh(
        new THREE.BoxGeometry(0.1 * scale, 3 * scale, 0.1 * scale),
        woodMat
      );
      post.position.x = s * 1.2 * scale;
      post.position.y = 1.5 * scale;
      group.add(post);
    }

    // Arch top (box curved approximation)
    var archSegments = 8;
    for (var a = 0; a < archSegments; a++) {
      var angle = (a / (archSegments - 1)) * Math.PI;
      var ax = Math.cos(angle) * 1.2 * scale;
      var ay = 3 * scale + Math.sin(angle) * 0.6 * scale;
      var seg = new THREE.Mesh(
        new THREE.BoxGeometry(0.35 * scale, 0.08 * scale, 0.1 * scale),
        woodMat
      );
      seg.position.x = ax;
      seg.position.y = ay;
      seg.rotation.z = angle - Math.PI / 2;
      group.add(seg);
    }

    // Vines wrapping around
    for (var v = 0; v < 8; v++) {
      var vineAngle = (v / 8) * Math.PI;
      var vine = new THREE.Mesh(
        new THREE.SphereGeometry(0.08 * scale, 5, 4),
        vineMat
      );
      vine.position.x = Math.cos(vineAngle) * 1.15 * scale;
      vine.position.y = 2.9 * scale + Math.sin(vineAngle) * 0.55 * scale;
      vine.position.z = (Math.random() - 0.5) * 0.15 * scale;
      group.add(vine);

      // Occasional flower
      if (Math.random() < 0.4) {
        var flower = new THREE.Mesh(
          new THREE.SphereGeometry(0.05 * scale, 5, 4),
          flowerMat
        );
        flower.position.copy(vine.position);
        flower.position.z += 0.1 * scale;
        group.add(flower);
      }
    }

    // Vine tendrils down the posts
    for (var side = -1; side <= 1; side += 2) {
      for (var tv = 0; tv < 4; tv++) {
        var tendril = new THREE.Mesh(
          new THREE.SphereGeometry(0.06 * scale, 4, 3),
          vineMat
        );
        tendril.position.x = side * 1.15 * scale + (Math.random() - 0.5) * 0.1 * scale;
        tendril.position.y = 0.5 + tv * 0.7 * scale;
        tendril.position.z = (Math.random() - 0.5) * 0.1 * scale;
        group.add(tendril);
      }
    }

    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.01;
    group.userData.swaySpeed = 1;

    return group;
  }

  function createBannerPole(color, scale) {
    scale = scale || 1;
    color = color || 0xcc0000;
    var group = new THREE.Group();
    group.name = 'banner_pole';

    // Pole
    var poleMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
    var pole = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04 * scale, 0.05 * scale, 4 * scale, 6),
      poleMat
    );
    pole.position.y = 2 * scale;
    group.add(pole);

    // Finial (top ornament)
    var finial = new THREE.Mesh(
      new THREE.SphereGeometry(0.08 * scale, 6, 6),
      new THREE.MeshPhongMaterial({ color: 0xdaa520 })
    );
    finial.position.y = 4.1 * scale;
    group.add(finial);

    // Banner (two triangles forming a flag)
    var bannerMat = new THREE.MeshLambertMaterial({ color: color, side: THREE.DoubleSide });
    var bannerGeo = new THREE.PlaneGeometry(0.8 * scale, 1.2 * scale);
    var banner = new THREE.Mesh(bannerGeo, bannerMat);
    banner.position.x = 0.4 * scale;
    banner.position.y = 3.4 * scale;
    group.add(banner);

    // Banner trim
    var trimMat = new THREE.MeshLambertMaterial({ color: 0xdaa520 });
    var trim = new THREE.Mesh(
      new THREE.BoxGeometry(0.82 * scale, 0.04 * scale, 0.02 * scale),
      trimMat
    );
    trim.position.x = 0.4 * scale;
    trim.position.y = 4 * scale;
    group.add(trim);

    group.userData.animationType = 'sway';
    group.userData.swayAmount = 0.03;
    group.userData.swaySpeed = 1.5;

    return group;
  }

  // ========================================
  // EXPORTS
  // ========================================

  exports.createTree = createTree;
  exports.createRock = createRock;
  exports.createBuilding = createBuilding;
  exports.createFurniture = createFurniture;
  exports.createCreature = createCreature;
  exports.createLandmark = createLandmark;
  exports.createResourceNode = createResourceNode;
  exports.createWildlife = createWildlife;
  exports.createGrassPatch = createGrassPatch;
  exports.createMushroom = createMushroom;
  exports.createBush = createBush;
  exports.createFallenLog = createFallenLog;
  exports.createRuinWall = createRuinWall;
  exports.createColumnRow = createColumnRow;
  exports.createAmphitheater = createAmphitheater;
  exports.createWishingWell = createWishingWell;
  exports.createBookshelf = createBookshelf;
  exports.createTorch = createTorch;
  exports.createBridge = createBridge;
  exports.createGardenArch = createGardenArch;
  exports.createBannerPole = createBannerPole;
  exports.animateModel = animateModel;

})(typeof module !== 'undefined' ? module.exports : (window.Models = {}));


// auth.js
(function(exports) {
  // GitHub App OAuth Configuration â€” Standard Web Flow (CORS-enabled for GitHub Apps)
  const OAUTH_CONFIG = {
    clientId: 'Iv23lixLqM3xo88npTs4',
    scope: 'read:user',
    authorizeUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://zion-oauth.kwildfeuer.workers.dev'
  };

  // Storage keys
  const TOKEN_KEY = 'zion_auth_token';
  const USERNAME_KEY = 'zion_username';
  const AVATAR_KEY = 'zion_avatar';

  // Helper: safe localStorage access
  function getStorage(key) {
    if (typeof localStorage === 'undefined') return null;
    try { return localStorage.getItem(key); } catch (e) { return null; }
  }
  function setStorage(key, value) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.setItem(key, value); } catch (e) {}
  }
  function removeStorage(key) {
    if (typeof localStorage === 'undefined') return;
    try { localStorage.removeItem(key); } catch (e) {}
  }

  /**
   * Initiate GitHub OAuth â€” redirects browser to GitHub authorization page.
   * After the user authorizes, GitHub redirects back with ?code= in the URL.
   */
  function initiateOAuth() {
    if (typeof window === 'undefined') return;
    var redirectUri = window.location.origin + window.location.pathname;
    var url = OAUTH_CONFIG.authorizeUrl +
      '?client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
      '&redirect_uri=' + encodeURIComponent(redirectUri) +
      '&scope=' + encodeURIComponent(OAUTH_CONFIG.scope);
    window.location.href = url;
  }

  /**
   * Handle OAuth callback â€” checks for ?code= in URL, exchanges for token.
   * GitHub Apps support CORS on the token exchange endpoint.
   * @returns {Promise<string|null>} access token or null if no code present
   */
  async function handleCallback() {
    if (typeof window === 'undefined') return null;
    var params = new URLSearchParams(window.location.search);
    var code = params.get('code');

    // Also handle legacy ?token= for PAT-based auth
    var token = params.get('token');
    if (token) {
      setStorage(TOKEN_KEY, token);
      window.history.replaceState({}, document.title, window.location.pathname);
      return token;
    }

    if (!code) return null;

    // Clean the URL immediately
    window.history.replaceState({}, document.title, window.location.pathname);

    try {
      // Exchange code for access token (CORS-enabled for GitHub Apps)
      // Use form-urlencoded to avoid CORS preflight (simple request)
      var res = await fetch(OAUTH_CONFIG.tokenUrl, {
        method: 'POST',
        headers: {
          'Accept': 'application/json'
        },
        body: 'client_id=' + encodeURIComponent(OAUTH_CONFIG.clientId) +
              '&code=' + encodeURIComponent(code)
      });

      if (!res.ok) {
        console.error('Token exchange failed:', res.status);
        return null;
      }

      var data = await res.json();
      if (data.access_token) {
        setStorage(TOKEN_KEY, data.access_token);
        // Fetch and store profile
        await getProfile(data.access_token);
        return data.access_token;
      } else {
        console.error('Token exchange error:', data.error, data.error_description);
        return null;
      }
    } catch (e) {
      console.error('OAuth callback error:', e);
      return null;
    }
  }

  /**
   * Fetch GitHub user profile
   */
  async function getProfile(token) {
    if (typeof fetch === 'undefined') throw new Error('fetch not available');
    var response = await fetch('https://api.github.com/user', {
      headers: { 'Authorization': 'Bearer ' + token, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!response.ok) throw new Error('GitHub API error: ' + response.status);
    var data = await response.json();
    setStorage(USERNAME_KEY, data.login);
    setStorage(AVATAR_KEY, data.avatar_url || '');
    return { username: data.login, avatar_url: data.avatar_url };
  }

  function isAuthenticated() { return !!getStorage(TOKEN_KEY); }
  function getUsername() { return getStorage(USERNAME_KEY); }
  function getToken() { return getStorage(TOKEN_KEY); }
  function setToken(token) { setStorage(TOKEN_KEY, token); }

  function loginAsGuest(username) {
    if (!username || typeof username !== 'string') return false;
    username = username.trim().replace(/[^a-zA-Z0-9_-]/g, '');
    if (username.length < 1 || username.length > 39) return false;
    setStorage(TOKEN_KEY, 'guest_' + username);
    setStorage(USERNAME_KEY, username);
    setStorage(AVATAR_KEY, '');
    return true;
  }

  function logout() {
    removeStorage(TOKEN_KEY);
    removeStorage(USERNAME_KEY);
    removeStorage(AVATAR_KEY);
  }

  // ========================================================================
  // PLAYER DATA PERSISTENCE â€” Save/load player state across sessions
  // ========================================================================

  var PLAYER_DATA_KEY = 'zion_player_data';
  var PLAYER_PREFS_KEY = 'zion_player_prefs';

  /**
   * Save player game data to localStorage
   * @param {Object} data - Player state to save
   */
  function savePlayerData(data) {
    if (!data) return;
    try {
      var saveData = {
        version: 2,
        ts: Date.now(),
        username: getUsername(),
        inventory: data.inventory || null,
        spark: data.spark || 0,
        position: data.position || null,
        zone: data.zone || 'nexus',
        skills: data.skills || null,
        questState: data.questState || null,
        achievements: data.achievements || null,
        guild: data.guild || null,
        discoveredSecrets: data.discoveredSecrets || [],
        warmth: data.warmth || 0,
        playTime: data.playTime || 0,
        lastSave: Date.now()
      };
      setStorage(PLAYER_DATA_KEY, JSON.stringify(saveData));
    } catch (e) {
      console.warn('Failed to save player data:', e);
    }
  }

  /**
   * Load player game data from localStorage
   * @returns {Object|null} Saved player data or null
   */
  function loadPlayerData() {
    try {
      var raw = getStorage(PLAYER_DATA_KEY);
      if (!raw) return null;
      var data = JSON.parse(raw);
      // Verify it belongs to current user
      if (data.username !== getUsername()) return null;
      return data;
    } catch (e) {
      console.warn('Failed to load player data:', e);
      return null;
    }
  }

  /**
   * Save player preferences
   * @param {Object} prefs - {volume, musicVolume, sfxVolume, quality, chatVisible, minimapVisible, showFPS}
   */
  function savePreferences(prefs) {
    try {
      setStorage(PLAYER_PREFS_KEY, JSON.stringify(prefs));
    } catch (e) {}
  }

  /**
   * Load player preferences
   * @returns {Object} Saved preferences or defaults
   */
  function loadPreferences() {
    try {
      var raw = getStorage(PLAYER_PREFS_KEY);
      if (!raw) return getDefaultPreferences();
      return JSON.parse(raw);
    } catch (e) {
      return getDefaultPreferences();
    }
  }

  function getDefaultPreferences() {
    return {
      volume: 0.5,
      musicVolume: 0.3,
      sfxVolume: 0.5,
      quality: 'medium',
      chatVisible: true,
      minimapVisible: true,
      showFPS: false,
      controlsHint: true
    };
  }

  /**
   * Get avatar URL for display
   * @returns {string} Avatar URL or empty string
   */
  function getAvatarUrl() {
    return getStorage(AVATAR_KEY) || '';
  }

  /**
   * Check if user is a guest
   * @returns {boolean}
   */
  function isGuest() {
    var token = getStorage(TOKEN_KEY);
    return token ? token.startsWith('guest_') : false;
  }

  /**
   * Get time since last save
   * @returns {number} Milliseconds since last save, or Infinity if never saved
   */
  function getTimeSinceLastSave() {
    var data = loadPlayerData();
    if (!data || !data.lastSave) return Infinity;
    return Date.now() - data.lastSave;
  }

  exports.OAUTH_CONFIG = OAUTH_CONFIG;
  exports.initiateOAuth = initiateOAuth;
  exports.handleCallback = handleCallback;
  exports.getProfile = getProfile;
  exports.isAuthenticated = isAuthenticated;
  exports.getUsername = getUsername;
  exports.getToken = getToken;
  exports.setToken = setToken;
  exports.loginAsGuest = loginAsGuest;
  exports.logout = logout;
  exports.savePlayerData = savePlayerData;
  exports.loadPlayerData = loadPlayerData;
  exports.savePreferences = savePreferences;
  exports.loadPreferences = loadPreferences;
  exports.getDefaultPreferences = getDefaultPreferences;
  exports.getAvatarUrl = getAvatarUrl;
  exports.isGuest = isGuest;
  exports.getTimeSinceLastSave = getTimeSinceLastSave;

})(typeof module !== 'undefined' ? module.exports : (window.Auth = {}));


// network.js
(function(exports) {
  // PeerJS mesh networking
  let peer = null;
  let connections = new Map(); // peerId -> connection
  let messageCallback = null;
  let peerConnectCallback = null;
  let peerDisconnectCallback = null;
  let seenMessages = new Set(); // For deduplication
  const MAX_SEEN_MESSAGES = 1000;

  /**
   * Initialize PeerJS mesh network
   * @param {string} peerId - Unique peer ID for this client
   * @param {object} options - Configuration
   * @param {function} options.onMessage - Callback for incoming messages (msg)
   * @param {function} options.onPeerConnect - Callback when peer connects (peerId)
   * @param {function} options.onPeerDisconnect - Callback when peer disconnects (peerId)
   */
  function initMesh(peerId, options = {}) {
    // Check if PeerJS is available
    if (typeof Peer === 'undefined') {
      console.warn('PeerJS not available. Network mesh disabled.');
      return null;
    }

    messageCallback = options.onMessage || (() => {});
    peerConnectCallback = options.onPeerConnect || (() => {});
    peerDisconnectCallback = options.onPeerDisconnect || (() => {});

    // Create peer with optional config
    peer = new Peer(peerId, {
      debug: 2 // Set to 3 for verbose logging
    });

    peer.on('open', (id) => {
      console.log('Mesh network initialized. Peer ID:', id);
    });

    peer.on('connection', (conn) => {
      handleConnection(conn);
    });

    peer.on('error', (err) => {
      // peer-unavailable is normal when lobby/seed peers don't exist yet
      if (err.type === 'peer-unavailable') {
        // Silently ignore â€” this just means no other players are online
        return;
      }
      console.error('Peer error:', err);
      // Auto-reconnect on network errors only
      if (err.type === 'network') {
        attemptReconnect(peerId, 0);
      }
    });

    peer.on('disconnected', () => {
      console.warn('Peer disconnected from signaling server');
      attemptReconnect(peerId, 0);
    });

    return peer;
  }

  /**
   * Handle incoming connection
   * @param {DataConnection} conn
   */
  function handleConnection(conn) {
    const remotePeerId = conn.peer;

    conn.on('open', () => {
      console.log('Connected to peer:', remotePeerId);
      connections.set(remotePeerId, conn);
      peerConnectCallback(remotePeerId);
    });

    conn.on('data', (data) => {
      handleIncomingMessage(data, remotePeerId);
    });

    conn.on('close', () => {
      console.log('Peer disconnected:', remotePeerId);
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });

    conn.on('error', (err) => {
      // Don't log errors for expected lobby/seed peer failures
      if (err && err.type !== 'peer-unavailable') {
        console.warn('Connection error with peer', remotePeerId, ':', err);
      }
      connections.delete(remotePeerId);
      peerDisconnectCallback(remotePeerId);
    });
  }

  /**
   * Handle incoming message with deduplication
   * @param {object} data
   * @param {string} fromPeer
   */
  function handleIncomingMessage(data, fromPeer) {
    try {
      const msg = typeof data === 'string' ? JSON.parse(data) : data;

      // Generate message ID for deduplication
      const msgId = generateMessageId(msg);

      // Check if already seen
      if (seenMessages.has(msgId)) {
        return; // Duplicate, ignore
      }

      // Add to seen messages
      seenMessages.add(msgId);

      // Evict oldest if over limit
      if (seenMessages.size > MAX_SEEN_MESSAGES) {
        const firstItem = seenMessages.values().next().value;
        seenMessages.delete(firstItem);
      }

      // Relay to other peers (mesh propagation)
      relayMessage(msg, fromPeer);

      // Invoke callback
      messageCallback(msg);
    } catch (err) {
      console.error('Error handling message:', err);
    }
  }

  /**
   * Generate unique message ID for deduplication
   * @param {object} msg
   * @returns {string}
   */
  function generateMessageId(msg) {
    // Use message fields to create unique ID
    const str = JSON.stringify({
      type: msg.type,
      from: msg.from,
      timestamp: msg.timestamp,
      nonce: msg.nonce
    });
    return simpleHash(str);
  }

  /**
   * Simple hash function
   * @param {string} str
   * @returns {string}
   */
  function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  /**
   * Relay message to all peers except sender
   * @param {object} msg
   * @param {string} excludePeer
   */
  function relayMessage(msg, excludePeer) {
    connections.forEach((conn, peerId) => {
      if (peerId !== excludePeer && conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error relaying to peer', peerId, ':', err);
        }
      }
    });
  }

  /**
   * Broadcast message to all connected peers
   * @param {object} msg - Message object (will be JSON serialized)
   */
  function broadcastMessage(msg) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    // Add to seen messages to prevent echo
    const msgId = generateMessageId(msg);
    seenMessages.add(msgId);

    connections.forEach((conn, peerId) => {
      if (conn.open) {
        try {
          conn.send(msg);
        } catch (err) {
          console.error('Error sending to peer', peerId, ':', err);
        }
      }
    });
  }

  /**
   * Register message handler
   * @param {function} callback
   */
  function onMessage(callback) {
    messageCallback = callback;
  }

  /**
   * Get list of connected peer IDs
   * @returns {string[]}
   */
  function getPeers() {
    return Array.from(connections.keys());
  }

  /**
   * Connect to a specific peer
   * @param {string} peerId
   */
  function connectToPeer(peerId) {
    if (!peer) {
      console.warn('Peer not initialized');
      return;
    }

    if (connections.has(peerId)) {
      console.log('Already connected to peer:', peerId);
      return;
    }

    console.log('Connecting to peer:', peerId);
    const conn = peer.connect(peerId, {
      reliable: true
    });

    handleConnection(conn);
  }

  /**
   * Disconnect from all peers and destroy peer
   */
  function disconnect() {
    if (!peer) return;

    connections.forEach((conn) => {
      conn.close();
    });

    connections.clear();
    peer.destroy();
    peer = null;

    console.log('Disconnected from mesh network');
  }

  /**
   * Attempt to reconnect with exponential backoff
   * @param {string} peerId
   * @param {number} attempt
   */
  function attemptReconnect(peerId, attempt) {
    const maxAttempts = 3;
    if (attempt >= maxAttempts) {
      console.log('Max reconnection attempts reached, will retry on next discovery cycle');
      return;
    }

    const delay = Math.pow(2, attempt) * 1000; // Exponential: 1s, 2s, 4s
    console.log(`Reconnecting in ${delay}ms (attempt ${attempt + 1}/${maxAttempts})`);

    setTimeout(() => {
      if (!peer || peer.destroyed) {
        console.log('Attempting to reconnect...');
        peer.reconnect();

        // Check if reconnection succeeded after 2 seconds
        setTimeout(() => {
          if (peer && !peer.open) {
            attemptReconnect(peerId, attempt + 1);
          }
        }, 2000);
      }
    }, delay);
  }

  /**
   * Generate lobby peer ID from world ID
   * @param {string} worldId - World identifier (default: 'main')
   * @returns {string}
   */
  function getLobbyPeerId(worldId = 'main') {
    return `zion-lobby-${worldId}`;
  }

  // ========================================================================
  // LOBBY SYSTEM â€” Automatic peer discovery
  // ========================================================================

  var lobbyState = {
    peerId: null,
    worldId: 'main',
    discoveryInterval: null,
    knownPeers: [],       // All peer IDs ever seen
    heartbeatInterval: null,
    playerName: '',
    zone: 'nexus',
    lastAnnounce: 0
  };

  /**
   * Join the world lobby for automatic peer discovery.
   * Uses a well-known lobby peer ID that the first player to join becomes.
   * Others connect to the lobby peer and receive the full peer list.
   */
  function joinLobby(worldId, playerName, zone) {
    lobbyState.worldId = worldId || 'main';
    lobbyState.playerName = playerName || 'Anonymous';
    lobbyState.zone = zone || 'nexus';

    if (!peer) return;

    lobbyState.peerId = peer.id;

    // Try connecting to the lobby peer
    var lobbyId = getLobbyPeerId(lobbyState.worldId);

    if (peer.id !== lobbyId) {
      // Not the lobby â€” try connecting to it
      connectToPeer(lobbyId);
    }

    // Also try a list of "seed" peer IDs derived from the world
    // This creates a gossip-based discovery pattern
    var seedCount = 5;
    for (var i = 0; i < seedCount; i++) {
      var seedId = 'zion-seed-' + lobbyState.worldId + '-' + i;
      if (seedId !== peer.id) {
        connectToPeer(seedId);
      }
    }

    // Periodically announce presence and discover peers
    if (lobbyState.discoveryInterval) {
      clearInterval(lobbyState.discoveryInterval);
    }

    lobbyState.discoveryInterval = setInterval(function() {
      announcePresence();
    }, 10000); // Every 10 seconds

    // Start heartbeat
    if (lobbyState.heartbeatInterval) {
      clearInterval(lobbyState.heartbeatInterval);
    }

    lobbyState.heartbeatInterval = setInterval(function() {
      sendHeartbeat();
    }, 30000); // Every 30 seconds

    // Initial announce
    announcePresence();
  }

  function announcePresence() {
    if (!peer || !peer.open) return;

    var announcement = {
      type: '_lobby_announce',
      peerId: peer.id,
      playerName: lobbyState.playerName,
      zone: lobbyState.zone,
      peers: getPeers(), // Share our peer list for gossip
      timestamp: Date.now()
    };

    broadcastMessage(announcement);
    lobbyState.lastAnnounce = Date.now();
  }

  function sendHeartbeat() {
    if (!peer || !peer.open) return;

    broadcastMessage({
      type: '_heartbeat',
      peerId: peer.id,
      zone: lobbyState.zone,
      peerCount: connections.size,
      timestamp: Date.now()
    });
  }

  /**
   * Handle lobby-specific messages (called from handleIncomingMessage)
   */
  function handleLobbyMessage(msg) {
    if (!msg || !msg.type) return false;

    // Check if it's a federation message first
    if (handleFederationMessage(msg)) {
      return true;
    }

    if (msg.type === '_lobby_announce') {
      // Someone announced â€” connect to their known peers
      if (msg.peers && Array.isArray(msg.peers)) {
        msg.peers.forEach(function(peerId) {
          if (peerId !== peer.id && !connections.has(peerId)) {
            // Track known peer
            if (lobbyState.knownPeers.indexOf(peerId) === -1) {
              lobbyState.knownPeers.push(peerId);
            }
            // Try connecting if we have room
            if (connections.size < 20) {
              connectToPeer(peerId);
            }
          }
        });
      }
      return true; // Handled
    }

    if (msg.type === '_heartbeat') {
      // Update known peer activity
      return true; // Handled, don't propagate to game
    }

    if (msg.type === '_peer_list_request') {
      // Someone asking for our peer list
      broadcastMessage({
        type: '_lobby_announce',
        peerId: peer.id,
        playerName: lobbyState.playerName,
        zone: lobbyState.zone,
        peers: getPeers(),
        timestamp: Date.now()
      });
      return true;
    }

    return false; // Not a lobby message
  }

  function updateLobbyZone(zone) {
    lobbyState.zone = zone;
  }

  function leaveLobby() {
    if (lobbyState.discoveryInterval) {
      clearInterval(lobbyState.discoveryInterval);
      lobbyState.discoveryInterval = null;
    }
    if (lobbyState.heartbeatInterval) {
      clearInterval(lobbyState.heartbeatInterval);
      lobbyState.heartbeatInterval = null;
    }
  }

  function getNetworkStats() {
    return {
      peerId: peer ? peer.id : null,
      connected: peer ? peer.open : false,
      peerCount: connections.size,
      knownPeers: lobbyState.knownPeers.length,
      seenMessages: seenMessages.size
    };
  }

  // ========================================================================
  // FEDERATION SYSTEM â€” Cross-world connectivity
  // ========================================================================

  var federationState = {
    worldId: null,
    worldName: null,
    endpoint: null,
    federatedPeers: new Map(), // worldId -> {peerId, connection, worldInfo}
    federationCallback: null,
    discoveredWorlds: new Map() // worldId -> worldInfo
  };

  /**
   * Initialize federation for this world
   * @param {string} worldId - Unique world identifier (derived from URL)
   * @param {string} worldName - Human-readable world name
   * @param {string} endpoint - Public endpoint URL (e.g., GitHub Pages URL)
   */
  function initFederation(worldId, worldName, endpoint) {
    federationState.worldId = worldId;
    federationState.worldName = worldName || worldId;
    federationState.endpoint = endpoint;

    console.log('Federation initialized for world:', worldId);
  }

  /**
   * Generate federated peer ID for cross-world connections
   * @param {string} worldId - World identifier
   * @param {string} playerId - Player identifier
   * @returns {string}
   */
  function getFederatedPeerId(worldId, playerId) {
    return `zion-fed-${worldId}-${playerId}`;
  }

  /**
   * Announce this world to the federation network
   * Broadcasts availability for cross-world connections
   */
  function announceFederation() {
    if (!peer || !peer.open) return;
    if (!federationState.worldId) {
      console.warn('Federation not initialized');
      return;
    }

    var announcement = {
      type: 'federation_announce',
      worldId: federationState.worldId,
      worldName: federationState.worldName,
      endpoint: federationState.endpoint,
      protocolVersion: 1,
      playerCount: connections.size,
      peerId: peer.id,
      timestamp: Date.now()
    };

    broadcastMessage(announcement);
    console.log('Federation announced:', federationState.worldName);
  }

  /**
   * Establish handshake with a federated world
   * @param {string} targetWorldId - Target world identifier
   * @param {object} worldInfo - Information about target world
   */
  function federationHandshake(targetWorldId, worldInfo) {
    if (!peer || !peer.open) return;
    if (!federationState.worldId) {
      console.warn('Federation not initialized');
      return;
    }

    // Generate federated peer ID for the target world
    var federatedPeerId = getFederatedPeerId(targetWorldId, lobbyState.peerId);

    // Check if already connected
    if (federationState.federatedPeers.has(targetWorldId)) {
      console.log('Already federated with world:', targetWorldId);
      return;
    }

    // Send handshake message
    var handshake = {
      type: 'federation_handshake',
      from_world: federationState.worldId,
      to_world: targetWorldId,
      worldName: federationState.worldName,
      endpoint: federationState.endpoint,
      protocolVersion: 1,
      peerId: peer.id,
      timestamp: Date.now()
    };

    broadcastMessage(handshake);

    // Store federated world info
    federationState.federatedPeers.set(targetWorldId, {
      worldId: targetWorldId,
      worldInfo: worldInfo,
      peerId: federatedPeerId,
      status: 'handshake_sent',
      timestamp: Date.now()
    });

    console.log('Federation handshake sent to:', targetWorldId);
  }

  /**
   * Handle incoming federation messages
   * @param {object} msg - Federation message
   * @returns {boolean} True if message was handled
   */
  function handleFederationMessage(msg) {
    if (!msg || !msg.type) return false;

    if (msg.type === 'federation_announce') {
      // Another world announced itself
      var worldId = msg.worldId || msg.payload?.worldId;
      if (worldId && worldId !== federationState.worldId) {
        var worldInfo = {
          worldId: worldId,
          worldName: msg.worldName || msg.payload?.worldName,
          endpoint: msg.endpoint || msg.payload?.endpoint,
          protocolVersion: msg.protocolVersion || msg.payload?.protocolVersion || 1,
          playerCount: msg.playerCount || msg.payload?.playerCount || 0,
          peerId: msg.peerId || msg.payload?.peerId,
          timestamp: msg.timestamp || Date.now()
        };

        // Track discovered world
        federationState.discoveredWorlds.set(worldId, worldInfo);

        // Notify callback
        if (federationState.federationCallback) {
          federationState.federationCallback({
            type: 'world_discovered',
            worldInfo: worldInfo
          });
        }

        console.log('Discovered federated world:', worldInfo.worldName);
      }
      return true;
    }

    if (msg.type === 'federation_handshake') {
      // Another world wants to federate with us
      var fromWorld = msg.from_world || msg.payload?.from_world;
      var toWorld = msg.to_world || msg.payload?.to_world;

      if (toWorld === federationState.worldId && fromWorld) {
        var worldInfo = {
          worldId: fromWorld,
          worldName: msg.worldName || msg.payload?.worldName,
          endpoint: msg.endpoint || msg.payload?.endpoint,
          protocolVersion: msg.protocolVersion || msg.payload?.protocolVersion || 1,
          peerId: msg.peerId || msg.payload?.peerId,
          timestamp: msg.timestamp || Date.now()
        };

        // Check if we already have a federation with this world
        var existing = federationState.federatedPeers.get(fromWorld);
        if (existing && existing.status === 'active') {
          console.log('Federation already active with:', fromWorld);
          return true;
        }

        // Store federated world
        federationState.federatedPeers.set(fromWorld, {
          worldId: fromWorld,
          worldInfo: worldInfo,
          status: 'active',
          timestamp: Date.now()
        });

        // Notify callback
        if (federationState.federationCallback) {
          federationState.federationCallback({
            type: 'federation_established',
            worldInfo: worldInfo
          });
        }

        console.log('Federation established with:', worldInfo.worldName);
      }
      return true;
    }

    if (msg.type === 'warp_fork') {
      // Player warping between federated worlds
      if (federationState.federationCallback) {
        federationState.federationCallback({
          type: 'cross_world_warp',
          playerId: msg.from,
          targetWorld: msg.payload?.target_world,
          position: msg.payload?.position
        });
      }
      return true;
    }

    if (msg.type === 'return_home') {
      // Player returning from federated world
      if (federationState.federationCallback) {
        federationState.federationCallback({
          type: 'player_returned',
          playerId: msg.from,
          position: msg.payload?.position
        });
      }
      return true;
    }

    return false;
  }

  /**
   * Register callback for federation events
   * @param {function} callback - Called with federation events
   */
  function onFederationEvent(callback) {
    federationState.federationCallback = callback;
  }

  /**
   * Get list of federated worlds
   * @returns {Array} Array of federated world info
   */
  function getFederatedWorlds() {
    return Array.from(federationState.federatedPeers.values());
  }

  /**
   * Get list of discovered worlds
   * @returns {Array} Array of discovered world info
   */
  function getDiscoveredWorlds() {
    return Array.from(federationState.discoveredWorlds.values());
  }

  /**
   * Check if connected to a specific world
   * @param {string} worldId - World identifier
   * @returns {boolean}
   */
  function isFederatedWith(worldId) {
    var fed = federationState.federatedPeers.get(worldId);
    return fed && fed.status === 'active';
  }

  /**
   * Get world ID derived from current URL
   * @returns {string}
   */
  function deriveWorldId() {
    if (typeof window === 'undefined' || !window.location) {
      return 'localhost';
    }

    var url = window.location.href;
    // Extract meaningful part from URL (e.g., github.io/repo-name)
    var match = url.match(/github\.io\/([^\/]+)/);
    if (match) {
      return match[1];
    }

    // Fallback to hostname
    return window.location.hostname.replace(/\./g, '-');
  }

  // Export public API
  exports.initMesh = initMesh;
  exports.broadcastMessage = broadcastMessage;
  exports.onMessage = onMessage;
  exports.getPeers = getPeers;
  exports.connectToPeer = connectToPeer;
  exports.disconnect = disconnect;
  exports.getLobbyPeerId = getLobbyPeerId;
  exports.joinLobby = joinLobby;
  exports.leaveLobby = leaveLobby;
  exports.updateLobbyZone = updateLobbyZone;
  exports.handleLobbyMessage = handleLobbyMessage;
  exports.getNetworkStats = getNetworkStats;

  // Federation exports
  exports.initFederation = initFederation;
  exports.announceFederation = announceFederation;
  exports.federationHandshake = federationHandshake;
  exports.handleFederationMessage = handleFederationMessage;
  exports.onFederationEvent = onFederationEvent;
  exports.getFederatedWorlds = getFederatedWorlds;
  exports.getDiscoveredWorlds = getDiscoveredWorlds;
  exports.isFederatedWith = isFederatedWith;
  exports.deriveWorldId = deriveWorldId;
  exports.getFederatedPeerId = getFederatedPeerId;

})(typeof module !== 'undefined' ? module.exports : (window.Network = {}));


// federation.js
// federation.js â€” Federation Bridge for ZION (Article X of the Constitution)
// Implements Â§10.1-10.9: sovereign fork connections, cross-world travel, rift portals
(function(exports) {
  'use strict';

  // â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var PROTOCOL_VERSION = 1;
  var FEDERATION_ANNOUNCE = 'federation_announce';
  var FEDERATION_HANDSHAKE = 'federation_handshake';
  var WARP_FORK = 'warp_fork';
  var RETURN_HOME = 'return_home';

  // Latency threshold (ms) below which connection is considered healthy
  var HEALTHY_LATENCY_THRESHOLD = 200;

  // â”€â”€â”€ Internal State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Active connections map: worldId â†’ connection object
  var connections = {};

  // Visitor registry: players currently visiting THIS world from another fork
  var visitors = [];

  // Visiting registry: players from THIS world currently visiting another fork
  var visiting = [];

  // â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function generateUUID() {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  function now() {
    return new Date().toISOString();
  }

  /**
   * Build a minimal protocol message envelope.
   * All federation messages use platform='api' since they are server/bot originated.
   */
  function buildMessage(type, from, payload) {
    return {
      v: PROTOCOL_VERSION,
      id: generateUUID(),
      ts: now(),
      seq: 0,
      from: from || 'federation',
      type: type,
      platform: 'api',
      position: { x: 0, y: 0, z: 0, zone: 'nexus' },
      geo: null,
      payload: payload || {}
    };
  }

  // â”€â”€â”€ Discovery & Handshake â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Generate a federation_announce message advertising this world.
   * Â§10.2 step 1: Fork A sends federation_announce with world ID, protocol version, endpoint.
   *
   * @param {Object} worldConfig - {worldId, worldName, endpoint, protocolVersion, adminUser?}
   * @returns {Object} Protocol message of type federation_announce
   */
  function announce(worldConfig) {
    return buildMessage(FEDERATION_ANNOUNCE, worldConfig.adminUser || worldConfig.worldId, {
      worldId: worldConfig.worldId,
      worldName: worldConfig.worldName,
      endpoint: worldConfig.endpoint,
      protocolVersion: worldConfig.protocolVersion || PROTOCOL_VERSION,
      announcedAt: now()
    });
  }

  /**
   * Handle an incoming federation_announce message.
   * Â§10.2 step 2: Decides whether to accept the connection.
   *
   * @param {Object} message - Incoming federation_announce message
   * @param {string} [localWorldId] - This world's ID (to reject self-connections)
   * @returns {{accept: boolean, reason?: string}}
   */
  function handleAnnounce(message, localWorldId) {
    if (!message || !message.payload) {
      return { accept: false, reason: 'Invalid or missing announcement message' };
    }

    var p = message.payload;

    // Must be a federation_announce message
    if (message.type !== FEDERATION_ANNOUNCE) {
      return { accept: false, reason: 'Message is not a federation_announce' };
    }

    // Must have required fields
    if (!p.worldId || !p.worldName || !p.endpoint) {
      return { accept: false, reason: 'Missing required fields: worldId, worldName, or endpoint' };
    }

    // Â§10.9 No imperial fork â€” reject self-connections
    if (localWorldId && p.worldId === localWorldId) {
      return { accept: false, reason: 'Self-connection rejected: cannot federate with yourself' };
    }

    // Â§10.8 Protocol compatibility check
    var versionCheck = validateProtocolVersion(PROTOCOL_VERSION, p.protocolVersion);
    if (!versionCheck.compatible) {
      return { accept: false, reason: 'Protocol version incompatible: ' + versionCheck.reason };
    }

    return { accept: true };
  }

  /**
   * Generate a federation_handshake message accepting (or declining) a connection.
   * Â§10.2 step 3: Fork B sends federation_handshake.
   *
   * @param {string} targetWorldId - The remote world's ID
   * @param {Object} localConfig - This world's config
   * @param {Object} remoteConfig - Remote world's config (for validation)
   * @returns {Object} Protocol message of type federation_handshake
   */
  function handshake(targetWorldId, localConfig, remoteConfig) {
    var accepted = true;

    // Check protocol compatibility (Â§10.8)
    if (accepted && remoteConfig) {
      var versionCheck = validateProtocolVersion(
        localConfig.protocolVersion || PROTOCOL_VERSION,
        remoteConfig.protocolVersion || PROTOCOL_VERSION
      );
      if (!versionCheck.compatible) {
        accepted = false;
      }
    }

    return buildMessage(FEDERATION_HANDSHAKE, localConfig.adminUser || localConfig.worldId, {
      worldId: localConfig.worldId,
      worldName: localConfig.worldName,
      endpoint: localConfig.endpoint,
      protocolVersion: localConfig.protocolVersion || PROTOCOL_VERSION,
      targetWorldId: targetWorldId,
      accepted: accepted,
      handshakeAt: now()
    });
  }

  /**
   * Handle an incoming federation_handshake message.
   * If accepted, creates and registers a connection object.
   *
   * @param {Object} message - Incoming federation_handshake message
   * @param {Object} localConfig - This world's config
   * @returns {Object|null} Connection object, or null if not accepted
   */
  function handleHandshake(message, localConfig) {
    if (!message || !message.payload) {
      return null;
    }

    var p = message.payload;

    if (!p.accepted) {
      return null;
    }

    // Â§10.9 No imperial fork â€” reject self-connections at reception
    if (localConfig && p.worldId === localConfig.worldId) {
      return null;
    }

    // Build connection object
    var conn = {
      worldId: p.worldId,
      worldName: p.worldName,
      endpoint: p.endpoint,
      protocolVersion: p.protocolVersion || PROTOCOL_VERSION,
      status: 'active',
      connectedSince: now(),
      lastHeartbeat: now(),
      playerCount: 0,
      latency: 0
    };

    // Register the connection
    connections[conn.worldId] = conn;

    return conn;
  }

  // â”€â”€â”€ Connection Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Register or update a connection in the registry.
   * Handles duplicate connections by updating in place (Â§10.9 peer-to-peer equals).
   *
   * @param {Object} connObj - Connection data {worldId, worldName, endpoint, ...}
   */
  function connect(connObj) {
    if (!connObj || !connObj.worldId) {
      return;
    }
    // Update-in-place for duplicates
    connections[connObj.worldId] = Object.assign({}, connObj, {
      status: connObj.status || 'active'
    });
  }

  /**
   * Disconnect a world by worldId. Generates a leave message and marks as disconnected.
   *
   * @param {string} worldId
   * @returns {Object|null} Protocol message, or null if world was not connected
   */
  function disconnect(worldId) {
    if (!connections[worldId]) {
      return null;
    }

    var conn = connections[worldId];
    connections[worldId] = Object.assign({}, conn, { status: 'disconnected' });

    return buildMessage('leave', conn.worldId, {
      worldId: worldId,
      reason: 'federation_dissolved',
      disconnectedAt: now()
    });
  }

  /**
   * Returns all active (non-disconnected) connections.
   *
   * @returns {Array<{worldId, worldName, status, playerCount, latency}>}
   */
  function getConnections() {
    return Object.values(connections).filter(function(c) {
      return c.status === 'active';
    });
  }

  /**
   * Returns whether a world is currently actively connected.
   *
   * @param {string} worldId
   * @returns {boolean}
   */
  function isConnected(worldId) {
    return !!(connections[worldId] && connections[worldId].status === 'active');
  }

  // â”€â”€â”€ Cross-World Travel (Â§10.3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Prepare to travel to a federated fork.
   * Generates a warp_fork protocol message and a travelPack.
   *
   * TravelPack includes (Â§10.3): identity, reputation, appearance, intentions, skills
   * TravelPack EXCLUDES: inventory, spark, gardens, structures, steward status
   *
   * @param {string} worldId - Target fork's world ID
   * @param {Object} player - Player state object
   * @returns {{message: Object, travelPack: Object}}
   */
  function warpToFork(worldId, player) {
    // Build travelPack â€” only what travels per Â§10.3
    var travelPack = {
      username: player.username,
      homeWorld: player.homeWorld,
      reputation: player.reputation || 0,
      appearance: player.appearance ? JSON.parse(JSON.stringify(player.appearance)) : {},
      intentions: player.intentions ? JSON.parse(JSON.stringify(player.intentions)) : [],
      skills: player.skills ? JSON.parse(JSON.stringify(player.skills)) : [],
      travelerMarks: player.travelerMarks ? JSON.parse(JSON.stringify(player.travelerMarks)) : [],
      departedAt: now()
    };

    var message = buildMessage(WARP_FORK, player.username, {
      fork_id: worldId,
      destination_zone: 'nexus',   // Â§10.4 visitors start in Nexus
      travelPack: travelPack
    });

    return { message: message, travelPack: travelPack };
  }

  /**
   * Handle a player arriving from a fork.
   * Creates a local visitor player state in the visited world.
   *
   * @param {Object} travelPack - The travelPack from warpToFork
   * @returns {Object} Visitor player state for the visited world
   */
  function arriveFromFork(travelPack) {
    var visitor = {
      username: travelPack.username,
      homeWorld: travelPack.homeWorld,
      reputation: travelPack.reputation || 0,
      appearance: travelPack.appearance ? JSON.parse(JSON.stringify(travelPack.appearance)) : {},
      intentions: travelPack.intentions ? JSON.parse(JSON.stringify(travelPack.intentions)) : [],
      skills: travelPack.skills ? JSON.parse(JSON.stringify(travelPack.skills)) : [],
      travelerMarks: travelPack.travelerMarks ? JSON.parse(JSON.stringify(travelPack.travelerMarks)) : [],
      // Visitor-specific state
      isVisitor: true,
      arrivedAt: now(),
      inventory: [],      // arrive with empty hands (Â§10.3)
      spark: 0,           // currency is sovereign (Â§10.3)
      isSteward: false,   // governance is local (Â§10.3)
      // Start in nexus (Â§10.4)
      position: { x: 0, y: 0, z: 0, zone: 'nexus' }
    };

    return visitor;
  }

  /**
   * Generate a return_home protocol message for a visiting player.
   * Â§10.4: A visitor can return_home at any time.
   *
   * @param {Object} player - Visiting player state
   * @returns {Object} Protocol message of type return_home
   */
  function returnHome(player) {
    return buildMessage(RETURN_HOME, player.username, {
      homeWorld: player.homeWorld,
      departedAt: now()
    });
  }

  // â”€â”€â”€ Visitor Management (Â§10.4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Register an arriving visitor into the local visitor registry.
   *
   * @param {Object} visitor - Visitor state (from arriveFromFork)
   */
  function registerVisitor(visitor) {
    // Remove any existing entry for this visitor
    visitors = visitors.filter(function(v) { return v.username !== visitor.username; });
    visitors.push({
      username: visitor.username,
      homeWorld: visitor.homeWorld,
      arrivedAt: visitor.arrivedAt || now()
    });
  }

  /**
   * Returns all players currently visiting THIS world from other forks.
   *
   * @returns {Array<{username, homeWorld, arrivedAt}>}
   */
  function getVisitors() {
    return visitors.slice();
  }

  /**
   * Returns all players from THIS world who are currently visiting other forks.
   *
   * @returns {Array<{username, visitingWorld, departedAt}>}
   */
  function getVisiting() {
    return visiting.slice();
  }

  // â”€â”€â”€ Rift Portal (Â§10.5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create a Rift Portal object representing a federation connection's portal in the Nexus.
   * Â§10.5: Displays world name, player count, latency indicator, description.
   *
   * @param {Object} connection - Connection data
   * @returns {Object} Portal display data
   */
  function createRiftPortal(connection) {
    var healthy = (connection.latency || 0) < HEALTHY_LATENCY_THRESHOLD && connection.status === 'active';

    return {
      worldId: connection.worldId,
      worldName: connection.worldName,
      playerCount: connection.playerCount || 0,
      latency: connection.latency || 0,
      healthy: healthy,
      description: connection.description || '',
      position: {
        x: 0, y: 0, z: -20,    // Rift portals placed at Nexus center near the hub
        zone: 'nexus'
      },
      type: 'rift_portal',
      createdAt: now()
    };
  }

  /**
   * Update portal data from a connection (e.g. after heartbeat).
   *
   * @param {Object} connection - Updated connection data
   * @returns {Object} Updated portal display data
   */
  function updateRiftPortal(connection) {
    return createRiftPortal(connection);
  }

  // â”€â”€â”€ Registry (Â§10.7) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Load and parse the federation.json registry.
   *
   * @param {Object} federationJson - Parsed federation.json contents
   * @returns {Object} Parsed registry with federations array
   */
  function loadRegistry(federationJson) {
    if (!federationJson) {
      return { worldId: '', worldName: '', federations: [], discoveredWorlds: [] };
    }

    return {
      worldId: federationJson.worldId || '',
      worldName: federationJson.worldName || '',
      endpoint: federationJson.endpoint || '',
      protocolVersion: federationJson.protocolVersion || PROTOCOL_VERSION,
      federations: (federationJson.federations || []).map(function(f) {
        return {
          worldId: f.worldId,
          worldName: f.worldName,
          endpoint: f.endpoint,
          protocolVersion: f.protocolVersion || PROTOCOL_VERSION,
          federatedSince: f.federatedSince || null,
          status: f.status || 'unknown',
          playerCount: f.playerCount || 0,
          lastHeartbeat: f.lastHeartbeat || null
        };
      }),
      discoveredWorlds: federationJson.discoveredWorlds || [],
      lastAnnounce: federationJson.lastAnnounce || null
    };
  }

  /**
   * Serialize active connections into the federation.json registry shape.
   * Â§10.7: The Multiverse Registry is a public JSON file.
   *
   * @param {Array} activeConnections - Array of connection objects
   * @returns {Object} Updated federation JSON object
   */
  function updateRegistry(activeConnections) {
    return {
      federations: (activeConnections || []).map(function(conn) {
        return {
          worldId: conn.worldId,
          worldName: conn.worldName,
          endpoint: conn.endpoint,
          protocolVersion: conn.protocolVersion || PROTOCOL_VERSION,
          federatedSince: conn.connectedSince || null,
          status: conn.status || 'active',
          playerCount: conn.playerCount || 0,
          lastHeartbeat: conn.lastHeartbeat || null
        };
      }),
      updatedAt: now()
    };
  }

  /**
   * Returns all worlds with status 'active' from the internal connections registry.
   *
   * @returns {Array<{worldId, worldName, endpoint, status, playerCount}>}
   */
  function getActiveWorlds() {
    return getConnections().map(function(conn) {
      return {
        worldId: conn.worldId,
        worldName: conn.worldName,
        endpoint: conn.endpoint,
        status: conn.status,
        playerCount: conn.playerCount || 0
      };
    });
  }

  // â”€â”€â”€ Validation (Â§10.8) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Check whether two protocol versions are compatible.
   * Â§10.8: Incompatible forks cannot federate.
   * For now, exact major version match is required.
   *
   * @param {number} local - Local protocol version
   * @param {number} remote - Remote protocol version
   * @returns {{compatible: boolean, reason?: string}}
   */
  function validateProtocolVersion(local, remote) {
    if (!remote || remote <= 0) {
      return { compatible: false, reason: 'Remote protocol version is missing or invalid (got ' + remote + ')' };
    }

    if (!local || local <= 0) {
      return { compatible: false, reason: 'Local protocol version is missing or invalid (got ' + local + ')' };
    }

    if (local !== remote) {
      return {
        compatible: false,
        reason: 'Protocol version mismatch: local=' + local + ', remote=' + remote
      };
    }

    return { compatible: true };
  }

  /**
   * Validate an incoming federation request message (announce or handshake).
   * Â§10.8: Both worlds must speak the same protocol.
   *
   * @param {Object} message - Incoming protocol message
   * @param {Object} localConfig - This world's config
   * @returns {{valid: boolean, reason?: string}}
   */
  function validateFederationRequest(message, localConfig) {
    if (!message || typeof message !== 'object') {
      return { valid: false, reason: 'Message must be an object' };
    }

    // Must be a federation message type
    if (message.type !== FEDERATION_ANNOUNCE && message.type !== FEDERATION_HANDSHAKE) {
      return {
        valid: false,
        reason: 'Message type must be federation_announce or federation_handshake, got: ' + message.type
      };
    }

    // Payload must exist and have worldId
    if (!message.payload || !message.payload.worldId) {
      return { valid: false, reason: 'Payload must include worldId' };
    }

    // Protocol version must be compatible (Â§10.8)
    var versionCheck = validateProtocolVersion(
      (localConfig && localConfig.protocolVersion) || PROTOCOL_VERSION,
      message.payload.protocolVersion
    );
    if (!versionCheck.compatible) {
      return { valid: false, reason: 'Protocol incompatible: ' + versionCheck.reason };
    }

    return { valid: true };
  }

  // â”€â”€â”€ State Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Return a serializable snapshot of the federation module state.
   * Useful for persistence and debugging.
   *
   * @returns {Object} Serializable state
   */
  function getState() {
    return {
      connections: JSON.parse(JSON.stringify(connections)),
      visitors: JSON.parse(JSON.stringify(visitors)),
      visiting: JSON.parse(JSON.stringify(visiting))
    };
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.PROTOCOL_VERSION = PROTOCOL_VERSION;

  // Discovery & Handshake
  exports.announce = announce;
  exports.handleAnnounce = handleAnnounce;
  exports.handshake = handshake;
  exports.handleHandshake = handleHandshake;

  // Connection Management
  exports.connect = connect;
  exports.disconnect = disconnect;
  exports.getConnections = getConnections;
  exports.isConnected = isConnected;

  // Cross-World Travel (Â§10.3)
  exports.warpToFork = warpToFork;
  exports.arriveFromFork = arriveFromFork;
  exports.returnHome = returnHome;

  // Visitor Management (Â§10.4)
  exports.registerVisitor = registerVisitor;
  exports.getVisitors = getVisitors;
  exports.getVisiting = getVisiting;

  // Rift Portal (Â§10.5)
  exports.createRiftPortal = createRiftPortal;
  exports.updateRiftPortal = updateRiftPortal;

  // Registry (Â§10.7)
  exports.loadRegistry = loadRegistry;
  exports.updateRegistry = updateRegistry;
  exports.getActiveWorlds = getActiveWorlds;

  // Validation (Â§10.8)
  exports.validateProtocolVersion = validateProtocolVersion;
  exports.validateFederationRequest = validateFederationRequest;

  // State
  exports.getState = getState;

})(typeof module !== 'undefined' ? module.exports : (window.Federation = {}));


// rift_portal.js
// rift_portal.js â€” Federation Rift Portal 3D Rendering for ZION
// Constitution Â§10.5: Rift Portals are shimmering, otherworldly, clearly marked
// with destination world's name and player count.
//
// Standalone module â€” does NOT modify world.js.
// Requires THREE.js r128 in browser context.
// Uses only: MeshBasicMaterial, MeshPhongMaterial (no ShaderMaterial, no CapsuleGeometry)

(function(exports) {
  'use strict';

  // â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Nexus center coordinates (world.js ZONES.nexus: cx=0, cz=0)
  var NEXUS_X = 0;
  var NEXUS_Z = 0;

  // Portal geometry dimensions
  var RING_RADIUS = 1.5;          // Outer torus radius (diameter 3)
  var RING_TUBE = 0.2;            // Torus tube thickness
  var DISC_RADIUS = 1.3;          // Inner disc radius
  var PARTICLE_SIZE = 0.12;       // Orbiting sphere radius
  var PARTICLE_COUNT = 10;        // Number of orbiting particles
  var PARTICLE_ORBIT_RADIUS = 1.8;// Orbit radius around portal centre

  // Semicircle layout near Nexus
  var SEMICIRCLE_RADIUS = 20;     // Distance from Nexus centre
  var SEMICIRCLE_START_ANGLE = Math.PI * 0.1;
  var SEMICIRCLE_END_ANGLE   = Math.PI * 0.9;

  // Interaction
  var DEFAULT_PROXIMITY_RANGE = 5;

  // Colors
  var COLOR_RING_HEALTHY   = 0x7c3aed;  // Purple
  var COLOR_RING_UNHEALTHY = 0xdc2626;  // Red
  var COLOR_DISC_A         = 0x4f46e5;  // Deep indigo
  var COLOR_DISC_B         = 0x818cf8;  // Light indigo
  var COLOR_PARTICLE_BASE  = 0x6ee7f7;  // Cyan
  var COLOR_GLOW_HEALTHY   = 0xa78bfa;  // Soft violet
  var COLOR_GLOW_UNHEALTHY = 0xf87171;  // Soft red
  var COLOR_STATUS_HEALTHY   = 0x22c55e;  // Green
  var COLOR_STATUS_UNHEALTHY = 0xef4444;  // Red

  // Animation
  var RING_ROTATION_SPEED    = 0.8;   // rad/s around Y
  var DISC_PULSE_SPEED       = 1.2;   // Hz
  var PARTICLE_ORBIT_SPEEDS  = [1.0, -0.7, 1.3, -0.9, 0.6, -1.1, 0.8, -0.5, 1.5, -1.2];
  var FLICKER_SPEED          = 8.0;   // Hz, for unhealthy portals

  // â”€â”€â”€ Internal Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Interpolate between two hex colors by t âˆˆ [0,1]
  function lerpColor(a, b, t) {
    var ar = (a >> 16) & 0xff, ag = (a >> 8) & 0xff, ab = a & 0xff;
    var br = (b >> 16) & 0xff, bg = (b >> 8) & 0xff, bb = b & 0xff;
    var r = Math.round(ar + (br - ar) * t);
    var g = Math.round(ag + (bg - ag) * t);
    var bl2 = Math.round(ab + (bb - ab) * t);
    return (r << 16) | (g << 8) | bl2;
  }

  // Generate a label string from connection data
  function buildLabelText(connection) {
    var name = (connection && connection.worldName) ? connection.worldName : 'Unknown World';
    var count = (connection && typeof connection.playerCount === 'number') ? connection.playerCount : 0;
    var unit = count === 1 ? 'player' : 'players';
    return name + '\n(' + count + ' ' + unit + ')';
  }

  // Create a sprite-based text label that works in Three.js r128
  // Uses a canvas texture painted onto a Sprite (billboard, always faces camera)
  function createTextSprite(text, THREE) {
    var canvas = (typeof document !== 'undefined')
      ? document.createElement('canvas')
      : { width: 256, height: 128,
          getContext: function() {
            return {
              clearRect:         function() {},
              fillRect:          function() {},
              fillText:          function() {},
              measureText:       function(t) { return { width: t.length * 8 }; },
              beginPath:         function() {},
              moveTo:            function() {},
              lineTo:            function() {},
              quadraticCurveTo:  function() {},
              closePath:         function() {},
              fill:              function() {},
              roundRect:         function() {},
              font:              '',
              fillStyle:         '',
              textAlign:         '',
              textBaseline:      ''
            };
          }
        };

    canvas.width  = 256;
    canvas.height = 128;

    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 256, 128);

    // Background pill
    ctx.fillStyle = 'rgba(20, 10, 40, 0.82)';
    _roundRect(ctx, 8, 8, 240, 112, 16);

    // World name (line 1)
    var lines = text.split('\n');
    ctx.font = 'bold 26px Arial, sans-serif';
    ctx.fillStyle = '#e0d7ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(lines[0] || '', 128, 44);

    // Player count (line 2)
    ctx.font = '20px Arial, sans-serif';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText(lines[1] || '', 128, 84);

    var texture = new THREE.CanvasTexture
      ? new THREE.CanvasTexture(canvas)
      : new THREE.Texture(canvas);

    if (texture.needsUpdate !== undefined) {
      texture.needsUpdate = true;
    }

    var material = new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      depthTest: false
    });

    var sprite = new THREE.Sprite(material);
    sprite.scale.set(4.0, 2.0, 1.0);
    return sprite;
  }

  // Fallback for environments without CanvasRenderingContext2D.roundRect
  function _roundRect(ctx, x, y, w, h, r) {
    if (ctx.roundRect) {
      ctx.beginPath();
      ctx.roundRect(x, y, w, h, r);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }
  }

  // â”€â”€â”€ Portal Positions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Arrange portals in a semicircle near Nexus centre.
   * Portals face inward (toward NEXUS_X, NEXUS_Z).
   *
   * @param {number} count - Number of portals
   * @param {function} [terrainHeightFn] - Optional fn(x, z) â†’ y
   * @returns {Array<{x, y, z, angle}>}
   */
  function getPortalPositions(count, terrainHeightFn) {
    if (!count || count <= 0) return [];

    var positions = [];
    for (var i = 0; i < count; i++) {
      var t = count === 1 ? 0.5 : i / (count - 1);
      var angle = SEMICIRCLE_START_ANGLE + t * (SEMICIRCLE_END_ANGLE - SEMICIRCLE_START_ANGLE);

      var x = NEXUS_X + Math.cos(angle) * SEMICIRCLE_RADIUS;
      var z = NEXUS_Z + Math.sin(angle) * SEMICIRCLE_RADIUS;
      var terrainY = (typeof terrainHeightFn === 'function') ? terrainHeightFn(x, z) : 0;
      var y = terrainY + 1;

      // The portal should face inward (toward Nexus centre)
      var facingAngle = Math.atan2(NEXUS_X - x, NEXUS_Z - z);

      positions.push({ x: x, y: y, z: z, angle: facingAngle });
    }
    return positions;
  }

  // â”€â”€â”€ Portal Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create a Three.js Group representing a Rift Portal.
   *
   * @param {Object} connection - {worldId, worldName, playerCount, latency, status, healthy?}
   * @param {Object} scene - THREE.Scene (portal is NOT added here; caller adds it)
   * @param {Object} THREE - THREE namespace (injected for testability)
   * @returns {Object} THREE.Group with userData.portalData attached
   */
  function createPortal(connection, scene, THREE) {
    if (!THREE) {
      if (typeof window !== 'undefined' && window.THREE) {
        THREE = window.THREE;
      } else {
        throw new Error('RiftPortal.createPortal: THREE is required');
      }
    }

    var healthy = _isHealthy(connection);
    var group = new THREE.Group();

    // â”€â”€ Outer ring (Torus) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var ringGeo = new THREE.TorusGeometry(RING_RADIUS, RING_TUBE, 16, 48);
    var ringMat = new THREE.MeshPhongMaterial({
      color: healthy ? COLOR_RING_HEALTHY : COLOR_RING_UNHEALTHY,
      emissive: healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY,
      emissiveIntensity: 0.6,
      shininess: 80,
      transparent: true,
      opacity: 0.95
    });
    var ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2; // Stand upright
    ring.name = 'riftRing';
    group.add(ring);

    // â”€â”€ Inner disc (Circle) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var discGeo = new THREE.CircleGeometry(DISC_RADIUS, 32);
    var discMat = new THREE.MeshBasicMaterial({
      color: COLOR_DISC_A,
      transparent: true,
      opacity: 0.75,
      side: 2 // THREE.DoubleSide = 2
    });
    var disc = new THREE.Mesh(discGeo, discMat);
    disc.rotation.x = Math.PI / 2; // Stand upright (same plane as ring)
    disc.name = 'riftDisc';
    group.add(disc);

    // â”€â”€ Orbiting particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var particles = [];
    for (var i = 0; i < PARTICLE_COUNT; i++) {
      var pGeo = new THREE.SphereGeometry(PARTICLE_SIZE, 6, 6);
      var pColor = lerpColor(COLOR_PARTICLE_BASE, healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY, i / PARTICLE_COUNT);
      var pMat = new THREE.MeshBasicMaterial({
        color: pColor,
        transparent: true,
        opacity: 0.9
      });
      var particle = new THREE.Mesh(pGeo, pMat);
      // Initial angle spread evenly around the ring
      var initAngle = (i / PARTICLE_COUNT) * Math.PI * 2;
      particle.position.x = Math.cos(initAngle) * PARTICLE_ORBIT_RADIUS;
      particle.position.y = Math.sin(initAngle) * PARTICLE_ORBIT_RADIUS;
      particle.position.z = 0;
      particle.name = 'riftParticle_' + i;
      particle.userData.orbitAngle = initAngle;
      particle.userData.orbitSpeed = PARTICLE_ORBIT_SPEEDS[i % PARTICLE_ORBIT_SPEEDS.length];
      group.add(particle);
      particles.push(particle);
    }

    // â”€â”€ Status indicator dot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var dotGeo = new THREE.SphereGeometry(0.15, 8, 8);
    var dotMat = new THREE.MeshBasicMaterial({
      color: healthy ? COLOR_STATUS_HEALTHY : COLOR_STATUS_UNHEALTHY
    });
    var statusDot = new THREE.Mesh(dotGeo, dotMat);
    statusDot.position.set(RING_RADIUS + 0.3, 0, 0);
    statusDot.name = 'riftStatusDot';
    group.add(statusDot);

    // â”€â”€ Text label (billboard sprite) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var labelSprite = createTextSprite(buildLabelText(connection), THREE);
    labelSprite.position.set(0, RING_RADIUS + 1.2, 0);
    labelSprite.name = 'riftLabel';
    group.add(labelSprite);

    // â”€â”€ Internal state attached to the group â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    group.name = 'riftPortal_' + (connection.worldId || 'unknown');
    group.userData.portalData = {
      worldId:     connection.worldId || '',
      worldName:   connection.worldName || '',
      playerCount: connection.playerCount || 0,
      latency:     connection.latency || 0,
      healthy:     healthy,
      time:        0,          // accumulated time for animation
      particles:   particles,
      ring:        ring,
      disc:        disc,
      statusDot:   statusDot,
      label:       labelSprite,
      connection:  connection
    };

    return group;
  }

  // â”€â”€â”€ Portal Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Update a portal's appearance from fresh connection data.
   * Also re-creates the label text if player count changed.
   *
   * @param {Object} portalObject - THREE.Group returned by createPortal
   * @param {Object} connection - Updated connection data
   */
  function updatePortal(portalObject, connection) {
    if (!portalObject || !portalObject.userData || !portalObject.userData.portalData) {
      return;
    }

    var pd = portalObject.userData.portalData;
    var healthy = _isHealthy(connection);
    var playerCountChanged = pd.playerCount !== (connection.playerCount || 0);

    // Update stored state
    pd.worldName   = connection.worldName || pd.worldName;
    pd.playerCount = connection.playerCount || 0;
    pd.latency     = connection.latency || 0;
    pd.healthy     = healthy;
    pd.connection  = connection;

    // Update ring color
    if (pd.ring && pd.ring.material) {
      pd.ring.material.color.setHex(healthy ? COLOR_RING_HEALTHY : COLOR_RING_UNHEALTHY);
      pd.ring.material.emissive.setHex(healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY);
    }

    // Update status dot color
    if (pd.statusDot && pd.statusDot.material) {
      pd.statusDot.material.color.setHex(healthy ? COLOR_STATUS_HEALTHY : COLOR_STATUS_UNHEALTHY);
    }

    // Update particle colors
    if (pd.particles) {
      for (var i = 0; i < pd.particles.length; i++) {
        var p = pd.particles[i];
        if (p && p.material) {
          var pColor = lerpColor(COLOR_PARTICLE_BASE, healthy ? COLOR_GLOW_HEALTHY : COLOR_GLOW_UNHEALTHY, i / pd.particles.length);
          p.material.color.setHex(pColor);
        }
      }
    }

    // Rebuild label if player count changed
    if (playerCountChanged && pd.label) {
      var newText = buildLabelText(connection);
      // Update the canvas texture if possible
      _updateLabelText(pd.label, newText);
    }
  }

  // Update sprite label text by re-painting the canvas texture
  function _updateLabelText(sprite, text) {
    if (!sprite || !sprite.material || !sprite.material.map) return;
    var map = sprite.material.map;
    if (!map.image || typeof map.image.getContext !== 'function') return;
    var canvas = map.image;
    var ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(20, 10, 40, 0.82)';
    _roundRect(ctx, 8, 8, 240, 112, 16);

    var lines = text.split('\n');
    ctx.font = 'bold 26px Arial, sans-serif';
    ctx.fillStyle = '#e0d7ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(lines[0] || '', 128, 44);

    ctx.font = '20px Arial, sans-serif';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText(lines[1] || '', 128, 84);

    map.needsUpdate = true;
  }

  // â”€â”€â”€ Portal Removal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Remove a portal from the scene and dispose its geometry/materials.
   *
   * @param {Object} portalObject - THREE.Group to remove
   * @param {Object} scene - THREE.Scene
   */
  function removePortal(portalObject, scene) {
    if (!portalObject) return;

    // Dispose children geometry and materials
    _disposeGroup(portalObject);

    // Remove from scene
    if (scene && typeof scene.remove === 'function') {
      scene.remove(portalObject);
    }
  }

  function _disposeGroup(group) {
    if (!group || !group.children) return;
    for (var i = group.children.length - 1; i >= 0; i--) {
      var child = group.children[i];
      if (child.geometry && typeof child.geometry.dispose === 'function') {
        child.geometry.dispose();
      }
      if (child.material) {
        if (child.material.map && typeof child.material.map.dispose === 'function') {
          child.material.map.dispose();
        }
        if (typeof child.material.dispose === 'function') {
          child.material.dispose();
        }
      }
    }
  }

  // â”€â”€â”€ Animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Animate a single portal's visual effects each frame.
   * Call this from your game loop for every active portal.
   *
   * @param {Object} portalObject - THREE.Group from createPortal
   * @param {number} deltaTime - Seconds since last frame
   */
  function animatePortal(portalObject, deltaTime) {
    if (!portalObject || !portalObject.userData || !portalObject.userData.portalData) return;

    var pd = portalObject.userData.portalData;
    pd.time += deltaTime;

    var t = pd.time;
    var healthy = pd.healthy;

    // Rotate the ring slowly around Y
    if (pd.ring) {
      pd.ring.rotation.z += RING_ROTATION_SPEED * deltaTime;
    }

    // Pulse the disc color between two hues
    if (pd.disc && pd.disc.material) {
      var pulse = (Math.sin(t * DISC_PULSE_SPEED * Math.PI * 2) + 1) * 0.5;
      var discColor = lerpColor(COLOR_DISC_A, COLOR_DISC_B, pulse);
      pd.disc.material.color.setHex(discColor);
      pd.disc.material.opacity = 0.55 + pulse * 0.3;
    }

    // Flicker effect for unhealthy portals
    if (!healthy && pd.ring && pd.ring.material) {
      var flicker = (Math.sin(t * FLICKER_SPEED * Math.PI * 2) + 1) * 0.5;
      pd.ring.material.opacity = 0.5 + flicker * 0.45;
    }

    // Orbit particles
    if (pd.particles) {
      for (var i = 0; i < pd.particles.length; i++) {
        var particle = pd.particles[i];
        if (!particle) continue;
        var speed = particle.userData.orbitSpeed || 1.0;
        particle.userData.orbitAngle += speed * deltaTime;
        var angle = particle.userData.orbitAngle;
        particle.position.x = Math.cos(angle) * PARTICLE_ORBIT_RADIUS;
        particle.position.y = Math.sin(angle) * PARTICLE_ORBIT_RADIUS;
        // Small vertical float
        particle.position.z = Math.sin(angle * 2.3 + t) * 0.25;
      }
    }

    // Gentle hover of the whole portal group
    portalObject.position.y = (portalObject.userData.baseY || 0) +
      Math.sin(t * 0.8 + (portalObject.userData.hoverOffset || 0)) * 0.15;
  }

  // â”€â”€â”€ Batch Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Synchronise the live portals map against the current connections list.
   * Adds portals for new connections, removes portals for dissolved ones,
   * updates and animates existing ones.
   *
   * @param {Object} portals - Mutable map of { worldId â†’ portalObject }
   * @param {Array} connections - Array from Federation.getConnections()
   * @param {Object} scene - THREE.Scene
   * @param {number} deltaTime - Seconds since last frame
   * @param {Object} [THREE] - THREE namespace (optional, falls back to window.THREE)
   * @param {function} [terrainHeightFn] - Optional fn(x, z) â†’ y
   */
  function updateAll(portals, connections, scene, deltaTime, THREE, terrainHeightFn) {
    if (!portals || !connections || !scene) return;

    var threeLib = THREE || (typeof window !== 'undefined' && window.THREE) || null;
    if (!threeLib) return;

    // Build set of worldIds present in current connections
    var activeIds = {};
    for (var ci = 0; ci < connections.length; ci++) {
      var conn = connections[ci];
      if (conn && conn.worldId) {
        activeIds[conn.worldId] = conn;
      }
    }

    // Remove portals for connections that no longer exist
    var existingIds = Object.keys(portals);
    for (var ri = 0; ri < existingIds.length; ri++) {
      var id = existingIds[ri];
      if (!activeIds[id]) {
        removePortal(portals[id], scene);
        delete portals[id];
      }
    }

    // Compute positions for current connections
    var connList = connections.filter(function(c) { return c && c.worldId; });
    var positions = getPortalPositions(connList.length, terrainHeightFn);

    // Add portals for new connections; update existing ones
    for (var ai = 0; ai < connList.length; ai++) {
      var connection = connList[ai];
      var worldId = connection.worldId;
      var pos = positions[ai] || { x: 0, y: 1, z: -20, angle: 0 };

      if (!portals[worldId]) {
        // Create new portal
        var portal = createPortal(connection, scene, threeLib);
        portal.position.set(pos.x, pos.y, pos.z);
        portal.rotation.y = pos.angle;
        portal.userData.baseY = pos.y;
        portal.userData.hoverOffset = ai * 1.1; // stagger hover phase
        scene.add(portal);
        portals[worldId] = portal;
      } else {
        // Update existing portal's connection data
        updatePortal(portals[worldId], connection);
      }

      // Animate
      animatePortal(portals[worldId], deltaTime);
    }
  }

  // â”€â”€â”€ Proximity Check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Check if the player is near any portal.
   *
   * @param {{x, y, z}} playerPos - Player world position
   * @param {Object} portals - Map of { worldId â†’ portalObject }
   * @param {number} [range] - Proximity radius in world units (default 5)
   * @returns {{near: boolean, portal: Object|null, worldId: string|null, distance: number}}
   */
  function isPlayerNearPortal(playerPos, portals, range) {
    if (!playerPos || !portals) {
      return { near: false, portal: null, worldId: null, distance: Infinity };
    }

    var checkRange = (typeof range === 'number' && range > 0) ? range : DEFAULT_PROXIMITY_RANGE;
    var rangeSq = checkRange * checkRange;

    var ids = Object.keys(portals);
    for (var i = 0; i < ids.length; i++) {
      var id = ids[i];
      var portalObj = portals[id];
      if (!portalObj || !portalObj.position) continue;

      var dx = playerPos.x - portalObj.position.x;
      var dy = playerPos.y - portalObj.position.y;
      var dz = playerPos.z - portalObj.position.z;
      var distSq = dx * dx + dy * dy + dz * dz;

      if (distSq <= rangeSq) {
        return {
          near: true,
          portal: portalObj,
          worldId: id,
          distance: Math.sqrt(distSq)
        };
      }
    }

    return { near: false, portal: null, worldId: null, distance: Infinity };
  }

  // â”€â”€â”€ Internal Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _isHealthy(connection) {
    if (!connection) return false;
    var hasGoodLatency = (connection.latency === undefined || connection.latency < 200);
    var isActive = (connection.status === 'active' || connection.status === undefined);
    // If connection provides an explicit 'healthy' flag, honour it
    if (typeof connection.healthy === 'boolean') return connection.healthy;
    return hasGoodLatency && isActive;
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.createPortal       = createPortal;
  exports.updatePortal       = updatePortal;
  exports.removePortal       = removePortal;
  exports.animatePortal      = animatePortal;
  exports.updateAll          = updateAll;
  exports.getPortalPositions = getPortalPositions;
  exports.isPlayerNearPortal = isPlayerNearPortal;

  // Expose internal helpers for testing
  exports._isHealthy         = _isHealthy;
  exports._buildLabelText    = buildLabelText;
  exports._lerpColor         = lerpColor;

  // Constants exposed for tests / external configuration
  exports.RING_RADIUS            = RING_RADIUS;
  exports.DISC_RADIUS            = DISC_RADIUS;
  exports.PARTICLE_COUNT         = PARTICLE_COUNT;
  exports.SEMICIRCLE_RADIUS      = SEMICIRCLE_RADIUS;
  exports.DEFAULT_PROXIMITY_RANGE = DEFAULT_PROXIMITY_RANGE;

})(typeof module !== 'undefined' ? module.exports : (window.RiftPortal = {}));


// api_bridge.js
// api_bridge.js â€” Client-side bridge for AI Agent API
(function(exports) {
  'use strict';

  var REPO_OWNER = 'kody-w';
  var REPO_NAME = 'zion';
  var RAW_BASE = 'https://raw.githubusercontent.com/' + REPO_OWNER + '/' + REPO_NAME + '/main';
  var API_BASE = 'https://api.github.com/repos/' + REPO_OWNER + '/' + REPO_NAME;

  var PUBLISH_INTERVAL = 60000;  // 60s between state publishes
  var POLL_INTERVAL = 30000;     // 30s between inbox polls

  var lastPublishTime = 0;
  var lastPollTime = 0;
  var pendingMessages = [];

  /**
   * Initialize the API bridge
   */
  function init() {
    console.log('[ApiBridge] Initialized â€” publish every %ds, poll every %ds',
      PUBLISH_INTERVAL / 1000, POLL_INTERVAL / 1000);
  }

  /**
   * Update loop â€” called from main game loop
   * @param {number} now - Current timestamp (Date.now())
   * @param {object} gameState - Current game state
   */
  function update(now, gameState) {
    // Publish state on timer
    if (now - lastPublishTime >= PUBLISH_INTERVAL) {
      lastPublishTime = now;
      publishStateSnapshot(gameState);
    }

    // Poll inbox on timer
    if (now - lastPollTime >= POLL_INTERVAL) {
      lastPollTime = now;
      pollInbox(gameState);
    }

    // Process any pending messages
    if (pendingMessages.length > 0) {
      processPendingMessages(gameState);
    }
  }

  /**
   * Build a world state snapshot from live game state
   * @param {object} gameState - Current game state
   * @returns {object} Snapshot for API consumers
   */
  function buildSnapshot(gameState) {
    var state = typeof State !== 'undefined' ? State : {};
    var zones = typeof Zones !== 'undefined' ? Zones : {};
    var liveState = state.getLiveState ? state.getLiveState() : {};

    var world = liveState.world || {};
    var players = liveState.players || {};
    var economy = liveState.economy || {};
    var chat = liveState.chat || [];

    // Count players per zone
    var playerZones = {};
    var playerEntries = {};
    for (var pid in players) {
      if (players.hasOwnProperty(pid)) {
        var p = players[pid];
        var pzone = (p.position && p.position.zone) || 'nexus';
        playerZones[pzone] = (playerZones[pzone] || 0) + 1;
        playerEntries[pid] = {
          position: p.position || {},
          zone: pzone,
          online: true
        };
      }
    }

    // Zone summaries
    var zoneIds = zones.getAllZoneIds ? zones.getAllZoneIds() : [];
    var zoneSummaries = {};
    for (var i = 0; i < zoneIds.length; i++) {
      var zid = zoneIds[i];
      var zdata = zones.getZone ? zones.getZone(zid) : {};
      zoneSummaries[zid] = {
        name: zdata.name || zid,
        description: zdata.description || '',
        player_count: playerZones[zid] || 0,
        npc_count: 0
      };
    }

    // NPC data
    var npcList = [];
    if (typeof NPCs !== 'undefined' && NPCs.getAllNPCs) {
      var allNpcs = NPCs.getAllNPCs();
      for (var n = 0; n < allNpcs.length; n++) {
        var npc = allNpcs[n];
        var nzone = (npc.position && npc.position.zone) || 'nexus';
        npcList.push({
          id: npc.id || '',
          name: npc.name || '',
          archetype: npc.archetype || '',
          zone: nzone
        });
        if (zoneSummaries[nzone]) {
          zoneSummaries[nzone].npc_count++;
        }
      }
    }

    // Recent chat (last 20)
    var recentChat = [];
    var chatSlice = chat.slice(-20);
    for (var c = 0; c < chatSlice.length; c++) {
      var msg = chatSlice[c];
      recentChat.push({
        from: msg.from || '',
        type: msg.type || 'say',
        text: (msg.payload && msg.payload.text) || '',
        ts: msg.ts || ''
      });
    }

    // Simulation summaries
    var simulations = {};
    if (typeof SimCRM !== 'undefined' && SimCRM.getMetrics) {
      var crmState = typeof Main !== 'undefined' && Main.getSimCrmState ? Main.getSimCrmState() : null;
      if (crmState) {
        simulations.crm = SimCRM.getMetrics(crmState);
      }
    }

    return {
      v: 1,
      ts: new Date().toISOString(),
      world: {
        time: world.time || 0,
        dayPhase: world.dayPhase || 'day',
        weather: world.weather || 'clear',
        season: world.season || 'spring'
      },
      zones: zoneSummaries,
      players: playerEntries,
      npcs: npcList,
      recent_chat: recentChat,
      economy: {
        total_spark: sumValues(economy.balances || {}),
        active_listings: (economy.listings || []).length
      },
      simulations: simulations
    };
  }

  /**
   * Publish state snapshot (stores in localStorage for local access)
   * @param {object} gameState - Current game state
   */
  function publishStateSnapshot(gameState) {
    try {
      var snapshot = buildSnapshot(gameState);
      // Store locally for any local tools to read
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem('zion_api_state', JSON.stringify(snapshot));
        localStorage.setItem('zion_api_state_ts', snapshot.ts);
      }
    } catch (e) {
      console.warn('[ApiBridge] Failed to publish snapshot:', e.message);
    }
  }

  /**
   * Poll GitHub inbox for new messages from AI agents
   * @param {object} gameState - Current game state
   */
  function pollInbox(gameState) {
    var url = API_BASE + '/contents/state/inbox';

    fetch(url, {
      headers: { 'Accept': 'application/vnd.github.v3+json' }
    })
    .then(function(response) {
      if (!response.ok) return [];
      return response.json();
    })
    .then(function(files) {
      if (!Array.isArray(files)) return;

      // Filter for JSON files (not .gitkeep, not _processed dir)
      var messageFiles = files.filter(function(f) {
        return f.name.endsWith('.json') && f.type === 'file';
      });

      if (messageFiles.length === 0) return;

      console.log('[ApiBridge] Found %d inbox messages', messageFiles.length);

      // Fetch each message
      messageFiles.forEach(function(f) {
        fetch(f.download_url)
          .then(function(r) { return r.json(); })
          .then(function(msg) {
            pendingMessages.push(msg);
          })
          .catch(function(e) {
            console.warn('[ApiBridge] Failed to fetch message %s: %s', f.name, e.message);
          });
      });
    })
    .catch(function(e) {
      // Silent fail â€” GitHub API rate limiting is common for unauthenticated requests
    });
  }

  /**
   * Process pending messages from inbox
   * @param {object} gameState - Current game state
   */
  function processPendingMessages(gameState) {
    var protocol = typeof Protocol !== 'undefined' ? Protocol : null;
    var state = typeof State !== 'undefined' ? State : null;

    if (!protocol || !state) return;

    while (pendingMessages.length > 0) {
      var msg = pendingMessages.shift();

      // Validate
      var result = protocol.validateMessage(msg);
      if (!result.valid) {
        console.warn('[ApiBridge] Invalid message from %s: %s', msg.from, result.errors.join(', '));
        continue;
      }

      // Apply to live state
      try {
        var currentState = state.getLiveState();
        var newState = state.applyMessage(currentState, msg);
        state.setLiveState(newState);
        console.log('[ApiBridge] Applied %s from %s', msg.type, msg.from);

        // Chat messages are rendered by HUD from live state â€” no extra call needed
      } catch (e) {
        console.warn('[ApiBridge] Failed to apply message: %s', e.message);
      }
    }
  }

  /**
   * Get the latest published snapshot
   * @returns {object|null} Latest snapshot or null
   */
  function getLatestSnapshot() {
    if (typeof localStorage === 'undefined') return null;
    try {
      var raw = localStorage.getItem('zion_api_state');
      return raw ? JSON.parse(raw) : null;
    } catch (e) {
      return null;
    }
  }

  /**
   * Sum numeric values in an object
   */
  function sumValues(obj) {
    var total = 0;
    for (var k in obj) {
      if (obj.hasOwnProperty(k) && typeof obj[k] === 'number') {
        total += obj[k];
      }
    }
    return total;
  }

  // Exports
  exports.init = init;
  exports.update = update;
  exports.buildSnapshot = buildSnapshot;
  exports.publishStateSnapshot = publishStateSnapshot;
  exports.pollInbox = pollInbox;
  exports.getLatestSnapshot = getLatestSnapshot;

})(typeof module !== 'undefined' ? module.exports : (window.ApiBridge = {}));


// LAZY_LOAD_START: sim_crm
// sim_crm.js â€” Self-evolving CRM Simulation (Dynamics 365-style)
// Article XI: Simulations run locally, store state as JSON, use pure functions.
// The state JSON IS the simulation â€” portable between raw GitHub and local disk.
// When an unknown action arrives, the simulation molts to handle it.
(function(exports) {
  'use strict';

  // --- Defaults (used only when creating a fresh state) ---

  var DEFAULT_PIPELINE = [
    'prospecting', 'qualification', 'proposal',
    'negotiation', 'closed_won', 'closed_lost'
  ];

  var DEFAULT_STAGE_PROB = {
    'prospecting': 10, 'qualification': 25, 'proposal': 50,
    'negotiation': 75, 'closed_won': 100, 'closed_lost': 0
  };

  var DEFAULT_ACTIVITY_TYPES = ['call', 'email', 'meeting', 'task'];

  var DEFAULT_SCHEMA = {
    collections: {
      accounts:      { prefix: 'acc', fields: ['name','industry','revenue','owner','status','zone'] },
      contacts:      { prefix: 'con', fields: ['name','email','phone','role','accountId','owner'] },
      opportunities: { prefix: 'opp', fields: ['name','accountId','stage','value','probability','owner','expected_close'] }
    },
    activity_types: DEFAULT_ACTIVITY_TYPES.slice(),
    pipeline_stages: DEFAULT_PIPELINE.slice(),
    stage_probabilities: JSON.parse(JSON.stringify(DEFAULT_STAGE_PROB))
  };

  var idCounter = 0;

  function generateId(prefix) {
    idCounter++;
    return prefix + '_' + Date.now().toString(36) + '_' + idCounter;
  }

  // --- State management ---

  function initState(snapshot) {
    if (snapshot && (snapshot.accounts || snapshot._schema)) {
      // Restore id counter from existing data
      var maxNum = 0;
      var schema = snapshot._schema || DEFAULT_SCHEMA;
      var collNames = objectKeys(schema.collections || {});
      // Also scan legacy top-level collections
      var scanKeys = collNames.concat(['accounts', 'contacts', 'opportunities']);
      for (var c = 0; c < scanKeys.length; c++) {
        var coll = snapshot[scanKeys[c]];
        if (coll && typeof coll === 'object' && !Array.isArray(coll)) {
          for (var k in coll) {
            if (coll.hasOwnProperty(k)) {
              var parts = k.split('_');
              var num = parseInt(parts[parts.length - 1], 10);
              if (!isNaN(num) && num > maxNum) { maxNum = num; }
            }
          }
        }
      }
      var activities = snapshot.activities || [];
      for (var a = 0; a < activities.length; a++) {
        if (activities[a].id) {
          var aParts = activities[a].id.split('_');
          var aNum = parseInt(aParts[aParts.length - 1], 10);
          if (!isNaN(aNum) && aNum > maxNum) { maxNum = aNum; }
        }
      }
      idCounter = maxNum;

      var loaded = JSON.parse(JSON.stringify(snapshot));
      // Ensure schema exists (migrate v1 states)
      if (!loaded._schema) {
        loaded._schema = JSON.parse(JSON.stringify(DEFAULT_SCHEMA));
      }
      if (!loaded._molt_log) { loaded._molt_log = []; }
      // Ensure pipeline_stages at top level for backward compat
      if (!loaded.pipeline_stages) {
        loaded.pipeline_stages = loaded._schema.pipeline_stages.slice();
      }
      return loaded;
    }
    return {
      _schema: JSON.parse(JSON.stringify(DEFAULT_SCHEMA)),
      _molt_log: [],
      accounts: {},
      contacts: {},
      opportunities: {},
      activities: [],
      pipeline_stages: DEFAULT_PIPELINE.slice()
    };
  }

  // --- Molt: the simulation adapts ---

  function molt(state, reason) {
    var s = clone(state);
    if (!s._molt_log) { s._molt_log = []; }
    s._molt_log.push({
      v: s._molt_log.length + 1,
      reason: reason,
      ts: new Date().toISOString()
    });
    return s;
  }

  function ensureCollection(state, collName, prefix) {
    if (state[collName] && typeof state[collName] === 'object' && !Array.isArray(state[collName])) {
      return state;
    }
    var s = molt(state, 'New collection: ' + collName);
    s[collName] = {};
    if (!s._schema.collections[collName]) {
      s._schema.collections[collName] = { prefix: prefix || collName.substring(0, 3), fields: [] };
    }
    return s;
  }

  function ensurePipelineStage(state, stageName) {
    var stages = state._schema.pipeline_stages;
    if (stages.indexOf(stageName) !== -1) { return state; }
    var s = molt(state, 'New pipeline stage: ' + stageName);
    // Insert before closed stages
    var closedIdx = stages.indexOf('closed_won');
    if (closedIdx === -1) { closedIdx = stages.length; }
    s._schema.pipeline_stages.splice(closedIdx, 0, stageName);
    s.pipeline_stages = s._schema.pipeline_stages.slice();
    if (!s._schema.stage_probabilities[stageName]) {
      // Estimate probability based on position
      var pos = s._schema.pipeline_stages.indexOf(stageName);
      var total = s._schema.pipeline_stages.length;
      s._schema.stage_probabilities[stageName] = Math.round((pos / (total - 1)) * 100);
    }
    return s;
  }

  function ensureActivityType(state, typeName) {
    if (state._schema.activity_types.indexOf(typeName) !== -1) { return state; }
    var s = molt(state, 'New activity type: ' + typeName);
    s._schema.activity_types.push(typeName);
    return s;
  }

  function learnFields(state, collName, data) {
    // Absorb any new fields into the schema
    var schema = state._schema;
    if (!schema.collections[collName]) { return state; }
    var known = schema.collections[collName].fields;
    var newFields = [];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id' && k !== 'owner' && known.indexOf(k) === -1) {
        newFields.push(k);
      }
    }
    if (newFields.length === 0) { return state; }
    var s = molt(state, 'New fields on ' + collName + ': ' + newFields.join(', '));
    for (var i = 0; i < newFields.length; i++) {
      s._schema.collections[collName].fields.push(newFields[i]);
    }
    return s;
  }

  // --- Action dispatch (with molting) ---

  function applyAction(state, msg) {
    var payload = msg.payload || msg;
    var action = payload.action;
    var data = payload.data || {};
    var from = msg.from || payload.from || 'system';
    var result;

    // Ensure schema exists
    if (!state._schema) {
      state = initState(state);
    }

    switch (action) {
      case 'create_account':
        result = createAccount(state, mergeOwner(data, from));
        return result.state;

      case 'update_account':
        return updateAccount(state, data.id, data);

      case 'create_contact':
        result = createContact(state, mergeOwner(data, from));
        return result.state;

      case 'update_contact':
        return updateContact(state, data.id, data);

      case 'create_opportunity':
        result = createOpportunity(state, mergeOwner(data, from));
        return result.state;

      case 'update_stage':
        return updateStage(state, data.id, data.stage);

      case 'close_deal':
        return closeDeal(state, data.id, data.won, data);

      case 'log_activity':
        result = logActivity(state, mergeOwner(data, from));
        return result.state;

      case 'add_note':
        return addNote(state, data.entityType, data.entityId, data.text, from);

      default:
        // --- MOLT: handle unknown actions ---
        return moltForAction(state, action, data, from);
    }
  }

  /**
   * When the simulation doesn't know an action, it molts.
   * Patterns: create_X, update_X, delete_X, list_X
   */
  function moltForAction(state, action, data, from) {
    if (!action || typeof action !== 'string') { return state; }

    var parts = action.split('_');
    if (parts.length < 2) { return state; }

    var verb = parts[0];
    // e.g. create_lead â†’ verb=create, entitySingular=lead, collName=leads
    var entitySingular = parts.slice(1).join('_');
    var collName = entitySingular + 's';
    var prefix = entitySingular.substring(0, 3);

    if (verb === 'create') {
      var s = ensureCollection(state, collName, prefix);
      s = learnFields(s, collName, data);
      var s2 = clone(s);
      var id = generateId(prefix);
      var record = { id: id, owner: data.owner || from, createdAt: new Date().toISOString() };
      for (var k in data) {
        if (data.hasOwnProperty(k)) { record[k] = data[k]; }
      }
      if (!record.name) { record.name = 'Unnamed ' + entitySingular; }
      if (!record.notes) { record.notes = []; }
      s2[collName][id] = record;
      return s2;

    } else if (verb === 'update') {
      if (!state[collName] || !data.id || !state[collName][data.id]) { return state; }
      var su = clone(state);
      su = learnFields(su, collName, data);
      var target = su[collName][data.id];
      for (var uk in data) {
        if (data.hasOwnProperty(uk) && uk !== 'id') { target[uk] = data[uk]; }
      }
      target.updatedAt = new Date().toISOString();
      return su;

    } else if (verb === 'delete') {
      if (!state[collName] || !data.id || !state[collName][data.id]) { return state; }
      var sd = clone(state);
      delete sd[collName][data.id];
      return sd;

    } else if (verb === 'list') {
      // Read-only, no state change
      return state;
    }

    return state;
  }

  function mergeOwner(data, from) {
    var out = {};
    for (var k in data) {
      if (data.hasOwnProperty(k)) { out[k] = data[k]; }
    }
    if (!out.owner) { out.owner = from; }
    return out;
  }

  // --- CRUD: Accounts ---

  function createAccount(state, data) {
    var s = learnFields(state, 'accounts', data);
    s = clone(s);
    var id = generateId('acc');
    var record = {
      id: id,
      name: data.name || 'Unnamed Account',
      industry: data.industry || 'general',
      revenue: data.revenue || 0,
      owner: data.owner || 'system',
      status: data.status || 'active',
      zone: data.zone || 'agora',
      notes: [],
      createdAt: new Date().toISOString()
    };
    // Absorb extra fields from data
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.accounts[id] = record;
    return { state: s, record: record };
  }

  function updateAccount(state, id, data) {
    if (!state.accounts[id]) { return state; }
    var s = learnFields(state, 'accounts', data);
    s = clone(s);
    var acct = s.accounts[id];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id') { acct[k] = data[k]; }
    }
    acct.updatedAt = new Date().toISOString();
    return s;
  }

  // --- CRUD: Contacts ---

  function createContact(state, data) {
    var s = learnFields(state, 'contacts', data);
    s = clone(s);
    var id = generateId('con');
    var record = {
      id: id,
      name: data.name || 'Unnamed Contact',
      email: data.email || '',
      phone: data.phone || '',
      role: data.role || '',
      accountId: data.accountId || '',
      owner: data.owner || 'system',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.contacts[id] = record;
    return { state: s, record: record };
  }

  function updateContact(state, id, data) {
    if (!state.contacts[id]) { return state; }
    var s = learnFields(state, 'contacts', data);
    s = clone(s);
    var con = s.contacts[id];
    for (var k in data) {
      if (data.hasOwnProperty(k) && k !== 'id') { con[k] = data[k]; }
    }
    con.updatedAt = new Date().toISOString();
    return s;
  }

  // --- CRUD: Opportunities ---

  function createOpportunity(state, data) {
    var s = state;
    var stage = data.stage || 'prospecting';
    // Molt if unknown stage
    if (s._schema && s._schema.pipeline_stages.indexOf(stage) === -1) {
      s = ensurePipelineStage(s, stage);
    }
    s = learnFields(s, 'opportunities', data);
    s = clone(s);
    var id = generateId('opp');
    var probs = s._schema ? s._schema.stage_probabilities : DEFAULT_STAGE_PROB;
    var record = {
      id: id,
      name: data.name || 'Unnamed Opportunity',
      accountId: data.accountId || '',
      stage: stage,
      value: data.value || 0,
      probability: data.probability !== undefined ? data.probability : (probs[stage] || 0),
      owner: data.owner || 'system',
      expected_close: data.expected_close || '',
      notes: [],
      createdAt: new Date().toISOString()
    };
    for (var k in data) {
      if (data.hasOwnProperty(k) && record[k] === undefined) { record[k] = data[k]; }
    }
    s.opportunities[id] = record;
    return { state: s, record: record };
  }

  function updateStage(state, oppId, newStage) {
    if (!state.opportunities[oppId]) { return state; }
    var s = state;
    var stages = s._schema ? s._schema.pipeline_stages : DEFAULT_PIPELINE;
    // Molt if unknown stage
    if (stages.indexOf(newStage) === -1) {
      s = ensurePipelineStage(s, newStage);
      stages = s._schema.pipeline_stages;
    }
    s = clone(s);
    var opp = s.opportunities[oppId];
    if (opp.stage === 'closed_won' || opp.stage === 'closed_lost') { return state; }
    opp.stage = newStage;
    var probs = s._schema ? s._schema.stage_probabilities : DEFAULT_STAGE_PROB;
    opp.probability = probs[newStage] !== undefined ? probs[newStage] : opp.probability;
    opp.updatedAt = new Date().toISOString();
    return s;
  }

  function closeDeal(state, oppId, won, details) {
    if (!state.opportunities[oppId]) { return state; }
    var s = clone(state);
    var opp = s.opportunities[oppId];
    opp.stage = won ? 'closed_won' : 'closed_lost';
    opp.probability = won ? 100 : 0;
    if (details && details.value !== undefined) { opp.value = details.value; }
    if (details && details.reason) { opp.close_reason = details.reason; }
    opp.closedAt = new Date().toISOString();
    opp.updatedAt = opp.closedAt;
    return s;
  }

  // --- Activities ---

  function logActivity(state, data) {
    var s = state;
    var actType = data.type || 'task';
    // Molt if unknown activity type
    if (s._schema && s._schema.activity_types.indexOf(actType) === -1) {
      s = ensureActivityType(s, actType);
    }
    s = clone(s);
    var id = generateId('act');
    var record = {
      id: id,
      type: actType,
      subject: data.subject || '',
      regarding: data.regarding || '',
      regardingType: data.regardingType || '',
      status: data.status || 'open',
      owner: data.owner || 'system',
      notes: data.notes || '',
      createdAt: new Date().toISOString()
    };
    s.activities.push(record);
    return { state: s, record: record };
  }

  // --- Notes ---

  function addNote(state, entityType, entityId, text, author) {
    // Look up collection from schema
    var collName = entityType;
    if (!state[collName]) {
      // Try singularâ†’plural
      collName = entityType + 's';
    }
    // Also support legacy singular names
    var singularMap = { account: 'accounts', contact: 'contacts', opportunity: 'opportunities' };
    if (singularMap[entityType]) { collName = singularMap[entityType]; }

    if (!state[collName] || !state[collName][entityId]) { return state; }
    var s = clone(state);
    var entity = s[collName][entityId];
    if (!entity.notes) { entity.notes = []; }
    entity.notes.push({
      text: text,
      author: author || 'system',
      ts: new Date().toISOString()
    });
    return s;
  }

  // --- Query ---

  function query(state, entityType, filters) {
    // Resolve collection name â€” try exact, then plural, then legacy map
    var collName = entityType;
    var legacy = {
      account: 'accounts', accounts: 'accounts',
      contact: 'contacts', contacts: 'contacts',
      opportunity: 'opportunities', opportunities: 'opportunities',
      activity: 'activities', activities: 'activities'
    };
    if (legacy[entityType]) {
      collName = legacy[entityType];
    } else if (!state[collName] && state[collName + 's']) {
      collName = collName + 's';
    }

    var source = state[collName];
    if (!source) { return []; }
    var items;

    if (Array.isArray(source)) {
      items = source.slice();
    } else {
      items = [];
      for (var k in source) {
        if (source.hasOwnProperty(k)) {
          items.push(source[k]);
        }
      }
    }

    if (!filters) { return items; }

    return items.filter(function(item) {
      for (var key in filters) {
        if (filters.hasOwnProperty(key)) {
          if (item[key] !== filters[key]) { return false; }
        }
      }
      return true;
    });
  }

  // --- Metrics ---

  function getMetrics(state) {
    var accounts = state.accounts || {};
    var opportunities = state.opportunities || {};
    var contacts = state.contacts || {};
    var activities = state.activities || [];
    var stages = (state._schema && state._schema.pipeline_stages) || DEFAULT_PIPELINE;

    var accountCount = 0;
    for (var a in accounts) { if (accounts.hasOwnProperty(a)) { accountCount++; } }

    var contactCount = 0;
    for (var c in contacts) { if (contacts.hasOwnProperty(c)) { contactCount++; } }

    var oppCount = 0;
    var pipelineValue = 0;
    var wonCount = 0;
    var lostCount = 0;
    var wonValue = 0;
    var closedCount = 0;
    var stageBreakdown = {};

    for (var i = 0; i < stages.length; i++) {
      stageBreakdown[stages[i]] = { count: 0, value: 0 };
    }

    for (var o in opportunities) {
      if (opportunities.hasOwnProperty(o)) {
        var opp = opportunities[o];
        oppCount++;
        var stage = opp.stage || 'prospecting';
        if (stageBreakdown[stage]) {
          stageBreakdown[stage].count++;
          stageBreakdown[stage].value += opp.value || 0;
        }
        if (stage === 'closed_won') {
          wonCount++;
          wonValue += opp.value || 0;
          closedCount++;
        } else if (stage === 'closed_lost') {
          lostCount++;
          closedCount++;
        } else {
          pipelineValue += opp.value || 0;
        }
      }
    }

    var conversionRate = closedCount > 0 ? Math.round((wonCount / closedCount) * 100) : 0;

    // Count molted collections beyond the 3 defaults
    var extraCollections = [];
    if (state._schema && state._schema.collections) {
      var collKeys = objectKeys(state._schema.collections);
      for (var ci = 0; ci < collKeys.length; ci++) {
        if (['accounts', 'contacts', 'opportunities'].indexOf(collKeys[ci]) === -1) {
          extraCollections.push(collKeys[ci]);
        }
      }
    }

    return {
      accounts_count: accountCount,
      contacts_count: contactCount,
      opportunities_count: oppCount,
      pipeline_value: pipelineValue,
      won_count: wonCount,
      won_value: wonValue,
      lost_count: lostCount,
      conversion_rate: conversionRate,
      activity_count: activities.length,
      stage_breakdown: stageBreakdown,
      molt_count: (state._molt_log || []).length,
      extra_collections: extraCollections
    };
  }

  // --- Simulation tick ---

  var OPEN_STAGES = ['prospecting', 'qualification', 'proposal', 'negotiation'];
  var STAGE_ADVANCE = {
    'prospecting': 'qualification',
    'qualification': 'proposal',
    'proposal': 'negotiation',
    'negotiation': 'closed_won'
  };

  var TICK_DEAL_NAMES = [
    'Enchanted Gem Lot', 'Potion Ingredient Bundle', 'Scroll Consignment',
    'Festival Supply Order', 'Armor Repair Contract', 'Seed Catalog Deal',
    'Map Commission', 'Instrument Materials', 'Forge Fuel Shipment',
    'Textile Dye Batch', 'Herb Subscription', 'Crystal Lens Order',
    'Waystone Part Supply', 'Lantern Oil Contract', 'Rune Ink Purchase'
  ];

  var TICK_ACTIVITY_SUBJECTS = [
    'Checked in on deal progress', 'Sent pricing update',
    'Met to discuss terms', 'Followed up after delivery',
    'Reviewed quarterly numbers', 'Negotiated bulk discount',
    'Introduced new product line', 'Resolved supply delay',
    'Scheduled next review', 'Collected feedback on service'
  ];

  var tickSeed = 1;
  var tickCount = 0;

  function tickRandom() {
    tickSeed = (tickSeed * 1664525 + 1013904223) & 0x7fffffff;
    return (tickSeed & 0xffff) / 0x10000;
  }

  function pickRandom(arr) {
    return arr[Math.floor(tickRandom() * arr.length)];
  }

  function objectKeys(obj) {
    var keys = [];
    for (var k in obj) { if (obj.hasOwnProperty(k)) { keys.push(k); } }
    return keys;
  }

  function simulateTick(state) {
    if (!state || !state.accounts) { return state; }

    tickCount++;
    tickSeed = ((Date.now() + tickCount * 7919) & 0x7fffffff) || 1;
    var s = state;
    var accIds = objectKeys(s.accounts);
    var oppIds = objectKeys(s.opportunities);
    if (accIds.length === 0) { return s; }

    var openOpps = [];
    for (var i = 0; i < oppIds.length; i++) {
      var opp = s.opportunities[oppIds[i]];
      if (opp && OPEN_STAGES.indexOf(opp.stage) !== -1) {
        openOpps.push(opp);
      }
    }

    if (openOpps.length > 0 && tickRandom() < 0.6) {
      var advOpp = pickRandom(openOpps);
      var nextStage = STAGE_ADVANCE[advOpp.stage];
      if (nextStage) {
        s = updateStage(s, advOpp.id, nextStage);
        if (nextStage === 'closed_won') {
          openOpps = openOpps.filter(function(o) { return o.id !== advOpp.id; });
        }
      }
    }

    if (tickRandom() < 0.7) {
      var actTypes = (s._schema && s._schema.activity_types) || DEFAULT_ACTIVITY_TYPES;
      var actOwner = s.accounts[pickRandom(accIds)].owner || 'system';
      var regarding = '';
      var regardingType = '';
      if (openOpps.length > 0 && tickRandom() > 0.3) {
        var refOpp = pickRandom(openOpps);
        regarding = refOpp.id;
        regardingType = 'opportunity';
      } else {
        regarding = pickRandom(accIds);
        regardingType = 'account';
      }
      var actResult = logActivity(s, {
        type: pickRandom(actTypes),
        subject: pickRandom(TICK_ACTIVITY_SUBJECTS),
        regarding: regarding,
        regardingType: regardingType,
        owner: actOwner,
        status: 'completed'
      });
      s = actResult.state;
    }

    if (tickRandom() < 0.15 && accIds.length > 0) {
      var accId = pickRandom(accIds);
      var acct = s.accounts[accId];
      var oppResult = createOpportunity(s, {
        name: pickRandom(TICK_DEAL_NAMES),
        accountId: accId,
        stage: pickRandom(['prospecting', 'prospecting', 'qualification']),
        value: Math.floor(tickRandom() * 4000) + 200,
        owner: acct.owner || 'system'
      });
      s = oppResult.state;
    }

    if (openOpps.length > 0 && tickRandom() < 0.1) {
      var closeOpp = pickRandom(openOpps);
      var won = tickRandom() < 0.65;
      s = closeDeal(s, closeOpp.id, won, {
        reason: won ? 'terms agreed' : 'budget constraints'
      });
    }

    return s;
  }

  // --- Helpers ---

  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function getState() {
    return null;
  }

  // --- Exports ---

  exports.PIPELINE_STAGES = DEFAULT_PIPELINE;
  exports.ACTIVITY_TYPES = DEFAULT_ACTIVITY_TYPES;
  exports.initState = initState;
  exports.applyAction = applyAction;
  exports.createAccount = createAccount;
  exports.updateAccount = updateAccount;
  exports.createContact = createContact;
  exports.updateContact = updateContact;
  exports.createOpportunity = createOpportunity;
  exports.updateStage = updateStage;
  exports.closeDeal = closeDeal;
  exports.logActivity = logActivity;
  exports.addNote = addNote;
  exports.query = query;
  exports.getMetrics = getMetrics;
  exports.getState = getState;
  exports.simulateTick = simulateTick;
  exports.molt = molt;
  exports.ensureCollection = ensureCollection;
  exports.ensurePipelineStage = ensurePipelineStage;
  exports.ensureActivityType = ensureActivityType;

})(typeof module !== 'undefined' ? module.exports : (window.SimCRM = {}));

// LAZY_LOAD_END: sim_crm

// sim_forge_browser.js
// sim_forge_browser.js â€” Simulation Forge for ZION (browser port of sim_forge.py)
// Article XI: Simulations run locally, store state as JSON, use pure functions.
// Ported from scripts/sim_forge.py â€” generates UMD JS simulation modules in-browser.
(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Internal helpers (mirror Python helper functions)
  // ---------------------------------------------------------------------------

  function _jsStr(s) {
    // Escape a string as a JS single-quoted string literal
    return "'" + String(s).replace(/\\/g, '\\\\').replace(/'/g, "\\'") + "'";
  }

  function _collPrefix(collName) {
    // Derive a 3-char prefix for IDs from a collection name
    return collName.slice(0, 3).toLowerCase();
  }

  function _pascal(s) {
    // Convert snake_case to PascalCase
    return s.split('_').map(function(part) {
      return part.charAt(0).toUpperCase() + part.slice(1);
    }).join('');
  }

  function _windowName(simName) {
    return 'Sim' + _pascal(simName);
  }

  function _moduleName(simName) {
    return 'sim_' + simName;
  }

  // Deep clone via JSON round-trip
  function _deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // Check if a value is a plain object (not array, not null)
  function _isPlainObject(v) {
    return v !== null && typeof v === 'object' && !Array.isArray(v);
  }

  // ---------------------------------------------------------------------------
  // parseSpec â€” validate and apply defaults (mirrors parse_spec)
  // ---------------------------------------------------------------------------

  function parseSpec(specInput) {
    var spec;
    if (typeof specInput === 'string') {
      try {
        spec = JSON.parse(specInput);
      } catch (e) {
        throw new Error('Invalid JSON in spec: ' + e.message);
      }
    } else if (_isPlainObject(specInput)) {
      // Deep copy to avoid mutating the input
      spec = _deepClone(specInput);
    } else {
      throw new Error('spec_input must be an object or JSON string');
    }

    // --- Validate name ---
    if (!spec.name) {
      throw new Error('Spec must have a non-empty "name" field');
    }
    var name = spec.name;
    if (typeof name !== 'string') {
      throw new Error('"name" must be a string');
    }
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
      throw new Error(
        '"name" must start with a letter or underscore and contain only ' +
        'alphanumeric characters and underscores, got: ' + JSON.stringify(name)
      );
    }

    // --- Validate collections ---
    if (!spec.collections) {
      throw new Error('Spec must have a "collections" field');
    }
    var collections = spec.collections;
    if (!_isPlainObject(collections)) {
      throw new Error('"collections" must be an object/dict');
    }
    var collKeys = Object.keys(collections);
    if (collKeys.length === 0) {
      throw new Error('"collections" must have at least one collection');
    }

    // Normalise each collection entry
    for (var i = 0; i < collKeys.length; i++) {
      var collName = collKeys[i];
      var collDef = collections[collName];
      if (!_isPlainObject(collDef)) {
        collections[collName] = { fields: [] };
        collDef = collections[collName];
      }
      if (!collDef.fields || collDef.fields === null) {
        collDef.fields = [];
      }
      if (!Array.isArray(collDef.fields)) {
        throw new Error('fields for collection "' + collName + '" must be a list');
      }
    }

    // --- Default actions ---
    if (!spec.actions || spec.actions.length === 0) {
      spec.actions = ['create', 'update', 'delete'];
    }

    // --- Default description ---
    if (!spec.description) {
      spec.description = 'A ' + name.replace(/_/g, ' ') + ' simulation';
    }

    return spec;
  }

  // ---------------------------------------------------------------------------
  // generateModule â€” produce a UMD JS simulation module source string
  // ---------------------------------------------------------------------------

  function generateModule(spec) {
    var name = spec.name;
    var collections = spec.collections;
    var description = spec.description || '';
    var windowName = _windowName(name);
    var collNames = Object.keys(collections);

    var lines = [];
    function w(line) { lines.push(line); }

    // Header
    w('// sim_' + name + '.js â€” ' + description);
    w('// Auto-generated by sim_forge.py â€” Article XI: Simulations');
    w('// initState(snapshot), applyAction(state, message), getState(), getSchema()');
    w('(function(exports) {');
    w("  'use strict';");
    w('');

    // Schema definition
    w('  // --- Schema ---');
    w('');
    w('  var _schema = {');
    w('    collections: {');
    for (var si = 0; si < collNames.length; si++) {
      var collName = collNames[si];
      var collDef = collections[collName];
      var fields = collDef.fields || [];
      var prefix = _collPrefix(collName);
      var fieldsJs = '[' + fields.map(_jsStr).join(', ') + ']';
      var comma = (si < collNames.length - 1) ? ',' : '';
      w('      ' + _jsStr(collName) + ': { prefix: ' + _jsStr(prefix) + ', fields: ' + fieldsJs + ' }' + comma);
    }
    w('    }');
    w('  };');
    w('');

    // State holder
    w('  var _state = null;');
    w('  var _idCounter = 0;');
    w('');

    // Utility functions
    w('  // --- Utilities ---');
    w('');
    w('  function clone(obj) {');
    w('    return JSON.parse(JSON.stringify(obj));');
    w('  }');
    w('');
    w('  function generateId(prefix) {');
    w('    _idCounter++;');
    w("    return prefix + '_' + Date.now().toString(36) + '_' + _idCounter;");
    w('  }');
    w('');
    w('  function objectKeys(obj) {');
    w('    var keys = [];');
    w('    for (var k in obj) {');
    w('      if (obj.hasOwnProperty(k)) { keys.push(k); }');
    w('    }');
    w('    return keys;');
    w('  }');
    w('');
    w('  function mergeOwner(data, from) {');
    w('    var out = {};');
    w('    for (var k in data) {');
    w('      if (data.hasOwnProperty(k)) { out[k] = data[k]; }');
    w('    }');
    w("    if (!out.owner) { out.owner = from || 'system'; }");
    w('    return out;');
    w('  }');
    w('');

    // initState
    w('  // --- State Management ---');
    w('');
    w('  function initState(snapshot) {');
    w('    var freshSchema = JSON.parse(JSON.stringify(_schema));');
    w("    if (snapshot && typeof snapshot === 'object') {");
    w('      // Restore id counter from existing records');
    w('      var maxNum = 0;');
    w('      var collNames = objectKeys((snapshot._schema || {}).collections || {});');

    // Also scan the spec collections (same as Python: extra_colls)
    var extraColls = '[' + collNames.map(_jsStr).join(', ') + ']';
    w('      var specColls = ' + extraColls + ';');
    w('      for (var si = 0; si < specColls.length; si++) {');
    w('        if (collNames.indexOf(specColls[si]) === -1) { collNames.push(specColls[si]); }');
    w('      }');
    w('      for (var ci = 0; ci < collNames.length; ci++) {');
    w("        var coll = snapshot[collNames[ci]];");
    w("        if (coll && typeof coll === 'object' && !Array.isArray(coll)) {");
    w('          var ids = objectKeys(coll);');
    w('          for (var ii = 0; ii < ids.length; ii++) {');
    w("            var parts = ids[ii].split('_');");
    w('            var num = parseInt(parts[parts.length - 1], 10);');
    w('            if (!isNaN(num) && num > maxNum) { maxNum = num; }');
    w('          }');
    w('        }');
    w('      }');
    w('      _idCounter = maxNum;');
    w('      var loaded = clone(snapshot);');
    w('      if (!loaded._schema) { loaded._schema = freshSchema; }');
    w('      // Ensure all spec collections exist');
    w('      for (var sci = 0; sci < specColls.length; sci++) {');
    w('        if (!loaded[specColls[sci]]) { loaded[specColls[sci]] = {}; }');
    w('      }');
    w('      _state = loaded;');
    w('      return _state;');
    w('    }');
    w('    // Fresh state');
    w('    _idCounter = 0;');
    w('    _state = {');
    w('      _schema: freshSchema,');
    w('      _sim: ' + _jsStr(name) + ',');
    w('      _created_at: new Date().toISOString()');
    w('    };');
    for (var ci2 = 0; ci2 < collNames.length; ci2++) {
      w('    _state[' + _jsStr(collNames[ci2]) + '] = {};');
    }
    w('    return _state;');
    w('  }');
    w('');

    // CRUD helpers per collection
    w('  // --- CRUD Helpers ---');
    w('');
    for (var cri = 0; cri < collNames.length; cri++) {
      var cName = collNames[cri];
      var cDef = collections[cName];
      var cFields = cDef.fields || [];
      var cPrefix = _collPrefix(cName);

      // createItem
      w('  function create_' + cName + '(state, data) {');
      w('    var s = clone(state);');
      w('    var id = generateId(' + _jsStr(cPrefix) + ');');
      w('    var record = {');
      w('      id: id,');
      w("      owner: data.owner || 'system',");
      w('      createdAt: new Date().toISOString()');
      w('    };');
      w('    for (var k in data) {');
      w('      if (data.hasOwnProperty(k)) { record[k] = data[k]; }');
      w('    }');
      w("    if (!record.name && !record.title) {");
      // Mirror Python: coll_name.rstrip('s') removes trailing 's'
      var singularName = cName.replace(/s$/, '');
      w("      record.name = 'Unnamed " + singularName + "';");
      w('    }');
      w('    s[' + _jsStr(cName) + '][id] = record;');
      w('    return { state: s, record: record };');
      w('  }');
      w('');

      // updateItem
      w('  function update_' + cName + '(state, id, data) {');
      w('    if (!state[' + _jsStr(cName) + '] || !state[' + _jsStr(cName) + '][id]) { return state; }');
      w('    var s = clone(state);');
      w('    var target = s[' + _jsStr(cName) + '][id];');
      w('    for (var k in data) {');
      w("      if (data.hasOwnProperty(k) && k !== 'id') { target[k] = data[k]; }");
      w('    }');
      w('    target.updatedAt = new Date().toISOString();');
      w('    return s;');
      w('  }');
      w('');

      // deleteItem
      w('  function delete_' + cName + '(state, id) {');
      w('    if (!state[' + _jsStr(cName) + '] || !state[' + _jsStr(cName) + '][id]) { return state; }');
      w('    var s = clone(state);');
      w('    delete s[' + _jsStr(cName) + '][id];');
      w('    return s;');
      w('  }');
      w('');
    }

    // applyAction dispatch
    w('  // --- Action Dispatch ---');
    w('');
    w('  function applyAction(state, msg) {');
    w("    var payload = (msg && msg.payload) ? msg.payload : (msg || {});");
    w("    var action = payload.action || '';");
    w('    var data = payload.data || {};');
    w("    var from = (msg && msg.from) || payload.from || 'system';");
    w('    var result;');
    w('');
    w('    if (!state || !state._schema) {');
    w('      state = initState(state);');
    w('    }');
    w('');
    w('    switch (action) {');

    for (var ai = 0; ai < collNames.length; ai++) {
      var aColl = collNames[ai];
      // create_<coll>
      w('      case ' + _jsStr('create_' + aColl) + ':');
      w('        result = create_' + aColl + '(state, mergeOwner(data, from));');
      w('        return result.state;');
      w('');
      // update_<coll>
      w('      case ' + _jsStr('update_' + aColl) + ':');
      w('        return update_' + aColl + '(state, data.id, data);');
      w('');
      // delete_<coll>
      w('      case ' + _jsStr('delete_' + aColl) + ':');
      w('        return delete_' + aColl + '(state, data.id);');
      w('');
    }

    // Handle custom actions from spec
    var actions = spec.actions || [];
    var customActions = actions.filter(function(a) {
      return a !== 'create' && a !== 'update' && a !== 'delete';
    });

    for (var cai = 0; cai < customActions.length; cai++) {
      var action = customActions[cai];

      if (action === 'complete') {
        for (var ci3 = 0; ci3 < collNames.length; ci3++) {
          var ccName = collNames[ci3];
          var ccFields = collections[ccName].fields || [];
          var caseName = 'complete_' + ccName;
          w('      case ' + _jsStr(caseName) + ':');
          w('        var sc = clone(state);');
          w('        if (sc[' + _jsStr(ccName) + '] && sc[' + _jsStr(ccName) + '][data.id]) {');
          if (ccFields.indexOf('done') !== -1) {
            w('          sc[' + _jsStr(ccName) + '][data.id].done = true;');
          }
          if (ccFields.indexOf('status') !== -1) {
            w("          sc[" + _jsStr(ccName) + "][data.id].status = 'completed';");
          }
          w('          sc[' + _jsStr(ccName) + '][data.id].completedAt = new Date().toISOString();');
          w('        }');
          w('        return sc;');
          w('');
        }
      } else if (action === 'assign') {
        for (var ci4 = 0; ci4 < collNames.length; ci4++) {
          var acName = collNames[ci4];
          var acFields = collections[acName].fields || [];
          if (acFields.indexOf('assignee') !== -1) {
            var acaseName = 'assign_' + acName;
            w('      case ' + _jsStr(acaseName) + ':');
            w('        var sa = clone(state);');
            w('        if (sa[' + _jsStr(acName) + '] && sa[' + _jsStr(acName) + '][data.id]) {');
            w('          sa[' + _jsStr(acName) + '][data.id].assignee = data.assignee || from;');
            w('          sa[' + _jsStr(acName) + '][data.id].updatedAt = new Date().toISOString();');
            w('        }');
            w('        return sa;');
            w('');
          }
        }
      } else if (action === 'move') {
        for (var ci5 = 0; ci5 < collNames.length; ci5++) {
          var mcName = collNames[ci5];
          var mcFields = collections[mcName].fields || [];
          var hasBoard = mcFields.indexOf('board_id') !== -1;
          var hasParent = mcFields.indexOf('parent_id') !== -1;
          if (hasBoard || hasParent) {
            var targetField = hasBoard ? 'board_id' : 'parent_id';
            var mcaseName = 'move_' + mcName;
            w('      case ' + _jsStr(mcaseName) + ':');
            w('        var sm = clone(state);');
            w('        if (sm[' + _jsStr(mcName) + '] && sm[' + _jsStr(mcName) + '][data.id]) {');
            w('          sm[' + _jsStr(mcName) + '][data.id][' + _jsStr(targetField) + '] = data.' + targetField + ';');
            w('          sm[' + _jsStr(mcName) + '][data.id].updatedAt = new Date().toISOString();');
            w('        }');
            w('        return sm;');
            w('');
          }
        }
      }
    }

    // default: unknown action returns same state
    w('      default:');
    w('        return state;');
    w('    }');
    w('  }');
    w('');

    // query helper
    w('  // --- Query ---');
    w('');
    w('  function query(state, collName, filter) {');
    w("    var coll = state[collName];");
    w("    if (!coll || typeof coll !== 'object' || Array.isArray(coll)) { return []; }");
    w('    var results = [];');
    w('    var ids = objectKeys(coll);');
    w('    for (var i = 0; i < ids.length; i++) {');
    w('      var item = coll[ids[i]];');
    w('      if (!filter || matchesFilter(item, filter)) {');
    w('        results.push(item);');
    w('      }');
    w('    }');
    w('    return results;');
    w('  }');
    w('');
    w('  function matchesFilter(item, filter) {');
    w('    for (var k in filter) {');
    w('      if (filter.hasOwnProperty(k)) {');
    w('        if (item[k] !== filter[k]) { return false; }');
    w('      }');
    w('    }');
    w('    return true;');
    w('  }');
    w('');

    // Public exports
    w('  // --- Public API ---');
    w('');
    w('  exports.initState = function(snapshot) {');
    w('    return initState(snapshot);');
    w('  };');
    w('');
    w('  exports.applyAction = function(state, msg) {');
    w('    return applyAction(state, msg);');
    w('  };');
    w('');
    w('  exports.getState = function() {');
    w('    return JSON.parse(JSON.stringify(_state));');
    w('  };');
    w('');
    w('  exports.getSchema = function() {');
    w('    return JSON.parse(JSON.stringify(_schema));');
    w('  };');
    w('');
    w('  exports.query = function(state, collName, filter) {');
    w('    return query(state, collName, filter);');
    w('  };');
    w('');

    // Also export individual CRUD functions for direct use in tests
    for (var ei = 0; ei < collNames.length; ei++) {
      var eName = collNames[ei];
      w('  exports.create_' + eName + ' = function(state, data) {');
      w('    return create_' + eName + '(state, data);');
      w('  };');
      w('  exports.update_' + eName + ' = function(state, id, data) {');
      w('    return update_' + eName + '(state, id, data);');
      w('  };');
      w('  exports.delete_' + eName + ' = function(state, id) {');
      w('    return delete_' + eName + '(state, id);');
      w('  };');
      w('');
    }

    // UMD footer
    w("})(typeof module !== 'undefined' ? module.exports : (window." + windowName + " = {}));");

    return lines.join('\n') + '\n';
  }

  // ---------------------------------------------------------------------------
  // generateState â€” produce initial state JSON object (mirrors generate_state)
  // ---------------------------------------------------------------------------

  function generateState(spec) {
    var name = spec.name;
    var collections = spec.collections;
    var collNames = Object.keys(collections);

    var schemaCollections = {};
    for (var i = 0; i < collNames.length; i++) {
      var collName = collNames[i];
      var collDef = collections[collName];
      var fields = collDef.fields || [];
      schemaCollections[collName] = {
        prefix: _collPrefix(collName),
        fields: fields.slice()
      };
    }

    var state = {
      _sim: name,
      _schema: {
        collections: schemaCollections
      },
      _created_at: new Date().toISOString()
    };

    // Empty collections
    for (var j = 0; j < collNames.length; j++) {
      state[collNames[j]] = {};
    }

    return state;
  }

  // ---------------------------------------------------------------------------
  // generateTests â€” produce a JS test source string (mirrors generate_tests)
  // ---------------------------------------------------------------------------

  function generateTests(spec) {
    var name = spec.name;
    var collections = spec.collections;
    var collNames = Object.keys(collections);
    var moduleName = _moduleName(name);
    var moduleVar = 'Sim';

    var lines = [];
    function w(line) { lines.push(line); }

    w('#!/usr/bin/env node');
    w('// test_sim_' + name + '.js â€” Auto-generated tests for ' + moduleName);
    w('// Generated by sim_forge.py');
    w("'use strict';");
    w('');
    w('var ' + moduleVar + " = require('../src/js/" + moduleName + ".js');");
    w('');
    w('var passed = 0;');
    w('var failed = 0;');
    w('');
    w('function assert(condition, message) {');
    w('  if (condition) {');
    w('    passed++;');
    w('  } else {');
    w('    failed++;');
    w("    console.error('FAIL: ' + message);");
    w('  }');
    w('}');
    w('');
    w('function assertEqual(actual, expected, message) {');
    w('  if (actual === expected) {');
    w('    passed++;');
    w('  } else {');
    w('    failed++;');
    w("    console.error('FAIL: ' + message + ' â€” expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));");
    w('  }');
    w('}');
    w('');

    // --- initState tests ---
    w('// --- initState ---');
    w('');
    w('(function testInitStateEmpty() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  assert(state && typeof state === 'object', 'initState returns object');");
    w("  assert(state._schema && state._schema.collections, 'initState returns state with schema');");
    for (var ici = 0; ici < collNames.length; ici++) {
      var icName = collNames[ici];
      w("  assert(state[" + _jsStr(icName) + "] && typeof state[" + _jsStr(icName) + "] === 'object', 'initState returns " + icName + " object');");
    }
    w('})();');
    w('');

    w('(function testInitStateFromSnapshot() {');
    var firstColl = collNames[0];
    var firstPrefix = _collPrefix(firstColl);
    var testId = firstPrefix + '_snap_1';
    w('  var snap = {');
    w('    _schema: { collections: {} },');
    for (var sni = 0; sni < collNames.length; sni++) {
      var snName = collNames[sni];
      var snComma = (sni < collNames.length - 1) ? ',' : '';
      if (sni === 0) {
        w('    ' + _jsStr(snName) + ': { ' + _jsStr(testId) + ': { id: ' + _jsStr(testId) + ", name: 'Test' } }" + snComma);
      } else {
        w('    ' + _jsStr(snName) + ': {}' + snComma);
      }
    }
    w('  };');
    w('  var state = ' + moduleVar + '.initState(snap);');
    w("  assert(state[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "] !== undefined, 'initState restores snapshot data');");
    w("  assertEqual(state[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "].name, 'Test', 'initState restores record name');");
    w('  // Deep clone check');
    w("  snap[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "].name = 'Modified';");
    w("  assertEqual(state[" + _jsStr(firstColl) + "][" + _jsStr(testId) + "].name, 'Test', 'initState deep clones snapshot');");
    w('})();');
    w('');

    // --- CRUD tests per collection ---
    for (var tci = 0; tci < collNames.length; tci++) {
      var tcName = collNames[tci];
      var tcDef = collections[tcName];
      var tcFields = tcDef.fields || [];
      var tcPrefix = _collPrefix(tcName);

      w('// --- ' + tcName + ' CRUD ---');
      w('');

      // Create
      w('(function testCreate_' + tcName + '() {');
      w('  var state = ' + moduleVar + '.initState();');
      // Build a data object from fields (take first 3)
      var testDataParts = [];
      for (var fi = 0; fi < Math.min(tcFields.length, 3); fi++) {
        var f = tcFields[fi];
        if (f === 'done') {
          testDataParts.push(_jsStr(f) + ': false');
        } else if (f === 'status') {
          testDataParts.push(_jsStr(f) + ": 'active'");
        } else if (f === 'priority') {
          testDataParts.push(_jsStr(f) + ": 'high'");
        } else {
          testDataParts.push(_jsStr(f) + ': ' + _jsStr('test_' + f));
        }
      }
      var testData = testDataParts.length > 0
        ? '{ ' + testDataParts.join(', ') + ' }'
        : "{ name: 'Test Item' }";
      w('  var result = ' + moduleVar + '.create_' + tcName + '(state, ' + testData + ');');
      w('  var record = result.record;');
      w('  var newState = result.state;');
      w("  assert(record && record.id && record.id.indexOf(" + _jsStr(tcPrefix) + ") === 0, 'create_" + tcName + " id has " + tcPrefix + "_ prefix');");
      w("  assert(newState[" + _jsStr(tcName) + "][record.id] !== undefined, 'create_" + tcName + " stores record');");
      w("  assertEqual(Object.keys(state[" + _jsStr(tcName) + "]).length, 0, 'create_" + tcName + " does not mutate original state');");
      w('})();');
      w('');

      // Update
      w('(function testUpdate_' + tcName + '() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var r = " + moduleVar + ".create_" + tcName + "(state, { name: 'Original' });");
      w('  state = r.state;');
      w('  var id = r.record.id;');
      w("  var updated = " + moduleVar + ".update_" + tcName + "(state, id, { name: 'Updated Name' });");
      w("  assertEqual(updated[" + _jsStr(tcName) + "][id].name, 'Updated Name', 'update_" + tcName + " changes name');");
      w("  assertEqual(state[" + _jsStr(tcName) + "][id].name, 'Original', 'update_" + tcName + " does not mutate original state');");
      w('})();');
      w('');

      // Update missing (edge case)
      w('(function testUpdate_' + tcName + '_missing() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var result = " + moduleVar + ".update_" + tcName + "(state, 'nonexistent_id', { name: 'X' });");
      w("  assert(result === state, 'update_" + tcName + " nonexistent id returns same state');");
      w('})();');
      w('');

      // Delete
      w('(function testDelete_' + tcName + '() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var r = " + moduleVar + ".create_" + tcName + "(state, { name: 'Delete me' });");
      w('  state = r.state;');
      w('  var id = r.record.id;');
      w('  var deleted = ' + moduleVar + '.delete_' + tcName + '(state, id);');
      w("  assert(deleted[" + _jsStr(tcName) + "][id] === undefined, 'delete_" + tcName + " removes record');");
      w("  assertEqual(Object.keys(state[" + _jsStr(tcName) + "]).length, 1, 'delete_" + tcName + " does not mutate original state');");
      w('})();');
      w('');

      // Delete missing (edge case)
      w('(function testDelete_' + tcName + '_missing() {');
      w('  var state = ' + moduleVar + '.initState();');
      w("  var result = " + moduleVar + ".delete_" + tcName + "(state, 'nonexistent_id');");
      w("  assert(result === state, 'delete_" + tcName + " nonexistent id returns same state');");
      w('})();');
      w('');
    }

    // --- Schema validation ---
    w('// --- Schema ---');
    w('');
    w('(function testGetSchema() {');
    w('  ' + moduleVar + '.initState();');
    w('  var schema = ' + moduleVar + '.getSchema();');
    w("  assert(schema && schema.collections, 'getSchema returns collections');");
    for (var sci = 0; sci < collNames.length; sci++) {
      var scName = collNames[sci];
      w("  assert(schema.collections[" + _jsStr(scName) + "], 'schema has " + scName + " collection');");
      var scFields = collections[scName].fields || [];
      for (var sfi = 0; sfi < Math.min(scFields.length, 2); sfi++) {
        w("  assert(schema.collections[" + _jsStr(scName) + "].fields.indexOf(" + _jsStr(scFields[sfi]) + ") !== -1, 'schema " + scName + " has " + scFields[sfi] + " field');");
      }
    }
    w('})();');
    w('');

    // --- applyAction tests ---
    w('// --- applyAction ---');
    w('');
    w('(function testApplyAction_create() {');
    w('  var state = ' + moduleVar + '.initState();');
    w('  var msg = {');
    w("    from: 'user1',");
    w('    payload: {');
    w('      action: ' + _jsStr('create_' + firstColl) + ',');
    w("      data: { name: 'Action Created' }");
    w('    }');
    w('  };');
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w('  var items = ' + moduleVar + '.query(s2, ' + _jsStr(firstColl) + ', null);');
    w("  assertEqual(items.length, 1, 'applyAction create adds record');");
    w("  assertEqual(items[0].name, 'Action Created', 'applyAction create passes name');");
    w("  assertEqual(items[0].owner, 'user1', 'applyAction sets owner from msg.from');");
    w('})();');
    w('');

    w('(function testApplyAction_update() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var r = " + moduleVar + ".create_" + firstColl + "(state, { name: 'Before' });");
    w('  state = r.state;');
    w('  var id = r.record.id;');
    w('  var msg = {');
    w("    from: 'user1',");
    w('    payload: {');
    w('      action: ' + _jsStr('update_' + firstColl) + ',');
    w("      data: { id: id, name: 'After' }");
    w('    }');
    w('  };');
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w("  assertEqual(s2[" + _jsStr(firstColl) + "][id].name, 'After', 'applyAction update changes name');");
    w('})();');
    w('');

    w('(function testApplyAction_delete() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var r = " + moduleVar + ".create_" + firstColl + "(state, { name: 'Gone' });");
    w('  state = r.state;');
    w('  var id = r.record.id;');
    w('  var msg = {');
    w("    from: 'user1',");
    w('    payload: {');
    w('      action: ' + _jsStr('delete_' + firstColl) + ',');
    w('      data: { id: id }');
    w('    }');
    w('  };');
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w("  assert(s2[" + _jsStr(firstColl) + "][id] === undefined, 'applyAction delete removes record');");
    w('})();');
    w('');

    w('(function testApplyAction_unknown() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var msg = { from: 'x', payload: { action: 'nonexistent_action_xyz', data: {} } };");
    w('  var s2 = ' + moduleVar + '.applyAction(state, msg);');
    w("  assert(s2 === state, 'applyAction unknown action returns same state');");
    w('})();');
    w('');

    // --- Edge cases ---
    w('// --- Edge cases ---');
    w('');

    w('(function testCreate_missing_fields() {');
    w('  // Create with no data â€” should not throw, uses defaults');
    w('  var state = ' + moduleVar + '.initState();');
    w('  var result = ' + moduleVar + '.create_' + firstColl + '(state, {});');
    w("  assert(result && result.record && result.record.id, 'create with empty data sets an id');");
    w('})();');
    w('');

    w('(function testUpdate_nonexistent_id() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var result = " + moduleVar + ".update_" + firstColl + "(state, 'nonexistent', { name: 'X' });");
    w("  assert(result === state, 'update nonexistent id returns same state unchanged');");
    w('})();');
    w('');

    w('(function testDelete_nonexistent_id() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var result = " + moduleVar + ".delete_" + firstColl + "(state, 'nonexistent');");
    w("  assert(result === state, 'delete nonexistent id returns same state');");
    w('})();');
    w('');

    // --- Snapshot roundtrip ---
    w('// --- Snapshot roundtrip ---');
    w('');
    w('(function testSnapshotRoundtrip() {');
    w('  var state = ' + moduleVar + '.initState();');
    for (var sri = 0; sri < collNames.length; sri++) {
      var srName = collNames[sri];
      var srVar = 'r_' + srName;
      w("  var " + srVar + " = " + moduleVar + ".create_" + srName + "(state, { name: 'Persist " + srName + "' });");
      w('  state = ' + srVar + '.state;');
    }
    w('  var json = JSON.stringify(state);');
    w('  var restored = ' + moduleVar + '.initState(JSON.parse(json));');
    for (var srrI = 0; srrI < collNames.length; srrI++) {
      var srrName = collNames[srrI];
      w("  assertEqual(Object.keys(restored[" + _jsStr(srrName) + "]).length, 1, 'snapshot restores " + srrName + "');");
    }
    w('})();');
    w('');

    // --- getState ---
    w('(function testGetState() {');
    w('  var state = ' + moduleVar + '.initState();');
    w('  var got = ' + moduleVar + '.getState();');
    w("  assert(got && typeof got === 'object', 'getState returns object');");
    w("  assert(got._schema !== undefined, 'getState includes schema');");
    w('})();');
    w('');

    // --- query ---
    w('(function testQuery() {');
    w('  var state = ' + moduleVar + '.initState();');
    w("  var r1 = " + moduleVar + ".create_" + firstColl + "(state, { name: 'A', status: 'active' });");
    w('  state = r1.state;');
    w("  var r2 = " + moduleVar + ".create_" + firstColl + "(state, { name: 'B', status: 'done' });");
    w('  state = r2.state;');
    w('  var all = ' + moduleVar + '.query(state, ' + _jsStr(firstColl) + ', null);');
    w("  assertEqual(all.length, 2, 'query all returns 2');");
    w("  var active = " + moduleVar + ".query(state, " + _jsStr(firstColl) + ", { status: 'active' });");
    w("  assertEqual(active.length, 1, 'query filtered returns 1');");
    w("  var none = " + moduleVar + ".query(state, 'nonexistent_collection', {});");
    w("  assertEqual(none.length, 0, 'query nonexistent collection returns empty');");
    w('})();');
    w('');

    // Results
    w('// --- Results ---');
    w('');
    w("console.log('\\n" + moduleName + " Tests: ' + passed + ' passed, ' + failed + ' failed');");
    w('if (failed > 0) {');
    w('  process.exit(1);');
    w('} else {');
    w("  console.log('All " + name + " simulation tests passed!');");
    w('}');

    return lines.join('\n') + '\n';
  }

  // ---------------------------------------------------------------------------
  // forge â€” all-in-one: parse + generate everything
  // ---------------------------------------------------------------------------

  function forge(specInput) {
    var spec = parseSpec(specInput);
    var moduleSource = generateModule(spec);
    var initialState = generateState(spec);
    var testSource = generateTests(spec);
    return {
      name: spec.name,
      moduleSource: moduleSource,
      initialState: initialState,
      testSource: testSource
    };
  }

  // ---------------------------------------------------------------------------
  // loadAndRun â€” parse spec, generate module, eval it, return running instance
  // ---------------------------------------------------------------------------

  function loadAndRun(specInput) {
    var spec = parseSpec(specInput);
    var moduleSource = generateModule(spec);

    // The generated module uses the UMD pattern:
    // (function(exports) { ... })(typeof module !== 'undefined' ? module.exports : (window.SimXxx = {}));
    //
    // To eval it safely in any environment (browser or Node), we provide a
    // mock `module` object with an `exports` property. The UMD will detect
    // `typeof module !== 'undefined'` as true and write into mockModule.exports.
    // We also provide a mock `window` in case it is referenced at all.
    var simModule;
    try {
      var mockModule = { exports: {} };
      var mockWindow = {};
      // Use Function constructor with explicit arguments to sandbox the eval
      var factory = new Function('module', 'exports', 'window', moduleSource);
      factory(mockModule, mockModule.exports, mockWindow);
      simModule = mockModule.exports;
    } catch (e) {
      throw new Error('loadAndRun: failed to eval generated module for "' + spec.name + '": ' + e.message);
    }

    // Auto-initialize state
    simModule.initState();

    return simModule;
  }

  // ---------------------------------------------------------------------------
  // getExampleSpecs â€” built-in example spec objects for players to explore
  // ---------------------------------------------------------------------------

  function getExampleSpecs() {
    return [
      {
        name: 'todo',
        description: 'A simple todo list simulation',
        collections: {
          tasks: {
            fields: ['title', 'done', 'priority', 'due_date', 'notes']
          }
        },
        actions: ['create', 'update', 'delete', 'complete']
      },
      {
        name: 'project_manager',
        description: 'A project management simulation',
        collections: {
          projects: {
            fields: ['title', 'status', 'owner', 'deadline', 'budget']
          },
          tasks: {
            fields: ['title', 'status', 'assignee', 'board_id', 'priority', 'done']
          },
          milestones: {
            fields: ['title', 'due_date', 'status']
          }
        },
        actions: ['create', 'update', 'delete', 'complete', 'assign', 'move']
      },
      {
        name: 'inventory',
        description: 'An inventory management simulation',
        collections: {
          items: {
            fields: ['name', 'quantity', 'category', 'unit_price', 'location', 'notes']
          },
          categories: {
            fields: ['name', 'description']
          },
          transactions: {
            fields: ['item_id', 'quantity', 'type', 'timestamp', 'notes']
          }
        },
        actions: ['create', 'update', 'delete']
      },
      {
        name: 'recipe_book',
        description: 'A recipe collection simulation',
        collections: {
          recipes: {
            fields: ['title', 'cuisine', 'prep_time', 'servings', 'difficulty', 'notes']
          },
          ingredients: {
            fields: ['name', 'quantity', 'unit', 'recipe_id']
          },
          tags: {
            fields: ['name', 'color']
          }
        },
        actions: ['create', 'update', 'delete']
      }
    ];
  }

  // ---------------------------------------------------------------------------
  // Public API
  // ---------------------------------------------------------------------------

  exports.parseSpec = parseSpec;
  exports.generateModule = generateModule;
  exports.generateState = generateState;
  exports.generateTests = generateTests;
  exports.forge = forge;
  exports.loadAndRun = loadAndRun;
  exports.getExampleSpecs = getExampleSpecs;

})(typeof module !== 'undefined' ? module.exports : (window.SimForge = {}));


// world.js
(function(exports) {
  // ========================================================================
  // UNIFIED WORLD â€” Continuous terrain with 8 geographic zones
  // Chunk-based loading, noise heightmap, zone structures, physics
  // ========================================================================

  // Module references (set at runtime from window globals)
  var Seasons = (typeof window !== 'undefined' && window.Seasons) ? window.Seasons : null;

  var playerMeshes = new Map();
  var skyDome = null, sunMesh = null, moonMesh = null, stars = null;
  var clouds = [];
  var animatedObjects = [];
  var loadedChunks = new Map(); // "cx_cz" -> { group, objects[] }
  var activeZone = 'nexus';
  var zoneLights = []; // Night-time point lights at zone landmarks

  // Texture loader and cache
  var textureLoader = null;
  var textureCache = {};
  var ASSET_BASE = '';

  function getTexture(name) {
    if (!textureLoader) {
      if (typeof THREE === 'undefined') return null;
      textureLoader = new THREE.TextureLoader();
      if (typeof window !== 'undefined') {
        var path = window.location.pathname;
        ASSET_BASE = path.substring(0, path.lastIndexOf('/') + 1);
      }
    }
    if (textureCache[name]) return textureCache[name];
    var tex = textureLoader.load(ASSET_BASE + 'assets/textures/' + name);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    textureCache[name] = tex;
    return tex;
  }

  // ========================================================================
  // CONSTANTS
  // ========================================================================

  var CHUNK_SIZE = 64;
  var LOAD_RADIUS = 3; // chunks in each direction
  var WORLD_HALF = 600; // -600 to +600

  // ========================================================================
  // ZONE DEFINITIONS â€” Geographic regions on unified map
  // ========================================================================

  var ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, baseHeight: 2,   color: 0x8888cc, groundColor: 0xb0b0d0, texName: 'stone.png', name: 'The Nexus' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, baseHeight: 0,   color: 0x4caf50, groundColor: 0x3a8f3a, texName: 'grass.png', name: 'The Gardens' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, baseHeight: 4,   color: 0x795548, groundColor: 0x9e9e9e, texName: 'marble.png', name: 'The Athenaeum' },
    studio:     { cx: -200, cz: -100, radius: 60, baseHeight: 1,   color: 0xff9800, groundColor: 0xd4a76a, texName: 'wood.png', name: 'The Studio' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, baseHeight: -1,  color: 0x2e7d32, groundColor: 0x1b5e20, texName: 'grass_dark.png', name: 'The Wilds' },
    agora:      { cx: -190, cz: 120,  radius: 55, baseHeight: 1.5, color: 0xffd700, groundColor: 0xc8a45a, texName: 'cobblestone.png', name: 'The Agora' },
    commons:    { cx: 170,  cz: 190,  radius: 55, baseHeight: 0.5, color: 0xfaf0e6, groundColor: 0xd2b48c, texName: 'dirt_path.png', name: 'The Commons' },
    arena:      { cx: 0,    cz: -240, radius: 55, baseHeight: 3,   color: 0xd2691e, groundColor: 0xe0c097, texName: 'sand.png', name: 'The Arena' }
  };

  // ========================================================================
  // SEEDED RANDOM â€” deterministic world generation
  // ========================================================================

  function hash2D(x, y) {
    var n = x * 374761393 + y * 668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    return ((n ^ (n >> 16)) & 0x7fffffff) / 0x7fffffff;
  }

  function smoothstep(t) { return t * t * (3 - 2 * t); }

  function noise2D(x, y) {
    var ix = Math.floor(x), iy = Math.floor(y);
    var fx = x - ix, fy = y - iy;
    fx = smoothstep(fx);
    fy = smoothstep(fy);
    var a = hash2D(ix, iy);
    var b = hash2D(ix + 1, iy);
    var c = hash2D(ix, iy + 1);
    var d = hash2D(ix + 1, iy + 1);
    return a + (b - a) * fx + (c - a) * fy + (a - b - c + d) * fx * fy;
  }

  function seededRandom(a, b, c) {
    var n = a * 12345 + b * 67890 + (c || 0) * 11111;
    return hash2D(n, n * 7);
  }

  // ========================================================================
  // TERRAIN HEIGHT â€” Multi-octave noise with zone flattening
  // ========================================================================

  function rawTerrainHeight(wx, wz) {
    var h = 0;
    // 4 octaves of noise
    h += noise2D(wx * 0.008, wz * 0.008) * 20;    // broad hills
    h += noise2D(wx * 0.02, wz * 0.02) * 8;        // medium detail
    h += noise2D(wx * 0.06, wz * 0.06) * 3;        // fine detail
    h += noise2D(wx * 0.15, wz * 0.15) * 1;        // micro detail
    return h - 10; // shift baseline down
  }

  function terrainHeight(wx, wz) {
    var raw = rawTerrainHeight(wx, wz);

    // Flatten terrain near zone centers with smooth blend
    for (var zoneId in ZONES) {
      var z = ZONES[zoneId];
      var dx = wx - z.cx, dz = wz - z.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var flatRadius = z.radius * 0.5;
      var blendRadius = z.radius * 0.9;

      if (dist < blendRadius) {
        var t;
        if (dist < flatRadius) {
          t = 1.0;
        } else {
          t = 1.0 - (dist - flatRadius) / (blendRadius - flatRadius);
          t = smoothstep(t);
        }
        raw = raw * (1 - t) + z.baseHeight * t;
      }
    }

    // Flatten paths between zones (connecting to nexus)
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var nx = ZONES.nexus.cx, nz = ZONES.nexus.cz;
      // Distance from point to line segment (nexus -> zone center)
      var pathDist = pointToSegDist(wx, wz, nx, nz, zone.cx, zone.cz);
      if (pathDist < 8) {
        var pathBlend = smoothstep(1.0 - pathDist / 8);
        // Lerp path height between zone base heights
        var segT = projectOnSeg(wx, wz, nx, nz, zone.cx, zone.cz);
        var pathH = ZONES.nexus.baseHeight * (1 - segT) + zone.baseHeight * segT;
        raw = raw * (1 - pathBlend * 0.8) + pathH * pathBlend * 0.8;
      }
    }

    return raw;
  }

  function pointToSegDist(px, pz, ax, az, bx, bz) {
    var abx = bx - ax, abz = bz - az;
    var apx = px - ax, apz = pz - az;
    var t = (apx * abx + apz * abz) / (abx * abx + abz * abz + 0.001);
    t = Math.max(0, Math.min(1, t));
    var cx = ax + t * abx - px, cz = az + t * abz - pz;
    return Math.sqrt(cx * cx + cz * cz);
  }

  function projectOnSeg(px, pz, ax, az, bx, bz) {
    var abx = bx - ax, abz = bz - az;
    var apx = px - ax, apz = pz - az;
    return Math.max(0, Math.min(1, (apx * abx + apz * abz) / (abx * abx + abz * abz + 0.001)));
  }

  // ========================================================================
  // ZONE DETECTION
  // ========================================================================

  function getZoneAtPosition(wx, wz) {
    var closest = 'nexus', closestDist = Infinity;
    for (var zoneId in ZONES) {
      var z = ZONES[zoneId];
      var dx = wx - z.cx, dz = wz - z.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      // Weight by zone radius so smaller zones still "own" their area
      var weighted = dist / z.radius;
      if (weighted < closestDist) {
        closestDist = weighted;
        closest = zoneId;
      }
    }
    return closest;
  }

  function getZoneCenter(zoneId) {
    var z = ZONES[zoneId];
    return z ? { x: z.cx, z: z.cz } : { x: 0, z: 0 };
  }

  function getTerrainHeight(wx, wz) {
    return terrainHeight(wx, wz);
  }

  // ========================================================================
  // CHUNK SYSTEM â€” dynamic terrain loading/unloading
  // ========================================================================

  function chunkKey(cx, cz) { return cx + '_' + cz; }

  function updateChunks(sceneCtx, playerX, playerZ) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var pcx = Math.floor(playerX / CHUNK_SIZE);
    var pcz = Math.floor(playerZ / CHUNK_SIZE);

    // Determine which chunks should be loaded
    var needed = new Set();
    for (var dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
      for (var dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
        needed.add(chunkKey(pcx + dx, pcz + dz));
      }
    }

    // Unload chunks that are too far
    var toRemove = [];
    loadedChunks.forEach(function(chunkData, key) {
      if (!needed.has(key)) {
        sceneCtx.scene.remove(chunkData.group);
        // Dispose geometry/materials
        chunkData.group.traverse(function(obj) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(function(m) { m.dispose(); });
            else obj.material.dispose();
          }
        });
        toRemove.push(key);
      }
    });
    toRemove.forEach(function(key) { loadedChunks.delete(key); });

    // Load new chunks
    needed.forEach(function(key) {
      if (!loadedChunks.has(key)) {
        var parts = key.split('_');
        var cx = parseInt(parts[0]), cz = parseInt(parts[1]);
        generateChunk(sceneCtx.scene, cx, cz);
      }
    });
  }

  function generateChunk(scene, cx, cz) {
    var group = new THREE.Group();
    var wx = cx * CHUNK_SIZE, wz = cz * CHUNK_SIZE;

    // Determine dominant zone for this chunk
    var centerX = wx + CHUNK_SIZE / 2, centerZ = wz + CHUNK_SIZE / 2;
    var zone = getZoneAtPosition(centerX, centerZ);
    var zoneData = ZONES[zone];

    // ---- TERRAIN MESH ----
    var res = 16; // vertices per side
    var step = CHUNK_SIZE / res;
    var geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, res, res);
    var positions = geo.attributes.position.array;
    var colors = new Float32Array(positions.length);

    for (var i = 0; i <= res; i++) {
      for (var j = 0; j <= res; j++) {
        var idx = (i * (res + 1) + j);
        var px = wx + j * step;
        var pz = wz + i * step;
        var h = terrainHeight(px, pz);

        // Set vertex position directly in XZ plane (y-up)
        positions[idx * 3] = j * step;     // local x
        positions[idx * 3 + 1] = h;        // height (y-up)
        positions[idx * 3 + 2] = i * step; // local z

        // Vertex color based on zone/height
        var localZone = getZoneAtPosition(px, pz);
        var lz = ZONES[localZone];
        var r = ((lz.groundColor >> 16) & 0xff) / 255;
        var g = ((lz.groundColor >> 8) & 0xff) / 255;
        var b = (lz.groundColor & 0xff) / 255;

        // Height-based color variation
        var hFactor = Math.max(0, Math.min(1, (h + 5) / 30));
        r = r * (0.8 + hFactor * 0.4);
        g = g * (0.8 + hFactor * 0.2);
        b = b * (0.7 + hFactor * 0.3);

        // Path darkening
        for (var zId in ZONES) {
          if (zId === 'nexus') continue;
          var pDist = pointToSegDist(px, pz, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[zId].cx, ZONES[zId].cz);
          if (pDist < 6) {
            var pathFade = 1 - pDist / 6;
            r = r * (1 - pathFade * 0.3) + 0.55 * pathFade * 0.3;
            g = g * (1 - pathFade * 0.3) + 0.45 * pathFade * 0.3;
            b = b * (1 - pathFade * 0.3) + 0.35 * pathFade * 0.3;
          }
        }

        // World Memory: footpath darkening
        var memCell = getMemoryAtPosition(px, pz);
        if (memCell && memCell.steps > 5) {
          var pathStr = Math.min(1, (memCell.steps - 5) / 45);
          r = r * (1 - pathStr * 0.4) + 0.45 * pathStr * 0.4;
          g = g * (1 - pathStr * 0.4) + 0.35 * pathStr * 0.4;
          b = b * (1 - pathStr * 0.4) + 0.25 * pathStr * 0.4;
        }

        colors[idx * 3] = Math.min(1, r);
        colors[idx * 3 + 1] = Math.min(1, g);
        colors[idx * 3 + 2] = Math.min(1, b);
      }
    }

    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geo.computeVertexNormals();

    var mat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      roughness: 0.9,
      metalness: 0.0,
      flatShading: false
    });

    // Try to apply zone texture
    var tex = getTexture(zoneData.texName);
    if (tex) {
      tex.repeat.set(4, 4);
      mat.map = tex;
    }

    var mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(wx, 0, wz);
    mesh.receiveShadow = false;
    group.add(mesh);

    // ---- WORLD MEMORY OBJECTS (flowers, gathering spots) ----
    generateMemoryObjects(group, cx, cz, wx, wz);

    // ---- DETAIL OBJECTS ----
    generateChunkDetails(group, cx, cz, zone, wx, wz);

    scene.add(group);
    loadedChunks.set(chunkKey(cx, cz), { group: group });
  }

  // ========================================================================
  // WORLD MEMORY OBJECTS â€” Flowers and gathering spot campfires
  // ========================================================================

  function generateMemoryObjects(group, cx, cz, wx, wz) {
    // Scan worldMemory cells that fall in this chunk
    for (var gx = Math.floor(wx / MEMORY_GRID_SIZE); gx <= Math.floor((wx + CHUNK_SIZE) / MEMORY_GRID_SIZE); gx++) {
      for (var gz = Math.floor(wz / MEMORY_GRID_SIZE); gz <= Math.floor((wz + CHUNK_SIZE) / MEMORY_GRID_SIZE); gz++) {
        var key = gx + '_' + gz;
        var cell = worldMemory[key];
        if (!cell) continue;

        var cellX = gx * MEMORY_GRID_SIZE + MEMORY_GRID_SIZE / 2;
        var cellZ = gz * MEMORY_GRID_SIZE + MEMORY_GRID_SIZE / 2;
        var cellY = terrainHeight(cellX, cellZ);

        // Flowers
        if (cell.flowers) {
          for (var f = 0; f < 3; f++) {
            var fx = cellX + (f - 1) * 0.5;
            var fz = cellZ + (f * 0.7 - 0.7);
            var fy = terrainHeight(fx, fz);

            // Stem
            var stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 4);
            var stemMat = new THREE.MeshLambertMaterial({ color: 0x228822 });
            var stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.set(fx - wx, fy + 0.15, fz - wz);
            group.add(stem);

            // Petal
            var petalColors = [0xff6699, 0xffcc33, 0xff3366, 0x9966ff, 0xff9933];
            var petalGeo = new THREE.SphereGeometry(0.12, 6, 4);
            var petalMat = new THREE.MeshLambertMaterial({ color: petalColors[f % petalColors.length] });
            var petal = new THREE.Mesh(petalGeo, petalMat);
            petal.position.set(fx - wx, fy + 0.32, fz - wz);
            group.add(petal);
          }
        }

        // Gathering spots (campfire ring)
        if (cell.gathering > 3) {
          // 3 rocks in a ring
          for (var ri = 0; ri < 3; ri++) {
            var rockAngle = (ri / 3) * Math.PI * 2;
            var rockX = cellX + Math.cos(rockAngle) * 0.8;
            var rockZ = cellZ + Math.sin(rockAngle) * 0.8;
            var rockY = terrainHeight(rockX, rockZ);

            var rockGeo = new THREE.SphereGeometry(0.2, 4, 3);
            var rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            var rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(rockX - wx, rockY + 0.1, rockZ - wz);
            rock.scale.y = 0.5;
            group.add(rock);
          }

          // Orange glow
          var glowLight = new THREE.PointLight(0xff6622, 0.5, 5);
          glowLight.position.set(cellX - wx, cellY + 0.3, cellZ - wz);
          group.add(glowLight);
        }
      }
    }
  }

  // ========================================================================
  // CHUNK DETAIL GENERATION â€” trees, rocks, flowers, grass clumps
  // ========================================================================

  function generateChunkDetails(group, cx, cz, zone, wx, wz) {
    var seed = cx * 7919 + cz * 6271;

    // Skip details for chunks far from any zone
    var nearZone = false;
    for (var zId in ZONES) {
      var z = ZONES[zId];
      var dx = (wx + CHUNK_SIZE / 2) - z.cx;
      var dz = (wz + CHUNK_SIZE / 2) - z.cz;
      if (Math.sqrt(dx * dx + dz * dz) < z.radius + CHUNK_SIZE) {
        nearZone = true;
        break;
      }
    }

    // Trees density based on zone
    var treeDensity = 0;
    if (zone === 'gardens') treeDensity = 12;
    else if (zone === 'wilds') treeDensity = 18;
    else if (zone === 'commons') treeDensity = 4;
    else if (zone === 'studio') treeDensity = 3;
    else if (zone === 'agora') treeDensity = 2;
    else treeDensity = nearZone ? 5 : 8; // wilderness between zones

    for (var t = 0; t < treeDensity; t++) {
      var tx = wx + seededRandom(seed, t, 1) * CHUNK_SIZE;
      var tz = wz + seededRandom(seed, t, 2) * CHUNK_SIZE;

      // Don't place trees on paths
      var onPath = false;
      for (var pz in ZONES) {
        if (pz === 'nexus') continue;
        if (pointToSegDist(tx, tz, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[pz].cx, ZONES[pz].cz) < 5) {
          onPath = true;
          break;
        }
      }
      if (onPath) continue;

      // Don't place inside zone center structures
      var inCenter = false;
      for (var zId2 in ZONES) {
        var zd = ZONES[zId2];
        var ddx = tx - zd.cx, ddz = tz - zd.cz;
        if (Math.sqrt(ddx * ddx + ddz * ddz) < zd.radius * 0.35) {
          inCenter = true;
          break;
        }
      }
      if (inCenter) continue;

      var th = terrainHeight(tx, tz);
      createTree(group, tx, th, tz, seed + t, zone);
    }

    // Rocks
    var rockDensity = (zone === 'wilds' || zone === 'arena') ? 8 : (zone === 'nexus' || zone === 'athenaeum') ? 4 : 3;
    for (var r = 0; r < rockDensity; r++) {
      var rx = wx + seededRandom(seed + 100, r, 1) * CHUNK_SIZE;
      var rz = wz + seededRandom(seed + 100, r, 2) * CHUNK_SIZE;
      var rh = terrainHeight(rx, rz);
      createRock(group, rx, rh, rz, seed + 100 + r);
    }

    // Flowers (gardens, commons)
    if (zone === 'gardens' || zone === 'commons' || zone === 'wilds') {
      var flowerDensity = zone === 'gardens' ? 20 : 8;
      for (var f = 0; f < flowerDensity; f++) {
        var fx = wx + seededRandom(seed + 200, f, 1) * CHUNK_SIZE;
        var fz = wz + seededRandom(seed + 200, f, 2) * CHUNK_SIZE;
        var fh = terrainHeight(fx, fz);
        createFlower(group, fx, fh, fz, seed + 200 + f);
      }
    }

    // Grass clumps everywhere
    var grassDensity = (zone === 'gardens' || zone === 'wilds') ? 15 : (zone === 'arena' || zone === 'nexus') ? 3 : 8;
    for (var g = 0; g < grassDensity; g++) {
      var gx = wx + seededRandom(seed + 300, g, 1) * CHUNK_SIZE;
      var gz = wz + seededRandom(seed + 300, g, 2) * CHUNK_SIZE;
      var gh = terrainHeight(gx, gz);
      createGrassClump(group, gx, gh, gz, seed + 300 + g);
    }
  }

  // ========================================================================
  // DETAIL OBJECT CREATORS
  // ========================================================================

  function createTree(parent, x, y, z, seed, zone) {
    var treeGroup = new THREE.Group();
    var scale = 0.5 + seededRandom(seed, 0, 5) * 0.5;
    var treeType = seededRandom(seed, 0, 6);

    // Trunk
    var trunkH = 2.5 * scale + seededRandom(seed, 0, 7) * 1.5 * scale;
    var trunkR = 0.15 * scale + seededRandom(seed, 0, 8) * 0.1 * scale;
    var trunkGeo = new THREE.CylinderGeometry(trunkR * 0.7, trunkR, trunkH, 6);
    var trunkColor = zone === 'wilds' ? 0x4a3728 : 0x8B4513;
    var trunkMat = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.95 });
    var trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = trunkH / 2;
    trunk.castShadow = false;
    treeGroup.add(trunk);

    // Canopy
    if (treeType < 0.4) {
      // Round tree
      var canopyR = 1.2 * scale + seededRandom(seed, 0, 9) * 0.8 * scale;
      var canopyGeo = new THREE.SphereGeometry(canopyR, 8, 8);
      var canopyColor = zone === 'wilds' ? 0x1a5e1a : (zone === 'gardens' ? 0x4CAF50 : 0x2d8a2d);
      var canopyMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.85 });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.y = trunkH + canopyR * 0.6;
      canopy.castShadow = false;
      treeGroup.add(canopy);
    } else if (treeType < 0.7) {
      // Cone tree (pine)
      var pineH = 3 * scale;
      var pineR = 1.2 * scale;
      var pineGeo = new THREE.ConeGeometry(pineR, pineH, 8);
      var pineColor = zone === 'wilds' ? 0x0d4d0d : 0x1b7a1b;
      var pineMat = new THREE.MeshStandardMaterial({ color: pineColor, roughness: 0.85 });
      var pine = new THREE.Mesh(pineGeo, pineMat);
      pine.position.y = trunkH + pineH / 2 - 0.5;
      pine.castShadow = false;
      treeGroup.add(pine);
    } else {
      // Multi-sphere canopy
      for (var cs = 0; cs < 3; cs++) {
        var msr = 0.8 * scale + seededRandom(seed + cs, 0, 10) * 0.5 * scale;
        var msGeo = new THREE.SphereGeometry(msr, 6, 6);
        var msColor = 0x2d8a2d + Math.floor(seededRandom(seed + cs, 0, 11) * 0x202020);
        var msMat = new THREE.MeshStandardMaterial({ color: msColor, roughness: 0.85 });
        var msMesh = new THREE.Mesh(msGeo, msMat);
        var angle = cs * Math.PI * 2 / 3;
        msMesh.position.set(
          Math.cos(angle) * 0.8 * scale,
          trunkH + msr * 0.4 + cs * 0.5 * scale,
          Math.sin(angle) * 0.8 * scale
        );
        msMesh.castShadow = false;
        treeGroup.add(msMesh);
      }
    }

    treeGroup.position.set(x, y, z);
    treeGroup.rotation.y = seededRandom(seed, 0, 12) * Math.PI * 2;
    parent.add(treeGroup);

    // Register for animation (sway)
    animatedObjects.push({
      mesh: treeGroup,
      type: 'tree',
      params: { speed: 0.3 + seededRandom(seed, 0, 13) * 0.4, seed: seed * 0.01 }
    });
  }

  function createRock(parent, x, y, z, seed) {
    var scale = 0.3 + seededRandom(seed, 1, 1) * 1.2;
    var geo = new THREE.DodecahedronGeometry(scale, 0);
    var grey = 0.4 + seededRandom(seed, 1, 2) * 0.3;
    var col = new THREE.Color(grey, grey, grey * 0.95);
    var mat = new THREE.MeshStandardMaterial({ color: col, roughness: 0.95, flatShading: true });
    var rock = new THREE.Mesh(geo, mat);
    rock.position.set(x, y + scale * 0.3, z);
    rock.rotation.set(
      seededRandom(seed, 1, 3) * Math.PI,
      seededRandom(seed, 1, 4) * Math.PI,
      seededRandom(seed, 1, 5) * Math.PI
    );
    rock.scale.set(
      0.7 + seededRandom(seed, 1, 6) * 0.6,
      0.5 + seededRandom(seed, 1, 7) * 0.5,
      0.7 + seededRandom(seed, 1, 8) * 0.6
    );
    rock.castShadow = false;
    parent.add(rock);
  }

  function createFlower(parent, x, y, z, seed) {
    var flowerGroup = new THREE.Group();
    // Stem
    var stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
    var stemMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
    var stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.y = 0.2;
    stem.castShadow = false;
    flowerGroup.add(stem);
    // Petals
    var petalColors = [0xff4081, 0xffeb3b, 0xe040fb, 0xff5722, 0x29b6f6, 0xffffff];
    var petalColor = petalColors[Math.floor(seededRandom(seed, 2, 1) * petalColors.length)];
    var petalGeo = new THREE.SphereGeometry(0.12, 6, 6);
    var petalMat = new THREE.MeshStandardMaterial({ color: petalColor });
    var petal = new THREE.Mesh(petalGeo, petalMat);
    petal.position.y = 0.42;
    petal.castShadow = false;
    flowerGroup.add(petal);

    flowerGroup.position.set(x, y, z);
    parent.add(flowerGroup);
  }

  function createGrassClump(parent, x, y, z, seed) {
    var count = 3 + Math.floor(seededRandom(seed, 3, 1) * 4);
    var grassGroup = new THREE.Group();
    for (var i = 0; i < count; i++) {
      var bladeH = 0.3 + seededRandom(seed, 3, i + 2) * 0.5;
      var bladeGeo = new THREE.ConeGeometry(0.03, bladeH, 3);
      var green = 0.3 + seededRandom(seed, 3, i + 10) * 0.4;
      var bladeMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0.1, green, 0.05)
      });
      var blade = new THREE.Mesh(bladeGeo, bladeMat);
      blade.position.set(
        (seededRandom(seed, 3, i + 20) - 0.5) * 0.6,
        bladeH / 2,
        (seededRandom(seed, 3, i + 30) - 0.5) * 0.6
      );
      blade.rotation.set(
        (seededRandom(seed, 3, i + 40) - 0.5) * 0.3,
        seededRandom(seed, 3, i + 50) * Math.PI,
        (seededRandom(seed, 3, i + 60) - 0.5) * 0.3
      );
      blade.castShadow = false;
      grassGroup.add(blade);
    }
    grassGroup.position.set(x, y, z);
    parent.add(grassGroup);
  }

  // ========================================================================
  // ZONE STRUCTURES â€” Landmark buildings at each zone center
  // ========================================================================

  function createZoneStructures(scene) {
    createNexusStructure(scene);
    createGardensStructure(scene);
    createAtheneumStructure(scene);
    createStudioStructure(scene);
    createWildsStructure(scene);
    createAgoraStructure(scene);
    createCommonsStructure(scene);
    createArenaStructure(scene);
    createPortals(scene);
  }

  // Night-time warm point lights at zone landmarks
  function createZoneNightLights(scene) {
    var lightDefs = [
      // nexus: pillars + obelisk
      { x: 5, z: 5, y: 4, zone: 'nexus' },
      { x: -5, z: 5, y: 4, zone: 'nexus' },
      { x: -5, z: -5, y: 4, zone: 'nexus' },
      { x: 0, z: 0, y: 6, zone: 'nexus' },
      // gardens: fountain + paths
      { x: 200, z: 30, y: 3, zone: 'gardens' },
      { x: 210, z: 40, y: 2.5, zone: 'gardens' },
      { x: 190, z: 20, y: 2.5, zone: 'gardens' },
      // athenaeum: library windows + entrance
      { x: 100, z: -220, y: 4, zone: 'athenaeum' },
      { x: 105, z: -215, y: 4, zone: 'athenaeum' },
      { x: 95, z: -225, y: 3, zone: 'athenaeum' },
      // studio: workbenches
      { x: -200, z: -100, y: 3, zone: 'studio' },
      { x: -195, z: -95, y: 3, zone: 'studio' },
      // agora: market stalls + central
      { x: -190, z: 120, y: 3, zone: 'agora' },
      { x: -185, z: 125, y: 3, zone: 'agora' },
      { x: -195, z: 115, y: 3.5, zone: 'agora' },
      // commons: near buildings
      { x: 170, z: 190, y: 3, zone: 'commons' },
      { x: 175, z: 195, y: 3, zone: 'commons' },
      // wilds: campfire clearing
      { x: -30, z: 260, y: 2.5, zone: 'wilds' },
      // arena: perimeter braziers
      { x: 8, z: -240, y: 3.5, zone: 'arena' },
      { x: -8, z: -240, y: 3.5, zone: 'arena' }
    ];

    var glowGeo = new THREE.SphereGeometry(0.15, 8, 8);

    for (var i = 0; i < lightDefs.length; i++) {
      var def = lightDefs[i];
      var ty = terrainHeight(def.x, def.z) + def.y;

      var light = new THREE.PointLight(0xffaa55, 0, 15, 2);
      light.position.set(def.x, ty, def.z);
      scene.add(light);

      // Visible glow sphere
      var glowMat = new THREE.MeshBasicMaterial({
        color: 0xffcc66,
        transparent: true,
        opacity: 0
      });
      var glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.set(def.x, ty, def.z);
      scene.add(glow);

      zoneLights.push({ light: light, glow: glow, zone: def.zone });
    }
  }

  function createNexusStructure(scene) {
    var z = ZONES.nexus, y = z.baseHeight;
    // Central platform â€” large circular stone platform
    var platGeo = new THREE.CylinderGeometry(12, 14, 1.5, 32);
    var platMat = new THREE.MeshStandardMaterial({ color: 0xc0c0d0, roughness: 0.7 });
    var plat = new THREE.Mesh(platGeo, platMat);
    plat.position.set(z.cx, y + 0.75, z.cz);
    plat.castShadow = false;
    scene.add(plat);

    // Central crystal obelisk
    var obGeo = new THREE.CylinderGeometry(0.5, 1.5, 10, 6);
    var obMat = new THREE.MeshStandardMaterial({ color: 0x6666ff, emissive: 0x3333aa, emissiveIntensity: 0.4 });
    var obelisk = new THREE.Mesh(obGeo, obMat);
    obelisk.position.set(z.cx, y + 6.5, z.cz);
    obelisk.castShadow = false;
    scene.add(obelisk);
    animatedObjects.push({ mesh: obelisk, type: 'crystal', params: { speed: 0.3, baseY: y + 6.5 } });

    // 8 pillars in circle
    for (var i = 0; i < 8; i++) {
      var angle = (i / 8) * Math.PI * 2;
      var px = z.cx + Math.cos(angle) * 10;
      var pz = z.cz + Math.sin(angle) * 10;
      var pillarGeo = new THREE.CylinderGeometry(0.4, 0.5, 6, 8);
      var pillarMat = new THREE.MeshStandardMaterial({ color: 0xd0d0e0 });
      var pillar = new THREE.Mesh(pillarGeo, pillarMat);
      pillar.position.set(px, y + 3, pz);
      pillar.castShadow = false;
      scene.add(pillar);

      // Pillar cap
      var capGeo = new THREE.SphereGeometry(0.6, 8, 8);
      var capMat = new THREE.MeshStandardMaterial({ color: 0xe0e0f0 });
      var cap = new THREE.Mesh(capGeo, capMat);
      cap.position.set(px, y + 6.2, pz);
      cap.castShadow = false;
      scene.add(cap);
    }

    // Glowing pool around obelisk
    var poolGeo = new THREE.CylinderGeometry(4, 4, 0.3, 24);
    var poolMat = new THREE.MeshStandardMaterial({
      color: 0x4488ff, emissive: 0x2244aa, emissiveIntensity: 0.3,
      transparent: true, opacity: 0.7
    });
    var pool = new THREE.Mesh(poolGeo, poolMat);
    pool.position.set(z.cx, y + 0.15, z.cz);
    pool.castShadow = false;
    scene.add(pool);
    animatedObjects.push({ mesh: pool, type: 'water', params: { speed: 1 } });

    // ENHANCED DECORATIONS: Glowing central monument
    var monumentGeo = new THREE.CylinderGeometry(0.8, 1.2, 3, 8);
    var monumentMat = new THREE.MeshStandardMaterial({
      color: 0xb0b0d0,
      emissive: 0x5555aa,
      emissiveIntensity: 0.2,
      roughness: 0.5
    });
    var monument = new THREE.Mesh(monumentGeo, monumentMat);
    monument.position.set(z.cx + 6, y + 2.5, z.cz + 6);
    monument.castShadow = false;
    scene.add(monument);

    // Fountain particle effects (4 water jets)
    for (var j = 0; j < 4; j++) {
      var jAngle = (j / 4) * Math.PI * 2;
      var jx = z.cx + Math.cos(jAngle) * 2;
      var jz = z.cz + Math.sin(jAngle) * 2;
      var jetGeo = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 8);
      var jetMat = new THREE.MeshStandardMaterial({
        color: 0x66aaff,
        transparent: true,
        opacity: 0.6
      });
      var jet = new THREE.Mesh(jetGeo, jetMat);
      jet.position.set(jx, y + 2.5, jz);
      jet.castShadow = false;
      scene.add(jet);
      animatedObjects.push({ mesh: jet, type: 'water', params: { speed: 2 } });
    }

    // Decorative benches around perimeter
    for (var b = 0; b < 4; b++) {
      var bAngle = (b / 4) * Math.PI * 2 + Math.PI / 8;
      var bx = z.cx + Math.cos(bAngle) * 16;
      var bz = z.cz + Math.sin(bAngle) * 16;

      var benchGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
      var benchMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(bx, y + 0.4, bz);
      bench.rotation.y = bAngle + Math.PI / 2;
      bench.castShadow = false;
      scene.add(bench);

      // Bench legs
      for (var leg = -1; leg <= 1; leg += 2) {
        var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 6);
        var legMesh = new THREE.Mesh(legGeo, benchMat);
        legMesh.position.set(
          bx + Math.cos(bAngle + Math.PI / 2) * leg * 0.9,
          y + 0.2,
          bz + Math.sin(bAngle + Math.PI / 2) * leg * 0.9
        );
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    // Knowledge orbs floating around
    for (var k = 0; k < 3; k++) {
      var kAngle = (k / 3) * Math.PI * 2;
      var kx = z.cx + Math.cos(kAngle) * 7;
      var kz = z.cz + Math.sin(kAngle) * 7;
      var orbGeo = new THREE.SphereGeometry(0.3, 12, 12);
      var orbMat = new THREE.MeshStandardMaterial({
        color: 0x8888ff,
        emissive: 0x6666cc,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(kx, y + 4 + k * 0.5, kz);
      orb.castShadow = false;
      scene.add(orb);
      animatedObjects.push({ mesh: orb, type: 'crystal', params: { speed: 0.4, baseY: y + 4 + k * 0.5 } });
    }
  }

  function createGardensStructure(scene) {
    var z = ZONES.gardens, y = z.baseHeight;
    // Garden beds in concentric circles
    for (var ring = 0; ring < 3; ring++) {
      var radius = 8 + ring * 8;
      var segments = 8 + ring * 4;
      for (var s = 0; s < segments; s++) {
        var angle = (s / segments) * Math.PI * 2;
        var bx = z.cx + Math.cos(angle) * radius;
        var bz = z.cz + Math.sin(angle) * radius;
        // Raised bed
        var bedGeo = new THREE.BoxGeometry(3, 0.6, 3);
        var bedMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var bed = new THREE.Mesh(bedGeo, bedMat);
        bed.position.set(bx, y + 0.3, bz);
        bed.rotation.y = angle;
        bed.castShadow = false;
        scene.add(bed);
        // Plants on bed
        var plantGeo = new THREE.SphereGeometry(0.8, 6, 6);
        var plantColors = [0x4caf50, 0x66bb6a, 0x81c784, 0xa5d6a7];
        var plantMat = new THREE.MeshStandardMaterial({
          color: plantColors[s % plantColors.length]
        });
        var plant = new THREE.Mesh(plantGeo, plantMat);
        plant.position.set(bx, y + 1.0, bz);
        plant.castShadow = false;
        scene.add(plant);
      }
    }

    // Central fountain
    var fountainGeo = new THREE.CylinderGeometry(3, 3.5, 1.5, 16);
    var fountainMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
    var fountain = new THREE.Mesh(fountainGeo, fountainMat);
    fountain.position.set(z.cx, y + 0.75, z.cz);
    fountain.castShadow = false;
    scene.add(fountain);

    var waterGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.3, 16);
    var waterMat = new THREE.MeshStandardMaterial({
      color: 0x4488cc, transparent: true, opacity: 0.6
    });
    var water = new THREE.Mesh(waterGeo, waterMat);
    water.position.set(z.cx, y + 1.5, z.cz);
    water.castShadow = false;
    scene.add(water);
    animatedObjects.push({ mesh: water, type: 'water', params: { speed: 1 } });

    // ENHANCED DECORATIONS: Seasonal growing plants (varied heights and colors)
    for (var sp = 0; sp < 12; sp++) {
      var spAngle = (sp / 12) * Math.PI * 2 + 0.2;
      var spRadius = 12 + (sp % 3) * 6;
      var spx = z.cx + Math.cos(spAngle) * spRadius;
      var spz = z.cz + Math.sin(spAngle) * spRadius;

      var plantHeight = 0.5 + seededRandom(sp, 10, 1) * 1.5;
      var plantGeo = new THREE.ConeGeometry(0.3, plantHeight, 6);
      var plantColors = [0x66bb6a, 0x81c784, 0xa5d6a7, 0x4caf50, 0x8bc34a];
      var plantMat = new THREE.MeshStandardMaterial({
        color: plantColors[sp % plantColors.length]
      });
      var plant = new THREE.Mesh(plantGeo, plantMat);
      plant.position.set(spx, y + plantHeight / 2, spz);
      plant.castShadow = false;
      scene.add(plant);
    }

    // Butterfly particle effects (small glowing spheres that float around)
    for (var bf = 0; bf < 8; bf++) {
      var bfAngle = (bf / 8) * Math.PI * 2;
      var bfx = z.cx + Math.cos(bfAngle) * (15 + bf % 3 * 5);
      var bfz = z.cz + Math.sin(bfAngle) * (15 + bf % 3 * 5);
      var butterflyGeo = new THREE.SphereGeometry(0.15, 6, 6);
      var butterflyMat = new THREE.MeshStandardMaterial({
        color: bf % 2 === 0 ? 0xffeb3b : 0xff69b4,
        emissive: bf % 2 === 0 ? 0xffeb3b : 0xff69b4,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.7
      });
      var butterfly = new THREE.Mesh(butterflyGeo, butterflyMat);
      butterfly.position.set(bfx, y + 1.5 + bf * 0.2, bfz);
      butterfly.castShadow = false;
      scene.add(butterfly);
      animatedObjects.push({
        mesh: butterfly,
        type: 'crystal',
        params: { speed: 0.5 + bf * 0.1, baseY: y + 1.5 + bf * 0.2 }
      });
    }

    // Garden archways (decorative trellises)
    for (var ga = 0; ga < 4; ga++) {
      var gaAngle = (ga / 4) * Math.PI * 2;
      var gax = z.cx + Math.cos(gaAngle) * 25;
      var gaz = z.cz + Math.sin(gaAngle) * 25;

      // Two posts
      for (var side = -1; side <= 1; side += 2) {
        var postGeo = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
        var postMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var post = new THREE.Mesh(postGeo, postMat);
        var perpAngle = gaAngle + Math.PI / 2;
        post.position.set(
          gax + Math.cos(perpAngle) * side * 1.5,
          y + 1.5,
          gaz + Math.sin(perpAngle) * side * 1.5
        );
        post.castShadow = false;
        scene.add(post);
      }

      // Top beam
      var beamGeo = new THREE.BoxGeometry(3.5, 0.2, 0.2);
      var beamMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var beam = new THREE.Mesh(beamGeo, beamMat);
      beam.position.set(gax, y + 3.2, gaz);
      beam.rotation.y = gaAngle + Math.PI / 2;
      beam.castShadow = false;
      scene.add(beam);

      // Vines on archway
      var vineGeo = new THREE.TorusGeometry(0.8, 0.08, 6, 12);
      var vineMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
      var vine = new THREE.Mesh(vineGeo, vineMat);
      vine.position.set(gax, y + 2.8, gaz);
      vine.rotation.x = Math.PI / 2;
      vine.castShadow = false;
      scene.add(vine);
    }

    // Stone pathways markers
    for (var pm = 0; pm < 6; pm++) {
      var pmAngle = (pm / 6) * Math.PI * 2;
      var pmx = z.cx + Math.cos(pmAngle) * 18;
      var pmz = z.cz + Math.sin(pmAngle) * 18;
      var markerGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
      var markerMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var marker = new THREE.Mesh(markerGeo, markerMat);
      marker.position.set(pmx, y + 0.15, pmz);
      marker.castShadow = false;
      scene.add(marker);
    }
  }

  function createAtheneumStructure(scene) {
    var z = ZONES.athenaeum, y = z.baseHeight;
    // Grand library building
    var baseGeo = new THREE.BoxGeometry(20, 6, 14);
    var baseMat = new THREE.MeshStandardMaterial({ color: 0xdbd8d0 });
    var base = new THREE.Mesh(baseGeo, baseMat);
    base.position.set(z.cx, y + 3, z.cz);
    base.castShadow = false;
    scene.add(base);

    // Roof
    var roofGeo = new THREE.ConeGeometry(14, 4, 4);
    var roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
    var roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.set(z.cx, y + 8, z.cz);
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = false;
    scene.add(roof);

    // Front columns
    for (var c = 0; c < 6; c++) {
      var colX = z.cx - 8 + c * 3.2;
      var colGeo = new THREE.CylinderGeometry(0.4, 0.5, 6, 8);
      var colMat = new THREE.MeshStandardMaterial({ color: 0xe8e4dc });
      var col = new THREE.Mesh(colGeo, colMat);
      col.position.set(colX, y + 3, z.cz + 8);
      col.castShadow = false;
      scene.add(col);
    }

    // Steps
    for (var st = 0; st < 4; st++) {
      var stepGeo = new THREE.BoxGeometry(18 + st * 2, 0.4, 2);
      var stepMat = new THREE.MeshStandardMaterial({ color: 0xccc8c0 });
      var step = new THREE.Mesh(stepGeo, stepMat);
      step.position.set(z.cx, y + 0.2 + st * 0.4, z.cz + 9 + st * 1.5);
      step.castShadow = false;
      scene.add(step);
    }

    // ENHANCED DECORATIONS: Floating book particles
    for (var fb = 0; fb < 10; fb++) {
      var fbAngle = (fb / 10) * Math.PI * 2;
      var fbRadius = 8 + (fb % 3) * 3;
      var fbx = z.cx + Math.cos(fbAngle) * fbRadius;
      var fbz = z.cz + Math.sin(fbAngle) * fbRadius;
      var bookGeo = new THREE.BoxGeometry(0.2, 0.3, 0.05);
      var bookMat = new THREE.MeshStandardMaterial({
        color: [0x8b4513, 0x5d4037, 0x3e2723][fb % 3],
        emissive: 0x4a2511,
        emissiveIntensity: 0.1
      });
      var book = new THREE.Mesh(bookGeo, bookMat);
      book.position.set(fbx, y + 5 + fb * 0.3, fbz);
      book.rotation.y = fbAngle;
      book.rotation.x = Math.PI / 6;
      book.castShadow = false;
      scene.add(book);
      animatedObjects.push({
        mesh: book,
        type: 'crystal',
        params: { speed: 0.2, baseY: y + 5 + fb * 0.3 }
      });
    }

    // Glowing knowledge orbs
    for (var ko = 0; ko < 6; ko++) {
      var koAngle = (ko / 6) * Math.PI * 2;
      var kox = z.cx + Math.cos(koAngle) * 6;
      var koz = z.cz + Math.sin(koAngle) * 6;
      var orbGeo = new THREE.SphereGeometry(0.25, 12, 12);
      var orbMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        emissive: 0xffaa00,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.7
      });
      var orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.set(kox, y + 6 + ko * 0.4, koz);
      orb.castShadow = false;
      scene.add(orb);
      animatedObjects.push({
        mesh: orb,
        type: 'crystal',
        params: { speed: 0.3, baseY: y + 6 + ko * 0.4 }
      });
    }

    // Reading desks
    for (var rd = 0; rd < 4; rd++) {
      var rdAngle = (rd / 4) * Math.PI * 2 + Math.PI / 4;
      var rdx = z.cx + Math.cos(rdAngle) * 12;
      var rdz = z.cz + Math.sin(rdAngle) * 12;
      var deskGeo = new THREE.BoxGeometry(2, 0.15, 1.2);
      var deskMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var desk = new THREE.Mesh(deskGeo, deskMat);
      desk.position.set(rdx, y + 0.8, rdz);
      desk.rotation.y = rdAngle;
      desk.castShadow = false;
      scene.add(desk);

      // Desk legs
      for (var dl = 0; dl < 4; dl++) {
        var dlx = rdx + Math.cos(rdAngle) * (dl < 2 ? -0.9 : 0.9) + Math.cos(rdAngle + Math.PI / 2) * (dl % 2 === 0 ? -0.5 : 0.5);
        var dlz = rdz + Math.sin(rdAngle) * (dl < 2 ? -0.9 : 0.9) + Math.sin(rdAngle + Math.PI / 2) * (dl % 2 === 0 ? -0.5 : 0.5);
        var legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 6);
        var legMesh = new THREE.Mesh(legGeo, deskMat);
        legMesh.position.set(dlx, y + 0.4, dlz);
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    // Decorative scrolls on pillars
    for (var sc = 0; sc < 6; sc++) {
      var scrollGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
      var scrollMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
      var scroll = new THREE.Mesh(scrollGeo, scrollMat);
      var scx = z.cx - 8 + sc * 3.2;
      scroll.position.set(scx, y + 6, z.cz + 8);
      scroll.rotation.z = Math.PI / 2;
      scroll.castShadow = false;
      scene.add(scroll);
    }

    // Ancient tome pedestals
    for (var tp = 0; tp < 3; tp++) {
      var tpx = z.cx + (tp - 1) * 5;
      var pedestalGeo = new THREE.CylinderGeometry(0.5, 0.7, 1.2, 8);
      var pedestalMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
      pedestal.position.set(tpx, y + 0.6, z.cz - 3);
      pedestal.castShadow = false;
      scene.add(pedestal);

      // Tome on pedestal
      var tomeGeo = new THREE.BoxGeometry(0.6, 0.15, 0.8);
      var tomeMat = new THREE.MeshStandardMaterial({
        color: 0x4a148c,
        emissive: 0x2a0a4c,
        emissiveIntensity: 0.2
      });
      var tome = new THREE.Mesh(tomeGeo, tomeMat);
      tome.position.set(tpx, y + 1.3, z.cz - 3);
      tome.rotation.y = Math.PI / 8;
      tome.castShadow = false;
      scene.add(tome);
    }
  }

  function createStudioStructure(scene) {
    var z = ZONES.studio, y = z.baseHeight;
    // Creative workshop buildings
    for (var i = 0; i < 5; i++) {
      var angle = (i / 5) * Math.PI * 2 + 0.3;
      var bx = z.cx + Math.cos(angle) * 14;
      var bz = z.cz + Math.sin(angle) * 14;

      var buildGeo = new THREE.BoxGeometry(6, 5, 6);
      var buildColors = [0xff9800, 0xffc107, 0xff5722, 0x8bc34a, 0x03a9f4];
      var buildMat = new THREE.MeshStandardMaterial({ color: buildColors[i] });
      var build = new THREE.Mesh(buildGeo, buildMat);
      build.position.set(bx, y + 2.5, bz);
      build.rotation.y = angle + Math.PI;
      build.castShadow = false;
      scene.add(build);

      // Roof
      var sRoofGeo = new THREE.ConeGeometry(4.5, 3, 4);
      var sRoofMat = new THREE.MeshStandardMaterial({ color: 0x795548 });
      var sRoof = new THREE.Mesh(sRoofGeo, sRoofMat);
      sRoof.position.set(bx, y + 6.5, bz);
      sRoof.rotation.y = Math.PI / 4;
      sRoof.castShadow = false;
      scene.add(sRoof);
    }

    // Central sculpture (rotating)
    var sculpGeo = new THREE.OctahedronGeometry(2, 0);
    var sculpMat = new THREE.MeshStandardMaterial({
      color: 0xff6f00, emissive: 0x442200, emissiveIntensity: 0.3
    });
    var sculpture = new THREE.Mesh(sculpGeo, sculpMat);
    sculpture.position.set(z.cx, y + 4, z.cz);
    sculpture.castShadow = false;
    scene.add(sculpture);
    animatedObjects.push({ mesh: sculpture, type: 'crystal', params: { speed: 0.5, baseY: y + 4 } });

    // ENHANCED DECORATIONS: Paint splatter decorations (colorful spheres on ground)
    for (var ps = 0; ps < 15; ps++) {
      var psAngle = (ps / 15) * Math.PI * 2;
      var psRadius = 5 + seededRandom(ps, 20, 1) * 10;
      var psx = z.cx + Math.cos(psAngle) * psRadius;
      var psz = z.cz + Math.sin(psAngle) * psRadius;
      var splatGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var splatColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800, 0x8800ff];
      var splatMat = new THREE.MeshStandardMaterial({
        color: splatColors[ps % splatColors.length],
        emissive: splatColors[ps % splatColors.length],
        emissiveIntensity: 0.3
      });
      var splat = new THREE.Mesh(splatGeo, splatMat);
      splat.position.set(psx, y + 0.15, psz);
      splat.scale.y = 0.3;
      splat.castShadow = false;
      scene.add(splat);
    }

    // Easels around the zone
    for (var ea = 0; ea < 5; ea++) {
      var eaAngle = (ea / 5) * Math.PI * 2 + 0.2;
      var eax = z.cx + Math.cos(eaAngle) * 10;
      var eaz = z.cz + Math.sin(eaAngle) * 10;

      // Easel legs (tripod)
      for (var el = 0; el < 3; el++) {
        var elAngle = eaAngle + (el / 3) * Math.PI * 2;
        var legGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 6);
        var legMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        var leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(
          eax + Math.cos(elAngle) * 0.3,
          y + 1,
          eaz + Math.sin(elAngle) * 0.3
        );
        leg.rotation.z = (el === 1 ? -0.2 : (el === 2 ? 0.2 : 0));
        leg.castShadow = false;
        scene.add(leg);
      }

      // Canvas
      var canvasGeo = new THREE.PlaneGeometry(1.2, 1.5);
      var canvasMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
      });
      var canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.set(eax, y + 1.8, eaz);
      canvas.rotation.y = eaAngle;
      canvas.castShadow = false;
      scene.add(canvas);
    }

    // Musical note particles (for musician artists)
    for (var mn = 0; mn < 6; mn++) {
      var mnAngle = (mn / 6) * Math.PI * 2;
      var mnx = z.cx + Math.cos(mnAngle) * 8;
      var mnz = z.cz + Math.sin(mnAngle) * 8;
      var noteGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var noteMat = new THREE.MeshStandardMaterial({
        color: 0xff69b4,
        emissive: 0xff1493,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.7
      });
      var note = new THREE.Mesh(noteGeo, noteMat);
      note.position.set(mnx, y + 3 + mn * 0.4, mnz);
      note.castShadow = false;
      scene.add(note);
      animatedObjects.push({
        mesh: note,
        type: 'crystal',
        params: { speed: 0.4 + mn * 0.1, baseY: y + 3 + mn * 0.4 }
      });
    }

    // Sculpture pedestals
    for (var sp = 0; sp < 3; sp++) {
      var spAngle = (sp / 3) * Math.PI * 2;
      var spx = z.cx + Math.cos(spAngle) * 18;
      var spz = z.cz + Math.sin(spAngle) * 18;
      var pedGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 8);
      var pedMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
      var ped = new THREE.Mesh(pedGeo, pedMat);
      ped.position.set(spx, y + 0.75, spz);
      ped.castShadow = false;
      scene.add(ped);

      // Small sculpture on pedestal
      var miniSculpGeo = new THREE.TorusGeometry(0.4, 0.15, 8, 12);
      var miniSculpMat = new THREE.MeshStandardMaterial({
        color: [0xff9800, 0x9c27b0, 0x00bcd4][sp],
        emissive: [0xff9800, 0x9c27b0, 0x00bcd4][sp],
        emissiveIntensity: 0.2
      });
      var miniSculp = new THREE.Mesh(miniSculpGeo, miniSculpMat);
      miniSculp.position.set(spx, y + 1.8, spz);
      miniSculp.rotation.x = Math.PI / 4;
      miniSculp.castShadow = false;
      scene.add(miniSculp);
    }

    // Paint palettes on ground
    for (var pp = 0; pp < 4; pp++) {
      var ppx = z.cx + (pp % 2 === 0 ? -6 : 6);
      var ppz = z.cz + (pp < 2 ? -6 : 6);
      var paletteGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 8);
      var paletteMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var palette = new THREE.Mesh(paletteGeo, paletteMat);
      palette.position.set(ppx, y + 0.05, ppz);
      palette.castShadow = false;
      scene.add(palette);
    }
  }

  function createWildsStructure(scene) {
    var z = ZONES.wilds, y = z.baseHeight;
    // Ancient stone circle
    for (var i = 0; i < 12; i++) {
      var angle = (i / 12) * Math.PI * 2;
      var sx = z.cx + Math.cos(angle) * 16;
      var sz = z.cz + Math.sin(angle) * 16;
      var stoneH = 3 + seededRandom(i, 5, 1) * 3;
      var stoneGeo = new THREE.BoxGeometry(1.5, stoneH, 0.8);
      var stoneMat = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.95 });
      var stone = new THREE.Mesh(stoneGeo, stoneMat);
      var sh = terrainHeight(sx, sz);
      stone.position.set(sx, sh + stoneH / 2, sz);
      stone.rotation.y = angle;
      stone.rotation.z = (seededRandom(i, 5, 2) - 0.5) * 0.15;
      stone.castShadow = false;
      scene.add(stone);
    }

    // Moss-covered altar at center
    var altarGeo = new THREE.BoxGeometry(4, 1.5, 4);
    var altarMat = new THREE.MeshStandardMaterial({ color: 0x3e6b3e, roughness: 0.95 });
    var altar = new THREE.Mesh(altarGeo, altarMat);
    altar.position.set(z.cx, y + 0.75, z.cz);
    altar.castShadow = false;
    scene.add(altar);

    // Glowing rune on altar
    var runeGeo = new THREE.RingGeometry(0.5, 1.5, 6);
    var runeMat = new THREE.MeshStandardMaterial({
      color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 0.5,
      side: THREE.DoubleSide
    });
    var rune = new THREE.Mesh(runeGeo, runeMat);
    rune.position.set(z.cx, y + 1.55, z.cz);
    rune.rotation.x = -Math.PI / 2;
    rune.castShadow = false;
    scene.add(rune);
    animatedObjects.push({ mesh: rune, type: 'crystal', params: { speed: 0.2, baseY: y + 1.55 } });

    // ENHANCED DECORATIONS: More varied trees (different sizes)
    for (var vt = 0; vt < 10; vt++) {
      var vtAngle = (vt / 10) * Math.PI * 2;
      var vtRadius = 20 + seededRandom(vt, 15, 1) * 15;
      var vtx = z.cx + Math.cos(vtAngle) * vtRadius;
      var vtz = z.cz + Math.sin(vtAngle) * vtRadius;
      var treeHeight = 3 + seededRandom(vt, 15, 2) * 4;

      // Trunk
      var trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, treeHeight, 8);
      var trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(vtx, y + treeHeight / 2, vtz);
      trunk.castShadow = false;
      scene.add(trunk);

      // Canopy
      var canopyGeo = new THREE.SphereGeometry(treeHeight * 0.5, 8, 8);
      var canopyMat = new THREE.MeshStandardMaterial({ color: 0x1a5e1a });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.set(vtx, y + treeHeight + treeHeight * 0.3, vtz);
      canopy.castShadow = false;
      scene.add(canopy);
    }

    // Animal tracks (small spheres in dirt)
    for (var at = 0; at < 20; at++) {
      var atAngle = (at / 20) * Math.PI * 2;
      var atRadius = 8 + (at % 5) * 3;
      var atx = z.cx + Math.cos(atAngle) * atRadius;
      var atz = z.cz + Math.sin(atAngle) * atRadius;
      var trackGeo = new THREE.SphereGeometry(0.12, 6, 6);
      var trackMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
      var track = new THREE.Mesh(trackGeo, trackMat);
      track.position.set(atx, y + 0.08, atz);
      track.scale.y = 0.3;
      track.castShadow = false;
      scene.add(track);
    }

    // Fog patches (semi-transparent spheres)
    for (var fg = 0; fg < 6; fg++) {
      var fgAngle = (fg / 6) * Math.PI * 2 + 0.3;
      var fgx = z.cx + Math.cos(fgAngle) * 12;
      var fgz = z.cz + Math.sin(fgAngle) * 12;
      var fogGeo = new THREE.SphereGeometry(2, 8, 8);
      var fogMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        transparent: true,
        opacity: 0.2,
        emissive: 0xaaaaaa,
        emissiveIntensity: 0.1
      });
      var fog = new THREE.Mesh(fogGeo, fogMat);
      fog.position.set(fgx, y + 1, fgz);
      fog.scale.y = 0.4;
      fog.castShadow = false;
      scene.add(fog);
      animatedObjects.push({
        mesh: fog,
        type: 'water',
        params: { speed: 0.3 }
      });
    }

    // Wild mushroom clusters
    for (var wm = 0; wm < 12; wm++) {
      var wmAngle = (wm / 12) * Math.PI * 2;
      var wmRadius = 10 + (wm % 4) * 4;
      var wmx = z.cx + Math.cos(wmAngle) * wmRadius;
      var wmz = z.cz + Math.sin(wmAngle) * wmRadius;

      for (var mc = 0; mc < 3; mc++) {
        var mushroomCapGeo = new THREE.SphereGeometry(0.3, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        var mushroomMat = new THREE.MeshStandardMaterial({
          color: wm % 3 === 0 ? 0xff6b6b : (wm % 3 === 1 ? 0x4ecdc4 : 0xf7b731)
        });
        var mushroomCap = new THREE.Mesh(mushroomCapGeo, mushroomMat);
        mushroomCap.position.set(
          wmx + (mc - 1) * 0.4,
          y + 0.25 + mc * 0.05,
          wmz
        );
        mushroomCap.castShadow = false;
        scene.add(mushroomCap);

        var stemGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 6);
        var stemMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 });
        var stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.set(
          wmx + (mc - 1) * 0.4,
          y + 0.1 + mc * 0.05,
          wmz
        );
        stem.castShadow = false;
        scene.add(stem);
      }
    }

    // Ancient vine-covered rocks
    for (var vr = 0; vr < 8; vr++) {
      var vrAngle = (vr / 8) * Math.PI * 2;
      var vrx = z.cx + Math.cos(vrAngle) * 18;
      var vrz = z.cz + Math.sin(vrAngle) * 18;
      var rockSize = 0.8 + seededRandom(vr, 25, 1) * 1.2;
      var vineRockGeo = new THREE.SphereGeometry(rockSize, 8, 8);
      var vineRockMat = new THREE.MeshStandardMaterial({ color: 0x3e6b3e });
      var vineRock = new THREE.Mesh(vineRockGeo, vineRockMat);
      vineRock.position.set(vrx, y + rockSize * 0.6, vrz);
      vineRock.scale.y = 0.7;
      vineRock.castShadow = false;
      scene.add(vineRock);
    }
  }

  function createAgoraStructure(scene) {
    var z = ZONES.agora, y = z.baseHeight;
    // Market stalls in rows
    for (var i = 0; i < 8; i++) {
      var sx = z.cx + (i % 4 - 1.5) * 8;
      var sz = z.cz + Math.floor(i / 4) * 14 - 7;
      // Tent top
      var tentGeo = new THREE.ConeGeometry(3, 4, 4);
      var tentColors = [0xdc143c, 0xff8c00, 0x4169e1, 0x2e8b57, 0x9400d3, 0xdaa520, 0x008b8b, 0xcd853f];
      var tentMat = new THREE.MeshStandardMaterial({ color: tentColors[i] });
      var tent = new THREE.Mesh(tentGeo, tentMat);
      tent.position.set(sx, y + 5, sz);
      tent.castShadow = false;
      scene.add(tent);
      // Counter
      var counterGeo = new THREE.BoxGeometry(4, 1, 2);
      var counterMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var counter = new THREE.Mesh(counterGeo, counterMat);
      counter.position.set(sx, y + 0.5, sz + 2.5);
      counter.castShadow = false;
      scene.add(counter);
      // Support poles
      for (var p = -1; p <= 1; p += 2) {
        var poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 6);
        var poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
        var pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.set(sx + p * 2.5, y + 2.5, sz);
        pole.castShadow = false;
        scene.add(pole);
      }
    }

    // Crates
    for (var c = 0; c < 10; c++) {
      var crx = z.cx + (seededRandom(100, c, 1) - 0.5) * 25;
      var crz = z.cz + (seededRandom(100, c, 2) - 0.5) * 25;
      var crateGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
      var crateMat = new THREE.MeshStandardMaterial({ color: 0xd2691e });
      var crate = new THREE.Mesh(crateGeo, crateMat);
      crate.position.set(crx, y + 0.6, crz);
      crate.rotation.y = seededRandom(100, c, 3) * Math.PI;
      crate.castShadow = false;
      scene.add(crate);
    }

    // ENHANCED DECORATIONS: Market stall awnings (already have tents, add rope decorations)
    for (var aw = 0; aw < 8; aw++) {
      var awx = z.cx + (aw % 4 - 1.5) * 8;
      var awz = z.cz + Math.floor(aw / 4) * 14 - 7;

      // Hanging lanterns
      for (var hl = -1; hl <= 1; hl += 2) {
        var lanternGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.4, 6);
        var lanternMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.4
        });
        var lantern = new THREE.Mesh(lanternGeo, lanternMat);
        lantern.position.set(awx + hl * 2, y + 3.5, awz);
        lantern.castShadow = false;
        scene.add(lantern);

        // Rope
        var ropeGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
        var ropeMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
        var rope = new THREE.Mesh(ropeGeo, ropeMat);
        rope.position.set(awx + hl * 2, y + 4.2, awz);
        rope.castShadow = false;
        scene.add(rope);
      }
    }

    // Trading goods displays (colorful items on counters)
    for (var tg = 0; tg < 8; tg++) {
      var tgx = z.cx + (tg % 4 - 1.5) * 8;
      var tgz = z.cz + Math.floor(tg / 4) * 14 - 7 + 2.5;

      // Display items (spheres and boxes)
      for (var di = 0; di < 3; di++) {
        var displayGeo = di % 2 === 0 ? new THREE.SphereGeometry(0.15, 8, 8) : new THREE.BoxGeometry(0.25, 0.25, 0.25);
        var displayColors = [0xff6b6b, 0x4ecdc4, 0xf7b731, 0x5f27cd, 0x00d2d3, 0xff9ff3];
        var displayMat = new THREE.MeshStandardMaterial({
          color: displayColors[(tg + di) % displayColors.length],
          emissive: displayColors[(tg + di) % displayColors.length],
          emissiveIntensity: 0.1
        });
        var display = new THREE.Mesh(displayGeo, displayMat);
        display.position.set(tgx + (di - 1) * 0.5, y + 1.15, tgz);
        display.castShadow = false;
        scene.add(display);
      }
    }

    // Barrels for storage
    for (var br = 0; br < 6; br++) {
      var brAngle = (br / 6) * Math.PI * 2;
      var brx = z.cx + Math.cos(brAngle) * 12;
      var brz = z.cz + Math.sin(brAngle) * 12;
      var barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.2, 12);
      var barrelMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var barrel = new THREE.Mesh(barrelGeo, barrelMat);
      barrel.position.set(brx, y + 0.6, brz);
      barrel.castShadow = false;
      scene.add(barrel);

      // Barrel bands
      for (var bb = 0; bb < 3; bb++) {
        var bandGeo = new THREE.TorusGeometry(0.55, 0.03, 6, 12);
        var bandMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        var band = new THREE.Mesh(bandGeo, bandMat);
        band.position.set(brx, y + 0.3 + bb * 0.4, brz);
        band.rotation.x = Math.PI / 2;
        band.castShadow = false;
        scene.add(band);
      }
    }

    // Decorative rugs under stalls
    for (var rg = 0; rg < 4; rg++) {
      var rgx = z.cx + (rg % 2 - 0.5) * 12;
      var rgz = z.cz + (rg < 2 ? -10 : 10);
      var rugGeo = new THREE.PlaneGeometry(5, 3);
      var rugColors = [0x8b0000, 0x006400, 0x00008b, 0x8b008b];
      var rugMat = new THREE.MeshStandardMaterial({
        color: rugColors[rg],
        side: THREE.DoubleSide
      });
      var rug = new THREE.Mesh(rugGeo, rugMat);
      rug.position.set(rgx, y + 0.02, rgz);
      rug.rotation.x = -Math.PI / 2;
      rug.castShadow = false;
      scene.add(rug);
    }

    // Signposts
    for (var sgn = 0; sgn < 4; sgn++) {
      var sgnAngle = (sgn / 4) * Math.PI * 2;
      var sgnx = z.cx + Math.cos(sgnAngle) * 20;
      var sgnz = z.cz + Math.sin(sgnAngle) * 20;

      // Post
      var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      var postMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var post = new THREE.Mesh(postGeo, postMat);
      post.position.set(sgnx, y + 1.5, sgnz);
      post.castShadow = false;
      scene.add(post);

      // Sign
      var signGeo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
      var signMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
      var sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(sgnx, y + 3.2, sgnz);
      sign.rotation.y = sgnAngle;
      sign.castShadow = false;
      scene.add(sign);
    }
  }

  function createCommonsStructure(scene) {
    var z = ZONES.commons, y = z.baseHeight;
    // Small houses in circle
    for (var i = 0; i < 8; i++) {
      var angle = (i / 8) * Math.PI * 2;
      var hx = z.cx + Math.cos(angle) * 18;
      var hz = z.cz + Math.sin(angle) * 18;
      // House body
      var houseGeo = new THREE.BoxGeometry(5, 4, 5);
      var houseColors = [0xfaf0e6, 0xf5deb3, 0xffefd5, 0xffe4c4, 0xffdab9, 0xeee8aa, 0xfafad2, 0xfff8dc];
      var houseMat = new THREE.MeshStandardMaterial({ color: houseColors[i] });
      var house = new THREE.Mesh(houseGeo, houseMat);
      house.position.set(hx, y + 2, hz);
      house.rotation.y = angle + Math.PI;
      house.castShadow = false;
      scene.add(house);
      // Roof
      var roofGeo = new THREE.ConeGeometry(4, 2.5, 4);
      var roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var roofMesh = new THREE.Mesh(roofGeo, roofMat);
      roofMesh.position.set(hx, y + 5.25, hz);
      roofMesh.rotation.y = Math.PI / 4;
      roofMesh.castShadow = false;
      scene.add(roofMesh);
      // Door
      var doorGeo = new THREE.BoxGeometry(1, 2.5, 0.1);
      var doorMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(hx + Math.cos(angle + Math.PI) * 2.55, y + 1.25, hz + Math.sin(angle + Math.PI) * 2.55);
      door.rotation.y = angle + Math.PI;
      door.castShadow = false;
      scene.add(door);
    }

    // Central well
    var wellGeo = new THREE.CylinderGeometry(1.5, 1.5, 2, 12);
    var wellMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
    var well = new THREE.Mesh(wellGeo, wellMat);
    well.position.set(z.cx, y + 1, z.cz);
    well.castShadow = false;
    scene.add(well);

    // Well roof
    var wellRoofGeo = new THREE.ConeGeometry(2.2, 2, 6);
    var wellRoofMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    var wellRoof = new THREE.Mesh(wellRoofGeo, wellRoofMat);
    wellRoof.position.set(z.cx, y + 3.5, z.cz);
    wellRoof.castShadow = false;
    scene.add(wellRoof);

    // Well supports
    for (var ws = 0; ws < 4; ws++) {
      var wa = (ws / 4) * Math.PI * 2;
      var wpGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.5, 4);
      var wpMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var wp = new THREE.Mesh(wpGeo, wpMat);
      wp.position.set(z.cx + Math.cos(wa) * 1.2, y + 2.25, z.cz + Math.sin(wa) * 1.2);
      wp.castShadow = false;
      scene.add(wp);
    }

    // ENHANCED DECORATIONS: Benches in gathering circles
    for (var bc = 0; bc < 6; bc++) {
      var bcAngle = (bc / 6) * Math.PI * 2;
      var bcx = z.cx + Math.cos(bcAngle) * 8;
      var bcz = z.cz + Math.sin(bcAngle) * 8;

      var benchGeo = new THREE.BoxGeometry(2, 0.3, 0.6);
      var benchMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var bench = new THREE.Mesh(benchGeo, benchMat);
      bench.position.set(bcx, y + 0.4, bcz);
      bench.rotation.y = bcAngle + Math.PI / 2;
      bench.castShadow = false;
      scene.add(bench);

      // Bench back
      var backGeo = new THREE.BoxGeometry(2, 0.8, 0.1);
      var back = new THREE.Mesh(backGeo, benchMat);
      back.position.set(
        bcx + Math.cos(bcAngle) * 0.35,
        y + 0.9,
        bcz + Math.sin(bcAngle) * 0.35
      );
      back.rotation.y = bcAngle + Math.PI / 2;
      back.castShadow = false;
      scene.add(back);

      // Bench legs
      for (var bl = -1; bl <= 1; bl += 2) {
        var legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 6);
        var legMesh = new THREE.Mesh(legGeo, benchMat);
        legMesh.position.set(
          bcx + Math.cos(bcAngle + Math.PI / 2) * bl * 0.8,
          y + 0.2,
          bcz + Math.sin(bcAngle + Math.PI / 2) * bl * 0.8
        );
        legMesh.castShadow = false;
        scene.add(legMesh);
      }
    }

    // Gathering circles (stone rings)
    for (var gc = 0; gc < 2; gc++) {
      var gcx = z.cx + (gc === 0 ? -10 : 10);
      var gcz = z.cz;

      for (var gs = 0; gs < 10; gs++) {
        var gsAngle = (gs / 10) * Math.PI * 2;
        var stoneGeo = new THREE.BoxGeometry(0.5, 0.3, 0.4);
        var stoneMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
        var stone = new THREE.Mesh(stoneGeo, stoneMat);
        stone.position.set(
          gcx + Math.cos(gsAngle) * 4,
          y + 0.15,
          gcz + Math.sin(gsAngle) * 4
        );
        stone.rotation.y = gsAngle;
        stone.castShadow = false;
        scene.add(stone);
      }
    }

    // Lantern strings connecting houses
    for (var ls = 0; ls < 8; ls++) {
      var lsAngle = (ls / 8) * Math.PI * 2;
      var lsx = z.cx + Math.cos(lsAngle) * 18;
      var lsz = z.cz + Math.sin(lsAngle) * 18;

      // Lanterns hanging from house eaves
      var hangLanternGeo = new THREE.SphereGeometry(0.2, 8, 8);
      var hangLanternMat = new THREE.MeshStandardMaterial({
        color: 0xffeb3b,
        emissive: 0xffc107,
        emissiveIntensity: 0.5
      });
      var hangLantern = new THREE.Mesh(hangLanternGeo, hangLanternMat);
      hangLantern.position.set(lsx, y + 4.5, lsz);
      hangLantern.castShadow = false;
      scene.add(hangLantern);
      animatedObjects.push({
        mesh: hangLantern,
        type: 'torch',
        params: { seed: ls * 100 }
      });

      // String to next house
      var nextAngle = ((ls + 1) / 8) * Math.PI * 2;
      var nextX = z.cx + Math.cos(nextAngle) * 18;
      var nextZ = z.cz + Math.sin(nextAngle) * 18;
      var stringLength = Math.sqrt(Math.pow(nextX - lsx, 2) + Math.pow(nextZ - lsz, 2));
      var stringGeo = new THREE.CylinderGeometry(0.02, 0.02, stringLength, 6);
      var stringMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var string = new THREE.Mesh(stringGeo, stringMat);
      string.position.set((lsx + nextX) / 2, y + 4.5, (lsz + nextZ) / 2);
      string.rotation.y = Math.atan2(nextZ - lsz, nextX - lsx);
      string.rotation.z = Math.PI / 2;
      string.castShadow = false;
      scene.add(string);
    }

    // Flower pots near houses
    for (var fp = 0; fp < 8; fp++) {
      var fpAngle = (fp / 8) * Math.PI * 2;
      var fpx = z.cx + Math.cos(fpAngle) * 16;
      var fpz = z.cz + Math.sin(fpAngle) * 16;

      var potGeo = new THREE.CylinderGeometry(0.3, 0.25, 0.5, 8);
      var potMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var pot = new THREE.Mesh(potGeo, potMat);
      pot.position.set(fpx, y + 0.25, fpz);
      pot.castShadow = false;
      scene.add(pot);

      // Flowers in pot
      var flowerGeo = new THREE.SphereGeometry(0.25, 6, 6);
      var flowerMat = new THREE.MeshStandardMaterial({
        color: [0xff6b9d, 0x4ecdc4, 0xf7b731][fp % 3]
      });
      var flower = new THREE.Mesh(flowerGeo, flowerMat);
      flower.position.set(fpx, y + 0.6, fpz);
      flower.castShadow = false;
      scene.add(flower);
    }

    // Community notice board
    var boardPostGeo = new THREE.CylinderGeometry(0.12, 0.12, 3, 8);
    var boardPostMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
    var boardPost = new THREE.Mesh(boardPostGeo, boardPostMat);
    boardPost.position.set(z.cx + 5, y + 1.5, z.cz + 5);
    boardPost.castShadow = false;
    scene.add(boardPost);

    var boardGeo = new THREE.BoxGeometry(2.5, 2, 0.1);
    var boardMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
    var board = new THREE.Mesh(boardGeo, boardMat);
    board.position.set(z.cx + 5, y + 2.5, z.cz + 5);
    board.castShadow = false;
    scene.add(board);

    // Tool racks
    for (var tr = 0; tr < 2; tr++) {
      var trx = z.cx + (tr === 0 ? -12 : 12);
      var trz = z.cz + 8;

      var rackGeo = new THREE.BoxGeometry(1.5, 0.1, 0.3);
      var rackMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var rack = new THREE.Mesh(rackGeo, rackMat);
      rack.position.set(trx, y + 1.5, trz);
      rack.castShadow = false;
      scene.add(rack);

      // Tools on rack (simplified as small boxes)
      for (var tl = 0; tl < 3; tl++) {
        var toolGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
        var toolMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        var tool = new THREE.Mesh(toolGeo, toolMat);
        tool.position.set(trx + (tl - 1) * 0.4, y + 1.1, trz);
        tool.rotation.z = Math.PI / 6;
        tool.castShadow = false;
        scene.add(tool);
      }
    }
  }

  function createArenaStructure(scene) {
    var z = ZONES.arena, y = z.baseHeight;
    // Tiered seating (colosseum-style)
    for (var tier = 0; tier < 4; tier++) {
      var radius = 18 + tier * 6;
      var height = 1.5 + tier * 2;
      var segments = 20 + tier * 4;
      for (var s = 0; s < segments; s++) {
        var a1 = (s / segments) * Math.PI * 2;
        var sx = z.cx + Math.cos(a1) * radius;
        var sz = z.cz + Math.sin(a1) * radius;
        var seatGeo = new THREE.BoxGeometry(3, 1.5, 2.5);
        var seatMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
        var seat = new THREE.Mesh(seatGeo, seatMat);
        seat.position.set(sx, y + height, sz);
        seat.rotation.y = a1;
        seat.castShadow = false;
        scene.add(seat);
      }
    }

    // Central arena floor
    var arenaFloorGeo = new THREE.CylinderGeometry(16, 16, 0.5, 32);
    var arenaFloorMat = new THREE.MeshStandardMaterial({ color: 0xe0c097 });
    var arenaFloor = new THREE.Mesh(arenaFloorGeo, arenaFloorMat);
    arenaFloor.position.set(z.cx, y + 0.25, z.cz);
    arenaFloor.castShadow = false;
    scene.add(arenaFloor);

    // Entrance arches
    for (var ea = 0; ea < 4; ea++) {
      var eAngle = (ea / 4) * Math.PI * 2;
      var ex = z.cx + Math.cos(eAngle) * 16;
      var ez = z.cz + Math.sin(eAngle) * 16;
      // Two pillars
      for (var side = -1; side <= 1; side += 2) {
        var epGeo = new THREE.CylinderGeometry(0.6, 0.7, 7, 8);
        var epMat = new THREE.MeshStandardMaterial({ color: 0xc8a882 });
        var ep = new THREE.Mesh(epGeo, epMat);
        var perpAngle = eAngle + Math.PI / 2;
        ep.position.set(ex + Math.cos(perpAngle) * side * 2.5, y + 3.5, ez + Math.sin(perpAngle) * side * 2.5);
        ep.castShadow = false;
        scene.add(ep);
      }
      // Arch top
      var archGeo = new THREE.BoxGeometry(6, 1, 1.5);
      var archMat = new THREE.MeshStandardMaterial({ color: 0xc8a882 });
      var arch = new THREE.Mesh(archGeo, archMat);
      arch.position.set(ex, y + 7.5, ez);
      arch.rotation.y = eAngle;
      arch.castShadow = false;
      scene.add(arch);
    }

    // Torches around arena
    for (var ti = 0; ti < 12; ti++) {
      var tAngle = (ti / 12) * Math.PI * 2;
      var tpx = z.cx + Math.cos(tAngle) * 20;
      var tpz = z.cz + Math.sin(tAngle) * 20;
      addTorch(scene, tpx, y, tpz);
    }

    // ENHANCED DECORATIONS: Spectator banners
    for (var bn = 0; bn < 8; bn++) {
      var bnAngle = (bn / 8) * Math.PI * 2;
      var bnRadius = 28;
      var bnx = z.cx + Math.cos(bnAngle) * bnRadius;
      var bnz = z.cz + Math.sin(bnAngle) * bnRadius;

      // Banner pole
      var poleGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 8);
      var poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
      var pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.set(bnx, y + 2, bnz);
      pole.castShadow = false;
      scene.add(pole);

      // Banner cloth
      var bannerGeo = new THREE.PlaneGeometry(1.5, 2.5);
      var bannerColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00];
      var bannerMat = new THREE.MeshStandardMaterial({
        color: bannerColors[bn % bannerColors.length],
        side: THREE.DoubleSide
      });
      var banner = new THREE.Mesh(bannerGeo, bannerMat);
      banner.position.set(bnx, y + 3, bnz);
      banner.rotation.y = bnAngle + Math.PI / 2;
      banner.castShadow = false;
      scene.add(banner);
    }

    // Torch brackets on seating tiers
    for (var tb = 0; tb < 16; tb++) {
      var tbAngle = (tb / 16) * Math.PI * 2;
      var tbRadius = 24;
      var tbx = z.cx + Math.cos(tbAngle) * tbRadius;
      var tbz = z.cz + Math.sin(tbAngle) * tbRadius;

      var bracketGeo = new THREE.BoxGeometry(0.3, 0.15, 0.3);
      var bracketMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      var bracket = new THREE.Mesh(bracketGeo, bracketMat);
      bracket.position.set(tbx, y + 4, tbz);
      bracket.castShadow = false;
      scene.add(bracket);

      // Torch on bracket
      var torchGeo = new THREE.SphereGeometry(0.12, 6, 6);
      var torchMat = new THREE.MeshStandardMaterial({
        color: 0xff6600,
        emissive: 0xff4400,
        emissiveIntensity: 0.8
      });
      var torch = new THREE.Mesh(torchGeo, torchMat);
      torch.position.set(tbx, y + 4.3, tbz);
      torch.castShadow = false;
      scene.add(torch);
      animatedObjects.push({
        mesh: torch,
        type: 'torch',
        params: { seed: tb * 200 }
      });
    }

    // Scoring boards (tall posts with platforms)
    for (var sb = 0; sb < 4; sb++) {
      var sbAngle = (sb / 4) * Math.PI * 2;
      var sbx = z.cx + Math.cos(sbAngle) * 30;
      var sbz = z.cz + Math.sin(sbAngle) * 30;

      // Post
      var scorePostGeo = new THREE.CylinderGeometry(0.2, 0.25, 6, 8);
      var scorePostMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
      var scorePost = new THREE.Mesh(scorePostGeo, scorePostMat);
      scorePost.position.set(sbx, y + 3, sbz);
      scorePost.castShadow = false;
      scene.add(scorePost);

      // Scoreboard
      var scoreBoardGeo = new THREE.BoxGeometry(2, 1.5, 0.2);
      var scoreBoardMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
      var scoreBoard = new THREE.Mesh(scoreBoardGeo, scoreBoardMat);
      scoreBoard.position.set(sbx, y + 6.5, sbz);
      scoreBoard.rotation.y = sbAngle + Math.PI;
      scoreBoard.castShadow = false;
      scene.add(scoreBoard);
    }

    // Training equipment (dummy posts)
    for (var te = 0; te < 4; te++) {
      var teAngle = (te / 4) * Math.PI * 2 + Math.PI / 8;
      var tex = z.cx + Math.cos(teAngle) * 10;
      var tez = z.cz + Math.sin(teAngle) * 10;

      // Post
      var dummyPostGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
      var dummyPostMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var dummyPost = new THREE.Mesh(dummyPostGeo, dummyPostMat);
      dummyPost.position.set(tex, y + 1.25, tez);
      dummyPost.castShadow = false;
      scene.add(dummyPost);

      // Dummy head
      var dummyHeadGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var dummyHeadMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      var dummyHead = new THREE.Mesh(dummyHeadGeo, dummyHeadMat);
      dummyHead.position.set(tex, y + 2.8, tez);
      dummyHead.castShadow = false;
      scene.add(dummyHead);

      // Crossbar arms
      for (var ca = -1; ca <= 1; ca += 2) {
        var armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 6);
        var arm = new THREE.Mesh(armGeo, dummyPostMat);
        arm.position.set(tex + ca * 0.4, y + 2.2, tez);
        arm.rotation.z = Math.PI / 2;
        arm.castShadow = false;
        scene.add(arm);
      }
    }

    // Weapon racks
    for (var wr = 0; wr < 2; wr++) {
      var wrx = z.cx + (wr === 0 ? -14 : 14);
      var wrz = z.cz;

      var weaponRackGeo = new THREE.BoxGeometry(3, 0.15, 0.3);
      var weaponRackMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      var weaponRack = new THREE.Mesh(weaponRackGeo, weaponRackMat);
      weaponRack.position.set(wrx, y + 1.5, wrz);
      weaponRack.castShadow = false;
      scene.add(weaponRack);

      // Support posts
      for (var wp = -1; wp <= 1; wp += 2) {
        var wpGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
        var wpMesh = new THREE.Mesh(wpGeo, weaponRackMat);
        wpMesh.position.set(wrx + wp * 1.2, y + 0.75, wrz);
        wpMesh.castShadow = false;
        scene.add(wpMesh);
      }

      // Weapons on rack (simplified as sticks)
      for (var wn = 0; wn < 4; wn++) {
        var weaponGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 6);
        var weaponMat = new THREE.MeshStandardMaterial({ color: 0x8b8b8b });
        var weapon = new THREE.Mesh(weaponGeo, weaponMat);
        weapon.position.set(wrx + (wn - 1.5) * 0.6, y + 0.9, wrz);
        weapon.rotation.z = Math.PI / 6;
        weapon.castShadow = false;
        scene.add(weapon);
      }
    }
  }

  function addTorch(scene, x, baseY, z) {
    var poleGeo = new THREE.CylinderGeometry(0.08, 0.1, 2.5, 6);
    var poleMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
    var pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.set(x, baseY + 1.25, z);
    pole.castShadow = false;
    scene.add(pole);

    var flameGeo = new THREE.SphereGeometry(0.25, 8, 8);
    var flameMat = new THREE.MeshStandardMaterial({
      color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 1
    });
    var flame = new THREE.Mesh(flameGeo, flameMat);
    flame.position.set(x, baseY + 2.7, z);
    flame.castShadow = false;
    scene.add(flame);

    var light = new THREE.PointLight(0xffa500, 0.8, 12);
    light.position.set(x, baseY + 2.7, z);
    scene.add(light);

    animatedObjects.push({
      mesh: flame, type: 'torch',
      params: { seed: x * 100 + z, light: light }
    });
  }

  function createPortals(scene) {
    // Place portals between zones â€” at zone edges toward nexus
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      // Portal sits on the edge of the zone facing nexus
      var dx = ZONES.nexus.cx - zone.cx;
      var dz = ZONES.nexus.cz - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var nx = dx / dist, nz = dz / dist;
      var portalX = zone.cx + nx * zone.radius * 0.7;
      var portalZ = zone.cz + nz * zone.radius * 0.7;
      var portalY = terrainHeight(portalX, portalZ);
      addPortalMesh(scene, portalX, portalY, portalZ, zId);
    }
  }

  function addPortalMesh(scene, x, y, z, targetZone) {
    // Portal archway
    var archGeo = new THREE.TorusGeometry(2.5, 0.25, 12, 24);
    var archMat = new THREE.MeshStandardMaterial({
      color: 0x00ffff, emissive: 0x008888, emissiveIntensity: 0.6
    });
    var arch = new THREE.Mesh(archGeo, archMat);
    arch.position.set(x, y + 3, z);
    arch.castShadow = false;
    scene.add(arch);

    // Inner glow
    var innerGeo = new THREE.CircleGeometry(2.2, 16);
    var innerMat = new THREE.MeshStandardMaterial({
      color: 0x66ffff, emissive: 0x44cccc, emissiveIntensity: 0.4,
      transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    var inner = new THREE.Mesh(innerGeo, innerMat);
    inner.position.set(x, y + 3, z);
    inner.castShadow = false;
    scene.add(inner);

    // Portal light
    var portalLight = new THREE.PointLight(0x00ffff, 0.6, 15);
    portalLight.position.set(x, y + 3, z);
    scene.add(portalLight);

    // Spinning particle rings around portal
    var particleRings = [];
    var ringCount = 2;
    var particlesPerRing = 12;

    for (var r = 0; r < ringCount; r++) {
      var ringRadius = 2.8 + r * 0.4;
      var ringParticles = [];

      for (var p = 0; p < particlesPerRing; p++) {
        var particleGeo = new THREE.SphereGeometry(0.08, 6, 6);
        var particleMat = new THREE.MeshStandardMaterial({
          color: 0x88ffff,
          emissive: 0x44aaaa,
          emissiveIntensity: 0.8
        });
        var particle = new THREE.Mesh(particleGeo, particleMat);
        particle.castShadow = false;
        scene.add(particle);

        ringParticles.push({
          mesh: particle,
          angle: (p / particlesPerRing) * Math.PI * 2,
          radius: ringRadius
        });
      }

      particleRings.push({
        particles: ringParticles,
        speed: 0.001 + r * 0.0005,
        direction: r % 2 === 0 ? 1 : -1
      });
    }

    animatedObjects.push({
      mesh: arch, type: 'portal',
      params: {
        speed: 0.8,
        inner: inner,
        particleRings: particleRings,
        centerX: x,
        centerY: y + 3,
        centerZ: z
      }
    });

    arch.userData.targetZone = targetZone;
  }

  // ========================================================================
  // SKY AND ATMOSPHERE
  // ========================================================================

  function createSky(scene) {
    var skyGeo = new THREE.SphereGeometry(800, 32, 32);
    var skyMat = new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide, fog: false });
    skyDome = new THREE.Mesh(skyGeo, skyMat);
    scene.add(skyDome);

    // Sun
    var sunGeo = new THREE.SphereGeometry(12, 16, 16);
    var sunMat = new THREE.MeshBasicMaterial({ color: 0xfff8e7, fog: false });
    sunMesh = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sunMesh);

    // Moon
    var moonGeo = new THREE.SphereGeometry(8, 16, 16);
    var moonMat = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, fog: false });
    moonMesh = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moonMesh);

    // Stars
    var starGeo = new THREE.BufferGeometry();
    var starPos = [];
    for (var i = 0; i < 1200; i++) {
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.random() * Math.PI;
      var r = 700;
      starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    var starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, fog: false });
    stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // Clouds
    for (var c = 0; c < 30; c++) {
      var cloudGroup = new THREE.Group();
      var numPuffs = 2 + Math.floor(Math.random() * 4);
      for (var p = 0; p < numPuffs; p++) {
        var puffGeo = new THREE.SphereGeometry(8 + Math.random() * 12, 6, 6);
        var puffMat = new THREE.MeshBasicMaterial({
          color: 0xffffff, transparent: true, opacity: 0.35, fog: false
        });
        var puff = new THREE.Mesh(puffGeo, puffMat);
        puff.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 15);
        puff.scale.y = 0.4;
        cloudGroup.add(puff);
      }
      cloudGroup.position.set(
        (Math.random() - 0.5) * 1200,
        180 + Math.random() * 60,
        (Math.random() - 0.5) * 1200
      );
      cloudGroup.userData.driftSpeed = 0.3 + Math.random() * 0.5;
      cloudGroup.userData.driftAngle = Math.random() * Math.PI * 2;
      clouds.push(cloudGroup);
      scene.add(cloudGroup);
    }

    // Fog
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);
  }

  // ========================================================================
  // PLAYER MODELS
  // ========================================================================

  // 8-tone skin palette for character variety
  var SKIN_TONES = [
    0xFFDBAC, 0xF1C27D, 0xE0AC69, 0xC68642,
    0x8D5524, 0x6B3A2A, 0xF5D6C3, 0xD4A574
  ];

  function getSkinTone(seed) {
    var hash = 0;
    if (typeof seed === 'string') {
      for (var i = 0; i < seed.length; i++) {
        hash = ((hash << 5) - hash) + seed.charCodeAt(i);
        hash = hash & hash;
      }
    } else {
      hash = seed || 0;
    }
    return SKIN_TONES[Math.abs(hash) % SKIN_TONES.length];
  }

  function createHumanoidModel(color) {
    var player = new THREE.Group();
    var skinColor = getSkinTone(color || 0x4169e1);
    var skinMat = new THREE.MeshLambertMaterial({ color: skinColor });

    // Head - SphereGeometry, skin-toned
    var headGeo = new THREE.SphereGeometry(0.3, 16, 16);
    var head = new THREE.Mesh(headGeo, skinMat.clone());
    head.position.y = 1.5;
    head.castShadow = false;
    player.add(head);

    // Eyes - white with dark pupils
    var eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var pupilGeo = new THREE.SphereGeometry(0.02, 8, 8);
    var pupilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

    var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.1, 0.05, 0.26);
    var leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
    leftPupil.position.set(0, 0, 0.03);
    leftEye.add(leftPupil);
    head.add(leftEye);

    var rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
    rightEye.position.set(0.1, 0.05, 0.26);
    var rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
    rightPupil.position.set(0, 0, 0.03);
    rightEye.add(rightPupil);
    head.add(rightEye);

    // Hair - pick style based on color hash
    var hairHash = (color || 0x4169e1) % 4;
    var hairColors = [0x1a1a1a, 0x4a3000, 0x8B4513, 0xd4a574];
    var hairMat = new THREE.MeshLambertMaterial({ color: hairColors[hairHash] });
    if (hairHash === 0) {
      // Buzz cut - slightly oversized sphere
      var buzzGeo = new THREE.SphereGeometry(0.31, 16, 16);
      var buzz = new THREE.Mesh(buzzGeo, hairMat);
      buzz.position.y = 0.02;
      buzz.scale.y = 0.9;
      head.add(buzz);
    } else if (hairHash === 1) {
      // Long hair - sphere + box behind
      var longTopGeo = new THREE.SphereGeometry(0.32, 16, 16);
      var longTop = new THREE.Mesh(longTopGeo, hairMat);
      longTop.position.y = 0.05;
      longTop.scale.y = 0.85;
      head.add(longTop);
      var longBackGeo = new THREE.BoxGeometry(0.4, 0.35, 0.15);
      var longBack = new THREE.Mesh(longBackGeo, hairMat.clone());
      longBack.position.set(0, -0.15, -0.18);
      head.add(longBack);
    } else if (hairHash === 2) {
      // Mohawk - narrow box on top
      var mohawkGeo = new THREE.BoxGeometry(0.08, 0.2, 0.4);
      var mohawk = new THREE.Mesh(mohawkGeo, hairMat);
      mohawk.position.y = 0.25;
      head.add(mohawk);
    } else {
      // Bun - small sphere on back
      var bunGeo = new THREE.SphereGeometry(0.12, 8, 8);
      var bun = new THREE.Mesh(bunGeo, hairMat);
      bun.position.set(0, 0.1, -0.28);
      head.add(bun);
    }

    // Neck
    var neckGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.15, 8);
    var neck = new THREE.Mesh(neckGeo, skinMat.clone());
    neck.position.y = 1.28;
    neck.castShadow = false;
    player.add(neck);

    // Torso - BoxGeometry, colored shirt
    var torsoGeo = new THREE.BoxGeometry(0.5, 0.6, 0.3);
    var torsoMat = new THREE.MeshLambertMaterial({ color: color || 0x4169e1 });
    var torso = new THREE.Mesh(torsoGeo, torsoMat);
    torso.position.y = 0.9;
    torso.castShadow = false;
    player.add(torso);

    // Shoulder joints
    var shoulderGeo = new THREE.SphereGeometry(0.1, 8, 8);
    var leftShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    leftShoulder.position.set(-0.35, 1.2, 0);
    leftShoulder.castShadow = false;
    player.add(leftShoulder);

    var rightShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    rightShoulder.position.set(0.35, 1.2, 0);
    rightShoulder.castShadow = false;
    player.add(rightShoulder);

    // Arms - CylinderGeometry, attached at shoulders
    var armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);

    var leftArm = new THREE.Mesh(armGeo, skinMat.clone());
    leftArm.position.set(-0.35, 1.05, 0);
    leftArm.castShadow = false;
    player.add(leftArm);

    // Hands as children of arms
    var handGeo = new THREE.SphereGeometry(0.07, 8, 8);
    var leftHand = new THREE.Mesh(handGeo, skinMat.clone());
    leftHand.position.y = -0.3;
    leftArm.add(leftHand);

    var rightArm = new THREE.Mesh(armGeo, skinMat.clone());
    rightArm.position.set(0.35, 1.05, 0);
    rightArm.castShadow = false;
    player.add(rightArm);

    var rightHand = new THREE.Mesh(handGeo, skinMat.clone());
    rightHand.position.y = -0.3;
    rightArm.add(rightHand);

    // Legs - CylinderGeometry, attached at hips
    var legGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
    var legMat = new THREE.MeshLambertMaterial({ color: 0x2f4f4f });

    var leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, 0.35, 0);
    leftLeg.castShadow = false;
    player.add(leftLeg);

    var rightLeg = new THREE.Mesh(legGeo, legMat.clone());
    rightLeg.position.set(0.15, 0.35, 0);
    rightLeg.castShadow = false;
    player.add(rightLeg);

    // Feet - Small BoxGeometry at bottom of legs
    var footGeo = new THREE.BoxGeometry(0.15, 0.1, 0.25);
    var footMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

    var leftFoot = new THREE.Mesh(footGeo, footMat);
    leftFoot.position.set(-0.15, 0.05, 0.05);
    leftFoot.castShadow = false;
    player.add(leftFoot);

    var rightFoot = new THREE.Mesh(footGeo, footMat.clone());
    rightFoot.position.set(0.15, 0.05, 0.05);
    rightFoot.castShadow = false;
    player.add(rightFoot);

    // Store references to limbs in userData for animation
    player.userData.limbs = {
      head: head,
      torso: torso,
      leftArm: leftArm,
      rightArm: rightArm,
      leftLeg: leftLeg,
      rightLeg: rightLeg,
      leftFoot: leftFoot,
      rightFoot: rightFoot
    };

    // Animation state tracking
    player.userData.animTime = 0;
    player.userData.prevPosition = new THREE.Vector3();
    player.userData.animState = 'idle'; // 'idle', 'walk', 'run'

    return player;
  }

  // ========================================================================
  // ENVIRONMENT POPULATION â€” Trees, rocks, benches, lanterns
  // ========================================================================

  function populateEnvironment(scene) {
    var Models = typeof window !== 'undefined' ? window.Models : null;
    if (!Models) {
      console.log('Models module not loaded, skipping environment population');
      return;
    }

    // ---- Gardens: trees, flowers, benches along paths ----
    var gz = ZONES.gardens;
    var gardenTreeTypes = ['oak', 'willow', 'cherry', 'cherry'];
    for (var gt = 0; gt < 20; gt++) {
      var ga = hash2D(gt, 100) * Math.PI * 2;
      var gr = 15 + hash2D(gt, 101) * 55;
      var gx = gz.cx + Math.cos(ga) * gr;
      var gzz = gz.cz + Math.sin(ga) * gr;
      var gy = terrainHeight(gx, gzz);
      var treeType = gardenTreeTypes[gt % gardenTreeTypes.length];
      var tree = Models.createTree(treeType, 0.8 + hash2D(gt, 102) * 0.6);
      tree.position.set(gx, gy, gzz);
      tree.rotation.y = hash2D(gt, 103) * Math.PI * 2;
      scene.add(tree);
      animatedObjects.push({ mesh: tree, type: 'tree', params: { speed: 0.3 + hash2D(gt, 104) * 0.3 } });
    }
    // Benches in gardens
    for (var gb = 0; gb < 6; gb++) {
      var ba = (gb / 6) * Math.PI * 2 + 0.5;
      var bx = gz.cx + Math.cos(ba) * 25;
      var bz = gz.cz + Math.sin(ba) * 25;
      var by = terrainHeight(bx, bz);
      var bench = Models.createFurniture('bench');
      bench.position.set(bx, by, bz);
      bench.rotation.y = ba + Math.PI / 2;
      scene.add(bench);
    }
    // Lanterns along garden paths
    for (var gl = 0; gl < 10; gl++) {
      var la = (gl / 10) * Math.PI * 2;
      var lx = gz.cx + Math.cos(la) * 35;
      var lz = gz.cz + Math.sin(la) * 35;
      var ly = terrainHeight(lx, lz);
      var lantern = Models.createFurniture('lantern');
      lantern.position.set(lx, ly, lz);
      scene.add(lantern);
    }

    // ---- Wilds: dense forest, boulders, dead trees ----
    var wz = ZONES.wilds;
    var wildTreeTypes = ['oak', 'pine', 'pine', 'dead', 'oak'];
    for (var wt = 0; wt < 40; wt++) {
      var wa = hash2D(wt, 200) * Math.PI * 2;
      var wr = 10 + hash2D(wt, 201) * 70;
      var wx = wz.cx + Math.cos(wa) * wr;
      var wz2 = wz.cz + Math.sin(wa) * wr;
      var wy = terrainHeight(wx, wz2);
      var wildType = wildTreeTypes[wt % wildTreeTypes.length];
      var wtree = Models.createTree(wildType, 0.7 + hash2D(wt, 202) * 0.8);
      wtree.position.set(wx, wy, wz2);
      wtree.rotation.y = hash2D(wt, 203) * Math.PI * 2;
      scene.add(wtree);
      animatedObjects.push({ mesh: wtree, type: 'tree', params: { speed: 0.2 + hash2D(wt, 204) * 0.4 } });
    }
    // Boulders and crystal rocks in wilds
    for (var wb = 0; wb < 15; wb++) {
      var rba = hash2D(wb, 210) * Math.PI * 2;
      var rbr = 8 + hash2D(wb, 211) * 60;
      var rbx = wz.cx + Math.cos(rba) * rbr;
      var rbz = wz.cz + Math.sin(rba) * rbr;
      var rby = terrainHeight(rbx, rbz);
      var rockType = (wb % 5 === 0) ? 'crystal' : 'boulder';
      var rock = Models.createRock(rockType, 0.5 + hash2D(wb, 212) * 1.5);
      rock.position.set(rbx, rby, rbz);
      rock.rotation.y = hash2D(wb, 213) * Math.PI * 2;
      scene.add(rock);
    }

    // ---- Nexus: ornamental trees, benches, lanterns ----
    var nz = ZONES.nexus;
    for (var nt = 0; nt < 8; nt++) {
      var na = (nt / 8) * Math.PI * 2 + Math.PI / 8;
      var nx = nz.cx + Math.cos(na) * 25;
      var nzz = nz.cz + Math.sin(na) * 25;
      var ny = terrainHeight(nx, nzz);
      var ntree = Models.createTree('cherry', 0.7);
      ntree.position.set(nx, ny, nzz);
      scene.add(ntree);
      animatedObjects.push({ mesh: ntree, type: 'tree', params: { speed: 0.3 } });
    }
    // Stone benches around nexus
    for (var nb = 0; nb < 8; nb++) {
      var nba = (nb / 8) * Math.PI * 2;
      var nbx = nz.cx + Math.cos(nba) * 18;
      var nbz = nz.cz + Math.sin(nba) * 18;
      var nby = terrainHeight(nbx, nbz);
      var nbench = Models.createFurniture('bench');
      nbench.position.set(nbx, nby, nbz);
      nbench.rotation.y = nba + Math.PI / 2;
      scene.add(nbench);
    }

    // ---- Agora: market crates, lanterns along paths ----
    var az = ZONES.agora;
    for (var al = 0; al < 12; al++) {
      var ala = (al / 12) * Math.PI * 2;
      var alx = az.cx + Math.cos(ala) * 22;
      var alz = az.cz + Math.sin(ala) * 22;
      var aly = terrainHeight(alx, alz);
      var alantern = Models.createFurniture('lantern');
      alantern.position.set(alx, aly, alz);
      scene.add(alantern);
    }

    // ---- Commons: trees around village, fences ----
    var cz = ZONES.commons;
    for (var ct = 0; ct < 12; ct++) {
      var ca = hash2D(ct, 300) * Math.PI * 2;
      var cr = 25 + hash2D(ct, 301) * 25;
      var cx = cz.cx + Math.cos(ca) * cr;
      var czz = cz.cz + Math.sin(ca) * cr;
      var cy = terrainHeight(cx, czz);
      var ctree = Models.createTree('oak', 0.6 + hash2D(ct, 302) * 0.5);
      ctree.position.set(cx, cy, czz);
      ctree.rotation.y = hash2D(ct, 303) * Math.PI * 2;
      scene.add(ctree);
      animatedObjects.push({ mesh: ctree, type: 'tree', params: { speed: 0.3 } });
    }

    // ---- Studio: artistic rocks, small trees ----
    var sz = ZONES.studio;
    for (var st = 0; st < 8; st++) {
      var sa = hash2D(st, 400) * Math.PI * 2;
      var sr = 20 + hash2D(st, 401) * 30;
      var sx = sz.cx + Math.cos(sa) * sr;
      var szz = sz.cz + Math.sin(sa) * sr;
      var sy = terrainHeight(sx, szz);
      var srock = Models.createRock('crystal', 0.8 + hash2D(st, 402) * 0.8);
      srock.position.set(sx, sy, szz);
      scene.add(srock);
    }

    // ---- Athenaeum: ordered trees, benches ----
    var atz = ZONES.athenaeum;
    for (var at = 0; at < 10; at++) {
      var ata = hash2D(at, 500) * Math.PI * 2;
      var atr = 20 + hash2D(at, 501) * 35;
      var atx = atz.cx + Math.cos(ata) * atr;
      var atzz = atz.cz + Math.sin(ata) * atr;
      var aty = terrainHeight(atx, atzz);
      var attree = Models.createTree('pine', 0.7 + hash2D(at, 502) * 0.4);
      attree.position.set(atx, aty, atzz);
      scene.add(attree);
      animatedObjects.push({ mesh: attree, type: 'tree', params: { speed: 0.25 } });
    }

    // ---- Arena: sparse vegetation ----
    var arz = ZONES.arena;
    for (var ar = 0; ar < 6; ar++) {
      var ara = hash2D(ar, 600) * Math.PI * 2;
      var arr = 30 + hash2D(ar, 601) * 15;
      var arx = arz.cx + Math.cos(ara) * arr;
      var arzz = arz.cz + Math.sin(ara) * arr;
      var ary = terrainHeight(arx, arzz);
      var arrock = Models.createRock('boulder', 0.6 + hash2D(ar, 602) * 1.0);
      arrock.position.set(arx, ary, arzz);
      arrock.rotation.y = hash2D(ar, 603) * Math.PI;
      scene.add(arrock);
    }

    // ---- Butterflies and birds scattered around gardens and wilds ----
    if (Models.createCreature) {
      for (var bf = 0; bf < 8; bf++) {
        var bfa = hash2D(bf, 700) * Math.PI * 2;
        var bfr = 10 + hash2D(bf, 701) * 50;
        var bfx = gz.cx + Math.cos(bfa) * bfr;
        var bfz = gz.cz + Math.sin(bfa) * bfr;
        var bfy = terrainHeight(bfx, bfz) + 1.5 + hash2D(bf, 702) * 2;
        var butterfly = Models.createCreature('butterfly');
        butterfly.position.set(bfx, bfy, bfz);
        scene.add(butterfly);
        animatedObjects.push({ mesh: butterfly, type: 'creature', params: { speed: 1 + hash2D(bf, 703) } });
      }
      for (var bi = 0; bi < 6; bi++) {
        var bia = hash2D(bi, 710) * Math.PI * 2;
        var bir = 10 + hash2D(bi, 711) * 60;
        var bix = wz.cx + Math.cos(bia) * bir;
        var biz = wz.cz + Math.sin(bia) * bir;
        var biy = terrainHeight(bix, biz) + 5 + hash2D(bi, 712) * 5;
        var bird = Models.createCreature('bird');
        bird.position.set(bix, biy, biz);
        scene.add(bird);
        animatedObjects.push({ mesh: bird, type: 'creature', params: { speed: 0.5 + hash2D(bi, 713) * 0.5 } });
      }
    }

    // ---- LANDMARKS: unique structures per zone ----
    if (Models.createLandmark) {
      // Nexus: fountain (center), 4 obelisks (compass points), 2 signposts
      var fountain = Models.createLandmark('fountain', 1.2);
      fountain.position.set(nz.cx, terrainHeight(nz.cx, nz.cz), nz.cz);
      scene.add(fountain);
      animatedObjects.push({ mesh: fountain, type: 'landmark', params: {} });

      for (var no = 0; no < 4; no++) {
        var noa = (no / 4) * Math.PI * 2;
        var nox = nz.cx + Math.cos(noa) * 35;
        var noz = nz.cz + Math.sin(noa) * 35;
        var obelisk = Models.createLandmark('obelisk', 1.0);
        obelisk.position.set(nox, terrainHeight(nox, noz), noz);
        scene.add(obelisk);
        animatedObjects.push({ mesh: obelisk, type: 'landmark', params: {} });
      }

      for (var ns = 0; ns < 2; ns++) {
        var nsa = (ns / 2) * Math.PI * 2 + Math.PI / 4;
        var nsx = nz.cx + Math.cos(nsa) * 28;
        var nsz = nz.cz + Math.sin(nsa) * 28;
        var signpost = Models.createLandmark('signpost', 1.0);
        signpost.position.set(nsx, terrainHeight(nsx, nsz), nsz);
        signpost.rotation.y = nsa;
        scene.add(signpost);
      }

      // Nexus: Rift Portal â€” glowing arch for federation connections
      var riftPortal = new THREE.Group();
      var archMat = new THREE.MeshStandardMaterial({ color: 0x8855ff, emissive: 0x4422aa, emissiveIntensity: 0.5 });
      // Left pillar
      var pillarGeo = new THREE.BoxBufferGeometry(0.6, 6, 0.6);
      var lPillar = new THREE.Mesh(pillarGeo, archMat);
      lPillar.position.set(-2, 3, 0);
      riftPortal.add(lPillar);
      // Right pillar
      var rPillar = new THREE.Mesh(pillarGeo, archMat);
      rPillar.position.set(2, 3, 0);
      riftPortal.add(rPillar);
      // Top beam
      var beamGeo = new THREE.BoxBufferGeometry(4.6, 0.6, 0.6);
      var topBeam = new THREE.Mesh(beamGeo, archMat);
      topBeam.position.set(0, 6.3, 0);
      riftPortal.add(topBeam);
      // Portal shimmer plane
      var shimmerMat = new THREE.MeshBasicMaterial({ color: 0xaa77ff, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
      var shimmerGeo = new THREE.PlaneBufferGeometry(3.4, 5.6);
      var shimmer = new THREE.Mesh(shimmerGeo, shimmerMat);
      shimmer.position.set(0, 3.1, 0);
      riftPortal.add(shimmer);
      var rpx = nz.cx + 20;
      var rpz = nz.cz - 20;
      riftPortal.position.set(rpx, terrainHeight(rpx, rpz), rpz);
      scene.add(riftPortal);
      animatedObjects.push({ mesh: riftPortal, type: 'landmark', params: { shimmer: shimmer } });

      // Gardens: gazebo (center-ish), 4 campfires along paths, 6 flower beds, 4 herb patches
      var gazebo = Models.createLandmark('gazebo', 1.0);
      gazebo.position.set(gz.cx + 10, terrainHeight(gz.cx + 10, gz.cz + 10), gz.cz + 10);
      scene.add(gazebo);

      for (var gc = 0; gc < 4; gc++) {
        var gca = (gc / 4) * Math.PI * 2 + Math.PI / 8;
        var gcx = gz.cx + Math.cos(gca) * 40;
        var gcz = gz.cz + Math.sin(gca) * 40;
        var campfire = Models.createLandmark('campfire', 1.0);
        campfire.position.set(gcx, terrainHeight(gcx, gcz), gcz);
        scene.add(campfire);
        animatedObjects.push({ mesh: campfire, type: 'landmark', params: {} });
      }

      for (var gf = 0; gf < 6; gf++) {
        var gfa = hash2D(gf, 720) * Math.PI * 2;
        var gfr = 20 + hash2D(gf, 721) * 35;
        var gfx = gz.cx + Math.cos(gfa) * gfr;
        var gfz = gz.cz + Math.sin(gfa) * gfr;
        var flowerBed = Models.createResourceNode('flower_bed', 1.0);
        flowerBed.position.set(gfx, terrainHeight(gfx, gfz), gfz);
        flowerBed.rotation.y = hash2D(gf, 722) * Math.PI * 2;
        scene.add(flowerBed);
      }

      for (var gh = 0; gh < 4; gh++) {
        var gha = hash2D(gh, 730) * Math.PI * 2;
        var ghr = 25 + hash2D(gh, 731) * 30;
        var ghx = gz.cx + Math.cos(gha) * ghr;
        var ghz = gz.cz + Math.sin(gha) * ghr;
        var herbPatch = Models.createResourceNode('herb_patch', 1.0);
        herbPatch.position.set(ghx, terrainHeight(ghx, ghz), ghz);
        herbPatch.rotation.y = hash2D(gh, 732) * Math.PI * 2;
        scene.add(herbPatch);
      }

      // Wilds: 2 campfires (explorer camps), 3 signposts, 8 ore veins, 4 wood piles
      for (var wc = 0; wc < 2; wc++) {
        var wca = hash2D(wc, 740) * Math.PI * 2;
        var wcr = 30 + hash2D(wc, 741) * 25;
        var wcx = wz.cx + Math.cos(wca) * wcr;
        var wcz = wz.cz + Math.sin(wca) * wcr;
        var wcampfire = Models.createLandmark('campfire', 1.0);
        wcampfire.position.set(wcx, terrainHeight(wcx, wcz), wcz);
        scene.add(wcampfire);
        animatedObjects.push({ mesh: wcampfire, type: 'landmark', params: {} });
      }

      for (var ws = 0; ws < 3; ws++) {
        var wsa = hash2D(ws, 750) * Math.PI * 2;
        var wsr = 35 + hash2D(ws, 751) * 30;
        var wsx = wz.cx + Math.cos(wsa) * wsr;
        var wsz = wz.cz + Math.sin(wsa) * wsr;
        var wsignpost = Models.createLandmark('signpost', 1.0);
        wsignpost.position.set(wsx, terrainHeight(wsx, wsz), wsz);
        wsignpost.rotation.y = wsa;
        scene.add(wsignpost);
      }

      for (var wo = 0; wo < 8; wo++) {
        var woa = hash2D(wo, 760) * Math.PI * 2;
        var wor = 15 + hash2D(wo, 761) * 50;
        var wox = wz.cx + Math.cos(woa) * wor;
        var woz = wz.cz + Math.sin(woa) * wor;
        var oreVein = Models.createResourceNode('ore_vein', 0.8 + hash2D(wo, 762) * 0.5);
        oreVein.position.set(wox, terrainHeight(wox, woz), woz);
        oreVein.rotation.y = hash2D(wo, 763) * Math.PI * 2;
        scene.add(oreVein);
      }

      for (var ww = 0; ww < 4; ww++) {
        var wwa = hash2D(ww, 770) * Math.PI * 2;
        var wwr = 20 + hash2D(ww, 771) * 40;
        var wwx = wz.cx + Math.cos(wwa) * wwr;
        var wwz = wz.cz + Math.sin(wwa) * wwr;
        var woodPile = Models.createResourceNode('wood_pile', 1.0);
        woodPile.position.set(wwx, terrainHeight(wwx, wwz), wwz);
        woodPile.rotation.y = hash2D(ww, 772) * Math.PI * 2;
        scene.add(woodPile);
      }

      // Athenaeum: 2 statues (flanking entrance), 4 obelisks (mystical markers)
      for (var ats = 0; ats < 2; ats++) {
        var atsa = (ats / 2) * Math.PI * 2;
        var atsx = atz.cx + Math.cos(atsa) * 25;
        var atsz = atz.cz + Math.sin(atsa) * 25;
        var statue = Models.createLandmark('statue', 1.1);
        statue.position.set(atsx, terrainHeight(atsx, atsz), atsz);
        statue.rotation.y = atsa + Math.PI;
        scene.add(statue);
      }

      for (var ato = 0; ato < 4; ato++) {
        var atoa = (ato / 4) * Math.PI * 2 + Math.PI / 8;
        var atox = atz.cx + Math.cos(atoa) * 35;
        var atoz = atz.cz + Math.sin(atoa) * 35;
        var atobelisk = Models.createLandmark('obelisk', 0.9);
        atobelisk.position.set(atox, terrainHeight(atox, atoz), atoz);
        scene.add(atobelisk);
        animatedObjects.push({ mesh: atobelisk, type: 'landmark', params: {} });
      }

      // Studio: 3 crystal clusters (inspiration points), 1 gazebo
      for (var sc = 0; sc < 3; sc++) {
        var sca = hash2D(sc, 780) * Math.PI * 2;
        var scr = 25 + hash2D(sc, 781) * 20;
        var scx = sz.cx + Math.cos(sca) * scr;
        var scz = sz.cz + Math.sin(sca) * scr;
        var crystalCluster = Models.createResourceNode('crystal_cluster', 0.9 + hash2D(sc, 782) * 0.4);
        crystalCluster.position.set(scx, terrainHeight(scx, scz), scz);
        crystalCluster.rotation.y = hash2D(sc, 783) * Math.PI * 2;
        scene.add(crystalCluster);
      }

      var sgazebo = Models.createLandmark('gazebo', 0.9);
      sgazebo.position.set(sz.cx + 15, terrainHeight(sz.cx + 15, sz.cz - 15), sz.cz - 15);
      scene.add(sgazebo);

      // Agora: 6 signposts, 2 campfires (merchant gathering), 3 flower beds
      for (var ags = 0; ags < 6; ags++) {
        var agsa = (ags / 6) * Math.PI * 2;
        var agsx = az.cx + Math.cos(agsa) * 30;
        var agsz = az.cz + Math.sin(agsa) * 30;
        var agsignpost = Models.createLandmark('signpost', 1.0);
        agsignpost.position.set(agsx, terrainHeight(agsx, agsz), agsz);
        agsignpost.rotation.y = agsa;
        scene.add(agsignpost);
      }

      for (var agc = 0; agc < 2; agc++) {
        var agca = (agc / 2) * Math.PI * 2 + Math.PI / 4;
        var agcx = az.cx + Math.cos(agca) * 20;
        var agcz = az.cz + Math.sin(agca) * 20;
        var agcampfire = Models.createLandmark('campfire', 1.0);
        agcampfire.position.set(agcx, terrainHeight(agcx, agcz), agcz);
        scene.add(agcampfire);
        animatedObjects.push({ mesh: agcampfire, type: 'landmark', params: {} });
      }

      for (var agf = 0; agf < 3; agf++) {
        var agfa = hash2D(agf, 790) * Math.PI * 2;
        var agfr = 15 + hash2D(agf, 791) * 20;
        var agfx = az.cx + Math.cos(agfa) * agfr;
        var agfz = az.cz + Math.sin(agfa) * agfr;
        var agflowerBed = Models.createResourceNode('flower_bed', 0.9);
        agflowerBed.position.set(agfx, terrainHeight(agfx, agfz), agfz);
        agflowerBed.rotation.y = hash2D(agf, 792) * Math.PI * 2;
        scene.add(agflowerBed);
      }

      // Commons: 2 gazebos (gathering areas), 4 wood piles, 6 ore veins
      for (var cg = 0; cg < 2; cg++) {
        var cga = (cg / 2) * Math.PI * 2 + Math.PI / 3;
        var cgx = cz.cx + Math.cos(cga) * 30;
        var cgz = cz.cz + Math.sin(cga) * 30;
        var cgazebo = Models.createLandmark('gazebo', 0.95);
        cgazebo.position.set(cgx, terrainHeight(cgx, cgz), cgz);
        scene.add(cgazebo);
      }

      for (var cw = 0; cw < 4; cw++) {
        var cwa = hash2D(cw, 800) * Math.PI * 2;
        var cwr = 20 + hash2D(cw, 801) * 25;
        var cwx = cz.cx + Math.cos(cwa) * cwr;
        var cwz = cz.cz + Math.sin(cwa) * cwr;
        var cwoodPile = Models.createResourceNode('wood_pile', 1.0);
        cwoodPile.position.set(cwx, terrainHeight(cwx, cwz), cwz);
        cwoodPile.rotation.y = hash2D(cw, 802) * Math.PI * 2;
        scene.add(cwoodPile);
      }

      for (var co = 0; co < 6; co++) {
        var coa = hash2D(co, 810) * Math.PI * 2;
        var cor = 18 + hash2D(co, 811) * 28;
        var cox = cz.cx + Math.cos(coa) * cor;
        var coz = cz.cz + Math.sin(coa) * cor;
        var coreVein = Models.createResourceNode('ore_vein', 0.9 + hash2D(co, 812) * 0.4);
        coreVein.position.set(cox, terrainHeight(cox, coz), coz);
        coreVein.rotation.y = hash2D(co, 813) * Math.PI * 2;
        scene.add(coreVein);
      }

      // Arena: 2 statues (champion statues), 4 campfires
      for (var ars = 0; ars < 2; ars++) {
        var arsa = (ars / 2) * Math.PI * 2 + Math.PI / 2;
        var arsx = arz.cx + Math.cos(arsa) * 28;
        var arsz = arz.cz + Math.sin(arsa) * 28;
        var arstatue = Models.createLandmark('statue', 1.2);
        arstatue.position.set(arsx, terrainHeight(arsx, arsz), arsz);
        arstatue.rotation.y = arsa + Math.PI;
        scene.add(arstatue);
      }

      for (var arc = 0; arc < 4; arc++) {
        var arca = (arc / 4) * Math.PI * 2;
        var arcx = arz.cx + Math.cos(arca) * 32;
        var arcz = arz.cz + Math.sin(arca) * 32;
        var arcampfire = Models.createLandmark('campfire', 1.0);
        arcampfire.position.set(arcx, terrainHeight(arcx, arcz), arcz);
        scene.add(arcampfire);
        animatedObjects.push({ mesh: arcampfire, type: 'landmark', params: {} });
      }
    }

    // ---- WILDLIFE: creatures scattered by zone ----
    if (Models.createWildlife) {
      // Gardens: 6 rabbits, 10 fireflies
      for (var gr = 0; gr < 6; gr++) {
        var gra = hash2D(gr, 820) * Math.PI * 2;
        var grr = 15 + hash2D(gr, 821) * 40;
        var grx = gz.cx + Math.cos(gra) * grr;
        var grz = gz.cz + Math.sin(gra) * grr;
        var gry = terrainHeight(grx, grz);
        var rabbit = Models.createWildlife('rabbit');
        rabbit.position.set(grx, gry, grz);
        rabbit.rotation.y = hash2D(gr, 822) * Math.PI * 2;
        scene.add(rabbit);
        animatedObjects.push({ mesh: rabbit, type: 'creature', params: { speed: 0.8 + hash2D(gr, 823) * 0.4 } });
      }

      for (var gfl = 0; gfl < 10; gfl++) {
        var gfla = hash2D(gfl, 830) * Math.PI * 2;
        var gflr = 10 + hash2D(gfl, 831) * 50;
        var gflx = gz.cx + Math.cos(gfla) * gflr;
        var gflz = gz.cz + Math.sin(gfla) * gflr;
        var gfly = terrainHeight(gflx, gflz) + 1.5 + hash2D(gfl, 832) * 1.5;
        var firefly = Models.createWildlife('firefly');
        firefly.position.set(gflx, gfly, gflz);
        scene.add(firefly);
        animatedObjects.push({ mesh: firefly, type: 'creature', params: { speed: 1.2 + hash2D(gfl, 833) * 0.6 } });
      }

      // Wilds: 4 deer, 6 rabbits, 15 fireflies, 4 frogs
      for (var wd = 0; wd < 4; wd++) {
        var wda = hash2D(wd, 840) * Math.PI * 2;
        var wdr = 25 + hash2D(wd, 841) * 45;
        var wdx = wz.cx + Math.cos(wda) * wdr;
        var wdz = wz.cz + Math.sin(wda) * wdr;
        var wdy = terrainHeight(wdx, wdz);
        var deer = Models.createWildlife('deer');
        deer.position.set(wdx, wdy, wdz);
        deer.rotation.y = hash2D(wd, 842) * Math.PI * 2;
        scene.add(deer);
        animatedObjects.push({ mesh: deer, type: 'creature', params: { speed: 0.6 + hash2D(wd, 843) * 0.3 } });
      }

      for (var wr = 0; wr < 6; wr++) {
        var wra = hash2D(wr, 850) * Math.PI * 2;
        var wrr = 20 + hash2D(wr, 851) * 50;
        var wrx = wz.cx + Math.cos(wra) * wrr;
        var wrz = wz.cz + Math.sin(wra) * wrr;
        var wry = terrainHeight(wrx, wrz);
        var wrabbit = Models.createWildlife('rabbit');
        wrabbit.position.set(wrx, wry, wrz);
        wrabbit.rotation.y = hash2D(wr, 852) * Math.PI * 2;
        scene.add(wrabbit);
        animatedObjects.push({ mesh: wrabbit, type: 'creature', params: { speed: 0.8 + hash2D(wr, 853) * 0.4 } });
      }

      for (var wfl = 0; wfl < 15; wfl++) {
        var wfla = hash2D(wfl, 860) * Math.PI * 2;
        var wflr = 15 + hash2D(wfl, 861) * 60;
        var wflx = wz.cx + Math.cos(wfla) * wflr;
        var wflz = wz.cz + Math.sin(wfla) * wflr;
        var wfly = terrainHeight(wflx, wflz) + 1.5 + hash2D(wfl, 862) * 1.5;
        var wfirefly = Models.createWildlife('firefly');
        wfirefly.position.set(wflx, wfly, wflz);
        scene.add(wfirefly);
        animatedObjects.push({ mesh: wfirefly, type: 'creature', params: { speed: 1.2 + hash2D(wfl, 863) * 0.6 } });
      }

      for (var wf = 0; wf < 4; wf++) {
        var wfa = hash2D(wf, 870) * Math.PI * 2;
        var wfr = 30 + hash2D(wf, 871) * 35;
        var wfx = wz.cx + Math.cos(wfa) * wfr;
        var wfz = wz.cz + Math.sin(wfa) * wfr;
        var wfy = terrainHeight(wfx, wfz);
        var frog = Models.createWildlife('frog');
        frog.position.set(wfx, wfy, wfz);
        frog.rotation.y = hash2D(wf, 872) * Math.PI * 2;
        scene.add(frog);
        animatedObjects.push({ mesh: frog, type: 'creature', params: { speed: 0.5 + hash2D(wf, 873) * 0.3 } });
      }

      // Commons: 3 rabbits
      for (var cr = 0; cr < 3; cr++) {
        var cra = hash2D(cr, 880) * Math.PI * 2;
        var crr = 20 + hash2D(cr, 881) * 25;
        var crx = cz.cx + Math.cos(cra) * crr;
        var crz = cz.cz + Math.sin(cra) * crr;
        var cry = terrainHeight(crx, crz);
        var crabbit = Models.createWildlife('rabbit');
        crabbit.position.set(crx, cry, crz);
        crabbit.rotation.y = hash2D(cr, 882) * Math.PI * 2;
        scene.add(crabbit);
        animatedObjects.push({ mesh: crabbit, type: 'creature', params: { speed: 0.8 + hash2D(cr, 883) * 0.4 } });
      }

      // Nexus: 4 fireflies
      for (var nfl = 0; nfl < 4; nfl++) {
        var nfla = hash2D(nfl, 890) * Math.PI * 2;
        var nflr = 15 + hash2D(nfl, 891) * 20;
        var nflx = nz.cx + Math.cos(nfla) * nflr;
        var nflz = nz.cz + Math.sin(nfla) * nflr;
        var nfly = terrainHeight(nflx, nflz) + 1.5 + hash2D(nfl, 892) * 1.5;
        var nfirefly = Models.createWildlife('firefly');
        nfirefly.position.set(nflx, nfly, nflz);
        scene.add(nfirefly);
        animatedObjects.push({ mesh: nfirefly, type: 'creature', params: { speed: 1.2 + hash2D(nfl, 893) * 0.6 } });
      }
    }

    // ---- GROUND COVER: grass, bushes, mushrooms, fallen logs ----
    if (Models.createGrassPatch) {
      // Scatter grass patches across all natural zones
      var naturalZones = [gz, wz, cz, nz];
      for (var nzi = 0; nzi < naturalZones.length; nzi++) {
        var nzInfo = naturalZones[nzi];
        var grassCount = nzi === 1 ? 30 : 15; // More in wilds
        for (var gp = 0; gp < grassCount; gp++) {
          var gpa = hash2D(gp + nzi * 100, 900) * Math.PI * 2;
          var gpr = 8 + hash2D(gp + nzi * 100, 901) * 55;
          var gpx = nzInfo.cx + Math.cos(gpa) * gpr;
          var gpz = nzInfo.cz + Math.sin(gpa) * gpr;
          var grassPatch = Models.createGrassPatch(0.8 + hash2D(gp + nzi * 100, 902) * 0.6);
          grassPatch.position.set(gpx, terrainHeight(gpx, gpz), gpz);
          grassPatch.rotation.y = hash2D(gp + nzi * 100, 903) * Math.PI * 2;
          scene.add(grassPatch);
        }
      }
    }

    if (Models.createBush) {
      // Bushes in gardens (flowering), wilds (berry/green), commons (green)
      var bushTypes = ['flowering', 'flowering', 'green'];
      for (var gb = 0; gb < 8; gb++) {
        var gba = hash2D(gb, 910) * Math.PI * 2;
        var gbr = 12 + hash2D(gb, 911) * 40;
        var gbx = gz.cx + Math.cos(gba) * gbr;
        var gbz = gz.cz + Math.sin(gba) * gbr;
        var gardenBush = Models.createBush(bushTypes[gb % 3], 0.8 + hash2D(gb, 912) * 0.4);
        gardenBush.position.set(gbx, terrainHeight(gbx, gbz), gbz);
        scene.add(gardenBush);
      }

      // Berry and green bushes in wilds
      for (var wb = 0; wb < 10; wb++) {
        var wba = hash2D(wb, 920) * Math.PI * 2;
        var wbr = 15 + hash2D(wb, 921) * 50;
        var wbx = wz.cx + Math.cos(wba) * wbr;
        var wbz = wz.cz + Math.sin(wba) * wbr;
        var wildBush = Models.createBush(wb % 3 === 0 ? 'berry' : 'green', 0.7 + hash2D(wb, 922) * 0.5);
        wildBush.position.set(wbx, terrainHeight(wbx, wbz), wbz);
        scene.add(wildBush);
      }
    }

    if (Models.createMushroom) {
      // Mushroom clusters in wilds and gardens
      var mushroomTypes = ['red', 'brown', 'white', 'purple', 'glowing'];
      for (var wm = 0; wm < 8; wm++) {
        var wma = hash2D(wm, 930) * Math.PI * 2;
        var wmr = 20 + hash2D(wm, 931) * 45;
        var wmx = wz.cx + Math.cos(wma) * wmr;
        var wmz = wz.cz + Math.sin(wma) * wmr;
        var mushroom = Models.createMushroom(mushroomTypes[wm % 5], 0.8 + hash2D(wm, 932) * 0.5);
        mushroom.position.set(wmx, terrainHeight(wmx, wmz), wmz);
        mushroom.rotation.y = hash2D(wm, 933) * Math.PI * 2;
        scene.add(mushroom);
      }

      // Glowing mushrooms in athenaeum (mystical)
      for (var am = 0; am < 5; am++) {
        var ama = hash2D(am, 940) * Math.PI * 2;
        var amr = 15 + hash2D(am, 941) * 25;
        var amx = atz.cx + Math.cos(ama) * amr;
        var amz = atz.cz + Math.sin(ama) * amr;
        var glowMush = Models.createMushroom('glowing', 0.6 + hash2D(am, 942) * 0.4);
        glowMush.position.set(amx, terrainHeight(amx, amz), amz);
        scene.add(glowMush);
      }
    }

    if (Models.createFallenLog) {
      // Fallen logs in wilds and commons
      for (var fl = 0; fl < 5; fl++) {
        var fla = hash2D(fl, 950) * Math.PI * 2;
        var flr = 20 + hash2D(fl, 951) * 40;
        var flx = wz.cx + Math.cos(fla) * flr;
        var flz = wz.cz + Math.sin(fla) * flr;
        var fallenLog = Models.createFallenLog(0.8 + hash2D(fl, 952) * 0.4);
        fallenLog.position.set(flx, terrainHeight(flx, flz), flz);
        fallenLog.rotation.y = hash2D(fl, 953) * Math.PI * 2;
        scene.add(fallenLog);
      }

      for (var cl = 0; cl < 3; cl++) {
        var cla = hash2D(cl, 960) * Math.PI * 2;
        var clr = 18 + hash2D(cl, 961) * 25;
        var clx = cz.cx + Math.cos(cla) * clr;
        var clz = cz.cz + Math.sin(cla) * clr;
        var commonLog = Models.createFallenLog(0.7 + hash2D(cl, 962) * 0.3);
        commonLog.position.set(clx, terrainHeight(clx, clz), clz);
        commonLog.rotation.y = hash2D(cl, 963) * Math.PI * 2;
        scene.add(commonLog);
      }
    }

    // ---- ZONE ARCHITECTURE: detailed structures per zone ----

    if (Models.createRuinWall) {
      // Arena: ancient ruins and ruin walls
      var arenaZone = ZONES.arena;
      for (var rw = 0; rw < 4; rw++) {
        var rwa = hash2D(rw, 1000) * Math.PI * 2;
        var rwr = 15 + hash2D(rw, 1001) * 25;
        var rwx = arenaZone.cx + Math.cos(rwa) * rwr;
        var rwz = arenaZone.cz + Math.sin(rwa) * rwr;
        var ruinWall = Models.createRuinWall(0.8 + hash2D(rw, 1002) * 0.4);
        ruinWall.position.set(rwx, terrainHeight(rwx, rwz), rwz);
        ruinWall.rotation.y = rwa + Math.PI / 2;
        scene.add(ruinWall);
      }
    }

    if (Models.createColumnRow) {
      // Athenaeum: classical columns
      var athenZone = ZONES.athenaeum;
      for (var cr = 0; cr < 3; cr++) {
        var cra = hash2D(cr, 1010) * Math.PI * 2;
        var crr = 10 + hash2D(cr, 1011) * 20;
        var crx = athenZone.cx + Math.cos(cra) * crr;
        var crz = athenZone.cz + Math.sin(cra) * crr;
        var columns = Models.createColumnRow(4 + Math.floor(hash2D(cr, 1012) * 3), 3.5, 2, 0.9);
        columns.position.set(crx, terrainHeight(crx, crz), crz);
        columns.rotation.y = cra;
        scene.add(columns);
      }
    }

    if (Models.createAmphitheater) {
      // Arena: amphitheater at center
      var amphitheater = Models.createAmphitheater(1.2);
      amphitheater.position.set(arenaZone.cx, terrainHeight(arenaZone.cx, arenaZone.cz), arenaZone.cz);
      scene.add(amphitheater);
    }

    if (Models.createWishingWell) {
      // Gardens: wishing well
      var gardenZone = ZONES.gardens;
      var well = Models.createWishingWell(1.0);
      well.position.set(gardenZone.cx + 15, terrainHeight(gardenZone.cx + 15, gardenZone.cz - 10), gardenZone.cz - 10);
      scene.add(well);

      // Commons: another wishing well
      var commonsZone = ZONES.commons;
      var well2 = Models.createWishingWell(0.9);
      well2.position.set(commonsZone.cx - 8, terrainHeight(commonsZone.cx - 8, commonsZone.cz + 5), commonsZone.cz + 5);
      scene.add(well2);
    }

    if (Models.createBookshelf) {
      // Athenaeum: bookshelves
      for (var bs = 0; bs < 6; bs++) {
        var bsa = hash2D(bs, 1030) * Math.PI * 2;
        var bsr = 8 + hash2D(bs, 1031) * 12;
        var bsx = athenZone.cx + Math.cos(bsa) * bsr;
        var bsz = athenZone.cz + Math.sin(bsa) * bsr;
        var bookshelf = Models.createBookshelf(1.0);
        bookshelf.position.set(bsx, terrainHeight(bsx, bsz), bsz);
        bookshelf.rotation.y = bsa + Math.PI;
        scene.add(bookshelf);
      }
    }

    if (Models.createTorch) {
      // Place torches near landmarks in several zones
      var torchZones = ['nexus', 'athenaeum', 'arena', 'agora'];
      for (var tz = 0; tz < torchZones.length; tz++) {
        var torchZone = ZONES[torchZones[tz]];
        for (var tc = 0; tc < 4; tc++) {
          var tca = hash2D(tc + tz * 10, 1040) * Math.PI * 2;
          var tcr = 8 + hash2D(tc + tz * 10, 1041) * 15;
          var tcx = torchZone.cx + Math.cos(tca) * tcr;
          var tcz = torchZone.cz + Math.sin(tca) * tcr;
          var torch = Models.createTorch(1.0);
          torch.position.set(tcx, terrainHeight(tcx, tcz), tcz);
          torch.rotation.y = tca;
          scene.add(torch);
          animatedObjects.push(torch);
        }
      }
    }

    if (Models.createBridge) {
      // Bridges between close zones
      // Gardens to Commons bridge
      var bridgeGC = Models.createBridge(10, 0.9);
      var bgcx = (gardenZone.cx + commonsZone.cx) / 2;
      var bgcz = (gardenZone.cz + commonsZone.cz) / 2;
      bridgeGC.position.set(bgcx, terrainHeight(bgcx, bgcz) - 0.5, bgcz);
      bridgeGC.rotation.y = Math.atan2(commonsZone.cz - gardenZone.cz, commonsZone.cx - gardenZone.cx);
      scene.add(bridgeGC);

      // Nexus to Athenaeum bridge
      var bridgeNA = Models.createBridge(12, 0.9);
      var bnax = (ZONES.nexus.cx + athenZone.cx) / 2;
      var bnaz = (ZONES.nexus.cz + athenZone.cz) / 2;
      bridgeNA.position.set(bnax, terrainHeight(bnax, bnaz) - 0.5, bnaz);
      bridgeNA.rotation.y = Math.atan2(athenZone.cz - ZONES.nexus.cz, athenZone.cx - ZONES.nexus.cx);
      scene.add(bridgeNA);
    }

    if (Models.createGardenArch) {
      // Garden arches at garden entrances
      for (var ga = 0; ga < 3; ga++) {
        var gaa = hash2D(ga, 1060) * Math.PI * 2;
        var gar = gardenZone.radius * 0.6;
        var gax = gardenZone.cx + Math.cos(gaa) * gar;
        var gaz = gardenZone.cz + Math.sin(gaa) * gar;
        var gardenArch = Models.createGardenArch(1.1);
        gardenArch.position.set(gax, terrainHeight(gax, gaz), gaz);
        gardenArch.rotation.y = gaa;
        scene.add(gardenArch);
        animatedObjects.push(gardenArch);
      }
    }

    if (Models.createBannerPole) {
      // Banner poles in agora and arena
      var bannerColors = [0xcc0000, 0x0000cc, 0x00cc00, 0xcc9900, 0x9900cc, 0x009999];
      var bannerZones = ['agora', 'arena', 'nexus'];
      for (var bz = 0; bz < bannerZones.length; bz++) {
        var bannerZone = ZONES[bannerZones[bz]];
        var bannerCount = bz === 0 ? 6 : 4;
        for (var bp = 0; bp < bannerCount; bp++) {
          var bpa = hash2D(bp + bz * 20, 1070) * Math.PI * 2;
          var bpr = 10 + hash2D(bp + bz * 20, 1071) * 20;
          var bpx = bannerZone.cx + Math.cos(bpa) * bpr;
          var bpz = bannerZone.cz + Math.sin(bpa) * bpr;
          var bannerColor = bannerColors[(bp + bz * 3) % bannerColors.length];
          var banner = Models.createBannerPole(bannerColor, 0.9);
          banner.position.set(bpx, terrainHeight(bpx, bpz), bpz);
          scene.add(banner);
          animatedObjects.push(banner);
        }
      }
    }

    console.log('Environment populated with trees, rocks, furniture, creatures, ground cover, and architecture');
  }

  // ========================================================================
  // SCENE INITIALIZATION
  // ========================================================================

  function initScene(container) {
    if (typeof THREE === 'undefined') {
      console.warn('THREE.js not available');
      return null;
    }

    var scene = new THREE.Scene();
    createSky(scene);

    // Add exponential fog for atmospheric depth (matches weather system)
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);

    var w = container.clientWidth || window.innerWidth;
    var h = container.clientHeight || window.innerHeight;

    var camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 1000);
    camera.position.set(0, 15, 25);
    camera.lookAt(0, 0, 0);

    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    renderer.shadowMap.enabled = false;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    container.appendChild(renderer.domElement);

    // Handle resize
    window.addEventListener('resize', function() {
      var rw = container.clientWidth || window.innerWidth;
      var rh = container.clientHeight || window.innerHeight;
      camera.aspect = rw / rh;
      camera.updateProjectionMatrix();
      renderer.setSize(rw, rh);
    });

    var ambientLight = new THREE.HemisphereLight(0x87ceeb, 0xd2b48c, 0.6);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xfff8e7, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = false;
    scene.add(directionalLight);

    // Create all zone structures (one-time, persistent)
    createZoneStructures(scene);

    // Place warm night lights at zone landmarks
    createZoneNightLights(scene);

    // Populate world with environmental objects (trees, rocks, furniture)
    populateEnvironment(scene);

    // Load initial chunks around nexus
    var ctx = {
      scene: scene,
      camera: camera,
      renderer: renderer,
      ambientLight: ambientLight,
      directionalLight: directionalLight
    };
    updateChunks(ctx, 0, 0);

    return ctx;
  }

  // ========================================================================
  // ZONE LOADING â€” now just teleports camera
  // ========================================================================

  function loadZone(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene || !sceneCtx.camera) return;
    var zone = ZONES[zoneId];
    if (!zone) return;
    activeZone = zoneId;
    sceneCtx.camera.position.set(zone.cx, zone.baseHeight + 15, zone.cz + 25);
    sceneCtx.camera.lookAt(zone.cx, zone.baseHeight, zone.cz);
    updateChunks(sceneCtx, zone.cx, zone.cz);
  }

  // ========================================================================
  // PLAYER MANAGEMENT â€” API matches main.js expectations
  // ========================================================================

  function addPlayer(sceneCtx, playerId, position) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var x = position.x || 0, z = position.z || 0;
    var y = terrainHeight(x, z);
    var mesh = createHumanoidModel();
    mesh.position.set(x, y, z);

    // Initialize previous position for animation tracking
    mesh.userData.prevPosition.set(x, y, z);

    sceneCtx.scene.add(mesh);

    // Name label - billboard sprite above head
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    context.fillStyle = 'rgba(0, 0, 0, 0.6)';
    context.fillRect(0, 0, 256, 64);
    context.font = 'Bold 22px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.fillText(playerId, 128, 40);
    var texture = new THREE.CanvasTexture(canvas);
    var labelMat = new THREE.SpriteMaterial({ map: texture });
    var label = new THREE.Sprite(labelMat);
    label.scale.set(3, 0.75, 1);
    label.position.y = 2.0; // Above head
    mesh.add(label);

    playerMeshes.set(playerId, { mesh: mesh, label: label });
  }

  function movePlayer(sceneCtx, playerId, position) {
    var data = playerMeshes.get(playerId);
    if (!data) return;
    var mesh = data.mesh;

    // Store previous position before updating
    mesh.userData.prevPosition.copy(mesh.position);

    var x = position.x || 0, z = position.z || 0;
    var y = terrainHeight(x, z);
    mesh.position.set(x, y, z);

    // Calculate movement delta to determine animation state
    var dx = x - mesh.userData.prevPosition.x;
    var dz = z - mesh.userData.prevPosition.z;
    var movementDelta = Math.sqrt(dx * dx + dz * dz);

    // Determine animation state based on movement
    if (movementDelta < 0.001) {
      mesh.userData.animState = 'idle';
    } else if (movementDelta > 0.1) {
      mesh.userData.animState = 'run'; // Fast movement = running
    } else {
      mesh.userData.animState = 'walk';
    }

    // Update rotation to face movement direction
    if (movementDelta > 0.001) {
      var angle = Math.atan2(dx, dz);
      mesh.rotation.y = angle;
    }
  }

  function removePlayer(sceneCtx, playerId) {
    var data = playerMeshes.get(playerId);
    if (!data || !sceneCtx || !sceneCtx.scene) return;
    sceneCtx.scene.remove(data.mesh);
    playerMeshes.delete(playerId);
  }

  // ========================================================================
  // PLAYER ANIMATIONS
  // ========================================================================

  function updatePlayerAnimations(sceneCtx, deltaTime) {
    if (!sceneCtx) return;

    playerMeshes.forEach(function(data) {
      var mesh = data.mesh;
      var limbs = mesh.userData.limbs;
      if (!limbs) return;

      // Increment animation time
      mesh.userData.animTime += deltaTime;
      var t = mesh.userData.animTime;

      var state = mesh.userData.animState || 'idle';

      // Reset rotations to neutral positions
      limbs.leftArm.rotation.x = 0;
      limbs.rightArm.rotation.x = 0;
      limbs.leftLeg.rotation.x = 0;
      limbs.rightLeg.rotation.x = 0;
      limbs.torso.rotation.x = 0;
      limbs.torso.scale.set(1, 1, 1);
      limbs.head.rotation.x = 0;

      if (state === 'idle') {
        // IDLE ANIMATION
        // Subtle breathing - torso scales slightly on Y
        var breathe = Math.sin(t * 2) * 0.02;
        limbs.torso.scale.y = 1.0 + breathe;

        // Slight body sway
        limbs.torso.rotation.z = Math.sin(t * 1.5) * 0.02;

        // Arms hang naturally with subtle sway
        limbs.leftArm.rotation.z = Math.sin(t * 1.3) * 0.05;
        limbs.rightArm.rotation.z = -Math.sin(t * 1.3) * 0.05;

      } else if (state === 'walk') {
        // WALKING ANIMATION
        var walkSpeed = 8;
        var swingAngle = 0.5;

        // Legs swing forward/back alternately
        limbs.leftLeg.rotation.x = Math.sin(t * walkSpeed) * swingAngle;
        limbs.rightLeg.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle;

        // Arms swing opposite to legs (counter-swing)
        limbs.leftArm.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle * 0.7;
        limbs.rightArm.rotation.x = Math.sin(t * walkSpeed) * swingAngle * 0.7;

        // Feet rotate with legs
        limbs.leftFoot.rotation.x = Math.sin(t * walkSpeed) * swingAngle * 0.5;
        limbs.rightFoot.rotation.x = Math.sin(t * walkSpeed + Math.PI) * swingAngle * 0.5;

        // Body bobs slightly up/down
        var bob = Math.abs(Math.sin(t * walkSpeed)) * 0.05;
        limbs.torso.position.y = 0.9 + bob;
        limbs.head.position.y = 1.5 + bob;

        // Slight forward lean
        limbs.torso.rotation.x = 0.05;

      } else if (state === 'run') {
        // RUNNING ANIMATION
        var runSpeed = 12;
        var runSwingAngle = 0.8;

        // Legs swing with larger amplitude and faster
        limbs.leftLeg.rotation.x = Math.sin(t * runSpeed) * runSwingAngle;
        limbs.rightLeg.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle;

        // More dramatic arm swing
        limbs.leftArm.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle;
        limbs.rightArm.rotation.x = Math.sin(t * runSpeed) * runSwingAngle;

        // Feet rotate with legs
        limbs.leftFoot.rotation.x = Math.sin(t * runSpeed) * runSwingAngle * 0.5;
        limbs.rightFoot.rotation.x = Math.sin(t * runSpeed + Math.PI) * runSwingAngle * 0.5;

        // More pronounced body bob
        var runBob = Math.abs(Math.sin(t * runSpeed)) * 0.08;
        limbs.torso.position.y = 0.9 + runBob;
        limbs.head.position.y = 1.5 + runBob;

        // More body lean forward
        limbs.torso.rotation.x = 0.15;
      }
    });
  }

  // ========================================================================
  // DAY/NIGHT CYCLE
  // ========================================================================

  function updateDayNight(sceneCtx, worldTime) {
    if (!sceneCtx) return;

    // worldTime is 0-1440 (minutes in 24h cycle)
    var normalizedTime = worldTime / 1440; // 0-1

    // Sun position
    var sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2;
    if (sunMesh) {
      sunMesh.position.set(Math.cos(sunAngle) * 400, Math.sin(sunAngle) * 400, 0);
    }
    if (moonMesh) {
      moonMesh.position.set(Math.cos(sunAngle + Math.PI) * 400, Math.sin(sunAngle + Math.PI) * 400, 0);
    }

    // Stars
    if (stars && stars.material) {
      stars.material.opacity = Math.max(0, -Math.sin(sunAngle));
      stars.material.transparent = true;
    }

    // Sky color
    var skyColor, fogColor, sunIntensity;
    var t;
    if (normalizedTime < 0.25) {
      t = normalizedTime / 0.25;
      skyColor = lerpColor(0x0a0a2e, 0xff6b35, t);
      fogColor = skyColor;
      sunIntensity = t * 0.3;
    } else if (normalizedTime < 0.5) {
      t = (normalizedTime - 0.25) / 0.25;
      skyColor = lerpColor(0xff6b35, 0x87ceeb, t);
      fogColor = skyColor;
      sunIntensity = 0.3 + t * 0.7;
    } else if (normalizedTime < 0.75) {
      t = (normalizedTime - 0.5) / 0.25;
      skyColor = lerpColor(0x87ceeb, 0xff4500, t);
      fogColor = skyColor;
      sunIntensity = 1.0 - t * 0.5;
    } else {
      t = (normalizedTime - 0.75) / 0.25;
      skyColor = lerpColor(0xff4500, 0x0a0a2e, t);
      fogColor = skyColor;
      sunIntensity = 0.5 - t * 0.5;
    }

    if (skyDome && skyDome.material) skyDome.material.color.setHex(skyColor);
    if (sceneCtx.scene && sceneCtx.scene.fog) sceneCtx.scene.fog.color.setHex(fogColor);
    // Sync renderer background with fog to prevent visible horizon seam
    if (sceneCtx.renderer) sceneCtx.renderer.setClearColor(fogColor);
    if (sceneCtx.directionalLight) {
      sceneCtx.directionalLight.intensity = Math.max(0.15, sunIntensity);
      sceneCtx.directionalLight.position.set(
        Math.cos(sunAngle) * 50,
        Math.max(10, Math.sin(sunAngle) * 100),
        50
      );
    }
    if (sceneCtx.ambientLight) {
      var ambientIntensity = 0.3 + sunIntensity * 0.4;
      sceneCtx.ambientLight.intensity = ambientIntensity;
      // Tint ambient light by time of day
      var ambientColor;
      if (normalizedTime < 0.2) {
        // Night: cool blue tint
        ambientColor = 0x334466;
      } else if (normalizedTime < 0.3) {
        // Dawn: warm amber
        var dt = (normalizedTime - 0.2) / 0.1;
        ambientColor = lerpColor(0x334466, 0xffcc88, dt);
      } else if (normalizedTime < 0.7) {
        // Day: warm white
        var dt = (normalizedTime - 0.3) / 0.4;
        ambientColor = lerpColor(0xffcc88, 0xeeeedd, Math.min(dt * 2, 1.0));
      } else if (normalizedTime < 0.8) {
        // Dusk: warm orange
        var dt = (normalizedTime - 0.7) / 0.1;
        ambientColor = lerpColor(0xeeeedd, 0xff9966, dt);
      } else {
        // Evening to night: fade to blue
        var dt = (normalizedTime - 0.8) / 0.2;
        ambientColor = lerpColor(0xff9966, 0x334466, dt);
      }
      sceneCtx.ambientLight.color.setHex(ambientColor);
    }

    // Tint directional light (sunlight) color by time of day
    if (sceneCtx.directionalLight) {
      var sunColor;
      if (normalizedTime < 0.25) {
        sunColor = lerpColor(0x443355, 0xff8844, normalizedTime / 0.25);
      } else if (normalizedTime < 0.45) {
        sunColor = lerpColor(0xff8844, 0xffffff, (normalizedTime - 0.25) / 0.2);
      } else if (normalizedTime < 0.55) {
        sunColor = 0xffffff; // Bright noon
      } else if (normalizedTime < 0.75) {
        sunColor = lerpColor(0xffffff, 0xff6633, (normalizedTime - 0.55) / 0.2);
      } else {
        sunColor = lerpColor(0xff6633, 0x443355, (normalizedTime - 0.75) / 0.25);
      }
      sceneCtx.directionalLight.color.setHex(sunColor);
    }

    // Dynamic fog density by time of day
    if (sceneCtx.scene && sceneCtx.scene.fog && sceneCtx.scene.fog.density !== undefined) {
      var baseDensity = 0.0012; // Clear daytime default
      var timeFogMult = 1.0;

      if (normalizedTime < 0.2) {
        // Night: thicker fog, limited visibility
        timeFogMult = 1.8;
      } else if (normalizedTime < 0.28) {
        // Dawn: misty transition (thickest â€” morning mist)
        var dawnT = (normalizedTime - 0.2) / 0.08;
        timeFogMult = 1.8 + dawnT * 0.5; // peaks at 2.3 during dawn
      } else if (normalizedTime < 0.35) {
        // Morning: mist burning off
        var burnT = (normalizedTime - 0.28) / 0.07;
        timeFogMult = 2.3 - burnT * 1.3; // fades from 2.3 to 1.0
      } else if (normalizedTime < 0.7) {
        // Daytime: clearest visibility
        timeFogMult = 1.0;
      } else if (normalizedTime < 0.8) {
        // Dusk: golden haze
        var duskT = (normalizedTime - 0.7) / 0.1;
        timeFogMult = 1.0 + duskT * 0.5;
      } else {
        // Evening into night: fog thickens
        var nightT = (normalizedTime - 0.8) / 0.2;
        timeFogMult = 1.5 + nightT * 0.3;
      }

      // Only adjust fog if weather isn't overriding it
      if (currentWeatherType === 'clear' || !currentWeatherType) {
        sceneCtx.scene.fog.density = baseDensity * timeFogMult;
      }
    }

    // Fade zone night lights based on time of day
    var nightIntensity = 0;
    if (normalizedTime < 0.2 || normalizedTime > 0.8) {
      // Full night
      nightIntensity = 1.0;
    } else if (normalizedTime < 0.3) {
      // Dawn fade out
      nightIntensity = 1.0 - (normalizedTime - 0.2) / 0.1;
    } else if (normalizedTime > 0.7) {
      // Dusk fade in
      nightIntensity = (normalizedTime - 0.7) / 0.1;
    }
    for (var li = 0; li < zoneLights.length; li++) {
      var zl = zoneLights[li];
      zl.light.intensity = nightIntensity * 1.2;
      if (zl.glow && zl.glow.material) {
        zl.glow.material.opacity = nightIntensity * 0.8;
      }
    }
  }

  function lerpColor(c1, c2, t) {
    var r1 = (c1 >> 16) & 0xff, g1 = (c1 >> 8) & 0xff, b1 = c1 & 0xff;
    var r2 = (c2 >> 16) & 0xff, g2 = (c2 >> 8) & 0xff, b2 = c2 & 0xff;
    var r = Math.floor(r1 + (r2 - r1) * t);
    var g = Math.floor(g1 + (g2 - g1) * t);
    var b = Math.floor(b1 + (b2 - b1) * t);
    return (r << 16) | (g << 8) | b;
  }

  // ========================================================================
  // LIGHT CULLING â€” matches main.js: cullLights(ctx, position, maxDist, maxCount)
  // ========================================================================

  function cullLights(sceneCtx, playerPos, maxDistance, maxCount) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var px = playerPos.x || 0, pz = playerPos.z || 0;
    var lights = [];
    sceneCtx.scene.traverse(function(obj) {
      if (obj instanceof THREE.PointLight) {
        var dx = obj.position.x - px, dz = obj.position.z - pz;
        var dist = Math.sqrt(dx * dx + dz * dz);
        lights.push({ light: obj, dist: dist });
      }
    });
    lights.sort(function(a, b) { return a.dist - b.dist; });
    for (var i = 0; i < lights.length; i++) {
      lights[i].light.visible = (i < (maxCount || 8)) && (lights[i].dist < (maxDistance || 50));
    }
  }

  // ========================================================================
  // WEATHER
  // ========================================================================

  function updateWeather(sceneCtx, weatherType) {
    if (!sceneCtx || !sceneCtx.scene) return;
    // Call setWeather to handle visual effects and fog
    setWeather(sceneCtx, weatherType);
  }

  // ========================================================================
  // ANIMATION SYSTEM
  // ========================================================================

  function updateAnimations(sceneCtx, deltaTime, worldTime) {
    // Cloud drift
    for (var i = 0; i < clouds.length; i++) {
      var cloud = clouds[i];
      cloud.position.x += Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      cloud.position.z += Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      if (cloud.position.x > 600) cloud.position.x = -600;
      if (cloud.position.x < -600) cloud.position.x = 600;
      if (cloud.position.z > 600) cloud.position.z = -600;
      if (cloud.position.z < -600) cloud.position.z = 600;
    }

    // Animated objects
    var time = worldTime || 0;
    for (var j = 0; j < animatedObjects.length; j++) {
      var obj = animatedObjects[j];
      if (!obj.mesh || !obj.mesh.parent) continue;

      // Skip animation if object is outside frustum (set by updateFrustumCulling)
      if (obj.mesh.userData.inFrustum === false) continue;

      var p = obj.params;

      switch (obj.type) {
        case 'tree':
          var windMult = windState ? windState.strength : 1.0;
          var swayFreq = currentWeatherType === 'storm' ? 0.003 : 0.001;
          obj.mesh.rotation.z = Math.sin(time * swayFreq * p.speed + p.seed) * 0.04 * windMult;
          obj.mesh.rotation.x = Math.sin(time * swayFreq * 0.8 * p.speed + p.seed * 1.5) * 0.02 * windMult;
          break;
        case 'crystal':
          obj.mesh.rotation.y += deltaTime * (p.speed || 0.3);
          if (p.baseY !== undefined) {
            obj.mesh.position.y = p.baseY + Math.sin(time * 0.002) * 0.3;
          }
          break;
        case 'portal':
          obj.mesh.rotation.z += deltaTime * (p.speed || 0.5);
          if (p.inner) {
            p.inner.material.opacity = 0.25 + Math.sin(time * 0.003) * 0.15;
          }
          // Animate particle rings
          if (p.particleRings) {
            for (var ri = 0; ri < p.particleRings.length; ri++) {
              var ring = p.particleRings[ri];
              for (var pi = 0; pi < ring.particles.length; pi++) {
                var pData = ring.particles[pi];
                pData.angle += ring.speed * ring.direction * deltaTime;
                var px = p.centerX + Math.cos(pData.angle) * pData.radius;
                var pz = p.centerZ + Math.sin(pData.angle) * pData.radius;
                pData.mesh.position.set(px, p.centerY, pz);
              }
            }
          }
          break;
        case 'torch':
          var flicker = 0.7 + Math.sin(time * 0.01 + (p.seed || 0)) * 0.15 + Math.sin(time * 0.023 + (p.seed || 0) * 2) * 0.15;
          obj.mesh.scale.set(flicker, 0.8 + flicker * 0.4, flicker);
          if (p.light) {
            var torchBase = 0.5 + flicker * 0.5;
            // Boost torch brightness at night (worldTime passed as 3rd arg)
            var wt = (typeof worldTime === 'number') ? worldTime : 720;
            var nt = wt / 1440;
            var nightBoost = (nt < 0.2 || nt > 0.8) ? 1.5 : (nt < 0.3 ? (1.0 + 0.5 * (1.0 - (nt - 0.2) / 0.1)) : (nt > 0.7 ? (1.0 + 0.5 * ((nt - 0.7) / 0.1)) : 1.0));
            p.light.intensity = torchBase * nightBoost;
          }
          break;
        case 'water':
          obj.mesh.rotation.y += deltaTime * 0.05;
          break;
        case 'creature':
          // Delegate to Models.animateModel if available
          var Models = typeof window !== 'undefined' ? window.Models : null;
          if (Models && Models.animateModel) {
            Models.animateModel(obj.mesh, deltaTime, time);
          } else {
            // Fallback: simple bobbing motion
            obj.mesh.position.y += Math.sin(time * 0.003 * (p.speed || 1)) * 0.01;
            obj.mesh.rotation.y += deltaTime * (p.speed || 0.5);
          }
          break;
        case 'landmark':
          if (Models && Models.animateModel) {
            Models.animateModel(obj.mesh, deltaTime, time);
          }
          // Rift Portal shimmer animation
          if (p.shimmer && p.shimmer.material) {
            p.shimmer.material.opacity = 0.15 + Math.sin(time * 0.002) * 0.1;
          }
          break;
      }
    }
  }

  // ========================================================================
  // COLLISION / PHYSICS HELPERS
  // ========================================================================

  // Simple terrain-following: returns height at any world position
  // Used by main.js and npcs.js
  // Also provides basic collision checking for future use
  function checkCollision(x, z, radius) {
    // Check against placed structures only (not zone centers, which are walkable)
    if (placedStructures) {
      for (var i = 0; i < placedStructures.length; i++) {
        var s = placedStructures[i];
        if (!s || !s.position) continue;
        var dx = x - s.position.x, dz = z - s.position.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        var structRadius = s.collisionRadius || 1.5;
        if (dist < structRadius + radius) {
          return true;
        }
      }
    }
    return false;
  }

  // ========================================================================
  // PLACED STRUCTURES (for collision)
  // ========================================================================

  var placedStructures = [];

  // ========================================================================
  // PARTICLE SYSTEM
  // ========================================================================

  var particleSystems = null;
  var MAX_PARTICLES = 500;
  var PARTICLE_CULL_DISTANCE = 100;

  // Particle pool and emitter definitions
  function ParticleSystem() {
    this.particles = [];
    this.positions = new Float32Array(MAX_PARTICLES * 3);
    this.colors = new Float32Array(MAX_PARTICLES * 3);
    this.sizes = new Float32Array(MAX_PARTICLES);
    this.activeCount = 0;

    // Particle data
    for (var i = 0; i < MAX_PARTICLES; i++) {
      this.particles.push({
        active: false,
        position: { x: 0, y: 0, z: 0 },
        velocity: { x: 0, y: 0, z: 0 },
        life: 0,
        maxLife: 1,
        color: { r: 1, g: 1, b: 1 },
        size: 1,
        opacity: 1,
        emitterType: null
      });
    }

    // Create geometry
    this.geometry = new THREE.BufferGeometry();
    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
    this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
    this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

    // Create material with texture support
    this.material = new THREE.PointsMaterial({
      size: 0.5,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    // Generate procedural particle texture (soft circle)
    var particleCanvas = document.createElement('canvas');
    particleCanvas.width = 32;
    particleCanvas.height = 32;
    var pctx = particleCanvas.getContext('2d');
    var gradient = pctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    pctx.fillStyle = gradient;
    pctx.fillRect(0, 0, 32, 32);
    var particleTex = new THREE.CanvasTexture(particleCanvas);
    this.material.map = particleTex;

    // Create Points mesh
    this.points = new THREE.Points(this.geometry, this.material);
    this.points.frustumCulled = false;

    // Emitters
    this.emitters = [];
  }

  ParticleSystem.prototype.addEmitter = function(type, position, config) {
    this.emitters.push({
      type: type,
      position: position,
      config: config || {},
      timer: 0,
      active: true
    });
  };

  ParticleSystem.prototype.removeEmitter = function(index) {
    if (index >= 0 && index < this.emitters.length) {
      this.emitters.splice(index, 1);
    }
  };

  ParticleSystem.prototype.emitParticle = function(type, position, count) {
    count = count || 1;
    for (var i = 0; i < count; i++) {
      this._spawnParticle(type, position);
    }
  };

  ParticleSystem.prototype._spawnParticle = function(type, position) {
    // Find dead particle to reuse
    var particle = null;
    for (var i = 0; i < MAX_PARTICLES; i++) {
      if (!this.particles[i].active) {
        particle = this.particles[i];
        break;
      }
    }
    if (!particle) return; // Pool full

    particle.active = true;
    particle.position.x = position.x;
    particle.position.y = position.y;
    particle.position.z = position.z;
    particle.emitterType = type;

    // Configure particle based on type
    switch (type) {
      case 'fire':
        particle.maxLife = 1.0 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.5;
        particle.velocity.y = 1.5 + Math.random() * 1.0;
        particle.velocity.z = (Math.random() - 0.5) * 0.5;
        particle.color.r = 1.0;
        particle.color.g = 0.4 + Math.random() * 0.3;
        particle.color.b = 0.0;
        particle.size = 0.3 + Math.random() * 0.3;
        particle.opacity = 1.0;
        break;

      case 'sparkle':
        particle.maxLife = 1.5 + Math.random() * 1.0;
        particle.life = particle.maxLife;
        var angle = Math.random() * Math.PI * 2;
        var radius = 2.0;
        particle.velocity.x = Math.cos(angle) * radius;
        particle.velocity.y = (Math.random() - 0.5) * 0.3;
        particle.velocity.z = Math.sin(angle) * radius;
        particle.color.r = 0.0;
        particle.color.g = 0.8 + Math.random() * 0.2;
        particle.color.b = 1.0;
        particle.size = 0.2 + Math.random() * 0.2;
        particle.opacity = 1.0;
        break;

      case 'dust':
        particle.maxLife = 0.5 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 1.0;
        particle.velocity.y = 0.3 + Math.random() * 0.5;
        particle.velocity.z = (Math.random() - 0.5) * 1.0;
        particle.color.r = 0.6;
        particle.color.g = 0.5;
        particle.color.b = 0.4;
        particle.size = 0.1 + Math.random() * 0.15;
        particle.opacity = 0.6;
        break;

      case 'leaf':
        particle.maxLife = 3.0 + Math.random() * 2.0;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.5;
        particle.velocity.y = -0.3 - Math.random() * 0.2;
        particle.velocity.z = (Math.random() - 0.5) * 0.5;
        particle.color.r = 0.2 + Math.random() * 0.3;
        particle.color.g = 0.6 + Math.random() * 0.3;
        particle.color.b = 0.1;
        particle.size = 0.2 + Math.random() * 0.2;
        particle.opacity = 0.8;
        break;

      case 'mist':
        particle.maxLife = 2.0 + Math.random() * 2.0;
        particle.life = particle.maxLife;
        particle.velocity.x = (Math.random() - 0.5) * 0.2;
        particle.velocity.y = 0.05 + Math.random() * 0.1;
        particle.velocity.z = (Math.random() - 0.5) * 0.2;
        particle.color.r = 0.8;
        particle.color.g = 0.85;
        particle.color.b = 0.9;
        particle.size = 0.8 + Math.random() * 0.6;
        particle.opacity = 0.3;
        break;

      case 'fountain':
        particle.maxLife = 1.5 + Math.random() * 0.5;
        particle.life = particle.maxLife;
        var fAngle = Math.random() * Math.PI * 2;
        var fSpeed = 1.0 + Math.random() * 1.5;
        particle.velocity.x = Math.cos(fAngle) * fSpeed * 0.5;
        particle.velocity.y = 3.0 + Math.random() * 1.5;
        particle.velocity.z = Math.sin(fAngle) * fSpeed * 0.5;
        particle.color.r = 0.2;
        particle.color.g = 0.5 + Math.random() * 0.3;
        particle.color.b = 0.8 + Math.random() * 0.2;
        particle.size = 0.15 + Math.random() * 0.15;
        particle.opacity = 0.7;
        break;

      default:
        particle.active = false;
        return;
    }
  };

  ParticleSystem.prototype.update = function(deltaTime, playerPos) {
    var dt = deltaTime * 0.001; // Convert to seconds
    var px = playerPos ? playerPos.x : 0;
    var pz = playerPos ? playerPos.z : 0;

    // Update emitters
    for (var e = 0; e < this.emitters.length; e++) {
      var emitter = this.emitters[e];
      if (!emitter.active) continue;

      emitter.timer += deltaTime;

      // Emit particles based on type
      var emitRate = 50; // ms per particle
      switch (emitter.type) {
        case 'fire': emitRate = 80; break;
        case 'sparkle': emitRate = 100; break;
        case 'dust': emitRate = 150; break;
        case 'leaf': emitRate = 200; break;
        case 'mist': emitRate = 120; break;
        case 'fountain': emitRate = 60; break;
      }

      while (emitter.timer >= emitRate) {
        emitter.timer -= emitRate;
        this._spawnParticle(emitter.type, emitter.position);
      }
    }

    // Update particles
    this.activeCount = 0;
    for (var i = 0; i < MAX_PARTICLES; i++) {
      var p = this.particles[i];
      if (!p.active) continue;

      // Update life
      p.life -= dt;
      if (p.life <= 0) {
        p.active = false;
        continue;
      }

      // Distance culling
      var dx = p.position.x - px;
      var dz = p.position.z - pz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist > PARTICLE_CULL_DISTANCE) {
        p.active = false;
        continue;
      }

      // Update physics
      p.position.x += p.velocity.x * dt;
      p.position.y += p.velocity.y * dt;
      p.position.z += p.velocity.z * dt;

      // Apply gravity (except for sparkle and mist)
      if (p.emitterType !== 'sparkle' && p.emitterType !== 'mist') {
        p.velocity.y -= 2.0 * dt;
      }

      // Type-specific updates
      if (p.emitterType === 'sparkle') {
        // Circular motion around origin
        var angle = Math.atan2(p.velocity.z, p.velocity.x);
        angle += dt * 2.0;
        var speed = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.z * p.velocity.z);
        p.velocity.x = Math.cos(angle) * speed;
        p.velocity.z = Math.sin(angle) * speed;
      } else if (p.emitterType === 'leaf') {
        // Swaying motion
        p.velocity.x += Math.sin(p.life * 3.0) * dt * 0.5;
        p.velocity.z += Math.cos(p.life * 2.5) * dt * 0.5;
      } else if (p.emitterType === 'mist') {
        // Slow drift
        p.velocity.x *= 0.98;
        p.velocity.z *= 0.98;
      }

      // Friction
      p.velocity.x *= 0.99;
      p.velocity.z *= 0.99;

      // Fade out
      var lifeRatio = p.life / p.maxLife;
      p.opacity = Math.min(1.0, lifeRatio * 2.0);

      // Update buffer
      var idx = this.activeCount * 3;
      this.positions[idx] = p.position.x;
      this.positions[idx + 1] = p.position.y;
      this.positions[idx + 2] = p.position.z;

      this.colors[idx] = p.color.r * p.opacity;
      this.colors[idx + 1] = p.color.g * p.opacity;
      this.colors[idx + 2] = p.color.b * p.opacity;

      this.sizes[this.activeCount] = p.size;

      this.activeCount++;
    }

    // Update geometry
    this.geometry.setDrawRange(0, this.activeCount);
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
  };

  // Public API functions
  function initParticles(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    particleSystems = new ParticleSystem();
    sceneCtx.scene.add(particleSystems.points);

    // Add default emitters at key locations
    // Fire at arena torches (12 torches around arena)
    var arenaZ = ZONES.arena;
    for (var ti = 0; ti < 12; ti++) {
      var tAngle = (ti / 12) * Math.PI * 2;
      var tpx = arenaZ.cx + Math.cos(tAngle) * 20;
      var tpz = arenaZ.cz + Math.sin(tAngle) * 20;
      particleSystems.addEmitter('fire', { x: tpx, y: arenaZ.baseHeight + 2.7, z: tpz });
    }

    // Sparkle at portals
    for (var zId in ZONES) {
      if (zId === 'nexus') continue;
      var zone = ZONES[zId];
      var dx = ZONES.nexus.cx - zone.cx;
      var dz = ZONES.nexus.cz - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      var nx = dx / dist, nz = dz / dist;
      var portalX = zone.cx + nx * zone.radius * 0.7;
      var portalZ = zone.cz + nz * zone.radius * 0.7;
      var portalY = terrainHeight(portalX, portalZ);
      particleSystems.addEmitter('sparkle', { x: portalX, y: portalY + 3, z: portalZ });
    }

    // Fountain at gardens
    var gardensZ = ZONES.gardens;
    particleSystems.addEmitter('fountain', { x: gardensZ.cx, y: gardensZ.baseHeight + 1.5, z: gardensZ.cz });

    // Mist in wilds
    var wildsZ = ZONES.wilds;
    for (var mi = 0; mi < 3; mi++) {
      var mAngle = (mi / 3) * Math.PI * 2;
      var mx = wildsZ.cx + Math.cos(mAngle) * 10;
      var mz = wildsZ.cz + Math.sin(mAngle) * 10;
      particleSystems.addEmitter('mist', { x: mx, y: wildsZ.baseHeight + 0.5, z: mz });
    }

    // Leaves in gardens and wilds
    var leafZones = [ZONES.gardens, ZONES.wilds];
    for (var lzi = 0; lzi < leafZones.length; lzi++) {
      var lz = leafZones[lzi];
      for (var li = 0; li < 4; li++) {
        var lAngle = (li / 4) * Math.PI * 2;
        var lx = lz.cx + Math.cos(lAngle) * 15;
        var lzp = lz.cz + Math.sin(lAngle) * 15;
        particleSystems.addEmitter('leaf', { x: lx, y: lz.baseHeight + 8, z: lzp });
      }
    }
  }

  function updateParticles(sceneCtx, deltaTime, playerPos) {
    if (!particleSystems) return;
    particleSystems.update(deltaTime, playerPos);
  }

  function emitParticles(type, position, count) {
    if (!particleSystems) return;
    particleSystems.emitParticle(type, position, count || 1);
  }

  // ========================================================================
  // WEATHER EFFECTS SYSTEM
  // ========================================================================

  var weatherParticles = null; // Current active weather particle system
  var currentWeatherType = 'clear';
  var lightningTimer = 0;
  var lightningActive = false;
  var lightningLight = null;
  var weatherCallbacks = {}; // { onLightningStrike: function(x,z) }

  function setWeather(sceneCtx, type) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Remove existing weather particles
    if (weatherParticles) {
      sceneCtx.scene.remove(weatherParticles);
      if (weatherParticles.geometry) weatherParticles.geometry.dispose();
      if (weatherParticles.material) weatherParticles.material.dispose();
      weatherParticles = null;
    }

    currentWeatherType = type;

    // Update fog based on weather
    if (sceneCtx.scene.fog && sceneCtx.scene.fog.density !== undefined) {
      switch (type) {
        case 'storm':
          sceneCtx.scene.fog.density = 0.0030;
          break;
        case 'rain':
          sceneCtx.scene.fog.density = 0.0022;
          break;
        case 'snow':
          sceneCtx.scene.fog.density = 0.0018;
          break;
        case 'cloudy':
          sceneCtx.scene.fog.density = 0.0015;
          break;
        default:
          sceneCtx.scene.fog.density = 0.0012;
      }
    }

    // Create particle system based on type
    if (type === 'rain') {
      var rainCount = 2000;
      var rainGeo = new THREE.BufferGeometry();
      var rainPositions = new Float32Array(rainCount * 3);
      var rainVelocities = new Float32Array(rainCount * 3);

      // Initialize rain particles in a box around origin
      for (var i = 0; i < rainCount; i++) {
        var idx = i * 3;
        rainPositions[idx] = (Math.random() - 0.5) * 100;     // x
        rainPositions[idx + 1] = Math.random() * 80 + 20;      // y
        rainPositions[idx + 2] = (Math.random() - 0.5) * 100; // z

        // Velocities: fast downward with gentle drift
        rainVelocities[idx] = (Math.random() - 0.5) * 0.5;     // x drift
        rainVelocities[idx + 1] = -0.8 - Math.random() * 0.4;  // y fall speed
        rainVelocities[idx + 2] = (Math.random() - 0.5) * 0.5; // z drift
      }

      rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
      rainGeo.userData.velocities = rainVelocities;

      var rainMat = new THREE.PointsMaterial({
        color: 0xaaccff,
        size: 0.15,
        transparent: true,
        opacity: 0.6,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(rainGeo, rainMat);
      weatherParticles.userData.type = 'rain';
      sceneCtx.scene.add(weatherParticles);

    } else if (type === 'snow') {
      var snowCount = 1000;
      var snowGeo = new THREE.BufferGeometry();
      var snowPositions = new Float32Array(snowCount * 3);
      var snowVelocities = new Float32Array(snowCount * 3);
      var snowPhases = new Float32Array(snowCount); // For sine-wave movement

      // Initialize snow particles
      for (var j = 0; j < snowCount; j++) {
        var jdx = j * 3;
        snowPositions[jdx] = (Math.random() - 0.5) * 120;     // x
        snowPositions[jdx + 1] = Math.random() * 100 + 20;    // y
        snowPositions[jdx + 2] = (Math.random() - 0.5) * 120; // z

        // Velocities: slow downward
        snowVelocities[jdx] = 0;                              // x (handled by sine wave)
        snowVelocities[jdx + 1] = -0.15 - Math.random() * 0.1; // y fall speed
        snowVelocities[jdx + 2] = 0;                          // z (handled by sine wave)

        snowPhases[j] = Math.random() * Math.PI * 2;
      }

      snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
      snowGeo.userData.velocities = snowVelocities;
      snowGeo.userData.phases = snowPhases;

      var snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.25,
        transparent: true,
        opacity: 0.8,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(snowGeo, snowMat);
      weatherParticles.userData.type = 'snow';
      sceneCtx.scene.add(weatherParticles);

    } else if (type === 'storm') {
      // Storm: heavy rain + darker + lightning
      var stormCount = 3500;
      var stormGeo = new THREE.BufferGeometry();
      var stormPositions = new Float32Array(stormCount * 3);
      var stormVelocities = new Float32Array(stormCount * 3);

      for (var s = 0; s < stormCount; s++) {
        var sidx = s * 3;
        stormPositions[sidx] = (Math.random() - 0.5) * 120;
        stormPositions[sidx + 1] = Math.random() * 80 + 20;
        stormPositions[sidx + 2] = (Math.random() - 0.5) * 120;

        stormVelocities[sidx] = (Math.random() - 0.5) * 1.5;       // stronger wind
        stormVelocities[sidx + 1] = -1.2 - Math.random() * 0.6;    // faster rain
        stormVelocities[sidx + 2] = (Math.random() - 0.5) * 1.5;
      }

      stormGeo.setAttribute('position', new THREE.Float32BufferAttribute(stormPositions, 3));
      stormGeo.userData.velocities = stormVelocities;

      var stormMat = new THREE.PointsMaterial({
        color: 0x8899bb,
        size: 0.18,
        transparent: true,
        opacity: 0.7,
        depthWrite: false
      });

      weatherParticles = new THREE.Points(stormGeo, stormMat);
      weatherParticles.userData.type = 'rain'; // reuse rain update logic
      sceneCtx.scene.add(weatherParticles);

      // Create lightning light (initially off)
      if (!lightningLight) {
        lightningLight = new THREE.PointLight(0xeeeeff, 0, 200);
        lightningLight.position.set(0, 50, 0);
        sceneCtx.scene.add(lightningLight);
      }
      lightningTimer = 0;
      lightningActive = false;

      // Darken ambient for storm
      if (sceneCtx.ambientLight) {
        sceneCtx.ambientLight.intensity = Math.max(0.15, sceneCtx.ambientLight.intensity * 0.6);
      }

    } else if (type === 'cloudy') {
      // Cloudy: dim the lights slightly
      if (sceneCtx.ambientLight) {
        sceneCtx.ambientLight.intensity = Math.max(0.25, sceneCtx.ambientLight.intensity * 0.8);
      }
      if (sceneCtx.directionalLight) {
        sceneCtx.directionalLight.intensity = Math.max(0.2, sceneCtx.directionalLight.intensity * 0.7);
      }
    } else {
      // Clear: remove lightning light if it exists
      if (lightningLight && sceneCtx.scene) {
        sceneCtx.scene.remove(lightningLight);
        lightningLight = null;
      }
    }
  }

  function updateWeatherEffects(sceneCtx, deltaTime, cameraPos) {
    if (!weatherParticles || !weatherParticles.geometry) return;

    var positions = weatherParticles.geometry.attributes.position.array;
    var velocities = weatherParticles.geometry.userData.velocities;
    var type = weatherParticles.userData.type;

    var camX = cameraPos.x || 0;
    var camY = cameraPos.y || 0;
    var camZ = cameraPos.z || 0;

    if (type === 'rain') {
      // Update rain particles
      for (var i = 0; i < positions.length / 3; i++) {
        var idx = i * 3;

        // Update position based on velocity
        positions[idx] += velocities[idx] * deltaTime;
        positions[idx + 1] += velocities[idx + 1] * deltaTime;
        positions[idx + 2] += velocities[idx + 2] * deltaTime;

        // Get ground height at particle position
        var groundHeight = terrainHeight(positions[idx], positions[idx + 2]);

        // Recycle particle if it hits the ground
        if (positions[idx + 1] < groundHeight) {
          // Respawn near camera
          positions[idx] = camX + (Math.random() - 0.5) * 100;
          positions[idx + 1] = camY + Math.random() * 40 + 20;
          positions[idx + 2] = camZ + (Math.random() - 0.5) * 100;

          // Randomize drift slightly
          velocities[idx] = (Math.random() - 0.5) * 0.5;
          velocities[idx + 2] = (Math.random() - 0.5) * 0.5;
        }

        // Keep particles centered around camera
        var dx = positions[idx] - camX;
        var dz = positions[idx + 2] - camZ;
        if (Math.abs(dx) > 60 || Math.abs(dz) > 60) {
          positions[idx] = camX + (Math.random() - 0.5) * 100;
          positions[idx + 1] = camY + Math.random() * 40 + 20;
          positions[idx + 2] = camZ + (Math.random() - 0.5) * 100;
        }
      }

    } else if (type === 'snow') {
      var phases = weatherParticles.geometry.userData.phases;
      var time = Date.now() * 0.001;

      // Update snow particles
      for (var j = 0; j < positions.length / 3; j++) {
        var jdx = j * 3;

        // Sine wave horizontal movement
        var sineX = Math.sin(time * 0.5 + phases[j]) * 0.3;
        var sineZ = Math.cos(time * 0.5 + phases[j] * 1.3) * 0.3;

        positions[jdx] += (velocities[jdx] + sineX) * deltaTime;
        positions[jdx + 1] += velocities[jdx + 1] * deltaTime;
        positions[jdx + 2] += (velocities[jdx + 2] + sineZ) * deltaTime;

        // Get ground height at particle position
        var snowGroundHeight = terrainHeight(positions[jdx], positions[jdx + 2]);

        // Recycle particle if it hits the ground
        if (positions[jdx + 1] < snowGroundHeight) {
          positions[jdx] = camX + (Math.random() - 0.5) * 120;
          positions[jdx + 1] = camY + Math.random() * 50 + 30;
          positions[jdx + 2] = camZ + (Math.random() - 0.5) * 120;
          phases[j] = Math.random() * Math.PI * 2;
        }

        // Keep particles centered around camera
        var sdx = positions[jdx] - camX;
        var sdz = positions[jdx + 2] - camZ;
        if (Math.abs(sdx) > 70 || Math.abs(sdz) > 70) {
          positions[jdx] = camX + (Math.random() - 0.5) * 120;
          positions[jdx + 1] = camY + Math.random() * 50 + 30;
          positions[jdx + 2] = camZ + (Math.random() - 0.5) * 120;
        }
      }
    }

    weatherParticles.geometry.attributes.position.needsUpdate = true;

    // Rain splash spawning â€” when rain particles hit ground
    if (type === 'rain' && splashPool.length > 0) {
      for (var si = 0; si < positions.length / 3; si += 10) { // sample every 10th
        var sidx = si * 3;
        var groundH = terrainHeight(positions[sidx], positions[sidx + 2]);
        if (positions[sidx + 1] < groundH + 0.5 && positions[sidx + 1] > groundH - 1) {
          spawnSplash(positions[sidx], groundH, positions[sidx + 2]);
        }
      }
    }

    // Lightning flash logic for storms
    if (lightningLight && weatherParticles.userData.type === 'rain') {
      lightningTimer += deltaTime;

      if (lightningActive) {
        // Flash is happening â€” fade out over 150ms
        lightningLight.intensity *= 0.85;

        // Flash ambient intensity
        if (sceneCtx && sceneCtx.ambientLight && lightningLight.intensity > 1.0) {
          sceneCtx.ambientLight.intensity = Math.min(2.0, lightningLight.intensity * 0.5);
        }

        if (lightningLight.intensity < 0.05) {
          lightningLight.intensity = 0;
          lightningActive = false;
          lightningTimer = 0;
          // Restore ambient
          if (sceneCtx && sceneCtx.ambientLight) {
            sceneCtx.ambientLight.intensity = 0.15;
          }
        }
      } else {
        // Wait for next flash (random interval 3-8 seconds)
        var flashInterval = 3000 + Math.random() * 5000;
        if (lightningTimer > flashInterval) {
          // Trigger lightning flash
          lightningActive = true;
          lightningLight.intensity = 2.5 + Math.random() * 1.5;
          var boltX = (cameraPos.x || 0) + (Math.random() - 0.5) * 80;
          var boltZ = (cameraPos.z || 0) + (Math.random() - 0.5) * 80;
          lightningLight.position.set(boltX, 45 + Math.random() * 15, boltZ);
          lightningTimer = 0;

          // Create visible bolt
          createLightningBolt(sceneCtx, boltX, boltZ);

          // Trigger camera shake via callback
          if (weatherCallbacks.onLightningStrike) {
            weatherCallbacks.onLightningStrike(boltX, boltZ);
          }
        }
      }
    }

    // Update lightning bolt visibility
    updateLightningBolt(sceneCtx, deltaTime);

    // Update rain splashes
    updateRainSplashes(deltaTime);
  }

  function getCurrentWeather() {
    return currentWeatherType;
  }

  // ========================================================================
  // WATER SYSTEM â€” Animated water bodies for zones
  // ========================================================================

  var waterBodies = [];
  var waterTime = 0;
  var waterWeatherMultiplier = 1.0; // Modified by weather conditions

  function initWater(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var scene = sceneCtx.scene;

    // Clear any existing water bodies
    for (var i = 0; i < waterBodies.length; i++) {
      scene.remove(waterBodies[i].mesh);
      if (waterBodies[i].foamRing) scene.remove(waterBodies[i].foamRing);
      if (waterBodies[i].geometry) waterBodies[i].geometry.dispose();
      if (waterBodies[i].material) waterBodies[i].material.dispose();
    }
    waterBodies = [];

    // Gardens: Central pond/lake (~30 unit radius) - peaceful, clear water
    var gardensPond = createWaterBody({
      type: 'circle',
      centerX: ZONES.gardens.cx,
      centerZ: ZONES.gardens.cz,
      radius: 30,
      height: ZONES.gardens.baseHeight + 0.3,
      segments: 64,
      waveSpeed: 0.8,
      waveHeight: 0.2,
      waveFrequency: 0.3,
      color: 0x3388cc,
      emissive: 0x113355
    });
    scene.add(gardensPond.mesh);
    if (gardensPond.foamRing) scene.add(gardensPond.foamRing);
    waterBodies.push(gardensPond);

    // Wilds: Flowing river (~10 unit wide, winding through zone)
    // Create river as a series of connected segments
    var riverSegments = createRiverPath(ZONES.wilds.cx, ZONES.wilds.cz, ZONES.wilds.radius);
    for (var j = 0; j < riverSegments.length; j++) {
      var riverSegment = createWaterBody({
        type: 'river',
        centerX: riverSegments[j].x,
        centerZ: riverSegments[j].z,
        width: 10,
        length: riverSegments[j].length,
        rotation: riverSegments[j].rotation,
        height: ZONES.wilds.baseHeight + 0.2,
        segments: 64,
        waveSpeed: 1.2,
        waveHeight: 0.25,
        waveFrequency: 0.5,
        flowDirection: riverSegments[j].direction,
        color: 0x2277bb,
        emissive: 0x0f2844
      });
      scene.add(riverSegment.mesh);
      waterBodies.push(riverSegment);
    }

    // Nexus: Decorative fountain pool (~8 unit radius) - magical, glowing water
    var nexusFountain = createWaterBody({
      type: 'circle',
      centerX: ZONES.nexus.cx,
      centerZ: ZONES.nexus.cz,
      radius: 8,
      height: ZONES.nexus.baseHeight + 0.5,
      segments: 64,
      waveSpeed: 1.5,
      waveHeight: 0.15,
      waveFrequency: 0.8,
      color: 0x4499dd,
      emissive: 0x225588
    });
    scene.add(nexusFountain.mesh);
    if (nexusFountain.foamRing) scene.add(nexusFountain.foamRing);
    waterBodies.push(nexusFountain);
  }

  function createWaterBody(config) {
    var geometry, material, mesh;
    var segments = config.segments || 64;

    // Create geometry based on type
    if (config.type === 'circle') {
      geometry = new THREE.PlaneGeometry(config.radius * 2, config.radius * 2, segments, segments);
    } else if (config.type === 'river') {
      geometry = new THREE.PlaneGeometry(config.length, config.width, segments, segments);
    }

    // Rotate to be horizontal
    geometry.rotateX(-Math.PI / 2);

    // Position the geometry
    geometry.translate(config.centerX, config.height, config.centerZ);

    // Apply rotation for river segments
    if (config.rotation) {
      var tempGeom = new THREE.PlaneGeometry(config.length, config.width, segments, segments);
      tempGeom.rotateX(-Math.PI / 2);
      tempGeom.rotateY(config.rotation);
      tempGeom.translate(config.centerX, config.height, config.centerZ);
      geometry = tempGeom;
    }

    // Store initial vertex positions for animation
    var positions = geometry.attributes.position.array;
    var initialPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
      initialPositions[i] = positions[i];
    }

    // Create water material with enhanced visual properties
    var waterColor = config.color || 0x2266aa;
    var emissiveColor = config.emissive || 0x112244;

    material = new THREE.MeshPhongMaterial({
      color: waterColor,
      transparent: true,
      opacity: 0.65,
      side: THREE.DoubleSide,
      shininess: 100,
      specular: 0xaaddff,
      emissive: emissiveColor,
      emissiveIntensity: 0.15,
      reflectivity: 0.8
    });

    mesh = new THREE.Mesh(geometry, material);
    mesh.receiveShadow = false;
    mesh.castShadow = false;

    // Add shoreline foam ring for circular water bodies
    var foamRing = null;
    if (config.type === 'circle' && config.radius) {
      var foamInner = config.radius - 1.5;
      var foamOuter = config.radius + 0.5;
      var foamGeom = new THREE.RingBufferGeometry(foamInner, foamOuter, 32);
      foamGeom.rotateX(-Math.PI / 2);
      var foamMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      foamRing = new THREE.Mesh(foamGeom, foamMat);
      foamRing.position.set(config.centerX, config.height + 0.02, config.centerZ);
      mesh.parent ? mesh.parent.add(foamRing) : null;
    }

    // Store config and initial positions for animation
    return {
      mesh: mesh,
      geometry: geometry,
      material: material,
      initialPositions: initialPositions,
      config: config,
      foamRing: foamRing
    };
  }

  function createRiverPath(centerX, centerZ, zoneRadius) {
    // Create a winding river path through the Wilds zone
    var segments = [];
    var segmentLength = 25;
    var numSegments = 6;

    // Start from northwest side of zone
    var startX = centerX - zoneRadius * 0.6;
    var startZ = centerZ - zoneRadius * 0.7;

    // Create winding path
    var currentX = startX;
    var currentZ = startZ;
    var currentAngle = Math.PI * 0.3; // Initial direction (southeast)

    for (var i = 0; i < numSegments; i++) {
      // Calculate segment endpoint
      var nextX = currentX + Math.cos(currentAngle) * segmentLength;
      var nextZ = currentZ + Math.sin(currentAngle) * segmentLength;

      // Segment center point
      var segX = (currentX + nextX) / 2;
      var segZ = (currentZ + nextZ) / 2;

      segments.push({
        x: segX,
        z: segZ,
        length: segmentLength,
        rotation: currentAngle,
        direction: { x: Math.cos(currentAngle), z: Math.sin(currentAngle) }
      });

      // Update position and add some curve variation
      currentX = nextX;
      currentZ = nextZ;
      currentAngle += (Math.random() - 0.5) * 0.6; // Random curve
    }

    return segments;
  }

  function updateWater(deltaTime, weatherType) {
    if (!waterBodies || waterBodies.length === 0) return;

    waterTime += deltaTime;

    // Adjust water animation based on weather conditions
    var targetMultiplier = 1.0;
    if (weatherType === 'storm') {
      targetMultiplier = 2.5; // Much choppier waves during storms
    } else if (weatherType === 'rain') {
      targetMultiplier = 1.6; // Moderately rough during rain
    } else if (weatherType === 'snow') {
      targetMultiplier = 0.5; // Calmer, colder water
    }

    // Smoothly interpolate to target multiplier
    waterWeatherMultiplier += (targetMultiplier - waterWeatherMultiplier) * deltaTime * 0.5;

    for (var i = 0; i < waterBodies.length; i++) {
      var water = waterBodies[i];
      if (!water || !water.geometry || !water.initialPositions) continue;

      var positions = water.geometry.attributes.position.array;
      var initialPos = water.initialPositions;
      var config = water.config;

      var baseWaveSpeed = config.waveSpeed || 1.0;
      var baseWaveHeight = config.waveHeight || 0.2;
      var waveFrequency = config.waveFrequency || 0.5;

      // Apply weather multiplier to wave parameters
      var waveSpeed = baseWaveSpeed * waterWeatherMultiplier;
      var waveHeight = baseWaveHeight * waterWeatherMultiplier;

      // Animate vertices with sine waves
      for (var j = 0; j < positions.length; j += 3) {
        var x = initialPos[j];
        var y = initialPos[j + 1];
        var z = initialPos[j + 2];

        // Calculate distance from center for circular water bodies
        var distFromCenter = 0;
        if (config.type === 'circle') {
          var dx = x - config.centerX;
          var dz = z - config.centerZ;
          distFromCenter = Math.sqrt(dx * dx + dz * dz);

          // Multi-layered wave system for more realistic water
          // Primary radial ripples from center
          var ripple = Math.sin(distFromCenter * waveFrequency - waterTime * waveSpeed) * waveHeight;

          // Secondary angular wave pattern
          var angle = Math.atan2(dz, dx);
          var secondaryWave = Math.sin(angle * 3 + waterTime * waveSpeed * 0.5) * waveHeight * 0.3;

          // Tertiary detail waves for visual complexity
          var detailWave = Math.sin(x * 0.4 + waterTime * waveSpeed * 1.2) * waveHeight * 0.2 +
                           Math.sin(z * 0.3 + waterTime * waveSpeed * 0.9) * waveHeight * 0.2;

          // Random chop for storms
          var chopWave = 0;
          if (waterWeatherMultiplier > 1.5) {
            chopWave = Math.sin(x * 0.8 + z * 0.7 + waterTime * waveSpeed * 2.0) * waveHeight * 0.25;
          }

          positions[j + 1] = y + ripple + secondaryWave + detailWave + chopWave;

          // Fade ripples near edge for natural boundary
          if (distFromCenter > config.radius * 0.8) {
            var fadeRatio = 1 - (distFromCenter - config.radius * 0.8) / (config.radius * 0.2);
            positions[j + 1] = y + (ripple + secondaryWave + detailWave + chopWave) * Math.max(0, fadeRatio);
          }
        } else if (config.type === 'river') {
          // Flowing river animation with directional waves
          var flowDir = config.flowDirection || { x: 1, z: 0 };
          var flowComponent = (x - config.centerX) * flowDir.x + (z - config.centerZ) * flowDir.z;

          // Primary waves flowing in direction of river
          var flowWave = Math.sin(flowComponent * waveFrequency - waterTime * waveSpeed) * waveHeight;

          // Secondary flow wave at different frequency
          var flowWave2 = Math.sin(flowComponent * waveFrequency * 1.3 - waterTime * waveSpeed * 1.4) * waveHeight * 0.5;

          // Cross-river waves for more natural look
          var crossComponent = -(x - config.centerX) * flowDir.z + (z - config.centerZ) * flowDir.x;
          var crossWave = Math.sin(crossComponent * waveFrequency * 0.8 + waterTime * waveSpeed * 0.6) * waveHeight * 0.4;

          // Detail turbulence
          var turbulence = Math.sin(x * 0.5 + waterTime * waveSpeed * 1.8) * waveHeight * 0.15 +
                           Math.sin(z * 0.4 + waterTime * waveSpeed * 1.5) * waveHeight * 0.15;

          // Rapids effect during storms
          var rapids = 0;
          if (waterWeatherMultiplier > 1.5) {
            rapids = Math.sin(flowComponent * 1.2 - waterTime * waveSpeed * 3.0) * waveHeight * 0.3;
          }

          positions[j + 1] = y + flowWave + flowWave2 + crossWave + turbulence + rapids;
        }
      }

      // Wave crest tinting - add lighter color on wave peaks
      var maxAmp = baseWaveHeight * waterWeatherMultiplier;
      var crestThreshold = maxAmp * 0.6;
      if (!water.crestColors) {
        var colorCount = positions.length / 3;
        var colorArray = new Float32Array(colorCount * 3);
        water.crestColors = colorArray;
        water.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
        water.material.vertexColors = true;
        // Set base color from material
        var baseR = ((water.config.color >> 16) & 0xff) / 255;
        var baseG = ((water.config.color >> 8) & 0xff) / 255;
        var baseB = (water.config.color & 0xff) / 255;
        for (var ci = 0; ci < colorCount; ci++) {
          colorArray[ci * 3] = baseR;
          colorArray[ci * 3 + 1] = baseG;
          colorArray[ci * 3 + 2] = baseB;
        }
      }
      var colors = water.crestColors;
      var baseR2 = ((water.config.color >> 16) & 0xff) / 255;
      var baseG2 = ((water.config.color >> 8) & 0xff) / 255;
      var baseB2 = (water.config.color & 0xff) / 255;
      for (var ck = 0; ck < positions.length; ck += 3) {
        var displacement = positions[ck + 1] - initialPos[ck + 1];
        var crestFactor = displacement > crestThreshold ? Math.min((displacement - crestThreshold) / (maxAmp - crestThreshold), 1.0) * 0.3 : 0;
        colors[ck] = baseR2 + crestFactor;
        colors[ck + 1] = baseG2 + crestFactor;
        colors[ck + 2] = baseB2 + crestFactor;
      }
      water.geometry.attributes.color.needsUpdate = true;

      water.geometry.attributes.position.needsUpdate = true;
      water.geometry.computeVertexNormals();

      // Update water material properties based on weather
      if (water.material) {
        // Adjust opacity based on weather (rougher water is more opaque)
        var targetOpacity = 0.65;
        if (weatherType === 'storm') {
          targetOpacity = 0.75; // Darker, choppier water
        } else if (weatherType === 'rain') {
          targetOpacity = 0.7;
        }
        water.material.opacity += (targetOpacity - water.material.opacity) * deltaTime * 0.5;

        // Adjust emissive intensity (calmer water glows more)
        var targetEmissive = 0.15;
        if (weatherType === 'storm') {
          targetEmissive = 0.08; // Less glow during storm
        } else if (weatherType === 'snow') {
          targetEmissive = 0.1; // Reduced glow in cold
        }
        if (water.material.emissiveIntensity !== undefined) {
          water.material.emissiveIntensity += (targetEmissive - water.material.emissiveIntensity) * deltaTime * 0.5;
        }
      }
    }

    // Animate foam rings
    for (var fi = 0; fi < waterBodies.length; fi++) {
      var foamBody = waterBodies[fi];
      if (!foamBody.foamRing) continue;
      var foamMat = foamBody.foamRing.material;
      foamMat.opacity = Math.sin(waterTime * 1.5) * 0.06 + 0.14;
      var foamScale = 1.0 + Math.sin(waterTime * 0.8) * 0.02;
      foamBody.foamRing.scale.set(foamScale, 1, foamScale);
    }
  }

  // ========================================================================
  // SKYBOX / SKY DOME SYSTEM
  // ========================================================================

  var playerStarsMesh = null;

  function initPlayerStars(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    // Load player stars from localStorage
    var stored = null;
    if (typeof localStorage !== 'undefined') {
      try { stored = JSON.parse(localStorage.getItem('zion_playerStars') || '{}'); } catch(e) { stored = {}; }
    }
    if (!stored || Object.keys(stored).length === 0) return;

    var psPos = [];
    var psSizes = [];
    var psColors = [];
    for (var pid in stored) {
      var ps = stored[pid];
      psPos.push(ps.x || 0, ps.y || 0, ps.z || 0);
      psSizes.push(2.5);
      psColors.push(1.0, 0.87, 0.53); // warm gold 0xFFDD88
    }

    if (psPos.length === 0) return;

    var psGeo = new THREE.BufferGeometry();
    psGeo.setAttribute('position', new THREE.Float32BufferAttribute(psPos, 3));
    psGeo.setAttribute('size', new THREE.Float32BufferAttribute(psSizes, 1));
    psGeo.setAttribute('color', new THREE.Float32BufferAttribute(psColors, 3));

    var psMat = new THREE.PointsMaterial({
      size: 2.5,
      sizeAttenuation: false,
      transparent: true,
      opacity: 0.0,
      fog: false,
      vertexColors: true
    });

    playerStarsMesh = new THREE.Points(psGeo, psMat);
    sceneCtx.scene.add(playerStarsMesh);
  }

  function registerPlayerStar(playerId, playerName) {
    // Place star at a deterministic position based on player ID hash
    var hash = 0;
    for (var i = 0; i < playerId.length; i++) {
      hash = ((hash << 5) - hash) + playerId.charCodeAt(i);
      hash |= 0;
    }
    var theta = (Math.abs(hash) % 10000) / 10000 * Math.PI * 2;
    var phi = (Math.abs(hash * 7919) % 10000) / 10000 * Math.PI * 0.6 + 0.2; // keep above horizon
    var R = 750;
    var starData = {
      name: playerName || playerId,
      x: R * Math.sin(phi) * Math.cos(theta),
      y: R * Math.cos(phi),
      z: R * Math.sin(phi) * Math.sin(theta),
      color: 0xFFDD88,
      ts: new Date().toISOString()
    };

    // Save to localStorage
    if (typeof localStorage !== 'undefined') {
      try {
        var stored = JSON.parse(localStorage.getItem('zion_playerStars') || '{}');
        stored[playerId] = starData;
        localStorage.setItem('zion_playerStars', JSON.stringify(stored));
      } catch(e) {}
    }
    return starData;
  }

  function initSkybox(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Create sky dome with gradient colors using vertex colors
    var skyGeo = new THREE.SphereGeometry(800, 32, 32);

    // Add vertex colors for gradient (deep blue at top, orange/pink at horizon)
    var colors = [];
    var posArray = skyGeo.attributes.position.array;
    for (var i = 0; i < posArray.length; i += 3) {
      var y = posArray[i + 1];
      var normalizedY = (y + 800) / 1600; // 0 at bottom, 1 at top

      // Deep blue at top (y > 0.5), orange/pink at horizon (y < 0.5)
      var r, g, b;
      if (normalizedY > 0.5) {
        // Top half: deep blue
        var t = (normalizedY - 0.5) / 0.5;
        r = 0.02 + t * 0.1;
        g = 0.02 + t * 0.3;
        b = 0.2 + t * 0.6;
      } else {
        // Bottom half: gradient from orange/pink to blue
        var t = normalizedY / 0.5;
        r = 1.0 - t * 0.88;
        g = 0.42 - t * 0.1;
        b = 0.21 + t * 0.59;
      }

      colors.push(r, g, b);
    }

    skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    var skyMat = new THREE.MeshBasicMaterial({
      side: THREE.BackSide,
      vertexColors: true,
      fog: false
    });
    skyDome = new THREE.Mesh(skyGeo, skyMat);
    sceneCtx.scene.add(skyDome);

    // â”€â”€ Constellation Data â”€â”€
    var CONSTELLATIONS = {
      orion: { stars: [
        {theta:1.55,phi:1.20},{theta:1.60,phi:1.10},{theta:1.58,phi:1.00},
        {theta:1.50,phi:0.95},{theta:1.65,phi:0.95},
        {theta:1.52,phi:0.85},{theta:1.63,phi:0.85}
      ]},
      bigDipper: { stars: [
        {theta:0.80,phi:0.50},{theta:0.85,phi:0.52},{theta:0.92,phi:0.50},
        {theta:0.98,phi:0.53},{theta:1.05,phi:0.48},
        {theta:1.10,phi:0.55},{theta:1.15,phi:0.50}
      ]},
      cassiopeia: { stars: [
        {theta:2.50,phi:0.40},{theta:2.55,phi:0.35},{theta:2.60,phi:0.40},
        {theta:2.65,phi:0.35},{theta:2.70,phi:0.40}
      ]},
      scorpius: { stars: [
        {theta:4.20,phi:1.30},{theta:4.22,phi:1.25},{theta:4.25,phi:1.20},
        {theta:4.27,phi:1.15},{theta:4.30,phi:1.10},
        {theta:4.35,phi:1.12},{theta:4.40,phi:1.15},
        {theta:4.45,phi:1.20},{theta:4.50,phi:1.25}
      ]},
      leo: { stars: [
        {theta:3.10,phi:0.80},{theta:3.15,phi:0.75},{theta:3.20,phi:0.78},
        {theta:3.25,phi:0.82},{theta:3.18,phi:0.88},{theta:3.22,phi:0.85}
      ]},
      southernCross: { stars: [
        {theta:5.00,phi:2.10},{theta:5.05,phi:2.00},{theta:5.00,phi:1.90},
        {theta:4.95,phi:2.00},{theta:5.03,phi:2.00}
      ]}
    };

    // Create starfield: 1800 random + constellation stars
    var starGeo = new THREE.BufferGeometry();
    var starPos = [];
    var starSizes = [];
    var starColors = [];
    var starPhases = []; // for twinkling

    // 1800 random background stars
    for (var i = 0; i < 1800; i++) {
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.random() * Math.PI;
      var r = 750;
      starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
      starSizes.push(0.3 + Math.random() * 1.2);
      starColors.push(1.0, 1.0, 1.0); // white
      starPhases.push(Math.random() * Math.PI * 2);
    }

    // Add constellation stars (brighter, slightly warm-tinted)
    for (var cKey in CONSTELLATIONS) {
      var cStars = CONSTELLATIONS[cKey].stars;
      for (var cs = 0; cs < cStars.length; cs++) {
        var s = cStars[cs];
        var cr = 750;
        starPos.push(cr * Math.sin(s.phi) * Math.cos(s.theta), cr * Math.cos(s.phi), cr * Math.sin(s.phi) * Math.sin(s.theta));
        starSizes.push(1.8 + Math.random() * 0.5); // brighter
        starColors.push(1.0, 0.95, 0.85); // warm white
        starPhases.push(Math.random() * Math.PI * 2);
      }
    }

    var totalStars = starPos.length / 3;
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
    starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
    starGeo.userData.phases = new Float32Array(starPhases);
    starGeo.userData.baseSizes = new Float32Array(starSizes);
    starGeo.userData.starCount = totalStars;

    var starMat = new THREE.PointsMaterial({
      size: 1.0,
      sizeAttenuation: false,
      transparent: true,
      opacity: 0.0,
      fog: false,
      vertexColors: true
    });

    stars = new THREE.Points(starGeo, starMat);
    sceneCtx.scene.add(stars);

    // â”€â”€ Player Constellation Stars (separate Points group) â”€â”€
    initPlayerStars(sceneCtx);

    // Create Sun
    var sunGeo = new THREE.SphereGeometry(5, 16, 16);
    var sunMat = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      fog: false
    });
    sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sceneCtx.scene.add(sunMesh);

    // Create Moon
    var moonGeo = new THREE.SphereGeometry(3, 16, 16);
    var moonMat = new THREE.MeshBasicMaterial({
      color: 0xccccdd,
      fog: false
    });
    moonMesh = new THREE.Mesh(moonGeo, moonMat);
    sceneCtx.scene.add(moonMesh);
  }

  function updateSkybox(sceneCtx, worldTime) {
    if (!sceneCtx || !sceneCtx.camera) return;

    // Make sky dome follow camera position
    if (skyDome) {
      skyDome.position.copy(sceneCtx.camera.position);
    }

    // Update sun and moon positions based on worldTime
    // worldTime: 0-1440 (minutes in 24h cycle)
    // Noon (720) = sun overhead, Midnight (0/1440) = sun below horizon
    var normalizedTime = worldTime / 1440; // 0-1
    var sunAngle = normalizedTime * Math.PI * 2 - Math.PI / 2; // -PI/2 at midnight, PI/2 at noon

    if (sunMesh) {
      var sunRadius = 400;
      sunMesh.position.set(
        Math.cos(sunAngle) * sunRadius,
        Math.sin(sunAngle) * sunRadius,
        0
      );
      sunMesh.position.add(sceneCtx.camera.position);
    }

    if (moonMesh) {
      var moonRadius = 400;
      // Moon is opposite to sun
      var moonAngle = sunAngle + Math.PI;
      moonMesh.position.set(
        Math.cos(moonAngle) * moonRadius,
        Math.sin(moonAngle) * moonRadius,
        0
      );
      moonMesh.position.add(sceneCtx.camera.position);
    }

    // Update star visibility based on worldTime
    if (stars && stars.material) {
      // Night: worldTime 1080-1440 (18:00-24:00) and 0-360 (00:00-06:00)
      // Day: worldTime 360-1080 (06:00-18:00)
      var opacity = 0.0;

      if (worldTime >= 1080 && worldTime <= 1440) {
        // Evening to midnight (18:00-24:00)
        var t = (worldTime - 1080) / 360;
        opacity = Math.min(1.0, t * 2); // Fade in
      } else if (worldTime >= 0 && worldTime < 360) {
        // Midnight to dawn (00:00-06:00)
        var t = worldTime / 360;
        opacity = Math.max(0.0, 1.0 - t * 2); // Fade out
      } else if (worldTime >= 300 && worldTime < 420) {
        // Dawn fade out (05:00-07:00)
        var t = (worldTime - 300) / 120;
        opacity = Math.max(0.0, 1.0 - t);
      } else if (worldTime >= 1020 && worldTime < 1140) {
        // Dusk fade in (17:00-19:00)
        var t = (worldTime - 1020) / 120;
        opacity = Math.min(1.0, t);
      }

      stars.material.opacity = opacity;
      stars.material.transparent = true;

      // Star twinkling (only when visible)
      if (opacity > 0.05 && stars.geometry.userData.phases) {
        var phases = stars.geometry.userData.phases;
        var baseSizes = stars.geometry.userData.baseSizes;
        var sizes = stars.geometry.attributes.size.array;
        var twinkleTime = Date.now() * 0.001;
        for (var si = 0; si < phases.length; si++) {
          sizes[si] = baseSizes[si] + Math.sin(twinkleTime * 1.5 + phases[si]) * 0.4;
        }
        stars.geometry.attributes.size.needsUpdate = true;
      }

      // Make stars follow camera
      stars.position.copy(sceneCtx.camera.position);
    }

    // Update player stars visibility + position
    if (playerStarsMesh && playerStarsMesh.material) {
      playerStarsMesh.material.opacity = stars ? stars.material.opacity : 0;
      playerStarsMesh.position.copy(sceneCtx.camera.position);
    }
  }

  // ========================================================================
  // HARVESTABLE RESOURCE NODES
  // ========================================================================

  var resourceNodes = [];

  function initResourceNodes(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    addZoneResources(sceneCtx.scene, 'gardens', [
      { itemId: 'flower_rose', count: 8, radius: 30 },
      { itemId: 'flower_tulip', count: 10, radius: 35 },
      { itemId: 'flower_sunflower', count: 12, radius: 40 },
      { itemId: 'herb_lavender', count: 8, radius: 28 },
      { itemId: 'seed_wildflower', count: 6, radius: 25 }
    ]);

    addZoneResources(sceneCtx.scene, 'wilds', [
      { itemId: 'wood_oak', count: 15, radius: 45 },
      { itemId: 'wood_pine', count: 12, radius: 50 },
      { itemId: 'stone_common', count: 10, radius: 40 },
      { itemId: 'herb_ginseng', count: 5, radius: 35 },
      { itemId: 'crystal_clear', count: 4, radius: 30 },
      { itemId: 'food_mushroom', count: 8, radius: 38 },
      { itemId: 'food_berry', count: 10, radius: 42 }
    ]);

    addZoneResources(sceneCtx.scene, 'nexus', [
      { itemId: 'crystal_clear', count: 6, radius: 25 },
      { itemId: 'crystal_amethyst', count: 4, radius: 20 }
    ]);

    addZoneResources(sceneCtx.scene, 'studio', [
      { itemId: 'wood_mystical', count: 3, radius: 25 },
      { itemId: 'crystal_clear', count: 5, radius: 22 }
    ]);

    addZoneResources(sceneCtx.scene, 'commons', [
      { itemId: 'wood_oak', count: 8, radius: 25 },
      { itemId: 'stone_common', count: 6, radius: 23 }
    ]);

    addZoneResources(sceneCtx.scene, 'athenaeum', [
      { itemId: 'item_scroll', count: 10, radius: 28 }
    ]);

    addZoneResources(sceneCtx.scene, 'arena', [
      { itemId: 'item_trophy', count: 2, radius: 20 }
    ]);
  }

  function addZoneResources(scene, zoneId, resources) {
    var zone = ZONES[zoneId];
    if (!zone) return;

    resources.forEach(function(res) {
      for (var i = 0; i < res.count; i++) {
        var angle = seededRandom(zoneId.charCodeAt(0), i, res.itemId.charCodeAt(0)) * Math.PI * 2;
        var dist = seededRandom(zoneId.charCodeAt(1), i, res.itemId.charCodeAt(1)) * res.radius;
        var x = zone.cx + Math.cos(angle) * dist;
        var z = zone.cz + Math.sin(angle) * dist;

        var onPath = false;
        for (var pz in ZONES) {
          if (pz === 'nexus') continue;
          if (pointToSegDist(x, z, ZONES.nexus.cx, ZONES.nexus.cz, ZONES[pz].cx, ZONES[pz].cz) < 5) {
            onPath = true;
            break;
          }
        }
        if (onPath) continue;

        var distFromCenter = Math.sqrt((x - zone.cx) * (x - zone.cx) + (z - zone.cz) * (z - zone.cz));
        if (distFromCenter < zone.radius * 0.3) continue;

        var y = terrainHeight(x, z);
        createResourceNode(scene, x, y, z, res.itemId, zoneId);
      }
    });
  }

  function createResourceNode(scene, x, y, z, itemId, zone) {
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var itemData = Inventory.getItemData(itemId);
    if (!itemData) return;

    var nodeGroup = new THREE.Group();
    var nodeMesh;

    if (itemData.type === 'wood') {
      var stumpGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
      var stumpMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      nodeMesh = new THREE.Mesh(stumpGeo, stumpMat);
      nodeMesh.position.y = 0.6;
      nodeGroup.add(nodeMesh);

      var leavesGeo = new THREE.SphereGeometry(0.5, 6, 6);
      var leavesMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50, transparent: true, opacity: 0.7 });
      var leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = 1.4;
      nodeGroup.add(leaves);

    } else if (itemData.type === 'stone') {
      var rockGeo = new THREE.DodecahedronGeometry(0.6, 0);
      var rockMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
      nodeMesh = new THREE.Mesh(rockGeo, rockMat);
      nodeMesh.position.y = 0.4;
      nodeMesh.rotation.set(Math.random(), Math.random(), Math.random());
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'crystal') {
      var crystalGeo = new THREE.OctahedronGeometry(0.5, 0);
      var crystalColor = itemId === 'crystal_amethyst' ? 0x9C27B0 : (itemId === 'crystal_emerald' ? 0x4CAF50 : 0x00BCD4);
      var crystalMat = new THREE.MeshStandardMaterial({
        color: crystalColor,
        emissive: crystalColor,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.8
      });
      nodeMesh = new THREE.Mesh(crystalGeo, crystalMat);
      nodeMesh.position.y = 0.7;
      nodeGroup.add(nodeMesh);

      var glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var glowMat = new THREE.MeshBasicMaterial({ color: crystalColor, transparent: true, opacity: 0.3 });
      var glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 0.7;
      nodeGroup.add(glow);

      animatedObjects.push({ mesh: nodeMesh, type: 'crystal', params: { speed: 0.3, baseY: 0.7 } });

    } else if (itemData.type === 'flowers' || itemData.type === 'herbs') {
      var flowerGeo = new THREE.SphereGeometry(0.3, 6, 6);
      var flowerColors = {
        flower_rose: 0xFF1744, flower_tulip: 0xE91E63, flower_sunflower: 0xFFEB3B,
        flower_lotus: 0xE1BEE7, flower_cherry: 0xF8BBD0,
        herb_mint: 0x4CAF50, herb_sage: 0x66BB6A, herb_ginseng: 0xA1887F, herb_lavender: 0xCE93D8
      };
      var flowerColor = flowerColors[itemId] || 0x4CAF50;
      var flowerMat = new THREE.MeshStandardMaterial({ color: flowerColor });
      nodeMesh = new THREE.Mesh(flowerGeo, flowerMat);
      nodeMesh.position.y = 0.3;
      nodeGroup.add(nodeMesh);

      var stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 4);
      var stemMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
      var stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.15;
      nodeGroup.add(stem);

    } else if (itemData.type === 'seeds') {
      var seedGeo = new THREE.SphereGeometry(0.2, 6, 6);
      var seedMat = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
      nodeMesh = new THREE.Mesh(seedGeo, seedMat);
      nodeMesh.position.y = 0.2;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'food') {
      var foodGeo = new THREE.SphereGeometry(0.25, 6, 6);
      var foodColors = { food_mushroom: 0xD32F2F, food_berry: 0x7B1FA2 };
      var foodColor = foodColors[itemId] || 0x8D6E63;
      var foodMat = new THREE.MeshStandardMaterial({ color: foodColor });
      nodeMesh = new THREE.Mesh(foodGeo, foodMat);
      nodeMesh.position.y = 0.25;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'knowledge') {
      var scrollGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
      var scrollMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC });
      nodeMesh = new THREE.Mesh(scrollGeo, scrollMat);
      nodeMesh.position.y = 0.3;
      nodeMesh.rotation.z = Math.PI / 2;
      nodeGroup.add(nodeMesh);

    } else if (itemData.type === 'trophies') {
      var trophyGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var trophyMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.2 });
      nodeMesh = new THREE.Mesh(trophyGeo, trophyMat);
      nodeMesh.position.y = 0.5;
      nodeGroup.add(nodeMesh);

      var baseGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.3, 8);
      var baseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      var base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.15;
      nodeGroup.add(base);

    } else {
      var genGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
      var genMat = new THREE.MeshStandardMaterial({ color: 0xBDBDBD });
      nodeMesh = new THREE.Mesh(genGeo, genMat);
      nodeMesh.position.y = 0.2;
      nodeGroup.add(nodeMesh);
    }

    nodeGroup.position.set(x, y, z);
    nodeGroup.userData.isResource = true;
    nodeGroup.userData.itemId = itemId;
    nodeGroup.userData.depleted = false;
    nodeGroup.userData.respawnTime = 0;
    nodeGroup.userData.zone = zone;
    nodeGroup.userData.nodeMesh = nodeMesh;

    scene.add(nodeGroup);
    resourceNodes.push(nodeGroup);
  }

  function updateResourceNodes(deltaTime) {
    var currentTime = Date.now();

    resourceNodes.forEach(function(node) {
      if (node.userData.depleted) {
        if (currentTime >= node.userData.respawnTime) {
          node.userData.depleted = false;
          node.visible = true;

          if (node.userData.nodeMesh && node.userData.nodeMesh.material) {
            node.userData.nodeMesh.material.opacity = 1.0;
            node.userData.nodeMesh.material.transparent = false;
          }
        }
      }
    });
  }

  function harvestResource(node) {
    if (!node || !node.userData || !node.userData.isResource) return null;
    if (node.userData.depleted) return null;

    var itemId = node.userData.itemId;

    node.userData.depleted = true;
    node.userData.respawnTime = Date.now() + (30000 + Math.random() * 30000);

    if (node.userData.nodeMesh && node.userData.nodeMesh.material) {
      node.userData.nodeMesh.material.opacity = 0.3;
      node.userData.nodeMesh.material.transparent = true;
    }

    return itemId;
  }

  function getResourceNodeAtMouse(raycaster, camera, mouseX, mouseY) {
    raycaster.setFromCamera({ x: mouseX, y: mouseY }, camera);

    var intersects = raycaster.intersectObjects(resourceNodes, true);
    if (intersects.length > 0) {
      var obj = intersects[0].object;
      while (obj && !obj.userData.isResource) {
        obj = obj.parent;
      }
      return obj && obj.userData.isResource ? obj : null;
    }
    return null;
  }

  // ========================================================================
  // BUILD MODE â€” Visual building placement system
  // ========================================================================

  var buildMode = false;
  var buildType = 'bench';
  var buildGhost = null;
  var buildRotation = 0;
  var placedBuildings = [];

  // Simple buildable structure models
  function createBuildableModel(type) {
    var group = new THREE.Group();

    switch (type) {
      case 'bench':
        // Seat plank
        var seatGeo = new THREE.BoxGeometry(1.2, 0.1, 0.4);
        var woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
        var seat = new THREE.Mesh(seatGeo, woodMat);
        seat.position.y = 0.4;
        group.add(seat);
        // Legs
        for (var i = 0; i < 4; i++) {
          var legGeo = new THREE.BoxGeometry(0.08, 0.4, 0.08);
          var leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.x = (i % 2 === 0) ? -0.5 : 0.5;
          leg.position.z = (i < 2) ? -0.15 : 0.15;
          leg.position.y = 0.2;
          group.add(leg);
        }
        break;

      case 'lantern':
        // Post
        var postGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
        var metalMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
        var post = new THREE.Mesh(postGeo, metalMat);
        post.position.y = 1;
        group.add(post);
        // Light box
        var lightGeo = new THREE.BoxGeometry(0.3, 0.4, 0.3);
        var lightMat = new THREE.MeshStandardMaterial({
          color: 0xffdd88,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5,
          roughness: 0.3
        });
        var light = new THREE.Mesh(lightGeo, lightMat);
        light.position.y = 2.2;
        group.add(light);
        break;

      case 'signpost':
        // Post
        var signPostGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
        var signPostMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var signPost = new THREE.Mesh(signPostGeo, signPostMat);
        signPost.position.y = 0.75;
        group.add(signPost);
        // Sign board
        var boardGeo = new THREE.BoxGeometry(1, 0.4, 0.1);
        var boardMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.7 });
        var board = new THREE.Mesh(boardGeo, boardMat);
        board.position.y = 1.6;
        group.add(board);
        break;

      case 'fence':
        // Two posts
        var fencePostGeo = new THREE.CylinderGeometry(0.06, 0.06, 1, 6);
        var fencePostMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var post1 = new THREE.Mesh(fencePostGeo, fencePostMat);
        post1.position.set(-0.4, 0.5, 0);
        group.add(post1);
        var post2 = new THREE.Mesh(fencePostGeo, fencePostMat);
        post2.position.set(0.4, 0.5, 0);
        group.add(post2);
        // Horizontal bar
        var barGeo = new THREE.BoxGeometry(1, 0.08, 0.08);
        var bar = new THREE.Mesh(barGeo, fencePostMat);
        bar.position.y = 0.6;
        group.add(bar);
        break;

      case 'planter':
        // Box
        var planterGeo = new THREE.BoxGeometry(0.8, 0.4, 0.8);
        var planterMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.8 });
        var planter = new THREE.Mesh(planterGeo, planterMat);
        planter.position.y = 0.2;
        group.add(planter);
        // Green top (soil/plants)
        var soilGeo = new THREE.BoxGeometry(0.7, 0.1, 0.7);
        var soilMat = new THREE.MeshStandardMaterial({ color: 0x2d5016, roughness: 0.9 });
        var soil = new THREE.Mesh(soilGeo, soilMat);
        soil.position.y = 0.45;
        group.add(soil);
        break;

      case 'campfire':
        // Fire ring (stones)
        for (var j = 0; j < 8; j++) {
          var angle = (j / 8) * Math.PI * 2;
          var stoneGeo = new THREE.BoxGeometry(0.15, 0.1, 0.1);
          var stoneMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.95 });
          var stone = new THREE.Mesh(stoneGeo, stoneMat);
          stone.position.x = Math.cos(angle) * 0.35;
          stone.position.z = Math.sin(angle) * 0.35;
          stone.position.y = 0.05;
          stone.rotation.y = angle;
          group.add(stone);
        }
        // Fire glow
        var fireGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.3, 6);
        var fireMat = new THREE.MeshStandardMaterial({
          color: 0xff6600,
          emissive: 0xff4400,
          emissiveIntensity: 0.8,
          roughness: 0.2
        });
        var fire = new THREE.Mesh(fireGeo, fireMat);
        fire.position.y = 0.2;
        group.add(fire);
        break;

      case 'archway':
        // Two pillars
        var pillarGeo = new THREE.BoxGeometry(0.3, 2.5, 0.3);
        var pillarMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e, roughness: 0.7 });
        var pillar1 = new THREE.Mesh(pillarGeo, pillarMat);
        pillar1.position.set(-0.8, 1.25, 0);
        group.add(pillar1);
        var pillar2 = new THREE.Mesh(pillarGeo, pillarMat);
        pillar2.position.set(0.8, 1.25, 0);
        group.add(pillar2);
        // Curved top (simplified as box)
        var archGeo = new THREE.BoxGeometry(1.9, 0.3, 0.3);
        var arch = new THREE.Mesh(archGeo, pillarMat);
        arch.position.y = 2.6;
        group.add(arch);
        break;

      case 'table':
        // Flat top
        var topGeo = new THREE.BoxGeometry(1.2, 0.1, 0.8);
        var tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
        var top = new THREE.Mesh(topGeo, tableMat);
        top.position.y = 0.7;
        group.add(top);
        // 4 legs
        for (var k = 0; k < 4; k++) {
          var tableLegGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 6);
          var tableLeg = new THREE.Mesh(tableLegGeo, tableMat);
          tableLeg.position.x = (k % 2 === 0) ? -0.5 : 0.5;
          tableLeg.position.z = (k < 2) ? -0.3 : 0.3;
          tableLeg.position.y = 0.35;
          group.add(tableLeg);
        }
        break;

      case 'barrel':
        var barrelGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 12);
        var barrelMat = new THREE.MeshStandardMaterial({ color: 0x6d4c41, roughness: 0.8 });
        var barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.position.y = 0.4;
        group.add(barrel);
        // Metal bands
        for (var m = 0; m < 2; m++) {
          var bandGeo = new THREE.CylinderGeometry(0.32, 0.36, 0.05, 12);
          var bandMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.5 });
          var band = new THREE.Mesh(bandGeo, bandMat);
          band.position.y = 0.2 + m * 0.4;
          group.add(band);
        }
        break;

      case 'crate':
        var crateGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        var crateMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.9 });
        var crate = new THREE.Mesh(crateGeo, crateMat);
        crate.position.y = 0.3;
        group.add(crate);
        // Cross pattern
        var crossGeo1 = new THREE.BoxGeometry(0.05, 0.05, 0.7);
        var crossMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 });
        var cross1 = new THREE.Mesh(crossGeo1, crossMat);
        cross1.position.set(0, 0.3, 0);
        cross1.rotation.y = Math.PI / 4;
        group.add(cross1);
        var cross2 = new THREE.Mesh(crossGeo1, crossMat);
        cross2.position.set(0, 0.3, 0);
        cross2.rotation.y = -Math.PI / 4;
        group.add(cross2);
        break;

      default:
        // Fallback: simple cube
        var defaultGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        var defaultMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
        var defaultMesh = new THREE.Mesh(defaultGeo, defaultMat);
        defaultMesh.position.y = 0.25;
        group.add(defaultMesh);
    }

    return group;
  }

  function enterBuildMode(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    buildMode = true;
    buildRotation = 0;

    // Create ghost preview
    buildGhost = createBuildableModel(buildType);
    buildGhost.userData.isGhost = true;

    // Make all materials transparent
    buildGhost.traverse(function(child) {
      if (child.material) {
        var mat = child.material.clone();
        mat.transparent = true;
        mat.opacity = 0.5;
        mat.depthWrite = false;
        child.material = mat;
      }
    });

    sceneCtx.scene.add(buildGhost);
  }

  function exitBuildMode(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    buildMode = false;

    if (buildGhost) {
      sceneCtx.scene.remove(buildGhost);
      buildGhost.traverse(function(child) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      buildGhost = null;
    }
  }

  function setBuildType(type) {
    buildType = type;
    buildRotation = 0;
  }

  function confirmPlacement(sceneCtx, playerPos, zone) {
    if (!buildMode || !buildGhost || !sceneCtx || !sceneCtx.scene) return null;

    // Check if zone allows building
    var allowsBuild = (zone === 'commons' || zone === 'studio');
    if (!allowsBuild) {
      return { error: 'This zone does not allow building' };
    }

    // Get ghost position
    var pos = {
      x: buildGhost.position.x,
      y: buildGhost.position.y,
      z: buildGhost.position.z
    };

    // Create permanent structure
    var structure = createBuildableModel(buildType);
    structure.position.set(pos.x, pos.y, pos.z);
    structure.rotation.y = buildRotation;
    structure.userData.isBuilding = true;
    structure.userData.buildType = buildType;

    sceneCtx.scene.add(structure);

    // Track placement
    var placement = {
      type: buildType,
      x: pos.x,
      y: pos.y,
      z: pos.z,
      rotation: buildRotation
    };
    placedBuildings.push(placement);
    lastPlacedMesh = structure;

    return placement;
  }

  var lastPlacedMesh = null;

  function removeLastPlaced(sceneCtx) {
    if (lastPlacedMesh && sceneCtx && sceneCtx.scene) {
      sceneCtx.scene.remove(lastPlacedMesh);
      placedBuildings.pop();
      lastPlacedMesh = null;
    }
  }

  function updateBuildPreview(sceneCtx, mouseX, mouseY, camera) {
    if (!buildMode || !buildGhost || !sceneCtx || !camera) return;

    // Create raycaster
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(mouseX, mouseY);
    raycaster.setFromCamera(mouse, camera);

    // Raycast onto ground plane (y=0 for simplicity, could use terrain height)
    var plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    var hitPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, hitPoint);

    if (hitPoint) {
      // Snap to 2-unit grid
      var snappedX = Math.round(hitPoint.x / 2) * 2;
      var snappedZ = Math.round(hitPoint.z / 2) * 2;

      // Get terrain height at this position
      var groundY = terrainHeight(snappedX, snappedZ);

      buildGhost.position.set(snappedX, groundY, snappedZ);
      buildGhost.rotation.y = buildRotation;

      // Check if placement is valid (in building zone)
      var buildZone = getZoneAtPosition(snappedX, snappedZ);
      var isValid = (buildZone === 'commons' || buildZone === 'studio');

      // Update ghost color (green if valid, red if invalid)
      buildGhost.traverse(function(child) {
        if (child.material && child.material.color) {
          if (isValid) {
            child.material.color.setHex(0x00ff00);
          } else {
            child.material.color.setHex(0xff0000);
          }
        }
      });
    }
  }

  function rotateBuildPreview(delta) {
    buildRotation += delta;
    if (buildGhost) {
      buildGhost.rotation.y = buildRotation;
    }
  }

  function getBuildMode() {
    return buildMode;
  }

  // ========================================================================
  // PERFORMANCE OPTIMIZATIONS
  // ========================================================================

  // Track LOD state for objects
  var lodStates = new Map(); // objectId -> { level: 0/1/2, hiddenChildren: [] }

  // Object pools for particles
  var objectPools = {
    sphere: [],
    cube: [],
    cone: []
  };

  /**
   * Distance-based LOD for trees and structures
   * - distance > 200: hide completely
   * - distance > 100: simplify (hide small decorative pieces)
   * - distance < 100: full detail
   */
  function updateLOD(sceneCtx, playerPos) {
    if (!sceneCtx || !sceneCtx.scene || !playerPos) return;

    var scene = sceneCtx.scene;

    // Process all groups in scene with model_type userData
    scene.traverse(function(obj) {
      if (!obj.userData || !obj.userData.model_type) return;
      if (!(obj instanceof THREE.Group)) return;

      var objId = obj.uuid;
      var dx = obj.position.x - playerPos.x;
      var dz = obj.position.z - playerPos.z;
      var distance = Math.sqrt(dx * dx + dz * dz);

      var currentState = lodStates.get(objId);
      var newLevel = 0;

      if (distance > 200) {
        newLevel = 2; // hidden
      } else if (distance > 100) {
        newLevel = 1; // simplified
      } else {
        newLevel = 0; // full detail
      }

      // Only update if LOD level changed
      if (!currentState || currentState.level !== newLevel) {
        if (newLevel === 2) {
          // Hide completely
          obj.visible = false;
        } else if (newLevel === 1) {
          // Simplify: hide small meshes (low vertex count decorative pieces)
          obj.visible = true;
          var hiddenChildren = [];
          obj.traverse(function(child) {
            if (child instanceof THREE.Mesh && child !== obj) {
              var vertexCount = 0;
              if (child.geometry && child.geometry.attributes && child.geometry.attributes.position) {
                vertexCount = child.geometry.attributes.position.count;
              }
              // Hide meshes with fewer than 50 vertices (decorative details)
              if (vertexCount < 50 && child.visible) {
                child.visible = false;
                hiddenChildren.push(child);
              }
            }
          });
          lodStates.set(objId, { level: 1, hiddenChildren: hiddenChildren });
        } else {
          // Full detail: restore everything
          obj.visible = true;
          if (currentState && currentState.hiddenChildren) {
            for (var i = 0; i < currentState.hiddenChildren.length; i++) {
              currentState.hiddenChildren[i].visible = true;
            }
          }
          lodStates.set(objId, { level: 0, hiddenChildren: [] });
        }
      }
    });
  }

  /**
   * Frustum culling for animated objects and chunks
   * Sets userData.inFrustum flag to skip animation updates for objects outside view
   */
  function updateFrustumCulling(sceneCtx) {
    if (!sceneCtx || !sceneCtx.camera) return;

    var camera = sceneCtx.camera;
    camera.updateMatrixWorld();

    var frustum = new THREE.Frustum();
    var projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);

    // Cull animated objects
    for (var i = 0; i < animatedObjects.length; i++) {
      var obj = animatedObjects[i];
      if (!obj.mesh) continue;
      try {
        var inFrustum = frustum.intersectsObject(obj.mesh);
        obj.mesh.userData.inFrustum = inFrustum;
      } catch (e) {
        obj.mesh.userData.inFrustum = true; // default visible if check fails
      }
    }

    // Cull chunks
    loadedChunks.forEach(function(chunkData, key) {
      if (!chunkData.group) return;
      try {
        var inFrustum = frustum.intersectsObject(chunkData.group);
        chunkData.group.userData.inFrustum = inFrustum;
      } catch (e) {
        chunkData.group.userData.inFrustum = true;
      }
    });
  }

  /**
   * Get object from pool (for particle systems)
   */
  function getFromPool(type) {
    var pool = objectPools[type];
    if (!pool) {
      objectPools[type] = [];
      pool = objectPools[type];
    }

    if (pool.length > 0) {
      var obj = pool.pop();
      obj.visible = true;
      return obj;
    }

    // Create new object if pool is empty
    var geometry, material, mesh;
    switch (type) {
      case 'sphere':
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      case 'cube':
        geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      case 'cone':
        geometry = new THREE.ConeGeometry(0.1, 0.2, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
        break;
      default:
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        mesh = new THREE.Mesh(geometry, material);
    }
    return mesh;
  }

  /**
   * Return object to pool
   */
  function returnToPool(type, object) {
    if (!object) return;

    var pool = objectPools[type];
    if (!pool) {
      objectPools[type] = [];
      pool = objectPools[type];
    }

    // Reset object state
    object.visible = false;
    object.position.set(0, 0, 0);
    object.rotation.set(0, 0, 0);
    object.scale.set(1, 1, 1);

    // Add to pool if not too large
    if (pool.length < 1000) {
      pool.push(object);
    } else {
      // Dispose if pool is full
      if (object.geometry) object.geometry.dispose();
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            object.material[i].dispose();
          }
        } else {
          object.material.dispose();
        }
      }
    }
  }

  // ========================================================================
  // INTERACTIVE OBJECTS SYSTEM
  // ========================================================================

  var interactiveObjects = [];
  var nextInteractiveId = 1;

  /**
   * Interactive objects definitions per zone
   */
  var INTERACTIVE_OBJECTS = {
    nexus: [
      { type: 'fountain', position: { x: 0, z: 0 }, action: 'water_source', message: 'The fountain sparkles with pure energy. You feel restored.' },
      { type: 'bulletin_board', position: { x: 15, z: 15 }, action: 'read_announcements', message: 'The bulletin board displays community announcements and events.' }
    ],
    gardens: [
      { type: 'garden_bench', position: { x: 200, z: 40 }, action: 'rest', message: 'You sit on the garden bench, surrounded by fragrant flowers. Your mood improves.' },
      { type: 'watering_well', position: { x: 210, z: 25 }, action: 'gather_water', message: 'The well provides fresh water for the gardens.' }
    ],
    athenaeum: [
      { type: 'reading_desk', position: { x: 100, z: -215 }, action: 'study', message: 'You settle in at the reading desk. Knowledge flows more easily here.' },
      { type: 'bookshelf', position: { x: 105, z: -225 }, action: 'access_lore', message: 'The bookshelf contains ancient tomes and scrolls of wisdom.' }
    ],
    wilds: [
      { type: 'campfire', position: { x: -30, z: 265 }, action: 'warmth_cooking', message: 'The campfire crackles warmly. A perfect spot for cooking and gathering.' },
      { type: 'fallen_log', position: { x: -25, z: 255 }, action: 'sit', message: 'You sit on the weathered log, taking in the wild surroundings.' }
    ],
    agora: [
      { type: 'market_stall', position: { x: -185, z: 120 }, action: 'browse_goods', message: 'The market stall displays various wares and goods for trade.' },
      { type: 'town_bell', position: { x: -190, z: 125 }, action: 'ring_bell', message: 'CLANG! The town bell rings out across the agora.' }
    ],
    commons: [
      { type: 'park_bench', position: { x: 170, z: 195 }, action: 'socialize', message: 'A comfortable bench, perfect for meeting with friends.' },
      { type: 'street_lamp', position: { x: 175, z: 185 }, action: 'light', message: 'The street lamp provides warm light in the evening hours.' }
    ],
    arena: [
      { type: 'training_dummy', position: { x: 5, z: -240 }, action: 'practice_combat', message: 'The training dummy stands ready. Time to practice your skills.' },
      { type: 'spectator_bench', position: { x: -5, z: -235 }, action: 'watch_fights', message: 'From here, you have a great view of the arena floor.' }
    ],
    studio: [
      { type: 'easel', position: { x: -200, z: -95 }, action: 'create_art', message: 'The easel stands ready. Your creativity flows here.' },
      { type: 'piano', position: { x: -205, z: -105 }, action: 'play_music', message: 'The piano is perfectly tuned. Music fills the studio.' }
    ]
  };

  /**
   * Create a 3D mesh for an interactive object
   */
  function createInteractiveObject(type, position) {
    var group = new THREE.Group();
    var baseY = getTerrainHeight(position.x, position.z) || 0;

    // Create different objects based on type
    if (type === 'garden_bench' || type === 'park_bench' || type === 'spectator_bench') {
      // Bench seat
      var seatGeo = new THREE.BoxGeometry(2.5, 0.3, 0.8);
      var benchMat = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
      var seat = new THREE.Mesh(seatGeo, benchMat);
      seat.position.set(0, 0.4, 0);
      seat.castShadow = true;
      group.add(seat);

      // Bench legs
      for (var i = -1; i <= 1; i += 2) {
        for (var j = -1; j <= 1; j += 2) {
          var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8);
          var leg = new THREE.Mesh(legGeo, benchMat);
          leg.position.set(i * 1.0, 0.2, j * 0.3);
          leg.castShadow = true;
          group.add(leg);
        }
      }

      // Backrest
      var backGeo = new THREE.BoxGeometry(2.5, 0.8, 0.15);
      var back = new THREE.Mesh(backGeo, benchMat);
      back.position.set(0, 0.9, -0.4);
      back.castShadow = true;
      group.add(back);

    } else if (type === 'campfire') {
      // Fire pit stones
      var pitGeo = new THREE.CylinderGeometry(0.8, 0.9, 0.3, 12);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var pit = new THREE.Mesh(pitGeo, stoneMat);
      pit.position.set(0, 0.15, 0);
      pit.castShadow = true;
      group.add(pit);

      // Logs arranged in cone
      var logMat = new THREE.MeshPhongMaterial({ color: 0x4a2511 });
      for (var l = 0; l < 4; l++) {
        var angle = (l / 4) * Math.PI * 2;
        var logGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
        var log = new THREE.Mesh(logGeo, logMat);
        log.position.set(Math.cos(angle) * 0.2, 0.5, Math.sin(angle) * 0.2);
        log.rotation.z = Math.PI / 6;
        log.rotation.y = angle;
        log.castShadow = true;
        group.add(log);
      }

      // Fire light
      var fireLight = new THREE.PointLight(0xff6600, 1.5, 10);
      fireLight.position.set(0, 1, 0);
      fireLight.castShadow = false;
      group.add(fireLight);

      // Store light reference for animation
      group.userData.fireLight = fireLight;

    } else if (type === 'fountain') {
      // Fountain base
      var baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.8, 16);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0xc0c0d0 });
      var base = new THREE.Mesh(baseGeo, stoneMat);
      base.position.set(0, 0.4, 0);
      base.castShadow = true;
      group.add(base);

      // Middle tier
      var midGeo = new THREE.CylinderGeometry(1.2, 1.5, 0.5, 16);
      var mid = new THREE.Mesh(midGeo, stoneMat);
      mid.position.set(0, 1.2, 0);
      mid.castShadow = true;
      group.add(mid);

      // Top bowl
      var topGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 16);
      var top = new THREE.Mesh(topGeo, stoneMat);
      top.position.set(0, 1.8, 0);
      top.castShadow = true;
      group.add(top);

      // Water pool
      var waterGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.2, 24);
      var waterMat = new THREE.MeshStandardMaterial({
        color: 0x4488ff,
        emissive: 0x2244aa,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.7
      });
      var water = new THREE.Mesh(waterGeo, waterMat);
      water.position.set(0, 0.8, 0);
      water.castShadow = false;
      group.add(water);

    } else if (type === 'training_dummy') {
      // Base
      var baseGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 12);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var base = new THREE.Mesh(baseGeo, woodMat);
      base.position.set(0, 0.15, 0);
      base.castShadow = true;
      group.add(base);

      // Post
      var postGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
      var post = new THREE.Mesh(postGeo, woodMat);
      post.position.set(0, 1.4, 0);
      post.castShadow = true;
      group.add(post);

      // Body (burlap-wrapped)
      var bodyGeo = new THREE.CylinderGeometry(0.4, 0.45, 1.2, 12);
      var burlapMat = new THREE.MeshPhongMaterial({ color: 0xc4a574 });
      var body = new THREE.Mesh(bodyGeo, burlapMat);
      body.position.set(0, 1.8, 0);
      body.castShadow = true;
      group.add(body);

      // Head
      var headGeo = new THREE.SphereGeometry(0.3, 12, 12);
      var head = new THREE.Mesh(headGeo, burlapMat);
      head.position.set(0, 2.6, 0);
      head.castShadow = true;
      group.add(head);

    } else if (type === 'fallen_log') {
      // Large log lying horizontally
      var logGeo = new THREE.CylinderGeometry(0.4, 0.45, 3, 12);
      var barkMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var log = new THREE.Mesh(logGeo, barkMat);
      log.position.set(0, 0.4, 0);
      log.rotation.z = Math.PI / 2;
      log.castShadow = true;
      group.add(log);

    } else if (type === 'bulletin_board') {
      // Posts
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var p = -1; p <= 1; p += 2) {
        var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
        var post = new THREE.Mesh(postGeo, postMat);
        post.position.set(p * 0.8, 1.25, 0);
        post.castShadow = true;
        group.add(post);
      }

      // Board
      var boardGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
      var boardMat = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
      var board = new THREE.Mesh(boardGeo, boardMat);
      board.position.set(0, 1.5, 0);
      board.castShadow = true;
      group.add(board);

    } else if (type === 'watering_well') {
      // Well base (stone cylinder)
      var wellGeo = new THREE.CylinderGeometry(1, 1.2, 1.5, 16);
      var stoneMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var well = new THREE.Mesh(wellGeo, stoneMat);
      well.position.set(0, 0.75, 0);
      well.castShadow = true;
      group.add(well);

      // Well posts
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var w = -1; w <= 1; w += 2) {
        var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
        var post = new THREE.Mesh(postGeo, postMat);
        post.position.set(w * 0.8, 1.75, 0);
        post.castShadow = true;
        group.add(post);
      }

      // Roof
      var roofGeo = new THREE.ConeGeometry(1.2, 0.8, 4);
      var roofMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.set(0, 3.2, 0);
      roof.castShadow = true;
      group.add(roof);

    } else if (type === 'reading_desk') {
      // Desk surface
      var topGeo = new THREE.BoxGeometry(1.5, 0.1, 1);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var top = new THREE.Mesh(topGeo, woodMat);
      top.position.set(0, 0.8, 0);
      top.castShadow = true;
      group.add(top);

      // Legs
      for (var dx = -1; dx <= 1; dx += 2) {
        for (var dz = -1; dz <= 1; dz += 2) {
          var legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
          var leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.set(dx * 0.6, 0.4, dz * 0.4);
          leg.castShadow = true;
          group.add(leg);
        }
      }

      // Book on desk
      var bookGeo = new THREE.BoxGeometry(0.3, 0.05, 0.4);
      var bookMat = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
      var book = new THREE.Mesh(bookGeo, bookMat);
      book.position.set(0, 0.88, 0);
      book.rotation.y = Math.PI / 6;
      book.castShadow = true;
      group.add(book);

    } else if (type === 'bookshelf') {
      // Frame
      var frameMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
      var shelfGeo = new THREE.BoxGeometry(2, 2.5, 0.4);
      var shelf = new THREE.Mesh(shelfGeo, frameMat);
      shelf.position.set(0, 1.25, 0);
      shelf.castShadow = true;
      group.add(shelf);

      // Books
      var bookColors = [0x8b0000, 0x006400, 0x00008b, 0x8b4513, 0x4b0082];
      for (var row = 0; row < 3; row++) {
        for (var col = 0; col < 5; col++) {
          var bookGeo = new THREE.BoxGeometry(0.3, 0.6, 0.15);
          var bookMat = new THREE.MeshPhongMaterial({ color: bookColors[(row + col) % bookColors.length] });
          var book = new THREE.Mesh(bookGeo, bookMat);
          book.position.set(-0.7 + col * 0.35, 0.3 + row * 0.7, 0.1);
          book.castShadow = true;
          group.add(book);
        }
      }

    } else if (type === 'market_stall') {
      // Posts
      var postMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      for (var mx = -1; mx <= 1; mx += 2) {
        for (var mz = -1; mz <= 1; mz += 2) {
          var postGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
          var post = new THREE.Mesh(postGeo, postMat);
          post.position.set(mx * 1, 1.25, mz * 1);
          post.castShadow = true;
          group.add(post);
        }
      }

      // Canopy
      var canopyGeo = new THREE.BoxGeometry(2.5, 0.1, 2.5);
      var canopyMat = new THREE.MeshPhongMaterial({ color: 0xd2691e });
      var canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.set(0, 2.5, 0);
      canopy.castShadow = true;
      group.add(canopy);

      // Counter
      var counterGeo = new THREE.BoxGeometry(2, 0.8, 1);
      var counterMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var counter = new THREE.Mesh(counterGeo, counterMat);
      counter.position.set(0, 0.4, 0);
      counter.castShadow = true;
      group.add(counter);

    } else if (type === 'town_bell') {
      // Bell post
      var postGeo = new THREE.CylinderGeometry(0.15, 0.2, 3, 8);
      var woodMat = new THREE.MeshPhongMaterial({ color: 0x6d4c41 });
      var post = new THREE.Mesh(postGeo, woodMat);
      post.position.set(0, 1.5, 0);
      post.castShadow = true;
      group.add(post);

      // Cross beam
      var beamGeo = new THREE.BoxGeometry(1.5, 0.15, 0.15);
      var beam = new THREE.Mesh(beamGeo, woodMat);
      beam.position.set(0, 2.8, 0);
      beam.castShadow = true;
      group.add(beam);

      // Bell
      var bellGeo = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      var bellMat = new THREE.MeshPhongMaterial({ color: 0xb8860b });
      var bell = new THREE.Mesh(bellGeo, bellMat);
      bell.position.set(0, 2.5, 0);
      bell.rotation.x = Math.PI;
      bell.castShadow = true;
      group.add(bell);

    } else if (type === 'street_lamp') {
      // Lamp post
      var postGeo = new THREE.CylinderGeometry(0.08, 0.1, 3, 8);
      var metalMat = new THREE.MeshPhongMaterial({ color: 0x2f2f2f });
      var post = new THREE.Mesh(postGeo, metalMat);
      post.position.set(0, 1.5, 0);
      post.castShadow = true;
      group.add(post);

      // Lamp housing
      var housingGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 6);
      var housingMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
      var housing = new THREE.Mesh(housingGeo, housingMat);
      housing.position.set(0, 3.2, 0);
      housing.castShadow = true;
      group.add(housing);

      // Light
      var lampLight = new THREE.PointLight(0xffdd88, 1.0, 12);
      lampLight.position.set(0, 3, 0);
      lampLight.castShadow = false;
      group.add(lampLight);

      group.userData.lampLight = lampLight;

    } else if (type === 'easel') {
      // Easel legs
      var legMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
      var leg1Geo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 8);
      var leg1 = new THREE.Mesh(leg1Geo, legMat);
      leg1.position.set(0, 0.9, 0.3);
      leg1.rotation.x = -0.2;
      leg1.castShadow = true;
      group.add(leg1);

      var leg2 = new THREE.Mesh(leg1Geo, legMat);
      leg2.position.set(-0.3, 0.9, -0.2);
      leg2.rotation.z = 0.2;
      leg2.rotation.x = 0.2;
      leg2.castShadow = true;
      group.add(leg2);

      var leg3 = new THREE.Mesh(leg1Geo, legMat);
      leg3.position.set(0.3, 0.9, -0.2);
      leg3.rotation.z = -0.2;
      leg3.rotation.x = 0.2;
      leg3.castShadow = true;
      group.add(leg3);

      // Canvas
      var canvasGeo = new THREE.BoxGeometry(1, 1.2, 0.05);
      var canvasMat = new THREE.MeshPhongMaterial({ color: 0xf5f5dc });
      var canvas = new THREE.Mesh(canvasGeo, canvasMat);
      canvas.position.set(0, 1.4, 0.2);
      canvas.rotation.x = -0.1;
      canvas.castShadow = true;
      group.add(canvas);

    } else if (type === 'piano') {
      // Piano body
      var bodyGeo = new THREE.BoxGeometry(1.5, 0.8, 1);
      var pianoMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
      var body = new THREE.Mesh(bodyGeo, pianoMat);
      body.position.set(0, 0.4, 0);
      body.castShadow = true;
      group.add(body);

      // Keyboard
      var keyboardGeo = new THREE.BoxGeometry(1.3, 0.05, 0.3);
      var keyboardMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
      var keyboard = new THREE.Mesh(keyboardGeo, keyboardMat);
      keyboard.position.set(0, 0.85, 0.4);
      keyboard.castShadow = true;
      group.add(keyboard);

      // Legs
      for (var px = -1; px <= 1; px += 2) {
        for (var pz = -1; pz <= 1; pz += 2) {
          var legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
          var leg = new THREE.Mesh(legGeo, pianoMat);
          leg.position.set(px * 0.6, 0.2, pz * 0.4);
          leg.castShadow = true;
          group.add(leg);
        }
      }
    }

    // Position the group
    group.position.set(position.x, baseY, position.z);

    // Store interactive metadata
    group.userData.isInteractive = true;
    group.userData.interactiveType = type;
    group.userData.originalEmissive = 0x000000;
    group.userData.highlighted = false;

    return group;
  }

  /**
   * Spawn all interactive objects for a specific zone
   */
  function spawnZoneInteractives(sceneCtx, zoneId) {
    if (!sceneCtx || !sceneCtx.scene) return;
    if (!INTERACTIVE_OBJECTS[zoneId]) return;

    var zoneObjects = INTERACTIVE_OBJECTS[zoneId];
    for (var i = 0; i < zoneObjects.length; i++) {
      var objDef = zoneObjects[i];
      var mesh = createInteractiveObject(objDef.type, objDef.position);

      if (mesh) {
        sceneCtx.scene.add(mesh);

        // Store interactive object data
        var interactiveData = {
          id: nextInteractiveId++,
          type: objDef.type,
          position: objDef.position,
          action: objDef.action,
          message: objDef.message,
          mesh: mesh,
          zone: zoneId
        };

        interactiveObjects.push(interactiveData);
        mesh.userData.interactiveId = interactiveData.id;
      }
    }
  }

  /**
   * Get the nearest interactive object within range
   */
  function getInteractiveAtPosition(x, z, range) {
    var nearestObj = null;
    var minDist = range;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      var dx = obj.position.x - x;
      var dz = obj.position.z - z;
      var dist = Math.sqrt(dx * dx + dz * dz);

      if (dist < minDist) {
        minDist = dist;
        nearestObj = obj;
      }
    }

    return nearestObj;
  }

  /**
   * Interact with an object by ID
   */
  function interactWithObject(objectId) {
    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (obj.id === objectId) {
        return {
          type: obj.type,
          action: obj.action,
          message: obj.message,
          zone: obj.zone
        };
      }
    }
    return null;
  }

  /**
   * Highlight interactive objects near the player
   */
  function updateInteractiveHighlights(playerX, playerZ, highlightRange) {
    if (!highlightRange) highlightRange = 3;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (!obj.mesh) continue;

      var dx = obj.position.x - playerX;
      var dz = obj.position.z - playerZ;
      var dist = Math.sqrt(dx * dx + dz * dz);

      var shouldHighlight = dist < highlightRange;

      if (shouldHighlight && !obj.mesh.userData.highlighted) {
        // Turn on highlight
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh && child.material) {
            if (child.material.emissive) {
              child.userData.originalEmissive = child.material.emissive.getHex();
              child.material.emissive.setHex(0x444400);
              child.material.emissiveIntensity = 0.3;
            }
          }
        });
        obj.mesh.userData.highlighted = true;
      } else if (!shouldHighlight && obj.mesh.userData.highlighted) {
        // Turn off highlight
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh && child.material) {
            if (child.material.emissive && child.userData.originalEmissive !== undefined) {
              child.material.emissive.setHex(child.userData.originalEmissive);
              child.material.emissiveIntensity = 0;
            }
          }
        });
        obj.mesh.userData.highlighted = false;
      }
    }
  }

  /**
   * Animate interactive objects (fire flicker, etc.)
   */
  function updateInteractiveAnimations(deltaTime) {
    var time = Date.now() * 0.001;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (!obj.mesh) continue;

      // Campfire light flicker
      if (obj.type === 'campfire' && obj.mesh.userData.fireLight) {
        var flicker = Math.sin(time * 5) * 0.3 + Math.sin(time * 13) * 0.2;
        obj.mesh.userData.fireLight.intensity = 1.5 + flicker;
      }

      // Street lamp gentle sway
      if (obj.type === 'street_lamp' && obj.mesh.userData.lampLight) {
        var sway = Math.sin(time * 0.5) * 0.05;
        obj.mesh.userData.lampLight.intensity = 1.0 + sway;
      }
    }
  }

  /**
   * Remove all interactive objects (for cleanup)
   */
  function clearInteractiveObjects(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    for (var i = 0; i < interactiveObjects.length; i++) {
      var obj = interactiveObjects[i];
      if (obj.mesh) {
        sceneCtx.scene.remove(obj.mesh);

        // Dispose geometries and materials
        obj.mesh.traverse(function(child) {
          if (child instanceof THREE.Mesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                for (var m = 0; m < child.material.length; m++) {
                  child.material[m].dispose();
                }
              } else {
                child.material.dispose();
              }
            }
          }
        });
      }
    }

    interactiveObjects = [];
    nextInteractiveId = 1;
  }

  /**
   * Get all interactive objects for a zone
   */
  function getZoneInteractives(zoneId) {
    var result = [];
    for (var i = 0; i < interactiveObjects.length; i++) {
      if (interactiveObjects[i].zone === zoneId) {
        result.push(interactiveObjects[i]);
      }
    }
    return result;
  }

  /**
   * Hover highlight state for interaction system
   */
  var highlightedObject = null;
  var originalMaterials = new Map();

  /**
   * Highlight a specific object for hover/interaction (golden glow)
   */
  function highlightObject(mesh) {
    if (!mesh) return;
    if (highlightedObject === mesh) return;

    // Unhighlight previous object first
    unhighlightObject();

    highlightedObject = mesh;

    // Store original emissive values and apply golden glow
    mesh.traverse(function(child) {
      if (child.isMesh && child.material) {
        originalMaterials.set(child, {
          emissive: child.material.emissive ? child.material.emissive.clone() : null,
          emissiveIntensity: child.material.emissiveIntensity || 0
        });

        // Apply golden highlight glow
        if (child.material.emissive) {
          child.material.emissive.set(0xDAA520); // Golden color
          child.material.emissiveIntensity = 0.4;
        }
      }
    });
  }

  /**
   * Remove highlight from currently highlighted object
   */
  function unhighlightObject() {
    if (!highlightedObject) return;

    // Restore original materials
    highlightedObject.traverse(function(child) {
      if (child.isMesh && originalMaterials.has(child)) {
        var orig = originalMaterials.get(child);
        if (orig.emissive && child.material.emissive) {
          child.material.emissive.copy(orig.emissive);
        }
        child.material.emissiveIntensity = orig.emissiveIntensity;
      }
    });

    originalMaterials.clear();
    highlightedObject = null;
  }

  // ========================================================================
  // END INTERACTIVE OBJECTS SYSTEM
  // ========================================================================

  /**
   * Get performance statistics
   */
  function getPerformanceStats() {
    var stats = {
      totalObjects: 0,
      visibleObjects: 0,
      activeAnimations: 0,
      loadedChunks: loadedChunks.size,
      estimatedTriangles: 0
    };

    // Count scene objects
    if (sceneContext && sceneContext.scene) {
      sceneContext.scene.traverse(function(obj) {
        stats.totalObjects++;
        if (obj.visible) {
          stats.visibleObjects++;
        }
        // Estimate triangles for meshes
        if (obj instanceof THREE.Mesh && obj.geometry) {
          if (obj.geometry.index) {
            stats.estimatedTriangles += obj.geometry.index.count / 3;
          } else if (obj.geometry.attributes && obj.geometry.attributes.position) {
            stats.estimatedTriangles += obj.geometry.attributes.position.count / 3;
          }
        }
      });
    }

    // Count active animations (objects in frustum)
    for (var i = 0; i < animatedObjects.length; i++) {
      if (animatedObjects[i].mesh && animatedObjects[i].mesh.userData.inFrustum !== false) {
        stats.activeAnimations++;
      }
    }

    stats.estimatedTriangles = Math.floor(stats.estimatedTriangles);

    return stats;
  }

  // ========================================================================
  // ZONE TRANSITION EFFECTS
  // ========================================================================

  var zoneBoundaryParticles = [];
  var fadeOverlay = null;

  /**
   * Screen fade transition effect
   * @param {Function} callback - Function to call when screen is fully faded
   */
  function fadeTransition(callback) {
    if (typeof document === 'undefined') {
      if (callback) callback();
      return;
    }

    // Create overlay if it doesn't exist
    if (!fadeOverlay) {
      fadeOverlay = document.createElement('div');
      fadeOverlay.style.position = 'fixed';
      fadeOverlay.style.top = '0';
      fadeOverlay.style.left = '0';
      fadeOverlay.style.width = '100%';
      fadeOverlay.style.height = '100%';
      fadeOverlay.style.backgroundColor = 'black';
      fadeOverlay.style.opacity = '0';
      fadeOverlay.style.pointerEvents = 'none';
      fadeOverlay.style.zIndex = '9999';
      fadeOverlay.style.transition = 'opacity 0.5s ease-in-out';
      document.body.appendChild(fadeOverlay);
    }

    // Fade to black
    fadeOverlay.style.opacity = '1';

    // Call callback at peak fade
    setTimeout(function() {
      if (callback) callback();

      // Fade back in
      setTimeout(function() {
        fadeOverlay.style.opacity = '0';
      }, 50);
    }, 500);
  }

  /**
   * Create zone boundary particles
   * @param {THREE.Scene} scene - The scene to add particles to
   */
  function createZoneBoundaryParticles(scene) {
    if (!scene) return;

    // Clear existing boundary particles
    for (var i = 0; i < zoneBoundaryParticles.length; i++) {
      scene.remove(zoneBoundaryParticles[i].mesh);
    }
    zoneBoundaryParticles = [];

    // Create particles along zone boundaries
    for (var zId in ZONES) {
      var zone = ZONES[zId];
      var particleCount = Math.floor(zone.radius / 3);

      for (var i = 0; i < particleCount; i++) {
        var angle = (i / particleCount) * Math.PI * 2;
        var radius = zone.radius * 0.95;
        var px = zone.cx + Math.cos(angle) * radius;
        var pz = zone.cz + Math.sin(angle) * radius;
        var py = terrainHeight(px, pz) + 2 + Math.random() * 3;

        var particleGeo = new THREE.SphereGeometry(0.1, 6, 6);
        var particleMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.6,
          transparent: true,
          opacity: 0.4
        });
        var particle = new THREE.Mesh(particleGeo, particleMat);
        particle.position.set(px, py, pz);
        particle.castShadow = false;
        scene.add(particle);

        zoneBoundaryParticles.push({
          mesh: particle,
          baseY: py,
          phase: Math.random() * Math.PI * 2,
          speed: 0.0005 + Math.random() * 0.0003
        });
      }
    }
  }

  /**
   * Update zone boundary particle animations
   * @param {Number} time - World time in milliseconds
   */
  function updateZoneBoundaryParticles(time) {
    for (var i = 0; i < zoneBoundaryParticles.length; i++) {
      var p = zoneBoundaryParticles[i];
      p.mesh.position.y = p.baseY + Math.sin(time * p.speed + p.phase) * 0.5;
      p.mesh.material.opacity = 0.3 + Math.sin(time * p.speed * 2 + p.phase) * 0.15;
    }
  }

  // ========================================================================
  // WILDLIFE AND NATURE EFFECTS SYSTEM
  // ========================================================================

  var wildlifeData = {
    butterflies: [],
    fireflies: [],
    birds: [],
    fishJumpers: [],
    initialized: false
  };

  /**
   * Initialize wildlife systems
   */
  function initWildlife(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var scene = sceneCtx.scene;

    clearWildlife(scene);

    // Butterflies in gardens zone
    var gardensZ = ZONES.gardens;
    var butterflyColors = [0xffff00, 0xffa500, 0x4169e1, 0xffffff, 0xff69b4];

    for (var i = 0; i < 7; i++) {
      var bfGeo = new THREE.BufferGeometry();
      var bfVerts = new Float32Array([0,0,0, 0.3,0,0.2, 0,0,0.4]);
      bfGeo.setAttribute('position', new THREE.BufferAttribute(bfVerts, 3));
      var bfMat = new THREE.MeshBasicMaterial({
        color: butterflyColors[i % butterflyColors.length],
        side: THREE.DoubleSide
      });
      var bf = new THREE.Mesh(bfGeo, bfMat);
      var angle = Math.random() * Math.PI * 2;
      var radius = Math.random() * gardensZ.radius * 0.6;
      bf.position.set(
        gardensZ.cx + Math.cos(angle) * radius,
        gardensZ.baseHeight + 1 + Math.random() * 2,
        gardensZ.cz + Math.sin(angle) * radius
      );
      scene.add(bf);
      wildlifeData.butterflies.push({
        mesh: bf, time: Math.random() * 100,
        speed: 0.5 + Math.random() * 0.5,
        pathAngle: Math.random() * Math.PI * 2,
        pathRadius: 10 + Math.random() * 15,
        baseY: bf.position.y,
        centerX: gardensZ.cx, centerZ: gardensZ.cz
      });
    }

    // Fireflies across multiple zones
    var ffZones = [
      { zone: ZONES.gardens, count: 8 },
      { zone: ZONES.wilds, count: 10 },
      { zone: ZONES.commons, count: 4 },
      { zone: ZONES.nexus, count: 3 }
    ];
    for (var zi = 0; zi < ffZones.length; zi++) {
      var zInfo = ffZones[zi];
      for (var fi = 0; fi < zInfo.count; fi++) {
        var ffGeo = new THREE.SphereGeometry(0.15, 8, 8);
        var ffMat = new THREE.MeshBasicMaterial({
          color: 0xffff99, transparent: true, opacity: 0
        });
        var ff = new THREE.Mesh(ffGeo, ffMat);
        var ffA = Math.random() * Math.PI * 2;
        var ffR = Math.random() * zInfo.zone.radius * 0.7;
        ff.position.set(
          zInfo.zone.cx + Math.cos(ffA) * ffR,
          zInfo.zone.baseHeight + 0.5 + Math.random() * 3,
          zInfo.zone.cz + Math.sin(ffA) * ffR
        );
        scene.add(ff);
        wildlifeData.fireflies.push({
          mesh: ff, time: Math.random() * 100,
          speed: 0.3 + Math.random() * 0.3,
          pulseSpeed: 2 + Math.random() * 2,
          baseY: ff.position.y,
          driftAngle: Math.random() * Math.PI * 2
        });
      }
    }

    // Bird flocks (V-formations orbiting world)
    for (var fli = 0; fli < 3; fli++) {
      var flock = {
        birds: [], centerAngle: (fli / 3) * Math.PI * 2,
        orbitRadius: 200, speed: 0.1 + Math.random() * 0.05,
        height: 40 + Math.random() * 20
      };
      var birdOffsets = [
        {x:0,z:0}, {x:-2,z:-3}, {x:-4,z:-6}, {x:2,z:-3}, {x:4,z:-6}
      ];
      for (var bi = 0; bi < birdOffsets.length; bi++) {
        var bGeo = new THREE.BufferGeometry();
        var bVerts = new Float32Array([0,0,0, -0.4,0,0.3, 0.4,0,0.3]);
        bGeo.setAttribute('position', new THREE.BufferAttribute(bVerts, 3));
        var bMat = new THREE.MeshBasicMaterial({
          color: 0x2c2c2c, side: THREE.DoubleSide
        });
        var bMesh = new THREE.Mesh(bGeo, bMat);
        bMesh.position.y = flock.height;
        scene.add(bMesh);
        flock.birds.push({
          mesh: bMesh, offsetX: birdOffsets[bi].x,
          offsetZ: birdOffsets[bi].z, flapTime: Math.random() * 10
        });
      }
      wildlifeData.birds.push(flock);
    }

    // Fish jumpers near water
    for (var fsi = 0; fsi < 3; fsi++) {
      var fGeo = new THREE.SphereGeometry(0.3, 8, 8);
      var fMat = new THREE.MeshBasicMaterial({
        color: 0x888888, transparent: true, opacity: 0
      });
      var fMesh = new THREE.Mesh(fGeo, fMat);
      scene.add(fMesh);
      wildlifeData.fishJumpers.push({
        mesh: fMesh, jumping: false, jumpTime: 0, jumpDuration: 0,
        startX: 0, startZ: 0, endX: 0, endZ: 0, waterHeight: 0,
        nextJumpDelay: Math.random() * 5 + 3
      });
    }

    wildlifeData.initialized = true;
  }

  /**
   * Update wildlife animations
   */
  function updateWildlife(sceneCtx, deltaTime, worldTime) {
    if (!wildlifeData.initialized || !sceneCtx) return;

    var isNight = worldTime > 1080 || worldTime < 360;
    var isDay = worldTime >= 360 && worldTime <= 1080;

    // Butterflies (daytime, gardens)
    for (var i = 0; i < wildlifeData.butterflies.length; i++) {
      var bf = wildlifeData.butterflies[i];
      bf.time += deltaTime * bf.speed;
      bf.mesh.visible = isDay;
      if (isDay) {
        bf.pathAngle += deltaTime * 0.3;
        var tx = bf.centerX + Math.cos(bf.pathAngle) * bf.pathRadius;
        var tz = bf.centerZ + Math.sin(bf.pathAngle) * bf.pathRadius;
        bf.mesh.position.x += (tx - bf.mesh.position.x) * 0.02;
        bf.mesh.position.z += (tz - bf.mesh.position.z) * 0.02;
        bf.mesh.position.y = bf.baseY + Math.sin(bf.time * 5) * 0.3;
        bf.mesh.rotation.y = Math.sin(bf.time * 8) * 0.3;
        bf.mesh.rotation.z = Math.sin(bf.time * 6) * 0.2;
      }
    }

    // Fireflies (nighttime)
    for (var fi = 0; fi < wildlifeData.fireflies.length; fi++) {
      var ff = wildlifeData.fireflies[fi];
      ff.time += deltaTime;
      if (isNight) {
        var pulse = 0.5 + Math.sin(ff.time * ff.pulseSpeed) * 0.5;
        ff.mesh.material.opacity = pulse * 0.8;
        ff.mesh.visible = true;
        ff.driftAngle += deltaTime * 0.2;
        ff.mesh.position.x += Math.cos(ff.driftAngle) * deltaTime * ff.speed;
        ff.mesh.position.z += Math.sin(ff.driftAngle) * deltaTime * ff.speed;
        ff.mesh.position.y = ff.baseY + Math.sin(ff.time * 0.5) * 0.5;
      } else {
        ff.mesh.material.opacity = 0;
        ff.mesh.visible = false;
      }
    }

    // Bird flocks (daytime)
    for (var fli = 0; fli < wildlifeData.birds.length; fli++) {
      var flock = wildlifeData.birds[fli];
      flock.centerAngle += deltaTime * flock.speed;
      var fcx = Math.cos(flock.centerAngle) * flock.orbitRadius;
      var fcz = 150 + Math.sin(flock.centerAngle) * flock.orbitRadius;
      for (var bi = 0; bi < flock.birds.length; bi++) {
        var bd = flock.birds[bi];
        bd.flapTime += deltaTime * 5;
        bd.mesh.visible = isDay;
        if (isDay) {
          var fa = flock.centerAngle;
          var rox = Math.cos(fa) * bd.offsetX - Math.sin(fa) * bd.offsetZ;
          var roz = Math.sin(fa) * bd.offsetX + Math.cos(fa) * bd.offsetZ;
          bd.mesh.position.set(fcx + rox, flock.height + Math.sin(bd.flapTime) * 0.5, fcz + roz);
          bd.mesh.rotation.y = fa + Math.PI / 2;
          bd.mesh.rotation.z = Math.sin(bd.flapTime * 2) * 0.1;
        }
      }
    }

    // Fish jumpers
    if (waterBodies && waterBodies.length > 0) {
      for (var fsi = 0; fsi < wildlifeData.fishJumpers.length; fsi++) {
        var fish = wildlifeData.fishJumpers[fsi];
        if (fish.jumping) {
          fish.jumpTime += deltaTime;
          var prog = fish.jumpTime / fish.jumpDuration;
          if (prog >= 1) {
            fish.jumping = false;
            fish.mesh.material.opacity = 0;
            fish.mesh.visible = false;
            fish.nextJumpDelay = Math.random() * 8 + 5;
          } else {
            fish.mesh.position.x = fish.startX + (fish.endX - fish.startX) * prog;
            fish.mesh.position.z = fish.startZ + (fish.endZ - fish.startZ) * prog;
            fish.mesh.position.y = fish.waterHeight + Math.sin(prog * Math.PI) * 2;
            fish.mesh.material.opacity = 1;
            fish.mesh.visible = true;
          }
        } else {
          fish.nextJumpDelay -= deltaTime;
          if (fish.nextJumpDelay <= 0) {
            var wb = waterBodies[Math.floor(Math.random() * waterBodies.length)];
            var ja = Math.random() * Math.PI * 2;
            var jr = Math.random() * 10;
            fish.startX = wb.centerX + Math.cos(ja) * jr;
            fish.startZ = wb.centerZ + Math.sin(ja) * jr;
            fish.waterHeight = wb.height;
            var jd = Math.random() * Math.PI * 2;
            var jDist = 1 + Math.random() * 2;
            fish.endX = fish.startX + Math.cos(jd) * jDist;
            fish.endZ = fish.startZ + Math.sin(jd) * jDist;
            fish.jumping = true;
            fish.jumpTime = 0;
            fish.jumpDuration = 0.8 + Math.random() * 0.4;
          }
        }
      }
    }
  }

  /**
   * Clear all wildlife from scene
   */
  function clearWildlife(scene) {
    if (!scene) return;
    var groups = ['butterflies', 'fireflies', 'fishJumpers'];
    for (var g = 0; g < groups.length; g++) {
      var arr = wildlifeData[groups[g]];
      for (var i = 0; i < arr.length; i++) {
        scene.remove(arr[i].mesh);
        if (arr[i].mesh.geometry) arr[i].mesh.geometry.dispose();
        if (arr[i].mesh.material) arr[i].mesh.material.dispose();
      }
    }
    for (var fli = 0; fli < wildlifeData.birds.length; fli++) {
      var flock = wildlifeData.birds[fli];
      for (var bi = 0; bi < flock.birds.length; bi++) {
        scene.remove(flock.birds[bi].mesh);
        if (flock.birds[bi].mesh.geometry) flock.birds[bi].mesh.geometry.dispose();
        if (flock.birds[bi].mesh.material) flock.birds[bi].mesh.material.dispose();
      }
    }
    wildlifeData.butterflies = [];
    wildlifeData.fireflies = [];
    wildlifeData.birds = [];
    wildlifeData.fishJumpers = [];
    wildlifeData.initialized = false;
  }

  // ========================================================================
  // ZONE AMBIENCE â€” Unique atmospheric particles per zone
  // ========================================================================

  var zoneAmbienceData = {
    initialized: false,
    particles: {} // zone name -> { points, velocities, offsets }
  };

  /**
   * Initialize zone ambience particles
   */
  function initZoneAmbience(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var scene = sceneCtx.scene;
    zoneAmbienceData.particles = {};

    // Define particle configs for each zone
    var configs = {
      nexus: {
        count: 40,
        color: 0xffd700, // golden
        size: 0.3,
        rangeX: 50, rangeY: 30, rangeZ: 50,
        velocityY: 0.5, // slow upward drift
        velocityX: 0.1, velocityZ: 0.1
      },
      gardens: {
        count: 50,
        color: 0x90ee90, // light green
        size: 0.25,
        rangeX: 70, rangeY: 25, rangeZ: 70,
        velocityY: 0.2,
        velocityX: 0.3, velocityZ: 0.2 // wind drift
      },
      athenaeum: {
        count: 35,
        color: 0x87ceeb, // sky blue
        size: 0.2,
        rangeX: 50, rangeY: 35, rangeZ: 50,
        velocityY: 0.15,
        velocityX: 0.05, velocityZ: 0.05
      },
      studio: {
        count: 45,
        color: null, // multi-color, set per particle
        size: 0.3,
        rangeX: 50, rangeY: 30, rangeZ: 50,
        velocityY: 0.25,
        velocityX: 0.15, velocityZ: 0.15
      },
      wilds: {
        count: 40,
        color: 0xffffff, // white mist
        size: 0.4,
        rangeX: 80, rangeY: 8, rangeZ: 80, // ground-level
        velocityY: 0.05,
        velocityX: 0.4, velocityZ: 0.1 // horizontal drift
      },
      agora: {
        count: 35,
        color: 0xffa500, // orange lantern glow
        size: 0.25,
        rangeX: 45, rangeY: 30, rangeZ: 45,
        velocityY: 0.3,
        velocityX: 0.1, velocityZ: 0.1
      },
      commons: {
        count: 40,
        color: 0xf5f5f5, // soft white smoke
        size: 0.35,
        rangeX: 45, rangeY: 35, rangeZ: 45,
        velocityY: 0.6, // rising
        velocityX: 0.15, velocityZ: 0.15
      },
      arena: {
        count: 35,
        color: 0xff4500, // red embers
        size: 0.2,
        rangeX: 45, rangeY: 40, rangeZ: 45,
        velocityY: 0.7, // embers rising
        velocityX: 0.2, velocityZ: 0.2
      }
    };

    // Create particle system for each zone
    for (var zoneName in configs) {
      if (!configs.hasOwnProperty(zoneName)) continue;
      var cfg = configs[zoneName];
      var zone = ZONES[zoneName];
      if (!zone) continue;

      var count = cfg.count;
      var positions = new Float32Array(count * 3);
      var colors = new Float32Array(count * 3);
      var sizes = new Float32Array(count);
      var velocities = [];
      var offsets = [];

      // Initialize particle attributes
      for (var i = 0; i < count; i++) {
        var i3 = i * 3;

        // Random position within zone range
        var rx = (Math.random() - 0.5) * cfg.rangeX;
        var ry = Math.random() * cfg.rangeY;
        var rz = (Math.random() - 0.5) * cfg.rangeZ;

        positions[i3] = zone.cx + rx;
        positions[i3 + 1] = zone.baseHeight + ry;
        positions[i3 + 2] = zone.cz + rz;

        // Store offsets for reset
        offsets.push({ x: rx, y: ry, z: rz });

        // Random velocity variation
        var vx = (Math.random() - 0.5) * cfg.velocityX;
        var vy = cfg.velocityY * (0.8 + Math.random() * 0.4);
        var vz = (Math.random() - 0.5) * cfg.velocityZ;
        velocities.push({ x: vx, y: vy, z: vz });

        // Color
        var particleColor;
        if (zoneName === 'studio') {
          // Random colors for studio
          var hue = Math.random();
          var rgb = hslToRgb(hue, 0.7, 0.6);
          colors[i3] = rgb.r;
          colors[i3 + 1] = rgb.g;
          colors[i3 + 2] = rgb.b;
        } else {
          var c = new THREE.Color(cfg.color);
          colors[i3] = c.r;
          colors[i3 + 1] = c.g;
          colors[i3 + 2] = c.b;
        }

        sizes[i] = cfg.size * (0.8 + Math.random() * 0.4);
      }

      // Create geometry and material
      var geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      var material = new THREE.PointsMaterial({
        size: cfg.size,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      var points = new THREE.Points(geometry, material);
      points.visible = false; // Start hidden
      scene.add(points);

      zoneAmbienceData.particles[zoneName] = {
        points: points,
        velocities: velocities,
        offsets: offsets,
        config: cfg,
        zone: zone
      };
    }

    zoneAmbienceData.initialized = true;
  }

  /**
   * Update zone ambience particles
   */
  function updateZoneAmbience(sceneCtx, playerZone, deltaTime) {
    if (!zoneAmbienceData.initialized) return;

    var dt = deltaTime / 1000; // convert to seconds

    for (var zoneName in zoneAmbienceData.particles) {
      if (!zoneAmbienceData.particles.hasOwnProperty(zoneName)) continue;
      var data = zoneAmbienceData.particles[zoneName];

      // Toggle visibility based on player zone
      var isCurrentZone = zoneName === playerZone;
      data.points.visible = isCurrentZone;

      if (!isCurrentZone) continue;

      // Update particle positions
      var positions = data.points.geometry.attributes.position.array;
      var zone = data.zone;
      var cfg = data.config;

      for (var i = 0; i < data.velocities.length; i++) {
        var i3 = i * 3;
        var vel = data.velocities[i];
        var offset = data.offsets[i];

        // Apply velocity
        positions[i3] += vel.x * dt;
        positions[i3 + 1] += vel.y * dt;
        positions[i3 + 2] += vel.z * dt;

        // Wrap particles within zone bounds
        var localX = positions[i3] - zone.cx;
        var localY = positions[i3 + 1] - zone.baseHeight;
        var localZ = positions[i3 + 2] - zone.cz;

        // Reset particles that drift too far
        if (Math.abs(localX) > cfg.rangeX * 0.6 ||
            localY > cfg.rangeY || localY < 0 ||
            Math.abs(localZ) > cfg.rangeZ * 0.6) {
          // Reset to random position
          positions[i3] = zone.cx + (Math.random() - 0.5) * cfg.rangeX;
          positions[i3 + 1] = zone.baseHeight + Math.random() * cfg.rangeY * 0.3;
          positions[i3 + 2] = zone.cz + (Math.random() - 0.5) * cfg.rangeZ;
        }
      }

      data.points.geometry.attributes.position.needsUpdate = true;
    }
  }

  // ========================================================================
  // SEASONAL VISUALS â€” Atmospheric particles and lighting tints per season
  // ========================================================================

  var seasonalParticleData = {
    initialized: false,
    points: null,
    velocities: [],
    season: null,
    elapsed: 0
  };

  // Seasonal particle configs â€” subtle counts, gentle motion
  var SEASONAL_PARTICLE_CONFIGS = {
    spring: {
      count: 28,
      color: 0xffc0db,        // cherry blossom pink
      size: 0.28,
      rangeX: 60, rangeY: 22, rangeZ: 60,
      velocityX: 0.6,         // gentle sideways drift
      velocityY: -0.4,        // fall downward
      velocityZ: 0.3,
      resetAtTop: true        // respawn at top when reaching ground
    },
    summer: {
      count: 20,
      color: 0xccff66,        // yellow-green fireflies
      size: 0.22,
      rangeX: 50, rangeY: 18, rangeZ: 50,
      velocityX: 0.35,
      velocityY: 0.2,         // gentle upward float
      velocityZ: 0.35,
      nightOnly: true,        // only visible when nightFactor > 0.3
      resetAtTop: false
    },
    autumn: {
      count: 24,
      color: 0xd46020,        // orange-red falling leaf
      size: 0.32,
      rangeX: 60, rangeY: 24, rangeZ: 60,
      velocityX: 0.7,
      velocityY: -0.55,       // fall faster than petals
      velocityZ: 0.4,
      resetAtTop: true
    },
    winter: {
      count: 32,
      color: 0xe8f4ff,        // pale blue-white snowflake
      size: 0.20,
      rangeX: 55, rangeY: 26, rangeZ: 55,
      velocityX: 0.25,
      velocityY: -0.28,       // slow gentle fall
      velocityZ: 0.18,
      resetAtTop: true
    }
  };

  /**
   * Initialize the global seasonal particle system.
   * Creates a single Points object that follows the player camera.
   */
  function initSeasonalParticles(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Resolve Seasons lazily (may not exist at module parse time)
    if (!Seasons && typeof window !== 'undefined' && window.Seasons) {
      Seasons = window.Seasons;
    }
    if (!Seasons) return;

    var season = Seasons.getCurrentSeason();
    var cfg = SEASONAL_PARTICLE_CONFIGS[season.id];
    if (!cfg) return;

    var count = cfg.count;
    var positions = new Float32Array(count * 3);
    var colors = new Float32Array(count * 3);
    var velocities = [];

    var baseColor = new THREE.Color(cfg.color);

    for (var i = 0; i < count; i++) {
      var i3 = i * 3;

      // Scatter relative to origin; will be repositioned around camera each frame
      positions[i3]     = (Math.random() - 0.5) * cfg.rangeX;
      positions[i3 + 1] = Math.random() * cfg.rangeY;
      positions[i3 + 2] = (Math.random() - 0.5) * cfg.rangeZ;

      // Slight color variation per particle
      var variation = 0.85 + Math.random() * 0.3;
      colors[i3]     = Math.min(1, baseColor.r * variation);
      colors[i3 + 1] = Math.min(1, baseColor.g * variation);
      colors[i3 + 2] = Math.min(1, baseColor.b * variation);

      // Per-particle velocity variation
      velocities.push({
        x: (Math.random() - 0.5) * cfg.velocityX,
        y: cfg.velocityY * (0.7 + Math.random() * 0.6),
        z: (Math.random() - 0.5) * cfg.velocityZ,
        phase: Math.random() * Math.PI * 2  // swirl/bob phase
      });
    }

    var geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color',    new THREE.BufferAttribute(colors, 3));

    var material = new THREE.PointsMaterial({
      size: cfg.size,
      vertexColors: true,
      transparent: true,
      opacity: 0.72,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      fog: false
    });

    // Remove previous seasonal points if reinitializing
    if (seasonalParticleData.points) {
      sceneCtx.scene.remove(seasonalParticleData.points);
      seasonalParticleData.points.geometry.dispose();
      seasonalParticleData.points.material.dispose();
    }

    var points = new THREE.Points(geometry, material);
    points.frustumCulled = false;
    sceneCtx.scene.add(points);

    seasonalParticleData.points = points;
    seasonalParticleData.velocities = velocities;
    seasonalParticleData.season = season.id;
    seasonalParticleData.elapsed = 0;
    seasonalParticleData.config = cfg;
    seasonalParticleData.initialized = true;
  }

  /**
   * Update seasonal visuals: particle motion, lighting tints, fog tint.
   * Call this from the game loop every frame.
   *
   * @param {Object}  sceneCtx       - Scene context with scene, ambientLight, etc.
   * @param {string}  playerZone     - Current player zone name (unused for now, reserved)
   * @param {number}  deltaTime      - Frame delta in ms
   * @param {number}  normalizedTime - 0..1 time of day (0=midnight, 0.5=noon)
   */
  function updateSeasonalVisuals(sceneCtx, playerZone, deltaTime, normalizedTime) {
    // Resolve Seasons lazily
    if (!Seasons && typeof window !== 'undefined' && window.Seasons) {
      Seasons = window.Seasons;
    }
    if (!Seasons || !sceneCtx) return;

    var dt = (deltaTime || 16) / 1000; // seconds

    // ---- 1. Reinitialize if season has changed ----
    var currentSeasonId = Seasons.getCurrentSeason().id;
    if (!seasonalParticleData.initialized || seasonalParticleData.season !== currentSeasonId) {
      initSeasonalParticles(sceneCtx);
    }

    // ---- 2. Seasonal ambient light tint ----
    var seasonColors = Seasons.getSeasonalColors();
    if (sceneCtx.ambientLight && seasonColors) {
      // Parse hex string like '#ffe8f0' to a THREE.Color
      var ambientHex = seasonColors.ambient;
      var seasonAmbient = new THREE.Color(ambientHex);

      // Blend existing ambient ground color with seasonal tint (20% seasonal, 80% base)
      var TINT_STRENGTH = 0.18;
      var existingGroundColor = sceneCtx.ambientLight.groundColor;
      if (existingGroundColor) {
        var blendedR = existingGroundColor.r * (1 - TINT_STRENGTH) + seasonAmbient.r * TINT_STRENGTH;
        var blendedG = existingGroundColor.g * (1 - TINT_STRENGTH) + seasonAmbient.g * TINT_STRENGTH;
        var blendedB = existingGroundColor.b * (1 - TINT_STRENGTH) + seasonAmbient.b * TINT_STRENGTH;
        sceneCtx.ambientLight.groundColor.setRGB(blendedR, blendedG, blendedB);
      }
    }

    // ---- 3. Seasonal fog color tint (very subtle) ----
    if (sceneCtx.scene && sceneCtx.scene.fog && seasonColors) {
      var accentHex = seasonColors.accent;
      var seasonAccent = new THREE.Color(accentHex);
      var currentFogColor = sceneCtx.scene.fog.color;
      var FOG_TINT = 0.08; // very gentle
      currentFogColor.r = currentFogColor.r * (1 - FOG_TINT) + seasonAccent.r * FOG_TINT;
      currentFogColor.g = currentFogColor.g * (1 - FOG_TINT) + seasonAccent.g * FOG_TINT;
      currentFogColor.b = currentFogColor.b * (1 - FOG_TINT) + seasonAccent.b * FOG_TINT;
    }

    // ---- 4. Update seasonal particles ----
    if (!seasonalParticleData.initialized || !seasonalParticleData.points) return;

    var ntNorm = normalizedTime !== undefined ? normalizedTime : 0.5;
    // Night factor: 0 = full day, 1 = full night
    var nightFactor = 0;
    if (ntNorm < 0.2) {
      nightFactor = 1.0;
    } else if (ntNorm < 0.3) {
      nightFactor = 1.0 - (ntNorm - 0.2) / 0.1;
    } else if (ntNorm > 0.8) {
      nightFactor = (ntNorm - 0.8) / 0.2;
    }

    var cfg = seasonalParticleData.config;

    // Summer fireflies only visible at night (nightFactor > 0.3)
    if (cfg.nightOnly) {
      seasonalParticleData.points.visible = nightFactor > 0.3;
      if (!seasonalParticleData.points.visible) return;
      seasonalParticleData.points.material.opacity = 0.6 * nightFactor;
    } else {
      seasonalParticleData.points.visible = true;
    }

    seasonalParticleData.elapsed += dt;

    var positions = seasonalParticleData.points.geometry.attributes.position.array;
    var velocities = seasonalParticleData.velocities;
    var camX = 0, camY = 10, camZ = 0;
    if (sceneCtx.camera) {
      camX = sceneCtx.camera.position.x;
      camY = sceneCtx.camera.position.y;
      camZ = sceneCtx.camera.position.z;
    }

    var halfX = cfg.rangeX * 0.5;
    var halfZ = cfg.rangeZ * 0.5;

    for (var i = 0; i < velocities.length; i++) {
      var i3 = i * 3;
      var vel = velocities[i];

      // Swirl / bob oscillation adds organic motion
      var swirl = Math.sin(seasonalParticleData.elapsed * 0.8 + vel.phase) * 0.3;

      positions[i3]     += (vel.x + swirl * 0.4) * dt;
      positions[i3 + 1] += vel.y * dt;
      positions[i3 + 2] += (vel.z + swirl * 0.3) * dt;

      // Reset logic: wrap around camera so particles always surround player
      var localX = positions[i3]     - camX;
      var localY = positions[i3 + 1] - camY;
      var localZ = positions[i3 + 2] - camZ;

      var needsReset = false;
      if (Math.abs(localX) > halfX || Math.abs(localZ) > halfZ) needsReset = true;
      if (cfg.resetAtTop && localY < -2) needsReset = true;  // fell below camera
      if (!cfg.resetAtTop && localY > cfg.rangeY) needsReset = true; // floated too high (firefly)

      if (needsReset) {
        // Respawn at random position in the field around camera
        positions[i3]     = camX + (Math.random() - 0.5) * cfg.rangeX;
        positions[i3 + 2] = camZ + (Math.random() - 0.5) * cfg.rangeZ;
        if (cfg.resetAtTop) {
          // Falling particles start high
          positions[i3 + 1] = camY + cfg.rangeY * (0.5 + Math.random() * 0.5);
        } else {
          // Rising particles start near ground
          positions[i3 + 1] = camY - cfg.rangeY * 0.4 + Math.random() * 4;
        }
      }
    }

    seasonalParticleData.points.geometry.attributes.position.needsUpdate = true;
  }

  // Helper function for HSL to RGB conversion (for studio particles)
  function hslToRgb(h, s, l) {
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var hue2rgb = function(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return { r: r, g: g, b: b };
  }

  // ========================================================================
  // WORLD MEMORY â€” Footpaths, Gathering Spots, Flowers
  // ========================================================================

  var worldMemory = {};
  var worldMemoryLastStep = 0;
  var MEMORY_GRID_SIZE = 4;
  var MEMORY_MAX_CELLS = 2000;
  var stillTimer = 0;
  var lastPlayerVelocity = 0;
  var lastPlayerPos = null;

  function loadWorldMemory() {
    if (typeof localStorage === 'undefined') return;
    try {
      var stored = localStorage.getItem('zion_worldMemory');
      if (stored) {
        worldMemory = JSON.parse(stored);
        // Apply decay on load
        var keys = Object.keys(worldMemory);
        for (var i = keys.length - 1; i >= 0; i--) {
          var cell = worldMemory[keys[i]];
          cell.steps *= 0.9;
          cell.gathering *= 0.95;
          if (cell.steps < 1 && cell.gathering < 1 && !cell.flowers) {
            delete worldMemory[keys[i]];
          }
        }
      }
    } catch(e) {}
  }

  function saveWorldMemory() {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem('zion_worldMemory', JSON.stringify(worldMemory));
    } catch(e) {}
  }

  function memoryKey(x, z) {
    return Math.floor(x / MEMORY_GRID_SIZE) + '_' + Math.floor(z / MEMORY_GRID_SIZE);
  }

  function recordStep(x, z) {
    var key = memoryKey(x, z);
    if (!worldMemory[key]) {
      worldMemory[key] = { steps: 0, lastStep: 0, gathering: 0, flowers: false };
    }
    worldMemory[key].steps++;
    worldMemory[key].lastStep = Date.now();

    // Cap at max cells
    var keys = Object.keys(worldMemory);
    if (keys.length > MEMORY_MAX_CELLS) {
      keys.sort(function(a, b) { return worldMemory[a].steps - worldMemory[b].steps; });
      var toRemove = keys.length - MEMORY_MAX_CELLS;
      for (var i = 0; i < toRemove; i++) {
        if (!worldMemory[keys[i]].flowers) delete worldMemory[keys[i]];
      }
    }
  }

  function updateWorldMemory(playerPos, nearbyEntities, deltaTime) {
    if (!playerPos) return;
    var now = Date.now();

    // Record step every 500ms
    if (now - worldMemoryLastStep > 500) {
      recordStep(playerPos.x, playerPos.z);
      worldMemoryLastStep = now;
    }

    // Track velocity for stillness
    var velocity = 0;
    if (lastPlayerPos) {
      var dx = playerPos.x - lastPlayerPos.x;
      var dz = playerPos.z - lastPlayerPos.z;
      velocity = Math.sqrt(dx * dx + dz * dz) / Math.max(deltaTime, 0.001);
    }
    lastPlayerPos = { x: playerPos.x, y: playerPos.y, z: playerPos.z };
    lastPlayerVelocity = velocity;

    if (velocity < 0.5) {
      stillTimer += deltaTime;
    } else {
      stillTimer = 0;
    }

    var key = memoryKey(playerPos.x, playerPos.z);
    if (!worldMemory[key]) {
      worldMemory[key] = { steps: 0, lastStep: 0, gathering: 0, flowers: false };
    }

    // Gathering detection: still 10+ seconds near entity
    if (stillTimer >= 10 && nearbyEntities > 0) {
      worldMemory[key].gathering++;
    }

    // Flower growth: still 30+ seconds alone
    if (stillTimer >= 30 && nearbyEntities === 0) {
      worldMemory[key].flowers = true;
    }

    // Periodically save (every 10 seconds)
    if (now % 10000 < 500) {
      saveWorldMemory();
    }
  }

  function getMemoryAtPosition(wx, wz) {
    var key = memoryKey(wx, wz);
    return worldMemory[key] || null;
  }

  // ========================================================================
  // BILLBOARD CLOUDS
  // ========================================================================

  var billboardClouds = [];

  function initBillboardClouds(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;
    var cloudCount = 8 + Math.floor(Math.random() * 5); // 8-12

    for (var i = 0; i < cloudCount; i++) {
      var group = new THREE.Group();
      var puffCount = 4 + Math.floor(Math.random() * 3); // 4-6

      for (var p = 0; p < puffCount; p++) {
        var radius = 3 + Math.random() * 4;
        var puffGeo = new THREE.SphereGeometry(radius, 8, 6);
        var puffMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5 + Math.random() * 0.2,
          fog: false,
          depthWrite: false
        });
        var puff = new THREE.Mesh(puffGeo, puffMat);
        puff.position.set(
          (Math.random() - 0.5) * 8,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 6
        );
        puff.scale.y = 0.5 + Math.random() * 0.3; // flatten
        group.add(puff);
      }

      group.position.set(
        (Math.random() - 0.5) * 500,
        80 + Math.random() * 40,
        (Math.random() - 0.5) * 500
      );
      group.userData.driftSpeed = 0.5 + Math.random() * 1.0;
      group.userData.driftAngle = Math.random() * Math.PI * 2;
      group.visible = false; // hidden until weather needs them

      sceneCtx.scene.add(group);
      billboardClouds.push(group);
    }
  }

  function updateBillboardClouds(deltaTime, weatherType) {
    var showClouds = (weatherType === 'cloudy' || weatherType === 'rain' || weatherType === 'storm');
    for (var i = 0; i < billboardClouds.length; i++) {
      var cloud = billboardClouds[i];
      cloud.visible = showClouds;
      if (!showClouds) continue;

      cloud.position.x += Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;
      cloud.position.z += Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * deltaTime;

      // Wrap around
      if (cloud.position.x > 300) cloud.position.x = -300;
      if (cloud.position.x < -300) cloud.position.x = 300;
      if (cloud.position.z > 300) cloud.position.z = -300;
      if (cloud.position.z < -300) cloud.position.z = 300;
    }
  }

  // ========================================================================
  // RAIN SPLASH PARTICLES
  // ========================================================================

  var splashPool = [];
  var splashMesh = null;
  var MAX_SPLASHES = 200;

  function initRainSplashes(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    var geo = new THREE.BufferGeometry();
    var positions = new Float32Array(MAX_SPLASHES * 3);
    var sizes = new Float32Array(MAX_SPLASHES);

    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    var mat = new THREE.PointsMaterial({
      color: 0xaaddff,
      size: 0.3,
      transparent: true,
      opacity: 0.5,
      depthWrite: false,
      sizeAttenuation: true
    });

    splashMesh = new THREE.Points(geo, mat);
    sceneCtx.scene.add(splashMesh);

    for (var i = 0; i < MAX_SPLASHES; i++) {
      splashPool.push({
        active: false,
        x: 0, y: 0, z: 0,
        vx: 0, vy: 0, vz: 0,
        life: 0, maxLife: 0.3
      });
    }
  }

  function spawnSplash(x, y, z) {
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < splashPool.length; j++) {
        if (!splashPool[j].active) {
          splashPool[j].active = true;
          splashPool[j].x = x;
          splashPool[j].y = y;
          splashPool[j].z = z;
          splashPool[j].vx = (Math.random() - 0.5) * 2;
          splashPool[j].vy = 1 + Math.random() * 2;
          splashPool[j].vz = (Math.random() - 0.5) * 2;
          splashPool[j].life = 0;
          break;
        }
      }
    }
  }

  function updateRainSplashes(deltaTime) {
    if (!splashMesh) return;
    var positions = splashMesh.geometry.attributes.position.array;
    var sizes = splashMesh.geometry.attributes.size.array;

    for (var i = 0; i < splashPool.length; i++) {
      var sp = splashPool[i];
      if (sp.active) {
        sp.life += deltaTime * 0.001;
        sp.x += sp.vx * deltaTime * 0.001;
        sp.y += (sp.vy - 9.8 * sp.life) * deltaTime * 0.001;
        sp.z += sp.vz * deltaTime * 0.001;

        if (sp.life >= sp.maxLife) {
          sp.active = false;
        }

        positions[i * 3] = sp.x;
        positions[i * 3 + 1] = sp.y;
        positions[i * 3 + 2] = sp.z;
        sizes[i] = sp.active ? (0.3 * (1 - sp.life / sp.maxLife)) : 0;
      } else {
        sizes[i] = 0;
      }
    }

    splashMesh.geometry.attributes.position.needsUpdate = true;
    splashMesh.geometry.attributes.size.needsUpdate = true;
  }

  // ========================================================================
  // LIGHTNING BOLT GEOMETRY
  // ========================================================================

  var lightningBoltMesh = null;
  var lightningBoltTimer = 0;

  function createLightningBolt(sceneCtx, startX, startZ) {
    if (!sceneCtx || !sceneCtx.scene) return;
    // Remove old bolt
    if (lightningBoltMesh) {
      sceneCtx.scene.remove(lightningBoltMesh);
      lightningBoltMesh.geometry.dispose();
      lightningBoltMesh.material.dispose();
      lightningBoltMesh = null;
    }

    var segments = 5 + Math.floor(Math.random() * 3);
    var startY = 75 + Math.random() * 15;
    var groundY = terrainHeight(startX, startZ);
    var points = [];

    for (var i = 0; i <= segments; i++) {
      var t = i / segments;
      var y = startY + (groundY - startY) * t;
      var jitterX = (Math.random() - 0.5) * 12 * (1 - t * 0.5);
      var jitterZ = (Math.random() - 0.5) * 12 * (1 - t * 0.5);
      points.push(new THREE.Vector3(startX + jitterX, y, startZ + jitterZ));
    }

    var geo = new THREE.BufferGeometry().setFromPoints(points);
    var mat = new THREE.LineBasicMaterial({
      color: 0xeeeeff,
      linewidth: 2,
      transparent: true,
      opacity: 1.0
    });

    lightningBoltMesh = new THREE.Line(geo, mat);
    sceneCtx.scene.add(lightningBoltMesh);
    lightningBoltTimer = 0.15; // visible for 150ms
  }

  function updateLightningBolt(sceneCtx, deltaTime) {
    if (!lightningBoltMesh) return;
    lightningBoltTimer -= deltaTime * 0.001;
    if (lightningBoltTimer <= 0) {
      if (sceneCtx && sceneCtx.scene) {
        sceneCtx.scene.remove(lightningBoltMesh);
      }
      lightningBoltMesh.geometry.dispose();
      lightningBoltMesh.material.dispose();
      lightningBoltMesh = null;
    } else {
      lightningBoltMesh.material.opacity = lightningBoltTimer / 0.15;
    }
  }

  // ========================================================================
  // SNOW ACCUMULATION
  // ========================================================================

  var snowAccumulating = false;
  var snowAccumTimer = 0;

  function updateSnowAccumulation(deltaTime, weatherType) {
    var isSnow = (weatherType === 'snow');
    snowAccumulating = isSnow;

    snowAccumTimer += deltaTime;
    if (snowAccumTimer < 2000) return; // every 2 seconds
    snowAccumTimer = 0;

    loadedChunks.forEach(function(chunk) {
      if (!chunk.group) return;
      var terrain = chunk.group.children[0]; // first child is terrain mesh
      if (!terrain || !terrain.geometry || !terrain.geometry.attributes.color) return;

      var colors = terrain.geometry.attributes.color.array;

      // Store original colors on first encounter
      if (!terrain.userData.originalColors) {
        terrain.userData.originalColors = new Float32Array(colors);
      }

      var origColors = terrain.userData.originalColors;

      if (isSnow) {
        // Lerp 2% toward white
        for (var i = 0; i < colors.length; i += 3) {
          colors[i] += (0.95 - colors[i]) * 0.02;
          colors[i + 1] += (0.95 - colors[i + 1]) * 0.02;
          colors[i + 2] += (0.98 - colors[i + 2]) * 0.02;
        }
      } else {
        // Lerp 1% back toward original
        for (var j = 0; j < colors.length; j += 3) {
          colors[j] += (origColors[j] - colors[j]) * 0.01;
          colors[j + 1] += (origColors[j + 1] - colors[j + 1]) * 0.01;
          colors[j + 2] += (origColors[j + 2] - colors[j + 2]) * 0.01;
        }
      }

      terrain.geometry.attributes.color.needsUpdate = true;
    });
  }

  // ========================================================================
  // VALLEY FOG
  // ========================================================================

  var fogPlanes = [];

  function initValleyFog(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    // Sample terrain to find valleys
    var valleySpots = [];
    for (var x = -400; x < 400; x += 80) {
      for (var z = -400; z < 400; z += 80) {
        var h = terrainHeight(x, z);
        if (h < -2) {
          valleySpots.push({ x: x, z: z, h: h });
        }
      }
    }

    // Place up to 8 fog planes
    var count = Math.min(8, valleySpots.length);
    for (var i = 0; i < count; i++) {
      var spot = valleySpots[i];
      var fogGeo = new THREE.PlaneBufferGeometry(40, 40);
      var fogMat = new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        transparent: true,
        opacity: 0.15 + Math.random() * 0.1,
        depthWrite: false,
        side: THREE.DoubleSide,
        fog: false
      });

      var fogMesh = new THREE.Mesh(fogGeo, fogMat);
      fogMesh.rotation.x = -Math.PI / 2;
      fogMesh.position.set(spot.x, spot.h + 2, spot.z);
      fogMesh.userData.baseY = spot.h + 2;
      fogMesh.userData.bobPhase = Math.random() * Math.PI * 2;
      fogMesh.visible = false;

      sceneCtx.scene.add(fogMesh);
      fogPlanes.push(fogMesh);
    }
  }

  function updateValleyFog(worldTime, weatherType) {
    // Show during morning (dawn: 300-420) and rain/storm
    var isDawn = (worldTime >= 240 && worldTime <= 480);
    var isRain = (weatherType === 'rain' || weatherType === 'storm');
    var showFog = isDawn || isRain;
    var time = Date.now() * 0.001;

    for (var i = 0; i < fogPlanes.length; i++) {
      var fp = fogPlanes[i];
      fp.visible = showFog;
      if (!showFog) continue;

      // Gentle vertical bob
      fp.position.y = fp.userData.baseY + Math.sin(time * 0.3 + fp.userData.bobPhase) * 0.5;
    }
  }

  // ========================================================================
  // TERRAIN BREATHING â€” Subtle undulation making the world feel alive
  // ========================================================================

  var terrainBreathTime = 0;

  function updateTerrainBreathing(deltaTime, worldTime) {
    terrainBreathTime += deltaTime;

    // Only update every 3rd frame for performance
    if (Math.floor(terrainBreathTime * 60) % 3 !== 0) return;

    loadedChunks.forEach(function(chunk) {
      if (!chunk.group) return;
      var terrain = chunk.group.children[0];
      if (!terrain || !terrain.geometry || !terrain.geometry.attributes.position) return;

      var positions = terrain.geometry.attributes.position.array;

      // Store base heights on first encounter
      if (!terrain.userData.baseHeights) {
        terrain.userData.baseHeights = new Float32Array(positions.length / 3);
        for (var i = 0; i < positions.length; i += 3) {
          terrain.userData.baseHeights[i / 3] = positions[i + 1]; // Y component
        }
      }

      var baseHeights = terrain.userData.baseHeights;
      var time = terrainBreathTime;
      var wx = terrain.position.x;
      var wz = terrain.position.z;

      for (var j = 0; j < positions.length; j += 3) {
        var localX = positions[j] + wx;
        var localZ = positions[j + 2] + wz;
        var breathOffset = Math.sin(time * 0.3 + localX * 0.02 + localZ * 0.015) * 0.12;
        breathOffset += Math.sin(time * 0.5 + localX * 0.01 - localZ * 0.02) * 0.06;
        positions[j + 1] = baseHeights[j / 3] + breathOffset;
      }

      terrain.geometry.attributes.position.needsUpdate = true;
      terrain.geometry.computeVertexNormals();
    });
  }

  // ========================================================================
  // WIND SYSTEM â€” Synced gusts affecting trees and weather
  // ========================================================================

  var windState = { strength: 1.0, gustTimer: 0, gustTarget: 1.0 };

  function updateWindSystem(deltaTime, weatherType) {
    // Wind strength varies by weather
    var baseWind = 1.0;
    if (weatherType === 'storm') baseWind = 3.0;
    else if (weatherType === 'rain') baseWind = 1.5;
    else if (weatherType === 'cloudy') baseWind = 1.2;
    else if (weatherType === 'snow') baseWind = 0.8;

    // Periodic gusts
    windState.gustTimer += deltaTime;
    if (windState.gustTimer > 3 + Math.random() * 5) {
      windState.gustTarget = baseWind * (0.7 + Math.random() * 0.6);
      windState.gustTimer = 0;
    }

    // Smooth lerp to target
    windState.strength += (windState.gustTarget - windState.strength) * deltaTime * 0.5;
    windState.strength = Math.max(0.3, Math.min(windState.strength, baseWind * 1.3));
  }

  function getWindStrength() {
    return windState.strength;
  }

  // ========================================================================
  // ZONE BOUNDARY SHIMMER ENHANCEMENT
  // ========================================================================

  var zoneBorderParticles = [];

  function initZoneBorderShimmer(sceneCtx) {
    if (!sceneCtx || !sceneCtx.scene) return;

    for (var zId in ZONES) {
      var zone = ZONES[zId];
      if (!zone.radius) continue;

      // Create ring of shimmer particles at zone boundary
      var particleCount = 60;
      var geo = new THREE.BufferGeometry();
      var positions = new Float32Array(particleCount * 3);
      var colors = new Float32Array(particleCount * 3);

      var zoneColor = zone.groundColor || 0x88aa88;
      var cr = ((zoneColor >> 16) & 0xff) / 255;
      var cg = ((zoneColor >> 8) & 0xff) / 255;
      var cb = (zoneColor & 0xff) / 255;

      for (var i = 0; i < particleCount; i++) {
        var angle = (i / particleCount) * Math.PI * 2;
        var r = zone.radius;
        positions[i * 3] = zone.cx + Math.cos(angle) * r;
        positions[i * 3 + 1] = terrainHeight(zone.cx + Math.cos(angle) * r, zone.cz + Math.sin(angle) * r) + 1;
        positions[i * 3 + 2] = zone.cz + Math.sin(angle) * r;

        colors[i * 3] = cr;
        colors[i * 3 + 1] = cg;
        colors[i * 3 + 2] = cb;
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      var mat = new THREE.PointsMaterial({
        size: 0.8,
        transparent: true,
        opacity: 0.3,
        vertexColors: true,
        depthWrite: false,
        sizeAttenuation: true
      });

      var points = new THREE.Points(geo, mat);
      points.userData.zoneId = zId;
      points.userData.basePositions = new Float32Array(positions);
      sceneCtx.scene.add(points);
      zoneBorderParticles.push(points);
    }
  }

  function updateZoneBorderShimmer(worldTime) {
    var time = Date.now() * 0.001;
    for (var i = 0; i < zoneBorderParticles.length; i++) {
      var bp = zoneBorderParticles[i];
      var positions = bp.geometry.attributes.position.array;
      var basePos = bp.userData.basePositions;

      for (var j = 0; j < positions.length; j += 3) {
        // Vertical shimmer
        positions[j + 1] = basePos[j + 1] + Math.sin(time * 2 + j * 0.5) * 0.5;
      }

      bp.geometry.attributes.position.needsUpdate = true;
      // Pulse opacity
      bp.material.opacity = 0.2 + Math.sin(time * 1.5 + i) * 0.15;
    }
  }

  // ========================================================================
  // Structure & portal helpers
  // ========================================================================

  function addStructure(sceneCtx, type, position, options) {
    if (!sceneCtx || !sceneCtx.scene) return null;
    var opts = options || {};
    var result = confirmPlacement(sceneCtx, position, opts.zone || 'nexus');
    return result;
  }

  function createPortal(sceneCtx, fromZone, toZone, position) {
    if (!sceneCtx || !sceneCtx.scene) return null;
    return { from: fromZone, to: toZone, position: position };
  }

  // ========================================================================
  // EXPORTS
  // ========================================================================

  exports.initScene = initScene;
  exports.loadZone = loadZone;
  exports.addPlayer = addPlayer;
  exports.movePlayer = movePlayer;
  exports.removePlayer = removePlayer;
  exports.updatePlayerAnimations = updatePlayerAnimations;
  exports.updateDayNight = updateDayNight;
  exports.updateWeather = updateWeather;
  exports.setWeather = setWeather;
  exports.updateWeatherEffects = updateWeatherEffects;
  exports.getCurrentWeather = getCurrentWeather;
  exports.cullLights = cullLights;
  exports.updateAnimations = updateAnimations;
  exports.updateChunks = updateChunks;
  exports.getZoneAtPosition = getZoneAtPosition;
  exports.getTerrainHeight = getTerrainHeight;
  exports.getZoneCenter = getZoneCenter;
  exports.checkCollision = checkCollision;
  exports.getTexture = getTexture;
  exports.initParticles = initParticles;
  exports.updateParticles = updateParticles;
  exports.emitParticles = emitParticles;
  exports.initWater = initWater;
  exports.updateWater = updateWater;
  exports.initSkybox = initSkybox;
  exports.updateSkybox = updateSkybox;
  exports.initResourceNodes = initResourceNodes;
  exports.updateResourceNodes = updateResourceNodes;
  exports.harvestResource = harvestResource;
  exports.getResourceNodeAtMouse = getResourceNodeAtMouse;
  exports.ZONES = ZONES;
  exports.enterBuildMode = enterBuildMode;
  exports.exitBuildMode = exitBuildMode;
  exports.setBuildType = setBuildType;
  exports.confirmPlacement = confirmPlacement;
  exports.removeLastPlaced = removeLastPlaced;
  exports.updateBuildPreview = updateBuildPreview;
  exports.rotateBuildPreview = rotateBuildPreview;
  exports.getBuildMode = getBuildMode;
  exports.updateLOD = updateLOD;
  exports.updateFrustumCulling = updateFrustumCulling;
  exports.getFromPool = getFromPool;
  exports.returnToPool = returnToPool;
  exports.getPerformanceStats = getPerformanceStats;
  exports.spawnZoneInteractives = spawnZoneInteractives;
  exports.createInteractiveObject = createInteractiveObject;
  exports.getInteractiveAtPosition = getInteractiveAtPosition;
  exports.interactWithObject = interactWithObject;
  exports.updateInteractiveHighlights = updateInteractiveHighlights;
  exports.updateInteractiveAnimations = updateInteractiveAnimations;
  exports.clearInteractiveObjects = clearInteractiveObjects;
  exports.getZoneInteractives = getZoneInteractives;
  exports.highlightObject = highlightObject;
  exports.unhighlightObject = unhighlightObject;
  exports.fadeTransition = fadeTransition;
  exports.createZoneBoundaryParticles = createZoneBoundaryParticles;
  exports.updateZoneBoundaryParticles = updateZoneBoundaryParticles;
  exports.initWildlife = initWildlife;
  exports.updateWildlife = updateWildlife;
  exports.clearWildlife = clearWildlife;
  exports.initZoneAmbience = initZoneAmbience;
  exports.updateZoneAmbience = updateZoneAmbience;
  exports.initSeasonalParticles = initSeasonalParticles;
  exports.updateSeasonalVisuals = updateSeasonalVisuals;
  exports.registerPlayerStar = registerPlayerStar;
  exports.loadWorldMemory = loadWorldMemory;
  exports.saveWorldMemory = saveWorldMemory;
  exports.updateWorldMemory = updateWorldMemory;
  exports.initBillboardClouds = initBillboardClouds;
  exports.updateBillboardClouds = updateBillboardClouds;
  exports.initRainSplashes = initRainSplashes;
  exports.updateSnowAccumulation = updateSnowAccumulation;
  exports.initValleyFog = initValleyFog;
  exports.updateValleyFog = updateValleyFog;
  exports.updateTerrainBreathing = updateTerrainBreathing;
  exports.updateWindSystem = updateWindSystem;
  exports.getWindStrength = getWindStrength;
  exports.initZoneBorderShimmer = initZoneBorderShimmer;
  exports.updateZoneBorderShimmer = updateZoneBorderShimmer;
  exports.weatherCallbacks = weatherCallbacks;
  exports.addStructure = addStructure;
  exports.createPortal = createPortal;

})(typeof module !== 'undefined' ? module.exports : (window.World = {}));


// worldmap.js
// worldmap.js â€” World Map HUD Panel for ZION
// Provides canvas-based map rendering, coordinate transforms,
// zone detection, and a full-screen map panel overlay.
// No Three.js dependency â€” pure canvas 2D rendering.

(function(exports) {
  'use strict';

  // â”€â”€â”€ World Coordinate System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // World extends roughly -600 to +600 on both X and Z axes.
  var WORLD_MIN = -600;
  var WORLD_MAX = 600;
  var WORLD_RANGE = WORLD_MAX - WORLD_MIN; // 1200

  // â”€â”€â”€ Zone Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Derived from hud.js MINIMAP_ZONES and zones.js bounds.
  // cx/cz = center in world coords, radius = visual radius for rendering.
  var ZONE_DATA = {
    nexus:     { cx: 0,    cz: 0,    radius: 60,  name: 'The Nexus',      color: '#6688cc', bgColor: 'rgba(102,136,204,0.15)' },
    gardens:   { cx: 200,  cz: 30,   radius: 80,  name: 'The Gardens',    color: '#44aa44', bgColor: 'rgba(68,170,68,0.15)'   },
    athenaeum: { cx: 100,  cz: -220, radius: 60,  name: 'The Athenaeum',  color: '#8866aa', bgColor: 'rgba(136,102,170,0.15)' },
    studio:    { cx: -200, cz: -100, radius: 60,  name: 'The Studio',     color: '#cc6688', bgColor: 'rgba(204,102,136,0.15)' },
    wilds:     { cx: -30,  cz: 260,  radius: 90,  name: 'The Wilds',      color: '#228844', bgColor: 'rgba(34,136,68,0.15)'   },
    agora:     { cx: -190, cz: 120,  radius: 55,  name: 'The Agora',      color: '#cc8844', bgColor: 'rgba(204,136,68,0.15)'  },
    commons:   { cx: 170,  cz: 190,  radius: 55,  name: 'The Commons',    color: '#88aa44', bgColor: 'rgba(136,170,68,0.15)'  },
    arena:     { cx: 0,    cz: -240, radius: 55,  name: 'The Arena',      color: '#cc4444', bgColor: 'rgba(204,68,68,0.15)'   }
  };

  // Zone colors exported for external use
  var ZONE_COLORS = {};
  for (var _zk in ZONE_DATA) {
    ZONE_COLORS[_zk] = ZONE_DATA[_zk].color;
  }

  // Zone connection graph for path rendering
  var ZONE_CONNECTIONS = [
    ['nexus', 'gardens'],
    ['nexus', 'athenaeum'],
    ['nexus', 'studio'],
    ['nexus', 'wilds'],
    ['nexus', 'agora'],
    ['nexus', 'commons'],
    ['nexus', 'arena'],
    ['gardens', 'wilds'],
    ['gardens', 'athenaeum'],
    ['athenaeum', 'studio'],
    ['studio', 'agora'],
    ['agora', 'commons'],
    ['commons', 'arena'],
    ['wilds', 'arena']
  ];

  // â”€â”€â”€ Coordinate Transforms â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Convert world coordinates (X, Z) to map canvas pixel coordinates.
   * World Y is ignored (map is top-down).
   * @param {number} worldX - World X coordinate
   * @param {number} worldZ - World Z coordinate
   * @param {number} canvasW - Canvas pixel width
   * @param {number} canvasH - Canvas pixel height
   * @param {number} [margin=12] - Pixel margin around map edges
   * @returns {{ x: number, y: number }} Canvas pixel position
   */
  function worldToMap(worldX, worldZ, canvasW, canvasH, margin) {
    if (margin === undefined || margin === null) margin = 12;
    var drawW = canvasW - margin * 2;
    var drawH = canvasH - margin * 2;
    var px = margin + ((worldX - WORLD_MIN) / WORLD_RANGE) * drawW;
    var py = margin + ((worldZ - WORLD_MIN) / WORLD_RANGE) * drawH;
    return { x: px, y: py };
  }

  /**
   * Convert map canvas pixel coordinates back to world coordinates.
   * @param {number} mapX - Canvas pixel X
   * @param {number} mapY - Canvas pixel Y
   * @param {number} canvasW - Canvas pixel width
   * @param {number} canvasH - Canvas pixel height
   * @param {number} [margin=12] - Pixel margin used when rendering
   * @returns {{ x: number, z: number }} World position (X, Z)
   */
  function mapToWorld(mapX, mapY, canvasW, canvasH, margin) {
    if (margin === undefined || margin === null) margin = 12;
    var drawW = canvasW - margin * 2;
    var drawH = canvasH - margin * 2;
    var worldX = WORLD_MIN + ((mapX - margin) / drawW) * WORLD_RANGE;
    var worldZ = WORLD_MIN + ((mapY - margin) / drawH) * WORLD_RANGE;
    return { x: worldX, z: worldZ };
  }

  /**
   * Get all zone bounds data (center + radius) for external use.
   * @returns {Object} Zone data keyed by zone ID
   */
  function getZoneBounds() {
    var result = {};
    for (var zid in ZONE_DATA) {
      var z = ZONE_DATA[zid];
      result[zid] = {
        cx: z.cx,
        cz: z.cz,
        radius: z.radius,
        name: z.name,
        color: z.color
      };
    }
    return result;
  }

  // â”€â”€â”€ Zone Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Determine which zone contains the given world position.
   * Returns the zone whose center is closest if the point is inside
   * the zone's radius. Returns null if outside all zones.
   * @param {number} x - World X
   * @param {number} z - World Z
   * @returns {string|null} Zone ID or null
   */
  function getZoneAtPosition(x, z) {
    var best = null;
    var bestDist = Infinity;
    for (var zid in ZONE_DATA) {
      var zone = ZONE_DATA[zid];
      var dx = x - zone.cx;
      var dz = z - zone.cz;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist <= zone.radius && dist < bestDist) {
        bestDist = dist;
        best = zid;
      }
    }
    return best;
  }

  /**
   * Calculate Euclidean distance from a world point to a zone center.
   * @param {number} x - World X
   * @param {number} z - World Z
   * @param {string} zoneName - Zone ID
   * @returns {number} Distance in world units, or Infinity if zone not found
   */
  function getDistanceToZone(x, z, zoneName) {
    var zone = ZONE_DATA[zoneName];
    if (!zone) return Infinity;
    var dx = x - zone.cx;
    var dz = z - zone.cz;
    return Math.sqrt(dx * dx + dz * dz);
  }

  /**
   * Find the nearest zone to a world position.
   * @param {number} x - World X
   * @param {number} z - World Z
   * @returns {{ zoneId: string, distance: number, zone: Object }} Nearest zone info
   */
  function getNearestZone(x, z) {
    var nearest = null;
    var nearestDist = Infinity;
    for (var zid in ZONE_DATA) {
      var dist = getDistanceToZone(x, z, zid);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = zid;
      }
    }
    return {
      zoneId: nearest,
      distance: nearestDist,
      zone: nearest ? ZONE_DATA[nearest] : null
    };
  }

  /**
   * Calculate a simple waypoint path from one world point to another.
   * Uses straight-line if within same zone; routes via Nexus otherwise.
   * Returns array of {x, z} waypoints including start and end.
   * @param {number} fromX - Start world X
   * @param {number} fromZ - Start world Z
   * @param {number} toX - End world X
   * @param {number} toZ - End world Z
   * @returns {Array<{x: number, z: number}>} Path waypoints
   */
  function calculatePath(fromX, fromZ, toX, toZ) {
    var fromZone = getZoneAtPosition(fromX, fromZ);
    var toZone = getZoneAtPosition(toX, toZ);

    // Same zone or no zone â€” straight line
    if (!fromZone || !toZone || fromZone === toZone) {
      return [{ x: fromX, z: fromZ }, { x: toX, z: toZ }];
    }

    // Check if zones are directly connected
    var directlyConnected = false;
    for (var i = 0; i < ZONE_CONNECTIONS.length; i++) {
      var conn = ZONE_CONNECTIONS[i];
      if ((conn[0] === fromZone && conn[1] === toZone) ||
          (conn[1] === fromZone && conn[0] === toZone)) {
        directlyConnected = true;
        break;
      }
    }

    if (directlyConnected) {
      return [
        { x: fromX, z: fromZ },
        { x: ZONE_DATA[toZone].cx, z: ZONE_DATA[toZone].cz },
        { x: toX, z: toZ }
      ];
    }

    // Route via Nexus as hub
    var nexus = ZONE_DATA.nexus;
    return [
      { x: fromX, z: fromZ },
      { x: nexus.cx, z: nexus.cz },
      { x: ZONE_DATA[toZone].cx, z: ZONE_DATA[toZone].cz },
      { x: toX, z: toZ }
    ];
  }

  // â”€â”€â”€ Canvas Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Render the full world map onto a canvas context.
   * Draws zone regions, connection paths, zone labels, and grid.
   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
   * @param {number} width - Canvas width in pixels
   * @param {number} height - Canvas height in pixels
   * @param {Object} [options] - Rendering options
   * @param {string} [options.currentZone] - Highlighted zone ID
   * @param {number} [options.margin=12] - Map margin
   * @param {boolean} [options.showGrid=false] - Draw grid lines
   * @param {boolean} [options.showConnections=true] - Draw zone connection paths
   * @param {boolean} [options.showLabels=true] - Draw zone name labels
   */
  function renderMap(ctx, width, height, options) {
    options = options || {};
    var margin = (options.margin !== undefined) ? options.margin : 12;
    var currentZone = options.currentZone || null;
    var showGrid = options.showGrid || false;
    var showConnections = (options.showConnections !== false);
    var showLabels = (options.showLabels !== false);

    // Background
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, width, height);

    // Optional grid
    if (showGrid) {
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 0.5;
      var gridStep = 100; // every 100 world units
      var gridLines = [
        WORLD_MIN, -400, -200, 0, 200, 400, WORLD_MAX
      ];
      for (var gi = 0; gi < gridLines.length; gi++) {
        var gv = gridLines[gi];
        // Vertical line
        var gLeft = worldToMap(gv, WORLD_MIN, width, height, margin);
        var gRight = worldToMap(gv, WORLD_MAX, width, height, margin);
        ctx.beginPath();
        ctx.moveTo(gLeft.x, gLeft.y);
        ctx.lineTo(gRight.x, gRight.y);
        ctx.stroke();
        // Horizontal line
        var gTop = worldToMap(WORLD_MIN, gv, width, height, margin);
        var gBot = worldToMap(WORLD_MAX, gv, width, height, margin);
        ctx.beginPath();
        ctx.moveTo(gTop.x, gTop.y);
        ctx.lineTo(gBot.x, gBot.y);
        ctx.stroke();
      }
    }

    // Zone connection lines
    if (showConnections) {
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      for (var ci = 0; ci < ZONE_CONNECTIONS.length; ci++) {
        var conn = ZONE_CONNECTIONS[ci];
        var zA = ZONE_DATA[conn[0]];
        var zB = ZONE_DATA[conn[1]];
        if (!zA || !zB) continue;
        var pA = worldToMap(zA.cx, zA.cz, width, height, margin);
        var pB = worldToMap(zB.cx, zB.cz, width, height, margin);
        ctx.beginPath();
        ctx.moveTo(pA.x, pA.y);
        ctx.lineTo(pB.x, pB.y);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    // Zone regions
    for (var zid in ZONE_DATA) {
      var zone = ZONE_DATA[zid];
      var pos = worldToMap(zone.cx, zone.cz, width, height, margin);
      var isActive = (zid === currentZone);
      // Scale radius to canvas units
      var pxRadius = (zone.radius / WORLD_RANGE) * (width - margin * 2);

      // Fill
      ctx.globalAlpha = isActive ? 0.45 : 0.2;
      ctx.fillStyle = zone.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, pxRadius, 0, Math.PI * 2);
      ctx.fill();

      // Border
      ctx.globalAlpha = isActive ? 1.0 : 0.45;
      ctx.strokeStyle = zone.color;
      ctx.lineWidth = isActive ? 2.5 : 1;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, pxRadius, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 1.0;

      // Zone label
      if (showLabels) {
        ctx.fillStyle = isActive ? '#ffffff' : 'rgba(255,255,255,0.65)';
        ctx.font = isActive ? 'bold 11px Arial' : '9px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(zone.name, pos.x, pos.y);
      }
    }

    // Border
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, width, height);
  }

  /**
   * Render the player's position marker on the map.
   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
   * @param {number} x - Player world X
   * @param {number} z - Player world Z
   * @param {Object} [options] - Options
   * @param {number} [options.canvasW=400] - Canvas width
   * @param {number} [options.canvasH=400] - Canvas height
   * @param {number} [options.margin=12] - Map margin
   * @param {number} [options.pulse=0] - Pulse phase 0-1 for animation
   * @param {string} [options.color='#FFD700'] - Marker color
   * @param {number} [options.radius=5] - Base radius
   */
  function renderPlayerMarker(ctx, x, z, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;
    var pulse = options.pulse || 0;
    var color = options.color || '#FFD700';
    var baseRadius = options.radius || 5;

    var pos = worldToMap(x, z, canvasW, canvasH, margin);

    // Pulsing outer ring
    var pulseRadius = baseRadius + 3 + Math.sin(pulse * Math.PI * 2) * 2;
    ctx.globalAlpha = 0.35 + Math.sin(pulse * Math.PI * 2) * 0.15;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, pulseRadius, 0, Math.PI * 2);
    ctx.stroke();

    // White border
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, baseRadius + 1.5, 0, Math.PI * 2);
    ctx.fill();

    // Inner gold dot with glow
    ctx.shadowBlur = 10;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, baseRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  /**
   * Render NPC position markers on the map.
   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context
   * @param {Array} npcs - Array of {position: {x, z}, archetype?, name?}
   * @param {Object} [options]
   * @param {number} [options.canvasW=400] - Canvas width
   * @param {number} [options.canvasH=400] - Canvas height
   * @param {number} [options.margin=12] - Map margin
   * @param {number} [options.maxCount=50] - Maximum NPCs to render
   */
  function renderNPCMarkers(ctx, npcs, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;
    var maxCount = options.maxCount || 50;

    if (!npcs || !npcs.length) return;

    var count = Math.min(npcs.length, maxCount);
    for (var i = 0; i < count; i++) {
      var npc = npcs[i];
      if (!npc || !npc.position) continue;
      var pos = worldToMap(npc.position.x, npc.position.z, canvasW, canvasH, margin);

      ctx.globalAlpha = 0.75;
      ctx.fillStyle = '#44ff88';
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1.0;
    }
  }

  /**
   * Render rift portal markers on the map.
   * @param {CanvasRenderingContext2D} ctx
   * @param {Array} portals - Array of {position: {x, z}, name?, healthy?}
   * @param {Object} [options]
   * @param {number} [options.canvasW=400]
   * @param {number} [options.canvasH=400]
   * @param {number} [options.margin=12]
   */
  function renderPortals(ctx, portals, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;

    if (!portals || !portals.length) return;

    for (var i = 0; i < portals.length; i++) {
      var portal = portals[i];
      if (!portal || !portal.position) continue;
      var pos = worldToMap(portal.position.x, portal.position.z, canvasW, canvasH, margin);
      var healthy = (portal.healthy !== false);
      var color = healthy ? '#a78bfa' : '#f87171';

      // Diamond shape
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = color;
      ctx.fillStyle = healthy ? 'rgba(167,139,250,0.35)' : 'rgba(248,113,113,0.35)';
      ctx.lineWidth = 1.5;
      var s = 5;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - s);
      ctx.lineTo(pos.x + s, pos.y);
      ctx.lineTo(pos.x, pos.y + s);
      ctx.lineTo(pos.x - s, pos.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }
  }

  /**
   * Render anchor POI markers on the map.
   * @param {CanvasRenderingContext2D} ctx
   * @param {Array} anchors - Array of {zone?, position?: {x, z}, type?}
   * @param {Object} [options]
   * @param {number} [options.canvasW=400]
   * @param {number} [options.canvasH=400]
   * @param {number} [options.margin=12]
   */
  function renderAnchors(ctx, anchors, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var margin = (options.margin !== undefined) ? options.margin : 12;

    if (!anchors || !anchors.length) return;

    // Anchor type colors
    var typeColors = {
      zone_portal:     '#4af',
      resource_node:   '#4fa',
      discovery_point: '#fa4',
      gathering_spot:  '#f4a',
      garden_plot:     '#af4'
    };

    for (var i = 0; i < anchors.length; i++) {
      var anchor = anchors[i];
      if (!anchor) continue;

      // Position: use explicit position if available, fall back to zone center
      var wx, wz;
      if (anchor.position && typeof anchor.position.x === 'number') {
        wx = anchor.position.x;
        wz = anchor.position.z;
      } else if (anchor.zone && ZONE_DATA[anchor.zone]) {
        wx = ZONE_DATA[anchor.zone].cx;
        wz = ZONE_DATA[anchor.zone].cz;
      } else {
        continue;
      }

      var pos = worldToMap(wx, wz, canvasW, canvasH, margin);
      var color = typeColors[anchor.type] || '#88aaff';

      // Square marker
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 0.75;
      var s = 3.5;
      ctx.fillRect(pos.x - s, pos.y - s, s * 2, s * 2);
      ctx.strokeRect(pos.x - s, pos.y - s, s * 2, s * 2);
      ctx.globalAlpha = 1.0;
    }
  }

  /**
   * Render the map legend in the bottom-right corner.
   * @param {CanvasRenderingContext2D} ctx
   * @param {Object} [options]
   * @param {number} [options.canvasW=400]
   * @param {number} [options.canvasH=400]
   * @param {boolean} [options.showNPCs=false]
   * @param {boolean} [options.showPortals=false]
   * @param {boolean} [options.showAnchors=false]
   */
  function renderLegend(ctx, options) {
    options = options || {};
    var canvasW = options.canvasW || 400;
    var canvasH = options.canvasH || 400;
    var showNPCs = options.showNPCs || false;
    var showPortals = options.showPortals || false;
    var showAnchors = options.showAnchors || false;

    var items = [
      { color: '#FFD700', label: 'You', shape: 'circle' }
    ];
    if (showNPCs)    items.push({ color: '#44ff88', label: 'NPC', shape: 'circle' });
    if (showPortals) items.push({ color: '#a78bfa', label: 'Portal', shape: 'diamond' });
    if (showAnchors) items.push({ color: '#4af',    label: 'Anchor', shape: 'square' });

    var lineH = 16;
    var boxW = 80;
    var boxH = items.length * lineH + 10;
    var bx = canvasW - boxW - 6;
    var by = canvasH - boxH - 6;

    ctx.globalAlpha = 0.75;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.beginPath();
    ctx.rect(bx, by, boxW, boxH);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var iy = by + 8 + i * lineH;
      var ix = bx + 8;

      ctx.fillStyle = item.color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 0.5;

      if (item.shape === 'diamond') {
        ctx.beginPath();
        ctx.moveTo(ix + 5, iy - 3);
        ctx.lineTo(ix + 8, iy + 1);
        ctx.lineTo(ix + 5, iy + 5);
        ctx.lineTo(ix + 2, iy + 1);
        ctx.closePath();
        ctx.fill();
      } else if (item.shape === 'square') {
        ctx.fillRect(ix + 2, iy - 2, 6, 6);
      } else {
        // circle
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.arc(ix + 5, iy + 1, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }

      ctx.fillStyle = '#ddd';
      ctx.font = '9px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.label, ix + 14, iy + 1);
    }
  }

  // â”€â”€â”€ Map Panel State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  var mapPanelEl = null;
  var mapCanvas = null;
  var mapCtx = null;
  var mapVisible = false;
  var mapPulsePhase = 0;
  var mapAnimFrame = null;
  var mapZoom = 1.0;
  var mapZoomMin = 0.5;
  var mapZoomMax = 4.0;

  // Layer toggles
  var layerNPCs = false;
  var layerPortals = true;
  var layerAnchors = false;

  // Current state references (updated via updateMapData)
  var _playerX = 0;
  var _playerZ = 0;
  var _currentZone = null;
  var _npcs = [];
  var _portals = [];
  var _anchors = [];
  var _onWarpCallback = null;

  /**
   * Provide updated data for map rendering.
   * @param {Object} data
   * @param {number} [data.playerX=0] - Player world X
   * @param {number} [data.playerZ=0] - Player world Z
   * @param {string} [data.currentZone] - Zone ID
   * @param {Array}  [data.npcs=[]] - NPC array
   * @param {Array}  [data.portals=[]] - Portal array
   * @param {Array}  [data.anchors=[]] - Anchor array
   */
  function updateMapData(data) {
    data = data || {};
    if (typeof data.playerX === 'number') _playerX = data.playerX;
    if (typeof data.playerZ === 'number') _playerZ = data.playerZ;
    if (data.currentZone !== undefined) _currentZone = data.currentZone;
    if (Array.isArray(data.npcs)) _npcs = data.npcs;
    if (Array.isArray(data.portals)) _portals = data.portals;
    if (Array.isArray(data.anchors)) _anchors = data.anchors;
  }

  /**
   * Rebuild and return the map panel DOM element.
   * @returns {HTMLElement}
   */
  function _createMapPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'world-map-panel';
    panel.style.cssText = [
      'position:absolute',
      'top:50%',
      'left:50%',
      'transform:translate(-50%,-50%)',
      'width:520px',
      'height:560px',
      'background:rgba(5,8,20,0.96)',
      'border:1px solid rgba(100,136,200,0.45)',
      'border-radius:10px',
      'box-shadow:0 8px 32px rgba(0,0,0,0.7)',
      'display:flex',
      'flex-direction:column',
      'z-index:500',
      'pointer-events:auto',
      'user-select:none'
    ].join(';');

    // â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var header = document.createElement('div');
    header.style.cssText = [
      'display:flex',
      'align-items:center',
      'justify-content:space-between',
      'padding:10px 14px 8px',
      'border-bottom:1px solid rgba(100,136,200,0.25)',
      'flex-shrink:0'
    ].join(';');

    var title = document.createElement('div');
    title.style.cssText = 'font-size:15px;font-weight:bold;color:#aac4ff;letter-spacing:0.05em;';
    title.textContent = 'WORLD MAP';

    var closeBtn = document.createElement('button');
    closeBtn.id = 'world-map-close';
    closeBtn.style.cssText = [
      'background:none',
      'border:1px solid rgba(255,255,255,0.2)',
      'border-radius:4px',
      'color:#aaa',
      'cursor:pointer',
      'padding:2px 8px',
      'font-size:13px'
    ].join(';');
    closeBtn.textContent = 'x';
    closeBtn.addEventListener('click', hideMapPanel);

    header.appendChild(title);
    header.appendChild(closeBtn);
    panel.appendChild(header);

    // â”€â”€ Toolbar (layers + zoom) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var toolbar = document.createElement('div');
    toolbar.style.cssText = [
      'display:flex',
      'align-items:center',
      'gap:8px',
      'padding:6px 14px',
      'border-bottom:1px solid rgba(100,136,200,0.15)',
      'flex-shrink:0',
      'font-size:11px',
      'color:#aaa'
    ].join(';');

    function makeToggle(id, label, checked, onChange) {
      var wrap = document.createElement('label');
      wrap.style.cssText = 'display:flex;align-items:center;gap:3px;cursor:pointer;';
      var cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.id = id;
      cb.checked = checked;
      cb.style.cssText = 'cursor:pointer;';
      cb.addEventListener('change', function() { onChange(cb.checked); });
      var lbl = document.createElement('span');
      lbl.textContent = label;
      wrap.appendChild(cb);
      wrap.appendChild(lbl);
      return wrap;
    }

    toolbar.appendChild(makeToggle('map-layer-npcs', 'NPCs', layerNPCs, function(v) {
      layerNPCs = v;
    }));
    toolbar.appendChild(makeToggle('map-layer-portals', 'Portals', layerPortals, function(v) {
      layerPortals = v;
    }));
    toolbar.appendChild(makeToggle('map-layer-anchors', 'Anchors', layerAnchors, function(v) {
      layerAnchors = v;
    }));

    // Spacer
    var spacer = document.createElement('div');
    spacer.style.cssText = 'flex:1;';
    toolbar.appendChild(spacer);

    // Zoom controls
    var zoomOut = document.createElement('button');
    zoomOut.textContent = '-';
    zoomOut.title = 'Zoom out';
    zoomOut.style.cssText = 'background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);border-radius:4px;color:#ccc;cursor:pointer;padding:1px 7px;font-size:14px;';
    zoomOut.addEventListener('click', function() {
      mapZoom = Math.max(mapZoomMin, mapZoom - 0.25);
    });

    var zoomLbl = document.createElement('span');
    zoomLbl.id = 'map-zoom-label';
    zoomLbl.style.cssText = 'min-width:36px;text-align:center;';
    zoomLbl.textContent = '1.0x';

    var zoomIn = document.createElement('button');
    zoomIn.textContent = '+';
    zoomIn.title = 'Zoom in';
    zoomIn.style.cssText = 'background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.2);border-radius:4px;color:#ccc;cursor:pointer;padding:1px 7px;font-size:14px;';
    zoomIn.addEventListener('click', function() {
      mapZoom = Math.min(mapZoomMax, mapZoom + 0.25);
    });

    toolbar.appendChild(zoomOut);
    toolbar.appendChild(zoomLbl);
    toolbar.appendChild(zoomIn);

    panel.appendChild(toolbar);

    // â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var canvasWrap = document.createElement('div');
    canvasWrap.style.cssText = [
      'flex:1',
      'position:relative',
      'overflow:hidden',
      'margin:8px'
    ].join(';');

    mapCanvas = document.createElement('canvas');
    mapCanvas.id = 'world-map-canvas';
    mapCanvas.width = 496;
    mapCanvas.height = 440;
    mapCanvas.style.cssText = 'display:block;border-radius:5px;cursor:crosshair;';
    mapCtx = mapCanvas.getContext('2d');

    // Click-to-warp
    mapCanvas.addEventListener('click', function(e) {
      var rect = mapCanvas.getBoundingClientRect();
      var mx = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
      var my = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
      var world = mapToWorld(mx, my, mapCanvas.width, mapCanvas.height, 12);
      if (_onWarpCallback) {
        _onWarpCallback(world.x, world.z);
      }
    });

    // Hover tooltip
    var tooltip = document.createElement('div');
    tooltip.id = 'map-tooltip';
    tooltip.style.cssText = [
      'position:absolute',
      'background:rgba(0,0,0,0.8)',
      'color:#ddd',
      'font-size:10px',
      'padding:3px 7px',
      'border-radius:4px',
      'pointer-events:none',
      'display:none',
      'white-space:nowrap',
      'z-index:10'
    ].join(';');

    mapCanvas.addEventListener('mousemove', function(e) {
      var rect = mapCanvas.getBoundingClientRect();
      var mx = (e.clientX - rect.left) * (mapCanvas.width / rect.width);
      var my = (e.clientY - rect.top) * (mapCanvas.height / rect.height);
      var world = mapToWorld(mx, my, mapCanvas.width, mapCanvas.height, 12);
      var zoneHit = getZoneAtPosition(world.x, world.z);
      var zoneName = zoneHit ? ZONE_DATA[zoneHit].name : 'Wilderness';
      tooltip.style.display = 'block';
      tooltip.style.left = (e.offsetX + 14) + 'px';
      tooltip.style.top = (e.offsetY - 4) + 'px';
      tooltip.textContent = zoneName + '  (' + Math.round(world.x) + ', ' + Math.round(world.z) + ')';
    });
    mapCanvas.addEventListener('mouseleave', function() {
      tooltip.style.display = 'none';
    });

    canvasWrap.appendChild(mapCanvas);
    canvasWrap.appendChild(tooltip);
    panel.appendChild(canvasWrap);

    // â”€â”€ Footer: coordinate display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var footer = document.createElement('div');
    footer.id = 'map-footer';
    footer.style.cssText = [
      'padding:5px 14px 8px',
      'font-size:10px',
      'color:#667',
      'border-top:1px solid rgba(100,136,200,0.1)',
      'flex-shrink:0',
      'text-align:center'
    ].join(';');
    footer.textContent = 'Click map to warp. M to close.';
    panel.appendChild(footer);

    return panel;
  }

  /**
   * Render one frame of the map canvas.
   */
  function _renderFrame() {
    if (!mapCtx || !mapCanvas) return;
    var w = mapCanvas.width;
    var h = mapCanvas.height;
    var margin = 12;

    // Increment pulse phase
    mapPulsePhase = (mapPulsePhase + 0.02) % 1.0;

    renderMap(mapCtx, w, h, {
      currentZone: _currentZone,
      margin: margin,
      showGrid: true,
      showConnections: true,
      showLabels: true
    });

    if (layerAnchors) {
      renderAnchors(mapCtx, _anchors, { canvasW: w, canvasH: h, margin: margin });
    }
    if (layerPortals) {
      renderPortals(mapCtx, _portals, { canvasW: w, canvasH: h, margin: margin });
    }
    if (layerNPCs) {
      renderNPCMarkers(mapCtx, _npcs, { canvasW: w, canvasH: h, margin: margin });
    }

    renderPlayerMarker(mapCtx, _playerX, _playerZ, {
      canvasW: w,
      canvasH: h,
      margin: margin,
      pulse: mapPulsePhase
    });

    renderLegend(mapCtx, {
      canvasW: w,
      canvasH: h,
      showNPCs: layerNPCs,
      showPortals: layerPortals,
      showAnchors: layerAnchors
    });

    // Update zoom label
    if (typeof document !== 'undefined') {
      var zl = document.getElementById('map-zoom-label');
      if (zl) zl.textContent = mapZoom.toFixed(2) + 'x';
    }
  }

  /**
   * Animation loop for the map panel.
   */
  function _animateMap() {
    if (!mapVisible) return;
    _renderFrame();
    if (typeof requestAnimationFrame !== 'undefined') {
      mapAnimFrame = requestAnimationFrame(_animateMap);
    }
  }

  /**
   * Show the world map panel.
   * @param {Object} [options]
   * @param {Function} [options.onWarp] - Called with (worldX, worldZ) on map click
   */
  function showMapPanel(options) {
    options = options || {};
    if (typeof document === 'undefined') return;

    if (options.onWarp) _onWarpCallback = options.onWarp;

    if (!mapPanelEl) {
      mapPanelEl = _createMapPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && mapPanelEl) {
        hud.appendChild(mapPanelEl);
      } else if (mapPanelEl) {
        document.body.appendChild(mapPanelEl);
      }
    }

    if (!mapPanelEl) return;

    mapPanelEl.style.display = 'flex';
    mapVisible = true;
    _animateMap();
  }

  /**
   * Hide the world map panel.
   */
  function hideMapPanel() {
    if (mapPanelEl) {
      mapPanelEl.style.display = 'none';
    }
    mapVisible = false;
    if (mapAnimFrame && typeof cancelAnimationFrame !== 'undefined') {
      cancelAnimationFrame(mapAnimFrame);
      mapAnimFrame = null;
    }
  }

  /**
   * Toggle the world map panel.
   * @param {Object} [options] - Passed to showMapPanel if showing
   */
  function toggleMapPanel(options) {
    if (mapVisible) {
      hideMapPanel();
    } else {
      showMapPanel(options);
    }
  }

  /**
   * Check whether the map panel is currently visible.
   * @returns {boolean}
   */
  function isMapVisible() {
    return mapVisible;
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  exports.ZONE_COLORS = ZONE_COLORS;
  exports.ZONE_DATA = ZONE_DATA;
  exports.ZONE_CONNECTIONS = ZONE_CONNECTIONS;
  exports.WORLD_MIN = WORLD_MIN;
  exports.WORLD_MAX = WORLD_MAX;
  exports.WORLD_RANGE = WORLD_RANGE;

  // Coordinate transforms
  exports.worldToMap = worldToMap;
  exports.mapToWorld = mapToWorld;
  exports.getZoneBounds = getZoneBounds;

  // Zone logic
  exports.getZoneAtPosition = getZoneAtPosition;
  exports.getDistanceToZone = getDistanceToZone;
  exports.getNearestZone = getNearestZone;
  exports.calculatePath = calculatePath;

  // Canvas renderers
  exports.renderMap = renderMap;
  exports.renderPlayerMarker = renderPlayerMarker;
  exports.renderNPCMarkers = renderNPCMarkers;
  exports.renderPortals = renderPortals;
  exports.renderAnchors = renderAnchors;
  exports.renderLegend = renderLegend;

  // Panel API
  exports.showMapPanel = showMapPanel;
  exports.hideMapPanel = hideMapPanel;
  exports.toggleMapPanel = toggleMapPanel;
  exports.isMapVisible = isMapVisible;
  exports.updateMapData = updateMapData;

})(typeof module !== 'undefined' ? module.exports : (window.WorldMap = {}));


// LAZY_LOAD_START: timelapse
// timelapse.js
/**
 * ZION Civilization Timelapse Renderer
 * Processes civilization_sim.py output into frame-by-frame playback,
 * camera paths, audio mappings, and 2D canvas rendering helpers.
 *
 * UMD module â€” works in browser (window.Timelapse) and Node.js (module.exports).
 */

(function(exports) {
  'use strict';

  // â”€â”€â”€ Zone Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var ZONES = ['nexus', 'gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena'];

  // World positions (cx, cz) from ZONE_CENTERS in civilization_sim.py
  var ZONE_CENTERS = {
    nexus:     { x: 0,    z: 0    },
    gardens:   { x: 200,  z: 30   },
    athenaeum: { x: 100,  z: -220 },
    studio:    { x: -200, z: -100 },
    wilds:     { x: -30,  z: 260  },
    agora:     { x: -190, z: 120  },
    commons:   { x: 170,  z: 190  },
    arena:     { x: 0,    z: -240 }
  };

  // Zone mood â†’ harmony name mapping
  var ZONE_MOOD = {
    nexus:     'welcoming',
    gardens:   'peaceful',
    athenaeum: 'curious',
    studio:    'creative',
    wilds:     'adventurous',
    agora:     'bustling',
    commons:   'communal',
    arena:     'intense'
  };

  // Archetype â†’ instrument mapping
  var ARCHETYPE_INSTRUMENT = {
    gardener:    'soft pads',
    builder:     'percussion',
    storyteller: 'vocals/melody',
    merchant:    'bass',
    explorer:    'strings',
    teacher:     'piano',
    musician:    'lead synth',
    healer:      'choir',
    philosopher: 'ambient',
    artist:      'bells'
  };

  // Zone colors for minimap rendering
  var ZONE_COLORS = {
    nexus:     '#daa520',
    gardens:   '#4caf50',
    athenaeum: '#2196f3',
    studio:    '#e040fb',
    wilds:     '#ff5722',
    agora:     '#ff9800',
    commons:   '#00bcd4',
    arena:     '#f44336'
  };

  // Event type â†’ icon character
  var EVENT_ICONS = {
    join:      '+',
    build:     'B',
    creation:  'C',
    discovery: 'D',
    harvest:   'H',
    trade:     'T',
    plant:     'P',
    craft:     'K',
    weather:   'W',
    milestone: '*',
    ubi:       '$'
  };

  // â”€â”€â”€ Data Processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * loadSimData(simJson) â€” parse civilization_sim.py JSON output into timeline.
   *
   * Input format (from civilization_sim.py main() raw_data output):
   *   {
   *     snapshots: [{tick, population, structures, creations, gardens, discoveries,
   *                  total_spark, txn_volume, listings, active_zones, zone_populations,
   *                  gini, weather, season, dayPhase, chat_messages}],
   *     analysis: {...},
   *     notable_events: [[tick, type, description], ...],
   *     final_population, final_structures, final_creations, final_discoveries
   *   }
   *
   * Returns timeline: {frames, totalTicks, notableEvents, analysis}
   */
  function loadSimData(simJson) {
    var snapshots = simJson.snapshots || [];
    var rawEvents = simJson.notable_events || [];
    var analysis = simJson.analysis || {};

    // Build frame list â€” one frame per snapshot
    var frames = [];
    for (var i = 0; i < snapshots.length; i++) {
      var snap = snapshots[i];
      frames.push(_snapshotToFrame(snap, rawEvents));
    }

    // Build notable events list: [{tick, type, description}]
    var notableEvents = [];
    for (var j = 0; j < rawEvents.length; j++) {
      var ev = rawEvents[j];
      if (Array.isArray(ev) && ev.length >= 3) {
        notableEvents.push({ tick: ev[0], type: ev[1], description: ev[2] });
      } else if (ev && typeof ev === 'object') {
        notableEvents.push(ev);
      }
    }

    var totalTicks = frames.length > 0 ? frames[frames.length - 1].tick : 0;

    return {
      frames: frames,
      totalTicks: totalTicks,
      notableEvents: notableEvents,
      analysis: analysis
    };
  }

  /**
   * Convert a raw snapshot to a normalized frame object.
   */
  function _snapshotToFrame(snap, rawEvents) {
    var tick = snap.tick || 0;

    // Build zoneActivity from zone_populations
    var zoneActivity = {};
    var zonePop = snap.zone_populations || {};
    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      zoneActivity[zone] = zonePop[zone] || 0;
    }

    // Collect events that fall at this tick
    var events = [];
    if (rawEvents) {
      for (var e = 0; e < rawEvents.length; e++) {
        var ev = rawEvents[e];
        var evTick = Array.isArray(ev) ? ev[0] : (ev.tick || 0);
        if (evTick === tick) {
          events.push(Array.isArray(ev)
            ? { tick: ev[0], type: ev[1], description: ev[2] }
            : ev);
        }
      }
    }

    return {
      tick: tick,
      population: snap.population || 0,
      zoneActivity: zoneActivity,
      economy: {
        totalSpark: snap.total_spark || 0,
        gini: snap.gini || 0,
        txnVolume: snap.txn_volume || 0,
        listings: snap.listings || 0,
        activeZones: snap.active_zones || 0
      },
      events: events,
      culture: {
        weather: snap.weather || 'clear',
        season: snap.season || 'spring',
        dayPhase: snap.dayPhase || 'day',
        structures: snap.structures || 0,
        creations: snap.creations || 0,
        gardens: snap.gardens || 0,
        discoveries: snap.discoveries || 0,
        chatMessages: snap.chat_messages || 0
      }
    };
  }

  /**
   * getFrame(timeline, tick) â€” return frame for the exact tick, or null.
   */
  function getFrame(timeline, tick) {
    if (!timeline || !timeline.frames || tick < 0) return null;
    var frames = timeline.frames;
    for (var i = 0; i < frames.length; i++) {
      if (frames[i].tick === tick) return frames[i];
    }
    return null;
  }

  /**
   * interpolateFrame(timeline, t) â€” smoothly interpolated frame at normalized t (0-1).
   * Linearly interpolates numeric values between adjacent frames.
   */
  function interpolateFrame(timeline, t) {
    if (!timeline || !timeline.frames || timeline.frames.length === 0) return null;
    var frames = timeline.frames;

    if (frames.length === 1) {
      return _cloneFrame(frames[0]);
    }

    // Clamp t
    t = Math.max(0, Math.min(1, t));

    // Map t to position in frames array
    var pos = t * (frames.length - 1);
    var lo = Math.floor(pos);
    var hi = Math.ceil(pos);
    var alpha = pos - lo;

    // Clamp indices
    lo = Math.max(0, Math.min(frames.length - 1, lo));
    hi = Math.max(0, Math.min(frames.length - 1, hi));

    if (lo === hi) return _cloneFrame(frames[lo]);

    var fA = frames[lo];
    var fB = frames[hi];

    // Interpolate zone activity
    var zoneActivity = {};
    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      zoneActivity[zone] = _lerp(fA.zoneActivity[zone], fB.zoneActivity[zone], alpha);
    }

    return {
      tick: _lerp(fA.tick, fB.tick, alpha),
      population: _lerp(fA.population, fB.population, alpha),
      zoneActivity: zoneActivity,
      economy: {
        totalSpark: _lerp(fA.economy.totalSpark, fB.economy.totalSpark, alpha),
        gini: _lerp(fA.economy.gini, fB.economy.gini, alpha),
        txnVolume: _lerp(fA.economy.txnVolume, fB.economy.txnVolume, alpha),
        listings: _lerp(fA.economy.listings, fB.economy.listings, alpha),
        activeZones: _lerp(fA.economy.activeZones, fB.economy.activeZones, alpha)
      },
      events: alpha < 0.5 ? fA.events : fB.events,
      culture: alpha < 0.5 ? fA.culture : fB.culture
    };
  }

  /**
   * getSummary(timeline) â€” return high-level summary of the civilization history.
   * Returns {totalTicks, peakPopulation, majorEvents, dominantZones}
   */
  function getSummary(timeline) {
    if (!timeline || !timeline.frames || timeline.frames.length === 0) {
      return { totalTicks: 0, peakPopulation: 0, majorEvents: [], dominantZones: [] };
    }

    var frames = timeline.frames;
    var totalTicks = timeline.totalTicks;
    var peakPopulation = 0;

    // Zone activity accumulator
    var zoneTotal = {};
    for (var z = 0; z < ZONES.length; z++) {
      zoneTotal[ZONES[z]] = 0;
    }

    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      if (frame.population > peakPopulation) {
        peakPopulation = frame.population;
      }
      for (var z2 = 0; z2 < ZONES.length; z2++) {
        var zone = ZONES[z2];
        zoneTotal[zone] += (frame.zoneActivity[zone] || 0);
      }
    }

    // Sort zones by total activity
    var sortedZones = ZONES.slice().sort(function(a, b) {
      return zoneTotal[b] - zoneTotal[a];
    });

    // Dominant zones = those with above-average total activity
    var totalActivity = 0;
    for (var z3 = 0; z3 < ZONES.length; z3++) {
      totalActivity += zoneTotal[ZONES[z3]];
    }
    var avgActivity = totalActivity / ZONES.length;
    var dominantZones = sortedZones.filter(function(z) {
      return zoneTotal[z] > avgActivity;
    });
    if (dominantZones.length === 0) {
      dominantZones = [sortedZones[0]]; // at least one
    }

    return {
      totalTicks: totalTicks,
      peakPopulation: peakPopulation,
      majorEvents: timeline.notableEvents || [],
      dominantZones: dominantZones
    };
  }

  // â”€â”€â”€ Camera Path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * generateCameraPath(timeline, options?) â€” generate 3D flyover keyframes.
   *
   * Options: {altitude, orbitSpeed, zoomOnEvents}
   * Returns [{tick, position: {x,y,z}, lookAt: {x,y,z}, fov}]
   */
  function generateCameraPath(timeline, options) {
    options = options || {};
    var altitude = typeof options.altitude === 'number' ? options.altitude : 150;
    var orbitSpeed = typeof options.orbitSpeed === 'number' ? options.orbitSpeed : 1.0;
    var zoomOnEvents = options.zoomOnEvents !== false;

    var frames = timeline.frames || [];
    if (frames.length === 0) {
      return [_makeKeyframe(0, { x: 0, y: altitude, z: 300 }, { x: 0, y: 0, z: 0 }, 60)];
    }

    var keyframes = [];
    var totalFrames = frames.length;

    for (var i = 0; i < totalFrames; i++) {
      var frame = frames[i];
      var t = totalFrames > 1 ? i / (totalFrames - 1) : 0;

      // Base orbit angle â€” full circle over the run
      var angle = t * Math.PI * 2 * orbitSpeed;

      // Orbit radius contracts as population grows (civilization consolidates)
      var popFraction = frame.population > 0 ? Math.min(frame.population / 100, 1) : 0;
      var orbitRadius = 400 - popFraction * 150; // 400 â†’ 250

      // Find most active zone to focus on
      var dominantZone = _getDominantZone(frame.zoneActivity);
      var focusCenter = ZONE_CENTERS[dominantZone] || ZONE_CENTERS.nexus;

      // Camera orbits around a focus between world center and dominant zone
      var focusBlend = 0.3; // 30% pull toward dominant zone
      var lookX = focusCenter.x * focusBlend;
      var lookZ = focusCenter.z * focusBlend;

      var camX = lookX + orbitRadius * Math.cos(angle);
      var camZ = lookZ + orbitRadius * Math.sin(angle);
      var camY = altitude;

      // Zoom in (lower fov) during high-activity periods
      var totalActivity = _sumZoneActivity(frame.zoneActivity);
      var activityFraction = Math.min(totalActivity / 100, 1);
      var fov = 60 - activityFraction * 20; // 60Â° â†’ 40Â°

      // Zoom in on notable events
      if (zoomOnEvents && frame.events && frame.events.length > 0) {
        fov = Math.max(fov - 10, 25);
        // Swoop closer to the active zone
        var activeCenter = ZONE_CENTERS[dominantZone] || ZONE_CENTERS.nexus;
        camX = activeCenter.x + 80 * Math.cos(angle);
        camZ = activeCenter.z + 80 * Math.sin(angle);
        camY = altitude * 0.6;
      }

      keyframes.push(_makeKeyframe(
        frame.tick,
        { x: camX, y: camY, z: camZ },
        { x: lookX, y: 0, z: lookZ },
        fov
      ));
    }

    return keyframes;
  }

  /**
   * getCameraAt(cameraPath, t) â€” interpolated camera state at normalized t (0-1).
   * Returns {position, lookAt, fov}.
   */
  function getCameraAt(cameraPath, t) {
    if (!cameraPath || cameraPath.length === 0) {
      return _makeKeyframe(0, { x: 0, y: 150, z: 300 }, { x: 0, y: 0, z: 0 }, 60);
    }

    if (cameraPath.length === 1) {
      return {
        position: { x: cameraPath[0].position.x, y: cameraPath[0].position.y, z: cameraPath[0].position.z },
        lookAt: { x: cameraPath[0].lookAt.x, y: cameraPath[0].lookAt.y, z: cameraPath[0].lookAt.z },
        fov: cameraPath[0].fov
      };
    }

    t = Math.max(0, Math.min(1, t));

    var pos = t * (cameraPath.length - 1);
    var lo = Math.floor(pos);
    var hi = Math.ceil(pos);
    var alpha = pos - lo;

    lo = Math.max(0, Math.min(cameraPath.length - 1, lo));
    hi = Math.max(0, Math.min(cameraPath.length - 1, hi));

    if (lo === hi) {
      return {
        position: { x: cameraPath[lo].position.x, y: cameraPath[lo].position.y, z: cameraPath[lo].position.z },
        lookAt: { x: cameraPath[lo].lookAt.x, y: cameraPath[lo].lookAt.y, z: cameraPath[lo].lookAt.z },
        fov: cameraPath[lo].fov
      };
    }

    var kA = cameraPath[lo];
    var kB = cameraPath[hi];

    return {
      position: {
        x: _lerp(kA.position.x, kB.position.x, alpha),
        y: _lerp(kA.position.y, kB.position.y, alpha),
        z: _lerp(kA.position.z, kB.position.z, alpha)
      },
      lookAt: {
        x: _lerp(kA.lookAt.x, kB.lookAt.x, alpha),
        y: _lerp(kA.lookAt.y, kB.lookAt.y, alpha),
        z: _lerp(kA.lookAt.z, kB.lookAt.z, alpha)
      },
      fov: _lerp(kA.fov, kB.fov, alpha)
    };
  }

  // â”€â”€â”€ Audio Mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * mapToAudio(frame) â€” derive procedural audio parameters from a frame.
   * Returns {tempo, harmony, intensity, instruments}
   */
  function mapToAudio(frame) {
    // Determine dominant zone
    var dominantZone = _getDominantZone(frame.zoneActivity);
    var harmony = ZONE_MOOD[dominantZone] || 'welcoming';

    // Tempo: base 60 BPM + up to 80 BPM based on total activity
    var totalActivity = _sumZoneActivity(frame.zoneActivity);
    var activityFraction = Math.min(totalActivity / 100, 1);
    var tempo = 60 + activityFraction * 80;

    // Intensity: weighted combination of activity, economy velocity, and events
    var eventWeight = Math.min((frame.events ? frame.events.length : 0) / 5, 1);
    var popFraction = Math.min((frame.population || 0) / 100, 1);
    var intensity = activityFraction * 0.5 + eventWeight * 0.3 + popFraction * 0.2;
    intensity = Math.max(0, Math.min(1, intensity));

    // Instruments based on which archetypes are known to inhabit dominant zone
    // Zone â†’ archetype affinity (from civilization_sim.py _pick_zone)
    var zoneArchetypes = {
      nexus:     ['gardener', 'builder', 'storyteller', 'merchant', 'teacher', 'musician', 'healer', 'philosopher', 'artist'],
      gardens:   ['gardener', 'healer', 'artist'],
      athenaeum: ['storyteller', 'teacher', 'philosopher'],
      studio:    ['builder', 'musician', 'artist'],
      wilds:     ['explorer', 'philosopher'],
      agora:     ['storyteller', 'merchant', 'musician'],
      commons:   ['gardener', 'merchant', 'healer'],
      arena:     ['builder', 'explorer']
    };

    var activeArchetypes = zoneArchetypes[dominantZone] || [];
    var instruments = [];
    var seen = {};
    for (var a = 0; a < activeArchetypes.length; a++) {
      var instr = ARCHETYPE_INSTRUMENT[activeArchetypes[a]];
      if (instr && !seen[instr]) {
        seen[instr] = true;
        instruments.push(instr);
      }
    }

    // Add a few secondary zone instruments proportional to activity
    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      if (zone !== dominantZone && (frame.zoneActivity[zone] || 0) > 5) {
        var secondaryArchetypes = zoneArchetypes[zone] || [];
        if (secondaryArchetypes.length > 0) {
          var instr2 = ARCHETYPE_INSTRUMENT[secondaryArchetypes[0]];
          if (instr2 && !seen[instr2]) {
            seen[instr2] = true;
            instruments.push(instr2);
          }
        }
      }
    }

    return {
      tempo: Math.round(tempo),
      harmony: harmony,
      intensity: intensity,
      instruments: instruments
    };
  }

  // â”€â”€â”€ Playback Controller â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * createController(timeline) â€” create a playback controller.
   *
   * controller.play(speed?)      â€” start playback
   * controller.pause()           â€” pause
   * controller.seek(tick)        â€” jump to tick
   * controller.getProgress()     â€” {currentTick, totalTicks, percent}
   * controller.onFrame(cb)       â€” called each tick advance with {frame, camera, audio}
   * controller.onEvent(cb)       â€” called on notable events
   * controller.setSpeed(n)       â€” set speed multiplier
   * controller.getSpeed()        â€” get current speed
   * controller.isPlaying()       â€” playback state
   * controller.update(dtMs)      â€” advance playback by dt milliseconds
   */
  function createController(timeline) {
    var currentTick = 0;
    var totalTicks = timeline.totalTicks || 0;
    var playing = false;
    var speed = 1;
    var frameCallbacks = [];
    var eventCallbacks = [];
    var cameraPath = generateCameraPath(timeline);
    var accumulatedMs = 0;

    // Track which notable events have fired
    var firedEvents = {};

    // Ticks-per-second at 1x speed â€” 1 tick per second
    var TICKS_PER_SECOND = 1;

    function getProgress() {
      var pct = totalTicks > 0 ? (currentTick / totalTicks) * 100 : 0;
      return {
        currentTick: currentTick,
        totalTicks: totalTicks,
        percent: pct
      };
    }

    function seek(tick) {
      currentTick = Math.max(0, Math.min(totalTicks, tick));
      accumulatedMs = 0;
      _fireFrame();
    }

    function play(s) {
      if (typeof s === 'number') speed = s;
      playing = true;
    }

    function pause() {
      playing = false;
    }

    function setSpeed(s) {
      speed = s;
    }

    function getSpeed() {
      return speed;
    }

    function isPlaying() {
      return playing;
    }

    function onFrame(cb) {
      frameCallbacks.push(cb);
    }

    function onEvent(cb) {
      eventCallbacks.push(cb);
    }

    /**
     * update(dtMs) â€” advance the controller by dtMs milliseconds.
     * Call this from your animation/game loop.
     */
    function update(dtMs) {
      if (!playing || totalTicks === 0) {
        _fireFrame();
        return;
      }

      accumulatedMs += dtMs * speed;
      var ticksToAdvance = Math.floor(accumulatedMs / (1000 / TICKS_PER_SECOND));
      accumulatedMs -= ticksToAdvance * (1000 / TICKS_PER_SECOND);

      if (ticksToAdvance <= 0) return;

      var oldTick = currentTick;
      currentTick = Math.min(totalTicks, currentTick + ticksToAdvance);

      if (currentTick !== oldTick) {
        _fireFrame();
        _checkEvents(oldTick, currentTick);
      }

      if (currentTick >= totalTicks) {
        playing = false;
      }
    }

    function _fireFrame() {
      if (frameCallbacks.length === 0) return;
      var t = totalTicks > 0 ? currentTick / totalTicks : 0;
      var interpFrame = interpolateFrame(timeline, t);
      var cam = getCameraAt(cameraPath, t);
      var audio = mapToAudio(interpFrame || (timeline.frames[0] || {}));
      var data = { frame: interpFrame, camera: cam, audio: audio };
      for (var i = 0; i < frameCallbacks.length; i++) {
        frameCallbacks[i](data);
      }
    }

    function _checkEvents(fromTick, toTick) {
      if (eventCallbacks.length === 0) return;
      var events = timeline.notableEvents || [];
      for (var i = 0; i < events.length; i++) {
        var ev = events[i];
        var evTick = ev.tick || 0;
        var evKey = evTick + '_' + i;
        if (evTick > fromTick && evTick <= toTick && !firedEvents[evKey]) {
          firedEvents[evKey] = true;
          for (var j = 0; j < eventCallbacks.length; j++) {
            eventCallbacks[j](ev);
          }
        }
      }
    }

    return {
      play: play,
      pause: pause,
      seek: seek,
      getProgress: getProgress,
      onFrame: onFrame,
      onEvent: onEvent,
      setSpeed: setSpeed,
      getSpeed: getSpeed,
      isPlaying: isPlaying,
      update: update
    };
  }

  // â”€â”€â”€ 2D Canvas Rendering Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * renderMinimap(ctx, frame, width, height) â€” draw zone activity minimap.
   * Renders the 8 zones as dots on a 2D projection of the world, sized by population.
   */
  function renderMinimap(ctx, frame, width, height) {
    var pad = 10;
    var w = width - pad * 2;
    var h = height - pad * 2;

    // World bounds: roughly -280 to +280 in X and Z
    var WORLD_SIZE = 320;

    // Background
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, width, height);

    // Border
    ctx.strokeStyle = '#1a1f30';
    ctx.lineWidth = 1;
    ctx.strokeRect(pad, pad, w, h);

    // Total activity for scaling
    var maxActivity = 0;
    for (var z = 0; z < ZONES.length; z++) {
      var act = frame.zoneActivity[ZONES[z]] || 0;
      if (act > maxActivity) maxActivity = act;
    }
    if (maxActivity === 0) maxActivity = 1;

    // Draw each zone
    for (var i = 0; i < ZONES.length; i++) {
      var zoneName = ZONES[i];
      var center = ZONE_CENTERS[zoneName];
      var activity = frame.zoneActivity[zoneName] || 0;
      var color = ZONE_COLORS[zoneName];

      // Map world coords to canvas
      var cx = pad + ((center.x + WORLD_SIZE) / (WORLD_SIZE * 2)) * w;
      var cy = pad + ((-center.z + WORLD_SIZE) / (WORLD_SIZE * 2)) * h; // Z is inverted

      // Radius based on activity (min 4, max 20)
      var radius = 4 + (activity / maxActivity) * 16;

      // Draw zone circle
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.3 + (activity / maxActivity) * 0.7;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Zone label
      ctx.fillStyle = '#ffffff';
      ctx.font = '9px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(zoneName.charAt(0).toUpperCase(), cx, cy + 3);

      // Activity count below label
      if (activity > 0) {
        ctx.fillStyle = color;
        ctx.font = '8px monospace';
        ctx.fillText(String(Math.round(activity)), cx, cy + radius + 10);
      }
    }

    // Reset text align
    ctx.textAlign = 'left';

    // Population overlay in top-left
    ctx.fillStyle = '#daa520';
    ctx.font = 'bold 11px monospace';
    ctx.fillText('Pop: ' + Math.round(frame.population), pad + 4, pad + 14);
  }

  /**
   * renderTimeline(ctx, timeline, currentTick, width, height) â€” draw scrubber bar.
   */
  function renderTimeline(ctx, timeline, currentTick, width, height) {
    var pad = 20;
    var barH = 8;
    var barY = height / 2 - barH / 2;
    var barW = width - pad * 2;

    // Background
    ctx.fillStyle = '#0a0e1a';
    ctx.fillRect(0, 0, width, height);

    // Track background
    ctx.fillStyle = '#1a1f30';
    ctx.fillRect(pad, barY, barW, barH);

    var frames = timeline.frames || [];
    var totalTicks = timeline.totalTicks || 1;

    // Color-coded segments by dominant zone
    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      var t = totalTicks > 0 ? frame.tick / totalTicks : 0;
      var x = pad + t * barW;
      var segW = frames.length > 1 && i < frames.length - 1
        ? (frames[i + 1].tick - frame.tick) / totalTicks * barW
        : 4;

      var dominantZone = _getDominantZone(frame.zoneActivity);
      ctx.fillStyle = ZONE_COLORS[dominantZone] || '#888';
      ctx.globalAlpha = 0.6;
      ctx.fillRect(x, barY, Math.max(segW, 2), barH);
      ctx.globalAlpha = 1;
    }

    // Event markers
    var events = timeline.notableEvents || [];
    for (var e = 0; e < events.length; e++) {
      var ev = events[e];
      var evTick = ev.tick || 0;
      var evT = totalTicks > 0 ? evTick / totalTicks : 0;
      var evX = pad + evT * barW;
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.8;
      ctx.fillRect(evX - 1, barY - 3, 2, barH + 6);
      ctx.globalAlpha = 1;
    }

    // Progress indicator (playhead)
    var progress = totalTicks > 0 ? currentTick / totalTicks : 0;
    var playX = pad + progress * barW;
    ctx.fillStyle = '#daa520';
    ctx.fillRect(playX - 2, barY - 4, 4, barH + 8);

    // Time labels
    ctx.fillStyle = '#666';
    ctx.font = '10px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('Tick 0', pad, height - 4);
    ctx.textAlign = 'right';
    ctx.fillText('Tick ' + totalTicks, pad + barW, height - 4);
    ctx.textAlign = 'center';
    ctx.fillText('Tick ' + Math.round(currentTick), playX, barY - 8);
    ctx.textAlign = 'left';
  }

  /**
   * renderStats(ctx, frame, x, y) â€” draw current stats overlay.
   */
  function renderStats(ctx, frame, x, y) {
    var lineH = 18;
    var padX = 12;
    var padY = 10;
    var bgW = 180;
    var bgH = 8 * lineH + padY * 2;

    // Background panel
    ctx.fillStyle = 'rgba(10, 14, 26, 0.85)';
    ctx.fillRect(x, y, bgW, bgH);
    ctx.strokeStyle = '#1a1f30';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, bgW, bgH);

    // Header
    ctx.fillStyle = '#daa520';
    ctx.font = 'bold 12px monospace';
    ctx.fillText('TICK ' + Math.round(frame.tick || 0), x + padX, y + padY + lineH * 0.7);

    // Stats
    var stats = [
      ['Population', Math.round(frame.population || 0)],
      ['Spark', Math.round((frame.economy && frame.economy.totalSpark) || 0)],
      ['Gini', ((frame.economy && frame.economy.gini) || 0).toFixed(3)],
      ['Weather', (frame.culture && frame.culture.weather) || 'clear'],
      ['Season', (frame.culture && frame.culture.season) || 'spring'],
      ['Phase', (frame.culture && frame.culture.dayPhase) || 'day'],
      ['Structures', (frame.culture && frame.culture.structures) || 0]
    ];

    ctx.font = '11px monospace';
    for (var i = 0; i < stats.length; i++) {
      var ly = y + padY + lineH * (i + 1.5);
      ctx.fillStyle = '#888';
      ctx.fillText(stats[i][0], x + padX, ly);
      ctx.fillStyle = '#e0e0e0';
      ctx.fillText(String(stats[i][1]), x + padX + 100, ly);
    }
  }

  /**
   * renderEventBanner(ctx, event) â€” draw event announcement banner.
   * Renders centered on its canvas (assumes ctx is full-width context).
   * Event: {type, description}
   */
  function renderEventBanner(ctx, event) {
    var desc = (event && event.description) ? event.description : '';
    var type = (event && event.type) ? event.type : 'event';
    var icon = EVENT_ICONS[type] || '!';

    // Banner colors by event type
    var bgColors = {
      discovery: '#0d2a0d',
      milestone: '#1a1400',
      build:     '#0a1a2a',
      creation:  '#1a0a1a',
      join:      '#0a1a0a',
      trade:     '#1a0f00',
      harvest:   '#0a1a0a',
      ubi:       '#0a0a1a'
    };
    var textColors = {
      discovery: '#4caf50',
      milestone: '#daa520',
      build:     '#2196f3',
      creation:  '#e040fb',
      join:      '#00bcd4',
      trade:     '#ff9800',
      harvest:   '#8bc34a',
      ubi:       '#9c27b0'
    };

    var bgColor = bgColors[type] || '#0a0e1a';
    var textColor = textColors[type] || '#e0e0e0';

    var bannerH = 44;
    var bannerY = 0;

    // Background bar
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, bannerY, 800, bannerH); // use 800 as default width

    ctx.strokeStyle = textColor;
    ctx.lineWidth = 2;
    ctx.strokeRect(0, bannerY, 800, bannerH);

    // Icon
    ctx.fillStyle = textColor;
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('[' + icon + ']', 16, bannerY + 28);

    // Description text
    ctx.fillStyle = '#e0e0e0';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText(desc, 60, bannerY + 28);

    ctx.textAlign = 'left';
  }

  // â”€â”€â”€ Internal Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function _cloneFrame(frame) {
    var zoneActivity = {};
    for (var z = 0; z < ZONES.length; z++) {
      zoneActivity[ZONES[z]] = frame.zoneActivity[ZONES[z]] || 0;
    }
    return {
      tick: frame.tick,
      population: frame.population,
      zoneActivity: zoneActivity,
      economy: {
        totalSpark: frame.economy.totalSpark,
        gini: frame.economy.gini,
        txnVolume: frame.economy.txnVolume,
        listings: frame.economy.listings,
        activeZones: frame.economy.activeZones
      },
      events: frame.events,
      culture: frame.culture
    };
  }

  function _makeKeyframe(tick, position, lookAt, fov) {
    return { tick: tick, position: position, lookAt: lookAt, fov: fov };
  }

  function _getDominantZone(zoneActivity) {
    var best = ZONES[0];
    var bestVal = -1;
    for (var z = 0; z < ZONES.length; z++) {
      var val = zoneActivity[ZONES[z]] || 0;
      if (val > bestVal) {
        bestVal = val;
        best = ZONES[z];
      }
    }
    return best;
  }

  function _sumZoneActivity(zoneActivity) {
    var total = 0;
    for (var z = 0; z < ZONES.length; z++) {
      total += zoneActivity[ZONES[z]] || 0;
    }
    return total;
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.loadSimData = loadSimData;
  exports.getFrame = getFrame;
  exports.interpolateFrame = interpolateFrame;
  exports.getSummary = getSummary;
  exports.generateCameraPath = generateCameraPath;
  exports.getCameraAt = getCameraAt;
  exports.mapToAudio = mapToAudio;
  exports.createController = createController;
  exports.renderMinimap = renderMinimap;
  exports.renderTimeline = renderTimeline;
  exports.renderStats = renderStats;
  exports.renderEventBanner = renderEventBanner;

  // Expose constants for external use
  exports.ZONES = ZONES;
  exports.ZONE_CENTERS = ZONE_CENTERS;
  exports.ZONE_MOOD = ZONE_MOOD;
  exports.ZONE_COLORS = ZONE_COLORS;
  exports.ARCHETYPE_INSTRUMENT = ARCHETYPE_INSTRUMENT;

})(typeof module !== 'undefined' ? module.exports : (window.Timelapse = {}));

// LAZY_LOAD_END: timelapse

// input.js
(function(exports) {
  // Input handling and protocol message generation
  var callbacks = {};
  var keys = {};
  var chatMode = false;
  var buildMode = false;
  var canvas = null;
  var mouseNDC = { x: 0, y: 0 }; // Normalized device coordinates

  // Camera control variables
  var cameraDistance = 20; // Default camera distance from player
  var cameraOrbitAngle = 0; // Horizontal orbit angle in radians
  var isDraggingCamera = false;
  var lastCameraDragX = 0;
  var lastCameraDragY = 0;

  /**
   * Initialize input handlers
   * @param {object} cbs - Callbacks
   * @param {function} cbs.onMove - Movement callback (delta, position)
   * @param {function} cbs.onAction - Action callback (type, data)
   * @param {function} cbs.onChat - Chat callback (message)
   * @param {function} cbs.onBuild - Build callback (data)
   */
  function initInput(cbs) {
    callbacks = cbs || {};

    if (typeof document === 'undefined') {
      console.warn('Input requires browser environment');
      return;
    }

    // Keyboard handlers
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    // Mouse handlers
    canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.addEventListener('click', handleMouseClick);
      canvas.addEventListener('contextmenu', handleContextMenu);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('wheel', handleMouseWheel, { passive: false });
    }

    // Global mouse up handler for camera drag
    document.addEventListener('mouseup', handleMouseUp);

    // Touch handlers for mobile
    if ('ontouchstart' in window) {
      initTouchControls();
    }

    console.log('Input system initialized');
  }

  /**
   * Handle key down
   */
  function handleKeyDown(e) {
    // Don't process game keys in chat mode (except Escape/Enter)
    if (chatMode && e.key !== 'Escape' && e.key !== 'Enter') {
      return;
    }

    keys[e.key.toLowerCase()] = true;

    // Special keys
    switch (e.key) {
      case 'Enter':
        if (chatMode) {
          chatMode = false;
        } else {
          chatMode = true;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: 'open' });
          }
        }
        e.preventDefault();
        break;

      case 'Escape':
        chatMode = false;
        buildMode = false;
        if (callbacks.onAction) {
          callbacks.onAction('toggleSettings', {});
        }
        e.preventDefault();
        break;

      case 'b':
      case 'B':
        if (!chatMode) {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
          e.preventDefault();
        }
        break;

      case 'e':
      case 'E':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('interact', {});
          }
          e.preventDefault();
        }
        break;

      case 'i':
      case 'I':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleInventory', {});
          }
          e.preventDefault();
        }
        break;

      case 'c':
      case 'C':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleCrafting', {});
          }
          e.preventDefault();
        }
        break;

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '0':
        if (!chatMode) {
          if (buildMode && callbacks.onBuild) {
            // In build mode, number keys select build type
            var typeIndex = (e.key === '0' ? 9 : parseInt(e.key) - 1);
            callbacks.onBuild({ action: 'selectType', typeIndex: typeIndex });
          } else if (callbacks.onAction && parseInt(e.key) >= 1 && parseInt(e.key) <= 5) {
            // Outside build mode, 1-5 are quick slots
            callbacks.onAction('useQuickSlot', { slot: parseInt(e.key) - 1 });
          }
          e.preventDefault();
        }
        break;

      case 'j':
      case 'J':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggle_quest_log', {});
          }
          e.preventDefault();
        }
        break;

      case 't':
      case 'T':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('initiate_trade', {});
          }
          e.preventDefault();
        }
        break;

      case 'f':
      case 'F':
        if (!chatMode) {
          // F key toggles emote menu
          if (callbacks.onAction) {
            callbacks.onAction('toggleEmoteMenu', {});
          }
          e.preventDefault();
        }
        break;

      case 'm':
      case 'M':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleMap', {});
          }
          e.preventDefault();
        }
        break;

      case 'p':
      case 'P':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleProfile', {});
          }
          e.preventDefault();
        }
        break;

      case 'k':
      case 'K':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleSkills', {});
          }
          e.preventDefault();
        }
        break;

      case 'n':
      case 'N':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleCompose', {});
          }
          e.preventDefault();
        }
        break;

      case 'g':
      case 'G':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleGuild', {});
          }
          e.preventDefault();
        }
        break;

      case 'l':
      case 'L':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleLoreJournal', {});
          }
          e.preventDefault();
        }
        break;

      case 'v':
      case 'V':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleDiscoveryLog', {});
          }
          e.preventDefault();
        }
        break;

      case 'h':
      case 'H':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleGovernance', {});
          }
          e.preventDefault();
        }
        break;

      case 'u':
      case 'U':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAuctionHouse', {});
          }
          e.preventDefault();
        }
        break;

      case 'y':
      case 'Y':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAchievements', {});
          }
          e.preventDefault();
        }
        break;

      case 'r':
      case 'R':
        if (!chatMode && buildMode) {
          // R key rotates build preview
          if (callbacks.onBuild) {
            callbacks.onBuild({ action: 'rotate' });
          }
          e.preventDefault();
        }
        break;

      case 'q':
      case 'Q':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('togglePetPanel', {});
          }
          e.preventDefault();
        }
        break;

      case 'x':
      case 'X':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('startFishing', {});
          }
          e.preventDefault();
        }
        break;

      case 'j':
      case 'J':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleAnchorPanel', {});
          }
          e.preventDefault();
        }
        break;

      case 'n':
      case 'N':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleFederationProposal', {});
          }
          e.preventDefault();
        }
        break;

      case 'z':
      case 'Z':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('toggleHousing', {});
          }
          e.preventDefault();
        }
        break;

      case 'F2':
        if (!chatMode) {
          if (callbacks.onAction) {
            callbacks.onAction('togglePhotoMode', {});
          }
          e.preventDefault();
        }
        break;
    }

    // Emote hotkeys: F+Number
    if (!chatMode && (keys['f'] || keys['F'])) {
      var emoteType = null;
      switch (e.key) {
        case '1': emoteType = 'wave'; break;
        case '2': emoteType = 'dance'; break;
        case '3': emoteType = 'bow'; break;
        case '4': emoteType = 'cheer'; break;
        case '5': emoteType = 'meditate'; break;
        case '6': emoteType = 'point'; break;
      }
      if (emoteType && callbacks.onAction) {
        callbacks.onAction('emote', { type: emoteType });
        e.preventDefault();
      }
    }
  }

  /**
   * Handle key up
   */
  function handleKeyUp(e) {
    keys[e.key.toLowerCase()] = false;
  }

  /**
   * Handle mouse click
   */
  function handleMouseClick(e) {
    if (!canvas) return;

    var rect = canvas.getBoundingClientRect();
    var x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    var y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    // In build mode, click places structure
    if (buildMode && callbacks.onBuild) {
      callbacks.onBuild({ action: 'place', x: x, y: y });
    } else if (callbacks.onAction) {
      callbacks.onAction('click', { x, y, screenX: e.clientX, screenY: e.clientY });
    }
  }

  /**
   * Handle context menu (right-click)
   */
  function handleContextMenu(e) {
    e.preventDefault();

    if (callbacks.onAction) {
      callbacks.onAction('context', { x: e.clientX, y: e.clientY });
    }
  }

  /**
   * Handle mouse move
   */
  function handleMouseMove(e) {
    if (!canvas) return;

    var rect = canvas.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    // Handle camera orbit dragging
    if (isDraggingCamera) {
      var deltaX = e.clientX - lastCameraDragX;
      var deltaY = e.clientY - lastCameraDragY;

      // Adjust orbit angle based on horizontal drag
      cameraOrbitAngle -= deltaX * 0.005;

      lastCameraDragX = e.clientX;
      lastCameraDragY = e.clientY;
    }
  }

  /**
   * Handle mouse down for camera drag
   */
  function handleMouseDown(e) {
    // Right-click or middle-click for camera orbit
    if (e.button === 2 || e.button === 1) {
      isDraggingCamera = true;
      lastCameraDragX = e.clientX;
      lastCameraDragY = e.clientY;
      e.preventDefault();
    }
  }

  /**
   * Handle mouse up
   */
  function handleMouseUp(e) {
    if (e.button === 2 || e.button === 1) {
      isDraggingCamera = false;
    }
  }

  /**
   * Handle mouse wheel for camera zoom
   */
  function handleMouseWheel(e) {
    e.preventDefault();

    // Adjust camera distance with constraints
    cameraDistance += e.deltaY * 0.02;
    cameraDistance = Math.max(5, Math.min(50, cameraDistance));
  }

  /**
   * Get current mouse position in NDC
   */
  function getMouseNDC() {
    return mouseNDC;
  }

  /**
   * Get camera distance (for zoom)
   */
  function getCameraDistance() {
    return cameraDistance;
  }

  /**
   * Get camera orbit angle
   */
  function getCameraOrbit() {
    return cameraOrbitAngle;
  }

  /**
   * Initialize touch controls (virtual joystick and action buttons)
   */
  function initTouchControls() {
    if (typeof document === 'undefined') return;

    // Only show on mobile devices
    var platform = getPlatform();
    if (platform !== 'phone') return;

    // Create improved virtual joystick (left side) - larger and more responsive
    var joystick = document.createElement('div');
    joystick.id = 'virtual-joystick';
    joystick.style.cssText = `
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      border: 3px solid rgba(218,165,32,0.6);
      touch-action: none;
      z-index: 1000;
    `;

    var stick = document.createElement('div');
    stick.style.cssText = `
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(218,165,32,0.8);
      top: 35px;
      left: 35px;
      touch-action: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    joystick.appendChild(stick);
    document.body.appendChild(joystick);

    // Joystick touch handler
    var touchStartPos = { x: 0, y: 0 };
    var isDragging = false;

    joystick.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      var touch = e.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
    });

    joystick.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      e.preventDefault();

      var touch = e.touches[0];
      var deltaX = touch.clientX - touchStartPos.x;
      var deltaY = touch.clientY - touchStartPos.y;

      // Limit stick movement
      var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      var maxDistance = 35;
      var normalizedDelta = {
        x: deltaX / maxDistance,
        y: deltaY / maxDistance
      };

      if (distance > maxDistance) {
        stick.style.left = (35 + (deltaX / distance) * maxDistance) + 'px';
        stick.style.top = (35 + (deltaY / distance) * maxDistance) + 'px';
      } else {
        stick.style.left = (35 + deltaX) + 'px';
        stick.style.top = (35 + deltaY) + 'px';
      }

      // Send movement
      if (callbacks.onMove) {
        callbacks.onMove({
          x: normalizedDelta.x,
          y: 0,
          z: -normalizedDelta.y // Invert Y for forward/back
        });
      }
    });

    joystick.addEventListener('touchend', (e) => {
      e.preventDefault();
      isDragging = false;
      stick.style.left = '35px';
      stick.style.top = '35px';
    });

    // Create action buttons overlay (bottom-right, circular arc layout)
    var actionButtons = [
      { label: 'E', action: 'interact', size: 50, angle: 0, radius: 0, color: 'rgba(218,165,32,0.7)' },
      { label: 'I', action: 'toggleInventory', size: 45, angle: -45, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'J', action: 'toggle_quest_log', size: 45, angle: -90, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'B', action: 'toggleBuild', size: 45, angle: 45, radius: 70, color: 'rgba(218,165,32,0.7)' },
      { label: 'ðŸ’¬', action: 'toggleChat', size: 45, angle: 90, radius: 70, color: 'rgba(218,165,32,0.7)' }
    ];

    var baseX = window.innerWidth - 80;
    var baseY = window.innerHeight - 80;

    actionButtons.forEach(function(btn) {
      var button = document.createElement('button');
      button.textContent = btn.label;

      // Calculate position using angle and radius
      var angleRad = (btn.angle * Math.PI) / 180;
      var x = baseX + btn.radius * Math.cos(angleRad);
      var y = baseY + btn.radius * Math.sin(angleRad);

      button.style.cssText = `
        position: fixed;
        bottom: ${window.innerHeight - y - btn.size/2}px;
        right: ${window.innerWidth - x - btn.size/2}px;
        width: ${btn.size}px;
        height: ${btn.size}px;
        border-radius: 50%;
        background: ${btn.color};
        border: 3px solid rgba(218,165,32,0.9);
        color: white;
        font-size: ${btn.size === 50 ? 20 : 16}px;
        font-weight: bold;
        z-index: 1000;
        touch-action: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        display: flex;
        align-items: center;
        justify-content: center;
      `;

      button.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (btn.action === 'toggleBuild') {
          buildMode = !buildMode;
          if (callbacks.onBuild) {
            callbacks.onBuild({ mode: buildMode });
          }
        } else if (btn.action === 'toggleChat') {
          chatMode = !chatMode;
          if (callbacks.onChat) {
            callbacks.onChat({ mode: chatMode ? 'open' : 'close' });
          }
        } else if (callbacks.onAction) {
          callbacks.onAction(btn.action, {});
        }
      });

      document.body.appendChild(button);
    });

    // Add pinch-to-zoom support
    var lastPinchDistance = 0;

    if (canvas) {
      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);
    }

    var touchStartTime = 0;
    var touchStartX = 0;
    var touchStartY = 0;
    var lastTouchX = 0;
    var lastTouchY = 0;
    var isTouchDragging = false;
    var wasPinching = false;

    function handleTouchStart(e) {
      if (e.touches.length === 2) {
        // Two-finger pinch for zoom
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
        wasPinching = true;
        isTouchDragging = false;
      } else if (e.touches.length === 1) {
        // Single touch - track for tap detection and camera orbit
        touchStartTime = Date.now();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        isTouchDragging = false;
        wasPinching = false;
      }
    }

    function handleTouchMove(e) {
      if (e.touches.length === 2) {
        // Pinch zoom
        e.preventDefault();
        var dx = e.touches[0].clientX - e.touches[1].clientX;
        var dy = e.touches[0].clientY - e.touches[1].clientY;
        var distance = Math.sqrt(dx * dx + dy * dy);

        if (lastPinchDistance > 0) {
          var delta = lastPinchDistance - distance;
          cameraDistance += delta * 0.1;
          cameraDistance = Math.max(5, Math.min(50, cameraDistance));
        }

        lastPinchDistance = distance;
        wasPinching = true;
      } else if (e.touches.length === 1 && !wasPinching) {
        // Single-finger drag for camera orbit
        var touchX = e.touches[0].clientX;
        var touchY = e.touches[0].clientY;
        var totalDx = touchX - touchStartX;
        var totalDy = touchY - touchStartY;
        var totalMoved = Math.sqrt(totalDx * totalDx + totalDy * totalDy);

        if (totalMoved > 10) {
          // Past drag threshold â€” orbit camera
          isTouchDragging = true;
          var deltaX = touchX - lastTouchX;
          cameraOrbitAngle -= deltaX * 0.008;
        }

        lastTouchX = touchX;
        lastTouchY = touchY;
      }
    }

    function handleTouchEnd(e) {
      if (e.touches.length < 2) {
        lastPinchDistance = 0;
      }

      // Tap-to-interact detection (not pinch, not drag)
      if (!wasPinching && !isTouchDragging && e.changedTouches.length === 1 && touchStartTime > 0) {
        var touchEndTime = Date.now();
        var touchEndX = e.changedTouches[0].clientX;
        var touchEndY = e.changedTouches[0].clientY;

        var timeDiff = touchEndTime - touchStartTime;
        var dx = touchEndX - touchStartX;
        var dy = touchEndY - touchStartY;
        var distanceMoved = Math.sqrt(dx * dx + dy * dy);

        // Tap if quick (< 300ms) and minimal movement (< 10px)
        if (timeDiff < 300 && distanceMoved < 10) {
          var rect = canvas.getBoundingClientRect();
          var x = ((touchEndX - rect.left) / rect.width) * 2 - 1;
          var y = -((touchEndY - rect.top) / rect.height) * 2 + 1;

          if (callbacks.onAction) {
            callbacks.onAction('click', { x: x, y: y, screenX: touchEndX, screenY: touchEndY });
          }
        }
      }

      isTouchDragging = false;
      wasPinching = false;
    }
  }

  /**
   * Get movement delta from keyboard state
   * @returns {object} - {x, y, z}
   */
  function getMovementDelta() {
    if (chatMode) return { x: 0, y: 0, z: 0 };

    var delta = { x: 0, y: 0, z: 0 };

    // WASD / Arrow keys
    if (keys['w'] || keys['arrowup']) delta.z -= 1;
    if (keys['s'] || keys['arrowdown']) delta.z += 1;
    if (keys['a'] || keys['arrowleft']) delta.x -= 1;
    if (keys['d'] || keys['arrowright']) delta.x += 1;

    // Normalize diagonal movement
    if (delta.x !== 0 && delta.z !== 0) {
      var length = Math.sqrt(delta.x * delta.x + delta.z * delta.z);
      delta.x /= length;
      delta.z /= length;
    }

    return delta;
  }

  /**
   * Detect platform
   * @returns {string} - 'desktop', 'phone', 'vr', 'ar'
   */
  function getPlatform() {
    if (typeof navigator === 'undefined') return 'desktop';

    var ua = navigator.userAgent.toLowerCase();

    // Check WebXR
    if (navigator.xr) {
      // Note: Actual VR/AR detection requires async check, this is just availability
      return 'desktop'; // Default, can be upgraded to VR/AR when session starts
    }

    // Check mobile
    if (/mobile|android|iphone|ipad|tablet/.test(ua)) {
      return 'phone';
    }

    return 'desktop';
  }

  /**
   * Create move protocol message
   * @param {string} from - Player ID
   * @param {object} delta - Movement delta {x, y, z}
   * @param {object} currentPosition - Current position {x, y, z}
   * @param {string} zone - Current zone
   * @returns {object} - Protocol message
   */
  function createMoveMessage(from, delta, currentPosition, zone) {
    var baseSpeed = 0.3; // Units per frame
    var speed = (keys['shift']) ? baseSpeed * 2.0 : baseSpeed; // Sprint with Shift
    var newPosition = {
      x: currentPosition.x + delta.x * speed,
      y: currentPosition.y + delta.y * speed,
      z: currentPosition.z + delta.z * speed
    };

    return {
      type: 'move',
      from: from,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        position: newPosition,
        zone: zone
      }
    };
  }

  // Export public API
  exports.initInput = initInput;
  exports.getMovementDelta = getMovementDelta;
  exports.getPlatform = getPlatform;
  exports.createMoveMessage = createMoveMessage;
  exports.getMouseNDC = getMouseNDC;
  exports.getCameraDistance = getCameraDistance;
  exports.getCameraOrbit = getCameraOrbit;

})(typeof module !== 'undefined' ? module.exports : (window.Input = {}));


// hud.js
(function(exports) {
  // HUD overlay management
  let hudContainer = null;
  let chatPanel = null;
  let playerInfoPanel = null;
  let minimapCanvas = null;
  let minimapCtx = null;
  let zoneLabel = null;
  let nearbyPlayersList = null;
  let chatInput = null;
  let notificationContainer = null;
  let federationPanel = null;

  /**
   * Initialize HUD
   * @param {HTMLElement} container - Parent container for HUD
   */
  function initHUD(container) {
    if (typeof document === 'undefined') {
      console.warn('HUD requires browser environment');
      return;
    }

    hudContainer = container;

    // Create main HUD overlay
    const hudOverlay = document.createElement('div');
    hudOverlay.id = 'zion-hud';
    hudOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      font-family: Arial, sans-serif;
      color: white;
      z-index: 100;
    `;

    // Chat panel (bottom-left)
    chatPanel = document.createElement('div');
    chatPanel.id = 'chat-panel';
    chatPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 350px;
      height: 200px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      pointer-events: auto;
      font-size: 14px;
    `;
    hudOverlay.appendChild(chatPanel);

    // Player info panel (top-left)
    playerInfoPanel = document.createElement('div');
    playerInfoPanel.id = 'player-info';
    playerInfoPanel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 15px;
      min-width: 200px;
      pointer-events: auto;
    `;
    hudOverlay.appendChild(playerInfoPanel);

    // Zone label (top-center)
    zoneLabel = document.createElement('div');
    zoneLabel.id = 'zone-label';
    zoneLabel.style.cssText = `
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
    `;
    hudOverlay.appendChild(zoneLabel);

    // Minimap (top-right)
    const minimapContainer = document.createElement('div');
    minimapContainer.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      pointer-events: auto;
    `;

    minimapCanvas = document.createElement('canvas');
    minimapCanvas.width = 200;
    minimapCanvas.height = 200;
    minimapCanvas.style.cssText = `
      display: block;
      border-radius: 4px;
    `;
    minimapCtx = minimapCanvas.getContext('2d');
    minimapContainer.appendChild(minimapCanvas);
    hudOverlay.appendChild(minimapContainer);

    // Nearby players list (right side)
    nearbyPlayersList = document.createElement('div');
    nearbyPlayersList.id = 'nearby-players';
    nearbyPlayersList.style.cssText = `
      position: absolute;
      top: 200px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      padding: 10px;
      min-width: 150px;
      max-height: 300px;
      overflow-y: auto;
      pointer-events: auto;
    `;
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';
    hudOverlay.appendChild(nearbyPlayersList);

    // Federation status panel (bottom-right)
    federationPanel = document.createElement('div');
    federationPanel.id = 'federation-panel';
    federationPanel.style.cssText = `
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      padding: 10px;
      min-width: 200px;
      max-height: 250px;
      overflow-y: auto;
      pointer-events: auto;
      border: 2px solid rgba(100, 100, 255, 0.5);
    `;
    federationPanel.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #88f;">Federation</div>';
    hudOverlay.appendChild(federationPanel);

    // Notification container (top-center, below zone label)
    notificationContainer = document.createElement('div');
    notificationContainer.id = 'notifications';
    notificationContainer.style.cssText = `
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      pointer-events: none;
    `;
    hudOverlay.appendChild(notificationContainer);

    container.appendChild(hudOverlay);

    console.log('HUD initialized');
  }

  /**
   * Update chat panel
   * @param {Array} messages - Array of {user, text, timestamp}
   */
  function updateChat(messages) {
    if (!chatPanel) return;

    chatPanel.innerHTML = '';

    messages.slice(-10).forEach(msg => {
      const msgEl = document.createElement('div');
      msgEl.style.cssText = `
        margin-bottom: 5px;
        padding: 3px;
        border-radius: 3px;
      `;

      const time = new Date(msg.timestamp).toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });

      msgEl.innerHTML = `
        <span style="color: #888; font-size: 11px;">${time}</span>
        <span style="color: #4af; font-weight: bold;">${msg.user}:</span>
        <span>${msg.text}</span>
      `;

      chatPanel.appendChild(msgEl);
    });

    // Auto-scroll to bottom
    chatPanel.scrollTop = chatPanel.scrollHeight;
  }

  /**
   * Add a single chat message to the chat panel
   * @param {string} user - Sender name
   * @param {string} text - Message text
   */
  function addChatMessage(user, text) {
    if (!chatPanel || typeof document === 'undefined') return;

    var msgEl = document.createElement('div');
    msgEl.style.cssText = 'margin-bottom:5px;padding:3px;border-radius:3px;';

    var time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    msgEl.innerHTML =
      '<span style="color:#888;font-size:11px;">' + time + '</span> ' +
      '<span style="color:#4af;font-weight:bold;">' + (user || 'Unknown') + ':</span> ' +
      '<span>' + (text || '') + '</span>';

    chatPanel.appendChild(msgEl);
    chatPanel.scrollTop = chatPanel.scrollHeight;

    // Keep last 50 messages max
    while (chatPanel.children.length > 50) {
      chatPanel.removeChild(chatPanel.firstChild);
    }
  }

  /**
   * Update player info panel
   * @param {object} player - {name, spark, zone, warmth}
   */
  function updatePlayerInfo(player) {
    if (!playerInfoPanel) return;

    playerInfoPanel.innerHTML = `
      <div style="font-weight: bold; font-size: 16px; margin-bottom: 8px;">${player.name || 'Unknown'}</div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ffa500;">Spark:</span> ${player.spark || 0}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #4af;">Zone:</span> ${player.zone || 'Unknown'}
      </div>
      <div style="margin-bottom: 3px;">
        <span style="color: #ff6347;">Warmth:</span> ${Math.round(player.warmth || 0)}%
      </div>
    `;
  }

  /**
   * Update minimap
   * @param {Array} players - Array of {id, position, isLocal}
   * @param {string} currentZone - Current zone name
   */
  // World zone coordinates for minimap
  var MINIMAP_ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, color: '#6688cc', label: 'Nexus' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, color: '#44aa44', label: 'Gardens' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, color: '#8866aa', label: 'Athenaeum' },
    studio:     { cx: -200, cz: -100, radius: 60, color: '#cc6688', label: 'Studio' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, color: '#228844', label: 'Wilds' },
    agora:      { cx: -190, cz: 120,  radius: 55, color: '#cc8844', label: 'Agora' },
    commons:    { cx: 170,  cz: 190,  radius: 55, color: '#88aa44', label: 'Commons' },
    arena:      { cx: 0,    cz: -240, radius: 55, color: '#cc4444', label: 'Arena' }
  };

  function updateMinimap(players, currentZone) {
    if (!minimapCtx) return;

    var w = minimapCanvas.width;
    var h = minimapCanvas.height;

    // Clear with dark background
    minimapCtx.fillStyle = '#0a0e1a';
    minimapCtx.fillRect(0, 0, w, h);

    // World bounds: roughly -300 to 300 on both axes
    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var margin = 8;

    function worldToMap(wx, wz) {
      return {
        x: margin + ((wx - worldMin) / worldRange) * (w - margin * 2),
        y: margin + ((wz - worldMin) / worldRange) * (h - margin * 2)
      };
    }

    // Draw paths between zones (nexus to each)
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.15)';
    minimapCtx.lineWidth = 1;
    var nexusPos = worldToMap(0, 0);
    for (var zId in MINIMAP_ZONES) {
      if (zId === 'nexus') continue;
      var z = MINIMAP_ZONES[zId];
      var zPos = worldToMap(z.cx, z.cz);
      minimapCtx.beginPath();
      minimapCtx.moveTo(nexusPos.x, nexusPos.y);
      minimapCtx.lineTo(zPos.x, zPos.y);
      minimapCtx.stroke();
    }

    // Draw zone circles
    for (var zoneId in MINIMAP_ZONES) {
      var zone = MINIMAP_ZONES[zoneId];
      var pos = worldToMap(zone.cx, zone.cz);
      var r = (zone.radius / worldRange) * (w - margin * 2);

      // Zone circle fill
      minimapCtx.globalAlpha = zoneId === currentZone ? 0.4 : 0.2;
      minimapCtx.fillStyle = zone.color;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      minimapCtx.fill();

      // Zone circle border
      minimapCtx.globalAlpha = zoneId === currentZone ? 0.9 : 0.4;
      minimapCtx.strokeStyle = zone.color;
      minimapCtx.lineWidth = zoneId === currentZone ? 2 : 1;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      minimapCtx.stroke();

      // Zone label
      minimapCtx.globalAlpha = zoneId === currentZone ? 1.0 : 0.5;
      minimapCtx.fillStyle = '#fff';
      minimapCtx.font = (zoneId === currentZone ? 'bold ' : '') + '8px Arial';
      minimapCtx.textAlign = 'center';
      minimapCtx.fillText(zone.label, pos.x, pos.y + 3);
    }

    minimapCtx.globalAlpha = 1.0;

    // Draw players
    players.forEach(function(player) {
      var pp = worldToMap(player.position.x, player.position.z);

      if (player.isLocal) {
        // Local player â€” larger bright gold dot with white border
        minimapCtx.fillStyle = '#FFD700';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.fill();
        // White border
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.lineWidth = 1.5;
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.stroke();
        // Add subtle glow
        minimapCtx.shadowBlur = 8;
        minimapCtx.shadowColor = '#FFD700';
        minimapCtx.fillStyle = '#FFD700';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 4, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.shadowBlur = 0;
      } else {
        // Other players â€” smaller green dots
        minimapCtx.fillStyle = '#44ff44';
        minimapCtx.beginPath();
        minimapCtx.arc(pp.x, pp.y, 2, 0, Math.PI * 2);
        minimapCtx.fill();
      }
    });

    // Draw border
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    minimapCtx.lineWidth = 1;
    minimapCtx.strokeRect(0, 0, w, h);
  }

  /**
   * Update zone label
   * @param {string} zoneName
   */
  var ZONE_DISPLAY_NAMES = {
    nexus: 'The Nexus',
    gardens: 'The Living Gardens',
    athenaeum: 'The Athenaeum',
    studio: 'The Studio',
    wilds: 'The Wilds',
    agora: 'The Agora',
    commons: 'The Commons',
    arena: 'The Arena'
  };

  function updateZoneLabel(zoneName) {
    if (!zoneLabel) return;
    var display = ZONE_DISPLAY_NAMES[zoneName] || zoneName || 'Unknown Zone';
    zoneLabel.innerHTML = '<div style="font-size:18px;font-weight:bold;">' + display + '</div>';
  }

  /**
   * Update nearby players list
   * @param {Array} players - Array of {id, name, distance}
   */
  function updateNearbyPlayers(players) {
    if (!nearbyPlayersList) return;

    // Keep header, remove old entries
    nearbyPlayersList.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Nearby Players</div>';

    if (players.length === 0) {
      const emptyMsg = document.createElement('div');
      emptyMsg.style.cssText = 'color: #888; font-size: 12px; font-style: italic;';
      emptyMsg.textContent = 'No players nearby';
      nearbyPlayersList.appendChild(emptyMsg);
      return;
    }

    players.slice(0, 10).forEach(player => {
      const playerEl = document.createElement('div');
      playerEl.style.cssText = `
        padding: 5px;
        margin-bottom: 3px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-size: 13px;
      `;

      const distanceStr = player.distance ? `(${player.distance.toFixed(1)}m)` : '';
      playerEl.innerHTML = `
        <span style="color: #4f4;">${player.name || player.id}</span>
        <span style="color: #888; font-size: 11px; margin-left: 5px;">${distanceStr}</span>
      `;

      nearbyPlayersList.appendChild(playerEl);
    });
  }

  /**
   * Show break reminder
   * @param {number} minutes - Minutes played
   */
  function showBreakReminder(minutes) {
    showNotification(
      `You've been playing for ${minutes} minutes. Consider taking a break!`,
      'info'
    );
  }

  /**
   * Add chat input field
   * @param {function} onSubmit - Callback when message is submitted
   */
  function addChatInput(onSubmit) {
    if (!hudContainer || chatInput) return;
    if (typeof document === 'undefined') return;

    chatInput = document.createElement('input');
    chatInput.type = 'text';
    chatInput.placeholder = 'Press Enter to chat...';
    chatInput.style.cssText = `
      position: absolute;
      bottom: 230px;
      left: 20px;
      width: 330px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #4af;
      border-radius: 4px;
      color: white;
      font-size: 14px;
      pointer-events: auto;
      display: none;
    `;

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const text = chatInput.value.trim();
        if (text && onSubmit) {
          onSubmit(text);
        }
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      } else if (e.key === 'Escape') {
        chatInput.value = '';
        chatInput.style.display = 'none';
        e.preventDefault();
      }
    });

    document.querySelector('#zion-hud').appendChild(chatInput);
  }

  /**
   * Show chat input (called when chat mode activated)
   */
  function showChatInput() {
    if (chatInput) {
      chatInput.style.display = 'block';
      chatInput.focus();
    }
  }

  /**
   * Hide chat input
   */
  function hideChatInput() {
    if (chatInput) {
      chatInput.style.display = 'none';
      chatInput.value = '';
    }
  }

  /**
   * Show notification
   * @param {string} text - Notification text
   * @param {string} type - 'info', 'success', 'warning', 'error'
   */
  function showNotification(text, type = 'info') {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const colors = {
      info: '#4af',
      success: '#4f4',
      warning: '#fa4',
      error: '#f44'
    };

    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.style.cssText = `
      background: rgba(0, 0, 0, 0.8);
      border-left: 4px solid ${colors[type] || colors.info};
      border-radius: 4px;
      padding: 12px 15px;
      margin-bottom: 10px;
      pointer-events: auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    // Add visible class after a frame for animation
    requestAnimationFrame(function() {
      notification.classList.add('visible');
    });

    // Auto-remove after 5 seconds
    setTimeout(function() {
      notification.classList.remove('visible');
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 5000);
  }

  // Add CSS animations
  if (typeof document !== 'undefined') {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateY(0);
          opacity: 1;
        }
        to {
          transform: translateY(-20px);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }

  // ========================================================================
  // ACTION TOOLBAR
  // ========================================================================

  var toolbarEl = null;
  var coordsEl = null;
  var weatherEl = null;
  var timeEl = null;

  function initToolbar() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    // Bottom toolbar with action buttons
    toolbarEl = document.createElement('div');
    toolbarEl.id = 'action-toolbar';
    toolbarEl.style.cssText = 'position:absolute;bottom:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto;';

    var actions = [
      { key: 'E', label: 'Interact', color: '#44aa66' },
      { key: 'B', label: 'Build', color: '#aa6644' },
      { key: 'Enter', label: 'Chat', color: '#4488cc' },
      { key: 'Shift', label: 'Sprint', color: '#cc8844' }
    ];

    actions.forEach(function(action) {
      var btn = document.createElement('div');
      btn.style.cssText = 'background:rgba(0,0,0,0.7);border:1px solid ' + action.color + ';border-radius:6px;padding:6px 12px;text-align:center;font-size:11px;min-width:50px;';
      btn.innerHTML = '<div style="font-weight:bold;color:' + action.color + ';font-size:14px;">' + action.key + '</div><div style="color:#aaa;margin-top:2px;">' + action.label + '</div>';
      toolbarEl.appendChild(btn);
    });
    hud.appendChild(toolbarEl);

    // Coordinates display (bottom-left above chat)
    coordsEl = document.createElement('div');
    coordsEl.id = 'coords-display';
    coordsEl.style.cssText = 'position:absolute;bottom:240px;left:20px;background:rgba(0,0,0,0.5);border-radius:4px;padding:4px 8px;font-size:11px;color:#888;font-family:monospace;pointer-events:none;';
    hud.appendChild(coordsEl);

    // Weather and time display (top-right, below minimap)
    var infoPanel = document.createElement('div');
    infoPanel.style.cssText = 'position:absolute;top:260px;right:20px;background:rgba(0,0,0,0.6);border-radius:8px;padding:10px;min-width:120px;font-size:12px;pointer-events:none;';

    timeEl = document.createElement('div');
    timeEl.style.cssText = 'margin-bottom:4px;';
    infoPanel.appendChild(timeEl);

    weatherEl = document.createElement('div');
    weatherEl.style.cssText = 'color:#aaa;';
    infoPanel.appendChild(weatherEl);

    hud.appendChild(infoPanel);
  }

  function updateCoords(position) {
    if (!coordsEl || !position) return;
    coordsEl.textContent = 'X: ' + Math.round(position.x) + '  Y: ' + Math.round(position.y) + '  Z: ' + Math.round(position.z);
  }

  function updateTimeWeather(worldTime, weather) {
    if (timeEl) {
      var hours = Math.floor(worldTime / 60);
      var mins = Math.floor(worldTime % 60);
      var ampm = hours >= 12 ? 'PM' : 'AM';
      var displayHour = hours % 12 || 12;
      var timeStr = displayHour + ':' + (mins < 10 ? '0' : '') + mins + ' ' + ampm;
      var icon = (hours >= 6 && hours < 18) ? '&#9728;' : '&#9790;'; // sun or moon
      timeEl.innerHTML = icon + ' ' + timeStr;
    }
    if (weatherEl && weather) {
      var weatherIcons = { clear: '&#9728;', cloudy: '&#9729;', rain: '&#127783;', snow: '&#10052;' };
      var icon = weatherIcons[weather] || '';
      weatherEl.innerHTML = icon + ' ' + weather.charAt(0).toUpperCase() + weather.slice(1);
    }
  }

  // ========================================================================
  // NPC INTERACTION DIALOG
  // ========================================================================

  var npcDialogEl = null;
  var npcDialogTimer = null;
  var npcActionCallback = null;
  var npcShopPanel = null;

  // Archetype colors for NPC portraits
  var ARCHETYPE_COLORS_HUD = {
    gardener: '#4CAF50', builder: '#8D6E63', storyteller: '#9C27B0',
    merchant: '#FFD700', explorer: '#00BCD4', teacher: '#2196F3',
    musician: '#FF4081', healer: '#FFFFFF', philosopher: '#3F51B5',
    artist: '#FF9800'
  };

  var ARCHETYPE_ICONS = {
    gardener: '&#127793;', builder: '&#128296;', storyteller: '&#128214;',
    merchant: '&#128176;', explorer: '&#129517;', teacher: '&#127891;',
    musician: '&#127925;', healer: '&#10084;', philosopher: '&#128161;',
    artist: '&#127912;'
  };

  /**
   * Show NPC interaction dialog â€” a proper panel with portrait, mood, activity, dialogue
   * @param {object} npcData - {name, message, archetype, mood, activity, familiarity, id}
   */
  function showNPCDialog(npcData) {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    // Remove existing dialog
    hideNPCDialog();

    var color = ARCHETYPE_COLORS_HUD[npcData.archetype] || '#888';
    var icon = ARCHETYPE_ICONS[npcData.archetype] || '';
    var mood = npcData.mood || 'neutral';
    var activity = npcData.activity || '';
    var familiarity = npcData.familiarity || 0;

    // Familiarity label
    var famLabel = 'Stranger';
    if (familiarity > 70) famLabel = 'Good Friend';
    else if (familiarity > 40) famLabel = 'Acquaintance';
    else if (familiarity > 10) famLabel = 'Familiar';

    // Mood emoji
    var moodEmoji = { content: '&#128522;', excited: '&#128516;', contemplative: '&#129300;',
      social: '&#128075;', tired: '&#128564;', happy: '&#128515;', curious: '&#129488;',
      neutral: '&#128528;', focused: '&#128373;', relaxed: '&#128524;' };
    var moodIcon = moodEmoji[mood] || moodEmoji.neutral;

    npcDialogEl = document.createElement('div');
    npcDialogEl.id = 'npc-dialog';
    npcDialogEl.style.cssText = 'position:absolute;bottom:60px;left:50%;transform:translateX(-50%);' +
      'background:rgba(10,14,26,0.92);border:2px solid ' + color + ';border-radius:12px;' +
      'padding:16px 20px;min-width:380px;max-width:480px;pointer-events:auto;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.6);animation:slideIn 0.3s ease-out;';

    // Header row: portrait + name + archetype
    var header = '<div style="display:flex;align-items:center;margin-bottom:10px;">' +
      '<div style="width:48px;height:48px;border-radius:50%;background:' + color + ';' +
      'display:flex;align-items:center;justify-content:center;font-size:24px;flex-shrink:0;">' + icon + '</div>' +
      '<div style="margin-left:12px;flex:1;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;">' + (npcData.name || 'NPC') + '</div>' +
      '<div style="font-size:11px;color:' + color + ';text-transform:capitalize;">' + (npcData.archetype || '') + '</div>' +
      '</div>' +
      '<div style="text-align:right;font-size:11px;color:#888;">' +
      '<div>' + moodIcon + ' ' + mood + '</div>' +
      '<div style="margin-top:2px;">' + famLabel + '</div>' +
      '</div></div>';

    // Activity bar
    var activityBar = '';
    if (activity) {
      activityBar = '<div style="font-size:11px;color:#aaa;margin-bottom:8px;padding:4px 8px;' +
        'background:rgba(255,255,255,0.05);border-radius:4px;font-style:italic;">' +
        '&#128269; ' + activity + '</div>';
    }

    // Dialogue text
    var dialogue = '<div style="font-size:14px;color:#e0e0e0;line-height:1.5;padding:8px 0;' +
      'border-top:1px solid rgba(255,255,255,0.1);">"' + (npcData.message || '...') + '"</div>';

    // Familiarity bar
    var famBar = '<div style="margin-top:8px;display:flex;align-items:center;gap:8px;">' +
      '<span style="font-size:10px;color:#666;">Familiarity</span>' +
      '<div style="flex:1;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden;">' +
      '<div style="width:' + Math.min(familiarity, 100) + '%;height:100%;background:' + color + ';border-radius:2px;"></div>' +
      '</div>' +
      '<span style="font-size:10px;color:#666;">' + familiarity + '%</span></div>';

    // Action buttons row
    var actionBtns = '<div style="display:flex;gap:6px;margin-top:10px;flex-wrap:wrap;">';
    // Trade button (merchants/traders show prominently)
    var isMerchant = npcData.archetype === 'merchant' || npcData.archetype === 'trader' ||
                     npcData.archetype === 'artisan' || npcData.archetype === 'farmer';
    actionBtns += '<button class="npc-action-btn" data-action="trade" style="flex:1;padding:6px 10px;' +
      'background:rgba(218,165,32,0.15);border:1px solid rgba(218,165,32,0.4);border-radius:6px;' +
      'color:#daa520;font-size:11px;cursor:pointer;transition:background 0.2s;"' +
      (isMerchant ? ' data-primary="true"' : '') + '>&#128176; Trade</button>';
    // Learn button (scholars/sages)
    actionBtns += '<button class="npc-action-btn" data-action="learn" style="flex:1;padding:6px 10px;' +
      'background:rgba(100,149,237,0.15);border:1px solid rgba(100,149,237,0.4);border-radius:6px;' +
      'color:#6495ed;font-size:11px;cursor:pointer;transition:background 0.2s;">&#128218; Learn</button>';
    // Lore button
    actionBtns += '<button class="npc-action-btn" data-action="lore" style="flex:1;padding:6px 10px;' +
      'background:rgba(147,112,219,0.15);border:1px solid rgba(147,112,219,0.4);border-radius:6px;' +
      'color:#9370db;font-size:11px;cursor:pointer;transition:background 0.2s;">&#128220; Lore</button>';
    actionBtns += '</div>';

    // Close hint
    var closeHint = '<div style="text-align:center;font-size:10px;color:#555;margin-top:8px;">Click an action or ESC to close</div>';

    npcDialogEl.innerHTML = header + activityBar + dialogue + famBar + actionBtns + closeHint;

    // Wire up action button clicks
    var buttons = npcDialogEl.querySelectorAll('.npc-action-btn');
    buttons.forEach(function(btn) {
      btn.addEventListener('mouseover', function() { btn.style.background = 'rgba(255,255,255,0.15)'; });
      btn.addEventListener('mouseout', function() { btn.style.background = ''; });
      btn.addEventListener('click', function() {
        var action = btn.getAttribute('data-action');
        if (npcActionCallback) {
          npcActionCallback(action, npcData);
        }
      });
    });

    hud.appendChild(npcDialogEl);

    // Auto-hide after 15 seconds (longer since there are actions now)
    npcDialogTimer = setTimeout(function() { hideNPCDialog(); }, 15000);
  }

  /**
   * Hide NPC interaction dialog
   */
  function hideNPCDialog() {
    if (npcDialogTimer) {
      clearTimeout(npcDialogTimer);
      npcDialogTimer = null;
    }
    if (npcDialogEl && npcDialogEl.parentNode) {
      npcDialogEl.parentNode.removeChild(npcDialogEl);
      npcDialogEl = null;
    }
  }

  /**
   * Set callback for NPC dialog action buttons
   * @param {function} callback - function(action, npcData)
   */
  function setNPCActionCallback(callback) {
    npcActionCallback = callback;
  }

  /**
   * Show NPC shop panel
   * @param {object} npcData - NPC info
   * @param {Array} items - [{id, name, price, description, icon}]
   * @param {number} playerSpark - Player's current Spark balance
   * @param {function} onBuy - callback(itemId)
   */
  function showNPCShop(npcData, items, playerSpark, onBuy) {
    if (typeof document === 'undefined') return;
    hideNPCShop();
    hideNPCDialog();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var color = ARCHETYPE_COLORS_HUD[npcData.archetype] || '#888';

    npcShopPanel = document.createElement('div');
    npcShopPanel.id = 'npc-shop-panel';
    npcShopPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid ' + color + ';border-radius:12px;' +
      'padding:20px;min-width:400px;max-width:500px;max-height:70vh;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.7);animation:slideIn 0.3s ease-out;overflow-y:auto;';

    var header = '<div style="display:flex;align-items:center;margin-bottom:14px;padding-bottom:10px;' +
      'border-bottom:1px solid rgba(255,255,255,0.1);">' +
      '<div style="font-size:18px;font-weight:bold;color:#fff;flex:1;">&#128176; ' +
      (npcData.name || 'Shop') + '\'s Wares</div>' +
      '<div style="font-size:13px;color:#daa520;">Your Spark: ' + (playerSpark || 0) + '</div></div>';

    var itemList = '';
    if (!items || items.length === 0) {
      itemList = '<div style="text-align:center;color:#888;padding:20px;">No items for sale right now.</div>';
    } else {
      items.forEach(function(item) {
        var canAfford = playerSpark >= item.price;
        itemList += '<div style="display:flex;align-items:center;padding:10px;margin-bottom:6px;' +
          'background:rgba(255,255,255,0.04);border-radius:8px;border:1px solid rgba(255,255,255,0.08);">' +
          '<div style="font-size:24px;margin-right:12px;">' + (item.icon || '&#128230;') + '</div>' +
          '<div style="flex:1;">' +
          '<div style="font-size:13px;color:#fff;">' + item.name + '</div>' +
          '<div style="font-size:11px;color:#888;">' + (item.description || '') + '</div>' +
          '</div>' +
          '<div style="text-align:right;margin-left:12px;">' +
          '<div style="font-size:12px;color:#daa520;margin-bottom:4px;">' + item.price + ' Spark</div>' +
          '<button class="npc-shop-buy-btn" data-item-id="' + item.id + '" style="padding:4px 12px;' +
          'background:' + (canAfford ? 'rgba(218,165,32,0.2)' : 'rgba(100,100,100,0.2)') + ';' +
          'border:1px solid ' + (canAfford ? 'rgba(218,165,32,0.5)' : 'rgba(100,100,100,0.3)') + ';' +
          'border-radius:4px;color:' + (canAfford ? '#daa520' : '#666') + ';font-size:11px;cursor:' +
          (canAfford ? 'pointer' : 'not-allowed') + ';"' +
          (canAfford ? '' : ' disabled') + '>Buy</button>' +
          '</div></div>';
      });
    }

    var closeBtn = '<div style="text-align:center;margin-top:12px;">' +
      '<button id="npc-shop-close" style="padding:6px 24px;background:rgba(255,255,255,0.08);' +
      'border:1px solid rgba(255,255,255,0.2);border-radius:6px;color:#aaa;font-size:12px;cursor:pointer;">Close Shop</button></div>';

    npcShopPanel.innerHTML = header + itemList + closeBtn;
    npcShopPanel.className = 'npc-shop-panel';
    hud.appendChild(npcShopPanel);
    requestAnimationFrame(function() {
      npcShopPanel.classList.add('visible');
    });

    // Wire buy buttons
    npcShopPanel.querySelectorAll('.npc-shop-buy-btn').forEach(function(btn) {
      if (!btn.disabled) {
        btn.addEventListener('click', function() {
          var itemId = btn.getAttribute('data-item-id');
          if (onBuy) onBuy(itemId);
        });
      }
    });

    // Wire close button
    var closeEl = npcShopPanel.querySelector('#npc-shop-close');
    if (closeEl) {
      closeEl.addEventListener('click', function() { hideNPCShop(); });
    }
  }

  function hideNPCShop() {
    if (npcShopPanel && npcShopPanel.parentNode) {
      npcShopPanel.classList.remove('visible');
      setTimeout(function() {
        if (npcShopPanel && npcShopPanel.parentNode) {
          npcShopPanel.parentNode.removeChild(npcShopPanel);
          npcShopPanel = null;
        }
      }, 250);
    }
  }

  // ========================================================================
  // NPC DOTS ON MINIMAP
  // ========================================================================

  /**
   * Update minimap with NPC positions
   * @param {Array} npcPositions - [{x, z, archetype}]
   * @param {object} playerPos - {x, z} player position for range check
   */
  function updateMinimapNPCs(npcPositions, playerPos) {
    if (!minimapCtx || !npcPositions) return;

    var w = minimapCanvas.width;
    var h = minimapCanvas.height;
    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var margin = 8;

    function worldToMap(wx, wz) {
      return {
        x: margin + ((wx - worldMin) / worldRange) * (w - margin * 2),
        y: margin + ((wz - worldMin) / worldRange) * (h - margin * 2)
      };
    }

    // Draw NPC dots (small, colored by archetype)
    npcPositions.forEach(function(npc) {
      // Only show NPCs within 250 units of player
      if (playerPos) {
        var dx = npc.x - playerPos.x;
        var dz = npc.z - playerPos.z;
        if (Math.sqrt(dx * dx + dz * dz) > 250) return;
      }
      var pos = worldToMap(npc.x, npc.z);
      var color = ARCHETYPE_COLORS_HUD[npc.archetype] || '#888';
      minimapCtx.fillStyle = color;
      minimapCtx.globalAlpha = 0.7;
      minimapCtx.beginPath();
      minimapCtx.arc(pos.x, pos.y, 1.5, 0, Math.PI * 2);
      minimapCtx.fill();
    });
    minimapCtx.globalAlpha = 1.0;
  }

  // ========================================================================
  // QUEST SYSTEM UI
  // ========================================================================

  var questTrackerEl = null;
  var questLogEl = null;
  var questOfferEl = null;

  /**
   * Initialize quest tracker (top-right, below minimap)
   */
  function initQuestTracker() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questTrackerEl = document.createElement('div');
    questTrackerEl.id = 'quest-tracker';
    questTrackerEl.style.cssText = 'position:absolute;top:470px;right:20px;background:rgba(10,14,26,0.85);' +
      'border-left:3px solid #d4af37;border-radius:8px;padding:12px;min-width:220px;max-width:300px;' +
      'font-size:12px;pointer-events:auto;max-height:250px;overflow-y:auto;';
    questTrackerEl.innerHTML = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>';
    hud.appendChild(questTrackerEl);
  }

  /**
   * Update quest tracker with active quests
   * @param {Array} activeQuests - Array of active quest objects
   */
  function updateQuestTracker(activeQuests) {
    if (!questTrackerEl) return;

    if (activeQuests.length === 0) {
      questTrackerEl.innerHTML = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>' +
        '<div style="color:#888;font-style:italic;font-size:11px;">No active quests</div>';
      return;
    }

    var html = '<div style="font-weight:bold;color:#d4af37;margin-bottom:6px;font-size:13px;">Active Quests</div>';

    activeQuests.forEach(function(quest) {
      var obj = quest.objectives[0]; // Show first objective
      var required = obj.required || obj.count || 1;
      var progress = obj.current + '/' + required;
      var progressPercent = Math.round((obj.current / required) * 100);
      var statusColor = quest.status === 'complete' ? '#4f4' : '#fff';

      html += '<div style="margin-bottom:10px;padding:6px;background:rgba(0,0,0,0.3);border-radius:4px;">' +
        '<div style="font-weight:bold;color:' + statusColor + ';font-size:11px;margin-bottom:3px;">' + quest.title + '</div>' +
        '<div style="color:#aaa;font-size:10px;margin-bottom:4px;">' + progress + '</div>' +
        '<div style="width:100%;height:4px;background:rgba(255,255,255,0.2);border-radius:2px;overflow:hidden;">' +
        '<div style="width:' + progressPercent + '%;height:100%;background:#d4af37;"></div></div>' +
        '</div>';
    });

    questTrackerEl.innerHTML = html;
  }

  /**
   * Show quest log panel (press J to toggle)
   */
  function showQuestLog(questLog, playerId) {
    if (typeof document === 'undefined') return;
    hideQuestLog(); // Remove existing if any

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questLogEl = document.createElement('div');
    questLogEl.id = 'quest-log-panel';
    questLogEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #d4af37;border-radius:12px;' +
      'padding:20px;width:600px;max-height:70vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:200;';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<div style="font-size:24px;font-weight:bold;color:#d4af37;">Quest Log</div>' +
      '<div style="cursor:pointer;font-size:20px;color:#888;padding:4px 8px;" onclick="window.HUD.hideQuestLog()">âœ•</div></div>';

    // Active quests section
    html += '<div style="margin-bottom:20px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Active Quests (' + questLog.active.length + '/5)</div>';

    if (questLog.active.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No active quests. Speak to NPCs to find new quests!</div>';
    } else {
      questLog.active.forEach(function(quest) {
        var obj = quest.objectives[0];
        var required = obj.required || obj.count || 1;
        var progress = obj.current + '/' + required;
        var statusText = quest.status === 'complete' ? '<span style="color:#4f4;">âœ“ Ready to turn in</span>' : '<span style="color:#fa4;">In Progress</span>';

        html += '<div style="margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:6px;border-left:3px solid #d4af37;">' +
          '<div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;">' +
          '<div style="font-weight:bold;color:#fff;font-size:14px;">' + quest.title + '</div>' +
          '<div style="font-size:11px;">' + statusText + '</div></div>' +
          '<div style="color:#aaa;font-size:12px;margin-bottom:6px;">' + quest.description + '</div>' +
          '<div style="color:#888;font-size:11px;">Progress: ' + progress + '</div>' +
          '<div style="margin-top:6px;font-size:11px;color:#d4af37;">Reward: ' + quest.rewards.spark + ' Spark' +
          (quest.rewards.items.length > 0 ? ' + items' : '') + '</div>' +
          '<div style="margin-top:8px;text-align:right;">' +
          '<span style="cursor:pointer;font-size:11px;color:#f44;text-decoration:underline;" onclick="window.HUD.abandonQuestFromLog(\'' + playerId + '\',\'' + quest.id + '\')">Abandon</span>' +
          '</div></div>';
      });
    }
    html += '</div>';

    // Available quests section
    html += '<div style="margin-bottom:20px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Available Quests (' + questLog.available.length + ')</div>';

    if (questLog.available.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No new quests available. Complete prerequisites or explore more zones!</div>';
    } else {
      questLog.available.slice(0, 10).forEach(function(quest) {
        html += '<div style="margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.2);border-radius:6px;border-left:3px solid #888;">' +
          '<div style="font-weight:bold;color:#fff;font-size:14px;margin-bottom:6px;">' + quest.title + '</div>' +
          '<div style="color:#aaa;font-size:12px;margin-bottom:6px;">' + quest.description + '</div>' +
          '<div style="font-size:11px;color:#d4af37;">Reward: ' + quest.rewards.spark + ' Spark' +
          (quest.rewards.items.length > 0 ? ' + items' : '') + '</div>' +
          '<div style="margin-top:8px;color:#888;font-size:10px;">Find quest giver to accept</div></div>';
      });
    }
    html += '</div>';

    // Completed quests section
    html += '<div>' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:10px;border-bottom:1px solid #d4af37;padding-bottom:4px;">Completed (' + questLog.completed.length + ')</div>';

    if (questLog.completed.length === 0) {
      html += '<div style="color:#888;font-style:italic;font-size:13px;padding:10px;">No completed quests yet.</div>';
    } else {
      html += '<div style="color:#4f4;font-size:12px;padding:10px;">You have completed ' + questLog.completed.length + ' quests!</div>';
    }
    html += '</div>';

    html += '<div style="text-align:center;margin-top:16px;font-size:11px;color:#666;">Press J to close</div>';

    questLogEl.innerHTML = html;
    hud.appendChild(questLogEl);
    requestAnimationFrame(function() {
      questLogEl.classList.add('visible');
    });
  }

  /**
   * Hide quest log panel
   */
  function hideQuestLog() {
    if (questLogEl && questLogEl.parentNode) {
      questLogEl.classList.remove('visible');
      setTimeout(function() {
        if (questLogEl && questLogEl.parentNode) {
          questLogEl.parentNode.removeChild(questLogEl);
          questLogEl = null;
        }
      }, 250);
    }
  }

  /**
   * Show quest offer dialog from NPC
   * @param {object} quest - Quest object
   * @param {object} npc - NPC data {name, archetype}
   */
  function showQuestOffer(quest, npc, playerId) {
    if (typeof document === 'undefined') return;
    hideQuestOffer(); // Remove existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    questOfferEl = document.createElement('div');
    questOfferEl.id = 'quest-offer-dialog';
    questOfferEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #d4af37;border-radius:12px;' +
      'padding:20px;width:500px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var questDialogue = quest.dialogue && quest.dialogue.offer ? quest.dialogue.offer : quest.description;

    var html = '<div style="font-size:20px;font-weight:bold;color:#d4af37;margin-bottom:12px;">New Quest</div>' +
      '<div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:8px;">' + quest.title + '</div>' +
      '<div style="color:#aaa;font-size:13px;margin-bottom:12px;font-style:italic;">"' + questDialogue + '"</div>' +
      '<div style="color:#ccc;font-size:12px;margin-bottom:8px;">' + quest.description + '</div>' +
      '<div style="padding:10px;background:rgba(0,0,0,0.3);border-radius:6px;margin-bottom:16px;">' +
      '<div style="font-size:12px;color:#d4af37;margin-bottom:4px;">Rewards:</div>' +
      '<div style="font-size:13px;color:#fff;">â€¢ ' + quest.rewards.spark + ' Spark</div>';

    if (quest.rewards.items.length > 0) {
      quest.rewards.items.forEach(function(item) {
        html += '<div style="font-size:13px;color:#fff;">â€¢ ' + item.count + 'x ' + item.id + '</div>';
      });
    }

    html += '</div>' +
      '<div style="display:flex;gap:12px;justify-content:center;">' +
      '<button onclick="window.HUD.acceptQuestFromOffer(\'' + playerId + '\',\'' + quest.id + '\')" style="' +
      'padding:10px 24px;background:#d4af37;color:#000;border:none;border-radius:6px;' +
      'font-weight:bold;font-size:14px;cursor:pointer;">Accept Quest</button>' +
      '<button onclick="window.HUD.hideQuestOffer()" style="' +
      'padding:10px 24px;background:rgba(255,255,255,0.1);color:#fff;border:1px solid #666;border-radius:6px;' +
      'font-size:14px;cursor:pointer;">Decline</button></div>';

    questOfferEl.innerHTML = html;
    hud.appendChild(questOfferEl);
  }

  /**
   * Hide quest offer dialog
   */
  function hideQuestOffer() {
    if (questOfferEl && questOfferEl.parentNode) {
      questOfferEl.parentNode.removeChild(questOfferEl);
      questOfferEl = null;
    }
  }

  /**
   * Show quest complete notification
   * @param {object} quest - Completed quest
   * @param {object} rewards - Rewards {spark, items}
   */
  function showQuestComplete(quest, rewards) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.style.cssText = 'background:linear-gradient(135deg,rgba(212,175,55,0.9),rgba(255,215,0,0.9));' +
      'border-left:4px solid #d4af37;border-radius:8px;padding:16px 20px;margin-bottom:10px;' +
      'animation:slideIn 0.3s ease-out;pointer-events:auto;box-shadow:0 4px 12px rgba(212,175,55,0.4);';

    var html = '<div style="font-size:18px;font-weight:bold;color:#000;margin-bottom:6px;">Quest Complete!</div>' +
      '<div style="font-size:14px;color:#111;margin-bottom:8px;">' + quest.title + '</div>' +
      '<div style="font-size:12px;color:#222;">+ ' + rewards.spark + ' Spark';

    if (rewards.items && rewards.items.length > 0) {
      html += ' + ' + rewards.items.length + ' item(s)';
    }

    html += '</div>';
    notification.innerHTML = html;

    notificationContainer.appendChild(notification);

    // Auto-remove after 6 seconds
    setTimeout(function() {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 6000);
  }

  /**
   * Show quest objective progress update
   * @param {string} text - Progress text (e.g., "+1/3 Sunflowers")
   */
  function showQuestProgress(text) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.style.cssText = 'background:rgba(212,175,55,0.3);border-left:3px solid #d4af37;' +
      'border-radius:6px;padding:8px 12px;margin-bottom:8px;animation:slideIn 0.3s ease-out;' +
      'pointer-events:auto;font-size:13px;color:#d4af37;font-weight:bold;';
    notification.textContent = text;

    notificationContainer.appendChild(notification);

    // Auto-remove after 3 seconds
    setTimeout(function() {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        notification.remove();
      }, 300);
    }, 3000);
  }

  /**
   * Accept quest from offer dialog (called by inline onclick)
   */
  function acceptQuestFromOffer(playerId, questId) {
    if (window.Quests) {
      var result = window.Quests.acceptQuest(playerId, questId);
      if (result.success) {
        showNotification('Quest accepted: ' + result.quest.title, 'success');
        hideQuestOffer();
      } else {
        showNotification('Cannot accept quest: ' + result.message, 'error');
      }
    }
  }

  /**
   * Abandon quest from log (called by inline onclick)
   */
  function abandonQuestFromLog(playerId, questId) {
    if (window.Quests) {
      var result = window.Quests.abandonQuest(playerId, questId);
      if (result.success) {
        showNotification('Quest abandoned', 'info');
        hideQuestLog();
      }
    }
  }

  // ========================================================================
  // INVENTORY PANEL
  // ========================================================================

  var inventoryPanel = null;
  var inventoryVisible = false;

  function initInventoryPanel() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    inventoryPanel = document.createElement('div');
    inventoryPanel.id = 'inventory-panel';
    inventoryPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #4af;border-radius:12px;' +
      'padding:20px;min-width:500px;pointer-events:auto;display:none;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.8);z-index:200;';

    var header = '<div style="font-size:20px;font-weight:bold;margin-bottom:15px;text-align:center;color:#4af;">Inventory</div>';
    var slotsGrid = '<div id="inventory-slots" style="display:grid;grid-template-columns:repeat(5,90px);gap:8px;margin-bottom:15px;"></div>';
    var closeBtn = '<div style="text-align:center;"><button id="close-inventory" style="padding:8px 20px;background:#4af;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Close (I)</button></div>';

    inventoryPanel.innerHTML = header + slotsGrid + closeBtn;
    hud.appendChild(inventoryPanel);

    var closeInvBtn = document.getElementById('close-inventory');
    if (closeInvBtn) closeInvBtn.addEventListener('click', function() {
      hideInventoryPanel();
    });
  }

  function toggleInventoryPanel() {
    if (inventoryVisible) {
      hideInventoryPanel();
    } else {
      showInventoryPanel();
    }
  }

  function showInventoryPanel() {
    if (!inventoryPanel) initInventoryPanel();
    inventoryPanel.style.display = 'block';
    requestAnimationFrame(function() {
      inventoryPanel.classList.add('visible');
    });
    inventoryVisible = true;
  }

  function hideInventoryPanel() {
    if (inventoryPanel) {
      inventoryPanel.classList.remove('visible');
      setTimeout(function() {
        inventoryPanel.style.display = 'none';
      }, 250);
    }
    inventoryVisible = false;
  }

  function updateInventoryDisplay(inventory) {
    if (!inventoryPanel || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var slotsDiv = document.getElementById('inventory-slots');
    if (!slotsDiv) return;

    var items = Inventory.getInventory(inventory);
    slotsDiv.innerHTML = '';

    items.forEach(function(item, idx) {
      var slot = document.createElement('div');
      slot.style.cssText = 'background:rgba(255,255,255,0.1);border:2px solid #555;border-radius:6px;' +
        'padding:10px;text-align:center;min-height:70px;position:relative;cursor:pointer;';

      if (item) {
        var rarityColors = { common: '#aaa', uncommon: '#4af', rare: '#f4a', legendary: '#fa4' };
        var borderColor = rarityColors[item.rarity] || '#555';
        slot.style.borderColor = borderColor;

        slot.innerHTML = '<div style="font-size:32px;margin-bottom:4px;">' + item.icon + '</div>' +
          '<div style="font-size:11px;color:#ccc;">' + item.name + '</div>' +
          '<div style="position:absolute;top:4px;right:6px;background:#000;padding:2px 6px;border-radius:3px;font-size:11px;font-weight:bold;">' + item.count + '</div>';

        slot.title = item.description + '\\n' + item.rarity.toUpperCase();
      } else {
        slot.innerHTML = '<div style="color:#444;padding-top:20px;">Empty</div>';
      }

      slotsDiv.appendChild(slot);
    });
  }

  // ========================================================================
  // CRAFTING PANEL
  // ========================================================================

  var craftingPanel = null;
  var craftingVisible = false;
  var onCraftCallback = null;

  function initCraftingPanel(onCraft) {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    onCraftCallback = onCraft;

    craftingPanel = document.createElement('div');
    craftingPanel.id = 'crafting-panel';
    craftingPanel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #fa4;border-radius:12px;' +
      'padding:20px;min-width:600px;max-height:70vh;overflow-y:auto;pointer-events:auto;display:none;' +
      'box-shadow:0 4px 20px rgba(0,0,0,0.8);z-index:200;';

    var header = '<div style="font-size:20px;font-weight:bold;margin-bottom:15px;text-align:center;color:#fa4;">Crafting</div>';
    var recipeList = '<div id="recipe-list"></div>';
    var closeBtn = '<div style="text-align:center;margin-top:15px;"><button id="close-crafting" style="padding:8px 20px;background:#fa4;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Close (C)</button></div>';

    craftingPanel.innerHTML = header + recipeList + closeBtn;
    hud.appendChild(craftingPanel);

    var closeCraftBtn = document.getElementById('close-crafting');
    if (closeCraftBtn) closeCraftBtn.addEventListener('click', function() {
      hideCraftingPanel();
    });
  }

  function toggleCraftingPanel() {
    if (craftingVisible) {
      hideCraftingPanel();
    } else {
      showCraftingPanel();
    }
  }

  function showCraftingPanel() {
    if (!craftingPanel) initCraftingPanel();
    craftingPanel.style.display = 'block';
    requestAnimationFrame(function() {
      craftingPanel.classList.add('visible');
    });
    craftingVisible = true;
  }

  function hideCraftingPanel() {
    if (craftingPanel) {
      craftingPanel.classList.remove('visible');
      setTimeout(function() {
        craftingPanel.style.display = 'none';
      }, 250);
    }
    craftingVisible = false;
  }

  function updateCraftingDisplay(inventory) {
    if (!craftingPanel || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var listDiv = document.getElementById('recipe-list');
    if (!listDiv) return;

    var allRecipes = Inventory.getAllRecipes();
    listDiv.innerHTML = '';

    allRecipes.forEach(function(recipe) {
      var canCraft = Inventory.canCraft(inventory, recipe);
      var outputItem = Inventory.getItemData(recipe.output.itemId);

      var recipeDiv = document.createElement('div');
      recipeDiv.style.cssText = 'background:rgba(255,255,255,0.05);border:1px solid ' + (canCraft ? '#4f4' : '#555') + ';' +
        'border-radius:6px;padding:12px;margin-bottom:10px;';

      var title = '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:' + (canCraft ? '#4f4' : '#888') + ';">' +
        (outputItem ? outputItem.icon + ' ' : '') + recipe.name + '</div>';

      var reqs = '<div style="font-size:12px;color:#aaa;margin-bottom:8px;">Requires: ';
      recipe.requirements.forEach(function(req, i) {
        var reqItem = Inventory.getItemData(req.itemId);
        var hasCount = Inventory.getItemCount(inventory, req.itemId);
        var hasEnough = hasCount >= req.count;
        reqs += (i > 0 ? ', ' : '') + '<span style="color:' + (hasEnough ? '#4f4' : '#f44') + ';">' +
          (reqItem ? reqItem.icon + ' ' : '') + req.count + ' ' + (reqItem ? reqItem.name : req.itemId) + '</span>';
      });
      reqs += '</div>';

      var reward = '<div style="font-size:11px;color:#ffa500;margin-bottom:8px;">Spark Reward: ' + recipe.sparkReward + '</div>';

      var craftBtn = '';
      if (canCraft) {
        craftBtn = '<button class="craft-btn" data-recipe="' + recipe.id + '" style="padding:6px 15px;background:#4f4;border:none;border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Craft</button>';
      } else {
        craftBtn = '<button disabled style="padding:6px 15px;background:#333;border:none;border-radius:4px;color:#666;cursor:not-allowed;">Cannot Craft</button>';
      }

      recipeDiv.innerHTML = title + reqs + reward + craftBtn;
      listDiv.appendChild(recipeDiv);
    });

    var craftBtns = document.querySelectorAll('.craft-btn');
    craftBtns.forEach(function(btn) {
      btn.addEventListener('click', function() {
        var recipeId = this.getAttribute('data-recipe');
        if (onCraftCallback) {
          onCraftCallback(recipeId);
        }
      });
    });
  }

  // ========================================================================
  // QUICK BAR
  // ========================================================================

  var quickBarEl = null;

  function initQuickBar() {
    if (typeof document === 'undefined') return;
    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    quickBarEl = document.createElement('div');
    quickBarEl.id = 'quick-bar';
    quickBarEl.style.cssText = 'position:absolute;bottom:70px;left:50%;transform:translateX(-50%);' +
      'display:flex;gap:8px;pointer-events:none;';

    for (var i = 0; i < 5; i++) {
      var slot = document.createElement('div');
      slot.className = 'quick-slot';
      slot.style.cssText = 'background:rgba(0,0,0,0.7);border:2px solid #555;border-radius:6px;' +
        'padding:8px;width:60px;height:60px;text-align:center;position:relative;';

      var keyLabel = '<div style="position:absolute;top:2px;left:4px;font-size:10px;color:#888;">' + (i + 1) + '</div>';
      slot.innerHTML = keyLabel + '<div class="quick-content" style="font-size:28px;margin-top:8px;">-</div>';

      quickBarEl.appendChild(slot);
    }

    hud.appendChild(quickBarEl);
  }

  function updateQuickBar(inventory) {
    if (!quickBarEl || !inventory) return;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    var items = Inventory.getInventory(inventory);
    var quickSlots = quickBarEl.querySelectorAll('.quick-slot');

    inventory.quickBar.forEach(function(slotIdx, qbIdx) {
      if (qbIdx >= quickSlots.length) return;

      var item = items[slotIdx];
      var contentDiv = quickSlots[qbIdx].querySelector('.quick-content');

      if (item) {
        contentDiv.innerHTML = item.icon;
        quickSlots[qbIdx].title = item.name + ' (' + item.count + ')';
      } else {
        contentDiv.innerHTML = '-';
        quickSlots[qbIdx].title = 'Empty';
      }
    });
  }

  // ========================================================================
  // ITEM PICKUP NOTIFICATION
  // ========================================================================

  function showItemPickup(itemName, count, icon) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    var pickup = document.createElement('div');
    pickup.style.cssText = 'background:rgba(0,200,0,0.8);border-left:4px solid #0f0;border-radius:4px;' +
      'padding:10px 15px;margin-bottom:10px;animation:slideIn 0.3s ease-out;' +
      'pointer-events:auto;box-shadow:0 2px 8px rgba(0,0,0,0.3);font-size:14px;';

    pickup.innerHTML = '<span style="font-size:20px;margin-right:8px;">' + (icon || '+') + '</span>' +
      '<span style="font-weight:bold;">+' + count + ' ' + itemName + '</span>';

    notificationContainer.appendChild(pickup);

    setTimeout(function() {
      pickup.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(function() {
        pickup.remove();
      }, 300);
    }, 2000);
  }

  // ========================================================================
  // WORLD MAP OVERLAY
  // ========================================================================

  var worldMapOverlay = null;
  var worldMapCanvas = null;
  var worldMapCtx = null;
  var worldMapVisible = false;

  var WORLD_MAP_ZONES = {
    nexus:      { cx: 0,    cz: 0,    radius: 60, color: '#8888cc', name: 'Nexus', desc: 'The heart of Zion. A safe meeting place for all.' },
    gardens:    { cx: 200,  cz: 30,   radius: 80, color: '#4caf50', name: 'Gardens', desc: 'Fertile grounds for planting, growing, and harvesting.' },
    athenaeum:  { cx: 100,  cz: -220, radius: 60, color: '#795548', name: 'Athenaeum', desc: 'A library of knowledge and arcane study.' },
    studio:     { cx: -200, cz: -100, radius: 60, color: '#ff9800', name: 'Studio', desc: 'Creative workshops for art, music, and crafting.' },
    wilds:      { cx: -30,  cz: 260,  radius: 90, color: '#2e7d32', name: 'Wilds', desc: 'Untamed wilderness full of discoveries.' },
    agora:      { cx: -190, cz: 120,  radius: 55, color: '#ffd700', name: 'Agora', desc: 'The marketplace. Trade goods and Spark.' },
    commons:    { cx: 170,  cz: 190,  radius: 55, color: '#faf0e6', name: 'Commons', desc: 'Community space for building and gathering.' },
    arena:      { cx: 0,    cz: -240, radius: 55, color: '#d2691e', name: 'Arena', desc: 'Honorable competition between consenting players.' }
  };

  var ZONE_CONNECTIONS = [
    ['nexus', 'gardens'],
    ['nexus', 'athenaeum'],
    ['nexus', 'studio'],
    ['nexus', 'wilds'],
    ['nexus', 'agora'],
    ['nexus', 'commons'],
    ['nexus', 'arena'],
    ['gardens', 'commons'],
    ['wilds', 'agora'],
    ['athenaeum', 'arena']
  ];

  function showWorldMap(playerPos, npcs, landmarks, onFastTravel) {
    if (typeof document === 'undefined') return;
    if (worldMapVisible) return;

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    worldMapVisible = true;

    worldMapOverlay = document.createElement('div');
    worldMapOverlay.id = 'world-map-overlay';
    worldMapOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;' +
      'background:rgba(10,10,20,0.92);z-index:500;display:flex;flex-direction:column;' +
      'align-items:center;justify-content:center;pointer-events:auto;';

    var title = document.createElement('div');
    title.style.cssText = 'font-size:48px;font-weight:bold;letter-spacing:8px;' +
      'color:#d4af37;margin-bottom:20px;text-align:center;' +
      'text-shadow:0 0 10px rgba(212,175,55,0.5);';
    title.textContent = 'WORLD OF ZION';
    worldMapOverlay.appendChild(title);

    var mapContainer = document.createElement('div');
    mapContainer.style.cssText = 'position:relative;width:80vw;height:60vh;max-width:800px;max-height:600px;' +
      'background:rgba(0,0,0,0.3);border:2px solid #d4af37;border-radius:8px;overflow:hidden;';

    worldMapCanvas = document.createElement('canvas');
    worldMapCanvas.style.cssText = 'display:block;width:100%;height:100%;';
    mapContainer.appendChild(worldMapCanvas);

    worldMapCanvas.width = 800;
    worldMapCanvas.height = 600;
    worldMapCtx = worldMapCanvas.getContext('2d');

    worldMapOverlay.appendChild(mapContainer);

    var instructions = document.createElement('div');
    instructions.style.cssText = 'margin-top:20px;font-size:14px;color:#aaa;text-align:center;';
    instructions.textContent = onFastTravel ? 'Click a zone to fast travel Â· Press M or ESC to close' : 'Press M or ESC to close';
    worldMapOverlay.appendChild(instructions);

    hud.appendChild(worldMapOverlay);

    drawWorldMap(playerPos, npcs, landmarks);

    worldMapOverlay.addEventListener('click', function(e) {
      if (e.target === worldMapOverlay) {
        hideWorldMap();
      }
    });

    var keyHandler = function(e) {
      if (e.key === 'Escape' || e.key === 'm' || e.key === 'M') {
        hideWorldMap();
        document.removeEventListener('keydown', keyHandler);
        e.preventDefault();
      }
    };
    document.addEventListener('keydown', keyHandler);
    worldMapOverlay._keyHandler = keyHandler;

    worldMapCanvas.addEventListener('mousemove', function(e) {
      handleMapHover(e);
    });

    // Fast travel click handler
    if (onFastTravel) {
      worldMapCanvas.addEventListener('click', function(e) {
        var zone = getZoneAtMapClick(e);
        if (zone) {
          hideWorldMap();
          onFastTravel(zone);
        }
      });
    }
  }

  function hideWorldMap() {
    if (!worldMapOverlay) return;

    if (worldMapOverlay._keyHandler) {
      document.removeEventListener('keydown', worldMapOverlay._keyHandler);
    }

    if (worldMapOverlay.parentNode) {
      worldMapOverlay.parentNode.removeChild(worldMapOverlay);
    }

    worldMapOverlay = null;
    worldMapCanvas = null;
    worldMapCtx = null;
    worldMapVisible = false;
  }

  function updateWorldMap(playerPos) {
    if (!worldMapVisible || !worldMapCtx) return;
    drawWorldMap(playerPos, [], []);
  }

  function drawWorldMap(playerPos, npcs, landmarks) {
    if (!worldMapCtx) return;

    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    worldMapCtx.fillStyle = '#0a0e1a';
    worldMapCtx.fillRect(0, 0, w, h);

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;

    function worldToCanvas(wx, wz) {
      return {
        x: padding + ((wx - worldMin) / worldRange) * (w - padding * 2),
        y: padding + ((wz - worldMin) / worldRange) * (h - padding * 2)
      };
    }

    worldMapCtx.strokeStyle = 'rgba(255,255,255,0.05)';
    worldMapCtx.lineWidth = 1;
    for (var i = 0; i <= 8; i++) {
      var x = padding + (i / 8) * (w - padding * 2);
      var y = padding + (i / 8) * (h - padding * 2);
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(x, padding);
      worldMapCtx.lineTo(x, h - padding);
      worldMapCtx.stroke();
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(padding, y);
      worldMapCtx.lineTo(w - padding, y);
      worldMapCtx.stroke();
    }

    worldMapCtx.strokeStyle = 'rgba(212,175,55,0.2)';
    worldMapCtx.lineWidth = 2;
    ZONE_CONNECTIONS.forEach(function(conn) {
      var z1 = WORLD_MAP_ZONES[conn[0]];
      var z2 = WORLD_MAP_ZONES[conn[1]];
      if (!z1 || !z2) return;
      var pos1 = worldToCanvas(z1.cx, z1.cz);
      var pos2 = worldToCanvas(z2.cx, z2.cz);
      worldMapCtx.beginPath();
      worldMapCtx.moveTo(pos1.x, pos1.y);
      worldMapCtx.lineTo(pos2.x, pos2.y);
      worldMapCtx.stroke();
    });

    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var pos = worldToCanvas(zone.cx, zone.cz);
      var r = (zone.radius / worldRange) * (w - padding * 2);

      worldMapCtx.globalAlpha = 0.3;
      worldMapCtx.fillStyle = zone.color;
      worldMapCtx.beginPath();
      worldMapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      worldMapCtx.fill();

      worldMapCtx.globalAlpha = 0.7;
      worldMapCtx.strokeStyle = zone.color;
      worldMapCtx.lineWidth = 2;
      worldMapCtx.beginPath();
      worldMapCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      worldMapCtx.stroke();

      worldMapCtx.globalAlpha = 1.0;
      worldMapCtx.fillStyle = '#fff';
      worldMapCtx.font = 'bold 14px Arial';
      worldMapCtx.textAlign = 'center';
      worldMapCtx.textBaseline = 'middle';
      worldMapCtx.fillText(zone.name, pos.x, pos.y);
    }

    worldMapCtx.globalAlpha = 1.0;

    if (npcs && npcs.length > 0) {
      npcs.forEach(function(npc) {
        var pos = worldToCanvas(npc.x, npc.z);
        var color = ARCHETYPE_COLORS_HUD[npc.archetype] || '#888';
        worldMapCtx.fillStyle = color;
        worldMapCtx.beginPath();
        worldMapCtx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
        worldMapCtx.fill();
      });
    }

    if (landmarks && landmarks.length > 0) {
      landmarks.forEach(function(landmark) {
        var pos = worldToCanvas(landmark.x, landmark.z);
        drawStar(worldMapCtx, pos.x, pos.y, 5, 8, 4, '#ffd700');
      });
    }

    if (playerPos) {
      var pPos = worldToCanvas(playerPos.x, playerPos.z);
      drawDiamond(worldMapCtx, pPos.x, pPos.y, 12, '#FFD700');

      worldMapCtx.shadowBlur = 15;
      worldMapCtx.shadowColor = '#FFD700';
      drawDiamond(worldMapCtx, pPos.x, pPos.y, 12, '#FFD700');
      worldMapCtx.shadowBlur = 0;
    }

    drawCompassRose(worldMapCtx, w - 60, 60, 30);
  }

  function drawDiamond(ctx, x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size, y);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawStar(ctx, x, y, points, outer, inner, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    for (var i = 0; i < points * 2; i++) {
      var angle = (i * Math.PI) / points - Math.PI / 2;
      var radius = i % 2 === 0 ? outer : inner;
      var px = x + Math.cos(angle) * radius;
      var py = y + Math.sin(angle) * radius;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawCompassRose(ctx, x, y, size) {
    ctx.strokeStyle = 'rgba(212,175,55,0.5)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x, y + size);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x - size, y);
    ctx.lineTo(x + size, y);
    ctx.stroke();

    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('N', x, y - size - 10);
    ctx.fillText('S', x, y + size + 10);
    ctx.fillText('E', x + size + 12, y);
    ctx.fillText('W', x - size - 12, y);
  }

  function handleMapHover(e) {
    if (!worldMapCanvas || !worldMapCtx) return;

    var rect = worldMapCanvas.getBoundingClientRect();
    var mx = ((e.clientX - rect.left) / rect.width) * worldMapCanvas.width;
    var my = ((e.clientY - rect.top) / rect.height) * worldMapCanvas.height;

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;
    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    var hoveredZone = null;
    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var zx = padding + ((zone.cx - worldMin) / worldRange) * (w - padding * 2);
      var zy = padding + ((zone.cz - worldMin) / worldRange) * (h - padding * 2);
      var zr = (zone.radius / worldRange) * (w - padding * 2);

      var dx = mx - zx;
      var dy = my - zy;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist <= zr) {
        hoveredZone = zone;
        break;
      }
    }

    if (hoveredZone) {
      worldMapCanvas.style.cursor = 'pointer';
      worldMapCanvas.title = hoveredZone.name + ' â€” Click to fast travel';
    } else {
      worldMapCanvas.style.cursor = 'default';
      worldMapCanvas.title = '';
    }
  }

  function getZoneAtMapClick(e) {
    if (!worldMapCanvas) return null;

    var rect = worldMapCanvas.getBoundingClientRect();
    var mx = ((e.clientX - rect.left) / rect.width) * worldMapCanvas.width;
    var my = ((e.clientY - rect.top) / rect.height) * worldMapCanvas.height;

    var worldMin = -320, worldMax = 320;
    var worldRange = worldMax - worldMin;
    var padding = 40;
    var w = worldMapCanvas.width;
    var h = worldMapCanvas.height;

    for (var zoneId in WORLD_MAP_ZONES) {
      var zone = WORLD_MAP_ZONES[zoneId];
      var zx = padding + ((zone.cx - worldMin) / worldRange) * (w - padding * 2);
      var zy = padding + ((zone.cz - worldMin) / worldRange) * (h - padding * 2);
      var zr = (zone.radius / worldRange) * (w - padding * 2);

      var dx = mx - zx;
      var dy = my - zy;
      if (Math.sqrt(dx * dx + dy * dy) <= zr) {
        return zoneId;
      }
    }
    return null;
  }

  // ========================================================================
  // EMOTE SYSTEM UI
  // ========================================================================

  var emoteMenuEl = null;
  var emoteMenuVisible = false;
  var emoteBubbles = new Map(); // playerId -> {element, timer}

  var EMOTE_SYMBOLS = {
    wave: '&#128075;',
    dance: '&#128131;',
    bow: '&#129485;',
    cheer: '&#127881;',
    meditate: '&#129496;',
    point: '&#128073;'
  };

  /**
   * Show emote menu (radial picker)
   */
  function showEmoteMenu() {
    if (typeof document === 'undefined') return;
    hideEmoteMenu(); // Remove existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    emoteMenuEl = document.createElement('div');
    emoteMenuEl.id = 'emote-menu';
    emoteMenuEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'width:300px;height:300px;pointer-events:auto;z-index:250;';

    var emotes = [
      { type: 'wave', label: 'Wave', angle: 0 },
      { type: 'dance', label: 'Dance', angle: 60 },
      { type: 'bow', label: 'Bow', angle: 120 },
      { type: 'cheer', label: 'Cheer', angle: 180 },
      { type: 'meditate', label: 'Meditate', angle: 240 },
      { type: 'point', label: 'Point', angle: 300 }
    ];

    var centerX = 150, centerY = 150, radius = 100;

    emotes.forEach(function(emote) {
      var angleRad = (emote.angle - 90) * Math.PI / 180;
      var x = centerX + radius * Math.cos(angleRad) - 35;
      var y = centerY + radius * Math.sin(angleRad) - 35;

      var btn = document.createElement('div');
      btn.className = 'emote-btn';
      btn.style.cssText = 'position:absolute;left:' + x + 'px;top:' + y + 'px;' +
        'width:70px;height:70px;border-radius:50%;background:rgba(0,0,0,0.8);' +
        'border:2px solid rgba(255,255,255,0.5);display:flex;flex-direction:column;' +
        'align-items:center;justify-content:center;cursor:pointer;' +
        'transition:all 0.2s;color:#fff;font-size:11px;';

      btn.innerHTML = '<div style="font-size:28px;margin-bottom:2px;">' + EMOTE_SYMBOLS[emote.type] + '</div>' +
        '<div>' + emote.label + '</div>';

      btn.onmouseover = function() {
        this.style.background = 'rgba(74,170,255,0.9)';
        this.style.borderColor = '#4af';
        this.style.transform = 'scale(1.1)';
      };

      btn.onmouseout = function() {
        this.style.background = 'rgba(0,0,0,0.8)';
        this.style.borderColor = 'rgba(255,255,255,0.5)';
        this.style.transform = 'scale(1)';
      };

      btn.onclick = (function(type) {
        return function() {
          hideEmoteMenu();
          if (window.Main && window.Main.handleLocalAction) {
            window.Main.handleLocalAction('emote', { type: type });
          }
        };
      })(emote.type);

      emoteMenuEl.appendChild(btn);
    });

    // Center label
    var centerLabel = document.createElement('div');
    centerLabel.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.9);border:2px solid #4af;border-radius:50%;' +
      'width:80px;height:80px;display:flex;align-items:center;justify-content:center;' +
      'color:#4af;font-weight:bold;font-size:12px;text-align:center;pointer-events:none;';
    centerLabel.textContent = 'Emotes';
    emoteMenuEl.appendChild(centerLabel);

    hud.appendChild(emoteMenuEl);
    emoteMenuVisible = true;
  }

  /**
   * Hide emote menu
   */
  function hideEmoteMenu() {
    if (emoteMenuEl && emoteMenuEl.parentNode) {
      emoteMenuEl.parentNode.removeChild(emoteMenuEl);
      emoteMenuEl = null;
    }
    emoteMenuVisible = false;
  }

  /**
   * Show emote bubble above player
   * @param {string} playerId - Player ID
   * @param {string} emoteType - Type of emote
   */
  function showEmoteBubble(playerId, emoteType) {
    if (typeof document === 'undefined') return;

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    // Remove existing bubble for this player
    var existing = emoteBubbles.get(playerId);
    if (existing && existing.element && existing.element.parentNode) {
      existing.element.parentNode.removeChild(existing.element);
    }

    var bubble = document.createElement('div');
    bubble.className = 'emote-bubble';
    bubble.style.cssText = 'position:absolute;background:rgba(255,255,255,0.95);' +
      'border:2px solid #4af;border-radius:20px;padding:8px 16px;' +
      'font-size:14px;font-weight:bold;color:#000;' +
      'box-shadow:0 4px 12px rgba(0,0,0,0.3);pointer-events:none;z-index:150;' +
      'animation:emoteFloat 2s ease-out forwards;white-space:nowrap;';

    var label = emoteType.charAt(0).toUpperCase() + emoteType.slice(1);
    bubble.innerHTML = EMOTE_SYMBOLS[emoteType] + ' ' + label;

    hud.appendChild(bubble);

    emoteBubbles.set(playerId, {
      element: bubble,
      timer: 2.0,
      emoteType: emoteType
    });

    // Auto-remove after animation
    setTimeout(function() {
      if (bubble.parentNode) {
        bubble.parentNode.removeChild(bubble);
      }
      emoteBubbles.delete(playerId);
    }, 2000);
  }

  /**
   * Update emote bubble positions (called from main loop)
   * @param {object} playerPositions - Map of playerId to screen position
   */
  function updateEmoteBubbles(playerPositions) {
    emoteBubbles.forEach(function(bubble, playerId) {
      if (!bubble.element || !bubble.element.parentNode) {
        emoteBubbles.delete(playerId);
        return;
      }

      var screenPos = playerPositions[playerId];
      if (screenPos) {
        bubble.element.style.left = screenPos.x + 'px';
        bubble.element.style.top = (screenPos.y - 80) + 'px';
      }
    });
  }

  // Add CSS animation for emote bubbles
  if (typeof document !== 'undefined') {
    var style = document.createElement('style');
    style.textContent += `
      @keyframes emoteFloat {
        0% {
          transform: translateY(0) scale(0.8);
          opacity: 0;
        }
        20% {
          opacity: 1;
          transform: translateY(-10px) scale(1);
        }
        80% {
          opacity: 1;
          transform: translateY(-30px) scale(1);
        }
        100% {
          transform: translateY(-40px) scale(0.9);
          opacity: 0;
        }
      }
    `;
    if (document.head) {
      document.head.appendChild(style);
    }
  }

  // ========================================================================
  // TRADING SYSTEM UI
  // ========================================================================

  var tradeRequestEl = null;
  var tradeWindowEl = null;
  var currentTradeData = null;

  /**
   * Show trade request popup
   * @param {string} fromPlayer - Player name requesting trade
   * @param {string} tradeId - Trade ID
   * @param {Function} onAccept - Callback when Accept clicked
   * @param {Function} onDecline - Callback when Decline clicked
   */
  function showTradeRequest(fromPlayer, tradeId, onAccept, onDecline) {
    if (typeof document === 'undefined') return;
    hideTradeRequest(); // Remove any existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    tradeRequestEl = document.createElement('div');
    tradeRequestEl.id = 'trade-request';
    tradeRequestEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #ffa500;border-radius:12px;' +
      'padding:20px;width:400px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    var html = '<div style="font-size:20px;font-weight:bold;color:#ffa500;margin-bottom:12px;">Trade Request</div>' +
      '<div style="font-size:16px;color:#fff;margin-bottom:16px;">' +
      '<span style="color:#4af;font-weight:bold;">' + fromPlayer + '</span> wants to trade with you.' +
      '</div>' +
      '<div style="display:flex;gap:12px;justify-content:center;">' +
      '<button id="trade-accept-btn" style="padding:10px 24px;background:#4f4;color:#000;border:none;' +
      'border-radius:6px;font-weight:bold;font-size:14px;cursor:pointer;">Accept</button>' +
      '<button id="trade-decline-btn" style="padding:10px 24px;background:rgba(255,255,255,0.1);color:#fff;' +
      'border:1px solid #666;border-radius:6px;font-size:14px;cursor:pointer;">Decline</button></div>';

    tradeRequestEl.innerHTML = html;
    hud.appendChild(tradeRequestEl);

    var acceptBtn = document.getElementById('trade-accept-btn');
    if (acceptBtn) acceptBtn.addEventListener('click', function() {
      hideTradeRequest();
      if (onAccept) onAccept(tradeId);
    });

    var declineBtn = document.getElementById('trade-decline-btn');
    if (declineBtn) declineBtn.addEventListener('click', function() {
      hideTradeRequest();
      if (onDecline) onDecline(tradeId);
    });
  }

  /**
   * Hide trade request popup
   */
  function hideTradeRequest() {
    if (tradeRequestEl && tradeRequestEl.parentNode) {
      tradeRequestEl.parentNode.removeChild(tradeRequestEl);
      tradeRequestEl = null;
    }
  }

  /**
   * Show trade window
   * @param {Object} trade - Trade data object
   * @param {string} localPlayerId - Local player's ID
   * @param {Function} onAddItem - Callback(slotIndex)
   * @param {Function} onRemoveItem - Callback(tradeSlot)
   * @param {Function} onSetSpark - Callback(amount)
   * @param {Function} onReady - Callback()
   * @param {Function} onConfirm - Callback()
   * @param {Function} onCancel - Callback()
   */
  function showTradeWindow(trade, localPlayerId, onAddItem, onRemoveItem, onSetSpark, onReady, onConfirm, onCancel) {
    if (typeof document === 'undefined') return;
    hideTradeWindow(); // Remove any existing

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    currentTradeData = { trade: trade, localPlayerId: localPlayerId };

    tradeWindowEl = document.createElement('div');
    tradeWindowEl.id = 'trade-window';
    tradeWindowEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #ffa500;border-radius:12px;' +
      'padding:20px;width:700px;pointer-events:auto;box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    tradeWindowEl.innerHTML = '<div style="font-size:20px;font-weight:bold;color:#ffa500;margin-bottom:16px;text-align:center;">Trade Window</div>' +
      '<div id="trade-content"></div>';

    hud.appendChild(tradeWindowEl);

    // Store callbacks
    tradeWindowEl._callbacks = { onAddItem, onRemoveItem, onSetSpark, onReady, onConfirm, onCancel };

    // Update content
    updateTradeWindow(trade, localPlayerId);
  }

  /**
   * Update trade window with current trade state
   * @param {Object} trade - Trade data object
   * @param {string} localPlayerId - Local player's ID
   */
  function updateTradeWindow(trade, localPlayerId) {
    if (!tradeWindowEl) return;

    var contentDiv = document.getElementById('trade-content');
    if (!contentDiv) return;

    var isPlayer1 = trade.player1.id === localPlayerId;
    var localPlayer = isPlayer1 ? trade.player1 : trade.player2;
    var otherPlayer = isPlayer1 ? trade.player2 : trade.player1;

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;

    // Build trade grid
    var html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:16px;">';

    // Your offer column
    html += '<div style="border:2px solid #4af;border-radius:8px;padding:12px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#4af;margin-bottom:10px;text-align:center;">Your Offer</div>' +
      '<div id="local-items" style="display:grid;grid-template-columns:repeat(3,80px);gap:6px;margin-bottom:10px;justify-content:center;">';

    // Local player's items (6 slots)
    for (var i = 0; i < 6; i++) {
      var item = localPlayer.items[i];
      var slotHtml = '<div class="trade-slot" data-slot="' + i + '" style="background:rgba(255,255,255,0.1);border:2px solid #555;' +
        'border-radius:6px;padding:8px;text-align:center;min-height:60px;cursor:pointer;position:relative;">';

      if (item && Inventory) {
        var itemData = Inventory.getItemData(item.itemId);
        if (itemData) {
          slotHtml += '<div style="font-size:28px;">' + itemData.icon + '</div>' +
            '<div style="font-size:9px;color:#ccc;">' + itemData.name + '</div>' +
            '<div style="position:absolute;top:2px;right:4px;background:#000;padding:1px 4px;border-radius:2px;font-size:10px;">' + item.count + '</div>';
        }
      } else {
        slotHtml += '<div style="color:#444;padding-top:15px;font-size:11px;">Empty</div>';
      }

      slotHtml += '</div>';
      html += slotHtml;
    }

    html += '</div>';

    // Spark input
    html += '<div style="margin-bottom:10px;">' +
      '<label style="font-size:12px;color:#aaa;display:block;margin-bottom:4px;">Spark Offer:</label>' +
      '<input type="number" id="local-spark-input" min="0" value="' + localPlayer.spark + '" ' +
      'style="width:100%;padding:6px;background:rgba(0,0,0,0.5);border:1px solid #555;border-radius:4px;color:#fff;font-size:14px;" />' +
      '</div>';

    // Status
    var statusText = localPlayer.ready ? 'âœ“ Ready' : 'Not ready';
    var statusColor = localPlayer.ready ? '#4f4' : '#888';
    html += '<div style="text-align:center;color:' + statusColor + ';font-size:13px;margin-bottom:8px;">' + statusText + '</div>';

    html += '</div>';

    // Their offer column
    html += '<div style="border:2px solid #f4a;border-radius:8px;padding:12px;">' +
      '<div style="font-size:16px;font-weight:bold;color:#f4a;margin-bottom:10px;text-align:center;">Their Offer</div>' +
      '<div id="other-items" style="display:grid;grid-template-columns:repeat(3,80px);gap:6px;margin-bottom:10px;justify-content:center;">';

    // Other player's items (6 slots)
    for (var j = 0; j < 6; j++) {
      var otherItem = otherPlayer.items[j];
      var otherSlotHtml = '<div style="background:rgba(255,255,255,0.1);border:2px solid #555;' +
        'border-radius:6px;padding:8px;text-align:center;min-height:60px;position:relative;">';

      if (otherItem && Inventory) {
        var otherItemData = Inventory.getItemData(otherItem.itemId);
        if (otherItemData) {
          otherSlotHtml += '<div style="font-size:28px;">' + otherItemData.icon + '</div>' +
            '<div style="font-size:9px;color:#ccc;">' + otherItemData.name + '</div>' +
            '<div style="position:absolute;top:2px;right:4px;background:#000;padding:1px 4px;border-radius:2px;font-size:10px;">' + otherItem.count + '</div>';
        }
      } else {
        otherSlotHtml += '<div style="color:#444;padding-top:15px;font-size:11px;">Empty</div>';
      }

      otherSlotHtml += '</div>';
      html += otherSlotHtml;
    }

    html += '</div>';

    // Their Spark
    html += '<div style="margin-bottom:10px;">' +
      '<label style="font-size:12px;color:#aaa;display:block;margin-bottom:4px;">Spark Offer:</label>' +
      '<div style="padding:6px;background:rgba(0,0,0,0.5);border:1px solid #555;border-radius:4px;color:#ffa500;font-size:14px;text-align:center;">' +
      otherPlayer.spark + '</div></div>';

    // Their status
    var otherStatusText = otherPlayer.ready ? 'âœ“ Ready' : 'Not ready';
    var otherStatusColor = otherPlayer.ready ? '#4f4' : '#888';
    html += '<div style="text-align:center;color:' + otherStatusColor + ';font-size:13px;margin-bottom:8px;">' + otherStatusText + '</div>';

    html += '</div>';

    html += '</div>';

    // Status message
    var statusMsg = '';
    if (localPlayer.confirmed && otherPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#4f4;font-size:14px;margin-bottom:12px;">âœ“ Trade completed!</div>';
    } else if (localPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#fa4;font-size:14px;margin-bottom:12px;">Waiting for ' + otherPlayer.id + ' to confirm...</div>';
    } else if (otherPlayer.confirmed) {
      statusMsg = '<div style="text-align:center;color:#fa4;font-size:14px;margin-bottom:12px;">' + otherPlayer.id + ' has confirmed. Ready to confirm?</div>';
    } else if (localPlayer.ready && otherPlayer.ready) {
      statusMsg = '<div style="text-align:center;color:#4f4;font-size:14px;margin-bottom:12px;">Both ready! Click Confirm to complete trade.</div>';
    } else if (localPlayer.ready) {
      statusMsg = '<div style="text-align:center;color:#888;font-size:14px;margin-bottom:12px;">Waiting for ' + otherPlayer.id + ' to ready up...</div>';
    } else {
      statusMsg = '<div style="text-align:center;color:#888;font-size:14px;margin-bottom:12px;">Add items and Spark, then click Ready.</div>';
    }

    html += statusMsg;

    // Action buttons
    html += '<div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">';

    if (!localPlayer.ready) {
      html += '<button id="trade-ready-btn" style="padding:8px 20px;background:#4f4;color:#000;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Ready</button>';
    }

    if (localPlayer.ready && otherPlayer.ready && !localPlayer.confirmed) {
      html += '<button id="trade-confirm-btn" style="padding:8px 20px;background:#ffa500;color:#000;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Confirm Trade</button>';
    }

    html += '<button id="trade-cancel-btn" style="padding:8px 20px;background:#f44;color:#fff;border:none;border-radius:6px;font-weight:bold;cursor:pointer;">Cancel</button>';

    html += '</div>';

    contentDiv.innerHTML = html;

    // Attach event listeners
    var callbacks = tradeWindowEl._callbacks;

    // Spark input
    var sparkInput = document.getElementById('local-spark-input');
    if (sparkInput && callbacks.onSetSpark) {
      sparkInput.addEventListener('change', function() {
        var amount = parseInt(this.value) || 0;
        callbacks.onSetSpark(amount);
      });
    }

    // Ready button
    var readyBtn = document.getElementById('trade-ready-btn');
    if (readyBtn && callbacks.onReady) {
      readyBtn.addEventListener('click', function() {
        callbacks.onReady();
      });
    }

    // Confirm button
    var confirmBtn = document.getElementById('trade-confirm-btn');
    if (confirmBtn && callbacks.onConfirm) {
      confirmBtn.addEventListener('click', function() {
        callbacks.onConfirm();
      });
    }

    // Cancel button
    var cancelBtn = document.getElementById('trade-cancel-btn');
    if (cancelBtn && callbacks.onCancel) {
      cancelBtn.addEventListener('click', function() {
        callbacks.onCancel();
      });
    }

    // Trade slot clicks (add or remove items)
    var tradeSlots = document.querySelectorAll('.trade-slot');
    tradeSlots.forEach(function(slot, idx) {
      slot.addEventListener('click', function() {
        if (localPlayer.items[idx] && callbacks.onRemoveItem) {
          callbacks.onRemoveItem(idx);
        } else if (!localPlayer.items[idx] && callbacks.onAddItem) {
          // Show inventory picker for empty slot
          showTradeItemPicker(idx, callbacks.onAddItem);
        }
      });
    });
  }

  /**
   * Show inventory item picker popup for trade window
   */
  function showTradeItemPicker(slotIndex, onAddItem) {
    // Remove existing picker
    var existing = document.getElementById('trade-item-picker');
    if (existing) existing.parentNode.removeChild(existing);

    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Inventory) return;

    // Get player inventory from global
    var inv = typeof playerInventory !== 'undefined' ? playerInventory : null;
    if (!inv) {
      // Try to get from window
      inv = typeof window !== 'undefined' && window.playerInventory ? window.playerInventory : null;
    }
    if (!inv) return;

    var items = Inventory.getInventory(inv);
    if (!items || items.length === 0) {
      showNotification('No items in inventory to trade');
      return;
    }

    var picker = document.createElement('div');
    picker.id = 'trade-item-picker';
    picker.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #4af;border-radius:12px;' +
      'padding:16px;width:320px;max-height:400px;overflow-y:auto;z-index:400;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.9);pointer-events:auto;';

    var html = '<div style="font-size:16px;font-weight:bold;color:#4af;margin-bottom:12px;text-align:center;">Select Item to Trade</div>';
    html += '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;">';

    items.forEach(function(item, i) {
      var itemData = Inventory.getItemData(item.itemId);
      if (itemData) {
        html += '<div class="trade-pick-item" data-idx="' + i + '" data-itemid="' + item.itemId + '" ' +
          'style="background:rgba(255,255,255,0.08);border:2px solid #444;border-radius:6px;' +
          'padding:8px;text-align:center;cursor:pointer;transition:border-color 0.2s;">' +
          '<div style="font-size:24px;">' + itemData.icon + '</div>' +
          '<div style="font-size:9px;color:#ccc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + itemData.name + '</div>' +
          '<div style="font-size:10px;color:#888;">x' + (item.count || 1) + '</div>' +
          '</div>';
      }
    });

    html += '</div>';
    html += '<div style="text-align:center;margin-top:12px;">' +
      '<button id="trade-pick-cancel" style="padding:6px 16px;background:#555;color:#fff;border:none;border-radius:4px;cursor:pointer;">Cancel</button></div>';

    picker.innerHTML = html;
    document.body.appendChild(picker);

    // Attach click handlers
    var pickItems = picker.querySelectorAll('.trade-pick-item');
    pickItems.forEach(function(el) {
      el.addEventListener('click', function() {
        var itemId = el.getAttribute('data-itemid');
        onAddItem(slotIndex, itemId);
        picker.parentNode.removeChild(picker);
      });
    });

    var cancelBtn = document.getElementById('trade-pick-cancel');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        picker.parentNode.removeChild(picker);
      });
    }
  }

  /**
   * Hide trade window
   */
  function hideTradeWindow() {
    if (tradeWindowEl && tradeWindowEl.parentNode) {
      tradeWindowEl.parentNode.removeChild(tradeWindowEl);
      tradeWindowEl = null;
      currentTradeData = null;
    }
  }

  /**
   * Show trade complete notification
   * @param {string} partnerName - Trade partner's name
   */
  function showTradeComplete(partnerName) {
    showNotification('Trade completed with ' + partnerName + '!', 'success');
  }

  // ========================================================================
  // BUILD TOOLBAR
  // ========================================================================

  let buildToolbar = null;
  let selectedBuildType = 'bench';

  var BUILD_TYPES = [
    { id: 'bench', icon: '\u{1F6CB}', label: 'Bench', cost: 50 },
    { id: 'lantern', icon: '\u{1F4A1}', label: 'Lantern', cost: 75 },
    { id: 'signpost', icon: '\u{1F6A9}', label: 'Sign', cost: 40 },
    { id: 'fence', icon: '\u{1F6AA}', label: 'Fence', cost: 30 },
    { id: 'planter', icon: '\u{1F33F}', label: 'Planter', cost: 60 },
    { id: 'campfire', icon: '\u{1F525}', label: 'Fire', cost: 80 },
    { id: 'archway', icon: '\u{26E9}', label: 'Arch', cost: 150 },
    { id: 'table', icon: '\u{1F6CF}', label: 'Table', cost: 70 },
    { id: 'barrel', icon: '\u{1F6E2}', label: 'Barrel', cost: 45 },
    { id: 'crate', icon: '\u{1F4E6}', label: 'Crate', cost: 35 }
  ];

  function showBuildToolbar() {
    if (typeof document === 'undefined') return;

    if (buildToolbar) {
      buildToolbar.style.display = 'block';
      return;
    }

    buildToolbar = document.createElement('div');
    buildToolbar.id = 'build-toolbar';
    buildToolbar.style.cssText = `
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px 8px 0 0;
      padding: 10px 20px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 200;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-bottom: none;
      pointer-events: auto;
    `;

    // Title
    var title = document.createElement('div');
    title.style.cssText = `
      color: #fff;
      font-weight: bold;
      margin-right: 10px;
      font-size: 14px;
    `;
    title.textContent = 'BUILD MODE';
    buildToolbar.appendChild(title);

    // Build type buttons
    BUILD_TYPES.forEach(function(type) {
      var btn = document.createElement('div');
      btn.className = 'build-type-btn';
      btn.dataset.type = type.id;
      btn.style.cssText = `
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      `;

      var icon = document.createElement('div');
      icon.style.cssText = 'font-size: 24px; margin-bottom: 2px;';
      icon.textContent = type.icon;

      var label = document.createElement('div');
      label.style.cssText = 'font-size: 9px; color: #ccc;';
      label.textContent = type.label;

      var cost = document.createElement('div');
      cost.style.cssText = 'font-size: 8px; color: #ffa500;';
      cost.textContent = type.cost + ' Spark';

      btn.appendChild(icon);
      btn.appendChild(label);
      btn.appendChild(cost);

      btn.addEventListener('click', function() {
        selectedBuildType = type.id;
        updateBuildToolbar(selectedBuildType);
        if (typeof World !== 'undefined' && World.setBuildType) {
          World.setBuildType(type.id);
        }
      });

      btn.addEventListener('mouseenter', function() {
        btn.style.background = 'rgba(255, 255, 255, 0.2)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.6)';
      });

      btn.addEventListener('mouseleave', function() {
        if (type.id !== selectedBuildType) {
          btn.style.background = 'rgba(255, 255, 255, 0.1)';
          btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
      });

      buildToolbar.appendChild(btn);
    });

    // Instructions
    var instructions = document.createElement('div');
    instructions.style.cssText = `
      margin-left: 15px;
      color: #ccc;
      font-size: 12px;
      line-height: 1.4;
    `;
    instructions.innerHTML = `
      <div>Click to place</div>
      <div>R to rotate</div>
      <div><strong>B or Esc</strong> to exit</div>
    `;
    buildToolbar.appendChild(instructions);

    document.body.appendChild(buildToolbar);

    updateBuildToolbar(selectedBuildType);
  }

  function hideBuildToolbar() {
    if (buildToolbar) {
      buildToolbar.style.display = 'none';
    }
  }

  function updateBuildToolbar(type) {
    if (!buildToolbar) return;
    selectedBuildType = type;

    var buttons = buildToolbar.querySelectorAll('.build-type-btn');
    buttons.forEach(function(btn) {
      if (btn.dataset.type === type) {
        btn.style.background = 'rgba(255, 215, 0, 0.3)';
        btn.style.borderColor = 'rgba(255, 215, 0, 0.8)';
        btn.style.borderWidth = '3px';
      } else {
        btn.style.background = 'rgba(255, 255, 255, 0.1)';
        btn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        btn.style.borderWidth = '2px';
      }
    });
  }

  // Settings Menu
  let settingsMenuPanel = null;
  let settingsData = {
    masterVolume: 50,
    musicVolume: 30,
    sfxVolume: 70,
    renderDistance: 'medium',
    particleDensity: 'medium',
    showFPS: false
  };

  function loadSettings() {
    if (typeof localStorage === 'undefined') return;
    try {
      var stored = localStorage.getItem('zion_settings');
      if (stored) {
        var parsed = JSON.parse(stored);
        Object.assign(settingsData, parsed);
      }
    } catch (err) {
      console.warn('Failed to load settings:', err);
    }
  }

  function saveSettings() {
    if (typeof localStorage === 'undefined') return;
    try {
      localStorage.setItem('zion_settings', JSON.stringify(settingsData));
    } catch (err) {
      console.warn('Failed to save settings:', err);
    }
  }

  function getSettings() {
    return settingsData;
  }

  function showSettingsMenu() {
    if (settingsMenuPanel) return;

    var overlay = document.createElement('div');
    overlay.id = 'settings-menu-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    `;

    var panel = document.createElement('div');
    panel.style.cssText = `
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 12px;
      padding: 30px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
    `;

    var title = document.createElement('h2');
    title.textContent = 'Settings';
    title.style.cssText = `
      margin: 0 0 25px 0;
      color: #DAA520;
      font-size: 28px;
      font-family: Georgia, serif;
      text-align: center;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;
    panel.appendChild(title);

    // Volume Section
    var volumeSection = document.createElement('div');
    volumeSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var volumeTitle = document.createElement('h3');
    volumeTitle.textContent = 'Audio';
    volumeTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    volumeSection.appendChild(volumeTitle);

    // Master Volume
    volumeSection.appendChild(createSlider('Master Volume', 'masterVolume', settingsData.masterVolume));
    // Music Volume
    volumeSection.appendChild(createSlider('Music Volume', 'musicVolume', settingsData.musicVolume));
    // SFX Volume
    volumeSection.appendChild(createSlider('SFX Volume', 'sfxVolume', settingsData.sfxVolume));

    panel.appendChild(volumeSection);

    // Graphics Section
    var graphicsSection = document.createElement('div');
    graphicsSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var graphicsTitle = document.createElement('h3');
    graphicsTitle.textContent = 'Graphics';
    graphicsTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    graphicsSection.appendChild(graphicsTitle);

    // Render Distance
    graphicsSection.appendChild(createOptionButtons('Render Distance', 'renderDistance', ['low', 'medium', 'high'], settingsData.renderDistance));
    // Particle Density
    graphicsSection.appendChild(createOptionButtons('Particle Density', 'particleDensity', ['low', 'medium', 'high'], settingsData.particleDensity));
    // Show FPS Counter
    graphicsSection.appendChild(createCheckbox('Show FPS Counter', 'showFPS', settingsData.showFPS));

    panel.appendChild(graphicsSection);

    // Controls Section
    var controlsSection = document.createElement('div');
    controlsSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var controlsTitle = document.createElement('h3');
    controlsTitle.textContent = 'Controls';
    controlsTitle.style.cssText = `
      margin: 0 0 15px 0;
      color: #E8E0D8;
      font-size: 20px;
      font-family: Georgia, serif;
    `;
    controlsSection.appendChild(controlsTitle);

    var controlsInfo = document.createElement('div');
    controlsInfo.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      line-height: 1.8;
      font-family: system-ui, sans-serif;
    `;
    controlsInfo.innerHTML = `
      <div style="display: grid; grid-template-columns: 120px 1fr; gap: 8px;">
        <div><strong>W/A/S/D</strong></div><div>Move</div>
        <div><strong>Mouse</strong></div><div>Look around</div>
        <div><strong>E</strong></div><div>Interact</div>
        <div><strong>I</strong></div><div>Inventory</div>
        <div><strong>C</strong></div><div>Crafting</div>
        <div><strong>J</strong></div><div>Quest Log</div>
        <div><strong>M</strong></div><div>World Map</div>
        <div><strong>B</strong></div><div>Build Mode</div>
        <div><strong>F</strong></div><div>Emote Menu</div>
        <div><strong>T</strong></div><div>Trade</div>
        <div><strong>P</strong></div><div>Player Profile</div>
        <div><strong>Enter</strong></div><div>Chat</div>
        <div><strong>Escape</strong></div><div>Settings / Cancel</div>
      </div>
    `;
    controlsSection.appendChild(controlsInfo);

    panel.appendChild(controlsSection);

    // Resume Button
    var resumeBtn = document.createElement('button');
    resumeBtn.textContent = 'Resume';
    resumeBtn.style.cssText = `
      width: 100%;
      padding: 15px;
      background: rgba(218, 165, 32, 0.2);
      color: #DAA520;
      border: 2px solid #DAA520;
      border-radius: 8px;
      font-size: 18px;
      font-family: Georgia, serif;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 10px;
    `;
    resumeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#FFD700';
    };
    resumeBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.2)';
      this.style.borderColor = '#DAA520';
    };
    resumeBtn.onclick = function() {
      hideSettingsMenu();
    };
    panel.appendChild(resumeBtn);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);
    settingsMenuPanel = overlay;
  }

  function hideSettingsMenu() {
    if (!settingsMenuPanel) return;
    document.body.removeChild(settingsMenuPanel);
    settingsMenuPanel = null;
  }

  function createSlider(label, key, value) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
    `;

    var labelEl = document.createElement('label');
    labelEl.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;

    var labelText = document.createElement('span');
    labelText.textContent = label;

    var valueDisplay = document.createElement('span');
    valueDisplay.textContent = value;
    valueDisplay.style.color = '#DAA520';
    valueDisplay.style.fontWeight = 'bold';

    labelEl.appendChild(labelText);
    labelEl.appendChild(valueDisplay);
    container.appendChild(labelEl);

    var slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '100';
    slider.value = value;
    slider.style.cssText = `
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    `;

    slider.oninput = function() {
      valueDisplay.textContent = this.value;
      settingsData[key] = parseInt(this.value);
      saveSettings();
      applySettings();
    };

    container.appendChild(slider);
    return container;
  }

  function createOptionButtons(label, key, options, currentValue) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
    `;

    var labelEl = document.createElement('div');
    labelEl.textContent = label;
    labelEl.style.cssText = `
      margin-bottom: 8px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    container.appendChild(labelEl);

    var buttonsContainer = document.createElement('div');
    buttonsContainer.style.cssText = `
      display: flex;
      gap: 10px;
    `;

    options.forEach(function(option) {
      var btn = document.createElement('button');
      btn.textContent = option.charAt(0).toUpperCase() + option.slice(1);
      btn.style.cssText = `
        flex: 1;
        padding: 10px;
        background: ${option === currentValue ? 'rgba(218, 165, 32, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
        color: ${option === currentValue ? '#DAA520' : '#E8E0D8'};
        border: 2px solid ${option === currentValue ? '#DAA520' : 'rgba(255, 255, 255, 0.3)'};
        border-radius: 6px;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        cursor: pointer;
        transition: all 0.3s ease;
      `;

      btn.onclick = function() {
        settingsData[key] = option;
        saveSettings();
        applySettings();

        // Update button styles
        Array.from(buttonsContainer.children).forEach(function(child) {
          child.style.background = 'rgba(255, 255, 255, 0.1)';
          child.style.color = '#E8E0D8';
          child.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        btn.style.background = 'rgba(218, 165, 32, 0.3)';
        btn.style.color = '#DAA520';
        btn.style.borderColor = '#DAA520';
      };

      btn.onmouseover = function() {
        if (option !== currentValue) {
          this.style.background = 'rgba(255, 255, 255, 0.15)';
        }
      };

      btn.onmouseout = function() {
        if (option !== currentValue) {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
        }
      };

      buttonsContainer.appendChild(btn);
    });

    container.appendChild(buttonsContainer);
    return container;
  }

  function createCheckbox(label, key, checked) {
    var container = document.createElement('div');
    container.style.cssText = `
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    `;

    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = checked;
    checkbox.style.cssText = `
      width: 20px;
      height: 20px;
      cursor: pointer;
    `;

    checkbox.onchange = function() {
      settingsData[key] = this.checked;
      saveSettings();
      applySettings();
    };

    var labelEl = document.createElement('label');
    labelEl.textContent = label;
    labelEl.style.cssText = `
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      cursor: pointer;
    `;
    labelEl.onclick = function() {
      checkbox.checked = !checkbox.checked;
      checkbox.onchange();
    };

    container.appendChild(checkbox);
    container.appendChild(labelEl);
    return container;
  }

  function applySettings() {
    // Apply audio settings
    if (typeof Audio !== 'undefined' && Audio.setVolume) {
      Audio.setVolume('master', settingsData.masterVolume / 100);
      Audio.setVolume('music', settingsData.musicVolume / 100);
      Audio.setVolume('sfx', settingsData.sfxVolume / 100);
    }

    // FPS counter will be handled by main.js
    // Render distance and particle density would be applied by renderer/world systems
  }

  // Player Profile Panel
  var playerProfilePanel = null;

  function showProfilePanel(playerData, skillData, achievementData) {
    if (playerProfilePanel) {
      hideProfilePanel();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'player-profile-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(0,0,0,0.9);border:2px solid #d4af37;border-radius:12px;' +
      'padding:0;width:700px;max-height:85vh;overflow-y:auto;pointer-events:auto;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);z-index:300;';

    // Header with close button
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;justify-content:space-between;align-items:center;' +
      'padding:20px;background:rgba(212,175,55,0.1);border-bottom:1px solid #d4af37;';

    var title = document.createElement('div');
    title.textContent = 'Player Profile';
    title.style.cssText = 'font-size:24px;font-weight:bold;color:#d4af37;';
    header.appendChild(title);

    var closeBtn = document.createElement('div');
    closeBtn.textContent = 'âœ•';
    closeBtn.style.cssText = 'cursor:pointer;font-size:24px;color:#888;padding:0 8px;';
    closeBtn.onmouseover = function() { this.style.color = '#d4af37'; };
    closeBtn.onmouseout = function() { this.style.color = '#888'; };
    closeBtn.onclick = function() { hideProfilePanel(); };
    header.appendChild(closeBtn);

    panel.appendChild(header);

    // Content container
    var content = document.createElement('div');
    content.id = 'profile-content';
    content.style.cssText = 'padding:20px;';

    // Player info section with avatar
    var playerInfoSection = document.createElement('div');
    playerInfoSection.style.cssText = 'display:flex;align-items:center;margin-bottom:20px;' +
      'padding-bottom:20px;border-bottom:1px solid rgba(212,175,55,0.3);';

    // Avatar (colored circle with initial)
    var avatar = document.createElement('div');
    var initial = (playerData.name || 'P').charAt(0).toUpperCase();
    avatar.textContent = initial;
    avatar.style.cssText = 'width:80px;height:80px;border-radius:50%;background:#d4af37;' +
      'display:flex;align-items:center;justify-content:center;font-size:36px;font-weight:bold;' +
      'color:#000;margin-right:20px;';
    playerInfoSection.appendChild(avatar);

    // Player details
    var playerDetails = document.createElement('div');
    playerDetails.style.cssText = 'flex:1;';

    var playerName = document.createElement('div');
    playerName.textContent = playerData.name || 'Player';
    playerName.style.cssText = 'font-size:22px;font-weight:bold;color:#fff;margin-bottom:8px;';
    playerDetails.appendChild(playerName);

    var reputationTier = document.createElement('div');
    var tier = playerData.reputationTier || 'Newcomer';
    reputationTier.textContent = 'Reputation: ' + tier;
    reputationTier.style.cssText = 'font-size:14px;color:#d4af37;margin-bottom:6px;';
    playerDetails.appendChild(reputationTier);

    var sparkBalance = document.createElement('div');
    sparkBalance.innerHTML = '<span style="color:#d4af37;">âœ¦</span> ' + (playerData.sparkBalance || 0) + ' Spark';
    sparkBalance.style.cssText = 'font-size:16px;color:#fff;font-weight:bold;';
    playerDetails.appendChild(sparkBalance);

    playerInfoSection.appendChild(playerDetails);
    content.appendChild(playerInfoSection);

    // Skills section
    var skillsSection = document.createElement('div');
    skillsSection.id = 'profile-skills-section';
    skillsSection.style.cssText = 'margin-bottom:20px;';

    var skillsTitle = document.createElement('div');
    skillsTitle.textContent = 'Skills';
    skillsTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    skillsSection.appendChild(skillsTitle);

    var skillNames = ['gardening', 'crafting', 'building', 'exploration', 'trading', 'social', 'combat', 'lore'];
    var skillIcons = {
      gardening: 'ðŸŒ±',
      crafting: 'ðŸ”¨',
      building: 'ðŸ—ï¸',
      exploration: 'ðŸ—ºï¸',
      trading: 'ðŸ’°',
      social: 'ðŸ‘¥',
      combat: 'âš”ï¸',
      lore: 'ðŸ“–'
    };

    skillNames.forEach(function(skillName) {
      var skill = (skillData && skillData[skillName]) || { level: 1, xp: 0, xpToNext: 100 };
      var skillDiv = document.createElement('div');
      skillDiv.className = 'skill-row-' + skillName;
      skillDiv.style.cssText = 'margin-bottom:14px;';

      var skillHeader = document.createElement('div');
      skillHeader.style.cssText = 'display:flex;justify-content:space-between;margin-bottom:4px;';

      var skillLabel = document.createElement('div');
      var icon = skillIcons[skillName] || 'â­';
      skillLabel.innerHTML = icon + ' ' + skillName.charAt(0).toUpperCase() + skillName.slice(1);
      skillLabel.style.cssText = 'font-size:14px;color:#fff;font-weight:600;';
      skillHeader.appendChild(skillLabel);

      var skillLevel = document.createElement('div');
      skillLevel.textContent = 'Level ' + skill.level;
      skillLevel.style.cssText = 'font-size:13px;color:#d4af37;font-weight:bold;';
      skillHeader.appendChild(skillLevel);

      skillDiv.appendChild(skillHeader);

      // Progress bar
      var progressContainer = document.createElement('div');
      progressContainer.style.cssText = 'width:100%;height:10px;background:rgba(255,255,255,0.1);' +
        'border-radius:5px;overflow:hidden;position:relative;';

      var progressFill = document.createElement('div');
      var progressPercent = Math.min(100, (skill.xp / skill.xpToNext) * 100);
      progressFill.style.cssText = 'height:100%;background:linear-gradient(90deg,#d4af37,#f4e4a6);' +
        'border-radius:5px;width:' + progressPercent + '%;transition:width 0.3s ease;';
      progressContainer.appendChild(progressFill);

      var progressText = document.createElement('div');
      progressText.textContent = skill.xp + ' / ' + skill.xpToNext + ' XP';
      progressText.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;' +
        'display:flex;align-items:center;justify-content:center;font-size:9px;color:#fff;font-weight:bold;';
      progressContainer.appendChild(progressText);

      skillDiv.appendChild(progressContainer);
      skillsSection.appendChild(skillDiv);
    });

    content.appendChild(skillsSection);

    // Statistics section
    var statsSection = document.createElement('div');
    statsSection.id = 'profile-stats-section';
    statsSection.style.cssText = 'margin-bottom:20px;padding:15px;background:rgba(212,175,55,0.05);' +
      'border-radius:8px;border:1px solid rgba(212,175,55,0.2);';

    var statsTitle = document.createElement('div');
    statsTitle.textContent = 'Statistics';
    statsTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    statsSection.appendChild(statsTitle);

    var statsGrid = document.createElement('div');
    statsGrid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:10px;';

    var stats = [
      { label: 'Quests Completed', value: playerData.questsCompleted || 0 },
      { label: 'Discoveries Found', value: playerData.discoveriesFound || 0 },
      { label: 'Items Crafted', value: playerData.itemsCrafted || 0 },
      { label: 'Trades Completed', value: playerData.tradesCompleted || 0 },
      { label: 'Time Played', value: formatPlayTime(playerData.playTimeSeconds || 0) }
    ];

    stats.forEach(function(stat) {
      var statItem = document.createElement('div');
      statItem.className = 'stat-' + stat.label.toLowerCase().replace(/ /g, '-');
      statItem.style.cssText = 'padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;';

      var statLabel = document.createElement('div');
      statLabel.textContent = stat.label;
      statLabel.style.cssText = 'font-size:11px;color:#888;margin-bottom:4px;';
      statItem.appendChild(statLabel);

      var statValue = document.createElement('div');
      statValue.textContent = stat.value;
      statValue.style.cssText = 'font-size:16px;color:#fff;font-weight:bold;';
      statItem.appendChild(statValue);

      statsGrid.appendChild(statItem);
    });

    statsSection.appendChild(statsGrid);
    content.appendChild(statsSection);

    // Recent Activity section
    var activitySection = document.createElement('div');
    activitySection.id = 'profile-activity-section';
    activitySection.style.cssText = 'margin-bottom:0;';

    var activityTitle = document.createElement('div');
    activityTitle.textContent = 'Recent Activity';
    activityTitle.style.cssText = 'font-size:18px;font-weight:bold;color:#d4af37;margin-bottom:12px;';
    activitySection.appendChild(activityTitle);

    var activities = playerData.recentActivities || ['Started playing ZION'];
    var activityList = document.createElement('div');
    activityList.style.cssText = 'max-height:150px;overflow-y:auto;';

    activities.slice(0, 10).forEach(function(activity) {
      var activityItem = document.createElement('div');
      activityItem.textContent = 'â€¢ ' + activity;
      activityItem.style.cssText = 'font-size:12px;color:#aaa;padding:4px 0;line-height:1.4;';
      activityList.appendChild(activityItem);
    });

    activitySection.appendChild(activityList);
    content.appendChild(activitySection);

    // Close hint
    var closeHint = document.createElement('div');
    closeHint.textContent = 'Press P to close';
    closeHint.style.cssText = 'text-align:center;margin-top:15px;font-size:11px;color:#666;';
    content.appendChild(closeHint);

    panel.appendChild(content);
    document.body.appendChild(panel);
    playerProfilePanel = panel;
  }

  function hideProfilePanel() {
    if (!playerProfilePanel) return;
    if (playerProfilePanel.parentNode) {
      playerProfilePanel.parentNode.removeChild(playerProfilePanel);
    }
    playerProfilePanel = null;
  }

  function updateProfileStats(stats) {
    if (!playerProfilePanel) return;

    // Update statistics values
    if (stats.questsCompleted !== undefined) {
      var questsStat = playerProfilePanel.querySelector('.stat-quests-completed div:last-child');
      if (questsStat) questsStat.textContent = stats.questsCompleted;
    }
    if (stats.discoveriesFound !== undefined) {
      var discoveriesStat = playerProfilePanel.querySelector('.stat-discoveries-found div:last-child');
      if (discoveriesStat) discoveriesStat.textContent = stats.discoveriesFound;
    }
    if (stats.itemsCrafted !== undefined) {
      var craftedStat = playerProfilePanel.querySelector('.stat-items-crafted div:last-child');
      if (craftedStat) craftedStat.textContent = stats.itemsCrafted;
    }
    if (stats.tradesCompleted !== undefined) {
      var tradesStat = playerProfilePanel.querySelector('.stat-trades-completed div:last-child');
      if (tradesStat) tradesStat.textContent = stats.tradesCompleted;
    }
    if (stats.playTimeSeconds !== undefined) {
      var timeStat = playerProfilePanel.querySelector('.stat-time-played div:last-child');
      if (timeStat) timeStat.textContent = formatPlayTime(stats.playTimeSeconds);
    }
  }

  // Legacy function names for backward compatibility
  function showPlayerProfile(playerData) {
    showProfilePanel(playerData, null, null);
  }

  function hidePlayerProfile() {
    hideProfilePanel();
  }

  function formatPlayTime(seconds) {
    var hours = Math.floor(seconds / 3600);
    var minutes = Math.floor((seconds % 3600) / 60);
    if (hours > 0) {
      return hours + 'h ' + minutes + 'm';
    }
    return minutes + 'm';
  }

  // Discovery Log Panel
  var discoveryLogPanel = null;

  function showDiscoveryLog(discoveries) {
    if (discoveryLogPanel) return;

    var panel = document.createElement('div');
    panel.id = 'discovery-log-overlay';
    panel.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    `;

    var content = document.createElement('div');
    content.style.cssText = `
      width: 80%;
      max-width: 900px;
      height: 80%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 12px;
      padding: 30px;
      overflow-y: auto;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
      border: 2px solid #3a506b;
    `;

    var header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #3a506b;
    `;

    var title = document.createElement('h2');
    title.textContent = 'Discovery Log';
    title.style.cssText = `
      margin: 0;
      color: #e0e0e0;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      font-weight: 600;
    `;

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'X';
    closeBtn.style.cssText = `
      background: #c0392b;
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
    `;
    closeBtn.onclick = hideDiscoveryLog;

    header.appendChild(title);
    header.appendChild(closeBtn);
    content.appendChild(header);

    // Group discoveries by zone
    var discoveryByZone = {};
    var totalDiscoveries = 0;
    if (discoveries && discoveries.length > 0) {
      discoveries.forEach(function(disc) {
        var zone = disc.zone || 'Unknown';
        if (!discoveryByZone[zone]) {
          discoveryByZone[zone] = [];
        }
        discoveryByZone[zone].push(disc);
        totalDiscoveries++;
      });
    }

    // Display discoveries by zone
    Object.keys(discoveryByZone).forEach(function(zone) {
      var zoneSection = document.createElement('div');
      zoneSection.style.cssText = `
        margin-bottom: 30px;
      `;

      var zoneHeader = document.createElement('div');
      zoneHeader.textContent = zone + ' (' + discoveryByZone[zone].length + ' discoveries)';
      zoneHeader.style.cssText = `
        color: #5dade2;
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 15px;
        font-family: system-ui, sans-serif;
      `;
      zoneSection.appendChild(zoneHeader);

      discoveryByZone[zone].forEach(function(disc) {
        var rarityColors = {
          common: '#ffffff',
          uncommon: '#1eff00',
          rare: '#0070dd',
          epic: '#a335ee',
          legendary: '#ff8000'
        };
        var color = rarityColors[disc.rarity] || '#ffffff';

        var discItem = document.createElement('div');
        discItem.style.cssText = `
          background: rgba(255, 255, 255, 0.05);
          border-left: 4px solid ` + color + `;
          padding: 12px 15px;
          margin-bottom: 10px;
          border-radius: 6px;
        `;

        var discName = document.createElement('div');
        discName.textContent = disc.name;
        discName.style.cssText = `
          color: ` + color + `;
          font-size: 16px;
          font-weight: 600;
          margin-bottom: 5px;
          font-family: system-ui, sans-serif;
        `;

        var discDesc = document.createElement('div');
        discDesc.textContent = disc.description || 'No description available';
        discDesc.style.cssText = `
          color: #b0b0b0;
          font-size: 14px;
          margin-bottom: 5px;
          font-family: system-ui, sans-serif;
        `;

        var discMeta = document.createElement('div');
        discMeta.textContent = 'Discovered: ' + (disc.timestamp ? new Date(disc.timestamp).toLocaleDateString() : 'Unknown');
        discMeta.style.cssText = `
          color: #808080;
          font-size: 12px;
          font-style: italic;
          font-family: system-ui, sans-serif;
        `;

        discItem.appendChild(discName);
        discItem.appendChild(discDesc);
        discItem.appendChild(discMeta);
        zoneSection.appendChild(discItem);
      });

      content.appendChild(zoneSection);
    });

    if (totalDiscoveries === 0) {
      var emptyMsg = document.createElement('div');
      emptyMsg.textContent = 'No discoveries yet. Explore the world to find new locations, creatures, and secrets!';
      emptyMsg.style.cssText = `
        color: #a0a0a0;
        font-size: 16px;
        text-align: center;
        margin-top: 50px;
        font-family: system-ui, sans-serif;
      `;
      content.appendChild(emptyMsg);
    }

    panel.appendChild(content);
    document.body.appendChild(panel);
    discoveryLogPanel = panel;
    panel.className = 'discovery-panel';
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideDiscoveryLog();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideDiscoveryLog() {
    if (!discoveryLogPanel) return;
    if (discoveryLogPanel.escapeHandler) {
      document.removeEventListener('keydown', discoveryLogPanel.escapeHandler);
    }
    discoveryLogPanel.classList.remove('visible');
    setTimeout(function() {
      if (discoveryLogPanel && discoveryLogPanel.parentNode) {
        document.body.removeChild(discoveryLogPanel);
        discoveryLogPanel = null;
      }
    }, 250);
  }

  // Lore Book Panel
  var loreBookPanel = null;

  /**
   * Show the Lore Journal panel
   * @param {string} playerId - The player's ID
   * @param {object} state - Game state object containing discoveries
   */
  function showLoreJournal(playerId, state) {
    if (loreBookPanel) {
      hideLoreJournal();
      return;
    }

    // Get unlocked lore and lore categories from Exploration module
    var unlockedLore = [];
    var loreCategories = {};

    if (typeof window !== 'undefined' && window.Exploration) {
      unlockedLore = window.Exploration.getUnlockedLore(playerId, state);
      loreCategories = window.Exploration.getLoreCategories();
    }

    // Group unlocked lore by category
    var loreByCategory = {};
    unlockedLore.forEach(function(entry) {
      if (!loreByCategory[entry.category]) {
        loreByCategory[entry.category] = [];
      }
      loreByCategory[entry.category].push(entry);
    });

    // Get all lore entries from Exploration module to show locked ones
    var allLoreEntries = window.Exploration ? window.Exploration.LORE_ENTRIES : {};

    // Panel overlay
    var panel = document.createElement('div');
    panel.className = 'lore-journal-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 85%;
      max-width: 950px;
      height: 85vh;
      background: linear-gradient(135deg, #3d2817 0%, #2a1810 100%);
      border: 3px solid #8b6914;
      border-radius: 10px;
      box-shadow: 0 15px 60px rgba(0, 0, 0, 0.8), inset 0 0 40px rgba(139, 105, 20, 0.1);
      z-index: 10000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
    `;

    // Header
    var header = document.createElement('div');
    header.style.cssText = `
      background: linear-gradient(180deg, rgba(61, 40, 23, 0.9) 0%, rgba(42, 24, 16, 0.95) 100%);
      padding: 20px 30px;
      border-bottom: 2px solid #8b6914;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;

    var titleContainer = document.createElement('div');

    var title = document.createElement('h2');
    title.textContent = 'Lore Journal';
    title.style.cssText = `
      margin: 0 0 5px 0;
      color: #f4e4c1;
      font-size: 30px;
      font-family: Georgia, serif;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
    `;
    titleContainer.appendChild(title);

    // Overall completion
    var totalLore = Object.keys(allLoreEntries).length;
    var unlockedCount = unlockedLore.length;
    var completionPct = totalLore > 0 ? Math.round((unlockedCount / totalLore) * 100) : 0;

    var completion = document.createElement('div');
    completion.textContent = 'Completion: ' + unlockedCount + '/' + totalLore + ' (' + completionPct + '%)';
    completion.style.cssText = `
      color: #d4af37;
      font-size: 14px;
      font-family: Georgia, serif;
    `;
    titleContainer.appendChild(completion);

    header.appendChild(titleContainer);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\u00D7';
    closeBtn.style.cssText = `
      background: rgba(139, 69, 19, 0.6);
      border: 2px solid #8b6914;
      color: #f4e4c1;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 28px;
      font-weight: bold;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.4)';
      this.style.borderColor = '#d4af37';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 69, 19, 0.6)';
      this.style.borderColor = '#8b6914';
    };
    closeBtn.onclick = hideLoreJournal;
    header.appendChild(closeBtn);

    panel.appendChild(header);

    // Category tabs
    var tabsContainer = document.createElement('div');
    tabsContainer.style.cssText = `
      display: flex;
      gap: 5px;
      padding: 15px 20px 0 20px;
      background: rgba(42, 24, 16, 0.7);
      overflow-x: auto;
      border-bottom: 2px solid #8b6914;
    `;

    // Content area
    var contentArea = document.createElement('div');
    contentArea.style.cssText = `
      flex: 1;
      overflow-y: auto;
      padding: 25px 30px;
      background: linear-gradient(180deg, rgba(42, 24, 16, 0.8) 0%, rgba(26, 15, 10, 0.9) 100%);
    `;

    // Category tabs array
    var categories = ['origins', 'artifacts', 'landmarks', 'nature', 'mysteries', 'art', 'history'];
    var currentCategory = categories[0];

    // Function to render category content
    function renderCategory(category) {
      contentArea.innerHTML = '';

      // Category header with progress
      var categoryHeader = document.createElement('div');
      categoryHeader.style.cssText = `
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(212, 175, 55, 0.3);
      `;

      var categoryTitle = document.createElement('h3');
      categoryTitle.textContent = category.charAt(0).toUpperCase() + category.slice(1);
      categoryTitle.style.cssText = `
        margin: 0 0 8px 0;
        color: #d4af37;
        font-size: 24px;
        font-family: Georgia, serif;
        font-weight: 600;
      `;
      categoryHeader.appendChild(categoryTitle);

      // Count entries in this category
      var categoryTotal = 0;
      var categoryUnlocked = 0;
      for (var loreId in allLoreEntries) {
        if (allLoreEntries[loreId].category === category) {
          categoryTotal++;
          if (loreByCategory[category] && loreByCategory[category].some(function(e) { return e.id === loreId; })) {
            categoryUnlocked++;
          }
        }
      }

      var categoryProgress = document.createElement('div');
      categoryProgress.className = 'lore-progress';
      categoryProgress.textContent = 'Discovered: ' + categoryUnlocked + '/' + categoryTotal;
      categoryProgress.style.cssText = `
        color: #c8b896;
        font-size: 13px;
        font-family: Georgia, serif;
      `;
      categoryHeader.appendChild(categoryProgress);

      contentArea.appendChild(categoryHeader);

      // Render entries for this category
      var entriesContainer = document.createElement('div');
      entriesContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 15px;
      `;

      // Show all entries (unlocked and locked)
      for (var loreId in allLoreEntries) {
        var loreEntry = allLoreEntries[loreId];
        if (loreEntry.category !== category) continue;

        var isUnlocked = loreByCategory[category] && loreByCategory[category].some(function(e) { return e.id === loreId; });

        var entryDiv = document.createElement('div');
        entryDiv.className = isUnlocked ? 'lore-entry' : 'lore-entry lore-entry-locked';
        entryDiv.style.cssText = `
          background: ${isUnlocked ? 'rgba(212, 175, 55, 0.08)' : 'rgba(100, 80, 60, 0.15)'};
          border-left: 4px solid ${isUnlocked ? '#d4af37' : '#666'};
          padding: 18px 20px;
          border-radius: 6px;
          transition: background 0.2s ease;
          ${!isUnlocked ? 'filter: blur(0.5px); opacity: 0.6;' : ''}
        `;

        if (isUnlocked) {
          entryDiv.onmouseover = function() {
            this.style.background = 'rgba(212, 175, 55, 0.15)';
          };
          entryDiv.onmouseout = function() {
            this.style.background = 'rgba(212, 175, 55, 0.08)';
          };
        }

        var entryTitle = document.createElement('div');
        entryTitle.textContent = isUnlocked ? loreEntry.title : '???';
        entryTitle.style.cssText = `
          color: ${isUnlocked ? '#f4e4c1' : '#888'};
          font-size: 18px;
          font-weight: 600;
          margin-bottom: 10px;
          font-family: Georgia, serif;
        `;
        entryDiv.appendChild(entryTitle);

        var entryText = document.createElement('div');
        if (isUnlocked) {
          entryText.textContent = loreEntry.text;
          entryText.style.cssText = `
            color: #c8b896;
            font-size: 14px;
            line-height: 1.7;
            font-family: Georgia, serif;
          `;
        } else {
          // Show hint for locked entries
          entryText.textContent = 'Undiscovered... Explore the world to unlock this lore.';
          entryText.style.cssText = `
            color: #777;
            font-size: 13px;
            font-style: italic;
            line-height: 1.6;
            font-family: Georgia, serif;
          `;
        }
        entryDiv.appendChild(entryText);

        entriesContainer.appendChild(entryDiv);
      }

      contentArea.appendChild(entriesContainer);
    }

    // Create tabs
    categories.forEach(function(category) {
      var tab = document.createElement('button');
      tab.className = 'lore-category-tab';
      tab.textContent = category.charAt(0).toUpperCase() + category.slice(1);
      tab.style.cssText = `
        background: ${category === currentCategory ? 'rgba(212, 175, 55, 0.3)' : 'rgba(100, 80, 60, 0.2)'};
        border: 2px solid ${category === currentCategory ? '#d4af37' : '#666'};
        border-bottom: none;
        border-radius: 6px 6px 0 0;
        color: ${category === currentCategory ? '#f4e4c1' : '#a0978e'};
        padding: 10px 20px;
        font-size: 14px;
        font-family: Georgia, serif;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        font-weight: ${category === currentCategory ? '600' : '400'};
      `;

      tab.onclick = function() {
        currentCategory = category;
        // Update all tabs
        var allTabs = tabsContainer.querySelectorAll('.lore-category-tab');
        allTabs.forEach(function(t) {
          var isActive = t.textContent.toLowerCase() === category;
          t.style.background = isActive ? 'rgba(212, 175, 55, 0.3)' : 'rgba(100, 80, 60, 0.2)';
          t.style.borderColor = isActive ? '#d4af37' : '#666';
          t.style.color = isActive ? '#f4e4c1' : '#a0978e';
          t.style.fontWeight = isActive ? '600' : '400';
        });
        renderCategory(category);
      };

      tab.onmouseover = function() {
        if (this.textContent.toLowerCase() !== currentCategory) {
          this.style.background = 'rgba(139, 105, 20, 0.3)';
          this.style.color = '#d4af37';
        }
      };
      tab.onmouseout = function() {
        if (this.textContent.toLowerCase() !== currentCategory) {
          this.style.background = 'rgba(100, 80, 60, 0.2)';
          this.style.color = '#a0978e';
        }
      };

      tabsContainer.appendChild(tab);
    });

    panel.appendChild(tabsContainer);
    panel.appendChild(contentArea);

    // Render initial category
    renderCategory(currentCategory);

    document.body.appendChild(panel);
    loreBookPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideLoreJournal();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideLoreJournal() {
    if (!loreBookPanel) return;
    if (loreBookPanel.escapeHandler) {
      document.removeEventListener('keydown', loreBookPanel.escapeHandler);
    }
    loreBookPanel.classList.remove('visible');
    setTimeout(function() {
      if (loreBookPanel && loreBookPanel.parentNode) {
        document.body.removeChild(loreBookPanel);
        loreBookPanel = null;
      }
    }, 250);
  }

  function toggleLoreJournal(playerId, state) {
    if (loreBookPanel) {
      hideLoreJournal();
    } else {
      showLoreJournal(playerId, state);
    }
  }

  // Legacy compatibility - keep old function names
  function showLoreBook(playerId, state) {
    showLoreJournal(playerId, state);
  }

  function hideLoreBook() {
    hideLoreJournal();
  }

  // Achievement Toast
  function showAchievementToast(achievement) {
    if (typeof document === 'undefined') return;

    var toast = document.createElement('div');
    toast.className = 'achievement-toast';

    var icon = document.createElement('div');
    icon.className = 'achievement-toast-icon';
    icon.textContent = achievement.icon || 'â­';

    var textContainer = document.createElement('div');
    textContainer.className = 'achievement-toast-text';

    var label = document.createElement('div');
    label.className = 'achievement-toast-label';
    label.textContent = 'ACHIEVEMENT UNLOCKED';

    var achievementName = document.createElement('div');
    achievementName.className = 'achievement-toast-name';
    achievementName.textContent = achievement.name || 'Unknown Achievement';

    textContainer.appendChild(label);
    textContainer.appendChild(achievementName);

    toast.appendChild(icon);
    toast.appendChild(textContainer);
    document.body.appendChild(toast);

    // Auto-remove after animation completes (4s total: 0.4s slide + 3s stay + 0.5s fade)
    setTimeout(function() {
      if (toast.parentNode) {
        document.body.removeChild(toast);
      }
    }, 4000);
  }

  // Discovery Popup
  function showDiscoveryPopup(discovery) {
    var popup = document.createElement('div');
    popup.className = 'discovery-popup';
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #5dade2;
      border-radius: 12px;
      padding: 30px;
      min-width: 400px;
      box-shadow: 0 0 50px rgba(93, 173, 226, 0.6);
      z-index: 10001;
    `;

    var header = document.createElement('div');
    header.textContent = 'NEW DISCOVERY';
    header.style.cssText = `
      color: #ffd700;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 15px;
      font-family: system-ui, sans-serif;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    `;

    var rarityColors = {
      common: '#ffffff',
      uncommon: '#1eff00',
      rare: '#0070dd',
      epic: '#a335ee',
      legendary: '#ff8000'
    };
    var color = rarityColors[discovery.rarity] || '#ffffff';

    var discoveryName = document.createElement('div');
    discoveryName.textContent = discovery.name || 'Unknown Discovery';
    discoveryName.style.cssText = `
      color: ` + color + `;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
      font-family: system-ui, sans-serif;
      text-shadow: 0 0 10px ` + color + `;
    `;

    var discoveryDesc = document.createElement('div');
    discoveryDesc.textContent = discovery.description || '';
    discoveryDesc.style.cssText = `
      color: #e0e0e0;
      font-size: 16px;
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.5;
      font-family: system-ui, sans-serif;
    `;

    var rewardText = document.createElement('div');
    rewardText.textContent = '+ ' + (discovery.sparkReward || 0) + ' Spark';
    rewardText.style.cssText = `
      color: #ffd700;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      font-family: system-ui, sans-serif;
    `;

    popup.appendChild(header);
    popup.appendChild(discoveryName);
    popup.appendChild(discoveryDesc);
    popup.appendChild(rewardText);
    document.body.appendChild(popup);

    // Animate in
    requestAnimationFrame(function() {
      popup.classList.add('visible');
    });

    // Auto-close after 4 seconds
    setTimeout(function() {
      popup.classList.remove('visible');
      setTimeout(function() {
        if (popup.parentNode) {
          document.body.removeChild(popup);
        }
      }, 300);
    }, 4000);

    // Click to close
    popup.onclick = function() {
      popup.classList.remove('visible');
      setTimeout(function() {
        if (popup.parentNode) {
          document.body.removeChild(popup);
        }
      }, 300);
    };
  }

  // ============================================================================
  // SKILLS PANEL
  // ============================================================================

  var skillsPanel = null;

  function showSkillsPanel(skillsData) {
    if (skillsPanel) return;

    var panel = document.createElement('div');
    panel.id = 'skills-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(100, 150, 255, 0.3);
      border-radius: 12px;
      padding: 25px;
      width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 10000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.innerHTML = '<h2 style="margin: 0 0 20px 0; color: #fff; font-size: 24px;">Skills</h2>';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
    `;
    closeBtn.onclick = hideSkillsPanel;
    panel.appendChild(closeBtn);

    for (var skillName in skillsData) {
      var skill = skillsData[skillName];
      var skillDiv = document.createElement('div');
      skillDiv.style.cssText = `
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
      `;

      var skillHeader = document.createElement('div');
      skillHeader.innerHTML = `
        <span style="color: #4af; font-weight: bold; font-size: 16px;">${skillName.charAt(0).toUpperCase() + skillName.slice(1)}</span>
        <span style="color: #888; float: right;">${skill.levelName} (Level ${skill.level})</span>
      `;
      skillDiv.appendChild(skillHeader);

      var xpBar = document.createElement('div');
      xpBar.style.cssText = `
        margin-top: 8px;
        width: 100%;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      `;

      var nextLevelXP = 1000;
      var currentLevelXP = 0;
      if (typeof window !== 'undefined' && window.Mentoring && window.Mentoring.SKILLS) {
        var skillConfig = window.Mentoring.SKILLS[skillName];
        if (skillConfig && skill.level < skillConfig.xpPerLevel.length - 1) {
          nextLevelXP = skillConfig.xpPerLevel[skill.level + 1];
          currentLevelXP = skillConfig.xpPerLevel[skill.level];
        }
      }

      var xpProgress = skill.xp - currentLevelXP;
      var xpNeeded = nextLevelXP - currentLevelXP;
      var progressPercent = skill.level >= 4 ? 100 : Math.min(100, (xpProgress / xpNeeded) * 100);

      var xpFill = document.createElement('div');
      xpFill.style.cssText = `
        width: ${progressPercent}%;
        height: 100%;
        background: linear-gradient(90deg, #4af, #a8f);
        transition: width 0.3s ease;
      `;
      xpBar.appendChild(xpFill);

      var xpText = document.createElement('div');
      xpText.textContent = skill.level >= 4 ? 'MAX LEVEL' : skill.xp + ' / ' + nextLevelXP + ' XP';
      xpText.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 11px;
        font-weight: bold;
      `;
      xpBar.appendChild(xpText);

      skillDiv.appendChild(xpBar);
      panel.appendChild(skillDiv);
    }

    document.body.appendChild(panel);
    skillsPanel = panel;
  }

  function hideSkillsPanel() {
    if (!skillsPanel) return;
    document.body.removeChild(skillsPanel);
    skillsPanel = null;
  }

  // ============================================================================
  // MENTOR OFFER PANEL
  // ============================================================================

  var mentorOfferPanel = null;

  function showMentorOffer(offerData, acceptCallback, declineCallback) {
    if (mentorOfferPanel) return;

    var panel = document.createElement('div');
    panel.id = 'mentor-offer-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(255, 200, 100, 0.5);
      border-radius: 12px;
      padding: 25px;
      width: 400px;
      z-index: 10001;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      text-align: center;
      pointer-events: auto;
    `;

    panel.innerHTML = `
      <h3 style="color: #ffa500; margin: 0 0 15px 0;">Mentorship Offer</h3>
      <p style="color: #fff; margin-bottom: 10px;">
        <strong>${offerData.mentorId}</strong> wants to mentor you in <strong>${offerData.skill}</strong>
      </p>
      <p style="color: #888; font-size: 13px; margin-bottom: 20px;">
        Complete 5 lesson steps to gain XP and unlock advanced techniques.
      </p>
    `;

    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center;';

    var acceptBtn = document.createElement('button');
    acceptBtn.textContent = 'Accept';
    acceptBtn.style.cssText = `
      padding: 10px 24px;
      background: linear-gradient(135deg, #4af, #a8f);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    `;
    acceptBtn.onclick = function() {
      acceptCallback(offerData.id);
      document.body.removeChild(mentorOfferPanel);
      mentorOfferPanel = null;
    };

    var declineBtn = document.createElement('button');
    declineBtn.textContent = 'Decline';
    declineBtn.style.cssText = `
      padding: 10px 24px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      cursor: pointer;
    `;
    declineBtn.onclick = function() {
      declineCallback(offerData.id);
      document.body.removeChild(mentorOfferPanel);
      mentorOfferPanel = null;
    };

    buttonContainer.appendChild(acceptBtn);
    buttonContainer.appendChild(declineBtn);
    panel.appendChild(buttonContainer);

    document.body.appendChild(panel);
    mentorOfferPanel = panel;
  }

  // ============================================================================
  // LESSON PROGRESS PANEL
  // ============================================================================

  var lessonProgressPanel = null;

  function showLessonProgress(mentorshipData) {
    if (lessonProgressPanel) {
      document.body.removeChild(lessonProgressPanel);
      lessonProgressPanel = null;
    }

    var panel = document.createElement('div');
    panel.id = 'lesson-progress-panel';
    panel.style.cssText = `
      position: fixed;
      top: 120px;
      right: 20px;
      background: rgba(20, 25, 35, 0.95);
      border: 2px solid rgba(255, 200, 100, 0.5);
      border-radius: 8px;
      padding: 15px;
      width: 300px;
      z-index: 9999;
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var progress = mentorshipData.stepsCompleted / mentorshipData.totalSteps;
    var progressPercent = Math.round(progress * 100);

    panel.innerHTML = `
      <h4 style="color: #ffa500; margin: 0 0 10px 0; font-size: 14px;">Mentorship Progress</h4>
      <p style="color: #fff; font-size: 13px; margin: 5px 0;">
        <strong>${mentorshipData.skill}</strong>
      </p>
      <p style="color: #888; font-size: 12px; margin: 5px 0;">
        Steps: ${mentorshipData.stepsCompleted} / ${mentorshipData.totalSteps}
      </p>
      <div style="width: 100%; height: 16px; background: rgba(0,0,0,0.5); border-radius: 8px; overflow: hidden; margin-top: 8px;">
        <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg, #ffa500, #ffcc00);"></div>
      </div>
    `;

    document.body.appendChild(panel);
    lessonProgressPanel = panel;
  }

  // ============================================================================
  // COMPOSE PANEL - Music Composition System
  // ============================================================================

  var composePanel = null;
  var audioContext = null;
  var recordedNotes = [];
  var isRecording = false;
  var recordingStartTime = 0;
  var currentInstrument = 'sine';

  // Note frequency map for C4 to C6 (2 octaves + middle C)
  var noteFrequencies = {
    'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
    'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
    'C6': 1046.50
  };

  var noteOrder = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5', 'C6'];

  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContext;
  }

  function playNote(noteName, duration) {
    var ctx = initAudioContext();
    var frequency = noteFrequencies[noteName];
    if (!frequency) return;

    var oscillator = ctx.createOscillator();
    var gainNode = ctx.createGain();

    oscillator.type = currentInstrument;
    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + (duration || 0.5));

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + (duration || 0.5));
  }

  function playComposition(notes) {
    if (!notes || notes.length === 0) {
      showNotification('No notes to play', 'warning');
      return;
    }

    var ctx = initAudioContext();
    var currentTime = ctx.currentTime;

    notes.forEach(function(note) {
      var startTime = currentTime + (note.time / 1000);
      var frequency = noteFrequencies[note.note];
      if (!frequency) return;

      var oscillator = ctx.createOscillator();
      var gainNode = ctx.createGain();

      oscillator.type = note.instrument || 'sine';
      oscillator.frequency.setValueAtTime(frequency, startTime);

      gainNode.gain.setValueAtTime(0.3, startTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.5);

      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);

      oscillator.start(startTime);
      oscillator.stop(startTime + 0.5);
    });
  }

  function showComposePanel(composeCallback) {
    if (composePanel) return;

    var panel = document.createElement('div');
    panel.id = 'compose-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(30, 35, 45, 0.98));
      border: 2px solid rgba(212, 175, 55, 0.7);
      border-radius: 12px;
      padding: 25px;
      width: 800px;
      z-index: 10000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      font-family: system-ui, sans-serif;
      pointer-events: auto;
    `;

    var header = document.createElement('div');
    header.innerHTML = '<h2 style="margin: 0 0 20px 0; color: #d4af37; font-size: 24px;">Compose Music</h2>';
    panel.appendChild(header);

    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(212, 175, 55, 0.2);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.5);
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    `;
    closeBtn.onclick = hideComposePanel;
    panel.appendChild(closeBtn);

    var form = document.createElement('div');

    // Instrument selector
    var instrumentLabel = document.createElement('label');
    instrumentLabel.textContent = 'Instrument:';
    instrumentLabel.style.cssText = 'display: block; color: #d4af37; margin-bottom: 5px; font-size: 14px; font-weight: bold;';
    form.appendChild(instrumentLabel);

    var instrumentSelect = document.createElement('select');
    instrumentSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      margin-bottom: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    `;

    var instruments = [
      { value: 'sine', label: 'Flute (Sine)' },
      { value: 'triangle', label: 'Soft Tone (Triangle)' },
      { value: 'square', label: 'Reed (Square)' },
      { value: 'sawtooth', label: 'Strings (Sawtooth)' }
    ];

    instruments.forEach(function(inst) {
      var option = document.createElement('option');
      option.value = inst.value;
      option.textContent = inst.label;
      instrumentSelect.appendChild(option);
    });

    instrumentSelect.onchange = function() {
      currentInstrument = instrumentSelect.value;
    };
    form.appendChild(instrumentSelect);

    // Piano keyboard
    var keyboardContainer = document.createElement('div');
    keyboardContainer.style.cssText = `
      display: flex;
      justify-content: center;
      gap: 4px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      flex-wrap: wrap;
    `;

    noteOrder.forEach(function(noteName) {
      var key = document.createElement('button');
      var isBlackKey = noteName.includes('C') || noteName.includes('F');

      key.textContent = noteName;
      key.style.cssText = `
        padding: 40px 12px;
        background: ${isBlackKey ? 'linear-gradient(135deg, #d4af37, #f4d03f)' : 'linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(230, 230, 230, 0.9))'};
        color: ${isBlackKey ? '#000' : '#333'};
        border: 2px solid ${isBlackKey ? '#d4af37' : '#999'};
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 12px;
        min-width: 45px;
        transition: all 0.1s;
      `;

      key.onmousedown = function() {
        key.style.transform = 'scale(0.95)';
        key.style.boxShadow = '0 0 10px rgba(212, 175, 55, 0.8)';
        playNote(noteName, 0.5);

        if (isRecording) {
          var currentTime = Date.now() - recordingStartTime;
          recordedNotes.push({
            note: noteName,
            time: currentTime,
            instrument: currentInstrument
          });
          updateNoteDisplay();
        }
      };

      key.onmouseup = function() {
        key.style.transform = 'scale(1)';
        key.style.boxShadow = 'none';
      };

      key.onmouseleave = function() {
        key.style.transform = 'scale(1)';
        key.style.boxShadow = 'none';
      };

      keyboardContainer.appendChild(key);
    });

    form.appendChild(keyboardContainer);

    // Control buttons
    var controlsContainer = document.createElement('div');
    controlsContainer.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    `;

    var recordBtn = document.createElement('button');
    recordBtn.textContent = 'Record';
    recordBtn.id = 'record-btn';
    recordBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #ff4444, #cc0000);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    recordBtn.onclick = function() {
      if (!isRecording) {
        isRecording = true;
        recordedNotes = [];
        recordingStartTime = Date.now();
        recordBtn.textContent = 'Stop Recording';
        recordBtn.style.background = 'linear-gradient(135deg, #ff8844, #ff4400)';
        showNotification('Recording started...', 'info');
      } else {
        isRecording = false;
        recordBtn.textContent = 'Record';
        recordBtn.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
        showNotification('Recording stopped. ' + recordedNotes.length + ' notes captured.', 'success');
      }
    };
    controlsContainer.appendChild(recordBtn);

    var playbackBtn = document.createElement('button');
    playbackBtn.textContent = 'Playback';
    playbackBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #44ff44, #00cc00);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    playbackBtn.onclick = function() {
      if (recordedNotes.length === 0) {
        showNotification('No notes recorded yet', 'warning');
        return;
      }
      playComposition(recordedNotes);
      showNotification('Playing composition...', 'info');
    };
    controlsContainer.appendChild(playbackBtn);

    var clearBtn = document.createElement('button');
    clearBtn.textContent = 'Clear';
    clearBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: linear-gradient(135deg, #ff9944, #cc6600);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    `;
    clearBtn.onclick = function() {
      recordedNotes = [];
      isRecording = false;
      var recordButton = document.getElementById('record-btn');
      if (recordButton) {
        recordButton.textContent = 'Record';
        recordButton.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
      }
      updateNoteDisplay();
      showNotification('Composition cleared', 'info');
    };
    controlsContainer.appendChild(clearBtn);

    form.appendChild(controlsContainer);

    // Note display
    var noteDisplayLabel = document.createElement('label');
    noteDisplayLabel.textContent = 'Composition:';
    noteDisplayLabel.style.cssText = 'display: block; color: #d4af37; margin-bottom: 5px; font-size: 14px; font-weight: bold;';
    form.appendChild(noteDisplayLabel);

    var noteDisplay = document.createElement('div');
    noteDisplay.id = 'note-display';
    noteDisplay.style.cssText = `
      width: 100%;
      min-height: 60px;
      padding: 15px;
      margin-bottom: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: #d4af37;
      border: 1px solid rgba(212, 175, 55, 0.3);
      border-radius: 6px;
      font-size: 14px;
      font-family: monospace;
      overflow-x: auto;
      white-space: nowrap;
    `;
    noteDisplay.textContent = 'No notes recorded yet...';
    form.appendChild(noteDisplay);

    function updateNoteDisplay() {
      var display = document.getElementById('note-display');
      if (!display) return;

      if (recordedNotes.length === 0) {
        display.textContent = 'No notes recorded yet...';
        return;
      }

      var noteSequence = recordedNotes.map(function(n) {
        return n.note;
      }).join(' - ');

      display.textContent = noteSequence + ' (' + recordedNotes.length + ' notes)';
    }

    // Save button
    var saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save Composition';
    saveBtn.style.cssText = `
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #d4af37, #f4d03f);
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
    `;
    saveBtn.onclick = function() {
      if (recordedNotes.length === 0) {
        showNotification('Please record some notes first', 'warning');
        return;
      }

      if (isRecording) {
        showNotification('Please stop recording first', 'warning');
        return;
      }

      var composition = {
        notes: recordedNotes,
        instrument: currentInstrument,
        timestamp: Date.now()
      };

      if (composeCallback) {
        composeCallback(composition);
      }

      showNotification('Composition saved!', 'success');
      hideComposePanel();
    };
    form.appendChild(saveBtn);

    panel.appendChild(form);
    document.body.appendChild(panel);
    composePanel = panel;

    // Reset state
    recordedNotes = [];
    isRecording = false;
    currentInstrument = 'sine';
  }

  function hideComposePanel() {
    if (!composePanel) return;
    document.body.removeChild(composePanel);
    composePanel = null;
    recordedNotes = [];
    isRecording = false;
  }

  // Guild Panel
  var guildPanel = null;
  var guildCreatePanel = null;
  var guildInvitePanel = null;

  function showGuildPanel(guildData, playerData) {
    if (guildPanel) {
      hideGuildPanel();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'guild-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 700px;
      max-height: 80vh;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      overflow-y: auto;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideGuildPanel;
    panel.appendChild(closeBtn);

    // Header
    var header = document.createElement('div');
    header.style.cssText = `
      margin-bottom: 25px;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;

    var title = document.createElement('h2');
    title.textContent = '[' + guildData.tag + '] ' + guildData.name;
    title.style.cssText = `
      color: #DAA520;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      margin: 0 0 8px 0;
      font-weight: bold;
    `;
    header.appendChild(title);

    var subtitle = document.createElement('div');
    subtitle.textContent = guildData.type.charAt(0).toUpperCase() + guildData.type.slice(1) +
                          ' â€¢ Level ' + guildData.level + ' â€¢ ' + guildData.members.length + '/' +
                          guildData.maxMembers + ' members';
    subtitle.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    header.appendChild(subtitle);

    if (guildData.description) {
      var desc = document.createElement('div');
      desc.textContent = guildData.description;
      desc.style.cssText = `
        color: #D4C5B3;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        margin-top: 12px;
        font-style: italic;
      `;
      header.appendChild(desc);
    }

    panel.appendChild(header);

    // Stats section
    var statsGrid = document.createElement('div');
    statsGrid.style.cssText = `
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 25px;
    `;

    var stats = [
      { label: 'Treasury', value: guildData.treasury + ' Spark' },
      { label: 'Guild XP', value: guildData.xp },
      { label: 'Home Zone', value: guildData.zone }
    ];

    stats.forEach(function(stat) {
      var statBox = document.createElement('div');
      statBox.style.cssText = `
        background: rgba(218, 165, 32, 0.1);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 12px;
        text-align: center;
      `;

      var statLabel = document.createElement('div');
      statLabel.textContent = stat.label;
      statLabel.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
        margin-bottom: 5px;
      `;
      statBox.appendChild(statLabel);

      var statValue = document.createElement('div');
      statValue.textContent = stat.value;
      statValue.style.cssText = `
        color: #DAA520;
        font-size: 18px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
      `;
      statBox.appendChild(statValue);

      statsGrid.appendChild(statBox);
    });

    panel.appendChild(statsGrid);

    // Members section
    var membersSection = document.createElement('div');
    membersSection.style.cssText = `
      margin-bottom: 25px;
    `;

    var membersTitle = document.createElement('h3');
    membersTitle.textContent = 'Members';
    membersTitle.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    membersSection.appendChild(membersTitle);

    var membersList = document.createElement('div');
    membersList.style.cssText = `
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 10px;
    `;

    guildData.members.forEach(function(member) {
      var memberItem = document.createElement('div');
      memberItem.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        margin-bottom: 5px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
      `;

      var memberInfo = document.createElement('div');
      memberInfo.style.cssText = `
        color: #E8E0D8;
        font-size: 14px;
        font-family: system-ui, sans-serif;
      `;
      memberInfo.textContent = member.playerId + (member.playerId === playerData.id ? ' (You)' : '');
      memberItem.appendChild(memberInfo);

      var roleTag = document.createElement('span');
      roleTag.textContent = member.role.toUpperCase();
      roleTag.style.cssText = `
        color: ${member.role === 'leader' ? '#FFD700' : member.role === 'officer' ? '#C0C0C0' : '#8B7355'};
        font-size: 11px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        padding: 3px 8px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 3px;
      `;
      memberItem.appendChild(roleTag);

      membersList.appendChild(memberItem);
    });

    membersSection.appendChild(membersList);
    panel.appendChild(membersSection);

    // Activities section
    var activitiesSection = document.createElement('div');
    activitiesSection.style.cssText = `
      margin-bottom: 15px;
    `;

    var activitiesTitle = document.createElement('h3');
    activitiesTitle.textContent = 'Recent Activity';
    activitiesTitle.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    activitiesSection.appendChild(activitiesTitle);

    var activitiesList = document.createElement('div');
    activitiesList.style.cssText = `
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 10px;
    `;

    var activities = guildData.activities.slice(-10).reverse();
    activities.forEach(function(activity) {
      var activityItem = document.createElement('div');
      activityItem.textContent = 'â€¢ ' + activity.text;
      activityItem.style.cssText = `
        color: #A0978E;
        font-size: 13px;
        font-family: system-ui, sans-serif;
        padding: 4px 0;
        line-height: 1.4;
      `;
      activitiesList.appendChild(activityItem);
    });

    if (activities.length === 0) {
      var noActivity = document.createElement('div');
      noActivity.textContent = 'No recent activity';
      noActivity.style.cssText = `
        color: #6B6B6B;
        font-size: 13px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 20px;
      `;
      activitiesList.appendChild(noActivity);
    }

    activitiesSection.appendChild(activitiesList);
    panel.appendChild(activitiesSection);

    // Action buttons
    var actionsDiv = document.createElement('div');
    actionsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-top: 20px;
    `;

    var leaveBtn = document.createElement('button');
    leaveBtn.textContent = 'Leave Guild';
    leaveBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: rgba(139, 0, 0, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(255, 69, 0, 0.5);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    leaveBtn.onmouseover = function() {
      this.style.background = 'rgba(139, 0, 0, 0.8)';
      this.style.borderColor = '#FF4500';
    };
    leaveBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 0, 0, 0.6)';
      this.style.borderColor = 'rgba(255, 69, 0, 0.5)';
    };
    leaveBtn.onclick = function() {
      if (confirm('Are you sure you want to leave the guild?')) {
        if (window.handleGuildAction) {
          window.handleGuildAction('leave', guildData.id);
        }
        hideGuildPanel();
      }
    };
    actionsDiv.appendChild(leaveBtn);

    panel.appendChild(actionsDiv);

    document.body.appendChild(panel);
    guildPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });
  }

  function hideGuildPanel() {
    if (!guildPanel) return;
    guildPanel.classList.remove('visible');
    setTimeout(function() {
      if (guildPanel && guildPanel.parentNode) {
        document.body.removeChild(guildPanel);
        guildPanel = null;
      }
    }, 250);
  }

  function showGuildCreate(callback) {
    if (guildCreatePanel) {
      hideGuildCreate();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'guild-create-panel';
    panel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideGuildCreate;
    panel.appendChild(closeBtn);

    // Title
    var title = document.createElement('h2');
    title.textContent = 'Create Guild';
    title.style.cssText = `
      color: #DAA520;
      font-size: 24px;
      font-family: system-ui, sans-serif;
      margin: 0 0 20px 0;
      font-weight: bold;
    `;
    panel.appendChild(title);

    // Form
    var form = document.createElement('div');
    form.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 15px;
    `;

    // Guild name input
    var nameLabel = document.createElement('label');
    nameLabel.textContent = 'Guild Name';
    nameLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(nameLabel);

    var nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Enter guild name';
    nameInput.maxLength = 30;
    nameInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    form.appendChild(nameInput);

    // Guild tag input
    var tagLabel = document.createElement('label');
    tagLabel.textContent = 'Guild Tag (3-5 characters)';
    tagLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(tagLabel);

    var tagInput = document.createElement('input');
    tagInput.type = 'text';
    tagInput.placeholder = 'e.g., ZON';
    tagInput.maxLength = 5;
    tagInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      text-transform: uppercase;
    `;
    form.appendChild(tagInput);

    // Guild type select
    var typeLabel = document.createElement('label');
    typeLabel.textContent = 'Type';
    typeLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(typeLabel);

    var typeSelect = document.createElement('select');
    typeSelect.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;

    ['guild', 'garden', 'studio', 'community'].forEach(function(type) {
      var option = document.createElement('option');
      option.value = type;
      option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
      typeSelect.appendChild(option);
    });

    form.appendChild(typeSelect);

    // Description textarea
    var descLabel = document.createElement('label');
    descLabel.textContent = 'Description (optional)';
    descLabel.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
    `;
    form.appendChild(descLabel);

    var descInput = document.createElement('textarea');
    descInput.placeholder = 'Describe your guild...';
    descInput.maxLength = 200;
    descInput.rows = 3;
    descInput.style.cssText = `
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(218, 165, 32, 0.3);
      border-radius: 6px;
      color: #E8E0D8;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      resize: vertical;
    `;
    form.appendChild(descInput);

    // Cost notice
    var costNotice = document.createElement('div');
    costNotice.textContent = 'Cost: 100 Spark';
    costNotice.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      text-align: center;
      padding: 10px;
      background: rgba(218, 165, 32, 0.1);
      border-radius: 6px;
    `;
    form.appendChild(costNotice);

    // Create button
    var createBtn = document.createElement('button');
    createBtn.textContent = 'Create Guild';
    createBtn.style.cssText = `
      padding: 12px;
      background: rgba(218, 165, 32, 0.3);
      color: #E8E0D8;
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 6px;
      font-size: 16px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    createBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.5)';
      this.style.borderColor = '#DAA520';
    };
    createBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = 'rgba(218, 165, 32, 0.5)';
    };
    createBtn.onclick = function() {
      var name = nameInput.value.trim();
      var tag = tagInput.value.trim().toUpperCase();
      var type = typeSelect.value;
      var description = descInput.value.trim();

      if (!name || !tag) {
        alert('Please enter guild name and tag');
        return;
      }

      if (tag.length < 3 || tag.length > 5) {
        alert('Tag must be 3-5 characters');
        return;
      }

      if (callback) {
        callback({ name: name, tag: tag, type: type, description: description });
      }

      hideGuildCreate();
    };
    form.appendChild(createBtn);

    panel.appendChild(form);

    document.body.appendChild(panel);
    guildCreatePanel = panel;
  }

  function hideGuildCreate() {
    if (!guildCreatePanel) return;
    document.body.removeChild(guildCreatePanel);
    guildCreatePanel = null;
  }

  function showGuildInvite(inviteData, callback) {
    if (guildInvitePanel) return;

    var panel = document.createElement('div');
    panel.id = 'guild-invite-panel';
    panel.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      width: 350px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 400;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 20px;
    `;

    // Title
    var title = document.createElement('h3');
    title.textContent = 'Guild Invitation';
    title.style.cssText = `
      color: #DAA520;
      font-size: 18px;
      font-family: system-ui, sans-serif;
      margin: 0 0 12px 0;
      font-weight: bold;
    `;
    panel.appendChild(title);

    // Message
    var message = document.createElement('div');
    message.textContent = 'You have been invited to join [' + inviteData.guildTag + '] ' + inviteData.guildName;
    message.style.cssText = `
      color: #D4C5B3;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
      line-height: 1.5;
    `;
    panel.appendChild(message);

    // Buttons
    var buttonsDiv = document.createElement('div');
    buttonsDiv.style.cssText = `
      display: flex;
      gap: 10px;
    `;

    var acceptBtn = document.createElement('button');
    acceptBtn.textContent = 'Accept';
    acceptBtn.style.cssText = `
      flex: 1;
      padding: 10px;
      background: rgba(34, 139, 34, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(34, 139, 34, 0.8);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    acceptBtn.onmouseover = function() {
      this.style.background = 'rgba(34, 139, 34, 0.8)';
    };
    acceptBtn.onmouseout = function() {
      this.style.background = 'rgba(34, 139, 34, 0.6)';
    };
    acceptBtn.onclick = function() {
      if (callback) {
        callback('accept', inviteData);
      }
      document.body.removeChild(panel);
      guildInvitePanel = null;
    };
    buttonsDiv.appendChild(acceptBtn);

    var declineBtn = document.createElement('button');
    declineBtn.textContent = 'Decline';
    declineBtn.style.cssText = `
      flex: 1;
      padding: 10px;
      background: rgba(139, 0, 0, 0.6);
      color: #E8E0D8;
      border: 2px solid rgba(255, 69, 0, 0.5);
      border-radius: 6px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    declineBtn.onmouseover = function() {
      this.style.background = 'rgba(139, 0, 0, 0.8)';
    };
    declineBtn.onmouseout = function() {
      this.style.background = 'rgba(139, 0, 0, 0.6)';
    };
    declineBtn.onclick = function() {
      if (callback) {
        callback('decline', inviteData);
      }
      document.body.removeChild(panel);
      guildInvitePanel = null;
    };
    buttonsDiv.appendChild(declineBtn);

    panel.appendChild(buttonsDiv);

    document.body.appendChild(panel);
    guildInvitePanel = panel;
  }

  function updateGuildTag(tag) {
    var playerNameEl = document.getElementById('player-name');
    if (playerNameEl && tag) {
      var currentName = playerNameEl.textContent;
      // Remove existing tag if present
      currentName = currentName.replace(/\[.*?\]\s*/, '');
      playerNameEl.textContent = '[' + tag + '] ' + currentName;
    }
  }

  // ========================================================================
  // GOVERNANCE PANEL (Zone Stewards & Elections)
  // ========================================================================

  var governancePanel = null;
  var governanceVisible = false;
  var governanceCallback = null;

  function initGovernancePanel(callback) {
    if (typeof document === 'undefined') return;
    governanceCallback = callback;
  }

  function showGovernancePanel(zoneId, playerData) {
    if (typeof document === 'undefined') return;

    var Social = typeof window !== 'undefined' ? window.Social : null;
    var Zones = typeof window !== 'undefined' ? window.Zones : null;
    if (!Social || !Zones) return;

    hideGovernancePanel();

    governancePanel = document.createElement('div');
    governancePanel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #daa520;border-radius:12px;' +
      'padding:20px;width:700px;max-height:80vh;overflow-y:auto;z-index:300;' +
      'box-shadow:0 4px 30px rgba(218,165,32,0.3);pointer-events:auto;';

    var zone = Zones.getZone(zoneId);
    var stewards = Zones.getZoneStewards(zoneId);
    var policies = Zones.getZonePolicies(zoneId);
    var activeElection = Zones.getActiveElection(zoneId);
    var reputation = Social.getReputation(playerData.id);
    var isRegular = Zones.isZoneRegular(zoneId, playerData.id);
    var isSteward = Zones.isZoneSteward(zoneId, playerData.id);

    var html = '<div style="font-size:24px;font-weight:bold;margin-bottom:10px;text-align:center;color:#daa520;">' +
      zone.name + ' Governance</div>';

    html += '<div style="margin-bottom:15px;color:#b0e0e6;text-align:center;font-size:12px;">' +
      'Your Reputation: ' + reputation.tier + ' (' + reputation.score + ' points)</div>';

    // Stewards section
    html += '<div style="margin-bottom:20px;">';
    html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#4af;border-bottom:1px solid #4af;padding-bottom:4px;">Current Stewards</div>';
    if (stewards.length > 0) {
      html += '<div style="display:flex;flex-direction:column;gap:8px;">';
      stewards.forEach(function(s) {
        var daysLeft = Math.ceil((s.termEnd - Date.now()) / 86400000);
        html += '<div style="background:rgba(74,170,255,0.1);padding:10px;border-radius:6px;border-left:3px solid #4af;">' +
          '<div style="font-weight:bold;">' + s.playerId + '</div>' +
          '<div style="font-size:11px;color:#aaa;">' + s.votes + ' votes â€¢ ' + daysLeft + ' days remaining</div>' +
          '</div>';
      });
      html += '</div>';
    } else {
      html += '<div style="color:#888;font-style:italic;padding:10px;">No active stewards. Start an election!</div>';
    }
    html += '</div>';

    // Zone Policies section
    if (isSteward) {
      html += '<div style="margin-bottom:20px;">';
      html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#fa4;border-bottom:1px solid #fa4;padding-bottom:4px;">Zone Policies (Steward)</div>';
      html += '<div style="background:rgba(255,170,68,0.1);padding:12px;border-radius:6px;">';
      html += '<label style="display:block;margin-bottom:8px;cursor:pointer;">' +
        '<input type="checkbox" id="policy-building" ' + (policies.buildingRequiresApproval ? 'checked' : '') + '> Building requires approval</label>';
      html += '<label style="display:block;margin-bottom:8px;cursor:pointer;">' +
        '<input type="checkbox" id="policy-moderated" ' + (policies.chatModerated ? 'checked' : '') + '> Chat moderated</label>';
      html += '<div style="margin-top:10px;"><input type="text" id="welcome-message" placeholder="Zone welcome message..." ' +
        'value="' + (policies.welcomeMessage || '').replace(/"/g, '&quot;') + '" style="width:100%;padding:8px;background:rgba(0,0,0,0.3);' +
        'border:1px solid #666;border-radius:4px;color:#fff;"></div>';
      html += '<button id="save-policies-btn" style="margin-top:10px;padding:8px 16px;background:#fa4;border:none;' +
        'border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Save Policies</button>';
      html += '</div>';
      html += '</div>';
    } else if (policies.welcomeMessage) {
      html += '<div style="margin-bottom:20px;padding:12px;background:rgba(218,165,32,0.1);border-radius:6px;border-left:3px solid #daa520;">';
      html += '<div style="font-size:14px;font-weight:bold;color:#daa520;margin-bottom:4px;">Welcome Message</div>';
      html += '<div style="font-size:12px;color:#ccc;">' + policies.welcomeMessage + '</div>';
      html += '</div>';
    }

    // Election section
    html += '<div style="margin-bottom:20px;">';
    html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#4af;border-bottom:1px solid #4af;padding-bottom:4px;">Elections</div>';
    if (activeElection) {
      var timeLeft = Math.ceil((activeElection.endTime - Date.now()) / 3600000);
      html += '<div style="background:rgba(74,170,255,0.1);padding:12px;border-radius:6px;margin-bottom:10px;">';
      html += '<div style="font-weight:bold;margin-bottom:8px;">Active Election (' + timeLeft + ' hours left)</div>';
      html += '<div style="display:flex;flex-direction:column;gap:6px;">';
      activeElection.candidates.forEach(function(c) {
        var hasVoted = isRegular && c.voters && c.voters.has(playerData.id);
        html += '<div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:4px;display:flex;justify-content:space-between;align-items:center;">' +
          '<span>' + c.playerId + '</span>' +
          '<span style="color:#4af;font-weight:bold;">' + c.votes + ' votes</span>' +
          (isRegular && !hasVoted ? '<button class="vote-btn" data-candidate="' + c.playerId + '" data-election="' + activeElection.id + '" ' +
          'style="padding:4px 12px;background:#4af;border:none;border-radius:4px;color:#000;cursor:pointer;font-size:11px;">Vote</button>' : '') +
          (hasVoted ? '<span style="color:#4a4;font-size:11px;">Voted</span>' : '') +
          '</div>';
      });
      html += '</div></div>';

      if (isRegular) {
        html += '<div style="font-size:11px;color:#aaa;margin-top:8px;">You can vote as a zone regular.</div>';
      } else {
        html += '<div style="font-size:11px;color:#888;margin-top:8px;">Visit this zone 5+ times to vote in elections.</div>';
      }
    } else {
      var canRunForSteward = reputation.tier === 'Respected' || reputation.tier === 'Honored' || reputation.tier === 'Elder';
      html += '<div style="color:#888;font-style:italic;margin-bottom:10px;">No active election.</div>';
      if (canRunForSteward) {
        html += '<button id="start-election-btn" style="padding:8px 16px;background:#4af;border:none;' +
          'border-radius:4px;color:#000;font-weight:bold;cursor:pointer;">Start Election</button>';
      } else {
        html += '<div style="font-size:11px;color:#888;">Reach Respected tier to run for steward.</div>';
      }
    }
    html += '</div>';

    // Governance Log section
    var log = Zones.getGovernanceLog(zoneId, 10);
    if (log.length > 0) {
      html += '<div style="margin-bottom:20px;">';
      html += '<div style="font-size:16px;font-weight:bold;margin-bottom:8px;color:#888;border-bottom:1px solid #666;padding-bottom:4px;">Recent Actions</div>';
      html += '<div style="display:flex;flex-direction:column;gap:4px;max-height:150px;overflow-y:auto;">';
      log.forEach(function(action) {
        var timeAgo = Math.floor((Date.now() - action.timestamp) / 60000);
        html += '<div style="font-size:11px;color:#aaa;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.05);">' +
          '<span style="color:#4af;">' + action.type + '</span> by ' + (action.stewardId || action.from || 'system') + ' â€” ' + timeAgo + 'm ago</div>';
      });
      html += '</div></div>';
    }

    // Close button
    html += '<div style="text-align:center;margin-top:20px;">' +
      '<button id="close-governance-btn" style="padding:10px 24px;background:#666;border:none;' +
      'border-radius:6px;color:#fff;font-weight:bold;cursor:pointer;">Close (H)</button></div>';

    governancePanel.innerHTML = html;
    governancePanel.className = 'governance-panel';
    document.body.appendChild(governancePanel);
    governanceVisible = true;
    requestAnimationFrame(function() {
      governancePanel.classList.add('visible');
    });

    // Attach event listeners
    var closeBtn = document.getElementById('close-governance-btn');
    if (closeBtn) {
      closeBtn.onclick = hideGovernancePanel;
    }

    var startElectionBtn = document.getElementById('start-election-btn');
    if (startElectionBtn) {
      startElectionBtn.onclick = function() {
        if (governanceCallback) {
          governanceCallback('startElection', { zoneId: zoneId });
        }
      };
    }

    var savePoliciesBtn = document.getElementById('save-policies-btn');
    if (savePoliciesBtn) {
      savePoliciesBtn.onclick = function() {
        var buildingApproval = document.getElementById('policy-building').checked;
        var chatModerated = document.getElementById('policy-moderated').checked;
        var welcomeMsg = document.getElementById('welcome-message').value;

        if (governanceCallback) {
          governanceCallback('savePolicies', {
            zoneId: zoneId,
            buildingRequiresApproval: buildingApproval,
            chatModerated: chatModerated,
            welcomeMessage: welcomeMsg
          });
        }
      };
    }

    var voteButtons = document.querySelectorAll('.vote-btn');
    voteButtons.forEach(function(btn) {
      btn.onclick = function() {
        var candidateId = btn.getAttribute('data-candidate');
        var electionId = btn.getAttribute('data-election');
        if (governanceCallback) {
          governanceCallback('vote', {
            electionId: electionId,
            candidateId: candidateId
          });
        }
      };
    });
  }

  function hideGovernancePanel() {
    if (governancePanel) {
      governancePanel.classList.remove('visible');
      setTimeout(function() {
        if (governancePanel && governancePanel.parentNode) {
          document.body.removeChild(governancePanel);
          governancePanel = null;
        }
      }, 250);
    }
    governanceVisible = false;
  }

  function toggleGovernancePanel(zoneId, playerData) {
    if (governanceVisible) {
      hideGovernancePanel();
    } else {
      showGovernancePanel(zoneId, playerData);
    }
  }

  // ========================================================================
  // AUCTION HOUSE PANEL
  // ========================================================================

  var auctionHousePanel = null;
  var auctionHouseVisible = false;
  var auctionHouseCallback = null;
  var currentAuctionTab = 'browse';

  function initAuctionHousePanel(callback) {
    auctionHouseCallback = callback;
  }

  function showAuctionHousePanel(ledger, playerId, inventory) {
    if (typeof document === 'undefined') return;

    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Economy || !Inventory) return;

    hideAuctionHousePanel();

    auctionHousePanel = document.createElement('div');
    auctionHousePanel.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 800px;
      max-height: 80vh;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid rgba(218, 165, 32, 0.5);
      border-radius: 8px;
      z-index: 300;
      overflow-y: auto;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      padding: 25px;
    `;

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(255, 255, 255, 0.1);
      color: #E8E0D8;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    `;
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.3)';
      this.style.borderColor = '#DAA520';
      this.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255, 255, 255, 0.1)';
      this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      this.style.color = '#E8E0D8';
    };
    closeBtn.onclick = hideAuctionHousePanel;
    auctionHousePanel.appendChild(closeBtn);

    // Header
    var header = document.createElement('div');
    header.style.cssText = `
      margin-bottom: 20px;
      border-bottom: 2px solid rgba(218, 165, 32, 0.3);
      padding-bottom: 15px;
    `;

    var title = document.createElement('h2');
    title.textContent = 'Auction House';
    title.style.cssText = `
      color: #DAA520;
      font-size: 28px;
      font-family: system-ui, sans-serif;
      margin: 0 0 8px 0;
      font-weight: bold;
    `;
    header.appendChild(title);

    var subtitle = document.createElement('div');
    var playerBalance = Economy.getBalance(ledger, playerId);
    subtitle.textContent = 'Your Spark: ' + playerBalance;
    subtitle.style.cssText = `
      color: #A0978E;
      font-size: 14px;
      font-family: system-ui, sans-serif;
    `;
    header.appendChild(subtitle);

    auctionHousePanel.appendChild(header);

    // Tab buttons
    var tabsDiv = document.createElement('div');
    tabsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    `;

    var tabs = ['browse', 'myauctions', 'create'];
    var tabLabels = { browse: 'Browse Auctions', myauctions: 'My Auctions', create: 'Create Auction' };

    tabs.forEach(function(tabName) {
      var tabBtn = document.createElement('button');
      tabBtn.textContent = tabLabels[tabName];
      tabBtn.setAttribute('data-tab', tabName);
      tabBtn.style.cssText = `
        flex: 1;
        padding: 12px;
        background: ${currentAuctionTab === tabName ? 'rgba(218, 165, 32, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
        color: ${currentAuctionTab === tabName ? '#DAA520' : '#A0978E'};
        border: 2px solid ${currentAuctionTab === tabName ? '#DAA520' : 'rgba(255, 255, 255, 0.3)'};
        border-radius: 6px;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
      `;
      tabBtn.onmouseover = function() {
        if (currentAuctionTab !== tabName) {
          this.style.background = 'rgba(218, 165, 32, 0.2)';
          this.style.borderColor = 'rgba(218, 165, 32, 0.5)';
        }
      };
      tabBtn.onmouseout = function() {
        if (currentAuctionTab !== tabName) {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
          this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        }
      };
      tabBtn.onclick = function() {
        currentAuctionTab = tabName;
        showAuctionHousePanel(ledger, playerId, inventory);
      };
      tabsDiv.appendChild(tabBtn);
    });

    auctionHousePanel.appendChild(tabsDiv);

    // Tab content
    var contentDiv = document.createElement('div');
    contentDiv.id = 'auction-content';
    contentDiv.style.cssText = `
      min-height: 300px;
    `;

    if (currentAuctionTab === 'browse') {
      renderBrowseTab(contentDiv, ledger, playerId);
    } else if (currentAuctionTab === 'myauctions') {
      renderMyAuctionsTab(contentDiv, ledger, playerId);
    } else if (currentAuctionTab === 'create') {
      renderCreateTab(contentDiv, ledger, playerId, inventory);
    }

    auctionHousePanel.appendChild(contentDiv);
    auctionHousePanel.className = 'auction-panel';
    document.body.appendChild(auctionHousePanel);
    auctionHouseVisible = true;
    requestAnimationFrame(function() {
      auctionHousePanel.classList.add('visible');
    });
  }

  function renderBrowseTab(container, ledger, playerId) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    if (!Economy) return;

    var auctions = Economy.getActiveAuctions(ledger);

    if (auctions.length === 0) {
      var noAuctions = document.createElement('div');
      noAuctions.textContent = 'No active auctions at the moment.';
      noAuctions.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noAuctions);
      return;
    }

    auctions.forEach(function(auction) {
      var auctionItem = document.createElement('div');
      auctionItem.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      `;

      var itemInfo = document.createElement('div');
      itemInfo.style.cssText = `
        flex: 1;
      `;

      var itemName = document.createElement('div');
      var itemData = auction.item;
      var itemDisplayName = typeof itemData === 'string' ? itemData : (itemData.name || itemData.id || 'Unknown Item');
      itemName.textContent = itemDisplayName;
      itemName.style.cssText = `
        color: #E8E0D8;
        font-size: 16px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        margin-bottom: 5px;
      `;
      itemInfo.appendChild(itemName);

      var auctionDetails = document.createElement('div');
      var currentBidText = auction.currentBid > 0 ? auction.currentBid + ' Spark' : 'Starting: ' + auction.startingBid + ' Spark';
      var timeRemaining = Math.ceil((auction.endTime - Date.now()) / 60000);
      var timeText = timeRemaining > 60 ? Math.floor(timeRemaining / 60) + 'h ' + (timeRemaining % 60) + 'm' : timeRemaining + 'm';

      auctionDetails.textContent = 'Current Bid: ' + currentBidText + ' | Time: ' + timeText + ' | Seller: ' + auction.seller;
      auctionDetails.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
      `;
      itemInfo.appendChild(auctionDetails);

      auctionItem.appendChild(itemInfo);

      // Bid button
      if (auction.seller !== playerId) {
        var bidBtn = document.createElement('button');
        bidBtn.textContent = 'Bid';
        bidBtn.style.cssText = `
          padding: 8px 20px;
          background: rgba(218, 165, 32, 0.6);
          color: #000;
          border: 2px solid #DAA520;
          border-radius: 6px;
          font-size: 14px;
          font-family: system-ui, sans-serif;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.3s ease;
        `;
        bidBtn.onmouseover = function() {
          this.style.background = 'rgba(218, 165, 32, 0.8)';
        };
        bidBtn.onmouseout = function() {
          this.style.background = 'rgba(218, 165, 32, 0.6)';
        };
        bidBtn.onclick = function() {
          var minBid = Math.max(auction.startingBid, auction.currentBid + 1);
          var bidAmount = prompt('Enter your bid (minimum ' + minBid + ' Spark):');
          if (bidAmount) {
            var amount = parseInt(bidAmount, 10);
            if (!isNaN(amount) && amount >= minBid) {
              if (auctionHouseCallback) {
                auctionHouseCallback('placeBid', { auctionId: auction.id, amount: amount });
              }
            } else {
              alert('Invalid bid amount. Must be at least ' + minBid + ' Spark.');
            }
          }
        };
        auctionItem.appendChild(bidBtn);
      } else {
        var ownLabel = document.createElement('span');
        ownLabel.textContent = 'Your Auction';
        ownLabel.style.cssText = `
          color: #4a4;
          font-size: 12px;
          font-family: system-ui, sans-serif;
          font-style: italic;
        `;
        auctionItem.appendChild(ownLabel);
      }

      container.appendChild(auctionItem);
    });
  }

  function renderMyAuctionsTab(container, ledger, playerId) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    if (!Economy) return;

    var allAuctions = ledger.auctions || [];
    var myAuctions = allAuctions.filter(function(a) { return a.seller === playerId; });

    if (myAuctions.length === 0) {
      var noAuctions = document.createElement('div');
      noAuctions.textContent = 'You have not created any auctions yet.';
      noAuctions.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noAuctions);
      return;
    }

    myAuctions.forEach(function(auction) {
      var auctionItem = document.createElement('div');
      auctionItem.style.cssText = `
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(218, 165, 32, 0.3);
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
      `;

      var itemData = auction.item;
      var itemDisplayName = typeof itemData === 'string' ? itemData : (itemData.name || itemData.id || 'Unknown Item');

      var itemName = document.createElement('div');
      itemName.textContent = itemDisplayName;
      itemName.style.cssText = `
        color: #E8E0D8;
        font-size: 16px;
        font-family: system-ui, sans-serif;
        font-weight: bold;
        margin-bottom: 5px;
      `;
      auctionItem.appendChild(itemName);

      var statusText = 'Status: ' + auction.status.toUpperCase();
      if (auction.status === 'active') {
        var timeRemaining = Math.ceil((auction.endTime - Date.now()) / 60000);
        var timeText = timeRemaining > 60 ? Math.floor(timeRemaining / 60) + 'h ' + (timeRemaining % 60) + 'm' : timeRemaining + 'm';
        statusText += ' | Time Left: ' + timeText;
        statusText += ' | Current Bid: ' + (auction.currentBid > 0 ? auction.currentBid + ' Spark' : 'No bids yet');
      } else if (auction.status === 'sold') {
        statusText += ' | Sold for: ' + auction.currentBid + ' Spark to ' + auction.currentBidder;
      } else if (auction.status === 'expired') {
        statusText += ' | No bids received';
      }

      var statusDiv = document.createElement('div');
      statusDiv.textContent = statusText;
      statusDiv.style.cssText = `
        color: #A0978E;
        font-size: 12px;
        font-family: system-ui, sans-serif;
      `;
      auctionItem.appendChild(statusDiv);

      container.appendChild(auctionItem);
    });
  }

  function renderCreateTab(container, ledger, playerId, inventory) {
    var Economy = typeof window !== 'undefined' ? window.Economy : null;
    var Inventory = typeof window !== 'undefined' ? window.Inventory : null;
    if (!Economy || !Inventory) return;

    var formDiv = document.createElement('div');
    formDiv.style.cssText = `
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      padding: 20px;
    `;

    // Item selection
    var itemLabel = document.createElement('div');
    itemLabel.textContent = 'Select Item to Auction:';
    itemLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(itemLabel);

    var itemSelect = document.createElement('select');
    itemSelect.id = 'auction-item-select';
    itemSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;

    var items = Inventory.getInventory(inventory);
    var hasItems = false;

    items.forEach(function(item) {
      if (item && item.count > 0) {
        hasItems = true;
        var option = document.createElement('option');
        option.value = item.id;
        option.textContent = item.name + ' (x' + item.count + ')';
        itemSelect.appendChild(option);
      }
    });

    if (!hasItems) {
      var noItems = document.createElement('div');
      noItems.textContent = 'You have no items to auction.';
      noItems.style.cssText = `
        color: #6B6B6B;
        font-size: 14px;
        font-family: system-ui, sans-serif;
        font-style: italic;
        text-align: center;
        padding: 40px;
      `;
      container.appendChild(noItems);
      return;
    }

    formDiv.appendChild(itemSelect);

    // Starting bid
    var bidLabel = document.createElement('div');
    bidLabel.textContent = 'Starting Bid (Spark):';
    bidLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(bidLabel);

    var bidInput = document.createElement('input');
    bidInput.id = 'auction-starting-bid';
    bidInput.type = 'number';
    bidInput.min = '1';
    bidInput.value = '10';
    bidInput.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;
    formDiv.appendChild(bidInput);

    // Duration
    var durationLabel = document.createElement('div');
    durationLabel.textContent = 'Auction Duration:';
    durationLabel.style.cssText = `
      color: #DAA520;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      margin-bottom: 10px;
    `;
    formDiv.appendChild(durationLabel);

    var durationSelect = document.createElement('select');
    durationSelect.id = 'auction-duration';
    durationSelect.style.cssText = `
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #E8E0D8;
      border: 1px solid rgba(218, 165, 32, 0.3);
      border-radius: 4px;
      font-size: 14px;
      font-family: system-ui, sans-serif;
      margin-bottom: 20px;
    `;

    var durations = [
      { label: '1 Hour', value: 3600000 },
      { label: '6 Hours', value: 21600000 },
      { label: '24 Hours', value: 86400000 }
    ];

    durations.forEach(function(dur) {
      var option = document.createElement('option');
      option.value = dur.value;
      option.textContent = dur.label;
      durationSelect.appendChild(option);
    });

    formDiv.appendChild(durationSelect);

    // Create button
    var createBtn = document.createElement('button');
    createBtn.textContent = 'Create Auction';
    createBtn.style.cssText = `
      width: 100%;
      padding: 12px;
      background: rgba(218, 165, 32, 0.6);
      color: #000;
      border: 2px solid #DAA520;
      border-radius: 6px;
      font-size: 16px;
      font-family: system-ui, sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    `;
    createBtn.onmouseover = function() {
      this.style.background = 'rgba(218, 165, 32, 0.8)';
    };
    createBtn.onmouseout = function() {
      this.style.background = 'rgba(218, 165, 32, 0.6)';
    };
    createBtn.onclick = function() {
      var itemId = itemSelect.value;
      var startingBid = parseInt(bidInput.value, 10);
      var duration = parseInt(durationSelect.value, 10);

      if (!itemId || isNaN(startingBid) || startingBid < 1) {
        alert('Please select an item and set a valid starting bid.');
        return;
      }

      if (auctionHouseCallback) {
        auctionHouseCallback('createAuction', { itemId: itemId, startingBid: startingBid, duration: duration });
      }
    };
    formDiv.appendChild(createBtn);

    container.appendChild(formDiv);
  }

  function hideAuctionHousePanel() {
    if (auctionHousePanel) {
      auctionHousePanel.classList.remove('visible');
      setTimeout(function() {
        if (auctionHousePanel && auctionHousePanel.parentNode) {
          document.body.removeChild(auctionHousePanel);
          auctionHousePanel = null;
        }
      }, 250);
    }
    auctionHouseVisible = false;
  }

  function toggleAuctionHousePanel(ledger, playerId, inventory) {
    if (auctionHouseVisible) {
      hideAuctionHousePanel();
    } else {
      showAuctionHousePanel(ledger, playerId, inventory);
    }
  }

  // ========================================================================
  // REPUTATION DISPLAY
  // ========================================================================

  function updateReputationDisplay(reputation) {
    if (typeof document === 'undefined') return;
    var playerInfo = document.getElementById('player-info');
    if (!playerInfo) return;

    var repEl = document.getElementById('reputation-display');
    if (!repEl) {
      repEl = document.createElement('div');
      repEl.id = 'reputation-display';
      repEl.style.cssText = 'font-size:11px;color:#daa520;margin-top:2px;';
      playerInfo.appendChild(repEl);
    }

    var tierColors = {
      'Newcomer': '#888',
      'Trusted': '#4af',
      'Respected': '#4a4',
      'Honored': '#f4a',
      'Elder': '#daa520'
    };

    var color = tierColors[reputation.tier] || '#888';
    repEl.innerHTML = '<span style="color:' + color + ';">â˜…</span> ' + reputation.tier + ' (' + reputation.score + ')';
  }

  // ========================================================================
  // ACHIEVEMENT PANEL
  // ========================================================================

  var achievementPanel = null;

  function showAchievementPanel(playerId) {
    if (typeof document === 'undefined') return;

    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    if (!Quests) {
      console.warn('Quests module not available');
      return;
    }

    // Toggle if already open
    if (achievementPanel) {
      hideAchievementPanel();
      return;
    }

    var achievements = Quests.getAchievements(playerId);
    var progress = Quests.getAchievementProgress(playerId);

    var panel = document.createElement('div');
    panel.className = 'achievement-panel';

    // Header
    var header = document.createElement('h2');
    header.textContent = 'Achievements';
    panel.appendChild(header);

    // Overall progress
    var progressText = document.createElement('div');
    progressText.style.cssText = 'color:#E8E0D8;font-size:0.9rem;margin-bottom:4px;';
    progressText.textContent = 'Progress: ' + progress.unlocked + ' / ' + progress.total + ' (' + progress.percentage.toFixed(1) + '%)';
    panel.appendChild(progressText);

    // Progress bar
    var progressBarContainer = document.createElement('div');
    progressBarContainer.className = 'achievement-progress-bar';
    var progressBarFill = document.createElement('div');
    progressBarFill.className = 'achievement-progress-fill';
    progressBarFill.style.width = progress.percentage + '%';
    progressBarContainer.appendChild(progressBarFill);
    panel.appendChild(progressBarContainer);

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:15px;right:15px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;font-size:20px;cursor:pointer;transition:all 0.2s;';
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218,165,32,0.3)';
      this.style.borderColor = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255,255,255,0.1)';
      this.style.borderColor = 'rgba(255,255,255,0.3)';
    };
    closeBtn.onclick = hideAchievementPanel;
    panel.appendChild(closeBtn);

    // Group achievements by category
    var categories = {
      exploration: [],
      social: [],
      crafting: [],
      building: [],
      gardening: [],
      economy: [],
      competition: [],
      quests: [],
      guild: [],
      art: [],
      physical: [],
      mentoring: []
    };

    achievements.forEach(function(ach) {
      if (categories[ach.category]) {
        categories[ach.category].push(ach);
      }
    });

    // Category display names
    var categoryNames = {
      exploration: 'Exploration',
      social: 'Social',
      crafting: 'Crafting',
      building: 'Building',
      gardening: 'Gardening',
      economy: 'Economy',
      competition: 'Competition',
      quests: 'Quests',
      guild: 'Guild',
      art: 'Art & Creativity',
      physical: 'Physical Wellness',
      mentoring: 'Mentoring'
    };

    // Render categories
    Object.keys(categoryNames).forEach(function(catKey) {
      var catAchievements = categories[catKey];
      if (catAchievements.length === 0) return;

      var categorySection = document.createElement('div');
      categorySection.className = 'achievement-category';

      var categoryTitle = document.createElement('div');
      categoryTitle.className = 'achievement-category-title';
      categoryTitle.textContent = categoryNames[catKey];
      categorySection.appendChild(categoryTitle);

      catAchievements.forEach(function(ach) {
        var row = document.createElement('div');
        row.className = 'achievement-row ' + (ach.unlocked ? 'unlocked' : 'locked');
        if (ach.unlocked) {
          row.style.borderLeft = '3px solid #daa520';
          row.style.paddingLeft = '5px';
        }

        var icon = document.createElement('div');
        icon.className = 'achievement-icon';
        icon.textContent = ach.icon || 'â­';
        row.appendChild(icon);

        var info = document.createElement('div');
        info.className = 'achievement-info';

        var name = document.createElement('div');
        name.className = 'achievement-name';
        name.textContent = ach.name;
        info.appendChild(name);

        var desc = document.createElement('div');
        desc.className = 'achievement-desc';
        desc.textContent = ach.description;
        info.appendChild(desc);

        row.appendChild(info);

        var reward = document.createElement('div');
        reward.className = 'achievement-reward';
        reward.textContent = '+' + ach.sparkReward + ' Spark';
        row.appendChild(reward);

        categorySection.appendChild(row);
      });

      panel.appendChild(categorySection);
    });

    document.body.appendChild(panel);
    achievementPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hideAchievementPanel();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function hideAchievementPanel() {
    if (!achievementPanel) return;
    if (achievementPanel.escapeHandler) {
      document.removeEventListener('keydown', achievementPanel.escapeHandler);
    }
    achievementPanel.classList.remove('visible');
    setTimeout(function() {
      if (achievementPanel && achievementPanel.parentNode) {
        document.body.removeChild(achievementPanel);
        achievementPanel = null;
      }
    }, 250);
  }

  // Export public API
  /**
   * Update federation status panel
   * @param {Array} discoveredWorlds - Array of discovered world info
   * @param {Array} federatedWorlds - Array of federated world info
   */
  function updateFederationStatus(discoveredWorlds, federatedWorlds) {
    if (!federationPanel) return;

    var html = '<div style="font-weight: bold; margin-bottom: 8px; color: #88f;">Federation</div>';

    // Show federated worlds (active portals)
    if (federatedWorlds && federatedWorlds.length > 0) {
      html += '<div style="margin-bottom: 8px;">';
      html += '<div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">Active Portals:</div>';
      federatedWorlds.forEach(function(world) {
        html += '<div style="margin-left: 8px; margin-bottom: 3px;">';
        html += '<span style="color: #4f4;">&#x2713;</span> ';
        html += '<span style="color: #fff;">' + (world.worldInfo?.worldName || world.worldId) + '</span>';
        if (world.worldInfo?.playerCount !== undefined) {
          html += '<span style="color: #888; font-size: 10px;"> (' + world.worldInfo.playerCount + ')</span>';
        }
        html += '</div>';
      });
      html += '</div>';
    }

    // Show discovered worlds (not yet federated)
    if (discoveredWorlds && discoveredWorlds.length > 0) {
      var unfederated = discoveredWorlds.filter(function(dw) {
        return !federatedWorlds.some(function(fw) {
          return fw.worldId === dw.worldId;
        });
      });

      if (unfederated.length > 0) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">Discovered:</div>';
        unfederated.forEach(function(world) {
          html += '<div style="margin-left: 8px; margin-bottom: 3px;">';
          html += '<span style="color: #88f;">&#x25cf;</span> ';
          html += '<span style="color: #ccc;">' + (world.worldName || world.worldId) + '</span>';
          if (world.playerCount !== undefined) {
            html += '<span style="color: #888; font-size: 10px;"> (' + world.playerCount + ')</span>';
          }
          html += '</div>';
        });
        html += '</div>';
      }
    }

    // Show help text if no worlds
    if ((!federatedWorlds || federatedWorlds.length === 0) &&
        (!discoveredWorlds || discoveredWorlds.length === 0)) {
      html += '<div style="color: #888; font-size: 11px; font-style: italic;">No federated worlds yet</div>';
    }

    federationPanel.innerHTML = html;
  }

  /**
   * Show federation portal UI when near a portal
   * @param {object} portalInfo - Portal information
   */
  function showFederationPortalUI(portalInfo) {
    if (typeof document === 'undefined') return;

    // Create portal interaction UI
    var portalUI = document.getElementById('federation-portal-ui');
    if (!portalUI) {
      portalUI = document.createElement('div');
      portalUI.id = 'federation-portal-ui';
      portalUI.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #88f;
        border-radius: 12px;
        padding: 20px;
        min-width: 300px;
        color: white;
        text-align: center;
        pointer-events: auto;
        z-index: 200;
      `;
      document.body.appendChild(portalUI);
    }

    var html = '<div style="font-size: 20px; font-weight: bold; margin-bottom: 10px; color: #88f;">Rift Portal</div>';
    html += '<div style="margin-bottom: 15px; color: #ccc;">' + (portalInfo.worldName || 'Unknown World') + '</div>';

    if (portalInfo.playerCount !== undefined) {
      html += '<div style="margin-bottom: 15px; font-size: 12px; color: #aaa;">Players: ' + portalInfo.playerCount + '</div>';
    }

    html += '<button id="portal-warp-btn" style="';
    html += 'background: #4488ff; color: white; border: none; padding: 10px 20px;';
    html += 'border-radius: 5px; cursor: pointer; font-size: 14px; margin-right: 10px;">Enter Portal</button>';
    html += '<button id="portal-close-btn" style="';
    html += 'background: #444; color: white; border: none; padding: 10px 20px;';
    html += 'border-radius: 5px; cursor: pointer; font-size: 14px;">Cancel</button>';

    portalUI.innerHTML = html;

    // Add event listeners
    document.getElementById('portal-warp-btn').onclick = function() {
      if (portalInfo.onWarp) {
        portalInfo.onWarp(portalInfo.targetWorld);
      }
      hideFederationPortalUI();
    };

    document.getElementById('portal-close-btn').onclick = function() {
      hideFederationPortalUI();
    };
  }

  /**
   * Hide federation portal UI
   */
  function hideFederationPortalUI() {
    var portalUI = document.getElementById('federation-portal-ui');
    if (portalUI) {
      portalUI.remove();
    }
  }

  // ========================================================================
  // FISHING MINIGAME UI
  // ========================================================================

  let fishingUIActive = false;
  let fishingCallback = null;

  /**
   * Show fishing UI with casting and reeling mechanics
   * @param {string} zoneId - Current zone for fish type determination
   * @param {Function} onResult - Callback with result {success: boolean, fish?: Object}
   */
  function showFishingUI(zoneId, onResult) {
    if (!hudContainer || fishingUIActive) return;
    if (typeof document === 'undefined') return;

    fishingUIActive = true;
    fishingCallback = onResult;

    // Create fishing overlay with ocean theme
    const fishingOverlay = document.createElement('div');
    fishingOverlay.id = 'fishing-ui';
    fishingOverlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(0, 50, 100, 0.3) 0%, rgba(0, 100, 150, 0.5) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: auto;
    `;

    // Fishing panel
    const fishingPanel = document.createElement('div');
    fishingPanel.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 80, 140, 0.95) 0%, rgba(0, 120, 180, 0.95) 100%);
      border: 3px solid rgba(100, 200, 255, 0.8);
      border-radius: 15px;
      padding: 40px;
      min-width: 400px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0, 150, 255, 0.5), inset 0 0 50px rgba(0, 100, 200, 0.3);
      animation: wave-effect 3s ease-in-out infinite;
    `;

    // Add wave animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes wave-effect {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-5px); }
      }
      @keyframes ripple {
        0% { transform: scale(0.8); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // Fishing icon
    const fishingIcon = document.createElement('div');
    fishingIcon.style.cssText = `
      font-size: 64px;
      margin-bottom: 20px;
      animation: ripple 2s ease-out infinite;
    `;
    fishingIcon.textContent = 'ðŸŽ£';
    fishingPanel.appendChild(fishingIcon);

    // Status text
    const statusText = document.createElement('div');
    statusText.style.cssText = `
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
      margin-bottom: 20px;
    `;
    statusText.textContent = 'Casting...';
    fishingPanel.appendChild(statusText);

    // Subtext
    const subText = document.createElement('div');
    subText.style.cssText = `
      font-size: 16px;
      color: rgba(200, 240, 255, 0.9);
      margin-top: 10px;
    `;
    subText.textContent = 'Wait for a bite...';
    fishingPanel.appendChild(subText);

    fishingOverlay.appendChild(fishingPanel);
    hudContainer.appendChild(fishingOverlay);

    // Random casting time (2-5 seconds)
    const castTime = 2000 + Math.random() * 3000;

    setTimeout(() => {
      if (!document.getElementById('fishing-ui')) return;

      // Fish on! Show reeling prompt
      statusText.textContent = 'FISH ON!';
      statusText.style.color = '#ffff00';
      statusText.style.fontSize = '32px';
      subText.textContent = 'Press E to reel in!';
      subText.style.color = '#ffff00';
      fishingIcon.textContent = 'ðŸŸ';

      let caughtFish = false;
      const reelWindow = 1500; // 1.5 second window to press E

      // Listen for E key
      const reelHandler = (e) => {
        if (e.key === 'e' || e.key === 'E') {
          caughtFish = true;
          document.removeEventListener('keydown', reelHandler);

          // Determine caught fish based on zone
          const fishResult = determineCatch(zoneId);

          statusText.textContent = `Caught ${fishResult.name}!`;
          statusText.style.color = '#4f4';
          subText.textContent = `+${fishResult.value} Spark`;
          fishingIcon.textContent = fishResult.icon;

          setTimeout(() => {
            hideFishingUI();
            if (fishingCallback) {
              fishingCallback({ success: true, fish: fishResult });
            }
          }, 2000);
        }
      };

      document.addEventListener('keydown', reelHandler);

      // Miss window timeout
      setTimeout(() => {
        if (!caughtFish) {
          document.removeEventListener('keydown', reelHandler);
          statusText.textContent = 'The fish got away...';
          statusText.style.color = '#f44';
          subText.textContent = 'Try again!';
          fishingIcon.textContent = 'ðŸ’¨';

          setTimeout(() => {
            hideFishingUI();
            if (fishingCallback) {
              fishingCallback({ success: false });
            }
          }, 2000);
        }
      }, reelWindow);
    }, castTime);
  }

  /**
   * Determine what fish was caught based on zone
   * @param {string} zoneId - Current zone
   * @returns {Object} Fish data {id, name, icon, value, rarity}
   */
  function determineCatch(zoneId) {
    const zoneFishTables = {
      gardens: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' },
          { id: 'fish_sunfish', name: 'Sunfish', icon: 'â˜€ï¸', value: 8, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' },
          { id: 'fish_crystal_trout', name: 'Crystal Trout', icon: 'ðŸ’Ž', value: 40, rarity: 'rare' }
        ],
        rare: [
          { id: 'fish_golden', name: 'Golden Koi', icon: 'ðŸŸ¡', value: 50, rarity: 'rare' }
        ]
      },
      wilds: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_shadow_bass', name: 'Shadow Bass', icon: 'ðŸŒ‘', value: 18, rarity: 'uncommon' },
          { id: 'fish_silver_eel', name: 'Silver Eel', icon: 'ðŸ', value: 20, rarity: 'uncommon' }
        ],
        rare: [
          { id: 'fish_starfish', name: 'Star Cod', icon: 'â­', value: 35, rarity: 'rare' },
          { id: 'fish_dragonfish', name: 'Dragonfish', icon: 'ðŸ‰', value: 100, rarity: 'legendary' }
        ]
      },
      commons: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' },
          { id: 'fish_sunfish', name: 'Sunfish', icon: 'â˜€ï¸', value: 8, rarity: 'common' }
        ],
        rare: [
          { id: 'fish_moonfish', name: 'Moonfish', icon: 'ðŸŒ™', value: 25, rarity: 'uncommon' }
        ]
      },
      agora: {
        common: [
          { id: 'fish_common', name: 'Common Carp', icon: 'ðŸŸ', value: 5, rarity: 'common' }
        ],
        uncommon: [
          { id: 'fish_rare', name: 'Rainbow Trout', icon: 'ðŸ ', value: 15, rarity: 'uncommon' }
        ],
        rare: [
          { id: 'fish_golden', name: 'Golden Koi', icon: 'ðŸŸ¡', value: 50, rarity: 'rare' }
        ]
      }
    };

    // Default to commons if zone not found
    const table = zoneFishTables[zoneId] || zoneFishTables.commons;

    // Roll for rarity: 70% common, 25% uncommon, 5% rare
    const roll = Math.random();
    let pool;
    if (roll < 0.05 && table.rare && table.rare.length > 0) {
      pool = table.rare;
    } else if (roll < 0.30 && table.uncommon && table.uncommon.length > 0) {
      pool = table.uncommon;
    } else {
      pool = table.common;
    }

    return pool[Math.floor(Math.random() * pool.length)];
  }

  /**
   * Hide fishing UI
   */
  function hideFishingUI() {
    const fishingUI = document.getElementById('fishing-ui');
    if (fishingUI) {
      fishingUI.remove();
    }
    fishingUIActive = false;
    fishingCallback = null;
  }

  /**
   * Show fish caught notification
   * @param {string} fishName - Name of the fish
   * @param {number} value - Spark value
   */
  function showFishCaughtNotification(fishName, value) {
    if (!notificationContainer) return;
    if (typeof document === 'undefined') return;

    const notification = document.createElement('div');
    notification.style.cssText = `
      background: linear-gradient(135deg, rgba(0, 120, 200, 0.95) 0%, rgba(0, 180, 255, 0.95) 100%);
      border: 2px solid rgba(100, 220, 255, 0.9);
      border-radius: 10px;
      padding: 20px 30px;
      margin-bottom: 10px;
      box-shadow: 0 4px 20px rgba(0, 150, 255, 0.6);
      animation: slideIn 0.3s ease-out, slideOut 0.3s ease-in 2.7s;
      pointer-events: auto;
      text-align: center;
    `;

    const fishIcon = document.createElement('div');
    fishIcon.style.cssText = `
      font-size: 48px;
      margin-bottom: 10px;
    `;
    fishIcon.textContent = 'ðŸŽ£';
    notification.appendChild(fishIcon);

    const fishText = document.createElement('div');
    fishText.style.cssText = `
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
      margin-bottom: 5px;
    `;
    fishText.textContent = `Caught ${fishName}!`;
    notification.appendChild(fishText);

    const valueText = document.createElement('div');
    valueText.style.cssText = `
      font-size: 16px;
      color: #ffff00;
      text-shadow: 0 0 8px rgba(255, 255, 0, 0.6);
    `;
    valueText.textContent = `+${value} Spark`;
    notification.appendChild(valueText);

    notificationContainer.appendChild(notification);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 3000);
  }

  // ========================================================================
  // PET PANEL
  // ========================================================================

  var petPanel = null;

  function showPetPanel(playerId, currentZone) {
    if (typeof document === 'undefined') return;

    var Pets = typeof window !== 'undefined' ? window.Pets : null;
    if (!Pets) {
      console.warn('Pets module not available');
      return;
    }

    // Toggle if already open
    if (petPanel) {
      hidePetPanel();
      return;
    }

    var pet = Pets.getPlayerPet(playerId);

    var panel = document.createElement('div');
    panel.className = 'pet-panel';

    // Header
    var header = document.createElement('h2');
    header.textContent = pet ? 'My Pingym' : 'Adopt a Pingym';
    panel.appendChild(header);

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:15px;right:15px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;font-size:20px;cursor:pointer;transition:all 0.2s;';
    closeBtn.onmouseover = function() {
      this.style.background = 'rgba(218,165,32,0.3)';
      this.style.borderColor = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      this.style.background = 'rgba(255,255,255,0.1)';
      this.style.borderColor = 'rgba(255,255,255,0.3)';
    };
    closeBtn.onclick = hidePetPanel;
    panel.appendChild(closeBtn);

    if (pet) {
      // Show current pet info
      showCurrentPetInfo(panel, pet, playerId, Pets);
    } else {
      // Show available pets to adopt
      showAdoptionList(panel, playerId, currentZone, Pets);
    }

    document.body.appendChild(panel);
    petPanel = panel;
    requestAnimationFrame(function() {
      panel.classList.add('visible');
    });

    // Close on Escape
    var escapeHandler = function(e) {
      if (e.key === 'Escape') {
        hidePetPanel();
      }
    };
    document.addEventListener('keydown', escapeHandler);
    panel.escapeHandler = escapeHandler;
  }

  function showCurrentPetInfo(panel, pet, playerId, Pets) {
    var petTypeData = Pets.getPetTypeData(pet.type);
    var mood = Pets.getPetMood(pet);
    var moodEmoji = Pets.getMoodEmoji(mood);
    var bonus = Pets.getPetBonus(playerId);

    // Pet display section
    var petDisplay = document.createElement('div');
    petDisplay.style.cssText = 'text-align:center;margin-bottom:20px;padding:20px;' +
      'background:rgba(255,255,255,0.03);border-radius:8px;';

    // Pet icon
    var petIcon = document.createElement('div');
    petIcon.textContent = petTypeData.icon;
    petIcon.style.cssText = 'font-size:64px;margin-bottom:10px;';
    petDisplay.appendChild(petIcon);

    // Pet name
    var petName = document.createElement('div');
    petName.textContent = pet.name;
    petName.style.cssText = 'font-size:1.2rem;color:#DAA520;font-weight:bold;margin-bottom:5px;';
    petDisplay.appendChild(petName);

    // Pet type
    var petType = document.createElement('div');
    petType.textContent = petTypeData.name;
    petType.style.cssText = 'font-size:0.9rem;color:#B8B0A8;margin-bottom:5px;';
    petDisplay.appendChild(petType);

    // Pet mood
    var petMoodDisplay = document.createElement('div');
    petMoodDisplay.textContent = moodEmoji + ' ' + mood.charAt(0).toUpperCase() + mood.slice(1);
    petMoodDisplay.style.cssText = 'font-size:0.9rem;color:#E8E0D8;margin-top:10px;';
    petDisplay.appendChild(petMoodDisplay);

    panel.appendChild(petDisplay);

    // Stats section
    var statsSection = document.createElement('div');
    statsSection.style.cssText = 'margin-bottom:20px;';

    // Mood bar
    var moodLabel = document.createElement('div');
    moodLabel.textContent = 'Mood: ' + Math.round(pet.mood) + '/100';
    moodLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;';
    statsSection.appendChild(moodLabel);

    var moodBar = createProgressBar(pet.mood, '#DAA520');
    statsSection.appendChild(moodBar);

    // Hunger bar
    var hungerLabel = document.createElement('div');
    hungerLabel.textContent = 'Hunger: ' + Math.round(pet.hunger) + '/100';
    hungerLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;margin-top:12px;';
    statsSection.appendChild(hungerLabel);

    var hungerBar = createProgressBar(pet.hunger, pet.hunger > 60 ? '#e74c3c' : '#3498db');
    statsSection.appendChild(hungerBar);

    // Bond bar
    var bondLabel = document.createElement('div');
    bondLabel.textContent = 'Bond: ' + Math.round(pet.bond) + '/100';
    bondLabel.style.cssText = 'color:#E8E0D8;font-size:0.85rem;margin-bottom:4px;margin-top:12px;';
    statsSection.appendChild(bondLabel);

    var bondBar = createProgressBar(pet.bond, '#2ecc71');
    statsSection.appendChild(bondBar);

    panel.appendChild(statsSection);

    // Bonus display
    if (bonus && bonus.value > 0) {
      var bonusDisplay = document.createElement('div');
      bonusDisplay.textContent = 'Bonus: ' + bonus.description;
      bonusDisplay.style.cssText = 'color:#2ecc71;font-size:0.85rem;margin-bottom:20px;' +
        'padding:8px;background:rgba(46,204,113,0.1);border-radius:4px;text-align:center;';
      panel.appendChild(bonusDisplay);
    }

    // Actions section
    var actionsSection = document.createElement('div');
    actionsSection.style.cssText = 'display:flex;gap:8px;margin-bottom:12px;';

    // Feed button
    var feedBtn = document.createElement('button');
    feedBtn.textContent = 'Feed';
    feedBtn.className = 'pet-action-btn';
    feedBtn.onclick = function() {
      showFeedMenu(playerId, Pets);
    };
    actionsSection.appendChild(feedBtn);

    // Rename button
    var renameBtn = document.createElement('button');
    renameBtn.textContent = 'Rename';
    renameBtn.className = 'pet-action-btn';
    renameBtn.onclick = function() {
      var newName = prompt('Enter new name for ' + pet.name + ':');
      if (newName && newName.trim()) {
        if (Pets.renamePet(playerId, newName.trim())) {
          showNotification('Pingym renamed to ' + newName.trim());
          hidePetPanel();
        }
      }
    };
    actionsSection.appendChild(renameBtn);

    panel.appendChild(actionsSection);

    // Release button (dangerous action)
    var releaseBtn = document.createElement('button');
    releaseBtn.textContent = 'Release to Wild';
    releaseBtn.className = 'pet-release-btn';
    releaseBtn.onclick = function() {
      if (confirm('Are you sure you want to release ' + pet.name + '? This cannot be undone.')) {
        if (Pets.releasePet(playerId)) {
          showNotification(pet.name + ' has been released to the wild');
          hidePetPanel();
        }
      }
    };
    panel.appendChild(releaseBtn);
  }

  function showAdoptionList(panel, playerId, currentZone, Pets) {
    var availablePets = Pets.getAvailablePets(currentZone || 'commons');

    // Info text
    var infoText = document.createElement('div');
    infoText.textContent = 'Choose a Pingym to adopt in this zone:';
    infoText.style.cssText = 'color:#B8B0A8;font-size:0.9rem;margin-bottom:16px;';
    panel.appendChild(infoText);

    if (availablePets.length === 0) {
      var noPets = document.createElement('div');
      noPets.textContent = 'No pets available in this zone. Try exploring other areas!';
      noPets.style.cssText = 'color:#E8E0D8;text-align:center;padding:20px;';
      panel.appendChild(noPets);
      return;
    }

    // Pet list
    availablePets.forEach(function(petType) {
      var petRow = document.createElement('div');
      petRow.className = 'pet-adoption-row';
      petRow.style.cssText = 'display:flex;align-items:center;gap:12px;padding:12px;' +
        'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);' +
        'border-radius:8px;margin-bottom:8px;transition:all 0.2s;cursor:pointer;';

      petRow.onmouseover = function() {
        this.style.borderColor = 'rgba(218,165,32,0.5)';
        this.style.background = 'rgba(218,165,32,0.1)';
      };
      petRow.onmouseout = function() {
        this.style.borderColor = 'rgba(255,255,255,0.1)';
        this.style.background = 'rgba(255,255,255,0.03)';
      };

      // Pet icon
      var icon = document.createElement('div');
      icon.textContent = petType.icon;
      icon.style.cssText = 'font-size:32px;width:40px;text-align:center;';
      petRow.appendChild(icon);

      // Pet info
      var info = document.createElement('div');
      info.style.cssText = 'flex:1;';

      var name = document.createElement('div');
      name.textContent = petType.name;
      name.style.cssText = 'color:#E8E0D8;font-size:0.95rem;font-weight:bold;margin-bottom:2px;';
      info.appendChild(name);

      var desc = document.createElement('div');
      desc.textContent = petType.description;
      desc.style.cssText = 'color:#B8B0A8;font-size:0.75rem;margin-bottom:4px;';
      info.appendChild(desc);

      var rarity = document.createElement('div');
      rarity.textContent = petType.rarity.charAt(0).toUpperCase() + petType.rarity.slice(1);
      var rarityColor = petType.rarity === 'legendary' ? '#f39c12' :
                        petType.rarity === 'rare' ? '#3498db' :
                        petType.rarity === 'uncommon' ? '#2ecc71' : '#95a5a6';
      rarity.style.cssText = 'color:' + rarityColor + ';font-size:0.7rem;';
      info.appendChild(rarity);

      petRow.appendChild(info);

      // Adopt button
      var adoptBtn = document.createElement('button');
      adoptBtn.textContent = 'Adopt';
      adoptBtn.className = 'pet-adopt-btn';
      adoptBtn.onclick = function(e) {
        e.stopPropagation();
        var petName = prompt('Choose a name for your ' + petType.name + ':');
        if (petName && petName.trim()) {
          var adoptedPet = Pets.adoptPet(playerId, petType.id, petName.trim());
          if (adoptedPet) {
            showPetAdoptNotification(petName.trim(), petType);
            hidePetPanel();
          } else {
            alert('Could not adopt. You may already have a Pingym.');
          }
        }
      };
      petRow.appendChild(adoptBtn);

      panel.appendChild(petRow);
    });
  }

  function showFeedMenu(playerId, Pets) {
    if (!petPanel) return;

    // Simple food selection
    var foods = ['berry', 'fish', 'mushroom', 'bread', 'treat'];
    var foodEmojis = {
      'berry': 'ðŸ«',
      'fish': 'ðŸŸ',
      'mushroom': 'ðŸ„',
      'bread': 'ðŸž',
      'treat': 'ðŸª'
    };

    var feedMenu = document.createElement('div');
    feedMenu.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(15,12,10,0.98);border:2px solid #DAA520;border-radius:12px;' +
      'padding:20px;z-index:1200;min-width:250px;';

    var title = document.createElement('h3');
    title.textContent = 'Choose Food';
    title.style.cssText = 'color:#DAA520;margin:0 0 16px;text-align:center;';
    feedMenu.appendChild(title);

    foods.forEach(function(food) {
      var foodBtn = document.createElement('button');
      foodBtn.textContent = foodEmojis[food] + ' ' + food.charAt(0).toUpperCase() + food.slice(1);
      foodBtn.className = 'pet-food-btn';
      foodBtn.style.cssText = 'display:block;width:100%;padding:10px;margin-bottom:8px;' +
        'background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);' +
        'border-radius:6px;color:#E8E0D8;cursor:pointer;transition:all 0.2s;';

      foodBtn.onmouseover = function() {
        this.style.background = 'rgba(218,165,32,0.2)';
        this.style.borderColor = '#DAA520';
      };
      foodBtn.onmouseout = function() {
        this.style.background = 'rgba(255,255,255,0.1)';
        this.style.borderColor = 'rgba(255,255,255,0.2)';
      };

      foodBtn.onclick = function() {
        var result = Pets.feedPet(playerId, food);
        if (result.success) {
          showNotification(result.message);
          document.body.removeChild(feedMenu);
          hidePetPanel();
        }
      };
      feedMenu.appendChild(foodBtn);
    });

    var cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.className = 'pet-food-btn';
    cancelBtn.style.cssText = 'display:block;width:100%;padding:10px;' +
      'background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:6px;color:#B8B0A8;cursor:pointer;';
    cancelBtn.onclick = function() {
      document.body.removeChild(feedMenu);
    };
    feedMenu.appendChild(cancelBtn);

    document.body.appendChild(feedMenu);
  }

  function createProgressBar(value, color) {
    var container = document.createElement('div');
    container.style.cssText = 'width:100%;height:8px;background:rgba(255,255,255,0.1);' +
      'border-radius:4px;overflow:hidden;';

    var fill = document.createElement('div');
    fill.style.cssText = 'height:100%;background:' + color + ';border-radius:4px;' +
      'transition:width 0.5s ease;width:' + value + '%;';

    container.appendChild(fill);
    return container;
  }

  function hidePetPanel() {
    if (!petPanel) return;
    if (petPanel.escapeHandler) {
      document.removeEventListener('keydown', petPanel.escapeHandler);
    }
    petPanel.classList.remove('visible');
    setTimeout(function() {
      if (petPanel && petPanel.parentNode) {
        document.body.removeChild(petPanel);
        petPanel = null;
      }
    }, 250);
  }

  function showPetAdoptNotification(petName, petType) {
    if (typeof document === 'undefined') return;

    var notification = document.createElement('div');
    notification.className = 'pet-adopt-notification';
    notification.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:linear-gradient(135deg,rgba(25,20,15,0.95),rgba(35,28,18,0.95));' +
      'border:2px solid #DAA520;border-radius:16px;padding:30px 40px;text-align:center;' +
      'z-index:2000;animation:petAdoptReveal 0.5s ease-out,petAdoptFade 4s ease-in-out;' +
      'box-shadow:0 0 40px rgba(218,165,32,0.4);pointer-events:none;';

    // Add keyframes if not already present
    var styleId = 'pet-adopt-animations';
    if (!document.getElementById(styleId)) {
      var style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
        @keyframes petAdoptReveal {
          0% { transform: translate(-50%,-50%) scale(0.6); opacity: 0; }
          60% { transform: translate(-50%,-50%) scale(1.05); }
          100% { opacity: 1; transform: translate(-50%,-50%) scale(1); }
        }
        @keyframes petAdoptFade {
          0%, 80% { opacity: 1; }
          100% { opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    var icon = document.createElement('div');
    icon.textContent = petType.icon;
    icon.style.cssText = 'font-size:64px;margin-bottom:16px;';
    notification.appendChild(icon);

    var title = document.createElement('div');
    title.textContent = 'Pingym Adopted!';
    title.style.cssText = 'font-size:0.9rem;color:#DAA520;text-transform:uppercase;' +
      'letter-spacing:0.15em;margin-bottom:8px;';
    notification.appendChild(title);

    var name = document.createElement('div');
    name.textContent = petName;
    name.style.cssText = 'font-size:1.5rem;color:#E8E0D8;font-weight:bold;margin-bottom:4px;';
    notification.appendChild(name);

    var typeName = document.createElement('div');
    typeName.textContent = petType.name;
    typeName.style.cssText = 'font-size:1rem;color:#B8B0A8;';
    notification.appendChild(typeName);

    document.body.appendChild(notification);

    setTimeout(function() {
      if (notification.parentNode) {
        document.body.removeChild(notification);
      }
    }, 4000);
  }

  exports.initHUD = initHUD;
  exports.initToolbar = initToolbar;
  exports.updateChat = updateChat;
  exports.addChatMessage = addChatMessage;
  exports.updatePlayerInfo = updatePlayerInfo;
  exports.updateMinimap = updateMinimap;
  exports.updateZoneLabel = updateZoneLabel;
  exports.updateNearbyPlayers = updateNearbyPlayers;
  exports.showBreakReminder = showBreakReminder;
  exports.addChatInput = addChatInput;
  exports.showChatInput = showChatInput;
  exports.hideChatInput = hideChatInput;
  exports.showNotification = showNotification;
  exports.updateCoords = updateCoords;
  exports.updateTimeWeather = updateTimeWeather;
  exports.showNPCDialog = showNPCDialog;
  exports.hideNPCDialog = hideNPCDialog;
  exports.setNPCActionCallback = setNPCActionCallback;
  exports.showNPCShop = showNPCShop;
  exports.hideNPCShop = hideNPCShop;
  exports.updateMinimapNPCs = updateMinimapNPCs;
  exports.initQuestTracker = initQuestTracker;
  exports.updateQuestTracker = updateQuestTracker;
  exports.showQuestLog = showQuestLog;
  exports.hideQuestLog = hideQuestLog;
  exports.showQuestOffer = showQuestOffer;
  exports.hideQuestOffer = hideQuestOffer;
  exports.showQuestComplete = showQuestComplete;
  exports.showQuestProgress = showQuestProgress;
  exports.acceptQuestFromOffer = acceptQuestFromOffer;
  exports.updateFederationStatus = updateFederationStatus;
  exports.showFederationPortalUI = showFederationPortalUI;
  exports.hideFederationPortalUI = hideFederationPortalUI;
  exports.abandonQuestFromLog = abandonQuestFromLog;
  exports.initInventoryPanel = initInventoryPanel;
  exports.toggleInventoryPanel = toggleInventoryPanel;
  exports.showInventoryPanel = showInventoryPanel;
  exports.hideInventoryPanel = hideInventoryPanel;
  exports.updateInventoryDisplay = updateInventoryDisplay;
  exports.initCraftingPanel = initCraftingPanel;
  exports.toggleCraftingPanel = toggleCraftingPanel;
  exports.showCraftingPanel = showCraftingPanel;
  exports.hideCraftingPanel = hideCraftingPanel;
  exports.updateCraftingDisplay = updateCraftingDisplay;
  exports.initQuickBar = initQuickBar;
  exports.updateQuickBar = updateQuickBar;
  exports.showItemPickup = showItemPickup;
  exports.showTradeRequest = showTradeRequest;
  exports.hideTradeRequest = hideTradeRequest;
  exports.showTradeWindow = showTradeWindow;
  exports.updateTradeWindow = updateTradeWindow;
  exports.hideTradeWindow = hideTradeWindow;
  exports.showTradeComplete = showTradeComplete;
  exports.showEmoteMenu = showEmoteMenu;
  exports.hideEmoteMenu = hideEmoteMenu;
  exports.showEmoteBubble = showEmoteBubble;
  exports.updateEmoteBubbles = updateEmoteBubbles;
  exports.showBuildToolbar = showBuildToolbar;
  exports.hideBuildToolbar = hideBuildToolbar;
  exports.updateBuildToolbar = updateBuildToolbar;
  exports.showWorldMap = showWorldMap;
  exports.hideWorldMap = hideWorldMap;
  exports.updateWorldMap = updateWorldMap;
  exports.showSettingsMenu = showSettingsMenu;
  exports.hideSettingsMenu = hideSettingsMenu;
  exports.loadSettings = loadSettings;
  exports.getSettings = getSettings;
  exports.showPlayerProfile = showPlayerProfile;
  exports.hidePlayerProfile = hidePlayerProfile;
  exports.showProfilePanel = showProfilePanel;
  exports.hideProfilePanel = hideProfilePanel;
  exports.updateProfileStats = updateProfileStats;
  exports.showDiscoveryLog = showDiscoveryLog;
  exports.hideDiscoveryLog = hideDiscoveryLog;
  exports.showLoreBook = showLoreBook;
  exports.hideLoreBook = hideLoreBook;
  exports.showLoreJournal = showLoreJournal;
  exports.hideLoreJournal = hideLoreJournal;
  exports.toggleLoreJournal = toggleLoreJournal;
  exports.showAchievementToast = showAchievementToast;
  exports.showDiscoveryPopup = showDiscoveryPopup;
  exports.showSkillsPanel = showSkillsPanel;
  exports.hideSkillsPanel = hideSkillsPanel;
  exports.showMentorOffer = showMentorOffer;
  exports.showLessonProgress = showLessonProgress;
  exports.showComposePanel = showComposePanel;
  exports.hideComposePanel = hideComposePanel;
  exports.playComposition = playComposition;
  exports.showGuildPanel = showGuildPanel;
  exports.hideGuildPanel = hideGuildPanel;
  exports.showGuildCreate = showGuildCreate;
  exports.hideGuildCreate = hideGuildCreate;
  exports.showGuildInvite = showGuildInvite;
  exports.updateGuildTag = updateGuildTag;
  exports.initGovernancePanel = initGovernancePanel;
  exports.showGovernancePanel = showGovernancePanel;
  exports.hideGovernancePanel = hideGovernancePanel;
  exports.toggleGovernancePanel = toggleGovernancePanel;
  exports.initAuctionHousePanel = initAuctionHousePanel;
  exports.showAuctionHousePanel = showAuctionHousePanel;
  exports.hideAuctionHousePanel = hideAuctionHousePanel;
  exports.toggleAuctionHousePanel = toggleAuctionHousePanel;
  exports.updateReputationDisplay = updateReputationDisplay;
  exports.showAchievementPanel = showAchievementPanel;
  exports.hideAchievementPanel = hideAchievementPanel;
  exports.showFishingUI = showFishingUI;
  exports.hideFishingUI = hideFishingUI;
  exports.showFishCaughtNotification = showFishCaughtNotification;
  exports.showPetPanel = showPetPanel;
  exports.hidePetPanel = hidePetPanel;
  exports.showPetAdoptNotification = showPetAdoptNotification;

  // =============================================================================
  // TUTORIAL/ONBOARDING SYSTEM
  // =============================================================================

  var tutorialState = {
    active: false,
    currentStep: 0,
    completed: false
  };

  var tutorialTooltip = null;
  var tutorialSteps = [
    {
      id: 'move',
      message: 'Welcome to ZION! Use WASD to move around.',
      action: 'move'
    },
    {
      id: 'interact',
      message: 'Press E near an NPC to interact.',
      action: 'interact'
    },
    {
      id: 'inventory',
      message: 'Press I to open your inventory.',
      action: 'openInventory'
    },
    {
      id: 'quests',
      message: 'Press J to check your quests.',
      action: 'openQuests'
    },
    {
      id: 'chat',
      message: 'Press Enter to chat with other players.',
      action: 'openChat'
    },
    {
      id: 'complete',
      message: "You're ready! Explore the world, make friends, and build something beautiful.",
      action: 'complete',
      autoDismiss: true
    }
  ];

  /**
   * Create tutorial tooltip UI
   */
  function createTutorialTooltip() {
    if (typeof document === 'undefined') return null;

    var tooltip = document.createElement('div');
    tooltip.id = 'tutorial-tooltip';
    tooltip.style.cssText = `
      position: absolute;
      bottom: 240px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 12, 10, 0.92);
      border: 1px solid rgba(218, 165, 32, 0.4);
      border-radius: 8px;
      padding: 20px 25px;
      min-width: 400px;
      max-width: 500px;
      pointer-events: auto;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      animation: tutorialPulse 2s infinite;
    `;

    // Add CSS animation for pulsing glow
    var styleSheet = document.createElement('style');
    styleSheet.textContent = `
      @keyframes tutorialPulse {
        0%, 100% {
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 10px rgba(218, 165, 32, 0.2);
        }
        50% {
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 20px rgba(218, 165, 32, 0.5);
        }
      }
    `;
    document.head.appendChild(styleSheet);

    // Step counter
    var stepCounter = document.createElement('div');
    stepCounter.id = 'tutorial-step-counter';
    stepCounter.style.cssText = `
      color: #DAA520;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    `;
    tooltip.appendChild(stepCounter);

    // Message content
    var message = document.createElement('div');
    message.id = 'tutorial-message';
    message.style.cssText = `
      color: #ffffff;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 15px;
    `;
    tooltip.appendChild(message);

    // Button container
    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
      display: flex;
      justify-content: flex-end;
    `;

    // Skip button
    var skipButton = document.createElement('button');
    skipButton.id = 'tutorial-skip-btn';
    skipButton.textContent = 'Skip Tutorial';
    skipButton.style.cssText = `
      background: rgba(100, 100, 100, 0.3);
      border: 1px solid rgba(150, 150, 150, 0.4);
      color: #cccccc;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    `;
    skipButton.onmouseover = function() {
      skipButton.style.background = 'rgba(120, 120, 120, 0.4)';
      skipButton.style.borderColor = 'rgba(170, 170, 170, 0.6)';
    };
    skipButton.onmouseout = function() {
      skipButton.style.background = 'rgba(100, 100, 100, 0.3)';
      skipButton.style.borderColor = 'rgba(150, 150, 150, 0.4)';
    };
    skipButton.onclick = function() {
      skipTutorial();
    };
    buttonContainer.appendChild(skipButton);

    tooltip.appendChild(buttonContainer);

    return tooltip;
  }

  /**
   * Update tutorial tooltip content
   */
  function updateTutorialTooltip() {
    if (!tutorialTooltip || !tutorialState.active) return;

    var step = tutorialSteps[tutorialState.currentStep];
    var stepCounter = tutorialTooltip.querySelector('#tutorial-step-counter');
    var message = tutorialTooltip.querySelector('#tutorial-message');

    if (stepCounter) {
      stepCounter.textContent = 'Step ' + (tutorialState.currentStep + 1) + '/' + tutorialSteps.length;
    }

    if (message) {
      message.textContent = step.message;
    }
  }

  /**
   * Show tutorial tooltip
   */
  function showTutorialTooltip() {
    if (!hudContainer || typeof document === 'undefined') return;

    if (!tutorialTooltip) {
      tutorialTooltip = createTutorialTooltip();
      if (!tutorialTooltip) return;
    }

    var hudOverlay = document.getElementById('zion-hud');
    if (hudOverlay && tutorialTooltip.parentNode !== hudOverlay) {
      hudOverlay.appendChild(tutorialTooltip);
    }

    updateTutorialTooltip();
    tutorialTooltip.style.display = 'block';
  }

  /**
   * Hide tutorial tooltip
   */
  function hideTutorialTooltip() {
    if (tutorialTooltip) {
      tutorialTooltip.style.display = 'none';
    }
  }

  /**
   * Remove tutorial tooltip from DOM
   */
  function removeTutorialTooltip() {
    if (tutorialTooltip && tutorialTooltip.parentNode) {
      tutorialTooltip.parentNode.removeChild(tutorialTooltip);
      tutorialTooltip = null;
    }
  }

  /**
   * Initialize tutorial system
   * Called after login to check if player is new
   */
  function initTutorial() {
    if (typeof localStorage === 'undefined') {
      console.warn('Tutorial requires localStorage support');
      return;
    }

    // Check if tutorial is already complete
    var tutorialComplete = localStorage.getItem('zion_tutorial_complete');
    if (tutorialComplete === 'true') {
      tutorialState.completed = true;
      tutorialState.active = false;
      return;
    }

    // Start tutorial for new player
    tutorialState.active = true;
    tutorialState.currentStep = 0;
    tutorialState.completed = false;

    showTutorialTooltip();
  }

  /**
   * Advance tutorial to next step
   * @param {string} completedAction - The action that was completed (move, interact, openInventory, openQuests, openChat)
   */
  function advanceTutorial(completedAction) {
    if (!tutorialState.active || tutorialState.completed) return;

    var currentStep = tutorialSteps[tutorialState.currentStep];

    // Check if completed action matches current step
    if (currentStep.action !== completedAction) return;

    // Handle final step with auto-dismiss
    if (currentStep.autoDismiss) {
      setTimeout(function() {
        completeTutorial();
      }, 5000);
      return;
    }

    // Move to next step
    tutorialState.currentStep++;

    if (tutorialState.currentStep >= tutorialSteps.length) {
      completeTutorial();
      return;
    }

    // Update tooltip for next step
    updateTutorialTooltip();
  }

  /**
   * Complete tutorial and mark as done
   */
  function completeTutorial() {
    tutorialState.active = false;
    tutorialState.completed = true;

    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('zion_tutorial_complete', 'true');
    }

    hideTutorialTooltip();

    // Remove tooltip after a short delay to allow for fade out
    setTimeout(function() {
      removeTutorialTooltip();
    }, 300);

    // Show completion notification
    if (typeof showNotification === 'function') {
      showNotification('Tutorial Complete! Good luck in ZION!', 'success');
    }
  }

  /**
   * Skip tutorial and mark as complete
   */
  function skipTutorial() {
    completeTutorial();
  }

  /**
   * Check if tutorial is currently active
   * @returns {boolean} True if tutorial is active
   */
  function isTutorialActive() {
    return tutorialState.active;
  }

  // Export tutorial functions
  exports.initTutorial = initTutorial;
  exports.advanceTutorial = advanceTutorial;
  exports.skipTutorial = skipTutorial;
  exports.isTutorialActive = isTutorialActive;

  // =============================================================================
  // XR (VR/AR) BUTTONS
  // =============================================================================
  var xrCaps = null;
  var xrSceneCtx = null;

  function setXRCapabilities(caps, sceneCtx) {
    xrCaps = caps;
    xrSceneCtx = sceneCtx;
    // Add XR buttons to toolbar if supported
    if (typeof document === 'undefined') return;
    var toolbar = document.querySelector('#bottom-toolbar');
    if (!toolbar) return;

    if (caps.vrSupported) {
      var vrBtn = document.createElement('button');
      vrBtn.id = 'vr-btn';
      vrBtn.textContent = 'VR';
      vrBtn.title = 'Enter VR Mode';
      vrBtn.style.cssText = 'padding:6px 12px;background:rgba(68,170,255,0.3);color:#4af;border:1px solid #4af;' +
        'border-radius:6px;cursor:pointer;font-size:12px;font-weight:bold;';
      vrBtn.onclick = function() {
        var XR = typeof window !== 'undefined' ? window.XR : null;
        if (XR && xrSceneCtx && xrSceneCtx.renderer) {
          XR.enterVR(xrSceneCtx.renderer, xrSceneCtx.scene, xrSceneCtx.camera).catch(function(err) {
            showNotification('Failed to enter VR: ' + err.message, 'error');
          });
        }
      };
      toolbar.appendChild(vrBtn);
    }

    if (caps.arSupported) {
      var arBtn = document.createElement('button');
      arBtn.id = 'ar-btn';
      arBtn.textContent = 'AR';
      arBtn.title = 'Enter AR Mode';
      arBtn.style.cssText = 'padding:6px 12px;background:rgba(255,165,0,0.3);color:#ffa500;border:1px solid #ffa500;' +
        'border-radius:6px;cursor:pointer;font-size:12px;font-weight:bold;';
      arBtn.onclick = function() {
        var XR = typeof window !== 'undefined' ? window.XR : null;
        if (XR && xrSceneCtx && xrSceneCtx.renderer) {
          XR.enterAR(xrSceneCtx.renderer, xrSceneCtx.scene, xrSceneCtx.camera).catch(function(err) {
            showNotification('Failed to enter AR: ' + err.message, 'error');
          });
        }
      };
      toolbar.appendChild(arBtn);
    }
  }
  exports.setXRCapabilities = setXRCapabilities;

  // =============================================================================
  // ANCHOR SYSTEM PANEL
  // =============================================================================
  var anchorPanelEl = null;

  function showAnchorPanel(playerPosition, currentZone) {
    if (typeof document === 'undefined') return;
    hideAnchorPanel();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var State = typeof window !== 'undefined' ? window.State : null;
    var anchors = [];
    if (State) {
      var liveState = State.getLiveState();
      if (liveState && liveState.anchors) {
        anchors = Object.values(liveState.anchors);
      }
    }

    anchorPanelEl = document.createElement('div');
    anchorPanelEl.id = 'anchor-panel';
    anchorPanelEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #4af;border-radius:12px;' +
      'padding:20px;width:400px;max-height:500px;overflow-y:auto;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<h2 style="color:#4af;margin:0;font-size:18px;">Anchors</h2>' +
      '<button id="anchor-close" style="background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;">Ã—</button></div>';

    if (anchors.length === 0) {
      html += '<p style="color:#888;text-align:center;">No anchors placed yet.</p>';
    } else {
      anchors.forEach(function(anchor) {
        html += '<div style="background:rgba(255,255,255,0.05);border:1px solid #333;border-radius:8px;padding:10px;margin-bottom:8px;">' +
          '<div style="color:#4af;font-weight:bold;">' + (anchor.name || 'Unnamed Anchor') + '</div>' +
          '<div style="color:#888;font-size:12px;">Zone: ' + (anchor.zone || 'unknown') + ' | By: ' + (anchor.owner || 'unknown') + '</div>' +
          '</div>';
      });
    }

    // Place anchor form
    html += '<div style="border-top:1px solid #333;padding-top:12px;margin-top:12px;">' +
      '<div style="color:#aaa;font-size:13px;margin-bottom:8px;">Place New Anchor</div>' +
      '<input id="anchor-name-input" placeholder="Anchor name..." style="width:100%;padding:6px;background:rgba(0,0,0,0.5);' +
      'border:1px solid #555;border-radius:4px;color:#fff;font-size:13px;margin-bottom:8px;box-sizing:border-box;" />' +
      '<button id="anchor-place-btn" style="width:100%;padding:8px;background:#4af;color:#000;border:none;border-radius:6px;' +
      'font-weight:bold;cursor:pointer;">Place Anchor Here</button></div>';

    anchorPanelEl.innerHTML = html;
    hud.appendChild(anchorPanelEl);

    document.getElementById('anchor-close').onclick = hideAnchorPanel;
    document.getElementById('anchor-place-btn').onclick = function() {
      var name = document.getElementById('anchor-name-input').value.trim();
      if (!name) { showNotification('Enter an anchor name', 'warning'); return; }
      // Send anchor_place protocol message via main.js callback
      if (typeof window !== 'undefined' && window._onAnchorPlace) {
        window._onAnchorPlace({ name: name, zone: currentZone, position: playerPosition });
      }
      showNotification('Anchor "' + name + '" placed!', 'success');
      hideAnchorPanel();
    };
  }

  function hideAnchorPanel() {
    if (anchorPanelEl && anchorPanelEl.parentNode) {
      anchorPanelEl.parentNode.removeChild(anchorPanelEl);
      anchorPanelEl = null;
    }
  }

  exports.showAnchorPanel = showAnchorPanel;
  exports.hideAnchorPanel = hideAnchorPanel;

  // =============================================================================
  // STEWARD ELECTION PANEL
  // =============================================================================
  var stewardPanelEl = null;

  function showStewardPanel(currentZone, playerId) {
    if (typeof document === 'undefined') return;
    hideStewardPanel();

    var hud = document.querySelector('#zion-hud');
    if (!hud) return;

    var State = typeof window !== 'undefined' ? window.State : null;
    var liveState = State ? State.getLiveState() : {};
    var stewards = liveState.stewards || {};
    var elections = liveState.elections || {};
    var zoneSteward = stewards[currentZone];

    stewardPanelEl = document.createElement('div');
    stewardPanelEl.id = 'steward-panel';
    stewardPanelEl.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #DAA520;border-radius:12px;' +
      'padding:20px;width:420px;max-height:500px;overflow-y:auto;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);';

    var html = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<h2 style="color:#DAA520;margin:0;font-size:18px;">Zone Steward â€” ' + currentZone + '</h2>' +
      '<button id="steward-close" style="background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;">Ã—</button></div>';

    if (zoneSteward) {
      html += '<div style="background:rgba(218,165,32,0.1);border:1px solid #DAA520;border-radius:8px;padding:12px;margin-bottom:12px;">' +
        '<div style="color:#DAA520;font-weight:bold;">Current Steward: ' + zoneSteward.playerId + '</div>' +
        '<div style="color:#888;font-size:12px;">Elected: ' + new Date(zoneSteward.elected_at).toLocaleDateString() + '</div>' +
        '<div style="color:#888;font-size:12px;">Term ends: ' + new Date(zoneSteward.term_ends).toLocaleDateString() + '</div>';
      if (zoneSteward.welcomeMessage) {
        html += '<div style="color:#aaa;font-size:13px;margin-top:8px;font-style:italic;">"' + zoneSteward.welcomeMessage + '"</div>';
      }
      html += '</div>';
    } else {
      html += '<p style="color:#888;text-align:center;">No steward for this zone.</p>';
    }

    // Active elections
    var activeElections = Object.values(elections).filter(function(e) {
      return e.zone === currentZone && e.status === 'active';
    });

    if (activeElections.length > 0) {
      var elec = activeElections[0];
      html += '<div style="background:rgba(68,170,255,0.1);border:1px solid #4af;border-radius:8px;padding:12px;margin-bottom:12px;">' +
        '<div style="color:#4af;font-weight:bold;">Active Election</div>' +
        '<div style="color:#888;font-size:12px;">Candidates: ' + elec.candidates.join(', ') + '</div>' +
        '<div style="color:#888;font-size:12px;">Votes cast: ' + Object.keys(elec.votes).length + '</div>';

      // Vote buttons
      html += '<div style="margin-top:8px;">';
      elec.candidates.forEach(function(c) {
        html += '<button class="steward-vote-btn" data-election="' + elec.id + '" data-candidate="' + c + '" ' +
          'style="margin:2px;padding:4px 12px;background:rgba(68,170,255,0.3);color:#4af;border:1px solid #4af;' +
          'border-radius:4px;cursor:pointer;font-size:12px;">Vote: ' + c + '</button>';
      });
      html += '</div></div>';
    } else {
      // Start election button
      html += '<button id="steward-start-election" style="width:100%;padding:10px;background:#DAA520;color:#000;border:none;' +
        'border-radius:6px;font-weight:bold;cursor:pointer;margin-top:8px;">Start Election for ' + currentZone + '</button>';
    }

    stewardPanelEl.innerHTML = html;
    hud.appendChild(stewardPanelEl);

    document.getElementById('steward-close').onclick = hideStewardPanel;

    var startBtn = document.getElementById('steward-start-election');
    if (startBtn) {
      startBtn.onclick = function() {
        if (typeof window !== 'undefined' && window._onElectionStart) {
          window._onElectionStart({ zone: currentZone });
        }
        showNotification('Election started for ' + currentZone + '!', 'success');
        hideStewardPanel();
      };
    }

    var voteBtns = stewardPanelEl.querySelectorAll('.steward-vote-btn');
    voteBtns.forEach(function(btn) {
      btn.onclick = function() {
        var electionId = btn.getAttribute('data-election');
        var candidate = btn.getAttribute('data-candidate');
        if (typeof window !== 'undefined' && window._onElectionVote) {
          window._onElectionVote({ electionId: electionId, candidate: candidate });
        }
        showNotification('Voted for ' + candidate, 'success');
        hideStewardPanel();
      };
    });
  }

  function hideStewardPanel() {
    if (stewardPanelEl && stewardPanelEl.parentNode) {
      stewardPanelEl.parentNode.removeChild(stewardPanelEl);
      stewardPanelEl = null;
    }
  }

  exports.showStewardPanel = showStewardPanel;
  exports.hideStewardPanel = hideStewardPanel;

  // =============================================================================
  // FEDERATION PORTAL â€” PROPOSE + VISUAL STATUS
  // =============================================================================

  function showFederationProposal() {
    if (typeof document === 'undefined') return;

    var overlay = document.createElement('div');
    overlay.id = 'federation-proposal';
    overlay.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.95);border:2px solid #a855f7;border-radius:12px;' +
      'padding:20px;width:400px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);';

    overlay.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">' +
      '<h2 style="color:#a855f7;margin:0;font-size:18px;">Propose Federation</h2>' +
      '<button id="fed-close" style="background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.3);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;">Ã—</button></div>' +
      '<p style="color:#aaa;font-size:13px;margin-bottom:12px;">Link another ZION world instance via the Rift Portal in the Nexus.</p>' +
      '<input id="fed-name" placeholder="Federation name..." style="width:100%;padding:8px;background:rgba(0,0,0,0.5);' +
      'border:1px solid #555;border-radius:4px;color:#fff;font-size:13px;margin-bottom:8px;box-sizing:border-box;" />' +
      '<input id="fed-endpoint" placeholder="Endpoint URL (e.g. https://...)" style="width:100%;padding:8px;background:rgba(0,0,0,0.5);' +
      'border:1px solid #555;border-radius:4px;color:#fff;font-size:13px;margin-bottom:12px;box-sizing:border-box;" />' +
      '<button id="fed-submit" style="width:100%;padding:10px;background:#a855f7;color:#fff;border:none;border-radius:6px;' +
      'font-weight:bold;cursor:pointer;">Propose Federation</button>';

    document.body.appendChild(overlay);

    document.getElementById('fed-close').onclick = function() { overlay.parentNode.removeChild(overlay); };
    document.getElementById('fed-submit').onclick = function() {
      var name = document.getElementById('fed-name').value.trim();
      var endpoint = document.getElementById('fed-endpoint').value.trim();
      if (!name || !endpoint) { showNotification('Fill in all fields', 'warning'); return; }
      if (typeof window !== 'undefined' && window._onFederationPropose) {
        window._onFederationPropose({ name: name, endpoint: endpoint });
      }
      showNotification('Federation "' + name + '" proposed!', 'success');
      overlay.parentNode.removeChild(overlay);
    };
  }

  exports.showFederationProposal = showFederationProposal;

  // =============================================================================
  // PANEL A: ECONOMY VISUALIZER
  // =============================================================================

  var economyVizPanelEl = null;
  var economyVizVisible = false;
  var _economyVizState = null;

  function createEconomyVizPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'economy-viz-panel';
    panel.className = 'zion-tool-panel economy-viz-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #22c55e;border-radius:12px;' +
      'padding:0;width:520px;max-height:80vh;overflow:hidden;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    // Header
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(34,197,94,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#128200;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#22c55e;flex:1;">Economy Visualizer</span>' +
      '<button id="economy-viz-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    // Body
    var body = document.createElement('div');
    body.style.cssText = 'padding:16px;overflow-y:auto;flex:1;';

    // Module guard
    if (typeof EconomyViz === 'undefined') {
      body.innerHTML = '<div style="text-align:center;color:#888;padding:40px;">Module not loaded: EconomyViz</div>';
      panel.appendChild(body);
      return panel;
    }

    // Summary row
    var summaryEl = document.createElement('div');
    summaryEl.id = 'economy-viz-summary';
    summaryEl.style.cssText = 'background:rgba(34,197,94,0.08);border:1px solid rgba(34,197,94,0.2);' +
      'border-radius:8px;padding:10px 14px;margin-bottom:14px;font-size:12px;color:#ccc;line-height:1.6;';
    summaryEl.textContent = 'Loading economy data...';
    body.appendChild(summaryEl);

    // Gini row
    var giniRow = document.createElement('div');
    giniRow.style.cssText = 'display:flex;align-items:center;gap:12px;margin-bottom:14px;';
    giniRow.innerHTML = '<span style="font-size:12px;color:#888;">Gini Coefficient</span>' +
      '<div id="economy-gini-bar" style="flex:1;height:8px;background:#333;border-radius:4px;overflow:hidden;">' +
      '<div id="economy-gini-fill" style="height:100%;width:0%;background:#22c55e;border-radius:4px;transition:width 0.5s,background 0.5s;"></div></div>' +
      '<span id="economy-gini-val" style="font-size:13px;font-weight:bold;color:#22c55e;min-width:36px;text-align:right;">0.00</span>';
    body.appendChild(giniRow);

    // Canvas for flow/Sankey
    var canvasWrap = document.createElement('div');
    canvasWrap.style.cssText = 'background:#0a0e1a;border-radius:8px;margin-bottom:14px;overflow:hidden;';
    var flowCanvas = document.createElement('canvas');
    flowCanvas.id = 'economy-flow-canvas';
    flowCanvas.width = 480;
    flowCanvas.height = 200;
    flowCanvas.style.cssText = 'display:block;width:100%;height:auto;';
    canvasWrap.appendChild(flowCanvas);
    body.appendChild(canvasWrap);

    // Distribution bar chart area
    var distEl = document.createElement('div');
    distEl.id = 'economy-dist-chart';
    distEl.style.cssText = 'background:#0a0e1a;border-radius:8px;padding:12px;min-height:80px;';
    distEl.innerHTML = '<div style="font-size:11px;color:#666;margin-bottom:6px;text-transform:uppercase;letter-spacing:0.05em;">Wealth Distribution</div>' +
      '<div id="economy-dist-bars" style="display:flex;align-items:flex-end;gap:3px;height:60px;"></div>';
    body.appendChild(distEl);

    // Refresh button
    var refreshBtn = document.createElement('button');
    refreshBtn.textContent = 'Refresh';
    refreshBtn.style.cssText = 'margin-top:12px;width:100%;padding:8px;background:rgba(34,197,94,0.15);' +
      'border:1px solid rgba(34,197,94,0.4);border-radius:6px;color:#22c55e;font-size:12px;cursor:pointer;';
    refreshBtn.onclick = function() { refreshEconomyVizPanel(); };
    body.appendChild(refreshBtn);

    panel.appendChild(body);
    return panel;
  }

  function _economyVizRenderGini(gini) {
    var fillEl = document.getElementById('economy-gini-fill');
    var valEl = document.getElementById('economy-gini-val');
    if (!fillEl || !valEl) return;
    var pct = Math.round(gini * 100);
    var color = gini < 0.3 ? '#22c55e' : gini < 0.55 ? '#facc15' : '#ef4444';
    fillEl.style.width = pct + '%';
    fillEl.style.background = color;
    valEl.textContent = gini.toFixed(2);
    valEl.style.color = color;
  }

  function _economyVizRenderDistBars(distribution) {
    var barsEl = document.getElementById('economy-dist-bars');
    if (!barsEl || !distribution || !distribution.length) return;
    var max = 1;
    for (var i = 0; i < distribution.length; i++) {
      if (distribution[i] > max) max = distribution[i];
    }
    barsEl.innerHTML = '';
    var colors = ['#22c55e', '#4ade80', '#86efac', '#bbf7d0', '#dcfce7'];
    for (var j = 0; j < distribution.length; j++) {
      var bar = document.createElement('div');
      var hPct = Math.max(4, Math.round((distribution[j] / max) * 100));
      bar.style.cssText = 'flex:1;border-radius:3px 3px 0 0;background:' +
        (colors[j % colors.length]) + ';height:' + hPct + '%;title="' + distribution[j] + '"';
      bar.title = 'Quintile ' + (j + 1) + ': ' + distribution[j];
      barsEl.appendChild(bar);
    }
  }

  function refreshEconomyVizPanel() {
    if (!economyVizPanelEl) return;

    var EV = typeof EconomyViz !== 'undefined' ? EconomyViz : null;
    if (!EV) {
      var summaryEl = document.getElementById('economy-viz-summary');
      if (summaryEl) summaryEl.textContent = 'Module not loaded: EconomyViz';
      return;
    }

    var State = typeof window !== 'undefined' ? window.State : null;
    var state = (State && State.getLiveState) ? State.getLiveState() : (_economyVizState || {});

    // Summary
    var summaryEl = document.getElementById('economy-viz-summary');
    if (summaryEl) {
      try {
        summaryEl.textContent = EV.formatSummary(state);
      } catch (e) {
        summaryEl.textContent = 'Economy data unavailable';
      }
    }

    // Canvas
    var canvas = document.getElementById('economy-flow-canvas');
    if (canvas) {
      try {
        EV.init(canvas);
        EV.loadState(state);
        EV.render();
      } catch (e) {
        var ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#555';
          ctx.font = '13px monospace';
          ctx.fillText('Flow data unavailable', 12, 30);
        }
      }
    }

    // Gini
    try {
      var balances = (state.economy && state.economy.balances) ? state.economy.balances :
                     (state.balances ? state.balances : {});
      var gini = EV.computeGini(balances);
      _economyVizRenderGini(gini);
      var distribution = EV.computeDistribution(balances);
      _economyVizRenderDistBars(distribution);
    } catch (e) {
      _economyVizRenderGini(0);
    }
  }

  function showEconomyVizPanel(state) {
    if (typeof document === 'undefined') return;
    if (!economyVizPanelEl) {
      economyVizPanelEl = createEconomyVizPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && economyVizPanelEl) hud.appendChild(economyVizPanelEl);
    }
    if (!economyVizPanelEl) return;
    _economyVizState = state || null;
    economyVizPanelEl.style.display = 'flex';
    economyVizVisible = true;

    var closeBtn = document.getElementById('economy-viz-close');
    if (closeBtn) closeBtn.onclick = hideEconomyVizPanel;

    refreshEconomyVizPanel();
  }

  function hideEconomyVizPanel() {
    if (economyVizPanelEl) {
      economyVizPanelEl.style.display = 'none';
    }
    economyVizVisible = false;
  }

  function toggleEconomyVizPanel(state) {
    if (economyVizVisible) {
      hideEconomyVizPanel();
    } else {
      showEconomyVizPanel(state);
    }
  }

  exports.createEconomyVizPanel = createEconomyVizPanel;
  exports.showEconomyVizPanel = showEconomyVizPanel;
  exports.hideEconomyVizPanel = hideEconomyVizPanel;
  exports.toggleEconomyVizPanel = toggleEconomyVizPanel;
  exports.refreshEconomyVizPanel = refreshEconomyVizPanel;

  // =============================================================================
  // PANEL B: YAML STATE INSPECTOR
  // =============================================================================

  var yamlInspectorPanelEl = null;
  var yamlInspectorVisible = false;
  var _yamlInspectorTree = null;
  var _yamlInspectorSource = 'world';

  var YAML_SOURCES = ['world', 'economy', 'gardens', 'structures', 'chat'];

  function _getYamlSourceData(source) {
    var State = typeof window !== 'undefined' ? window.State : null;
    var liveState = (State && State.getLiveState) ? State.getLiveState() : {};
    switch (source) {
      case 'world':     return liveState;
      case 'economy':   return liveState.economy || {};
      case 'gardens':   return liveState.gardens || {};
      case 'structures':return liveState.structures || {};
      case 'chat':      return liveState.chat || [];
      default:          return liveState;
    }
  }

  function createYamlInspectorPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'yaml-inspector-panel';
    panel.className = 'zion-tool-panel yaml-inspector-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #818cf8;border-radius:12px;' +
      'padding:0;width:560px;height:600px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    // Header
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(129,140,248,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#128269;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#818cf8;flex:1;">State Inspector</span>' +
      '<button id="yaml-inspector-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    // Toolbar: search + dropdown
    var toolbar = document.createElement('div');
    toolbar.style.cssText = 'display:flex;gap:8px;padding:10px 16px;border-bottom:1px solid rgba(129,140,248,0.15);flex-shrink:0;';

    var searchInput = document.createElement('input');
    searchInput.id = 'yaml-inspector-search';
    searchInput.type = 'text';
    searchInput.placeholder = 'Filter keys/values...';
    searchInput.style.cssText = 'flex:1;background:rgba(0,0,0,0.5);border:1px solid rgba(129,140,248,0.4);' +
      'border-radius:6px;padding:6px 10px;color:#e0e0e0;font-size:12px;font-family:monospace;outline:none;';

    var sourceSelect = document.createElement('select');
    sourceSelect.id = 'yaml-inspector-source';
    sourceSelect.style.cssText = 'background:rgba(0,0,0,0.5);border:1px solid rgba(129,140,248,0.4);' +
      'border-radius:6px;padding:6px 10px;color:#818cf8;font-size:12px;cursor:pointer;outline:none;';
    YAML_SOURCES.forEach(function(src) {
      var opt = document.createElement('option');
      opt.value = src;
      opt.textContent = src;
      if (src === _yamlInspectorSource) opt.selected = true;
      sourceSelect.appendChild(opt);
    });

    toolbar.appendChild(searchInput);
    toolbar.appendChild(sourceSelect);
    panel.appendChild(toolbar);

    // Module guard message (shown if YamlDash missing)
    if (typeof YamlDash === 'undefined') {
      var guardMsg = document.createElement('div');
      guardMsg.style.cssText = 'text-align:center;color:#888;padding:40px;';
      guardMsg.textContent = 'Module not loaded: YamlDash';
      panel.appendChild(guardMsg);
      return panel;
    }

    // Tree view area
    var treeWrap = document.createElement('div');
    treeWrap.id = 'yaml-inspector-tree';
    treeWrap.style.cssText = 'flex:1;overflow-y:auto;padding:12px 16px;font-family:monospace;font-size:12px;' +
      'color:#e0e0e0;line-height:1.7;white-space:pre;';
    treeWrap.textContent = 'Loading...';
    panel.appendChild(treeWrap);

    // Wire events after panel is in DOM (done in showYamlInspectorPanel)
    panel._searchInput = searchInput;
    panel._sourceSelect = sourceSelect;

    return panel;
  }

  function _yamlInspectorRender() {
    if (!yamlInspectorPanelEl) return;
    var YD = typeof YamlDash !== 'undefined' ? YamlDash : null;
    if (!YD) return;

    var treeEl = document.getElementById('yaml-inspector-tree');
    if (!treeEl) return;

    var query = document.getElementById('yaml-inspector-search');
    var queryVal = query ? query.value.trim() : '';

    var displayTree = _yamlInspectorTree;
    if (queryVal && displayTree) {
      try {
        displayTree = YD.filterTree(displayTree, queryVal);
      } catch (e) { /* noop */ }
    }

    if (!displayTree) {
      treeEl.textContent = queryVal ? 'No matches found.' : 'No data.';
      return;
    }

    try {
      treeEl.textContent = YD.renderToText(displayTree);
    } catch (e) {
      treeEl.textContent = 'Render error: ' + e.message;
    }

    // Wire click-to-toggle on tree
    treeEl.onclick = function(e) {
      if (!_yamlInspectorTree) return;
      var target = e.target;
      var path = target.getAttribute && target.getAttribute('data-path');
      if (!path) {
        // Try to parse a path from the text content line
        var line = target.textContent || '';
        var match = line.match(/^\s*([\w\.\[\]]+)/);
        if (match) path = match[1];
      }
      if (path) {
        try { YD.toggleNode(_yamlInspectorTree, path); } catch (ex) { /* noop */ }
        _yamlInspectorRender();
      }
    };
  }

  function _yamlInspectorLoad(source) {
    var YD = typeof YamlDash !== 'undefined' ? YamlDash : null;
    if (!YD) return;
    _yamlInspectorSource = source || _yamlInspectorSource;
    var data = _getYamlSourceData(_yamlInspectorSource);
    try {
      _yamlInspectorTree = YD.buildTree(data, _yamlInspectorSource);
    } catch (e) {
      _yamlInspectorTree = null;
    }
    _yamlInspectorRender();
  }

  function showYamlInspectorPanel() {
    if (typeof document === 'undefined') return;
    if (!yamlInspectorPanelEl) {
      yamlInspectorPanelEl = createYamlInspectorPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && yamlInspectorPanelEl) hud.appendChild(yamlInspectorPanelEl);
    }
    if (!yamlInspectorPanelEl) return;
    yamlInspectorPanelEl.style.display = 'flex';
    yamlInspectorVisible = true;

    var closeBtn = document.getElementById('yaml-inspector-close');
    if (closeBtn) closeBtn.onclick = hideYamlInspectorPanel;

    var searchInput = document.getElementById('yaml-inspector-search');
    if (searchInput) {
      searchInput.oninput = function() { _yamlInspectorRender(); };
    }

    var sourceSelect = document.getElementById('yaml-inspector-source');
    if (sourceSelect) {
      sourceSelect.onchange = function() {
        _yamlInspectorLoad(sourceSelect.value);
      };
    }

    _yamlInspectorLoad(_yamlInspectorSource);
  }

  function hideYamlInspectorPanel() {
    if (yamlInspectorPanelEl) {
      yamlInspectorPanelEl.style.display = 'none';
    }
    yamlInspectorVisible = false;
  }

  function toggleYamlInspectorPanel() {
    if (yamlInspectorVisible) {
      hideYamlInspectorPanel();
    } else {
      showYamlInspectorPanel();
    }
  }

  exports.createYamlInspectorPanel = createYamlInspectorPanel;
  exports.showYamlInspectorPanel = showYamlInspectorPanel;
  exports.hideYamlInspectorPanel = hideYamlInspectorPanel;
  exports.toggleYamlInspectorPanel = toggleYamlInspectorPanel;

  // =============================================================================
  // PANEL C: PROTOCOL REPLAY CONTROLS
  // =============================================================================

  var replayPanelEl = null;
  var replayPanelVisible = false;
  var _replayState = 'idle'; // idle | recording | stopped | playing | paused
  var _replayRecorder = null;
  var _replayPlayer = null;
  var _replayRecording = null;
  var _replayUpdateInterval = null;

  function createReplayPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'replay-panel';
    panel.className = 'zion-tool-panel replay-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #f472b6;border-radius:12px;' +
      'padding:0;width:460px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    // Header
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(244,114,182,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#9654;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#f472b6;flex:1;">Protocol Replay</span>' +
      '<button id="replay-panel-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:16px;';

    // Module guard
    if (typeof Replay === 'undefined') {
      body.innerHTML = '<div style="text-align:center;color:#888;padding:40px;">Module not loaded: Replay</div>';
      panel.appendChild(body);
      return panel;
    }

    // Status display
    var statusEl = document.createElement('div');
    statusEl.id = 'replay-status';
    statusEl.style.cssText = 'text-align:center;padding:8px;margin-bottom:12px;border-radius:6px;font-size:12px;' +
      'background:rgba(244,114,182,0.08);border:1px solid rgba(244,114,182,0.2);color:#f472b6;font-weight:bold;';
    statusEl.textContent = 'IDLE';
    body.appendChild(statusEl);

    // Control buttons
    var btnRow = document.createElement('div');
    btnRow.style.cssText = 'display:flex;gap:8px;margin-bottom:14px;justify-content:center;';

    var recordBtn = document.createElement('button');
    recordBtn.id = 'replay-record-btn';
    recordBtn.style.cssText = 'padding:8px 16px;background:rgba(239,68,68,0.15);border:1px solid #ef4444;' +
      'border-radius:6px;color:#ef4444;font-size:13px;cursor:pointer;font-weight:bold;';
    recordBtn.innerHTML = '&#9679; Record';
    recordBtn.onclick = function() { _replayStartRecording(); };

    var stopBtn = document.createElement('button');
    stopBtn.id = 'replay-stop-btn';
    stopBtn.style.cssText = 'padding:8px 16px;background:rgba(100,100,100,0.15);border:1px solid #666;' +
      'border-radius:6px;color:#666;font-size:13px;cursor:pointer;';
    stopBtn.innerHTML = '&#9632; Stop';
    stopBtn.onclick = function() { _replayStop(); };

    var playBtn = document.createElement('button');
    playBtn.id = 'replay-play-btn';
    playBtn.style.cssText = 'padding:8px 16px;background:rgba(34,197,94,0.15);border:1px solid rgba(34,197,94,0.4);' +
      'border-radius:6px;color:#22c55e;font-size:13px;cursor:pointer;';
    playBtn.innerHTML = '&#9654; Play';
    playBtn.onclick = function() { _replayPlayPause(); };

    btnRow.appendChild(recordBtn);
    btnRow.appendChild(stopBtn);
    btnRow.appendChild(playBtn);
    body.appendChild(btnRow);

    // Progress display
    var progressEl = document.createElement('div');
    progressEl.id = 'replay-progress-text';
    progressEl.style.cssText = 'text-align:center;font-size:12px;color:#888;margin-bottom:10px;font-family:monospace;';
    progressEl.textContent = 'Message 0/0 â€” 00:00/00:00';
    body.appendChild(progressEl);

    // Seek slider
    var seekSlider = document.createElement('input');
    seekSlider.id = 'replay-seek';
    seekSlider.type = 'range';
    seekSlider.min = '0';
    seekSlider.max = '100';
    seekSlider.value = '0';
    seekSlider.style.cssText = 'width:100%;margin-bottom:14px;accent-color:#f472b6;cursor:pointer;';
    seekSlider.oninput = function() {
      if (_replayPlayer && (_replayState === 'playing' || _replayState === 'paused')) {
        try {
          var pos = parseInt(seekSlider.value, 10) / 100;
          var rec = _replayRecording;
          if (rec && rec.messages && rec.messages.length) {
            var idx = Math.floor(pos * (rec.messages.length - 1));
            _replayPlayer.seek(idx);
            _updateReplayProgress();
          }
        } catch (e) { /* noop */ }
      }
    };
    body.appendChild(seekSlider);

    // Speed selector
    var speedRow = document.createElement('div');
    speedRow.style.cssText = 'display:flex;align-items:center;gap:10px;margin-bottom:14px;';
    speedRow.innerHTML = '<span style="font-size:12px;color:#888;">Speed:</span>';
    [0.5, 1, 2, 5, 10].forEach(function(spd) {
      var btn = document.createElement('button');
      btn.textContent = spd + 'x';
      btn.setAttribute('data-speed', spd);
      btn.style.cssText = 'padding:4px 10px;background:rgba(244,114,182,' + (spd === 1 ? '0.25' : '0.08') + ');' +
        'border:1px solid rgba(244,114,182,' + (spd === 1 ? '0.6' : '0.2') + ');' +
        'border-radius:4px;color:#f472b6;font-size:11px;cursor:pointer;';
      btn.onclick = function() {
        speedRow.querySelectorAll('[data-speed]').forEach(function(b) {
          b.style.background = 'rgba(244,114,182,0.08)';
          b.style.borderColor = 'rgba(244,114,182,0.2)';
        });
        btn.style.background = 'rgba(244,114,182,0.25)';
        btn.style.borderColor = 'rgba(244,114,182,0.6)';
        if (_replayPlayer) {
          try { _replayPlayer.setSpeed(spd); } catch (e) { /* noop */ }
        }
      };
      speedRow.appendChild(btn);
    });
    body.appendChild(speedRow);

    // Export button
    var exportBtn = document.createElement('button');
    exportBtn.id = 'replay-export-btn';
    exportBtn.textContent = 'Export Recording';
    exportBtn.style.cssText = 'width:100%;padding:8px;background:rgba(129,140,248,0.12);' +
      'border:1px solid rgba(129,140,248,0.3);border-radius:6px;color:#818cf8;font-size:12px;cursor:pointer;';
    exportBtn.onclick = function() { _replayExport(); };
    body.appendChild(exportBtn);

    panel.appendChild(body);
    return panel;
  }

  function _updateReplayProgress() {
    var progressEl = document.getElementById('replay-progress-text');
    var seekEl = document.getElementById('replay-seek');
    if (!progressEl) return;

    var rec = _replayRecording;
    if (!rec || !rec.messages || !rec.messages.length) {
      progressEl.textContent = 'Message 0/0 â€” 00:00/00:00';
      return;
    }

    var total = rec.messages.length;
    var current = 0;
    if (_replayPlayer) {
      try { current = _replayPlayer.currentIndex() || 0; } catch (e) { current = 0; }
    }

    var elapsed = 0;
    var duration = 0;
    if (rec.messages.length > 1) {
      var t0 = rec.messages[0].ts || 0;
      var tEnd = rec.messages[rec.messages.length - 1].ts || 0;
      var tCur = rec.messages[current] ? (rec.messages[current].ts || t0) : t0;
      duration = (tEnd - t0) / 1000;
      elapsed = (tCur - t0) / 1000;
    }

    function fmtTime(s) {
      s = Math.max(0, Math.round(s));
      return String(Math.floor(s / 60)).padStart(2, '0') + ':' + String(s % 60).padStart(2, '0');
    }

    progressEl.textContent = 'Message ' + (current + 1) + '/' + total + ' â€” ' + fmtTime(elapsed) + '/' + fmtTime(duration);

    if (seekEl) {
      seekEl.value = total > 1 ? Math.round((current / (total - 1)) * 100) : 0;
    }
  }

  function _replaySetStatus(status, color) {
    var statusEl = document.getElementById('replay-status');
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.style.color = color || '#f472b6';
    }
  }

  function _replayStartRecording() {
    var R = typeof Replay !== 'undefined' ? Replay : null;
    if (!R) { showNotification('Replay module not loaded', 'error'); return; }
    if (_replayState === 'recording') { showNotification('Already recording', 'warning'); return; }

    try {
      _replayRecorder = R.createRecorder();
      _replayState = 'recording';
      _replayRecording = null;
      _replaySetStatus('RECORDING', '#ef4444');
      showNotification('Protocol recording started', 'info');
    } catch (e) {
      showNotification('Failed to start recording: ' + e.message, 'error');
    }
  }

  function _replayStop() {
    if (_replayState === 'recording' && _replayRecorder) {
      try {
        _replayRecording = _replayRecorder.stop ? _replayRecorder.stop() : _replayRecorder;
        _replayState = 'stopped';
        _replaySetStatus('STOPPED', '#facc15');
        showNotification('Recording stopped', 'success');
      } catch (e) {
        showNotification('Failed to stop recording: ' + e.message, 'error');
      }
    } else if (_replayState === 'playing' || _replayState === 'paused') {
      if (_replayPlayer) {
        try { _replayPlayer.stop(); } catch (e) { /* noop */ }
      }
      if (_replayUpdateInterval) { clearInterval(_replayUpdateInterval); _replayUpdateInterval = null; }
      _replayState = 'stopped';
      _replaySetStatus('STOPPED', '#facc15');
    }
  }

  function _replayPlayPause() {
    var R = typeof Replay !== 'undefined' ? Replay : null;
    if (!R) { showNotification('Replay module not loaded', 'error'); return; }

    if (_replayState === 'idle' || (!_replayRecording && _replayState !== 'playing' && _replayState !== 'paused')) {
      showNotification('No recording available. Record first.', 'warning');
      return;
    }

    if (_replayState === 'stopped' || _replayState === 'recording') {
      // If still recording, stop first
      if (_replayState === 'recording') _replayStop();
      if (!_replayRecording) { showNotification('No recording to play', 'warning'); return; }

      try {
        _replayPlayer = R.createPlayer(_replayRecording);
        _replayPlayer.play();
        _replayState = 'playing';
        _replaySetStatus('PLAYING', '#22c55e');

        var playBtn = document.getElementById('replay-play-btn');
        if (playBtn) playBtn.innerHTML = '&#9646;&#9646; Pause';

        // Periodic progress update
        _replayUpdateInterval = setInterval(function() {
          _updateReplayProgress();
          if (_replayPlayer && _replayPlayer.ended && _replayPlayer.ended()) {
            clearInterval(_replayUpdateInterval);
            _replayUpdateInterval = null;
            _replayState = 'stopped';
            _replaySetStatus('STOPPED', '#facc15');
            var pb = document.getElementById('replay-play-btn');
            if (pb) pb.innerHTML = '&#9654; Play';
          }
        }, 250);
      } catch (e) {
        showNotification('Failed to play recording: ' + e.message, 'error');
      }
    } else if (_replayState === 'playing') {
      if (_replayPlayer) {
        try { _replayPlayer.pause(); } catch (e) { /* noop */ }
      }
      _replayState = 'paused';
      _replaySetStatus('PAUSED', '#facc15');
      var playBtn = document.getElementById('replay-play-btn');
      if (playBtn) playBtn.innerHTML = '&#9654; Play';
    } else if (_replayState === 'paused') {
      if (_replayPlayer) {
        try { _replayPlayer.play(); } catch (e) { /* noop */ }
      }
      _replayState = 'playing';
      _replaySetStatus('PLAYING', '#22c55e');
      var playBtnResume = document.getElementById('replay-play-btn');
      if (playBtnResume) playBtnResume.innerHTML = '&#9646;&#9646; Pause';
    }
  }

  function _replayExport() {
    if (!_replayRecording) {
      showNotification('No recording to export. Record something first.', 'warning');
      return;
    }
    try {
      var jsonStr = JSON.stringify(_replayRecording, null, 2);
      var blob = new Blob([jsonStr], { type: 'application/json' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'zion-replay-' + Date.now() + '.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification('Recording exported!', 'success');
    } catch (e) {
      showNotification('Export failed: ' + e.message, 'error');
    }
  }

  function showReplayPanel() {
    if (typeof document === 'undefined') return;
    if (!replayPanelEl) {
      replayPanelEl = createReplayPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && replayPanelEl) hud.appendChild(replayPanelEl);
    }
    if (!replayPanelEl) return;
    replayPanelEl.style.display = 'flex';
    replayPanelVisible = true;

    var closeBtn = document.getElementById('replay-panel-close');
    if (closeBtn) closeBtn.onclick = hideReplayPanel;

    _updateReplayProgress();
  }

  function hideReplayPanel() {
    if (replayPanelEl) {
      replayPanelEl.style.display = 'none';
    }
    replayPanelVisible = false;
  }

  function toggleReplayPanel() {
    if (replayPanelVisible) {
      hideReplayPanel();
    } else {
      showReplayPanel();
    }
  }

  function getReplayState() {
    return _replayState;
  }

  exports.createReplayPanel = createReplayPanel;
  exports.showReplayPanel = showReplayPanel;
  exports.hideReplayPanel = hideReplayPanel;
  exports.toggleReplayPanel = toggleReplayPanel;
  exports.getReplayState = getReplayState;

  // =============================================================================
  // PANEL D: NEARBY ANCHORS / AR DISCOVERY
  // =============================================================================

  var nearbyAnchorsPanelEl = null;
  var nearbyAnchorsPanelVisible = false;
  var _nearbyAnchorsGeo = null;
  var _nearbyAnchorsEnabled = false;

  function createNearbyAnchorsPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'nearby-anchors-panel';
    panel.className = 'zion-tool-panel nearby-anchors-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #38bdf8;border-radius:12px;' +
      'padding:0;width:440px;max-height:600px;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(0,0,0,0.8);display:none;flex-direction:column;';

    // Header
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:14px 18px;border-bottom:1px solid rgba(56,189,248,0.3);flex-shrink:0;';
    header.innerHTML = '<span style="font-size:18px;margin-right:8px;">&#127981;</span>' +
      '<span style="font-size:16px;font-weight:bold;color:#38bdf8;flex:1;">Nearby Anchors</span>' +
      '<button id="nearby-anchors-close" style="background:rgba(255,255,255,0.1);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:28px;height:28px;cursor:pointer;font-size:14px;line-height:1;">&#215;</button>';
    panel.appendChild(header);

    var body = document.createElement('div');
    body.style.cssText = 'padding:16px;overflow-y:auto;flex:1;';

    // Module guard
    if (typeof Anchors === 'undefined') {
      body.innerHTML = '<div style="text-align:center;color:#888;padding:40px;">Module not loaded: Anchors</div>';
      panel.appendChild(body);
      return panel;
    }

    // Location enable section
    var locationSection = document.createElement('div');
    locationSection.id = 'nearby-location-section';
    locationSection.style.cssText = 'margin-bottom:14px;';

    var enableBtn = document.createElement('button');
    enableBtn.id = 'nearby-enable-location';
    enableBtn.textContent = 'Enable Location';
    enableBtn.style.cssText = 'width:100%;padding:10px;background:rgba(56,189,248,0.15);' +
      'border:1px solid rgba(56,189,248,0.4);border-radius:8px;color:#38bdf8;font-size:13px;cursor:pointer;font-weight:bold;';
    enableBtn.onclick = function() { _nearbyAnchorsRequestLocation(); };
    locationSection.appendChild(enableBtn);

    var locationStatus = document.createElement('div');
    locationStatus.id = 'nearby-location-status';
    locationStatus.style.cssText = 'font-size:11px;color:#888;text-align:center;margin-top:6px;';
    locationStatus.textContent = 'Location not enabled';
    locationSection.appendChild(locationStatus);

    body.appendChild(locationSection);

    // Safety warning area
    var safetyEl = document.createElement('div');
    safetyEl.id = 'nearby-safety-warning';
    safetyEl.style.cssText = 'background:rgba(251,191,36,0.08);border:1px solid rgba(251,191,36,0.3);' +
      'border-radius:8px;padding:10px;margin-bottom:14px;font-size:11px;color:#fbbf24;display:none;';
    body.appendChild(safetyEl);

    // Walking Warmth display
    var warmthEl = document.createElement('div');
    warmthEl.id = 'nearby-warmth';
    warmthEl.style.cssText = 'display:none;background:rgba(56,189,248,0.08);border:1px solid rgba(56,189,248,0.2);' +
      'border-radius:8px;padding:10px;margin-bottom:14px;';
    warmthEl.innerHTML = '<div style="font-size:11px;color:#888;margin-bottom:4px;text-transform:uppercase;letter-spacing:0.05em;">Walking Warmth</div>' +
      '<div id="nearby-warmth-value" style="font-size:22px;font-weight:bold;color:#38bdf8;">0</div>' +
      '<div style="font-size:11px;color:#666;margin-top:2px;">anchors discovered on foot</div>';
    body.appendChild(warmthEl);

    // Anchor list
    var listSection = document.createElement('div');
    listSection.id = 'nearby-anchor-list';
    listSection.innerHTML = '<div style="text-align:center;color:#666;font-size:12px;padding:20px;">Enable location to discover nearby anchors</div>';
    body.appendChild(listSection);

    panel.appendChild(body);
    return panel;
  }

  function _nearbyAnchorsRequestLocation() {
    var A = typeof Anchors !== 'undefined' ? Anchors : null;
    if (!A) { showNotification('Anchors module not loaded', 'error'); return; }

    var statusEl = document.getElementById('nearby-location-status');
    var enableBtn = document.getElementById('nearby-enable-location');
    if (statusEl) statusEl.textContent = 'Requesting location...';

    try {
      A.requestLocation(function(result) {
        if (result && result.geo) {
          _nearbyAnchorsGeo = result.geo;
          _nearbyAnchorsEnabled = true;
          if (statusEl) statusEl.textContent = 'Location enabled: ' +
            result.geo.lat.toFixed(4) + ', ' + result.geo.lon.toFixed(4);
          if (enableBtn) {
            enableBtn.textContent = 'Location Active';
            enableBtn.style.background = 'rgba(34,197,94,0.15)';
            enableBtn.style.borderColor = 'rgba(34,197,94,0.4)';
            enableBtn.style.color = '#22c55e';
          }
          // Show warmth + safety
          var warmthEl = document.getElementById('nearby-warmth');
          if (warmthEl) warmthEl.style.display = 'block';

          var safetyEl = document.getElementById('nearby-safety-warning');
          if (safetyEl && A.SAFETY && A.SAFETY.getWarningMessage) {
            var warning = A.SAFETY.getWarningMessage(result.geo);
            if (warning) {
              safetyEl.textContent = '&#9888; ' + warning;
              safetyEl.style.display = 'block';
            }
          }

          _nearbyAnchorsRefresh();
        } else {
          // Location denied or failed
          _nearbyAnchorsEnabled = false;
          if (statusEl) statusEl.textContent = 'Location denied or unavailable';
          if (enableBtn) {
            enableBtn.textContent = 'Enable Location';
          }
          showNotification('Location access denied', 'warning');
        }
      });
    } catch (e) {
      if (statusEl) statusEl.textContent = 'Location error: ' + e.message;
      _nearbyAnchorsEnabled = false;
      showNotification('Location request failed: ' + e.message, 'error');
    }
  }

  function _nearbyAnchorsRefresh() {
    var A = typeof Anchors !== 'undefined' ? Anchors : null;
    if (!A || !_nearbyAnchorsGeo) return;

    var listEl = document.getElementById('nearby-anchor-list');
    if (!listEl) return;

    // Get anchors from world state
    var State = typeof window !== 'undefined' ? window.State : null;
    var allAnchors = [];
    if (State && State.getLiveState) {
      var liveState = State.getLiveState();
      if (liveState && liveState.anchors) {
        allAnchors = Object.values(liveState.anchors);
      }
    }

    var nearby = [];
    try {
      nearby = A.getNearby(_nearbyAnchorsGeo, allAnchors, 500) || [];
    } catch (e) { nearby = []; }

    // Sort by distance
    nearby.sort(function(a, b) {
      var dA = 9999, dB = 9999;
      try { dA = A.getDistance(_nearbyAnchorsGeo.lat, _nearbyAnchorsGeo.lon, a.geo.lat, a.geo.lon); } catch (ex) {}
      try { dB = A.getDistance(_nearbyAnchorsGeo.lat, _nearbyAnchorsGeo.lon, b.geo.lat, b.geo.lon); } catch (ex) {}
      return dA - dB;
    });

    // Update walking warmth
    var warmthVal = document.getElementById('nearby-warmth-value');
    if (warmthVal) warmthVal.textContent = nearby.length;

    // Render anchor cards
    var typeIcons = {};
    try {
      if (A.TYPES) {
        typeIcons = A.TYPES;
      }
    } catch (e) {}

    if (nearby.length === 0) {
      listEl.innerHTML = '<div style="text-align:center;color:#666;font-size:12px;padding:20px;">No anchors within 500m</div>';
      return;
    }

    var html = '<div style="font-size:11px;color:#888;text-transform:uppercase;letter-spacing:0.05em;margin-bottom:8px;">' +
      nearby.length + ' anchor' + (nearby.length !== 1 ? 's' : '') + ' nearby</div>';

    nearby.forEach(function(anchor) {
      var dist = 0;
      try {
        dist = Math.round(A.getDistance(_nearbyAnchorsGeo.lat, _nearbyAnchorsGeo.lon,
          anchor.geo.lat, anchor.geo.lon));
      } catch (e) {}
      var typeIcon = (anchor.type && typeIcons[anchor.type]) ? typeIcons[anchor.type] : '&#127981;';
      var inRange = false;
      try { inRange = A.isInRange(_nearbyAnchorsGeo, anchor); } catch (ex) {}

      html += '<div class="nearby-anchor-card" style="display:flex;align-items:center;gap:10px;' +
        'padding:10px;margin-bottom:8px;background:rgba(' + (inRange ? '56,189,248' : '255,255,255') +
        ',0.04);border:1px solid rgba(' + (inRange ? '56,189,248' : '255,255,255') + ',0.12);' +
        'border-radius:8px;transition:background 0.2s;">' +
        '<div style="font-size:22px;width:32px;text-align:center;">' + typeIcon + '</div>' +
        '<div style="flex:1;">' +
        '<div style="font-size:13px;color:#e0e0e0;font-weight:bold;">' + (anchor.name || 'Unnamed Anchor') + '</div>' +
        '<div style="font-size:11px;color:#666;">' + (anchor.zone || 'unknown zone') + '</div>' +
        '</div>' +
        '<div style="text-align:right;font-size:12px;">' +
        '<div style="color:' + (dist < 100 ? '#22c55e' : dist < 300 ? '#38bdf8' : '#888') + ';font-weight:bold;">' +
        dist + 'm</div>' +
        (inRange ? '<div style="font-size:10px;color:#22c55e;">IN RANGE</div>' : '') +
        '</div></div>';
    });

    listEl.innerHTML = html;
  }

  function showNearbyAnchorsPanel() {
    if (typeof document === 'undefined') return;
    if (!nearbyAnchorsPanelEl) {
      nearbyAnchorsPanelEl = createNearbyAnchorsPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && nearbyAnchorsPanelEl) hud.appendChild(nearbyAnchorsPanelEl);
    }
    if (!nearbyAnchorsPanelEl) return;
    nearbyAnchorsPanelEl.style.display = 'flex';
    nearbyAnchorsPanelVisible = true;

    var closeBtn = document.getElementById('nearby-anchors-close');
    if (closeBtn) closeBtn.onclick = hideNearbyAnchorsPanel;

    if (_nearbyAnchorsEnabled && _nearbyAnchorsGeo) {
      _nearbyAnchorsRefresh();
    }
  }

  function hideNearbyAnchorsPanel() {
    if (nearbyAnchorsPanelEl) {
      nearbyAnchorsPanelEl.style.display = 'none';
    }
    nearbyAnchorsPanelVisible = false;
  }

  function toggleNearbyAnchorsPanel() {
    if (nearbyAnchorsPanelVisible) {
      hideNearbyAnchorsPanel();
    } else {
      showNearbyAnchorsPanel();
    }
  }

  exports.createNearbyAnchorsPanel = createNearbyAnchorsPanel;
  exports.showNearbyAnchorsPanel = showNearbyAnchorsPanel;
  exports.hideNearbyAnchorsPanel = hideNearbyAnchorsPanel;
  exports.toggleNearbyAnchorsPanel = toggleNearbyAnchorsPanel;

  // =============================================================================
  // AMENDMENT VOTING PANEL â€” Constitutional Amendment Proposals & Voting
  // =============================================================================

  var amendmentPanelEl = null;
  var amendmentPanelVisible = false;
  var amendmentCallback = null;
  var _amendmentActiveTab = 'active'; // 'active' | 'propose' | 'history'

  /**
   * Initialize the amendment panel with a callback for submitting protocol messages.
   * @param {Function} callback - fn(action, data) where action is
   *   'propose_amendment', 'vote_amendment', or 'refresh'
   */
  function initAmendmentPanel(callback) {
    amendmentCallback = callback || null;
  }

  /**
   * Format a countdown string from now until a closing date string.
   * @param {string} closingDateStr - ISO-8601 date string
   * @returns {string} Human-readable countdown
   */
  function _amendmentCountdown(closingDateStr) {
    var now = Date.now();
    var closes = new Date(closingDateStr).getTime();
    var diff = closes - now;
    if (!isFinite(diff) || diff <= 0) return 'Voting closed';
    var days = Math.floor(diff / 86400000);
    var hours = Math.floor((diff % 86400000) / 3600000);
    if (days > 0) return days + 'd ' + hours + 'h remaining';
    var mins = Math.floor((diff % 3600000) / 60000);
    if (hours > 0) return hours + 'h ' + mins + 'm remaining';
    return mins + 'm remaining';
  }

  /**
   * Compute a simple tally from a votes array.
   * @param {Array} votes - [{vote, spark_weight}, ...]
   * @returns {{forWeight: number, againstWeight: number, total: number, pct: number}}
   */
  function _amendmentTally(votes) {
    var forWeight = 0;
    var againstWeight = 0;
    var i;
    for (i = 0; i < votes.length; i++) {
      var v = votes[i];
      var w = v.spark_weight || 1;
      if (v.vote === 'for') forWeight += w;
      else if (v.vote === 'against') againstWeight += w;
    }
    var total = forWeight + againstWeight;
    var pct = total > 0 ? Math.round((forWeight / total) * 100) : 0;
    return { forWeight: forWeight, againstWeight: againstWeight, total: total, pct: pct };
  }

  /**
   * Render the tab bar HTML for the amendment panel.
   * @param {string} activeTab
   * @returns {string} HTML string
   */
  function _amendmentTabBar(activeTab) {
    var tabs = [
      { id: 'active', label: 'Active Votes' },
      { id: 'propose', label: 'Propose' },
      { id: 'history', label: 'History' }
    ];
    var html = '<div style="display:flex;gap:4px;margin-bottom:16px;border-bottom:1px solid rgba(218,165,32,0.25);padding-bottom:8px;">';
    tabs.forEach(function(tab) {
      var isActive = tab.id === activeTab;
      html += '<button class="amend-tab-btn" data-tab="' + tab.id + '" style="padding:6px 16px;border:none;border-radius:6px 6px 0 0;cursor:pointer;font-size:13px;font-weight:bold;' +
        (isActive
          ? 'background:rgba(218,165,32,0.25);color:#daa520;border-bottom:2px solid #daa520;'
          : 'background:transparent;color:#888;border-bottom:2px solid transparent;') +
        '">' + tab.label + '</button>';
    });
    html += '</div>';
    return html;
  }

  /**
   * Render the list of active (open) amendments.
   * @param {Array} amendments - amendment records
   * @param {string} currentUser - current player ID (for vote tracking)
   * @returns {string} HTML string
   */
  function _renderActiveAmendments(amendments, currentUser) {
    var open = amendments.filter(function(a) { return a.status === 'open'; });
    if (open.length === 0) {
      return '<div style="text-align:center;color:#888;padding:30px;font-style:italic;">' +
        'No active amendments. Be the first to propose one!</div>';
    }
    var html = '';
    open.forEach(function(a) {
      var tally = _amendmentTally(a.votes || []);
      var countdown = _amendmentCountdown(a.voting_closes_at);
      var userVote = null;
      (a.votes || []).forEach(function(v) {
        if (v.from === currentUser) userVote = v.vote;
      });
      var barWidth = Math.min(100, tally.pct);
      html += '<div class="amend-card" style="background:rgba(218,165,32,0.07);border:1px solid rgba(218,165,32,0.25);' +
        'border-radius:8px;padding:14px;margin-bottom:14px;">';
      // Title & proposer
      html += '<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:6px;">';
      html += '<div style="font-size:15px;font-weight:bold;color:#daa520;flex:1;margin-right:10px;">' + _htmlEsc(a.title) + '</div>';
      html += '<div style="font-size:10px;color:#888;white-space:nowrap;">' + countdown + '</div>';
      html += '</div>';
      // Proposer
      html += '<div style="font-size:11px;color:#aaa;margin-bottom:8px;">Proposed by <span style="color:#b0e0e6;">' + _htmlEsc(a.proposed_by) + '</span></div>';
      // Description (truncated)
      if (a.description) {
        var desc = a.description.length > 180 ? a.description.slice(0, 180) + '...' : a.description;
        html += '<div style="font-size:12px;color:#ccc;margin-bottom:10px;line-height:1.5;">' + _htmlEsc(desc) + '</div>';
      }
      // Vote bar
      html += '<div style="margin-bottom:10px;">';
      html += '<div style="display:flex;justify-content:space-between;font-size:11px;color:#aaa;margin-bottom:3px;">';
      html += '<span style="color:#4ade80;">For: ' + tally.forWeight + ' Spark</span>';
      html += '<span style="color:#f87171;">Against: ' + tally.againstWeight + ' Spark</span>';
      html += '</div>';
      html += '<div style="height:6px;background:rgba(255,255,255,0.08);border-radius:3px;overflow:hidden;">';
      html += '<div style="height:100%;width:' + barWidth + '%;background:linear-gradient(90deg,#4ade80,#22c55e);border-radius:3px;transition:width 0.4s ease;"></div>';
      html += '</div>';
      html += '<div style="font-size:10px;color:#888;margin-top:3px;">' + tally.total + ' total Spark weight from ' + (a.votes || []).length + ' voter(s) Â· ' + tally.pct + '% for</div>';
      html += '</div>';
      // Vote buttons
      if (userVote) {
        var voteColor = userVote === 'for' ? '#4ade80' : '#f87171';
        html += '<div style="font-size:12px;color:' + voteColor + ';font-weight:bold;">You voted: ' + userVote.toUpperCase() + '</div>';
      } else {
        html += '<div style="display:flex;gap:8px;">';
        html += '<button class="amend-vote-btn" data-amendment-id="' + _htmlEsc(a.id) + '" data-vote="for" style="flex:1;padding:7px;background:rgba(74,222,128,0.15);' +
          'border:1px solid #4ade80;border-radius:6px;color:#4ade80;font-weight:bold;cursor:pointer;font-size:12px;">For</button>';
        html += '<button class="amend-vote-btn" data-amendment-id="' + _htmlEsc(a.id) + '" data-vote="against" style="flex:1;padding:7px;background:rgba(248,113,113,0.15);' +
          'border:1px solid #f87171;border-radius:6px;color:#f87171;font-weight:bold;cursor:pointer;font-size:12px;">Against</button>';
        html += '</div>';
      }
      html += '</div>';
    });
    return html;
  }

  /**
   * Render the propose amendment form.
   * @returns {string} HTML string
   */
  function _renderProposeForm() {
    return '<div id="amend-propose-form" style="display:flex;flex-direction:column;gap:12px;">' +
      '<div style="font-size:11px;color:#aaa;line-height:1.6;background:rgba(218,165,32,0.07);padding:10px;border-radius:6px;border-left:3px solid #daa520;">' +
        'Proposals require a 7-day discussion period. Amendments cannot remove player rights, close the source code, ' +
        'require physical movement, retroactively punish players, or distinguish between player types (Â§7.5).' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Title *</label>' +
        '<input id="amend-title" type="text" maxlength="120" placeholder="Short, descriptive title..." ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:13px;">' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Description &amp; Rationale *</label>' +
        '<textarea id="amend-description" rows="4" maxlength="2000" placeholder="Explain the amendment and why it improves ZION..." ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:13px;resize:vertical;"></textarea>' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Proposed Changes (diff format) *</label>' +
        '<textarea id="amend-diff" rows="4" maxlength="4000" placeholder="+ Add this line&#10;- Remove this line&#10;  Context line..." ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:12px;font-family:monospace;resize:vertical;"></textarea>' +
      '</div>' +
      '<div>' +
        '<label style="display:block;font-size:12px;color:#daa520;margin-bottom:4px;">Discussion Period (days, min 7)</label>' +
        '<input id="amend-days" type="number" min="7" max="90" value="7" ' +
          'style="width:100%;box-sizing:border-box;padding:8px;background:rgba(0,0,0,0.4);border:1px solid rgba(218,165,32,0.4);' +
          'border-radius:6px;color:#fff;font-size:13px;">' +
      '</div>' +
      '<div id="amend-error" style="display:none;color:#f87171;font-size:12px;background:rgba(248,113,113,0.1);padding:8px;border-radius:6px;"></div>' +
      '<button id="amend-submit-btn" style="padding:10px;background:linear-gradient(135deg,#b8860b,#daa520);border:none;' +
        'border-radius:8px;color:#000;font-weight:bold;cursor:pointer;font-size:14px;">Submit Proposal</button>' +
    '</div>';
  }

  /**
   * Render amendment history (closed amendments).
   * @param {Array} amendments - amendment records
   * @returns {string} HTML string
   */
  function _renderAmendmentHistory(amendments) {
    var closed = amendments.filter(function(a) { return a.status === 'closed'; });
    if (closed.length === 0) {
      return '<div style="text-align:center;color:#888;padding:30px;font-style:italic;">No closed amendments yet.</div>';
    }
    // Most recent first
    var sorted = closed.slice().sort(function(a, b) {
      return new Date(b.closed_at || b.proposed_at) - new Date(a.closed_at || a.proposed_at);
    });
    var html = '';
    sorted.forEach(function(a) {
      var tally = a.tally || _amendmentTally(a.votes || []);
      var forW = tally.for_weight !== undefined ? tally.for_weight : (tally.forWeight || 0);
      var againstW = tally.against_weight !== undefined ? tally.against_weight : (tally.againstWeight || 0);
      var totalVoters = tally.total_voters !== undefined ? tally.total_voters : ((a.votes || []).length);
      var resultColor = a.result === 'approved' ? '#4ade80' : '#f87171';
      var resultIcon = a.result === 'approved' ? '&#10003;' : '&#10007;';
      html += '<div class="amend-history-card" style="background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);' +
        'border-left:3px solid ' + resultColor + ';border-radius:8px;padding:12px;margin-bottom:10px;">';
      html += '<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:4px;">';
      html += '<div style="font-size:14px;font-weight:bold;color:#ddd;">' + _htmlEsc(a.title) + '</div>';
      html += '<div style="font-size:13px;color:' + resultColor + ';font-weight:bold;white-space:nowrap;margin-left:10px;">' + resultIcon + ' ' + (a.result || 'unknown').toUpperCase() + '</div>';
      html += '</div>';
      html += '<div style="font-size:11px;color:#888;margin-bottom:6px;">by ' + _htmlEsc(a.proposed_by) + ' &nbsp;|&nbsp; ' +
        (a.closed_at ? new Date(a.closed_at).toLocaleDateString() : '?') + '</div>';
      html += '<div style="font-size:11px;color:#aaa;">For: ' + forW + ' Spark &nbsp;|&nbsp; Against: ' + againstW + ' Spark &nbsp;|&nbsp; ' + totalVoters + ' voter(s)</div>';
      html += '</div>';
    });
    return html;
  }

  /**
   * Simple HTML escape helper.
   * @param {string} str
   * @returns {string}
   */
  function _htmlEsc(str) {
    if (str == null) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  /**
   * Create the amendment panel DOM element.
   * @returns {HTMLElement|null}
   */
  function createAmendmentPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'amendment-panel';
    panel.className = 'zion-tool-panel amendment-panel';
    panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(10,14,26,0.97);border:2px solid #daa520;border-radius:12px;' +
      'padding:0;width:600px;max-height:82vh;pointer-events:auto;z-index:300;' +
      'box-shadow:0 8px 32px rgba(218,165,32,0.2);display:none;flex-direction:column;overflow:hidden;';

    // Header
    var header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;padding:16px 20px;border-bottom:1px solid rgba(218,165,32,0.3);flex-shrink:0;background:rgba(218,165,32,0.06);';
    header.innerHTML = '<span style="font-size:20px;margin-right:10px;">&#9878;</span>' +
      '<span style="font-size:17px;font-weight:bold;color:#daa520;flex:1;">Constitutional Amendments</span>' +
      '<button id="amendment-panel-close" style="background:rgba(255,255,255,0.08);color:#aaa;border:1px solid rgba(255,255,255,0.15);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;line-height:1;display:flex;align-items:center;justify-content:center;">&#215;</button>';
    panel.appendChild(header);

    // Body (scrollable)
    var body = document.createElement('div');
    body.id = 'amendment-panel-body';
    body.style.cssText = 'flex:1;overflow-y:auto;padding:18px 20px;';
    body.innerHTML = _amendmentTabBar(_amendmentActiveTab) +
      '<div id="amendment-panel-content"><div style="text-align:center;color:#888;padding:30px;">Loading...</div></div>';
    panel.appendChild(body);

    return panel;
  }

  /**
   * Refresh the content area of the amendment panel based on current tab.
   * @param {Array} amendments - list of amendment records
   * @param {string} currentUser - current player ID
   */
  function refreshAmendmentPanel(amendments, currentUser) {
    if (typeof document === 'undefined') return;
    var content = document.getElementById('amendment-panel-content');
    if (!content) return;

    var arr = amendments || [];

    if (_amendmentActiveTab === 'active') {
      content.innerHTML = _renderActiveAmendments(arr, currentUser || '');
      _wireAmendmentVoteButtons(currentUser);
    } else if (_amendmentActiveTab === 'propose') {
      content.innerHTML = _renderProposeForm();
      _wireProposalForm(currentUser);
    } else if (_amendmentActiveTab === 'history') {
      content.innerHTML = _renderAmendmentHistory(arr);
    }
  }

  /**
   * Wire click handlers for vote buttons in the active amendments view.
   * @param {string} currentUser
   */
  function _wireAmendmentVoteButtons(currentUser) {
    if (typeof document === 'undefined') return;
    var btns = document.querySelectorAll('.amend-vote-btn');
    btns.forEach(function(btn) {
      btn.onclick = function() {
        var amendId = btn.getAttribute('data-amendment-id');
        var voteVal = btn.getAttribute('data-vote');
        if (amendmentCallback && amendId && voteVal) {
          amendmentCallback('vote_amendment', {
            amendment_id: amendId,
            vote: voteVal
          });
        }
      };
    });
  }

  /**
   * Wire the proposal form submission.
   * @param {string} currentUser
   */
  function _wireProposalForm(currentUser) {
    if (typeof document === 'undefined') return;
    var submitBtn = document.getElementById('amend-submit-btn');
    var errDiv = document.getElementById('amend-error');
    if (!submitBtn) return;
    submitBtn.onclick = function() {
      var title = (document.getElementById('amend-title') || {}).value || '';
      var desc = (document.getElementById('amend-description') || {}).value || '';
      var diff = (document.getElementById('amend-diff') || {}).value || '';
      var daysVal = parseInt((document.getElementById('amend-days') || {}).value || '7', 10);

      // Client-side validation
      var err = '';
      if (!title.trim()) err = 'Title is required.';
      else if (title.trim().length < 5) err = 'Title must be at least 5 characters.';
      else if (!desc.trim()) err = 'Description is required.';
      else if (desc.trim().length < 20) err = 'Description must be at least 20 characters.';
      else if (!diff.trim()) err = 'Diff text is required.';
      else if (isNaN(daysVal) || daysVal < 7) err = 'Discussion period must be at least 7 days.';

      if (err) {
        if (errDiv) { errDiv.textContent = err; errDiv.style.display = 'block'; }
        return;
      }
      if (errDiv) errDiv.style.display = 'none';

      if (amendmentCallback) {
        amendmentCallback('propose_amendment', {
          title: title.trim(),
          description: desc.trim(),
          diff_text: diff.trim(),
          discussion_period_days: Math.max(7, daysVal)
        });
      }
    };
  }

  /**
   * Wire the tab buttons in the amendment panel.
   * @param {Array} amendments
   * @param {string} currentUser
   */
  function _wireAmendmentTabs(amendments, currentUser) {
    if (typeof document === 'undefined') return;
    var tabs = document.querySelectorAll('.amend-tab-btn');
    tabs.forEach(function(btn) {
      btn.onclick = function() {
        _amendmentActiveTab = btn.getAttribute('data-tab') || 'active';
        // Re-render tab bar
        var body = document.getElementById('amendment-panel-body');
        if (body) {
          body.innerHTML = _amendmentTabBar(_amendmentActiveTab) +
            '<div id="amendment-panel-content"></div>';
        }
        refreshAmendmentPanel(amendments, currentUser);
        _wireAmendmentTabs(amendments, currentUser);
      };
    });
  }

  /**
   * Show the amendment panel.
   * @param {Array} amendments - current amendment records from state
   * @param {string} currentUser - current player ID
   */
  function showAmendmentPanel(amendments, currentUser) {
    if (typeof document === 'undefined') return;

    if (!amendmentPanelEl) {
      amendmentPanelEl = createAmendmentPanel();
      var hud = document.querySelector('#zion-hud');
      if (hud && amendmentPanelEl) {
        hud.appendChild(amendmentPanelEl);
      } else if (amendmentPanelEl) {
        document.body.appendChild(amendmentPanelEl);
      }
    }
    if (!amendmentPanelEl) return;

    _amendmentActiveTab = 'active';
    amendmentPanelEl.style.display = 'flex';
    amendmentPanelVisible = true;

    // Render initial content
    var body = document.getElementById('amendment-panel-body');
    if (body) {
      body.innerHTML = _amendmentTabBar(_amendmentActiveTab) +
        '<div id="amendment-panel-content"></div>';
    }
    refreshAmendmentPanel(amendments || [], currentUser || '');
    _wireAmendmentTabs(amendments || [], currentUser || '');

    // Close button
    var closeBtn = document.getElementById('amendment-panel-close');
    if (closeBtn) closeBtn.onclick = hideAmendmentPanel;
  }

  /**
   * Hide the amendment panel.
   */
  function hideAmendmentPanel() {
    if (amendmentPanelEl) {
      amendmentPanelEl.style.display = 'none';
    }
    amendmentPanelVisible = false;
  }

  /**
   * Toggle the amendment panel.
   * @param {Array} amendments
   * @param {string} currentUser
   */
  function toggleAmendmentPanel(amendments, currentUser) {
    if (amendmentPanelVisible) {
      hideAmendmentPanel();
    } else {
      showAmendmentPanel(amendments, currentUser);
    }
  }

  exports.initAmendmentPanel = initAmendmentPanel;
  exports.showAmendmentPanel = showAmendmentPanel;
  exports.hideAmendmentPanel = hideAmendmentPanel;
  exports.toggleAmendmentPanel = toggleAmendmentPanel;
  exports.refreshAmendmentPanel = refreshAmendmentPanel;
  exports.createAmendmentPanel = createAmendmentPanel;
  // Exported helpers (used by tests)
  exports._amendmentCountdown = _amendmentCountdown;
  exports._amendmentTally = _amendmentTally;
  exports._renderActiveAmendments = _renderActiveAmendments;
  exports._renderAmendmentHistory = _renderAmendmentHistory;
  exports._renderProposeForm = _renderProposeForm;
  exports._htmlEsc = _htmlEsc;
  exports._amendmentTabBar = _amendmentTabBar;

  // =============================================================================
  // LEADERBOARD PANEL
  // =============================================================================

  var leaderboardPanelEl = null;
  var leaderboardVisible = false;
  var _lbActiveCategory = 'wealth';
  var _lbActivePeriod = 'all_time';
  var _lbDisplayCount = 10;
  var _lbGameData = null;

  var LB_CATEGORIES = [
    { id: 'wealth',      label: 'Wealth',      icon: '\u2728' },
    { id: 'quests',      label: 'Quests',       icon: '\u2694' },
    { id: 'exploration', label: 'Exploration',  icon: '\ud83d\uddfa' },
    { id: 'guilds',      label: 'Guilds',       icon: '\ud83d\udee1' },
    { id: 'reputation',  label: 'Reputation',   icon: '\u2b50' },
    { id: 'combined',    label: 'Combined',     icon: '\ud83c\udfc6' }
  ];

  var LB_PERIODS = [
    { id: 'all_time', label: 'All Time' },
    { id: 'daily',    label: 'Today'    },
    { id: 'weekly',   label: 'Week'     }
  ];

  var LB_COUNTS = [10, 25, 50];

  function _lbGetLeaderboards() {
    if (typeof Leaderboards === 'undefined') return null;
    return Leaderboards;
  }

  function _lbMakeTabBar(tabs, activeId, onSelect) {
    var bar = document.createElement('div');
    bar.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;margin-bottom:14px;';
    tabs.forEach(function(tab) {
      var btn = document.createElement('button');
      btn.textContent = (tab.icon ? tab.icon + ' ' : '') + tab.label;
      btn.dataset.tabId = tab.id;
      var isActive = tab.id === activeId;
      btn.style.cssText = 'padding:6px 12px;border-radius:6px;font-size:12px;cursor:pointer;font-weight:bold;transition:all 0.2s;' +
        (isActive
          ? 'background:rgba(218,165,32,0.25);border:1px solid #DAA520;color:#DAA520;'
          : 'background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);color:#A0978E;');
      btn.onclick = function() { onSelect(tab.id); };
      btn.onmouseover = function() {
        if (tab.id !== activeId) {
          btn.style.background = 'rgba(218,165,32,0.1)';
          btn.style.borderColor = 'rgba(218,165,32,0.4)';
          btn.style.color = '#D4C5B3';
        }
      };
      btn.onmouseout = function() {
        if (tab.id !== activeId) {
          btn.style.background = 'rgba(255,255,255,0.05)';
          btn.style.borderColor = 'rgba(255,255,255,0.15)';
          btn.style.color = '#A0978E';
        }
      };
      bar.appendChild(btn);
    });
    return bar;
  }

  function _lbRenderRows(rows, playerId) {
    var table = document.createElement('div');
    table.style.cssText = 'display:flex;flex-direction:column;gap:4px;';

    if (!rows || rows.length === 0) {
      var empty = document.createElement('div');
      empty.textContent = 'No data available.';
      empty.style.cssText = 'color:#A0978E;text-align:center;padding:20px;font-size:14px;';
      table.appendChild(empty);
      return table;
    }

    // Header row
    var header = document.createElement('div');
    header.style.cssText = 'display:grid;grid-template-columns:50px 1fr 120px;gap:8px;padding:6px 10px;' +
      'color:#A0978E;font-size:11px;font-weight:bold;text-transform:uppercase;letter-spacing:0.5px;' +
      'border-bottom:1px solid rgba(255,255,255,0.1);margin-bottom:4px;';
    header.innerHTML = '<span>Rank</span><span>Player</span><span style="text-align:right">Score</span>';
    table.appendChild(header);

    rows.forEach(function(row) {
      var isMe = row.isHighlighted || (playerId && row.id === playerId);
      var rowEl = document.createElement('div');
      rowEl.style.cssText = 'display:grid;grid-template-columns:50px 1fr 120px;gap:8px;padding:8px 10px;' +
        'border-radius:6px;font-size:13px;align-items:center;transition:background 0.15s;' +
        (isMe
          ? 'background:rgba(218,165,32,0.15);border:1px solid rgba(218,165,32,0.35);'
          : 'background:rgba(255,255,255,0.03);border:1px solid transparent;');

      rowEl.onmouseover = function() {
        if (!isMe) rowEl.style.background = 'rgba(255,255,255,0.06)';
      };
      rowEl.onmouseout = function() {
        if (!isMe) rowEl.style.background = 'rgba(255,255,255,0.03)';
      };

      // Rank badge
      var rankEl = document.createElement('span');
      var rankNum = row.rank;
      var rankStyle = 'font-weight:bold;';
      if (rankNum === 1) rankStyle += 'color:#FFD700;font-size:16px;';
      else if (rankNum === 2) rankStyle += 'color:#C0C0C0;font-size:15px;';
      else if (rankNum === 3) rankStyle += 'color:#CD7F32;font-size:14px;';
      else rankStyle += 'color:#6B6560;';
      rankEl.style.cssText = rankStyle;
      rankEl.textContent = rankNum === 1 ? '\ud83e\udd47' : (rankNum === 2 ? '\ud83e\udd48' : (rankNum === 3 ? '\ud83e\udd49' : '#' + rankNum));

      // Name
      var nameEl = document.createElement('span');
      nameEl.textContent = (row.tag ? '[' + row.tag + '] ' : '') + (row.name || row.id);
      nameEl.style.cssText = 'color:' + (isMe ? '#DAA520' : '#E8E0D8') + ';overflow:hidden;text-overflow:ellipsis;white-space:nowrap;';

      // Score
      var scoreEl = document.createElement('span');
      scoreEl.textContent = row.label || row.score;
      scoreEl.style.cssText = 'text-align:right;color:' + (isMe ? '#DAA520' : '#A0978E') + ';font-family:monospace;font-size:12px;';

      // Tier badge (reputation)
      if (row.tier) {
        var tierEl = document.createElement('span');
        tierEl.textContent = ' ' + row.tier;
        tierEl.style.cssText = 'font-size:10px;color:#818cf8;';
        nameEl.appendChild(tierEl);
      }

      // Guild extra info
      if (row.level !== undefined) {
        var lvlEl = document.createElement('span');
        lvlEl.textContent = ' Lv.' + row.level;
        lvlEl.style.cssText = 'font-size:10px;color:#6B6560;';
        nameEl.appendChild(lvlEl);
      }

      rowEl.appendChild(rankEl);
      rowEl.appendChild(nameEl);
      rowEl.appendChild(scoreEl);
      table.appendChild(rowEl);
    });

    return table;
  }

  function _lbRefreshContent(container) {
    var LB = _lbGetLeaderboards();
    if (!LB) {
      container.innerHTML = '<div style="text-align:center;color:#A0978E;padding:40px;">Leaderboards module not loaded.</div>';
      return;
    }

    var data = _lbGameData || {};
    var periodOpts = { period: _lbActivePeriod };
    var rankings = [];

    switch (_lbActiveCategory) {
      case 'wealth':
        rankings = LB.getWealthRankings(data.economy || {}, periodOpts);
        break;
      case 'quests':
        rankings = LB.getQuestRankings(data.quests || {}, periodOpts);
        break;
      case 'exploration':
        rankings = LB.getExplorationRankings(data.discoveries || [], periodOpts);
        break;
      case 'guilds':
        rankings = LB.getGuildRankings(data.guilds || [], periodOpts);
        break;
      case 'reputation':
        rankings = LB.getReputationRankings(data.reputation || {}, periodOpts);
        break;
      case 'combined':
        rankings = LB.getCombinedRankings(data, periodOpts);
        break;
      default:
        rankings = [];
    }

    var currentPlayerId = (typeof window !== 'undefined' && window._currentPlayerId) ? window._currentPlayerId : null;
    var fmtOpts = {
      count: _lbDisplayCount,
      allowedCounts: [_lbDisplayCount],
      highlightId: currentPlayerId,
      showBreakdown: _lbActiveCategory === 'combined'
    };

    var rows = LB.formatLeaderboard(rankings, fmtOpts);

    // Player's own rank block
    var playerRankInfo = null;
    if (currentPlayerId && LB.getPlayerRank) {
      var categoryData;
      switch (_lbActiveCategory) {
        case 'wealth': categoryData = data.economy || {}; break;
        case 'quests': categoryData = data.quests || {}; break;
        case 'exploration': categoryData = data.discoveries || []; break;
        case 'guilds': categoryData = data.guilds || []; break;
        case 'reputation': categoryData = data.reputation || {}; break;
        case 'combined': categoryData = data; break;
        default: categoryData = {};
      }
      playerRankInfo = LB.getPlayerRank(currentPlayerId, _lbActiveCategory, categoryData, periodOpts);
    }

    // Render
    container.innerHTML = '';

    // Player rank banner
    if (playerRankInfo) {
      var rankBanner = document.createElement('div');
      rankBanner.style.cssText = 'background:rgba(218,165,32,0.08);border:1px solid rgba(218,165,32,0.2);' +
        'border-radius:6px;padding:10px 14px;margin-bottom:14px;display:flex;align-items:center;justify-content:space-between;';
      var yourRankText = playerRankInfo.rank
        ? 'Your rank: #' + playerRankInfo.rank + ' of ' + playerRankInfo.total
        : 'You are not ranked yet';
      var yourScoreText = playerRankInfo.score ? '  (' + (playerRankInfo.label || playerRankInfo.score) + ')' : '';
      rankBanner.innerHTML =
        '<span style="color:#A0978E;font-size:12px;">You</span>' +
        '<span style="color:#DAA520;font-weight:bold;font-size:14px;">' + yourRankText + '</span>' +
        '<span style="color:#6B6560;font-size:12px;">' + yourScoreText + '</span>';
      container.appendChild(rankBanner);
    }

    // Rows
    container.appendChild(_lbRenderRows(rows, currentPlayerId));
  }

  function _lbBuildPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.id = 'leaderboard-panel';
    panel.style.cssText =
      'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'width:680px;max-height:85vh;' +
      'background:rgba(15,12,10,0.97);border:2px solid rgba(218,165,32,0.4);border-radius:10px;' +
      'z-index:300;pointer-events:auto;display:none;flex-direction:column;' +
      'box-shadow:0 12px 48px rgba(0,0,0,0.85);';

    // ---- Header ----
    var headerDiv = document.createElement('div');
    headerDiv.style.cssText =
      'display:flex;align-items:center;padding:16px 20px;border-bottom:1px solid rgba(218,165,32,0.2);flex-shrink:0;';
    headerDiv.innerHTML =
      '<span style="font-size:20px;margin-right:10px;">\ud83c\udfc6</span>' +
      '<span style="font-size:18px;font-weight:bold;color:#DAA520;flex:1;">Leaderboards</span>';

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\xd7';
    closeBtn.style.cssText =
      'background:rgba(255,255,255,0.08);color:#aaa;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;width:30px;height:30px;cursor:pointer;font-size:16px;line-height:1;';
    closeBtn.onclick = hideLeaderboardPanel;
    closeBtn.onmouseover = function() {
      closeBtn.style.background = 'rgba(218,165,32,0.2)';
      closeBtn.style.borderColor = '#DAA520';
      closeBtn.style.color = '#DAA520';
    };
    closeBtn.onmouseout = function() {
      closeBtn.style.background = 'rgba(255,255,255,0.08)';
      closeBtn.style.borderColor = 'rgba(255,255,255,0.2)';
      closeBtn.style.color = '#aaa';
    };
    headerDiv.appendChild(closeBtn);
    panel.appendChild(headerDiv);

    // ---- Controls bar ----
    var controlsDiv = document.createElement('div');
    controlsDiv.style.cssText =
      'padding:12px 20px;border-bottom:1px solid rgba(255,255,255,0.06);flex-shrink:0;';

    // Category tabs
    var categoryBar = _lbMakeTabBar(LB_CATEGORIES, _lbActiveCategory, function(id) {
      _lbActiveCategory = id;
      _lbRebuildPanel();
    });
    controlsDiv.appendChild(categoryBar);

    // Period + count row
    var subRow = document.createElement('div');
    subRow.style.cssText = 'display:flex;align-items:center;gap:8px;margin-top:8px;';

    var periodLabel = document.createElement('span');
    periodLabel.textContent = 'Period:';
    periodLabel.style.cssText = 'color:#6B6560;font-size:11px;';
    subRow.appendChild(periodLabel);

    LB_PERIODS.forEach(function(p) {
      var btn = document.createElement('button');
      btn.textContent = p.label;
      var isActive = p.id === _lbActivePeriod;
      btn.style.cssText =
        'padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;' +
        (isActive
          ? 'background:rgba(218,165,32,0.2);border:1px solid rgba(218,165,32,0.5);color:#DAA520;'
          : 'background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.1);color:#6B6560;');
      btn.onclick = function() {
        _lbActivePeriod = p.id;
        _lbRebuildPanel();
      };
      subRow.appendChild(btn);
    });

    // Spacer
    var spacer = document.createElement('span');
    spacer.style.cssText = 'flex:1;';
    subRow.appendChild(spacer);

    var countLabel = document.createElement('span');
    countLabel.textContent = 'Show:';
    countLabel.style.cssText = 'color:#6B6560;font-size:11px;';
    subRow.appendChild(countLabel);

    LB_COUNTS.forEach(function(c) {
      var btn = document.createElement('button');
      btn.textContent = String(c);
      var isActive = c === _lbDisplayCount;
      btn.style.cssText =
        'padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer;' +
        (isActive
          ? 'background:rgba(218,165,32,0.2);border:1px solid rgba(218,165,32,0.5);color:#DAA520;'
          : 'background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.1);color:#6B6560;');
      btn.onclick = function() {
        _lbDisplayCount = c;
        _lbRebuildPanel();
      };
      subRow.appendChild(btn);
    });

    controlsDiv.appendChild(subRow);
    panel.appendChild(controlsDiv);

    // ---- Content area ----
    var contentDiv = document.createElement('div');
    contentDiv.id = 'leaderboard-content';
    contentDiv.style.cssText = 'flex:1;overflow-y:auto;padding:16px 20px;';
    panel.appendChild(contentDiv);

    // ---- Footer ----
    var footerDiv = document.createElement('div');
    footerDiv.style.cssText =
      'padding:10px 20px;border-top:1px solid rgba(255,255,255,0.06);flex-shrink:0;' +
      'display:flex;justify-content:space-between;align-items:center;';
    footerDiv.innerHTML =
      '<span style="color:#6B6560;font-size:11px;">Rankings update in real time</span>' +
      '<span id="lb-player-count" style="color:#6B6560;font-size:11px;"></span>';
    panel.appendChild(footerDiv);

    return panel;
  }

  function _lbRebuildPanel() {
    if (!leaderboardPanelEl) return;
    leaderboardPanelEl.parentNode && leaderboardPanelEl.parentNode.removeChild(leaderboardPanelEl);
    leaderboardPanelEl = _lbBuildPanel();
    if (!leaderboardPanelEl) return;
    document.body.appendChild(leaderboardPanelEl);
    leaderboardPanelEl.style.display = 'flex';
    var content = document.getElementById('leaderboard-content');
    if (content) _lbRefreshContent(content);
  }

  /**
   * Show the leaderboard panel.
   * @param {Object} [gameData] - { economy, quests, discoveries, guilds, reputation }
   * @param {Object} [opts] - { category, period, count }
   */
  function showLeaderboardPanel(gameData, opts) {
    if (typeof document === 'undefined') return;
    opts = opts || {};

    if (gameData) _lbGameData = gameData;
    if (opts.category) _lbActiveCategory = opts.category;
    if (opts.period) _lbActivePeriod = opts.period;
    if (opts.count) _lbDisplayCount = opts.count;

    if (leaderboardPanelEl && leaderboardPanelEl.parentNode) {
      // Already open â€” just refresh content
      var content = document.getElementById('leaderboard-content');
      if (content) _lbRefreshContent(content);
      leaderboardPanelEl.style.display = 'flex';
      leaderboardVisible = true;
      return;
    }

    leaderboardPanelEl = _lbBuildPanel();
    if (!leaderboardPanelEl) return;

    document.body.appendChild(leaderboardPanelEl);
    leaderboardPanelEl.style.display = 'flex';
    leaderboardVisible = true;

    var content = document.getElementById('leaderboard-content');
    if (content) _lbRefreshContent(content);
  }

  /**
   * Hide the leaderboard panel.
   */
  function hideLeaderboardPanel() {
    if (leaderboardPanelEl) {
      leaderboardPanelEl.style.display = 'none';
    }
    leaderboardVisible = false;
  }

  /**
   * Toggle leaderboard panel.
   * @param {Object} [gameData]
   * @param {Object} [opts]
   */
  function toggleLeaderboardPanel(gameData, opts) {
    if (leaderboardVisible) {
      hideLeaderboardPanel();
    } else {
      showLeaderboardPanel(gameData, opts);
    }
  }

  /**
   * Refresh leaderboard with new data without closing.
   * @param {Object} gameData
   */
  function refreshLeaderboardPanel(gameData) {
    if (gameData) _lbGameData = gameData;
    if (!leaderboardVisible || !leaderboardPanelEl) return;
    var content = document.getElementById('leaderboard-content');
    if (content) _lbRefreshContent(content);
  }

  exports.showLeaderboardPanel = showLeaderboardPanel;
  exports.hideLeaderboardPanel = hideLeaderboardPanel;
  exports.toggleLeaderboardPanel = toggleLeaderboardPanel;
  exports.refreshLeaderboardPanel = refreshLeaderboardPanel;


})(typeof module !== 'undefined' ? module.exports : (window.HUD = {}));


// LAZY_LOAD_START: xr
// xr.js
(function(exports) {
  // WebXR integration for VR/AR
  let xrSession = null;
  let xrReferenceSpace = null;
  let lastPosition = { x: 0, y: 0, z: 0 };
  let lastCheckTime = 0;

  /**
   * Initialize XR and check capabilities
   * @returns {Promise<object>} - {vrSupported, arSupported}
   */
  async function initXR() {
    if (typeof navigator === 'undefined' || !navigator.xr) {
      console.warn('WebXR not available');
      return { vrSupported: false, arSupported: false };
    }

    try {
      const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      const arSupported = await navigator.xr.isSessionSupported('immersive-ar');

      console.log('XR capabilities:', { vrSupported, arSupported });

      return { vrSupported, arSupported };
    } catch (err) {
      console.error('Error checking XR support:', err);
      return { vrSupported: false, arSupported: false };
    }
  }

  /**
   * Enter VR mode
   * @param {THREE.WebGLRenderer} renderer - Three.js renderer
   * @param {THREE.Scene} scene - Three.js scene
   * @param {THREE.Camera} camera - Three.js camera
   * @returns {Promise<void>}
   */
  async function enterVR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    try {
      // Request VR session
      xrSession = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'bounded-floor']
      });

      // Enable XR on renderer
      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('VR session ended');
      });

      console.log('Entered VR mode');

      // Set up reference space
      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      // Start render loop
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter VR:', err);
      throw err;
    }
  }

  /**
   * Enter AR mode
   * @param {THREE.WebGLRenderer} renderer - Three.js renderer
   * @param {THREE.Scene} scene - Three.js scene
   * @param {THREE.Camera} camera - Three.js camera
   * @returns {Promise<void>}
   */
  async function enterAR(renderer, scene, camera) {
    if (!navigator.xr) {
      throw new Error('WebXR not available');
    }

    if (!renderer || !scene || !camera) {
      throw new Error('Renderer, scene, and camera required');
    }

    // Show safety warning first
    const proceed = await showSafetyWarning();
    if (!proceed) {
      console.log('AR session cancelled by user');
      return;
    }

    try {
      // Request AR session
      xrSession = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['local-floor'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });

      // Enable XR on renderer
      await renderer.xr.setSession(xrSession);
      renderer.xr.enabled = true;

      xrSession.addEventListener('end', () => {
        xrSession = null;
        renderer.xr.enabled = false;
        console.log('AR session ended');
      });

      console.log('Entered AR mode');

      // Set up reference space
      xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');

      // Make scene background transparent for AR
      scene.background = null;

      // Start render loop with speed checking
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          // Check speed periodically
          if (timestamp - lastCheckTime > 1000) { // Every second
            const pose = frame.getViewerPose(xrReferenceSpace);
            if (pose) {
              const position = pose.transform.position;
              const deltaTime = (timestamp - lastCheckTime) / 1000;
              const speedCheck = checkSpeed(position, lastPosition, deltaTime);

              if (!speedCheck.safe) {
                console.warn(`Speed too high: ${speedCheck.speed.toFixed(1)} km/h. Pausing AR.`);
                // Pause rendering or show warning
                showSpeedWarning(speedCheck.speed);
                return; // Skip rendering this frame
              }

              lastPosition = { x: position.x, y: position.y, z: position.z };
              lastCheckTime = timestamp;
            }
          }

          renderer.render(scene, camera);
        }
      });

    } catch (err) {
      console.error('Failed to enter AR:', err);
      throw err;
    }
  }

  /**
   * Exit XR mode
   */
  async function exitXR() {
    if (xrSession) {
      await xrSession.end();
      xrSession = null;
      xrReferenceSpace = null;
      console.log('Exited XR mode');
    }
  }

  /**
   * Check movement speed (safety feature for AR)
   * @param {object} position - Current position {x, y, z}
   * @param {object} lastPosition - Previous position {x, y, z}
   * @param {number} deltaTime - Time elapsed in seconds
   * @returns {object} - {safe: boolean, speed: number (km/h)}
   */
  function checkSpeed(position, lastPosition, deltaTime) {
    if (!position || !lastPosition || deltaTime === 0) {
      return { safe: true, speed: 0 };
    }

    const dx = position.x - lastPosition.x;
    const dy = position.y - lastPosition.y;
    const dz = position.z - lastPosition.z;

    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    const speedMetersPerSecond = distance / deltaTime;
    const speedKmPerHour = speedMetersPerSecond * 3.6;

    const MAX_SAFE_SPEED = 25; // km/h (walking/jogging speed)

    return {
      safe: speedKmPerHour <= MAX_SAFE_SPEED,
      speed: speedKmPerHour
    };
  }

  /**
   * Show safety warning for AR (required per 8.6)
   * @returns {Promise<boolean>} - User accepted or not
   */
  function showSafetyWarning() {
    if (typeof document === 'undefined') {
      return Promise.resolve(true);
    }

    return new Promise((resolve) => {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        color: white;
        font-family: Arial, sans-serif;
      `;

      const content = document.createElement('div');
      content.style.cssText = `
        max-width: 500px;
        padding: 30px;
        background: rgba(20, 20, 20, 0.95);
        border-radius: 12px;
        border: 2px solid #ff6347;
        text-align: center;
      `;

      content.innerHTML = `
        <h2 style="color: #ff6347; margin-bottom: 20px;">AR Safety Warning</h2>
        <p style="margin-bottom: 15px; line-height: 1.6;">
          Please be aware of your surroundings while using AR mode.
        </p>
        <ul style="text-align: left; margin-bottom: 20px; line-height: 1.8;">
          <li>Do not use AR while driving or operating vehicles</li>
          <li>Stay aware of obstacles, traffic, and other hazards</li>
          <li>AR will pause automatically if moving faster than 25 km/h</li>
          <li>Use in safe, well-lit areas</li>
          <li>Take breaks if you feel disoriented</li>
        </ul>
        <p style="margin-bottom: 25px; font-weight: bold; color: #ffa500;">
          By continuing, you acknowledge these safety guidelines.
        </p>
        <div>
          <button id="ar-accept" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #4af;
            color: white;
            cursor: pointer;
            font-weight: bold;
          ">I Understand</button>
          <button id="ar-cancel" style="
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            background: #666;
            color: white;
            cursor: pointer;
          ">Cancel</button>
        </div>
      `;

      overlay.appendChild(content);
      document.body.appendChild(overlay);

      document.getElementById('ar-accept').addEventListener('click', () => {
        overlay.remove();
        resolve(true);
      });

      document.getElementById('ar-cancel').addEventListener('click', () => {
        overlay.remove();
        resolve(false);
      });
    });
  }

  /**
   * Show speed warning overlay
   * @param {number} speed - Current speed in km/h
   */
  function showSpeedWarning(speed) {
    if (typeof document === 'undefined') return;

    let warningEl = document.getElementById('ar-speed-warning');
    if (!warningEl) {
      warningEl = document.createElement('div');
      warningEl.id = 'ar-speed-warning';
      warningEl.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 12px;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        z-index: 10001;
        border: 4px solid white;
      `;
      document.body.appendChild(warningEl);
    }

    warningEl.innerHTML = `
      <div style="margin-bottom: 15px;">SPEED TOO HIGH</div>
      <div style="font-size: 48px; margin-bottom: 15px;">${speed.toFixed(0)} km/h</div>
      <div style="font-size: 18px;">AR paused for safety</div>
      <div style="font-size: 14px; margin-top: 10px;">Slow down to resume</div>
    `;

    warningEl.style.display = 'block';

    // Hide after a few seconds if speed normalized
    setTimeout(() => {
      if (warningEl) {
        warningEl.style.display = 'none';
      }
    }, 3000);
  }

  // Export public API
  exports.initXR = initXR;
  exports.enterVR = enterVR;
  exports.enterAR = enterAR;
  exports.exitXR = exitXR;
  exports.checkSpeed = checkSpeed;
  exports.showSafetyWarning = showSafetyWarning;

})(typeof module !== 'undefined' ? module.exports : (window.XR = {}));

// LAZY_LOAD_END: xr

// audio.js
(function(exports) {
  // Procedural audio system using Web Audio API
  // All audio is generated procedurally - no external files

  var audioContext = null;
  var masterGain = null;
  var isMuted = false;
  var currentAmbient = null;
  var volumeLevels = { master: 0.5, music: 0.5, sfx: 0.5 };
  var activeNoiseSources = []; // Global tracker for all white noise sources

  /**
   * Initialize audio context
   * @returns {AudioContext|null}
   */
  function initAudio() {
    if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') {
      console.warn('Web Audio API not available');
      return null;
    }

    // Defer AudioContext creation until first user gesture to avoid browser warnings
    var resumeEvents = ['click', 'touchstart', 'keydown'];
    function createOnGesture() {
      if (audioContext) return;
      try {
        audioContext = new (AudioContext || webkitAudioContext)();
        masterGain = audioContext.createGain();
        if (masterGain) {
          masterGain.connect(audioContext.destination);
          masterGain.gain.value = 0.15;
        }
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        console.log('Audio system initialized (after user gesture)');
      } catch (err) {
        console.error('Failed to initialize audio:', err);
      }
      resumeEvents.forEach(function(evt) {
        document.removeEventListener(evt, createOnGesture);
      });
    }
    resumeEvents.forEach(function(evt) {
      document.addEventListener(evt, createOnGesture, { once: false });
    });

    console.log('Audio system deferred until user gesture');
    return true;
  }

  /**
   * Create brown noise buffer (warm, natural 1/fÂ² spectrum)
   * @returns {AudioBufferSourceNode|null}
   */
  function createWhiteNoise(maxDurationSec) {
    if (!audioContext) return null;

    try {
      const bufferSize = 2 * audioContext.sampleRate;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const output = noiseBuffer.getChannelData(0);

      // Brown noise: integrate white noise for warm 1/fÂ² rolloff
      var lastOut = 0;
      for (let i = 0; i < bufferSize; i++) {
        var white = Math.random() * 2 - 1;
        lastOut = (lastOut + (0.02 * white)) / 1.02;
        output[i] = lastOut * 3.5; // normalize amplitude
      }

      const whiteNoise = audioContext.createBufferSource();
      whiteNoise.buffer = noiseBuffer;
      whiteNoise.loop = true;
      whiteNoise.start();

      // Track globally so we can kill orphans
      activeNoiseSources.push(whiteNoise);
      whiteNoise.onended = function() {
        var idx = activeNoiseSources.indexOf(whiteNoise);
        if (idx !== -1) activeNoiseSources.splice(idx, 1);
      };

      // Safety cutoff: auto-stop after maxDurationSec (default 60s)
      var safeDur = maxDurationSec || 60;
      setTimeout(function() {
        try { whiteNoise.stop(); } catch(e) {}
        try { whiteNoise.disconnect(); } catch(e) {}
      }, safeDur * 1000);

      return whiteNoise;
    } catch (err) {
      console.error('Error creating white noise:', err);
      return null;
    }
  }

  /**
   * Stop and disconnect all tracked noise sources (safety net for orphans)
   */
  function killAllNoiseSources() {
    for (var i = 0; i < activeNoiseSources.length; i++) {
      try { activeNoiseSources[i].stop(); } catch(e) {}
      try { activeNoiseSources[i].disconnect(); } catch(e) {}
    }
    activeNoiseSources = [];
  }

  /**
   * Play zone-specific ambient sound
   * @param {string} zone - Zone identifier
   */
  function playAmbient(zone) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Stop current ambient
    if (currentAmbient) {
      stopAmbient();
    }

    try {
      switch (zone) {
        case 'nexus':
          currentAmbient = playNexusAmbient();
          break;
        case 'gardens':
          currentAmbient = playGardensAmbient();
          break;
        case 'athenaeum':
          currentAmbient = playAthenaeumAmbient();
          break;
        case 'studio':
          currentAmbient = playStudioAmbient();
          break;
        case 'wilds':
          currentAmbient = playWildsAmbient();
          break;
        case 'agora':
          currentAmbient = playAgoraAmbient();
          break;
        case 'commons':
          currentAmbient = playCommonsAmbient();
          break;
        case 'arena':
          currentAmbient = playArenaAmbient();
          break;
        default:
          currentAmbient = null;
      }
    } catch (err) {
      console.error('Error playing ambient:', err);
    }
  }

  /**
   * Stop current ambient sound
   */
  function stopAmbient() {
    if (!currentAmbient) return;

    try {
      // Stop all oscillators
      if (currentAmbient.oscillators && Array.isArray(currentAmbient.oscillators)) {
        currentAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      // Stop and disconnect all nodes
      if (currentAmbient.nodes && Array.isArray(currentAmbient.nodes)) {
        currentAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      // Disconnect gain
      if (currentAmbient.gain && currentAmbient.gain.disconnect) {
        try { currentAmbient.gain.disconnect(); } catch (e) {}
      }

      // Clear all intervals
      if (currentAmbient.intervals && Array.isArray(currentAmbient.intervals)) {
        currentAmbient.intervals.forEach(id => clearInterval(id));
      }

      // Clear all timeouts
      if (currentAmbient.timeouts && Array.isArray(currentAmbient.timeouts)) {
        currentAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      // Call cleanup function if exists
      if (currentAmbient.cleanup && typeof currentAmbient.cleanup === 'function') {
        currentAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping ambient:', err);
    }

    currentAmbient = null;
    killAllNoiseSources();
  }

  /**
   * NEXUS - Sacred gathering place
   * Deep drone + ethereal pad + crystalline chimes
   */
  function playNexusAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Deep resonant drone - C2 (65Hz) with octave harmonics
      const drone1 = audioContext.createOscillator();
      const drone2 = audioContext.createOscillator();
      const droneGain = audioContext.createGain();

      drone1.type = 'sine';
      drone1.frequency.value = 65.41; // C2
      drone2.type = 'sine';
      drone2.frequency.value = 130.81; // C3

      droneGain.gain.value = 0.03;

      drone1.connect(droneGain);
      drone2.connect(droneGain);
      droneGain.connect(masterGain);

      drone1.start();
      drone2.start();

      oscillators.push(drone1, drone2);
      nodes.push(droneGain);

      // Ethereal pad - C4, E4, G4 triad with slow LFO
      const pad1 = audioContext.createOscillator();
      const pad2 = audioContext.createOscillator();
      const pad3 = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      const padGain = audioContext.createGain();

      pad1.type = 'sine';
      pad1.frequency.value = 261.63; // C4
      pad2.type = 'sine';
      pad2.frequency.value = 329.63; // E4
      pad3.type = 'sine';
      pad3.frequency.value = 392.00; // G4

      lfo.type = 'sine';
      lfo.frequency.value = 0.2; // Slow modulation
      lfoGain.gain.value = 0.01; // Subtle volume modulation

      padGain.gain.value = 0.02;

      lfo.connect(lfoGain);
      lfoGain.connect(padGain.gain);

      pad1.connect(padGain);
      pad2.connect(padGain);
      pad3.connect(padGain);
      padGain.connect(masterGain);

      pad1.start();
      pad2.start();
      pad3.start();
      lfo.start();

      oscillators.push(pad1, pad2, pad3, lfo);
      nodes.push(lfoGain, padGain);

      // Crystalline chimes - random high notes with delays
      function playChime() {
        if (!audioContext || !masterGain) return;

        const chime = audioContext.createOscillator();
        const chimeGain = audioContext.createGain();
        const delay1 = audioContext.createDelay();
        const delay2 = audioContext.createDelay();
        const delayGain1 = audioContext.createGain();
        const delayGain2 = audioContext.createGain();

        chime.type = 'sine';
        chime.frequency.value = 400 + Math.random() * 400;

        chimeGain.gain.value = 0.015;
        chimeGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        delay1.delayTime.value = 0.4;
        delay2.delayTime.value = 0.7;
        delayGain1.gain.value = 0.1;
        delayGain2.gain.value = 0.06;

        chime.connect(chimeGain);
        chimeGain.connect(masterGain);
        chimeGain.connect(delay1);
        chimeGain.connect(delay2);
        delay1.connect(delayGain1);
        delay2.connect(delayGain2);
        delayGain1.connect(masterGain);
        delayGain2.connect(masterGain);

        chime.start();
        chime.stop(audioContext.currentTime + 2.5);

        const nextChime = setTimeout(playChime, 8000 + Math.random() * 12000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(playChime, 2000);
      timeouts.push(firstChime);

      return { oscillators, nodes, timeouts };
    } catch (err) {
      console.error('Error in nexus ambient:', err);
      return null;
    }
  }

  /**
   * GARDENS - Lush natural space
   * Bird chorus + gentle stream + breeze + crickets + rustling leaves
   */
  function playGardensAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Gentle stream - filtered white noise with LFO
      const stream = createWhiteNoise();
      if (stream) {
        const streamFilter = audioContext.createBiquadFilter();
        const streamLfo = audioContext.createOscillator();
        const streamLfoGain = audioContext.createGain();
        const streamGain = audioContext.createGain();

        streamFilter.type = 'lowpass';
        streamFilter.frequency.value = 400;

        streamLfo.type = 'sine';
        streamLfo.frequency.value = 0.5;
        streamLfoGain.gain.value = 100; // Modulate filter frequency

        streamGain.gain.value = 0.025;

        streamLfo.connect(streamLfoGain);
        streamLfoGain.connect(streamFilter.frequency);

        stream.connect(streamFilter);
        streamFilter.connect(streamGain);
        streamGain.connect(masterGain);

        streamLfo.start();

        nodes.push(stream, streamFilter, streamLfo, streamLfoGain, streamGain);
      }

      // Breeze - very low filtered noise
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 200;
        breezeGain.gain.value = 0.012;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Bird chorus - multiple chirp generators
      function chirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 600 + Math.random() * 1200;

        const duration = 0.1 + Math.random() * 0.2;
        birdGain.gain.value = 0.06;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(chirp, 500 + Math.random() * 3500);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 3; i++) {
        const firstChirp = setTimeout(chirp, Math.random() * 2000);
        timeouts.push(firstChirp);
      }

      // Crickets - oscillating high frequency with AM
      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 4500;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 20; // 20 Hz modulation
      cricketAmGain.gain.value = 0.015;

      cricketGain.gain.value = 0.015;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      nodes.push(cricket, cricketAm, cricketAmGain, cricketGain);

      // Rustling leaves
      function rustle() {
        if (!audioContext || !masterGain) return;

        const noise = createWhiteNoise(2);
        if (noise) {
          const rustleFilter = audioContext.createBiquadFilter();
          const rustleGain = audioContext.createGain();

          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 2000;
          rustleFilter.Q.value = 2;

          rustleGain.gain.value = 0.04;
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

          noise.connect(rustleFilter);
          rustleFilter.connect(rustleGain);
          rustleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (noise.stop) noise.stop();
              if (rustleFilter.disconnect) rustleFilter.disconnect();
              if (rustleGain.disconnect) rustleGain.disconnect();
            } catch (e) {}
          }, 400);
        }

        const nextRustle = setTimeout(rustle, 2000 + Math.random() * 3000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 1000);
      timeouts.push(firstRustle);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in gardens ambient:', err);
      return null;
    }
  }

  /**
   * ATHENAEUM - Library/knowledge hall
   * Deep silence + page turning + quill writing + distant footsteps + clock ticking
   */
  function playAthenaeumAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Room tone - very quiet
      const roomTone = createWhiteNoise();
      if (roomTone) {
        const roomGain = audioContext.createGain();
        roomGain.gain.value = 0.01;

        roomTone.connect(roomGain);
        roomGain.connect(masterGain);

        nodes.push(roomTone, roomGain);
      }

      // Page turning
      function turnPage() {
        if (!audioContext || !masterGain) return;

        const page = createWhiteNoise(2);
        if (page) {
          const pageFilter = audioContext.createBiquadFilter();
          const pageGain = audioContext.createGain();

          pageFilter.type = 'highpass';
          pageFilter.frequency.value = 2000;

          pageGain.gain.value = 0.03;
          pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

          page.connect(pageFilter);
          pageFilter.connect(pageGain);
          pageGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (page.stop) page.stop();
              if (pageFilter.disconnect) pageFilter.disconnect();
              if (pageGain.disconnect) pageGain.disconnect();
            } catch (e) {}
          }, 150);
        }

        const nextPage = setTimeout(turnPage, 8000 + Math.random() * 7000);
        timeouts.push(nextPage);
      }

      const firstPage = setTimeout(turnPage, 3000);
      timeouts.push(firstPage);

      // Quill writing - intermittent
      function writeQuill() {
        if (!audioContext || !masterGain) return;

        const quill = createWhiteNoise(2);
        if (quill) {
          const quillFilter = audioContext.createBiquadFilter();
          const quillGain = audioContext.createGain();

          quillFilter.type = 'bandpass';
          quillFilter.frequency.value = 3000;
          quillFilter.Q.value = 5;

          quillGain.gain.value = 0.05;

          quill.connect(quillFilter);
          quillFilter.connect(quillGain);
          quillGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (quill.stop) quill.stop();
              if (quillFilter.disconnect) quillFilter.disconnect();
              if (quillGain.disconnect) quillGain.disconnect();
            } catch (e) {}
          }, 200 + Math.random() * 500);
        }

        const nextQuill = setTimeout(writeQuill, 5000 + Math.random() * 10000);
        timeouts.push(nextQuill);
      }

      const firstQuill = setTimeout(writeQuill, 5000);
      timeouts.push(firstQuill);

      // Distant footsteps
      function footstep() {
        if (!audioContext || !masterGain) return;

        const step = audioContext.createOscillator();
        const stepGain = audioContext.createGain();

        step.type = 'sine';
        step.frequency.value = 60;

        stepGain.gain.value = 0.03;
        stepGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

        step.connect(stepGain);
        stepGain.connect(masterGain);

        step.start();
        step.stop(audioContext.currentTime + 0.05);

        const nextStep = setTimeout(footstep, 5000 + Math.random() * 5000);
        timeouts.push(nextStep);
      }

      const firstStep = setTimeout(footstep, 2000);
      timeouts.push(firstStep);

      // Clock ticking
      function tick() {
        if (!audioContext || !masterGain) return;

        const click = audioContext.createOscillator();
        const clickGain = audioContext.createGain();

        click.type = 'sine';
        click.frequency.value = 800;

        clickGain.gain.value = 0.02;
        clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

        click.connect(clickGain);
        clickGain.connect(masterGain);

        click.start();
        click.stop(audioContext.currentTime + 0.02);
      }

      const tickInterval = setInterval(tick, 1000);
      intervals.push(tickInterval);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in athenaeum ambient:', err);
      return null;
    }
  }

  /**
   * STUDIO - Creative workshop
   * Rhythmic tapping + metallic chimes + creative hum + melodic phrases
   */
  function playStudioAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Creative energy hum - 110Hz with modulation
      const hum = audioContext.createOscillator();
      const humLfo = audioContext.createOscillator();
      const humLfoGain = audioContext.createGain();
      const humGain = audioContext.createGain();

      hum.type = 'sine';
      hum.frequency.value = 110;

      humLfo.type = 'sine';
      humLfo.frequency.value = 0.3;
      humLfoGain.gain.value = 2;

      humGain.gain.value = 0.03;

      humLfo.connect(humLfoGain);
      humLfoGain.connect(hum.frequency);

      hum.connect(humGain);
      humGain.connect(masterGain);

      hum.start();
      humLfo.start();

      oscillators.push(hum, humLfo);
      nodes.push(humLfoGain, humGain);

      // Rhythmic tapping
      function tap() {
        if (!audioContext || !masterGain) return;

        const thud = audioContext.createOscillator();
        const thudGain = audioContext.createGain();

        thud.type = 'sine';
        thud.frequency.value = 100 + Math.random() * 200;

        thudGain.gain.value = 0.05;
        thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

        thud.connect(thudGain);
        thudGain.connect(masterGain);

        thud.start();
        thud.stop(audioContext.currentTime + 0.08);

        const nextTap = setTimeout(tap, 500 + Math.random() * 1500);
        timeouts.push(nextTap);
      }

      const firstTap = setTimeout(tap, 500);
      timeouts.push(firstTap);

      // Metallic chimes
      function chime() {
        if (!audioContext || !masterGain) return;

        const bell = audioContext.createOscillator();
        const bellGain = audioContext.createGain();

        bell.type = 'triangle';
        bell.frequency.value = 500 + Math.random() * 700;

        bellGain.gain.value = 0.04;
        bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);

        bell.connect(bellGain);
        bellGain.connect(masterGain);

        bell.start();
        bell.stop(audioContext.currentTime + 1.2);

        const nextChime = setTimeout(chime, 3000 + Math.random() * 5000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(chime, 2000);
      timeouts.push(firstChime);

      // Melodic phrases
      function melody() {
        if (!audioContext || !masterGain) return;

        const notes = [261.63, 293.66, 329.63, 392.00, 440.00]; // C, D, E, G, A
        const numNotes = 3 + Math.floor(Math.random() * 3);

        for (let i = 0; i < numNotes; i++) {
          const note = audioContext.createOscillator();
          const noteGain = audioContext.createGain();

          note.type = 'sine';
          note.frequency.value = notes[Math.floor(Math.random() * notes.length)];

          const startTime = audioContext.currentTime + i * 0.2;
          noteGain.gain.setValueAtTime(0, startTime);
          noteGain.gain.linearRampToValueAtTime(0.03, startTime + 0.05);
          noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

          note.connect(noteGain);
          noteGain.connect(masterGain);

          note.start(startTime);
          note.stop(startTime + 0.4);
        }

        const nextMelody = setTimeout(melody, 15000 + Math.random() * 15000);
        timeouts.push(nextMelody);
      }

      const firstMelody = setTimeout(melody, 10000);
      timeouts.push(firstMelody);

      return { oscillators, nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in studio ambient:', err);
      return null;
    }
  }

  /**
   * WILDS - Untamed wilderness
   * Heavy wind + wolf howls + thunder + rustling + owl hoots
   */
  function playWildsAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Heavy wind with varying intensity
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 150;
        windGain.gain.value = 0.05;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);

        // Vary wind intensity
        function varyWind() {
          if (!windGain || !audioContext) return;
          const target = 0.05 + Math.random() * 0.06;
          windGain.gain.linearRampToValueAtTime(target, audioContext.currentTime + 3);
        }

        const windInterval = setInterval(varyWind, 4000);
        intervals.push(windInterval);
      }

      // Wolf howls
      function howl() {
        if (!audioContext || !masterGain) return;

        const wolf = audioContext.createOscillator();
        const wolfVibrato = audioContext.createOscillator();
        const wolfVibratoGain = audioContext.createGain();
        const wolfGain = audioContext.createGain();

        wolf.type = 'sine';
        wolf.frequency.value = 400;

        wolfVibrato.type = 'sine';
        wolfVibrato.frequency.value = 5;
        wolfVibratoGain.gain.value = 15;

        wolfGain.gain.value = 0.04;

        wolfVibrato.connect(wolfVibratoGain);
        wolfVibratoGain.connect(wolf.frequency);

        wolf.connect(wolfGain);
        wolfGain.connect(masterGain);

        wolf.start();
        wolfVibrato.start();

        wolf.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 1);
        wolf.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 2);
        wolfGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        wolf.stop(audioContext.currentTime + 2.5);
        wolfVibrato.stop(audioContext.currentTime + 2.5);

        const nextHowl = setTimeout(howl, 20000 + Math.random() * 20000);
        timeouts.push(nextHowl);
      }

      const firstHowl = setTimeout(howl, 5000);
      timeouts.push(firstHowl);

      // Thunder rumble
      function thunder() {
        if (!audioContext || !masterGain) return;

        const rumble = createWhiteNoise(2);
        if (rumble) {
          const rumbleFilter = audioContext.createBiquadFilter();
          const rumbleGain = audioContext.createGain();

          rumbleFilter.type = 'lowpass';
          rumbleFilter.frequency.value = 60;

          rumbleGain.gain.value = 0.04;
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);

          rumble.connect(rumbleFilter);
          rumbleFilter.connect(rumbleGain);
          rumbleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (rumble.stop) rumble.stop();
              if (rumbleFilter.disconnect) rumbleFilter.disconnect();
              if (rumbleGain.disconnect) rumbleGain.disconnect();
            } catch (e) {}
          }, 2500);
        }

        const nextThunder = setTimeout(thunder, 30000 + Math.random() * 30000);
        timeouts.push(nextThunder);
      }

      const firstThunder = setTimeout(thunder, 15000);
      timeouts.push(firstThunder);

      // Rustling underbrush
      function rustle() {
        if (!audioContext || !masterGain) return;

        const brush = createWhiteNoise(2);
        if (brush) {
          const brushFilter = audioContext.createBiquadFilter();
          const brushGain = audioContext.createGain();

          brushFilter.type = 'bandpass';
          brushFilter.frequency.value = 1000;
          brushFilter.Q.value = 2;

          brushGain.gain.value = 0.05;
          brushGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

          brush.connect(brushFilter);
          brushFilter.connect(brushGain);
          brushGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (brush.stop) brush.stop();
              if (brushFilter.disconnect) brushFilter.disconnect();
              if (brushGain.disconnect) brushGain.disconnect();
            } catch (e) {}
          }, 400);
        }

        const nextRustle = setTimeout(rustle, 3000 + Math.random() * 4000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 2000);
      timeouts.push(firstRustle);

      // Owl hoots
      function hoot() {
        if (!audioContext || !masterGain) return;

        // Two-tone hoot
        const hoot1 = audioContext.createOscillator();
        const hoot1Gain = audioContext.createGain();

        hoot1.type = 'sine';
        hoot1.frequency.value = 350;

        hoot1Gain.gain.value = 0.04;
        hoot1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        hoot1.connect(hoot1Gain);
        hoot1Gain.connect(masterGain);

        hoot1.start();
        hoot1.stop(audioContext.currentTime + 0.3);

        // Second hoot
        const hoot2 = audioContext.createOscillator();
        const hoot2Gain = audioContext.createGain();

        hoot2.type = 'sine';
        hoot2.frequency.value = 280;

        hoot2Gain.gain.setValueAtTime(0, audioContext.currentTime + 0.35);
        hoot2Gain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.4);
        hoot2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.7);

        hoot2.connect(hoot2Gain);
        hoot2Gain.connect(masterGain);

        hoot2.start(audioContext.currentTime + 0.35);
        hoot2.stop(audioContext.currentTime + 0.7);

        const nextHoot = setTimeout(hoot, 15000 + Math.random() * 10000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(hoot, 8000);
      timeouts.push(firstHoot);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in wilds ambient:', err);
      return null;
    }
  }

  /**
   * AGORA - Marketplace
   * Crowd murmur + vendor calls + coin sounds + cart wheels
   */
  function playAgoraAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Crowd murmur - bandpass filtered noise with modulation
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdLfo = audioContext.createOscillator();
        const crowdLfoGain = audioContext.createGain();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 500;
        crowdFilter.Q.value = 1;

        crowdLfo.type = 'sine';
        crowdLfo.frequency.value = 0.4;
        crowdLfoGain.gain.value = 0.02;

        crowdGain.gain.value = 0.03;

        crowdLfo.connect(crowdLfoGain);
        crowdLfoGain.connect(crowdGain.gain);

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        crowdLfo.start();

        nodes.push(crowd, crowdFilter, crowdLfo, crowdLfoGain, crowdGain);
      }

      // Vendor calls - short melodic phrases
      function vendorCall() {
        if (!audioContext || !masterGain) return;

        const notes = [220, 247, 262, 294, 330, 349, 392, 440, 494];
        const numNotes = 2 + Math.floor(Math.random() * 2);

        for (let i = 0; i < numNotes; i++) {
          const call = audioContext.createOscillator();
          const callGain = audioContext.createGain();

          call.type = 'sine';
          call.frequency.value = notes[Math.floor(Math.random() * notes.length)];

          const startTime = audioContext.currentTime + i * 0.15;
          callGain.gain.setValueAtTime(0, startTime);
          callGain.gain.linearRampToValueAtTime(0.04, startTime + 0.05);
          callGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

          call.connect(callGain);
          callGain.connect(masterGain);

          call.start(startTime);
          call.stop(startTime + 0.25);
        }

        const nextCall = setTimeout(vendorCall, 8000 + Math.random() * 7000);
        timeouts.push(nextCall);
      }

      const firstCall = setTimeout(vendorCall, 3000);
      timeouts.push(firstCall);

      // Coin sounds
      function coinDrop() {
        if (!audioContext || !masterGain) return;

        const coin = audioContext.createOscillator();
        const coinGain = audioContext.createGain();

        coin.type = 'triangle';
        coin.frequency.value = 2000 + Math.random() * 1000;

        coinGain.gain.value = 0.03;
        coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        coin.connect(coinGain);
        coinGain.connect(masterGain);

        coin.start();
        coin.stop(audioContext.currentTime + 0.15);

        const nextCoin = setTimeout(coinDrop, 3000 + Math.random() * 5000);
        timeouts.push(nextCoin);
      }

      const firstCoin = setTimeout(coinDrop, 2000);
      timeouts.push(firstCoin);

      // Cart wheels rumbling
      function cartRumble() {
        if (!audioContext || !masterGain) return;

        const cart = createWhiteNoise(2);
        if (cart) {
          const cartFilter = audioContext.createBiquadFilter();
          const cartGain = audioContext.createGain();

          cartFilter.type = 'lowpass';
          cartFilter.frequency.value = 80;

          cartGain.gain.value = 0.04;
          cartGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);

          cart.connect(cartFilter);
          cartFilter.connect(cartGain);
          cartGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (cart.stop) cart.stop();
              if (cartFilter.disconnect) cartFilter.disconnect();
              if (cartGain.disconnect) cartGain.disconnect();
            } catch (e) {}
          }, 2500);
        }

        const nextCart = setTimeout(cartRumble, 15000 + Math.random() * 15000);
        timeouts.push(nextCart);
      }

      const firstCart = setTimeout(cartRumble, 5000);
      timeouts.push(firstCart);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in agora ambient:', err);
      return null;
    }
  }

  /**
   * COMMONS - Building/community area
   * Hammering + sawing + chatter + fire crackling
   */
  function playCommonsAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Friendly chatter
      const chatter = createWhiteNoise();
      if (chatter) {
        const chatterFilter = audioContext.createBiquadFilter();
        const chatterGain = audioContext.createGain();

        chatterFilter.type = 'bandpass';
        chatterFilter.frequency.value = 450;
        chatterFilter.Q.value = 1.5;

        chatterGain.gain.value = 0.018;

        chatter.connect(chatterFilter);
        chatterFilter.connect(chatterGain);
        chatterGain.connect(masterGain);

        nodes.push(chatter, chatterFilter, chatterGain);
      }

      // Fire crackling - continuous random bursts
      function crackle() {
        if (!audioContext || !masterGain) return;

        const fire = createWhiteNoise(2);
        if (fire) {
          const fireFilter = audioContext.createBiquadFilter();
          const fireGain = audioContext.createGain();

          fireFilter.type = 'bandpass';
          fireFilter.frequency.value = 1500 + Math.random() * 1500;
          fireFilter.Q.value = 3;

          const gain = 0.01 + Math.random() * 0.02;
          fireGain.gain.value = gain;
          fireGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

          fire.connect(fireFilter);
          fireFilter.connect(fireGain);
          fireGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (fire.stop) fire.stop();
              if (fireFilter.disconnect) fireFilter.disconnect();
              if (fireGain.disconnect) fireGain.disconnect();
            } catch (e) {}
          }, 150);
        }

        const nextCrackle = setTimeout(crackle, 100 + Math.random() * 300);
        timeouts.push(nextCrackle);
      }

      const firstCrackle = setTimeout(crackle, 500);
      timeouts.push(firstCrackle);

      // Hammering - rhythmic with pauses
      let hammerActive = true;
      function hammer() {
        if (!audioContext || !masterGain || !hammerActive) return;

        const thunk = audioContext.createOscillator();
        const thunkGain = audioContext.createGain();

        thunk.type = 'square';
        thunk.frequency.value = 80;

        thunkGain.gain.value = 0.06;
        thunkGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

        thunk.connect(thunkGain);
        thunkGain.connect(masterGain);

        thunk.start();
        thunk.stop(audioContext.currentTime + 0.1);

        const nextHammer = setTimeout(hammer, 800 + Math.random() * 400);
        timeouts.push(nextHammer);
      }

      function toggleHammer() {
        hammerActive = !hammerActive;
        if (hammerActive) {
          hammer();
        }
      }

      const firstHammer = setTimeout(hammer, 1000);
      timeouts.push(firstHammer);

      const hammerToggle = setInterval(toggleHammer, 8000);
      intervals.push(hammerToggle);

      // Sawing - filtered noise sweep
      let sawActive = false;
      function saw() {
        if (!audioContext || !masterGain || !sawActive) return;

        const sawNoise = createWhiteNoise(2);
        if (sawNoise) {
          const sawFilter = audioContext.createBiquadFilter();
          const sawGain = audioContext.createGain();

          sawFilter.type = 'bandpass';
          sawFilter.frequency.value = 400;
          sawFilter.Q.value = 5;

          sawGain.gain.value = 0.04;

          sawNoise.connect(sawFilter);
          sawFilter.connect(sawGain);
          sawGain.connect(masterGain);

          sawFilter.frequency.linearRampToValueAtTime(1000, audioContext.currentTime + 0.5);

          setTimeout(() => {
            try {
              if (sawNoise.stop) sawNoise.stop();
              if (sawFilter.disconnect) sawFilter.disconnect();
              if (sawGain.disconnect) sawGain.disconnect();
            } catch (e) {}
          }, 550);
        }

        const nextSaw = setTimeout(saw, 1000);
        timeouts.push(nextSaw);
      }

      function toggleSaw() {
        sawActive = !sawActive;
        if (sawActive) {
          saw();
        }
      }

      const sawToggle = setInterval(toggleSaw, 6000);
      intervals.push(sawToggle);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in commons ambient:', err);
      return null;
    }
  }

  /**
   * ARENA - Competition grounds
   * Crowd roar + drum beats + clash sounds + horn call
   */
  function playArenaAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];
    const intervals = [];

    try {
      // Crowd roar with periodic swells
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 600;
        crowdFilter.Q.value = 0.8;

        crowdGain.gain.value = 0.035;

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        nodes.push(crowd, crowdFilter, crowdGain);

        // Periodic swells
        function swell() {
          if (!crowdGain || !audioContext) return;
          crowdGain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 2);
          crowdGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 4);
        }

        const swellInterval = setInterval(swell, 12000);
        intervals.push(swellInterval);
      }

      // Drum beats - rhythmic at 120 BPM
      function drumBeat() {
        if (!audioContext || !masterGain) return;

        const drum = audioContext.createOscillator();
        const drumGain = audioContext.createGain();

        drum.type = 'sine';
        drum.frequency.value = 55;

        drumGain.gain.value = 0.08;
        drumGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        drum.connect(drumGain);
        drumGain.connect(masterGain);

        drum.start();
        drum.stop(audioContext.currentTime + 0.15);
      }

      const drumInterval = setInterval(drumBeat, 500); // 120 BPM
      intervals.push(drumInterval);

      // Clash sounds
      function clash() {
        if (!audioContext || !masterGain) return;

        const metal = createWhiteNoise(2);
        if (metal) {
          const metalFilter = audioContext.createBiquadFilter();
          const metalGain = audioContext.createGain();

          metalFilter.type = 'bandpass';
          metalFilter.frequency.value = 3000;
          metalFilter.Q.value = 3;

          metalGain.gain.value = 0.06;
          metalGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

          metal.connect(metalFilter);
          metalFilter.connect(metalGain);
          metalGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (metal.stop) metal.stop();
              if (metalFilter.disconnect) metalFilter.disconnect();
              if (metalGain.disconnect) metalGain.disconnect();
            } catch (e) {}
          }, 250);
        }

        const nextClash = setTimeout(clash, 5000 + Math.random() * 5000);
        timeouts.push(nextClash);
      }

      const firstClash = setTimeout(clash, 3000);
      timeouts.push(firstClash);

      // Horn call
      function hornCall() {
        if (!audioContext || !masterGain) return;

        const horn = audioContext.createOscillator();
        const hornGain = audioContext.createGain();

        horn.type = 'sawtooth';
        horn.frequency.value = 220;

        hornGain.gain.setValueAtTime(0, audioContext.currentTime);
        hornGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.2);
        hornGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.8);
        hornGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);

        horn.connect(hornGain);
        hornGain.connect(masterGain);

        horn.start();
        horn.stop(audioContext.currentTime + 1);

        const nextHorn = setTimeout(hornCall, 20000 + Math.random() * 10000);
        timeouts.push(nextHorn);
      }

      const firstHorn = setTimeout(hornCall, 10000);
      timeouts.push(firstHorn);

      return { nodes, timeouts, intervals };
    } catch (err) {
      console.error('Error in arena ambient:', err);
      return null;
    }
  }

  /**
   * Play UI sound effect
   * @param {string} type - Sound type
   */
  function playSound(type) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (type) {
        case 'chat':
          playChatSound();
          break;
        case 'warp':
          playWarpSound();
          break;
        case 'harvest':
          playHarvestSound();
          break;
        case 'build':
          playBuildSound();
          break;
        case 'trade':
          playTradeSound();
          break;
        case 'trade_request':
          playTradeRequestSound();
          break;
        case 'discover':
          playDiscoverSound();
          break;
        case 'challenge':
          playChallengeSound();
          break;
        case 'levelup':
          playLevelUpSound();
          break;
        case 'level_up':
          playLevelUpSound();
          break;
        case 'error':
          playErrorSound();
          break;
        case 'notification':
          playNotificationSound();
          break;
        case 'craft_complete':
          playCraftCompleteSound();
          break;
        case 'quest_accept':
          playQuestAcceptSound();
          break;
        case 'quest_complete':
          playQuestCompleteSound();
          break;
        case 'item_pickup':
          playItemPickupSound();
          break;
        case 'npc_greet':
          playNPCGreetSound();
          break;
        case 'portal_enter':
          playPortalEnterSound();
          break;
        case 'build_place':
          playBuildPlaceSound();
          break;
        case 'footstep':
          playFootstepSound();
          break;
        case 'zone_enter':
          playZoneEntrySwoosh();
          break;
        case 'shutter':
          playShutterSound();
          break;
        case 'coin':
          playCoinSound();
          break;
        default:
          console.warn('Unknown sound type:', type);
      }
    } catch (err) {
      console.error('Error playing sound:', err);
    }
  }

  /**
   * Chat sound - two-tone blip ascending
   */
  function playChatSound() {
    if (!audioContext || !masterGain) return;

    const blip1 = audioContext.createOscillator();
    const blip1Gain = audioContext.createGain();

    blip1.type = 'sine';
    blip1.frequency.value = 600;

    blip1Gain.gain.value = 0.05;
    blip1Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

    blip1.connect(blip1Gain);
    blip1Gain.connect(masterGain);

    blip1.start();
    blip1.stop(audioContext.currentTime + 0.05);

    const blip2 = audioContext.createOscillator();
    const blip2Gain = audioContext.createGain();

    blip2.type = 'sine';
    blip2.frequency.value = 900;

    blip2Gain.gain.setValueAtTime(0, audioContext.currentTime + 0.05);
    blip2Gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.06);
    blip2Gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

    blip2.connect(blip2Gain);
    blip2Gain.connect(masterGain);

    blip2.start(audioContext.currentTime + 0.05);
    blip2.stop(audioContext.currentTime + 0.1);
  }

  /**
   * Warp sound - sweeping whoosh with reverb
   */
  function playWarpSound() {
    if (!audioContext || !masterGain) return;

    const warp = audioContext.createOscillator();
    const warpGain = audioContext.createGain();
    const delay1 = audioContext.createDelay();
    const delay2 = audioContext.createDelay();
    const delayGain1 = audioContext.createGain();
    const delayGain2 = audioContext.createGain();

    warp.type = 'sawtooth';
    warp.frequency.value = 800;
    warp.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);

    warpGain.gain.value = 0.06;
    warpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    delay1.delayTime.value = 0.1;
    delay2.delayTime.value = 0.2;
    delayGain1.gain.value = 0.1;
    delayGain2.gain.value = 0.06;

    warp.connect(warpGain);
    warpGain.connect(masterGain);
    warpGain.connect(delay1);
    warpGain.connect(delay2);
    delay1.connect(delayGain1);
    delay2.connect(delayGain2);
    delayGain1.connect(masterGain);
    delayGain2.connect(masterGain);

    warp.start();
    warp.stop(audioContext.currentTime + 0.5);
  }

  /**
   * Harvest sound - satisfying pluck with harmonic
   */
  function playHarvestSound() {
    if (!audioContext || !masterGain) return;

    const pluck = audioContext.createOscillator();
    const harmonic = audioContext.createOscillator();
    const pluckGain = audioContext.createGain();

    pluck.type = 'triangle';
    pluck.frequency.value = 330;

    harmonic.type = 'triangle';
    harmonic.frequency.value = 660;

    pluckGain.gain.value = 0.06;
    pluckGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    pluck.connect(pluckGain);
    harmonic.connect(pluckGain);
    pluckGain.connect(masterGain);

    pluck.start();
    harmonic.start();
    pluck.stop(audioContext.currentTime + 0.3);
    harmonic.stop(audioContext.currentTime + 0.3);
  }

  /**
   * Build sound - heavy thump + click
   */
  function playBuildSound() {
    if (!audioContext || !masterGain) return;

    const thump = audioContext.createOscillator();
    const thumpGain = audioContext.createGain();

    thump.type = 'square';
    thump.frequency.value = 80;

    thumpGain.gain.value = 0.06;
    thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

    thump.connect(thumpGain);
    thumpGain.connect(masterGain);

    thump.start();
    thump.stop(audioContext.currentTime + 0.15);

    const click = audioContext.createOscillator();
    const clickGain = audioContext.createGain();

    click.type = 'sine';
    click.frequency.value = 2000;

    clickGain.gain.value = 0.04;
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

    click.connect(clickGain);
    clickGain.connect(masterGain);

    click.start();
    click.stop(audioContext.currentTime + 0.02);
  }

  /**
   * Trade sound - coin ding with shimmer
   */
  function playTradeSound() {
    if (!audioContext || !masterGain) return;

    const coin1 = audioContext.createOscillator();
    const coin2 = audioContext.createOscillator();
    const wobble = audioContext.createOscillator();
    const wobbleGain = audioContext.createGain();
    const coinGain = audioContext.createGain();

    coin1.type = 'sine';
    coin1.frequency.value = 1200;

    coin2.type = 'sine';
    coin2.frequency.value = 1500;

    wobble.type = 'sine';
    wobble.frequency.value = 5;
    wobbleGain.gain.value = 3;

    coinGain.gain.value = 0.05;
    coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    wobble.connect(wobbleGain);
    wobbleGain.connect(coin1.frequency);
    wobbleGain.connect(coin2.frequency);

    coin1.connect(coinGain);
    coin2.connect(coinGain);
    coinGain.connect(masterGain);

    coin1.start();
    coin2.start();
    wobble.start();
    coin1.stop(audioContext.currentTime + 0.3);
    coin2.stop(audioContext.currentTime + 0.3);
    wobble.stop(audioContext.currentTime + 0.3);
  }

  /**
   * Discover sound - magical sparkle arpeggio
   */
  function playDiscoverSound() {
    if (!audioContext || !masterGain) return;

    const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.08;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.2);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.2);
    });
  }

  /**
   * Challenge sound - dramatic horn
   */
  function playChallengeSound() {
    if (!audioContext || !masterGain) return;

    const horn1 = audioContext.createOscillator();
    const horn2 = audioContext.createOscillator();
    const hornGain = audioContext.createGain();

    horn1.type = 'sawtooth';
    horn1.frequency.value = 220;

    horn2.type = 'sawtooth';
    horn2.frequency.value = 330;

    hornGain.gain.setValueAtTime(0, audioContext.currentTime);
    hornGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.1);
    hornGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.4);
    hornGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    horn1.connect(hornGain);
    horn2.connect(hornGain);
    hornGain.connect(masterGain);

    horn1.start();
    horn2.start();
    horn1.stop(audioContext.currentTime + 0.5);
    horn2.stop(audioContext.currentTime + 0.5);
  }

  /**
   * Level up sound - rising triumphant chord
   */
  function playLevelUpSound() {
    if (!audioContext || !masterGain) return;

    const notes = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.1;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.1);
      noteGain.gain.linearRampToValueAtTime(0.03, startTime + 0.5);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.8);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.8);
    });
  }

  /**
   * Error sound - low buzz
   */
  function playErrorSound() {
    if (!audioContext || !masterGain) return;

    const buzz = audioContext.createOscillator();
    const buzzGain = audioContext.createGain();

    buzz.type = 'square';
    buzz.frequency.value = 100;

    buzzGain.gain.value = 0.04;
    buzzGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    buzz.connect(buzzGain);
    buzzGain.connect(masterGain);

    buzz.start();
    buzz.stop(audioContext.currentTime + 0.2);
  }

  /**
   * Notification sound - gentle bell
   */
  function playNotificationSound() {
    if (!audioContext || !masterGain) return;

    const bell = audioContext.createOscillator();
    const bellGain = audioContext.createGain();

    bell.type = 'sine';
    bell.frequency.value = 800;

    bellGain.gain.value = 0.05;
    bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

    bell.connect(bellGain);
    bellGain.connect(masterGain);

    bell.start();
    bell.stop(audioContext.currentTime + 0.4);
  }

  /**
   * Trade request sound - soft notification bell (single warm tone)
   */
  function playTradeRequestSound() {
    if (!audioContext || !masterGain) return;

    const bell = audioContext.createOscillator();
    const bellGain = audioContext.createGain();

    bell.type = 'sine';
    bell.frequency.value = 700;

    bellGain.gain.value = 0.04;
    bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

    bell.connect(bellGain);
    bellGain.connect(masterGain);

    bell.start();
    bell.stop(audioContext.currentTime + 0.5);
  }

  /**
   * Craft complete sound - satisfying metallic completion (anvil-like + sparkle)
   */
  function playCraftCompleteSound() {
    if (!audioContext || !masterGain) return;

    // Anvil strike - low metallic thump
    const anvil = audioContext.createOscillator();
    const anvilGain = audioContext.createGain();

    anvil.type = 'square';
    anvil.frequency.value = 120;

    anvilGain.gain.value = 0.06;
    anvilGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    anvil.connect(anvilGain);
    anvilGain.connect(masterGain);

    anvil.start();
    anvil.stop(audioContext.currentTime + 0.2);

    // Sparkle - high chime
    const sparkle1 = audioContext.createOscillator();
    const sparkle2 = audioContext.createOscillator();
    const sparkle3 = audioContext.createOscillator();
    const sparkleGain = audioContext.createGain();

    sparkle1.type = 'sine';
    sparkle1.frequency.value = 1800;
    sparkle2.type = 'sine';
    sparkle2.frequency.value = 2200;
    sparkle3.type = 'sine';
    sparkle3.frequency.value = 2600;

    const startTime = audioContext.currentTime + 0.1;
    sparkleGain.gain.setValueAtTime(0, startTime);
    sparkleGain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
    sparkleGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

    sparkle1.connect(sparkleGain);
    sparkle2.connect(sparkleGain);
    sparkle3.connect(sparkleGain);
    sparkleGain.connect(masterGain);

    sparkle1.start(startTime);
    sparkle2.start(startTime + 0.05);
    sparkle3.start(startTime + 0.1);
    sparkle1.stop(startTime + 0.4);
    sparkle2.stop(startTime + 0.45);
    sparkle3.stop(startTime + 0.5);
  }

  /**
   * Quest accept sound - adventurous ascending arpeggio (3 quick rising notes)
   */
  function playQuestAcceptSound() {
    if (!audioContext || !masterGain) return;

    const notes = [392.00, 493.88, 587.33]; // G4, B4, D5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.08;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.25);
    });
  }

  /**
   * Quest complete sound - triumphant fanfare (3 notes harmonized)
   */
  function playQuestCompleteSound() {
    if (!audioContext || !masterGain) return;

    // Triumphant chord - C major (C5, E5, G5)
    const chord1 = audioContext.createOscillator();
    const chord2 = audioContext.createOscillator();
    const chord3 = audioContext.createOscillator();
    const chordGain = audioContext.createGain();

    chord1.type = 'sine';
    chord1.frequency.value = 523.25; // C5
    chord2.type = 'sine';
    chord2.frequency.value = 659.25; // E5
    chord3.type = 'sine';
    chord3.frequency.value = 783.99; // G5

    chordGain.gain.setValueAtTime(0, audioContext.currentTime);
    chordGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.1);
    chordGain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.5);
    chordGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

    chord1.connect(chordGain);
    chord2.connect(chordGain);
    chord3.connect(chordGain);
    chordGain.connect(masterGain);

    chord1.start();
    chord2.start();
    chord3.start();
    chord1.stop(audioContext.currentTime + 0.8);
    chord2.stop(audioContext.currentTime + 0.8);
    chord3.stop(audioContext.currentTime + 0.8);
  }

  /**
   * Item pickup sound - quick soft pop (short white noise burst)
   */
  function playItemPickupSound() {
    if (!audioContext || !masterGain) return;

    try {
      // Create short white noise burst
      const bufferSize = audioContext.sampleRate * 0.05; // 50ms
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 1000;
      filter.Q.value = 1;

      const noiseGain = audioContext.createGain();
      noiseGain.gain.value = 0.05;
      noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.08);
    } catch (err) {
      console.error('Error in item pickup sound:', err);
    }
  }

  /**
   * NPC greet sound - warm gentle tone (single soft note)
   */
  function playNPCGreetSound() {
    if (!audioContext || !masterGain) return;

    const greet = audioContext.createOscillator();
    const greetGain = audioContext.createGain();

    greet.type = 'sine';
    greet.frequency.value = 440; // A4

    greetGain.gain.setValueAtTime(0, audioContext.currentTime);
    greetGain.gain.linearRampToValueAtTime(0.04, audioContext.currentTime + 0.05);
    greetGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.35);

    greet.connect(greetGain);
    greetGain.connect(masterGain);

    greet.start();
    greet.stop(audioContext.currentTime + 0.35);
  }

  /**
   * Portal enter sound - whooshing magical sound (filtered noise sweep)
   */
  function playPortalEnterSound() {
    if (!audioContext || !masterGain) return;

    try {
      // Create noise for whoosh
      const bufferSize = audioContext.sampleRate * 0.8;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      // Sweeping filter for magical effect
      const filter = audioContext.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 200;
      filter.frequency.exponentialRampToValueAtTime(4000, audioContext.currentTime + 0.8);
      filter.Q.value = 5;

      const whooshGain = audioContext.createGain();
      whooshGain.gain.value = 0.06;
      whooshGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

      noise.connect(filter);
      filter.connect(whooshGain);
      whooshGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.8);

      // Add ethereal tone
      const tone = audioContext.createOscillator();
      const toneGain = audioContext.createGain();

      tone.type = 'sine';
      tone.frequency.value = 800;
      tone.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.8);

      toneGain.gain.value = 0.03;
      toneGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);

      tone.connect(toneGain);
      toneGain.connect(masterGain);

      tone.start();
      tone.stop(audioContext.currentTime + 0.8);
    } catch (err) {
      console.error('Error in portal enter sound:', err);
    }
  }

  /**
   * Build place sound - solid thunk (low frequency impact)
   */
  function playBuildPlaceSound() {
    if (!audioContext || !masterGain) return;

    const thunk = audioContext.createOscillator();
    const thunkGain = audioContext.createGain();

    thunk.type = 'square';
    thunk.frequency.value = 60;

    thunkGain.gain.value = 0.06;
    thunkGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.12);

    thunk.connect(thunkGain);
    thunkGain.connect(masterGain);

    thunk.start();
    thunk.stop(audioContext.currentTime + 0.12);
  }

  /**
   * Zone entry swoosh â€” white noise burst + descending sine sweep
   */
  function playZoneEntrySwoosh() {
    if (!audioContext || !masterGain) return;
    try {
      var now = audioContext.currentTime;
      // White noise burst (40ms) through bandpass
      var bufSize = Math.floor(audioContext.sampleRate * 0.04);
      var buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
      var data = buf.getChannelData(0);
      for (var i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      var noise = audioContext.createBufferSource();
      noise.buffer = buf;
      var bandpass = audioContext.createBiquadFilter();
      bandpass.type = 'bandpass';
      bandpass.frequency.value = 400;
      bandpass.Q.value = 1.0;
      var noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(0.04, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
      noise.connect(bandpass);
      bandpass.connect(noiseGain);
      noiseGain.connect(masterGain);
      noise.start(now);
      noise.stop(now + 0.04);

      // Descending sine sweep 600Hz -> 200Hz over 0.3s
      var sweep = audioContext.createOscillator();
      sweep.type = 'sine';
      sweep.frequency.setValueAtTime(600, now);
      sweep.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      var sweepGain = audioContext.createGain();
      sweepGain.gain.setValueAtTime(0.03, now);
      sweepGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      sweep.connect(sweepGain);
      sweepGain.connect(masterGain);
      sweep.start(now);
      sweep.stop(now + 0.4);
    } catch (err) {
      console.error('Error in zone entry swoosh:', err);
    }
  }

  /**
   * Photo mode shutter click â€” two rapid noise clicks
   */
  function playShutterSound() {
    if (!audioContext || !masterGain) return;
    try {
      var now = audioContext.currentTime;
      // First click
      var bufSize = Math.floor(audioContext.sampleRate * 0.005);
      var buf = audioContext.createBuffer(1, bufSize, audioContext.sampleRate);
      var data = buf.getChannelData(0);
      for (var i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      var click1 = audioContext.createBufferSource();
      click1.buffer = buf;
      var hp1 = audioContext.createBiquadFilter();
      hp1.type = 'highpass';
      hp1.frequency.value = 3000;
      var g1 = audioContext.createGain();
      g1.gain.value = 0.04;
      click1.connect(hp1);
      hp1.connect(g1);
      g1.connect(masterGain);
      click1.start(now);
      click1.stop(now + 0.005);

      // Second click after 30ms gap
      var click2 = audioContext.createBufferSource();
      click2.buffer = buf;
      var hp2 = audioContext.createBiquadFilter();
      hp2.type = 'highpass';
      hp2.frequency.value = 3000;
      var g2 = audioContext.createGain();
      g2.gain.value = 0.04;
      click2.connect(hp2);
      hp2.connect(g2);
      g2.connect(masterGain);
      click2.start(now + 0.035);
      click2.stop(now + 0.04);
    } catch (err) {
      console.error('Error in shutter sound:', err);
    }
  }

  /**
   * Coin chime - quick ascending two-tone for Spark earn
   */
  function playCoinSound() {
    if (!audioContext || !masterGain) return;
    try {
      var now = audioContext.currentTime;
      // Tone 1: 880Hz sine, 40ms
      var osc1 = audioContext.createOscillator();
      var g1 = audioContext.createGain();
      osc1.type = 'sine';
      osc1.frequency.value = 880;
      g1.gain.setValueAtTime(0.04, now);
      g1.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
      osc1.connect(g1);
      g1.connect(masterGain);
      osc1.start(now);
      osc1.stop(now + 0.05);
      // Tone 2: 1320Hz sine, 60ms (starts at 50ms)
      var osc2 = audioContext.createOscillator();
      var g2 = audioContext.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = 1320;
      g2.gain.setValueAtTime(0.04, now + 0.05);
      g2.gain.exponentialRampToValueAtTime(0.001, now + 0.11);
      osc2.connect(g2);
      g2.connect(masterGain);
      osc2.start(now + 0.05);
      osc2.stop(now + 0.12);
    } catch (err) {
      console.error('Error in coin sound:', err);
    }
  }

  /**
   * Footstep sound - very subtle soft step (tiny noise burst, vary pitch slightly)
   */
  function playFootstepSound() {
    if (!audioContext || !masterGain) return;

    try {
      // Create very short white noise burst
      const bufferSize = audioContext.sampleRate * 0.03; // 30ms
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 300 + Math.random() * 200; // Vary pitch slightly
      filter.Q.value = 0.5;

      const stepGain = audioContext.createGain();
      stepGain.gain.value = 0.05; // Very subtle
      stepGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

      noise.connect(filter);
      filter.connect(stepGain);
      stepGain.connect(masterGain);

      noise.start();
      noise.stop(audioContext.currentTime + 0.05);
    } catch (err) {
      console.error('Error in footstep sound:', err);
    }
  }

  /**
   * Play footstep sound
   * @param {string} terrain - Terrain type
   */
  function playFootstep(terrain) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (terrain) {
        case 'grass':
          playGrassFootstep();
          break;
        case 'stone':
          playStoneFootstep();
          break;
        case 'sand':
          playSandFootstep();
          break;
        case 'water':
          playWaterFootstep();
          break;
        case 'wood':
          playWoodFootstep();
          break;
        default:
          playDefaultFootstep();
      }
    } catch (err) {
      console.error('Error playing footstep:', err);
    }
  }

  /**
   * Grass footstep - soft crunch
   */
  function playGrassFootstep() {
    if (!audioContext || !masterGain) return;

    const grass = createWhiteNoise(2);
    if (grass) {
      const grassFilter = audioContext.createBiquadFilter();
      const grassGain = audioContext.createGain();

      grassFilter.type = 'lowpass';
      grassFilter.frequency.value = 500;

      grassGain.gain.value = 0.08;
      grassGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

      grass.connect(grassFilter);
      grassFilter.connect(grassGain);
      grassGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (grass.stop) grass.stop();
          if (grassFilter.disconnect) grassFilter.disconnect();
          if (grassGain.disconnect) grassGain.disconnect();
        } catch (e) {}
      }, 100);
    }
  }

  /**
   * Stone footstep - hard tap
   */
  function playStoneFootstep() {
    if (!audioContext || !masterGain) return;

    const thud = audioContext.createOscillator();
    const thudGain = audioContext.createGain();

    thud.type = 'sine';
    thud.frequency.value = 200;

    thudGain.gain.value = 0.04;
    thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

    thud.connect(thudGain);
    thudGain.connect(masterGain);

    thud.start();
    thud.stop(audioContext.currentTime + 0.05);

    const click = audioContext.createOscillator();
    const clickGain = audioContext.createGain();

    click.type = 'sine';
    click.frequency.value = 3000;

    clickGain.gain.value = 0.05;
    clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.02);

    click.connect(clickGain);
    clickGain.connect(masterGain);

    click.start();
    click.stop(audioContext.currentTime + 0.02);
  }

  /**
   * Sand footstep - soft swish
   */
  function playSandFootstep() {
    if (!audioContext || !masterGain) return;

    const sand = createWhiteNoise(2);
    if (sand) {
      const sandFilter = audioContext.createBiquadFilter();
      const sandGain = audioContext.createGain();

      sandFilter.type = 'lowpass';
      sandFilter.frequency.value = 300;

      sandGain.gain.value = 0.07;
      sandGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

      sand.connect(sandFilter);
      sandFilter.connect(sandGain);
      sandGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (sand.stop) sand.stop();
          if (sandFilter.disconnect) sandFilter.disconnect();
          if (sandGain.disconnect) sandGain.disconnect();
        } catch (e) {}
      }, 120);
    }
  }

  /**
   * Water footstep - splash with bubbles
   */
  function playWaterFootstep() {
    if (!audioContext || !masterGain) return;

    const splash = createWhiteNoise(2);
    if (splash) {
      const splashFilter = audioContext.createBiquadFilter();
      const splashGain = audioContext.createGain();

      splashFilter.type = 'bandpass';
      splashFilter.frequency.value = 800;
      splashFilter.Q.value = 2;

      splashGain.gain.value = 0.04;
      splashGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.12);

      splash.connect(splashFilter);
      splashFilter.connect(splashGain);
      splashGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (splash.stop) splash.stop();
          if (splashFilter.disconnect) splashFilter.disconnect();
          if (splashGain.disconnect) splashGain.disconnect();
        } catch (e) {}
      }, 150);
    }

    // Bubbles
    for (let i = 0; i < 2; i++) {
      setTimeout(() => {
        const bubble = audioContext.createOscillator();
        const bubbleGain = audioContext.createGain();

        bubble.type = 'sine';
        bubble.frequency.value = 1500 + Math.random() * 1500;

        bubbleGain.gain.value = 0.03;
        bubbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);

        bubble.connect(bubbleGain);
        bubbleGain.connect(masterGain);

        bubble.start();
        bubble.stop(audioContext.currentTime + 0.05);
      }, i * 50);
    }
  }

  /**
   * Wood footstep - hollow knock
   */
  function playWoodFootstep() {
    if (!audioContext || !masterGain) return;

    const knock = audioContext.createOscillator();
    const knockGain = audioContext.createGain();

    knock.type = 'sine';
    knock.frequency.value = 150;

    knockGain.gain.value = 0.04;
    knockGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.06);

    knock.connect(knockGain);
    knockGain.connect(masterGain);

    knock.start();
    knock.stop(audioContext.currentTime + 0.06);
  }

  /**
   * Default footstep - generic soft thud
   */
  function playDefaultFootstep() {
    if (!audioContext || !masterGain) return;

    const thud = audioContext.createOscillator();
    const thudGain = audioContext.createGain();

    thud.type = 'sine';
    thud.frequency.value = 100;

    thudGain.gain.value = 0.08;
    thudGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.07);

    thud.connect(thudGain);
    thudGain.connect(masterGain);

    thud.start();
    thud.stop(audioContext.currentTime + 0.07);
  }

  /**
   * Set volume for a channel
   * @param {string} channel - 'master', 'music', or 'sfx'
   * @param {number} level - 0-1
   */
  function setVolume(channel, level) {
    if (typeof channel === 'number') {
      level = channel;
      channel = 'master';
    }
    var clampedLevel = Math.max(0, Math.min(1, level));
    volumeLevels[channel] = clampedLevel;
    if (channel === 'master' && masterGain) {
      masterGain.gain.value = clampedLevel;
    }
    if (channel === 'music') {
      setMusicVolume(clampedLevel);
    }
  }

  /**
   * Mute audio
   */
  function mute() {
    if (!masterGain) return;

    isMuted = true;
    masterGain.gain.value = 0;
  }

  /**
   * Unmute audio
   */
  function unmute() {
    if (!masterGain) return;

    isMuted = false;
    masterGain.gain.value = 0.15;
  }

  /**
   * Stop all sounds
   */
  function stopAll() {
    stopAmbient();
    stopTimeAmbient();
    stopWeatherAmbient();
    stopZoneAmbient();
    killAllNoiseSources();
  }

  // ============================================================================
  // TIME-OF-DAY AMBIENT LAYERS
  // ============================================================================

  let currentTimeAmbient = null;

  // Night cricket ambient layer
  var cricketLayer = null;

  function playNightCricketLayer() {
    if (!audioContext || !masterGain) return null;
    try {
      var layerGain = audioContext.createGain();
      layerGain.gain.value = 0.006;

      // Cricket 1: 3200Hz pulsed at ~12Hz (softer, lower pitch)
      var cricket1 = audioContext.createOscillator();
      cricket1.type = 'sine';
      cricket1.frequency.value = 3200;
      var lfo1 = audioContext.createOscillator();
      lfo1.type = 'sine';
      lfo1.frequency.value = 12;
      var lfoGain1 = audioContext.createGain();
      lfoGain1.gain.value = 0.3;
      lfo1.connect(lfoGain1);
      var cricket1Gain = audioContext.createGain();
      cricket1Gain.gain.value = 0.3;
      lfoGain1.connect(cricket1Gain.gain);
      cricket1.connect(cricket1Gain);
      cricket1Gain.connect(layerGain);

      // Cricket 2: 3400Hz slightly offset timing
      var cricket2 = audioContext.createOscillator();
      cricket2.type = 'sine';
      cricket2.frequency.value = 3400;
      var lfo2 = audioContext.createOscillator();
      lfo2.type = 'sine';
      lfo2.frequency.value = 10;
      var lfoGain2 = audioContext.createGain();
      lfoGain2.gain.value = 0.3;
      lfo2.connect(lfoGain2);
      var cricket2Gain = audioContext.createGain();
      cricket2Gain.gain.value = 0.3;
      lfoGain2.connect(cricket2Gain.gain);
      cricket2.connect(cricket2Gain);
      cricket2Gain.connect(layerGain);

      layerGain.connect(masterGain);
      cricket1.start();
      cricket2.start();
      lfo1.start();
      lfo2.start();

      return {
        oscillators: [cricket1, cricket2, lfo1, lfo2],
        nodes: [cricket1Gain, cricket2Gain, lfoGain1, lfoGain2, layerGain],
        gainNode: layerGain
      };
    } catch (err) {
      console.error('Error in cricket layer:', err);
      return null;
    }
  }

  function stopCricketLayer() {
    if (!cricketLayer) return;
    try {
      if (cricketLayer.gainNode) {
        cricketLayer.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
      }
      var cl = cricketLayer;
      setTimeout(function() {
        if (cl.oscillators) {
          cl.oscillators.forEach(function(o) { try { o.stop(); } catch(e) {} });
        }
      }, 2100);
      cricketLayer = null;
    } catch (err) {
      console.error('Error stopping crickets:', err);
    }
  }

  /**
   * Update ambient sounds based on time of day
   * @param {string} timePeriod - dawn, morning, midday, afternoon, evening, night
   */
  function updateAmbientForTime(timePeriod) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Stop current time ambient
    stopTimeAmbient();

    try {
      switch (timePeriod) {
        case 'dawn':
          currentTimeAmbient = playDawnAmbient();
          break;
        case 'morning':
          currentTimeAmbient = playMorningAmbient();
          break;
        case 'midday':
          currentTimeAmbient = playMiddayAmbient();
          break;
        case 'afternoon':
          currentTimeAmbient = playAfternoonAmbient();
          break;
        case 'evening':
          currentTimeAmbient = playEveningAmbient();
          break;
        case 'night':
          currentTimeAmbient = playNightAmbient();
          break;
        default:
          currentTimeAmbient = null;
      }

      // Night cricket layer
      if (timePeriod === 'night' || timePeriod === 'evening') {
        if (!cricketLayer) {
          cricketLayer = playNightCricketLayer();
        }
      } else if (timePeriod === 'dawn' || timePeriod === 'morning') {
        stopCricketLayer();
      } else {
        stopCricketLayer();
      }
    } catch (err) {
      console.error('Error updating time ambient:', err);
    }
  }

  /**
   * Stop current time-of-day ambient
   */
  function stopTimeAmbient() {
    if (!currentTimeAmbient) return;

    try {
      if (currentTimeAmbient.oscillators && Array.isArray(currentTimeAmbient.oscillators)) {
        currentTimeAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentTimeAmbient.nodes && Array.isArray(currentTimeAmbient.nodes)) {
        currentTimeAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentTimeAmbient.intervals && Array.isArray(currentTimeAmbient.intervals)) {
        currentTimeAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentTimeAmbient.timeouts && Array.isArray(currentTimeAmbient.timeouts)) {
        currentTimeAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentTimeAmbient.cleanup && typeof currentTimeAmbient.cleanup === 'function') {
        currentTimeAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping time ambient:', err);
    }

    currentTimeAmbient = null;
    killAllNoiseSources();
  }

  /**
   * Dawn ambient (5-7): Bird chirps, gentle wind
   */
  function playDawnAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Gentle wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 180;
        windGain.gain.value = 0.02;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      // Morning bird chirps - high frequency with fast attack/decay
      function dawnChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 800 + Math.random() * 1000;

        const duration = 0.05 + Math.random() * 0.1;
        birdGain.gain.value = 0.04;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(dawnChirp, 800 + Math.random() * 2000);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 2; i++) {
        const firstChirp = setTimeout(dawnChirp, Math.random() * 1000);
        timeouts.push(firstChirp);
      }

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in dawn ambient:', err);
      return null;
    }
  }

  /**
   * Morning ambient (7-12): Active birds, gentle breeze, insect buzzes
   */
  function playMorningAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Gentle breeze
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 200;
        breezeGain.gain.value = 0.025;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Active bird chorus
      function morningChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 700 + Math.random() * 1200;

        const duration = 0.08 + Math.random() * 0.15;
        birdGain.gain.value = 0.05;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(morningChirp, 400 + Math.random() * 2500);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 3; i++) {
        const firstChirp = setTimeout(morningChirp, Math.random() * 1500);
        timeouts.push(firstChirp);
      }

      // Occasional insect buzzes
      function buzz() {
        if (!audioContext || !masterGain) return;

        const insect = audioContext.createOscillator();
        const insectGain = audioContext.createGain();

        insect.type = 'sawtooth';
        insect.frequency.value = 250 + Math.random() * 100;

        insectGain.gain.value = 0.02;
        insectGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        insect.connect(insectGain);
        insectGain.connect(masterGain);

        insect.start();
        insect.stop(audioContext.currentTime + 0.3);

        const nextBuzz = setTimeout(buzz, 8000 + Math.random() * 12000);
        timeouts.push(nextBuzz);
      }

      const firstBuzz = setTimeout(buzz, 5000);
      timeouts.push(firstBuzz);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in morning ambient:', err);
      return null;
    }
  }

  /**
   * Midday ambient (12-14): Cicada-like sustained tones, warm breeze
   */
  function playMiddayAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Warm breeze
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 220;
        breezeGain.gain.value = 0.03;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Cicada-like sustained tone with AM
      const cicada = audioContext.createOscillator();
      const cicadaAm = audioContext.createOscillator();
      const cicadaAmGain = audioContext.createGain();
      const cicadaGain = audioContext.createGain();

      cicada.type = 'sine';
      cicada.frequency.value = 3500 + Math.random() * 500;

      cicadaAm.type = 'sine';
      cicadaAm.frequency.value = 15 + Math.random() * 10;
      cicadaAmGain.gain.value = 0.02;

      cicadaGain.gain.value = 0.04;

      cicadaAm.connect(cicadaAmGain);
      cicadaAmGain.connect(cicadaGain.gain);

      cicada.connect(cicadaGain);
      cicadaGain.connect(masterGain);

      cicada.start();
      cicadaAm.start();

      oscillators.push(cicada, cicadaAm);
      nodes.push(cicadaAmGain, cicadaGain);

      // Occasional bird (quieter in heat)
      function middayChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 600 + Math.random() * 800;

        const duration = 0.1 + Math.random() * 0.15;
        birdGain.gain.value = 0.03;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(middayChirp, 3000 + Math.random() * 5000);
        timeouts.push(nextChirp);
      }

      const firstChirp = setTimeout(middayChirp, 2000);
      timeouts.push(firstChirp);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in midday ambient:', err);
      return null;
    }
  }

  /**
   * Afternoon ambient (14-18): Softer birds, rustling leaves
   */
  function playAfternoonAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Gentle breeze
      const breeze = createWhiteNoise();
      if (breeze) {
        const breezeFilter = audioContext.createBiquadFilter();
        const breezeGain = audioContext.createGain();

        breezeFilter.type = 'lowpass';
        breezeFilter.frequency.value = 190;
        breezeGain.gain.value = 0.025;

        breeze.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(masterGain);

        nodes.push(breeze, breezeFilter, breezeGain);
      }

      // Softer bird calls
      function afternoonChirp() {
        if (!audioContext || !masterGain) return;

        const bird = audioContext.createOscillator();
        const birdGain = audioContext.createGain();

        bird.type = 'sine';
        bird.frequency.value = 500 + Math.random() * 900;

        const duration = 0.1 + Math.random() * 0.2;
        birdGain.gain.value = 0.04;
        birdGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

        bird.connect(birdGain);
        birdGain.connect(masterGain);

        bird.start();
        bird.stop(audioContext.currentTime + duration);

        const nextChirp = setTimeout(afternoonChirp, 1500 + Math.random() * 4000);
        timeouts.push(nextChirp);
      }

      for (let i = 0; i < 2; i++) {
        const firstChirp = setTimeout(afternoonChirp, Math.random() * 2000);
        timeouts.push(firstChirp);
      }

      // Rustling leaves
      function rustle() {
        if (!audioContext || !masterGain) return;

        const noise = createWhiteNoise(2);
        if (noise) {
          const rustleFilter = audioContext.createBiquadFilter();
          const rustleGain = audioContext.createGain();

          rustleFilter.type = 'bandpass';
          rustleFilter.frequency.value = 1800 + Math.random() * 400;
          rustleFilter.Q.value = 2;

          rustleGain.gain.value = 0.03;
          rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

          noise.connect(rustleFilter);
          rustleFilter.connect(rustleGain);
          rustleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (noise.stop) noise.stop();
              if (rustleFilter.disconnect) rustleFilter.disconnect();
              if (rustleGain.disconnect) rustleGain.disconnect();
            } catch (e) {}
          }, 450);
        }

        const nextRustle = setTimeout(rustle, 2500 + Math.random() * 3500);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(rustle, 1500);
      timeouts.push(firstRustle);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in afternoon ambient:', err);
      return null;
    }
  }

  /**
   * Evening ambient (18-21): Cricket chirps, owl hoots, gentle wind
   */
  function playEveningAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Gentle wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 170;
        windGain.gain.value = 0.02;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      // Cricket chirps - rapid oscillator pulses
      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 4000 + Math.random() * 500;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 18 + Math.random() * 8;
      cricketAmGain.gain.value = 0.025;

      cricketGain.gain.value = 0.03;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      oscillators.push(cricket, cricketAm);
      nodes.push(cricketAmGain, cricketGain);

      // Owl hoots - low frequency with vibrato
      function hoot() {
        if (!audioContext || !masterGain) return;

        const owl = audioContext.createOscillator();
        const owlVibrato = audioContext.createOscillator();
        const owlVibratoGain = audioContext.createGain();
        const owlGain = audioContext.createGain();

        owl.type = 'sine';
        owl.frequency.value = 320;

        owlVibrato.type = 'sine';
        owlVibrato.frequency.value = 4;
        owlVibratoGain.gain.value = 8;

        owlGain.gain.value = 0.05;
        owlGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);

        owlVibrato.connect(owlVibratoGain);
        owlVibratoGain.connect(owl.frequency);

        owl.connect(owlGain);
        owlGain.connect(masterGain);

        owl.start();
        owlVibrato.start();

        owl.stop(audioContext.currentTime + 0.4);
        owlVibrato.stop(audioContext.currentTime + 0.4);

        const nextHoot = setTimeout(hoot, 12000 + Math.random() * 12000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(hoot, 5000);
      timeouts.push(firstHoot);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in evening ambient:', err);
      return null;
    }
  }

  /**
   * Night ambient (21-5): Deep crickets, occasional owl, quiet wind, distant howl
   */
  function playNightAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const oscillators = [];
    const timeouts = [];

    try {
      // Very quiet wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 150;
        windGain.gain.value = 0.015;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      // Deep crickets
      const cricket = audioContext.createOscillator();
      const cricketAm = audioContext.createOscillator();
      const cricketAmGain = audioContext.createGain();
      const cricketGain = audioContext.createGain();

      cricket.type = 'sine';
      cricket.frequency.value = 3500 + Math.random() * 300;

      cricketAm.type = 'sine';
      cricketAm.frequency.value = 15 + Math.random() * 5;
      cricketAmGain.gain.value = 0.02;

      cricketGain.gain.value = 0.025;

      cricketAm.connect(cricketAmGain);
      cricketAmGain.connect(cricketGain.gain);

      cricket.connect(cricketGain);
      cricketGain.connect(masterGain);

      cricket.start();
      cricketAm.start();

      oscillators.push(cricket, cricketAm);
      nodes.push(cricketAmGain, cricketGain);

      // Occasional owl
      function nightHoot() {
        if (!audioContext || !masterGain) return;

        const owl = audioContext.createOscillator();
        const owlVibrato = audioContext.createOscillator();
        const owlVibratoGain = audioContext.createGain();
        const owlGain = audioContext.createGain();

        owl.type = 'sine';
        owl.frequency.value = 280;

        owlVibrato.type = 'sine';
        owlVibrato.frequency.value = 4;
        owlVibratoGain.gain.value = 6;

        owlGain.gain.value = 0.04;
        owlGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

        owlVibrato.connect(owlVibratoGain);
        owlVibratoGain.connect(owl.frequency);

        owl.connect(owlGain);
        owlGain.connect(masterGain);

        owl.start();
        owlVibrato.start();

        owl.stop(audioContext.currentTime + 0.5);
        owlVibrato.stop(audioContext.currentTime + 0.5);

        const nextHoot = setTimeout(nightHoot, 18000 + Math.random() * 18000);
        timeouts.push(nextHoot);
      }

      const firstHoot = setTimeout(nightHoot, 8000);
      timeouts.push(firstHoot);

      // Distant wolf-like howl (very rare)
      function distantHowl() {
        if (!audioContext || !masterGain) return;

        const wolf = audioContext.createOscillator();
        const wolfVibrato = audioContext.createOscillator();
        const wolfVibratoGain = audioContext.createGain();
        const wolfGain = audioContext.createGain();

        wolf.type = 'sine';
        wolf.frequency.value = 350;

        wolfVibrato.type = 'sine';
        wolfVibrato.frequency.value = 4;
        wolfVibratoGain.gain.value = 10;

        wolfGain.gain.value = 0.03;

        wolfVibrato.connect(wolfVibratoGain);
        wolfVibratoGain.connect(wolf.frequency);

        wolf.connect(wolfGain);
        wolfGain.connect(masterGain);

        wolf.start();
        wolfVibrato.start();

        wolf.frequency.linearRampToValueAtTime(500, audioContext.currentTime + 1.2);
        wolf.frequency.linearRampToValueAtTime(350, audioContext.currentTime + 2);
        wolfGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

        wolf.stop(audioContext.currentTime + 2.5);
        wolfVibrato.stop(audioContext.currentTime + 2.5);

        const nextHowl = setTimeout(distantHowl, 60000 + Math.random() * 60000);
        timeouts.push(nextHowl);
      }

      const firstHowl = setTimeout(distantHowl, 30000);
      timeouts.push(firstHowl);

      return { nodes, oscillators, timeouts };
    } catch (err) {
      console.error('Error in night ambient:', err);
      return null;
    }
  }

  // ============================================================================
  // WEATHER AMBIENT LAYERS
  // ============================================================================

  let currentWeatherAmbient = null;

  /**
   * Update ambient sounds based on weather
   * @param {string} weather - clear, cloudy, rain, snow
   */
  function updateAmbientForWeather(weather) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Stop current weather ambient
    stopWeatherAmbient();

    try {
      switch (weather) {
        case 'clear':
          // Normal ambient, no additional layer
          currentWeatherAmbient = null;
          break;
        case 'cloudy':
          currentWeatherAmbient = playCloudyAmbient();
          break;
        case 'rain':
          currentWeatherAmbient = playRainAmbient();
          break;
        case 'snow':
          currentWeatherAmbient = playSnowAmbient();
          break;
        default:
          currentWeatherAmbient = null;
      }
    } catch (err) {
      console.error('Error updating weather ambient:', err);
    }
  }

  /**
   * Stop current weather ambient
   */
  function stopWeatherAmbient() {
    if (!currentWeatherAmbient) return;

    try {
      if (currentWeatherAmbient.oscillators && Array.isArray(currentWeatherAmbient.oscillators)) {
        currentWeatherAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentWeatherAmbient.nodes && Array.isArray(currentWeatherAmbient.nodes)) {
        currentWeatherAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentWeatherAmbient.intervals && Array.isArray(currentWeatherAmbient.intervals)) {
        currentWeatherAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentWeatherAmbient.timeouts && Array.isArray(currentWeatherAmbient.timeouts)) {
        currentWeatherAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentWeatherAmbient.cleanup && typeof currentWeatherAmbient.cleanup === 'function') {
        currentWeatherAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping weather ambient:', err);
    }

    currentWeatherAmbient = null;
    killAllNoiseSources();
  }

  /**
   * Cloudy ambient - gentle wind increase
   */
  function playCloudyAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 200;
        windGain.gain.value = 0.03;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      return { nodes };
    } catch (err) {
      console.error('Error in cloudy ambient:', err);
      return null;
    }
  }

  /**
   * Rain ambient - rain sound, occasional thunder
   */
  function playRainAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Rain sound - white noise filtered through bandpass at ~4000Hz
      const rain = createWhiteNoise();
      if (rain) {
        const rainFilter = audioContext.createBiquadFilter();
        const rainGain = audioContext.createGain();

        rainFilter.type = 'bandpass';
        rainFilter.frequency.value = 4000;
        rainFilter.Q.value = 0.5;

        rainGain.gain.value = 0.05;

        rain.connect(rainFilter);
        rainFilter.connect(rainGain);
        rainGain.connect(masterGain);

        nodes.push(rain, rainFilter, rainGain);
      }

      // Occasional thunder
      function thunder() {
        if (!audioContext || !masterGain) return;

        const rumble = createWhiteNoise(2);
        if (rumble) {
          const rumbleFilter = audioContext.createBiquadFilter();
          const rumbleGain = audioContext.createGain();

          rumbleFilter.type = 'lowpass';
          rumbleFilter.frequency.value = 80;

          rumbleGain.gain.value = 0.05;
          rumbleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2.5);

          rumble.connect(rumbleFilter);
          rumbleFilter.connect(rumbleGain);
          rumbleGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (rumble.stop) rumble.stop();
              if (rumbleFilter.disconnect) rumbleFilter.disconnect();
              if (rumbleGain.disconnect) rumbleGain.disconnect();
            } catch (e) {}
          }, 3000);
        }

        const nextThunder = setTimeout(thunder, 25000 + Math.random() * 35000);
        timeouts.push(nextThunder);
      }

      const firstThunder = setTimeout(thunder, 15000);
      timeouts.push(firstThunder);

      return { nodes, timeouts };
    } catch (err) {
      console.error('Error in rain ambient:', err);
      return null;
    }
  }

  /**
   * Snow ambient - very quiet, muffled ambient, soft wind
   */
  function playSnowAmbient() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      // Soft wind
      const wind = createWhiteNoise();
      if (wind) {
        const windFilter = audioContext.createBiquadFilter();
        const windGain = audioContext.createGain();

        windFilter.type = 'lowpass';
        windFilter.frequency.value = 120;
        windGain.gain.value = 0.015;

        wind.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);

        nodes.push(wind, windFilter, windGain);
      }

      return { nodes };
    } catch (err) {
      console.error('Error in snow ambient:', err);
      return null;
    }
  }

  // ============================================================================
  // ZONE-SPECIFIC ENHANCEMENTS
  // ============================================================================

  let currentZoneAmbient = null;

  /**
   * Set zone-specific ambient layer (on top of base ambient)
   * @param {string} zone - Zone identifier
   */
  var crossfadeTimer = null;

  function setZoneAmbient(zone) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    // Clear any pending crossfade
    if (crossfadeTimer) {
      clearTimeout(crossfadeTimer);
      crossfadeTimer = null;
    }

    // Crossfade: stop old ambient immediately (kill noise sources), keep gain fade for smoothness
    var oldAmbient = currentZoneAmbient;
    if (oldAmbient) {
      // Fade out gain gracefully
      try {
        if (oldAmbient.gainNode) {
          oldAmbient.gainNode.gain.setValueAtTime(oldAmbient.gainNode.gain.value, audioContext.currentTime);
          oldAmbient.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        }
      } catch(e) {}

      // Stop all sources immediately to prevent orphaned noise
      try {
        if (oldAmbient.oscillators && Array.isArray(oldAmbient.oscillators)) {
          oldAmbient.oscillators.forEach(function(osc) {
            if (osc && osc.stop) { try { osc.stop(); } catch(e) {} }
          });
        }
        if (oldAmbient.nodes && Array.isArray(oldAmbient.nodes)) {
          oldAmbient.nodes.forEach(function(node) {
            if (node) {
              if (node.stop) { try { node.stop(); } catch(e) {} }
              if (node.disconnect) { try { node.disconnect(); } catch(e) {} }
            }
          });
        }
        if (oldAmbient.intervals && Array.isArray(oldAmbient.intervals)) {
          oldAmbient.intervals.forEach(function(id) { clearInterval(id); });
        }
        if (oldAmbient.timeouts && Array.isArray(oldAmbient.timeouts)) {
          oldAmbient.timeouts.forEach(function(id) { clearTimeout(id); });
        }
        if (oldAmbient.cleanup && typeof oldAmbient.cleanup === 'function') {
          oldAmbient.cleanup();
        }
      } catch(err) {}

      killAllNoiseSources();
      currentZoneAmbient = null;
    }

    // Start new zone ambient immediately (will overlap with fading old one)
    try {
      switch (zone) {
        case 'nexus':
          currentZoneAmbient = playNexusZoneLayer();
          break;
        case 'gardens':
          currentZoneAmbient = playGardensZoneLayer();
          break;
        case 'athenaeum':
          currentZoneAmbient = playAthenaeumZoneLayer();
          break;
        case 'studio':
          currentZoneAmbient = playStudioZoneLayer();
          break;
        case 'wilds':
          currentZoneAmbient = playWildsZoneLayer();
          break;
        case 'agora':
          currentZoneAmbient = playAgoraZoneLayer();
          break;
        case 'commons':
          currentZoneAmbient = playCommonsZoneLayer();
          break;
        case 'arena':
          currentZoneAmbient = playArenaZoneLayer();
          break;
        default:
          currentZoneAmbient = null;
      }

      // Fade in new ambient over 3 seconds
      if (currentZoneAmbient && currentZoneAmbient.gainNode) {
        var gain = currentZoneAmbient.gainNode;
        var targetVal = gain.gain.value || 0.3;
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(targetVal, audioContext.currentTime + 3);
      }
    } catch (err) {
      console.error('Error setting zone ambient:', err);
    }
  }

  /**
   * Stop current zone ambient layer
   */
  function stopZoneAmbient() {
    if (!currentZoneAmbient) return;

    try {
      if (currentZoneAmbient.oscillators && Array.isArray(currentZoneAmbient.oscillators)) {
        currentZoneAmbient.oscillators.forEach(osc => {
          if (osc && osc.stop) {
            try { osc.stop(); } catch (e) {}
          }
        });
      }

      if (currentZoneAmbient.nodes && Array.isArray(currentZoneAmbient.nodes)) {
        currentZoneAmbient.nodes.forEach(node => {
          if (node) {
            if (node.stop) {
              try { node.stop(); } catch (e) {}
            }
            if (node.disconnect) {
              try { node.disconnect(); } catch (e) {}
            }
          }
        });
      }

      if (currentZoneAmbient.intervals && Array.isArray(currentZoneAmbient.intervals)) {
        currentZoneAmbient.intervals.forEach(id => clearInterval(id));
      }

      if (currentZoneAmbient.timeouts && Array.isArray(currentZoneAmbient.timeouts)) {
        currentZoneAmbient.timeouts.forEach(id => clearTimeout(id));
      }

      if (currentZoneAmbient.cleanup && typeof currentZoneAmbient.cleanup === 'function') {
        currentZoneAmbient.cleanup();
      }
    } catch (err) {
      console.error('Error stopping zone ambient:', err);
    }

    currentZoneAmbient = null;
    killAllNoiseSources();
  }

  /**
   * Nexus zone layer - subtle crystalline resonance (high sine waves with slow LFO)
   */
  function playNexusZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const oscillators = [];
    const nodes = [];

    try {
      // Soft crystalline shimmer â€” two detuned sines at gentle frequencies
      const crystal1 = audioContext.createOscillator();
      const crystal2 = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      const layerGain = audioContext.createGain();

      crystal1.type = 'sine';
      crystal1.frequency.value = 523; // C5 â€” much gentler than 2000Hz

      crystal2.type = 'sine';
      crystal2.frequency.value = 659; // E5 â€” harmonic interval

      lfo.type = 'sine';
      lfo.frequency.value = 0.12;
      lfoGain.gain.value = 8; // subtle vibrato

      layerGain.gain.value = 0.012; // very quiet

      lfo.connect(lfoGain);
      lfoGain.connect(crystal1.frequency);
      lfoGain.connect(crystal2.frequency);

      crystal1.connect(layerGain);
      crystal2.connect(layerGain);
      layerGain.connect(masterGain);

      crystal1.start();
      crystal2.start();
      lfo.start();

      oscillators.push(crystal1, crystal2, lfo);
      nodes.push(lfoGain, layerGain);

      return { oscillators, nodes, gainNode: layerGain };
    } catch (err) {
      console.error('Error in nexus zone layer:', err);
      return null;
    }
  }

  /**
   * Gardens zone layer - water trickling, more birds
   */
  function playGardensZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Water trickling - filtered noise with LFO
      const water = createWhiteNoise();
      if (water) {
        const waterFilter = audioContext.createBiquadFilter();
        const waterLfo = audioContext.createOscillator();
        const waterLfoGain = audioContext.createGain();
        const waterGain = audioContext.createGain();

        waterFilter.type = 'highpass';
        waterFilter.frequency.value = 2000;

        waterLfo.type = 'sine';
        waterLfo.frequency.value = 0.8;
        waterLfoGain.gain.value = 50;

        waterGain.gain.value = 0.03;

        waterLfo.connect(waterLfoGain);
        waterLfoGain.connect(waterFilter.frequency);

        water.connect(waterFilter);
        waterFilter.connect(waterGain);
        waterGain.connect(masterGain);

        waterLfo.start();

        nodes.push(water, waterFilter, waterLfo, waterLfoGain, waterGain);
      }

      return { nodes, timeouts, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in gardens zone layer:', err);
      return null;
    }
  }

  /**
   * Athenaeum zone layer - echo/reverb quality, page rustling
   */
  function playAthenaeumZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Page rustling - short noise bursts
      function pageRustle() {
        if (!audioContext || !masterGain) return;

        const page = createWhiteNoise(2);
        if (page) {
          const pageFilter = audioContext.createBiquadFilter();
          const pageGain = audioContext.createGain();

          pageFilter.type = 'highpass';
          pageFilter.frequency.value = 2500;

          pageGain.gain.value = 0.02;
          pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);

          page.connect(pageFilter);
          pageFilter.connect(pageGain);
          pageGain.connect(masterGain);

          setTimeout(() => {
            try {
              if (page.stop) page.stop();
              if (pageFilter.disconnect) pageFilter.disconnect();
              if (pageGain.disconnect) pageGain.disconnect();
            } catch (e) {}
          }, 100);
        }

        const nextRustle = setTimeout(pageRustle, 10000 + Math.random() * 10000);
        timeouts.push(nextRustle);
      }

      const firstRustle = setTimeout(pageRustle, 5000);
      timeouts.push(firstRustle);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in athenaeum zone layer:', err);
      return null;
    }
  }

  /**
   * Studio zone layer - creative sounds (random melodic tones, tapping)
   */
  function playStudioZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Random melodic tones
      function creativeNote() {
        if (!audioContext || !masterGain) return;

        const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00];
        const note = audioContext.createOscillator();
        const noteGain = audioContext.createGain();

        note.type = 'sine';
        note.frequency.value = notes[Math.floor(Math.random() * notes.length)];

        noteGain.gain.value = 0.025;
        noteGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        note.connect(noteGain);
        noteGain.connect(masterGain);

        note.start();
        note.stop(audioContext.currentTime + 0.3);

        const nextNote = setTimeout(creativeNote, 8000 + Math.random() * 12000);
        timeouts.push(nextNote);
      }

      const firstNote = setTimeout(creativeNote, 4000);
      timeouts.push(firstNote);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in studio zone layer:', err);
      return null;
    }
  }

  /**
   * Wilds zone layer - dense nature sounds, rushing water
   */
  function playWildsZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      // Rushing water - white noise with bandpass
      const water = createWhiteNoise();
      if (water) {
        const waterFilter = audioContext.createBiquadFilter();
        const waterGain = audioContext.createGain();

        waterFilter.type = 'bandpass';
        waterFilter.frequency.value = 800;
        waterFilter.Q.value = 1;

        waterGain.gain.value = 0.04;

        water.connect(waterFilter);
        waterFilter.connect(waterGain);
        waterGain.connect(masterGain);

        nodes.push(water, waterFilter, waterGain);
      }

      return { nodes, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in wilds zone layer:', err);
      return null;
    }
  }

  /**
   * Agora zone layer - crowd murmur, occasional calls
   */
  function playAgoraZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Enhanced crowd murmur
      const crowd = createWhiteNoise();
      if (crowd) {
        const crowdFilter = audioContext.createBiquadFilter();
        const crowdGain = audioContext.createGain();

        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.value = 450;
        crowdFilter.Q.value = 1.2;

        crowdGain.gain.value = 0.025;

        crowd.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(masterGain);

        nodes.push(crowd, crowdFilter, crowdGain);
      }

      return { nodes, timeouts, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in agora zone layer:', err);
      return null;
    }
  }

  /**
   * Commons zone layer - homey sounds (crackling fire, wind chimes)
   */
  function playCommonsZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];
    const timeouts = [];

    try {
      // Wind chimes - random high notes
      function chime() {
        if (!audioContext || !masterGain) return;

        const bell = audioContext.createOscillator();
        const bellGain = audioContext.createGain();

        bell.type = 'sine';
        bell.frequency.value = 800 + Math.random() * 600;

        bellGain.gain.value = 0.03;
        bellGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

        bell.connect(bellGain);
        bellGain.connect(masterGain);

        bell.start();
        bell.stop(audioContext.currentTime + 1.5);

        const nextChime = setTimeout(chime, 5000 + Math.random() * 8000);
        timeouts.push(nextChime);
      }

      const firstChime = setTimeout(chime, 3000);
      timeouts.push(firstChime);

      return { nodes, timeouts, gainNode: null };
    } catch (err) {
      console.error('Error in commons zone layer:', err);
      return null;
    }
  }

  /**
   * Arena zone layer - echoing space (slight delay)
   */
  function playArenaZoneLayer() {
    if (!audioContext || !masterGain) return null;

    const nodes = [];

    try {
      // Subtle echo ambiance
      const echo = createWhiteNoise(2);
      if (echo) {
        const echoFilter = audioContext.createBiquadFilter();
        const echoDelay = audioContext.createDelay();
        const echoDelayGain = audioContext.createGain();
        const echoGain = audioContext.createGain();

        echoFilter.type = 'bandpass';
        echoFilter.frequency.value = 700;
        echoFilter.Q.value = 0.8;

        echoDelay.delayTime.value = 0.3;
        echoDelayGain.gain.value = 0.3;

        echoGain.gain.value = 0.02;

        echo.connect(echoFilter);
        echoFilter.connect(echoGain);
        echoGain.connect(masterGain);
        echoGain.connect(echoDelay);
        echoDelay.connect(echoDelayGain);
        echoDelayGain.connect(masterGain);

        nodes.push(echo, echoFilter, echoDelay, echoDelayGain, echoGain);
      }

      return { nodes, gainNode: nodes.length > 0 ? nodes[nodes.length - 1] : null };
    } catch (err) {
      console.error('Error in arena zone layer:', err);
      return null;
    }
  }

  // ============================================================================
  // NPC SOUNDS
  // ============================================================================

  /**
   * Play NPC activity sound
   * @param {string} type - hammer, music, garden, trade, teach, heal
   */
  function playNPCSound(type) {
    if (!audioContext || !masterGain) return;

    // Resume context if needed
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    try {
      switch (type) {
        case 'hammer':
          playNPCHammerSound();
          break;
        case 'music':
          playNPCMusicSound();
          break;
        case 'garden':
          playNPCGardenSound();
          break;
        case 'trade':
          playNPCTradeSound();
          break;
        case 'teach':
          playNPCTeachSound();
          break;
        case 'heal':
          playNPCHealSound();
          break;
        default:
          console.warn('Unknown NPC sound type:', type);
      }
    } catch (err) {
      console.error('Error playing NPC sound:', err);
    }
  }

  /**
   * NPC hammer sound - metallic clang
   */
  function playNPCHammerSound() {
    if (!audioContext || !masterGain) return;

    const hammer = audioContext.createOscillator();
    const hammerGain = audioContext.createGain();

    hammer.type = 'square';
    hammer.frequency.value = 90;

    hammerGain.gain.value = 0.08;
    hammerGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    hammer.connect(hammerGain);
    hammerGain.connect(masterGain);

    hammer.start();
    hammer.stop(audioContext.currentTime + 0.2);

    // Metal ring
    const ring = audioContext.createOscillator();
    const ringGain = audioContext.createGain();

    ring.type = 'sine';
    ring.frequency.value = 2500;

    ringGain.gain.value = 0.04;
    ringGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

    ring.connect(ringGain);
    ringGain.connect(masterGain);

    ring.start();
    ring.stop(audioContext.currentTime + 0.3);
  }

  /**
   * NPC music sound - short melodic phrase
   */
  function playNPCMusicSound() {
    if (!audioContext || !masterGain) return;

    const notes = [392.00, 440.00, 493.88]; // G4, A4, B4

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.15;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.05, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.25);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.25);
    });
  }

  /**
   * NPC garden sound - rustling, digging
   */
  function playNPCGardenSound() {
    if (!audioContext || !masterGain) return;

    const rustle = createWhiteNoise(2);
    if (rustle) {
      const rustleFilter = audioContext.createBiquadFilter();
      const rustleGain = audioContext.createGain();

      rustleFilter.type = 'bandpass';
      rustleFilter.frequency.value = 1200;
      rustleFilter.Q.value = 2;

      rustleGain.gain.value = 0.06;
      rustleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

      rustle.connect(rustleFilter);
      rustleFilter.connect(rustleGain);
      rustleGain.connect(masterGain);

      setTimeout(() => {
        try {
          if (rustle.stop) rustle.stop();
          if (rustleFilter.disconnect) rustleFilter.disconnect();
          if (rustleGain.disconnect) rustleGain.disconnect();
        } catch (e) {}
      }, 350);
    }
  }

  /**
   * NPC trade sound - coin clink
   */
  function playNPCTradeSound() {
    if (!audioContext || !masterGain) return;

    const coin = audioContext.createOscillator();
    const coinGain = audioContext.createGain();

    coin.type = 'triangle';
    coin.frequency.value = 1800 + Math.random() * 500;

    coinGain.gain.value = 0.06;
    coinGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

    coin.connect(coinGain);
    coinGain.connect(masterGain);

    coin.start();
    coin.stop(audioContext.currentTime + 0.2);
  }

  /**
   * NPC teach sound - book thump and page turn
   */
  function playNPCTeachSound() {
    if (!audioContext || !masterGain) return;

    // Book thump
    const thump = audioContext.createOscillator();
    const thumpGain = audioContext.createGain();

    thump.type = 'sine';
    thump.frequency.value = 80;

    thumpGain.gain.value = 0.05;
    thumpGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

    thump.connect(thumpGain);
    thumpGain.connect(masterGain);

    thump.start();
    thump.stop(audioContext.currentTime + 0.1);

    // Page turn
    setTimeout(() => {
      const page = createWhiteNoise(2);
      if (page) {
        const pageFilter = audioContext.createBiquadFilter();
        const pageGain = audioContext.createGain();

        pageFilter.type = 'highpass';
        pageFilter.frequency.value = 2200;

        pageGain.gain.value = 0.04;
        pageGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);

        page.connect(pageFilter);
        pageFilter.connect(pageGain);
        pageGain.connect(masterGain);

        setTimeout(() => {
          try {
            if (page.stop) page.stop();
            if (pageFilter.disconnect) pageFilter.disconnect();
            if (pageGain.disconnect) pageGain.disconnect();
          } catch (e) {}
        }, 180);
      }
    }, 100);
  }

  /**
   * NPC heal sound - gentle sparkle
   */
  function playNPCHealSound() {
    if (!audioContext || !masterGain) return;

    const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

    notes.forEach((freq, i) => {
      const note = audioContext.createOscillator();
      const noteGain = audioContext.createGain();

      note.type = 'sine';
      note.frequency.value = freq;

      const startTime = audioContext.currentTime + i * 0.1;
      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.04, startTime + 0.02);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);

      note.connect(noteGain);
      noteGain.connect(masterGain);

      note.start(startTime);
      note.stop(startTime + 0.3);
    });
  }

  // ========================================================================
  // PROCEDURAL MUSIC SYSTEM â€” Generative ambient music per zone/time
  // ========================================================================

  var musicState = {
    playing: false,
    zone: null,
    timeOfDay: 'day',
    volume: 0.12,
    oscillators: [],
    gains: [],
    nextNoteTime: 0,
    noteIndex: 0,
    chordIndex: 0,
    arpIndex: 0,
    beatTimer: null,
    padNodes: [],
    melodyTimeout: null
  };

  // Musical scales (frequencies in Hz)
  var SCALES = {
    // Pentatonic scales in 432Hz tuning â€” warm, focus-friendly
    nexus:     [256.87, 288.33, 323.63, 384.91, 432.00, 513.74, 576.65, 647.25],  // C major pentatonic
    gardens:   [288.33, 323.63, 363.27, 432.00, 484.90, 576.65, 647.25, 726.53],  // D major pentatonic
    athenaeum: [242.45, 272.18, 323.63, 363.27, 407.75, 484.90, 544.36, 647.25],  // B minor pentatonic
    studio:    [323.63, 363.27, 407.75, 484.90, 544.36, 647.25, 726.53, 815.51],  // E major pentatonic
    wilds:     [216.00, 256.87, 288.33, 323.63, 384.91, 432.00, 513.74, 576.65],  // A minor pentatonic
    agora:     [342.88, 384.91, 432.00, 513.74, 576.65, 685.76, 769.82, 864.00],  // F major pentatonic
    commons:   [288.33, 342.88, 384.91, 432.00, 513.74, 576.65, 685.76, 769.82],  // D mixolydian penta
    arena:     [192.43, 228.84, 256.87, 288.33, 342.88, 384.91, 457.69, 513.74]   // G minor pentatonic
  };

  // Chord progressions per zone (indices into the scale)
  var CHORD_PROGRESSIONS = {
    nexus:     [[0, 2, 4], [1, 3, 5], [2, 4, 6], [0, 3, 5]],
    gardens:   [[0, 2, 4], [2, 4, 6], [1, 3, 5], [0, 2, 5]],
    athenaeum: [[0, 2, 4], [1, 3, 5], [0, 3, 5], [2, 4, 6]],
    studio:    [[0, 2, 4], [1, 4, 6], [2, 4, 6], [0, 3, 5]],
    wilds:     [[0, 2, 4], [1, 3, 5], [0, 2, 5], [1, 4, 6]],
    agora:     [[0, 2, 4], [1, 3, 5], [2, 4, 6], [0, 2, 5]],
    commons:   [[0, 2, 4], [2, 4, 6], [1, 3, 5], [0, 3, 5]],
    arena:     [[0, 2, 4], [0, 3, 5], [1, 4, 6], [2, 4, 6]]
  };

  // Tempo and feel per zone (beat duration in seconds)
  var ZONE_MUSIC_STYLE = {
    nexus:     { beatDuration: 2.8, padVolume: 0.07, melodyChance: 0.15, melodyVolume: 0.03, type: 'ethereal' },
    gardens:   { beatDuration: 2.4, padVolume: 0.06, melodyChance: 0.2,  melodyVolume: 0.035, type: 'pastoral' },
    athenaeum: { beatDuration: 3.2, padVolume: 0.05, melodyChance: 0.1,  melodyVolume: 0.025, type: 'mysterious' },
    studio:    { beatDuration: 2.0, padVolume: 0.06, melodyChance: 0.25, melodyVolume: 0.04, type: 'creative' },
    wilds:     { beatDuration: 3.0, padVolume: 0.04, melodyChance: 0.12, melodyVolume: 0.03, type: 'nature' },
    agora:     { beatDuration: 1.8, padVolume: 0.05, melodyChance: 0.2,  melodyVolume: 0.035, type: 'lively' },
    commons:   { beatDuration: 2.4, padVolume: 0.06, melodyChance: 0.18, melodyVolume: 0.03, type: 'warm' },
    arena:     { beatDuration: 2.0, padVolume: 0.07, melodyChance: 0.15, melodyVolume: 0.035, type: 'dramatic' }
  };

  // Time-of-day modifiers
  var TIME_MODIFIERS = {
    dawn:    { tempoMult: 0.8, volumeMult: 0.6, melodyMult: 0.5, octaveShift: 0 },
    morning: { tempoMult: 0.9, volumeMult: 0.8, melodyMult: 0.8, octaveShift: 0 },
    midday:  { tempoMult: 1.0, volumeMult: 1.0, melodyMult: 1.0, octaveShift: 0 },
    afternoon: { tempoMult: 1.0, volumeMult: 0.9, melodyMult: 0.9, octaveShift: 0 },
    evening: { tempoMult: 0.85, volumeMult: 0.7, melodyMult: 0.6, octaveShift: -1 },
    night:   { tempoMult: 0.7, volumeMult: 0.4, melodyMult: 0.3, octaveShift: -1 }
  };

  function startMusic(zone, timeOfDay) {
    if (!audioContext || !masterGain) return;
    zone = zone || 'nexus';
    timeOfDay = timeOfDay || 'midday';

    // Stop existing music if playing
    if (musicState.playing) {
      stopMusic();
    }

    musicState.zone = zone;
    musicState.timeOfDay = timeOfDay;
    musicState.playing = true;
    musicState.chordIndex = 0;
    musicState.noteIndex = 0;
    musicState.arpIndex = 0;

    // Start the pad drone
    playPadChord();

    // Schedule melody notes
    scheduleMelody();
  }

  function playPadChord() {
    if (!audioContext || !masterGain || !musicState.playing) return;

    var zone = musicState.zone || 'nexus';
    var scale = SCALES[zone] || SCALES.nexus;
    var progression = CHORD_PROGRESSIONS[zone] || CHORD_PROGRESSIONS.nexus;
    var style = ZONE_MUSIC_STYLE[zone] || ZONE_MUSIC_STYLE.nexus;
    var timeMod = TIME_MODIFIERS[musicState.timeOfDay] || TIME_MODIFIERS.midday;

    var chordIndices = progression[musicState.chordIndex % progression.length];
    var beatDur = style.beatDuration / timeMod.tempoMult;
    var chordDuration = beatDur * 4; // 4 beats per chord

    // Clean up old pad nodes
    cleanupPadNodes();

    // Create pad oscillators for each note in the chord
    for (var i = 0; i < chordIndices.length; i++) {
      var noteIdx = chordIndices[i];
      var freq = scale[noteIdx % scale.length];

      // Apply octave shift for time of day
      if (timeMod.octaveShift < 0) freq *= 0.5;
      if (timeMod.octaveShift > 0) freq *= 2;

      // Pad uses two detuned oscillators for warmth
      for (var d = 0; d < 2; d++) {
        var osc = audioContext.createOscillator();
        var gain = audioContext.createGain();
        var filter = audioContext.createBiquadFilter();

        osc.type = (style.type === 'ethereal' || style.type === 'mysterious') ? 'sine' : 'triangle';
        osc.frequency.value = freq + (d === 0 ? -1.5 : 1.5); // lo-fi warm detune

        filter.type = 'lowpass';
        filter.frequency.value = 500;
        filter.Q.value = 0.7;

        var padVol = style.padVolume * timeMod.volumeMult * musicState.volume;
        var now = audioContext.currentTime;

        // Fade in
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(padVol, now + chordDuration * 0.15);
        // Sustain
        gain.gain.setValueAtTime(padVol, now + chordDuration * 0.7);
        // Fade out
        gain.gain.linearRampToValueAtTime(0, now + chordDuration);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(masterGain);

        osc.start(now);
        osc.stop(now + chordDuration + 0.1);

        musicState.padNodes.push({ osc: osc, gain: gain, filter: filter, endTime: now + chordDuration + 0.2 });
      }
    }

    // Arpeggio â€” occasionally play individual notes from the chord
    if (Math.random() < 0.6) {
      var arpDelay = beatDur * 0.5;
      for (var a = 0; a < 3; a++) {
        (function(arpIdx, delay) {
          setTimeout(function() {
            if (!musicState.playing || !audioContext) return;
            var arpFreq = scale[chordIndices[arpIdx % chordIndices.length] % scale.length];
            if (timeMod.octaveShift < 0) arpFreq *= 0.5;
            arpFreq *= 2; // One octave up for sparkle

            var arpOsc = audioContext.createOscillator();
            var arpGain = audioContext.createGain();

            arpOsc.type = 'sine';
            arpOsc.frequency.value = arpFreq;

            var arpVol = style.melodyVolume * timeMod.volumeMult * musicState.volume * 0.6;
            var t = audioContext.currentTime;
            arpGain.gain.setValueAtTime(0, t);
            arpGain.gain.linearRampToValueAtTime(arpVol, t + 0.05);
            arpGain.gain.exponentialRampToValueAtTime(0.001, t + beatDur * 0.8);

            arpOsc.connect(arpGain);
            arpGain.connect(masterGain);
            arpOsc.start(t);
            arpOsc.stop(t + beatDur);
          }, delay * 1000);
        })(a, arpDelay * (a + 1));
      }
    }

    // Schedule next chord
    musicState.chordIndex++;
    musicState.beatTimer = setTimeout(function() {
      if (musicState.playing) playPadChord();
    }, chordDuration * 1000);
  }

  function scheduleMelody() {
    if (!audioContext || !masterGain || !musicState.playing) return;

    var zone = musicState.zone || 'nexus';
    var scale = SCALES[zone] || SCALES.nexus;
    var style = ZONE_MUSIC_STYLE[zone] || ZONE_MUSIC_STYLE.nexus;
    var timeMod = TIME_MODIFIERS[musicState.timeOfDay] || TIME_MODIFIERS.midday;

    var melodyChance = style.melodyChance * timeMod.melodyMult;
    var beatDur = style.beatDuration / timeMod.tempoMult;

    // Random delay before next melody note
    var delay = beatDur * (1 + Math.random() * 3);

    musicState.melodyTimeout = setTimeout(function() {
      if (!musicState.playing || !audioContext) return;

      if (Math.random() < melodyChance) {
        // Pick a note from the scale â€” favor stepwise motion
        var direction = Math.random() < 0.5 ? 1 : -1;
        var step = Math.random() < 0.7 ? 1 : 2;
        musicState.noteIndex = Math.max(0, Math.min(scale.length - 1, musicState.noteIndex + direction * step));
        var freq = scale[musicState.noteIndex];
        if (timeMod.octaveShift < 0) freq *= 0.5;
        freq *= 2; // Melody one octave up

        var melOsc = audioContext.createOscillator();
        var melGain = audioContext.createGain();
        var melFilter = audioContext.createBiquadFilter();

        // Vary timbre by zone
        if (style.type === 'nature' || style.type === 'pastoral') {
          melOsc.type = 'sine';
        } else if (style.type === 'dramatic' || style.type === 'lively') {
          melOsc.type = 'triangle';
        } else {
          melOsc.type = Math.random() < 0.5 ? 'sine' : 'triangle';
        }

        melOsc.frequency.value = freq;

        melFilter.type = 'lowpass';
        melFilter.frequency.value = 700;

        var melVol = style.melodyVolume * timeMod.volumeMult * musicState.volume;
        var noteDur = beatDur * (0.5 + Math.random() * 1.5);
        var t = audioContext.currentTime;

        melGain.gain.setValueAtTime(0, t);
        melGain.gain.linearRampToValueAtTime(melVol, t + 0.03);
        melGain.gain.setValueAtTime(melVol * 0.8, t + noteDur * 0.5);
        melGain.gain.exponentialRampToValueAtTime(0.001, t + noteDur);

        melOsc.connect(melFilter);
        melFilter.connect(melGain);
        melGain.connect(masterGain);

        melOsc.start(t);
        melOsc.stop(t + noteDur + 0.1);

        // Occasionally add a harmony note
        if (Math.random() < 0.25) {
          var harmIdx = (musicState.noteIndex + 2) % scale.length;
          var harmFreq = scale[harmIdx] * 2;
          if (timeMod.octaveShift < 0) harmFreq *= 0.5;

          var harmOsc = audioContext.createOscillator();
          var harmGain = audioContext.createGain();

          harmOsc.type = 'sine';
          harmOsc.frequency.value = harmFreq;

          var harmVol = melVol * 0.4;
          harmGain.gain.setValueAtTime(0, t + 0.05);
          harmGain.gain.linearRampToValueAtTime(harmVol, t + 0.1);
          harmGain.gain.exponentialRampToValueAtTime(0.001, t + noteDur * 0.8);

          harmOsc.connect(harmGain);
          harmGain.connect(masterGain);
          harmOsc.start(t + 0.05);
          harmOsc.stop(t + noteDur);
        }
      }

      // Schedule next melody note
      scheduleMelody();
    }, delay * 1000);
  }

  function cleanupPadNodes() {
    var now = audioContext ? audioContext.currentTime : 0;
    musicState.padNodes = musicState.padNodes.filter(function(node) {
      if (now > node.endTime) {
        try {
          node.osc.disconnect();
          node.gain.disconnect();
          node.filter.disconnect();
        } catch (e) {}
        return false;
      }
      return true;
    });
  }

  function stopMusic() {
    musicState.playing = false;

    if (musicState.beatTimer) {
      clearTimeout(musicState.beatTimer);
      musicState.beatTimer = null;
    }
    if (musicState.melodyTimeout) {
      clearTimeout(musicState.melodyTimeout);
      musicState.melodyTimeout = null;
    }

    // Fade out all pad nodes
    for (var i = 0; i < musicState.padNodes.length; i++) {
      try {
        var node = musicState.padNodes[i];
        if (node.gain && audioContext) {
          node.gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
        }
      } catch (e) {}
    }

    // Clean up after fade
    setTimeout(function() {
      for (var i = 0; i < musicState.padNodes.length; i++) {
        try {
          musicState.padNodes[i].osc.disconnect();
          musicState.padNodes[i].gain.disconnect();
          musicState.padNodes[i].filter.disconnect();
        } catch (e) {}
      }
      musicState.padNodes = [];
    }, 600);
  }

  function updateMusic(zone, timeOfDay) {
    if (!musicState.playing) return;
    if (zone && zone !== musicState.zone) {
      startMusic(zone, timeOfDay || musicState.timeOfDay);
    } else if (timeOfDay && timeOfDay !== musicState.timeOfDay) {
      musicState.timeOfDay = timeOfDay;
      // Time changes take effect on next chord cycle naturally
    }
  }

  function setMusicVolume(vol) {
    musicState.volume = Math.max(0, Math.min(1, vol));
  }

  function isMusicPlaying() {
    return musicState.playing;
  }

  // â”€â”€â”€ Piano Accent System (BotW-style environmental cues) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Piano-like timbre: layered sine + soft triangle with fast attack, gentle decay
  // Each accent is a short melodic phrase triggered by world events

  var PIANO_ACCENTS = {
    dawn: {
      // Ascending bright arpeggio â€” C major pentatonic, hopeful
      notes: [261.63, 329.63, 392.00, 523.25, 659.25],
      noteSpacing: 0.12,
      noteDuration: 0.6,
      volume: 0.05
    },
    morning: {
      // Warm arpeggiated phrase â€” G major, gentle awakening
      notes: [392.00, 493.88, 587.33, 783.99, 987.77, 783.99],
      noteSpacing: 0.1,
      noteDuration: 0.5,
      volume: 0.04
    },
    dusk: {
      // Descending gentle â€” Am pentatonic, wistful
      notes: [880.00, 659.25, 523.25, 440.00, 329.63],
      noteSpacing: 0.15,
      noteDuration: 0.7,
      volume: 0.04
    },
    night: {
      // Low mysterious â€” Dm tones, sparse and atmospheric
      notes: [146.83, 174.61, 220.00, 196.00, 146.83],
      noteSpacing: 0.22,
      noteDuration: 0.9,
      volume: 0.04
    },
    zone_discovery: {
      // Flourish â€” ascending with a resolving turn, wonder
      notes: [392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 659.25, 783.99],
      noteSpacing: 0.09,
      noteDuration: 0.45,
      volume: 0.06
    },
    quest_complete: {
      // Triumphant fanfare phrase â€” C major with octave leap
      notes: [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50, 1318.51],
      noteSpacing: 0.1,
      noteDuration: 0.5,
      volume: 0.06
    },
    achievement: {
      // Playful ascending â€” sparkling discovery
      notes: [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50],
      noteSpacing: 0.08,
      noteDuration: 0.4,
      volume: 0.06
    }
  };

  function playPianoAccent(type) {
    if (!audioContext || !masterGain) return;
    var accent = PIANO_ACCENTS[type];
    if (!accent) return;

    // Resume context if suspended
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    var musicVol = volumeLevels.music !== undefined ? volumeLevels.music : 0.5;
    var baseVol = accent.volume * musicVol;

    try {
      for (var i = 0; i < accent.notes.length; i++) {
        (function(idx) {
          var freq = accent.notes[idx];
          var startTime = audioContext.currentTime + idx * accent.noteSpacing;

          // Layer 1: sine wave (fundamental â€” warm piano body)
          var osc1 = audioContext.createOscillator();
          var gain1 = audioContext.createGain();
          osc1.type = 'sine';
          osc1.frequency.value = freq;
          gain1.gain.setValueAtTime(0, startTime);
          gain1.gain.linearRampToValueAtTime(baseVol, startTime + 0.015);
          gain1.gain.exponentialRampToValueAtTime(baseVol * 0.6, startTime + accent.noteDuration * 0.3);
          gain1.gain.exponentialRampToValueAtTime(0.001, startTime + accent.noteDuration);
          osc1.connect(gain1);
          gain1.connect(masterGain);
          osc1.start(startTime);
          osc1.stop(startTime + accent.noteDuration + 0.05);

          // Layer 2: triangle wave (soft harmonic â€” adds "hammer" brightness)
          var osc2 = audioContext.createOscillator();
          var gain2 = audioContext.createGain();
          osc2.type = 'triangle';
          osc2.frequency.value = freq * 2; // octave above for shimmer
          gain2.gain.setValueAtTime(0, startTime);
          gain2.gain.linearRampToValueAtTime(baseVol * 0.3, startTime + 0.01);
          gain2.gain.exponentialRampToValueAtTime(0.001, startTime + accent.noteDuration * 0.5);
          osc2.connect(gain2);
          gain2.connect(masterGain);
          osc2.start(startTime);
          osc2.stop(startTime + accent.noteDuration * 0.5 + 0.05);

          // Layer 3: very quiet high sine for soft attack (reduced from 4x to 3x, minimal volume)
          var osc3 = audioContext.createOscillator();
          var gain3 = audioContext.createGain();
          osc3.type = 'sine';
          osc3.frequency.value = freq * 3;
          gain3.gain.setValueAtTime(0, startTime);
          gain3.gain.linearRampToValueAtTime(baseVol * 0.03, startTime + 0.005);
          gain3.gain.exponentialRampToValueAtTime(0.001, startTime + 0.06);
          osc3.connect(gain3);
          gain3.connect(masterGain);
          osc3.start(startTime);
          osc3.stop(startTime + 0.1);
        })(i);
      }
    } catch (err) {
      // Graceful degradation â€” no crash if Web Audio fails
    }
  }

  function getPianoAccentTypes() {
    return PIANO_ACCENTS;
  }

  // Export public API
  exports.initAudio = initAudio;
  exports.playAmbient = playAmbient;
  exports.playSound = playSound;
  exports.playFootstep = playFootstep;
  exports.setVolume = setVolume;
  exports.mute = mute;
  exports.unmute = unmute;
  exports.stopAll = stopAll;

  // Time-of-day and weather ambient
  exports.updateAmbientTime = updateAmbientForTime;
  exports.updateAmbientWeather = updateAmbientForWeather;
  exports.setZoneAmbient = setZoneAmbient;

  // NPC sounds
  exports.playNPCSound = playNPCSound;

  // Music system
  exports.startMusic = startMusic;
  exports.stopMusic = stopMusic;
  exports.updateMusic = updateMusic;
  exports.setMusicVolume = setMusicVolume;
  exports.isMusicPlaying = isMusicPlaying;

  // Piano accent system
  exports.playPianoAccent = playPianoAccent;
  exports.getPianoAccentTypes = getPianoAccentTypes;

})(typeof module !== 'undefined' ? module.exports : (window.Audio = {}));


// LAZY_LOAD_START: npc_dialogue
// npc_dialogue.js
/**
 * npc_dialogue.js â€” LLM-Powered NPC Dialogue System for ZION
 *
 * Provides prompt construction, response parsing, fallback responses,
 * dialogue management, memory integration, and culture emergence detection.
 *
 * UMD module: works in browser (window.NpcDialogue) and Node.js
 */
(function(exports) {
  'use strict';

  // ============================================================================
  // CONSTANTS
  // ============================================================================

  var MAX_PROMPT_CHARS = 2000;       // ~500 tokens at 4 chars/token
  var MAX_SPEECH_CHARS = 200;        // Max speech bubble length
  var DEFAULT_COOLDOWN_MS = 30000;   // 30 seconds between NPC utterances
  var DEFAULT_MAX_QUEUE = 50;        // Max pending dialogue requests
  var TREND_MIN_OCCURRENCES = 2;     // Min mentions for a trend to register
  var MEMORY_MAX_INTERACTIONS = 20;  // How many interactions to remember

  // ============================================================================
  // ARCHETYPE VOICE PROFILES
  // ============================================================================

  var VOICE_PROFILES = {
    gardener: {
      style: 'warm, nurturing, uses plant metaphors',
      markers: ['bloom', 'grow', 'root', 'soil', 'harvest', 'seed', 'tend', 'flourish'],
      openers: ['The soil tells me', 'Like a young seedling', 'In the garden of', 'Let it grow'],
      mood: 'peaceful and caring'
    },
    builder: {
      style: 'practical, direct, uses spatial language',
      markers: ['structure', 'foundation', 'build', 'craft', 'design', 'solid', 'measure'],
      openers: ['From the ground up', 'Let me be direct', 'The foundation is', 'Structurally speaking'],
      mood: 'focused and methodical'
    },
    storyteller: {
      style: 'dramatic, narrative structure, often begins with "Once..." or "There was..."',
      markers: ['once', 'tale', 'legend', 'story', 'chapter', 'narrative', 'journey'],
      openers: ['Once upon a time', 'There was a day', 'Legend has it', 'Let me tell you of'],
      mood: 'dramatic and engaging'
    },
    merchant: {
      style: 'shrewd, value-aware, deal-making language',
      markers: ['trade', 'value', 'deal', 'exchange', 'profit', 'cost', 'worth', 'fair'],
      openers: ['Let me offer you', 'A fair trade would be', "I'll tell you what", 'The value here is'],
      mood: 'calculating but friendly'
    },
    explorer: {
      style: 'excited, uses discovery language, often begins with "Have you seen..."',
      markers: ['discover', 'found', 'explore', 'adventure', 'uncharted', 'horizon', 'journey'],
      openers: ['Have you seen', 'Just discovered', 'Beyond that ridge', 'I mapped a new'],
      mood: 'excited and curious'
    },
    teacher: {
      style: 'patient, questioning, Socratic style',
      markers: ['consider', 'what if', 'think', 'learn', 'understand', 'question', 'wisdom'],
      openers: ['Have you considered', 'What do you think', 'A wise person once', 'Consider this'],
      mood: 'patient and thoughtful'
    },
    musician: {
      style: 'lyrical, rhythmic speech, references sounds and music',
      markers: ['melody', 'rhythm', 'harmony', 'song', 'notes', 'vibration', 'tune', 'play'],
      openers: ['The melody of', 'In perfect harmony', 'Life has a rhythm', 'Listen closely'],
      mood: 'expressive and rhythmic'
    },
    healer: {
      style: 'empathetic, gentle, body and wellness language',
      markers: ['heal', 'care', 'rest', 'breathe', 'gentle', 'balance', 'restore', 'comfort'],
      openers: ['Take a deep breath', 'Your wellbeing matters', 'Let me help you', 'With gentle care'],
      mood: 'compassionate and calm'
    },
    philosopher: {
      style: 'questioning, abstract, often uses "What if..." or poses dilemmas',
      markers: ['truth', 'existence', 'meaning', 'wonder', 'contemplate', 'ponder', 'essence'],
      openers: ['What if we considered', 'The deeper question is', 'In the grand scheme', 'Ponder this'],
      mood: 'contemplative and abstract'
    },
    artist: {
      style: 'visual, emotional, references color, shape, and beauty',
      markers: ['color', 'light', 'beautiful', 'create', 'inspire', 'vision', 'texture', 'express'],
      openers: ['The colors here remind me', 'I see beauty in', 'Art is everywhere', 'Notice the light'],
      mood: 'creative and emotionally expressive'
    }
  };

  // ============================================================================
  // FALLBACK RESPONSE POOLS (per archetype, per context)
  // Keyed by archetype, then context type
  // ============================================================================

  var FALLBACK_POOLS = {
    gardener: {
      greeting: [
        "Welcome! The gardens are alive with color today.",
        "Ah, a visitor! Let me show you the moonflowers.",
        "Hello, friend. Have you ever seen soil this rich?",
        "Welcome to the gardens â€” feel free to take in the beauty.",
        "Greetings! The herbs are especially fragrant today.",
        "Hello there! Every plant here has a story to tell.",
        "Welcome! Like a new seed, you've found good ground.",
        "Come in, come in! The garden always has room for more.",
        "Well met! I just finished planting a new flower bed.",
        "Hello! The garden whispers your name in the breeze."
      ],
      zone_comment: [
        "These gardens are the heart of ZION â€” life flows from here.",
        "Every flower here was planted with intention and love.",
        "The soil remembers every rain, every season.",
        "I tend this land daily. It gives back tenfold.",
        "Gardens teach patience â€” you can't rush a bloom.",
        "Notice how the light falls differently each hour here.",
        "This zone breathes. You can feel it if you stand still.",
        "Every path through here was worn by gentle footsteps.",
        "The gardens know when someone cares for them.",
        "We planted the first seeds here together as a community."
      ],
      idle_chat: [
        "The compost bin is turning beautifully this week.",
        "I'm deciding what to plant in the east bed next season.",
        "Did you know each flower here has medicinal uses?",
        "I've been cross-breeding two varieties â€” exciting experiment!",
        "The bees have been especially active today.",
        "Sometimes I just sit and watch the plants grow.",
        "A garden is a conversation between human and earth.",
        "I found a rare seedling on the hillside this morning.",
        "The rain last night was a gift to the soil.",
        "I dream in greens and bloom-colors."
      ],
      weather: [
        "Rain is a gardener's greatest ally â€” welcome, clouds!",
        "Sunshine like this makes everything grow just a bit faster.",
        "Storm coming? The plants can feel it too.",
        "Perfect weather for transplanting today.",
        "The mist this morning was magical on the flower beds.",
        "Wind like this carries seeds to new places â€” I love it.",
        "A cloudy day means I can work longer without the heat.",
        "The weather shapes the garden as much as my hands do.",
        "I planted these drought-resistant varieties just in time.",
        "Every weather pattern teaches the garden something new."
      ],
      craft: [
        "I'm weaving a basket to carry my harvest tools.",
        "I pressed some flowers earlier â€” nature's artwork.",
        "Making a tincture from these herbs takes real patience.",
        "I've been composting â€” turning waste into wealth.",
        "Grafting two rose varieties together is delicate work.",
        "I hand-tied every vine to the trellis this morning.",
        "Drying these herbs will preserve their strength all winter.",
        "I'm constructing a new raised bed from reclaimed wood.",
        "Seed sorting is meditative â€” I love every moment of it.",
        "My latest project: a garden that blooms in moonlight."
      ]
    },

    builder: {
      greeting: [
        "Hey! Solid ground here â€” good place to start something.",
        "Welcome. I was just reviewing some structural plans.",
        "Hello! Every great city starts with a single stone.",
        "Greetings. You look like someone who appreciates good construction.",
        "Good to see you. The agora has some impressive new foundations.",
        "Welcome to ZION â€” built to last, designed to inspire.",
        "Hello there. I was just measuring the load capacity here.",
        "Well met. Notice the craftsmanship on that archway?",
        "Hey! I can tell you built something once â€” the look in your eyes.",
        "Welcome. Strong foundations make strong communities."
      ],
      zone_comment: [
        "The agora's market stalls are structurally impressive.",
        "I designed those arches â€” three-point load distribution.",
        "Everything here was built to last a hundred years.",
        "The materials from the wilds made for excellent timber.",
        "That wall there has a hidden drainage channel inside.",
        "I love how the light hits these stone surfaces at dusk.",
        "Every structure in ZION started as a sketch in my notebook.",
        "The nexus obelisk â€” now THAT is a construction challenge.",
        "I've surveyed every zone. This one has the best site lines.",
        "Building in community is different â€” each stone has a story."
      ],
      idle_chat: [
        "I'm calculating the beam load for a new workshop extension.",
        "Timber or stone? That's the eternal builder's dilemma.",
        "I've been sketching plans for a public bathhouse.",
        "Measure twice, cut once â€” the builder's first law.",
        "The quarry site has some promising granite deposits.",
        "I just finished a commission â€” a communal storage hall.",
        "I've been stress-testing new mortar mixtures all week.",
        "A good roof changes everything about a space.",
        "I'm prototyping a new joint design â€” stronger than any before.",
        "Space shapes behavior â€” that's what architecture is really about."
      ],
      weather: [
        "Wind this strong tests mortar joints â€” I'm taking notes.",
        "Rain reveals every flaw in a structure. Educational.",
        "Perfect dry weather for laying stone foundations.",
        "I designed the drainage here specifically for heavy rain.",
        "Hot sun like this cures mortar faster â€” efficient.",
        "Storm coming â€” checking all the anchoring points.",
        "A builder reads weather like a farmer reads soil.",
        "I reinforced those windows before the last big storm.",
        "Humidity affects wood expansion â€” I account for it.",
        "Every storm improves the next building I design."
      ],
      craft: [
        "Joining two load-bearing beams is art and engineering combined.",
        "I'm hand-carving decorative corbels for the library extension.",
        "Cutting precise dovetail joints takes years of practice.",
        "I mixed a new plaster formula â€” smoother than ever.",
        "Laying a perfectly level floor is deeply satisfying.",
        "I forge my own tools â€” custom weight and balance.",
        "Today: fitting the keystone into a new archway.",
        "Stonemasonry and patience are the same skill.",
        "The joints in that wall will outlast us all.",
        "I'm crafting a scale model before the real build."
      ]
    },

    storyteller: {
      greeting: [
        "Ah, a new face! Every face holds a story untold.",
        "Welcome! I was just composing a verse about this very moment.",
        "Greetings, traveler! I hope your journey here was eventful.",
        "There was once a stranger who walked into ZION... that's you!",
        "Hello! Legend has it the best stories begin with a chance meeting.",
        "Welcome! Sit â€” let me tell you how this world began.",
        "Once, on a day like today, a hero arrived. Perhaps that is you.",
        "Ah! A new chapter begins. Welcome to ZION.",
        "Greetings! Your arrival adds a page to our ongoing saga.",
        "Hello, friend. Every great story needs a new character."
      ],
      zone_comment: [
        "The athenaeum holds a thousand tales between its walls.",
        "Once, the agora witnessed a debate that changed everything.",
        "The gardens have been the setting for love stories and tragedies.",
        "This zone is where Act Two always happens â€” the turning point.",
        "The nexus is where all paths cross â€” and stories intertwine.",
        "Every stone here has witnessed something worth remembering.",
        "The wilds hold stories older than any of us know.",
        "I recorded everything that happened here in my chronicle.",
        "They say this place was founded by dreamers â€” I believe it.",
        "The echo here carries words spoken long ago."
      ],
      idle_chat: [
        "I'm writing the third volume of the ZION Chronicles.",
        "A good story requires a villain â€” even if it's just winter.",
        "The best tales I've collected came from unexpected people.",
        "I've been interviewing every NPC in ZION for their stories.",
        "Plot twist: the gardener was a philosopher all along.",
        "My quill is worn from writing. That means it was a good day.",
        "I've been searching for the perfect ending to an old tale.",
        "Every conversation I have becomes research.",
        "I'm cataloging the oral traditions of ZION's founding.",
        "Some stories take years to be ready to be told."
      ],
      weather: [
        "A storm like this inspired one of my best passages.",
        "Rain and candlelight â€” perfect conditions for writing.",
        "The wind tonight reminds me of the tale of the wandering bard.",
        "Every weather pattern becomes atmosphere in a good story.",
        "Sunshine like this was how I described the hero's victory.",
        "The mist reminds me of the legend of the ghost gardener.",
        "Nature writes the best first drafts. I just transcribe.",
        "Thunder! Perfect punctuation for a dramatic chapter.",
        "A clear night sky is where the oldest stories were written.",
        "Even the weather here tells a story if you listen."
      ],
      craft: [
        "Crafting a narrative arc is harder than it sounds.",
        "I'm illustrating my new collection with hand-drawn maps.",
        "Binding a book by hand is its own kind of storytelling.",
        "Writing the perfect opening sentence took me three days.",
        "I'm composing a ballad about the founding of ZION.",
        "Character development is everything â€” plot is just what happens.",
        "I've been carving story-runes into this walking staff.",
        "The craft of dialogue is knowing when NOT to speak.",
        "Every revision makes the story more true.",
        "I'm compiling an anthology of every voice in this world."
      ]
    },

    merchant: {
      greeting: [
        "Welcome! I always say good business starts with good people.",
        "Hello there! See anything that catches your eye?",
        "Greetings! I just got a fresh shipment you might like.",
        "Welcome to my corner of ZION â€” fair prices, honest trade.",
        "Ah, a potential customer! Let me tell you what's special today.",
        "Hello! The best deals go fast â€” good timing on your part.",
        "Welcome. I believe in mutual benefit â€” shall we talk?",
        "Greetings! Every transaction is the start of a relationship.",
        "Hello! I've been expecting someone with your discerning eye.",
        "Welcome â€” I have something rare that might interest you."
      ],
      zone_comment: [
        "The agora is ZION's economic heart â€” and I know every beat.",
        "Market conditions here are favorable. I've studied the patterns.",
        "Every stall in this market has a specialty. Mine is quality.",
        "I've traded across every zone â€” the agora has the best flow.",
        "This location gets foot traffic from all directions. Ideal.",
        "The commerce here benefits everyone â€” that's sustainable trade.",
        "I've built my reputation here over hundreds of transactions.",
        "Value flows from where trust is established. That's here.",
        "The market has its own rhythm â€” I've learned to read it.",
        "Every zone has something to offer. I connect them all."
      ],
      idle_chat: [
        "I'm reviewing my inventory manifest from yesterday's trades.",
        "Supply and demand â€” once you understand it, everything's clear.",
        "I've been researching what resources are scarce in the wilds.",
        "A good merchant knows when NOT to sell as well as when to.",
        "I traded three rare gems for exclusive garden produce today.",
        "Negotiation is an art. I practice it every day.",
        "I keep a ledger of every transaction â€” patterns emerge.",
        "The best deal I ever made was built on mutual respect.",
        "I'm scouting for new trade routes between zones.",
        "Commerce is community â€” money is just the language."
      ],
      weather: [
        "Rain slows the foot traffic but the serious buyers still come.",
        "Clear skies mean more visitors â€” better for business.",
        "I keep waterproof tarps for exactly this kind of weather.",
        "A hot day means cold goods sell fast. I've prepared.",
        "Wind like this blows away casual browsers â€” good for focus.",
        "Storm warning? I've already secured my inventory.",
        "Every weather condition creates different trading opportunities.",
        "I sell hand-made umbrellas when it rains. Always prepared.",
        "The weather affects prices. I track it like a ledger.",
        "Sun or storm â€” a merchant adapts."
      ],
      craft: [
        "I've been crafting specialized carrying cases for rare goods.",
        "Pricing is a craft â€” it requires skill and knowledge.",
        "I'm hand-lettering new signs for my market stall.",
        "Contract writing is an underrated craft. I take it seriously.",
        "I've been making custom packaging for fragile trade goods.",
        "Negotiating a multi-party trade deal takes real craft.",
        "I'm crafting a new display system for rare artifacts.",
        "The craft of appraisal takes decades to master.",
        "I've been building a reference compendium of goods and values.",
        "Packaging is part of the value â€” I craft it carefully."
      ]
    },

    explorer: {
      greeting: [
        "Have you seen the northern peaks? Incredible view up there!",
        "Hello! Just got back from the outer wilds â€” you won't believe it.",
        "Welcome! I mapped three new trails this week.",
        "Hey! If you haven't been to the coastal cliffs yet, go NOW.",
        "Greetings! The world is so much bigger than the map suggests.",
        "Welcome to ZION! I know all the secret paths if you're interested.",
        "Hello, adventurer! I can tell you have wandering eyes.",
        "Hey! Adventure finds the ones who seek it. Like us.",
        "Welcome! I've been waiting for someone to share my discoveries with.",
        "Greetings! Every corner of this world holds a wonder."
      ],
      zone_comment: [
        "The wilds extend much further than the official maps show.",
        "I found a hidden valley beyond the eastern ridge yesterday.",
        "This zone has three secret passages most people never find.",
        "The terrain changes dramatically just past that treeline.",
        "I've catalogued every landmark in a five-zone radius.",
        "There's a waterfall hidden behind the moss wall over there.",
        "The best view in all of ZION is from the cliffside I found.",
        "I've camped in every zone â€” the wilds has the best stars.",
        "The ecosystem shifts exactly fifty paces past this point.",
        "This spot is an old trail crossing â€” you can see the worn stone."
      ],
      idle_chat: [
        "I'm updating my map with three new trail markers.",
        "Just finished a full perimeter survey of the wilds.",
        "The creature migration patterns changed this season.",
        "I've been comparing old maps with new â€” things have shifted.",
        "My next expedition: the fog zone at the world's edge.",
        "I found evidence of structures older than ZION itself.",
        "Have you explored every zone? I have a checklist.",
        "The horizon is always more interesting than where you stand.",
        "I keep a journal of every discovery â€” it's five volumes now.",
        "There's always more to find. That's what keeps me going."
      ],
      weather: [
        "Rain like this reveals hidden streams I'd never have noticed.",
        "Wind from the north means the fog will clear by afternoon.",
        "Perfect storm conditions for observing how terrain changes.",
        "I've explored in every weather â€” storms are the most exciting.",
        "Mist like this is perfect for finding hidden paths.",
        "Lightning last night revealed a cave I'd never seen before.",
        "Explorers don't wait for good weather. We find beauty in all.",
        "Snow would open up new terrain â€” I can't wait.",
        "The rain reveals the true drainage of this landscape.",
        "Weather is just terrain in the sky."
      ],
      craft: [
        "I'm hand-drawing a detailed topographic map of the eastern zones.",
        "Crafting a reliable compass from local materials was a challenge.",
        "I've been building a lightweight shelter system for expeditions.",
        "Making waterproof trail markers is surprisingly technical.",
        "I've been assembling an explorer's field kit from local materials.",
        "Craft a good camp and the wilderness becomes your home.",
        "I've been weaving rope strong enough for cliff descents.",
        "Repairing my pack after the last expedition took all morning.",
        "I made a sextant replica to practice celestial navigation.",
        "Every tool I carry, I made or modified myself."
      ]
    },

    teacher: {
      greeting: [
        "Welcome! Tell me â€” what would you like to learn today?",
        "Greetings! Every moment is an opportunity to learn something.",
        "Hello! I always find that new faces ask the best questions.",
        "Welcome to ZION. What knowledge brought you here?",
        "Greetings! A student arrives at the perfect moment.",
        "Hello. Have you considered what you already know?",
        "Welcome! Teaching begins with listening. So â€” how are you?",
        "Greetings! I've prepared a new lesson plan you might enjoy.",
        "Hello! Wisdom is the one resource that grows when shared.",
        "Welcome! Ask me anything â€” I love a good question."
      ],
      zone_comment: [
        "The athenaeum holds knowledge that takes lifetimes to exhaust.",
        "This space was designed for learning â€” notice the acoustics.",
        "Every surface here has been touched by a student's curiosity.",
        "I've taught here for many seasons. The students teach me too.",
        "Knowledge radiates outward from places like this.",
        "The scrolls in the athenaeum date back to ZION's founding.",
        "Have you considered why this zone was placed at this location?",
        "A learning environment shapes the quality of thinking itself.",
        "Every student who sat here left something behind.",
        "The library's collection grows by twelve volumes per season."
      ],
      idle_chat: [
        "I've been preparing a series of lectures on ZION's history.",
        "What do you think is the most important thing to teach a child?",
        "I'm revising my curriculum based on last season's questions.",
        "A good question is worth more than a hundred good answers.",
        "I've been corresponding with philosophers across all zones.",
        "My students asked me something yesterday I couldn't answer. Wonderful.",
        "Learning never stops â€” even for the teacher.",
        "I'm compiling questions no one has answered yet.",
        "The best lesson I ever taught was the one I hadn't planned.",
        "Education is the gift that can't be taken away."
      ],
      weather: [
        "Rain is an excellent metaphor for how knowledge accumulates.",
        "I asked my students to describe the storm using only verbs.",
        "Weather provides endless natural science opportunities.",
        "Have you considered why rain falls downward and not upward?",
        "The sun's angle today would make a fine geometry lesson.",
        "Mist like this is perfect for discussing atmospheric science.",
        "I assign outdoor observation during weather like this.",
        "Wind carries seeds â€” and ideas â€” farther than we expect.",
        "Every natural phenomenon is a question waiting to be asked.",
        "A good teacher turns every thunderstorm into a lecture."
      ],
      craft: [
        "I'm hand-illustrating a new educational text on botany.",
        "Teaching is a craft that improves only through practice.",
        "I've been designing interactive learning tools for the library.",
        "Writing curriculum is like crafting a journey for the mind.",
        "I'm building model structures to illustrate architectural concepts.",
        "The craft of explaining complex ideas simply â€” that takes years.",
        "I've been carving educational relief maps for tactile learners.",
        "Binding a textbook is the final step in creating knowledge.",
        "I'm crafting question cards for collaborative learning sessions.",
        "A lesson plan is a blueprint for discovery."
      ]
    },

    musician: {
      greeting: [
        "Welcome! Can you hear the music in this world?",
        "Hello! The wind makes a perfect fifth today.",
        "Greetings! I was just composing something for this moment.",
        "Welcome to ZION â€” have you noticed it has its own song?",
        "Hello! Music is the fastest way to feel at home.",
        "Greetings! Every footstep here is part of a rhythm.",
        "Welcome! I've been waiting to share a new melody.",
        "Hello, friend! The world sounds different with fresh ears.",
        "Greetings! I could write a whole symphony about this place.",
        "Welcome! If you listen carefully, ZION hums."
      ],
      zone_comment: [
        "The acoustics here are extraordinary â€” listen to that echo.",
        "The agora's market sounds form a natural symphony.",
        "I perform in this zone every evening â€” the resonance is perfect.",
        "The gardens have a subsonic hum on quiet mornings.",
        "Sound travels differently here. I've mapped the acoustic zones.",
        "Every zone in ZION has its own musical key, I believe.",
        "The stone walls here create natural reverb. Extraordinary.",
        "I've recorded the ambient sounds of every zone.",
        "The wind through those arches plays a natural flute note.",
        "When rain falls here, it creates my favorite percussion."
      ],
      idle_chat: [
        "I'm transcribing a melody I dreamed last night.",
        "The pentatonic scale works beautifully for ZION's atmosphere.",
        "I've been collecting folk songs from every zone.",
        "A good improvisation session teaches you who you really are.",
        "I've been experimenting with harmonic structures from nature.",
        "Sometimes silence is the most important note.",
        "I'm composing a piece that captures all four seasons.",
        "The intervals between sounds matter as much as the sounds.",
        "I've been teaching rhythm workshops at the agora.",
        "Music is time made beautiful."
      ],
      weather: [
        "Rain is perfect percussion â€” I've been recording it.",
        "Wind like this creates a natural drone note. I love it.",
        "A storm is the world's most powerful orchestra.",
        "I hear a dominant seventh chord in that thunder.",
        "The silence before a storm is the best rest I know.",
        "Sun and birdsong create a natural major key atmosphere.",
        "Mist softens all the sounds into something dreamlike.",
        "I compose specifically to weather. Rain pieces, sun pieces.",
        "Every weather pattern has its own rhythm and tempo.",
        "Nature plays the opening movement. I write the rest."
      ],
      craft: [
        "I've been hand-crafting a new string instrument from local wood.",
        "Composing is like architecture â€” structure supports freedom.",
        "I'm refining a new tuning system for this climate.",
        "Hand-carving the sound holes is the most precise work.",
        "I've been inlaying decorative patterns into my instrument.",
        "Writing music notation by hand is a meditative practice.",
        "I'm crafting a reed instrument from marsh grass.",
        "The craft of improvisation takes a lifetime of preparation.",
        "I've been building a percussion ensemble from found objects.",
        "Crafting a lute from scratch changes how you understand music."
      ]
    },

    healer: {
      greeting: [
        "Welcome! Take a deep breath â€” you're safe here.",
        "Hello there. How are you, truly?",
        "Greetings! The healing grove welcomes all who need rest.",
        "Welcome! I always have time to listen.",
        "Hello, friend. You look like you could use some calm.",
        "Greetings! Care is the first and most important medicine.",
        "Welcome! Let me know if there's anything I can do.",
        "Hello. Sometimes just being greeted is what's needed most.",
        "Welcome to ZION. Rest when you need â€” this is a safe place.",
        "Hello! Your presence here is a gift to us all."
      ],
      zone_comment: [
        "The gardens hold every medicinal plant ZION needs.",
        "The healing energy of this zone is palpable, isn't it?",
        "I've identified thirty-seven medicinal plants in this area.",
        "Water and greenery together create the best healing conditions.",
        "The air here has a quality that promotes deep breathing.",
        "I tend to the herbs in that bed â€” all for wellness purposes.",
        "This zone attracts those who need restoration.",
        "Every healer I know has spent time in the gardens.",
        "The sound of water here is therapeutic. Proven to calm the mind.",
        "I built a small sanctuary in the eastern part of this zone."
      ],
      idle_chat: [
        "I've been preparing a new herbal salve for sore muscles.",
        "Preventative care is the most powerful healing of all.",
        "I've been documenting the healing properties of local plants.",
        "Rest is underrated as a medicine. I prescribe it often.",
        "Community and connection heal things herbs can't.",
        "I've been practicing a new breathing technique.",
        "The body knows how to heal. I just help it remember.",
        "I'm creating a wellness guide for every zone in ZION.",
        "Listening without judgment is my most-used skill.",
        "A healer's work is never truly done â€” and that's beautiful."
      ],
      weather: [
        "Rain nourishes the medicinal herbs more than anything I do.",
        "The cool air after rain helps with inflammation.",
        "Sun like this is excellent for vitamin-rich herb growth.",
        "Mist in the morning is when I collect the finest dew.",
        "Storm energy can be grounding if you breathe through it.",
        "Cold weather means immunity tonics become essential.",
        "Every season brings different wellness challenges.",
        "Rain is the earth healing itself. I find it comforting.",
        "The wind carries healing pollen from the distant flowers.",
        "Weather is medicine when you learn to listen to it."
      ],
      craft: [
        "I've been crafting a new compound salve from seven herbs.",
        "Distilling herbal tinctures is precise, patient work.",
        "I'm weaving a new poultice wrap from medicinal fibers.",
        "Crafting a remedy requires understanding root causes.",
        "I'm blending a new tea mixture for stress and sleep.",
        "Hand-pressing herbal tablets is satisfying, careful work.",
        "I've been creating illustrated charts of medicinal plant uses.",
        "Steeping time affects potency â€” I time everything exactly.",
        "I'm crafting a new treatment protocol for cold-weather ailments.",
        "The craft of healing is mostly listening and observing."
      ]
    },

    philosopher: {
      greeting: [
        "Welcome! What if I told you your arrival was inevitable?",
        "Greetings. What is the nature of a greeting, truly?",
        "Hello! Have you ever considered what 'here' means?",
        "Welcome! The very act of meeting is a philosophical event.",
        "Greetings! I've been contemplating chance versus destiny.",
        "Hello, seeker! What question brought you to ZION?",
        "Welcome. What is it you're really looking for?",
        "Greetings! Every arrival is also a departure from somewhere.",
        "Hello! If a visitor arrives unseen, have they truly arrived?",
        "Welcome! The universe arranged this meeting. Interesting."
      ],
      zone_comment: [
        "What does a place mean when no one is observing it?",
        "This zone raises questions I've been pondering for seasons.",
        "Place shapes thought â€” have you felt that here?",
        "The athenaeum is where certainty goes to become questions.",
        "If a tree falls in the wilds with no one nearby... you know the rest.",
        "I chose this spot precisely because it provokes thinking.",
        "Every location in ZION holds a different philosophical mood.",
        "The nexus is where paradox is most comfortable.",
        "This zone feels like a question mark in spatial form.",
        "Space is a kind of argument made physical."
      ],
      idle_chat: [
        "I've been considering whether free will is compatible with fate.",
        "What if consciousness is what the universe uses to know itself?",
        "I'm tracing the history of an idea across multiple civilizations.",
        "The most important questions have the simplest surfaces.",
        "I've been cataloguing logical paradoxes found in nature.",
        "If you had to define ZION in one word, what would it be?",
        "I've been questioning the nature of questioning itself.",
        "What would ZION look like if no one remembered it?",
        "Thinking without a goal is the purest form of thinking.",
        "I've been wrong about something for years. Now I see it clearly."
      ],
      weather: [
        "Rain falls the same on philosopher and stone â€” equalizing.",
        "Is a storm violent, or is violence a human judgment?",
        "What if weather is the sky's way of having emotions?",
        "The sun illuminates â€” but what hides in that very light?",
        "Wind moves everything except the questions underneath.",
        "Thunder is the universe punctuating its own thoughts.",
        "What does it mean for weather to be 'good' or 'bad'?",
        "I observe the storm without preference. It simply is.",
        "Mist makes the familiar strange again. Philosophically useful.",
        "Every weather pattern reveals how we impose meaning on chaos."
      ],
      craft: [
        "Writing philosophy is less craft, more excavation.",
        "I'm constructing a thought experiment in essay form.",
        "The craft of argument is knowing when to stop speaking.",
        "I've been designing a new logical framework from first principles.",
        "Philosophical dialogue is the highest collaborative art.",
        "I'm mapping the connections between contradictory ideas.",
        "The structure of a sound argument is its own kind of beauty.",
        "I've been crafting counterarguments to my own positions.",
        "Writing a question is harder than writing an answer.",
        "The craft of philosophy is learning to sit with uncertainty."
      ]
    },

    artist: {
      greeting: [
        "Welcome! Notice the way light falls on everything here.",
        "Hello! I was just mixing a new color I discovered in the sunset.",
        "Greetings! Have you seen the mural by the eastern wall?",
        "Welcome! Your face has wonderful character â€” may I sketch you?",
        "Hello! Art is everywhere if you look with open eyes.",
        "Greetings! Something about your arrival inspired a new piece.",
        "Welcome to ZION! The beauty here is inexhaustible.",
        "Hello! I find strangers are often the most inspiring subjects.",
        "Greetings! This world deserves to be seen and made.",
        "Welcome! I've been painting since dawn â€” what do you see?"
      ],
      zone_comment: [
        "The light in this zone changes every hour â€” I never tire of it.",
        "I've painted this view from twenty different angles.",
        "Every texture here tells a story of wind, water, and time.",
        "The color palette of this zone shifts with the seasons.",
        "I installed three murals here â€” they've become landmarks.",
        "The way shadow falls in this space is endlessly interesting.",
        "Beauty reveals itself differently to different eyes here.",
        "I've filled seven sketchbooks just from this one zone.",
        "The negative space between these structures is as important as the structures.",
        "This zone inspired my most celebrated series."
      ],
      idle_chat: [
        "I've been experimenting with pigments made from local stones.",
        "Every piece I make is a conversation with the viewer.",
        "I've been studying how different surfaces accept color.",
        "Creativity is the practice of seeing what already exists.",
        "I'm working on a triptych inspired by the three moons.",
        "The hardest part of art is knowing when it's finished.",
        "I sketch everything â€” it's how I think.",
        "I've been creating sculptures from materials found in the wilds.",
        "Art without vulnerability is just decoration.",
        "I'm in a period of experimentation. Everything is allowed."
      ],
      weather: [
        "Rain changes color temperature dramatically â€” I love painting it.",
        "Storm light is the most dramatic light there is.",
        "The gray of an overcast sky has fifty different colors in it.",
        "Mist turns every scene into an impressionist painting.",
        "Golden hour in a storm is the most beautiful contradiction.",
        "I set up outside in the rain specifically to capture this.",
        "Every weather condition produces a different emotional palette.",
        "Wind creates movement in everything â€” animation for free.",
        "I have a whole series called 'Weather as Medium'.",
        "Snow would transform every color here. I can't wait."
      ],
      craft: [
        "I've been grinding local minerals into pigment all morning.",
        "The craft of seeing comes before the craft of making.",
        "I'm building a new frame from driftwood and copper wire.",
        "Mixing the perfect shade takes patience and intuition.",
        "I've been experimenting with encaustic wax painting.",
        "Every brushstroke is a decision â€” thousands per piece.",
        "I'm weaving a tapestry from naturally-dyed fibers.",
        "Hand-casting bronze sculptures is exhausting and beautiful.",
        "The craft of composition is knowing what to leave out.",
        "I'm creating a mosaic using only materials from ZION."
      ]
    }
  };

  // Default fallback pool for unknown archetypes
  var DEFAULT_FALLBACK_POOL = [
    "Welcome to ZION! It's a beautiful day.",
    "Hello there! I'm glad you found your way here.",
    "Greetings, traveler! What brings you to this part of the world?",
    "Good to see you! This place has something special about it.",
    "Hello! Every day here is a new adventure.",
    "Welcome! The community here is warm and welcoming.",
    "Greetings! I love meeting new people in ZION.",
    "Hello! There's always something interesting happening here.",
    "Welcome! Take your time and explore.",
    "Greetings! This world is full of wonders."
  ];

  // Context type to fallback pool key mapping
  var CONTEXT_TYPE_MAP = {
    'greeting': 'greeting',
    'zone_comment': 'zone_comment',
    'zone': 'zone_comment',
    'idle': 'idle_chat',
    'idle_chat': 'idle_chat',
    'weather': 'weather',
    'craft': 'craft',
    'crafting': 'craft'
  };

  // ============================================================================
  // STOP WORDS for topic detection
  // ============================================================================

  var STOP_WORDS = {
    'the': 1, 'a': 1, 'an': 1, 'and': 1, 'or': 1, 'but': 1, 'in': 1,
    'on': 1, 'at': 1, 'to': 1, 'for': 1, 'of': 1, 'with': 1, 'is': 1,
    'it': 1, 'i': 1, 'you': 1, 'we': 1, 'they': 1, 'this': 1, 'that': 1,
    'was': 1, 'are': 1, 'be': 1, 'been': 1, 'have': 1, 'has': 1, 'do': 1,
    'did': 1, 'so': 1, 'if': 1, 'my': 1, 'me': 1, 'he': 1, 'she': 1,
    'from': 1, 'by': 1, 'as': 1, 'not': 1, 'no': 1, 'can': 1, 'just': 1,
    'what': 1, 'how': 1, 'who': 1, 'when': 1, 'here': 1, 'there': 1,
    'like': 1, 'its': 1, 'all': 1, 'been': 1, 'about': 1, 'up': 1,
    'more': 1, 'some': 1, 'would': 1, 'their': 1, 'will': 1, 'your': 1
  };

  // ============================================================================
  // OPINION TEMPLATES per archetype for culture emergence
  // ============================================================================

  var OPINION_TEMPLATES = {
    gardener: [
      "From a gardener's view, {topic} is like planting â€” it takes patience and care.",
      "I think about {topic} the way I think about soil â€” it needs the right conditions to flourish.",
      "{topic} reminds me of tending plants. You have to listen to what's already there.",
      "My opinion on {topic}: nurture it, and it will grow. Rush it, and it won't.",
      "The gardens teach me about {topic} â€” everything cycles, everything has its season."
    ],
    builder: {
      templates: [
        "Let me be direct about {topic}: it needs a strong foundation or it will fail.",
        "The structure of {topic} matters more than its surface â€” I'd start from the base.",
        "My take on {topic}: measure twice, decide once. No shortcuts.",
        "{topic} is a construction problem. Identify the load-bearing elements.",
        "Practically speaking, {topic} requires clear planning before any action."
      ]
    },
    storyteller: {
      templates: [
        "There was once a world that faced {topic}... and here is what happened.",
        "Every great story has {topic} as its conflict. The question is the resolution.",
        "Legend says {topic} was decided long ago. But every legend can be rewritten.",
        "The most compelling chapter of any saga always involves {topic}.",
        "I've heard a hundred tales about {topic}. The wisest had no clear answer."
      ]
    },
    merchant: {
      templates: [
        "The value of {topic} depends entirely on what you're willing to trade for it.",
        "Let me assess {topic} like a trade: what's the cost, what's the benefit?",
        "In my experience, {topic} is worth investing in â€” when the timing is right.",
        "My honest appraisal of {topic}: undervalued by most, overrated by some.",
        "{topic} has real market potential. The smart move is to position early."
      ]
    },
    explorer: {
      templates: [
        "Have you explored every angle of {topic}? I find the edges most interesting.",
        "My first expedition into {topic} revealed things I hadn't expected.",
        "{topic} is uncharted territory for most people. That's exactly why it excites me.",
        "Beyond the obvious surface of {topic} is where the real discovery lives.",
        "I've mapped the terrain of {topic} and can tell you: the journey is worth it."
      ]
    },
    teacher: {
      templates: [
        "Consider this about {topic}: what do you already know, and what are you assuming?",
        "The key question about {topic} isn't what, but why. Start there.",
        "I've taught many lessons that touched on {topic}. The wisest students questioned everything.",
        "{topic} is a fascinating subject. What do YOU think about it?",
        "A Socratic approach to {topic}: challenge every assumption, find the root question."
      ]
    },
    musician: {
      templates: [
        "{topic} has a rhythm to it â€” sometimes you find it, sometimes you set it.",
        "In harmony terms, {topic} is a tension that wants resolution.",
        "There's a melody in {topic} if you listen for it.",
        "Every complex thing like {topic} has an underlying theme. Find that theme.",
        "My musical opinion on {topic}: it needs space. Let it breathe."
      ]
    },
    healer: {
      templates: [
        "From a wellness perspective, {topic} requires careful, gentle attention.",
        "I approach {topic} with the same care as healing â€” first, do no harm.",
        "The health of any situation like {topic} depends on what we nurture.",
        "{topic} can be a source of stress or strength. Choose your relationship with it.",
        "I believe {topic} needs compassion more than solutions right now."
      ]
    },
    philosopher: {
      templates: [
        "What if {topic} is not a problem but a question? Questions are more interesting.",
        "I've been contemplating {topic}. The more I consider it, the more uncertain I become.",
        "The true nature of {topic} depends on what we believe reality to be.",
        "Is {topic} real, or do we make it real by believing in it? Both, I suspect.",
        "Ponder this about {topic}: every position contains its own contradiction."
      ]
    },
    artist: {
      templates: [
        "I see {topic} as a palette â€” what colors are you choosing from it?",
        "The beauty in {topic} is in how it changes when you change your angle.",
        "I'd paint {topic} in deep blues and gold. It has that kind of weight.",
        "{topic} inspires me. Every challenge is just unfinished art.",
        "The texture of {topic} is rough at first, smooth with time. Worth feeling."
      ]
    }
  };

  // Normalize opinion templates to consistent format
  for (var arch in OPINION_TEMPLATES) {
    if (OPINION_TEMPLATES.hasOwnProperty(arch)) {
      var val = OPINION_TEMPLATES[arch];
      if (Array.isArray(val)) {
        OPINION_TEMPLATES[arch] = { templates: val };
      }
    }
  }

  var DEFAULT_OPINION_TEMPLATES = [
    "My honest view on {topic} is that it deserves careful thought.",
    "I find {topic} to be a genuinely interesting subject.",
    "{topic} is something the whole community should consider.",
    "When it comes to {topic}, I prefer to listen more than speak.",
    "I have mixed feelings about {topic} â€” it's more complex than it seems."
  ];

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  /**
   * Safe string accessor
   */
  function safeStr(val, fallback) {
    if (typeof val === 'string') return val;
    if (val == null) return (typeof fallback === 'string' ? fallback : '');
    return String(val);
  }

  /**
   * Seeded random number (simple hash-based)
   */
  function seededRandom(seed) {
    var x = Math.sin(seed + 1) * 10000;
    return x - Math.floor(x);
  }

  /**
   * Pick random element from array
   */
  function randomPick(arr) {
    if (!arr || arr.length === 0) return null;
    return arr[Math.floor(Math.random() * arr.length)];
  }

  /**
   * Pick random element using seeded random
   */
  function seededPick(arr, seed) {
    if (!arr || arr.length === 0) return null;
    var idx = Math.floor(seededRandom(seed) * arr.length);
    return arr[idx];
  }

  /**
   * Tokenize text into meaningful words (lowercased, stop-words removed)
   */
  function tokenize(text) {
    if (!text || typeof text !== 'string') return [];
    var words = text.toLowerCase().replace(/[^a-z\s]/g, '').split(/\s+/);
    var result = [];
    for (var i = 0; i < words.length; i++) {
      var w = words[i];
      if (w.length >= 3 && !STOP_WORDS[w]) {
        result.push(w);
      }
    }
    return result;
  }

  /**
   * Count word frequencies in an array of words
   */
  function countFrequencies(words) {
    var freq = {};
    for (var i = 0; i < words.length; i++) {
      var w = words[i];
      freq[w] = (freq[w] || 0) + 1;
    }
    return freq;
  }

  /**
   * Detect sentiment of text (simple positive/negative/neutral)
   */
  function detectSentiment(text) {
    if (!text) return 'neutral';
    var lower = text.toLowerCase();
    var positiveWords = ['love', 'beautiful', 'great', 'wonderful', 'amazing', 'perfect',
                         'excellent', 'joy', 'happy', 'good', 'best', 'incredible', 'fantastic'];
    var negativeWords = ['hate', 'terrible', 'awful', 'bad', 'wrong', 'broken', 'sad',
                         'difficult', 'hard', 'problem', 'trouble', 'fail', 'fear'];
    var posCount = 0;
    var negCount = 0;
    for (var i = 0; i < positiveWords.length; i++) {
      if (lower.indexOf(positiveWords[i]) !== -1) posCount++;
    }
    for (var j = 0; j < negativeWords.length; j++) {
      if (lower.indexOf(negativeWords[j]) !== -1) negCount++;
    }
    if (posCount > negCount) return 'positive';
    if (negCount > posCount) return 'negative';
    return 'neutral';
  }

  // ============================================================================
  // PROMPT CONSTRUCTION
  // ============================================================================

  /**
   * Build an LLM prompt for an NPC to speak based on context.
   * @param {object} npc - NPC data {name, archetype, personality, home_zone, memory}
   * @param {object} context - {zone, nearbyPlayers, recentChat, timeOfDay, weather, currentActivity}
   * @returns {string} prompt string (max ~2000 chars)
   */
  function buildPrompt(npc, context) {
    var name = safeStr(npc && npc.name, 'Unknown');
    var archetype = safeStr(npc && npc.archetype, 'citizen');
    var personality = (npc && Array.isArray(npc.personality) && npc.personality.length > 0)
      ? npc.personality.join(', ')
      : 'curious and friendly';
    var homeZone = safeStr(npc && npc.home_zone, 'nexus');

    context = context || {};
    var zone = safeStr(context.zone, homeZone);
    var timeOfDay = safeStr(context.timeOfDay, 'daytime');
    var weather = safeStr(context.weather, 'clear');
    var activity = safeStr(context.currentActivity, 'wandering');
    var nearbyPlayers = Array.isArray(context.nearbyPlayers) ? context.nearbyPlayers : [];
    var recentChat = Array.isArray(context.recentChat) ? context.recentChat : [];

    var voiceProfile = VOICE_PROFILES[archetype];
    var voiceStyle = voiceProfile ? voiceProfile.style : 'friendly and helpful';
    var voiceMood = voiceProfile ? voiceProfile.mood : 'neutral';

    // Get relevant memories
    var memories = npc ? getRelevantMemories(npc, context) : [];
    var memorySummary = memories.length > 0 ? summarizeMemories(memories) : '';

    // Build sections, being mindful of total length
    var sections = [];

    sections.push('You are ' + name + ', a ' + archetype + ' in ZION.');
    sections.push('Personality: ' + personality + '.');
    sections.push('Speaking style: ' + voiceStyle + '.');
    sections.push('Current mood: ' + voiceMood + '.');
    sections.push('Location: ' + zone + ' zone. Time: ' + timeOfDay + '. Weather: ' + weather + '.');
    sections.push('Current activity: ' + activity + '.');

    if (nearbyPlayers.length > 0) {
      sections.push('Nearby players: ' + nearbyPlayers.slice(0, 3).join(', ') + '.');
    }

    if (memorySummary) {
      sections.push('Recent memories: ' + memorySummary);
    }

    if (recentChat.length > 0) {
      var chatLines = [];
      var maxChat = Math.min(recentChat.length, 3);
      for (var i = Math.max(0, recentChat.length - maxChat); i < recentChat.length; i++) {
        var msg = recentChat[i];
        if (msg && msg.from && msg.message) {
          chatLines.push(msg.from + ': ' + msg.message);
        }
      }
      if (chatLines.length > 0) {
        sections.push('Recent conversation:\n' + chatLines.join('\n'));
      }
    }

    sections.push('Respond as ' + name + ' in 1-2 sentences, in character.');
    sections.push('You may include [ACTION: verb] or [EMOTION: word] tags if relevant.');

    var prompt = sections.join('\n');

    // Enforce max length
    if (prompt.length > MAX_PROMPT_CHARS) {
      prompt = prompt.substring(0, MAX_PROMPT_CHARS - 3) + '...';
    }

    return prompt;
  }

  /**
   * Build a prompt for NPC-to-NPC conversation.
   * @param {object} npc1 - First NPC
   * @param {object} npc2 - Second NPC
   * @param {string} [topic] - Optional conversation topic
   * @returns {string} prompt string
   */
  function buildConversationPrompt(npc1, npc2, topic) {
    var name1 = safeStr(npc1 && npc1.name, 'Citizen A');
    var arch1 = safeStr(npc1 && npc1.archetype, 'citizen');
    var name2 = safeStr(npc2 && npc2.name, 'Citizen B');
    var arch2 = safeStr(npc2 && npc2.archetype, 'citizen');

    var voice1 = VOICE_PROFILES[arch1];
    var voice2 = VOICE_PROFILES[arch2];

    var sections = [
      'Two citizens of ZION are having a conversation.',
      name1 + ' is a ' + arch1 + '. ' + (voice1 ? 'Style: ' + voice1.style + '.' : ''),
      name2 + ' is a ' + arch2 + '. ' + (voice2 ? 'Style: ' + voice2.style + '.' : '')
    ];

    if (topic) {
      sections.push('They are discussing: ' + topic);
    } else {
      sections.push('They are chatting about everyday life in ZION.');
    }

    sections.push('Write one line from ' + name1 + ' responding to ' + name2 + ', in character.');
    sections.push('Format: [' + name1 + ']: (their line)');

    var prompt = sections.join('\n');
    if (prompt.length > MAX_PROMPT_CHARS) {
      prompt = prompt.substring(0, MAX_PROMPT_CHARS - 3) + '...';
    }
    return prompt;
  }

  /**
   * Build a prompt for an NPC reacting to a world event.
   * @param {object} npc - NPC data
   * @param {object} event - {type, data}
   * @returns {string} prompt string
   */
  function buildReactionPrompt(npc, event) {
    var name = safeStr(npc && npc.name, 'Citizen');
    var archetype = safeStr(npc && npc.archetype, 'citizen');
    var personality = (npc && Array.isArray(npc.personality) && npc.personality.length > 0)
      ? npc.personality.join(', ')
      : 'curious';

    var eventType = safeStr(event && event.type, 'unknown_event');
    var eventData = (event && event.data) ? JSON.stringify(event.data) : '{}';

    var voice = VOICE_PROFILES[archetype];
    var style = voice ? voice.style : 'friendly';

    var prompt = [
      'You are ' + name + ', a ' + archetype + ' in ZION.',
      'Personality: ' + personality + '.',
      'Speaking style: ' + style + '.',
      'A world event just occurred: ' + eventType + '.',
      'Event details: ' + eventData,
      'React to this event as ' + name + ' in 1 sentence, in character.',
      'You may include [ACTION: verb] or [EMOTION: word] tags.'
    ].join('\n');

    if (prompt.length > MAX_PROMPT_CHARS) {
      prompt = prompt.substring(0, MAX_PROMPT_CHARS - 3) + '...';
    }
    return prompt;
  }

  // ============================================================================
  // RESPONSE PROCESSING
  // ============================================================================

  /**
   * Parse a raw LLM response into structured fields.
   * @param {string|null} rawResponse - The raw text response
   * @returns {{message: string, action: string, emotion: string, memory: string}}
   */
  function parseResponse(rawResponse) {
    var empty = { message: '', action: '', emotion: '', memory: '' };

    if (rawResponse == null || rawResponse === undefined) {
      return empty;
    }

    var raw = String(rawResponse);

    // Extract [ACTION: ...] tags
    var action = '';
    var actionMatch = raw.match(/\[ACTION:\s*([^\]]+)\]/i);
    if (actionMatch) {
      action = actionMatch[1].trim();
      raw = raw.replace(/\[ACTION:\s*[^\]]+\]/gi, '');
    }

    // Extract [EMOTION: ...] tags
    var emotion = '';
    var emotionMatch = raw.match(/\[EMOTION:\s*([^\]]+)\]/i);
    if (emotionMatch) {
      emotion = emotionMatch[1].trim();
      raw = raw.replace(/\[EMOTION:\s*[^\]]+\]/gi, '');
    }

    // Extract [MEMORY: ...] tags
    var memory = '';
    var memoryMatch = raw.match(/\[MEMORY:\s*([^\]]+)\]/i);
    if (memoryMatch) {
      memory = memoryMatch[1].trim();
      raw = raw.replace(/\[MEMORY:\s*[^\]]+\]/gi, '');
    }

    // Clean up remaining text
    var message = raw.trim();

    return { message: message, action: action, emotion: emotion, memory: memory };
  }

  /**
   * Sanitize a response string for safe display.
   * @param {string} response - Raw response text
   * @returns {string} cleaned, trimmed string
   */
  function sanitize(response) {
    if (response == null || response === undefined) return '';

    var text = String(response).trim();

    // Remove AI meta-text patterns
    var metaPatterns = [
      /As an AI( language model)?[,.]?\s*/gi,
      /I am an AI( assistant)?[,.]?\s*/gi,
      /I'm an AI( assistant)?[,.]?\s*/gi,
      /As a (language model|AI|chatbot)[,.]?\s*/gi,
      /Note:\s*I am[^.]*\./gi
    ];

    for (var i = 0; i < metaPatterns.length; i++) {
      text = text.replace(metaPatterns[i], '');
    }

    // Remove harmful/inappropriate content patterns (all-ages world)
    var bannedPatterns = [
      /\b(stupid|idiot|hate|kill|die|death|damn|hell|crap|ass)\b/gi
    ];

    for (var j = 0; j < bannedPatterns.length; j++) {
      text = text.replace(bannedPatterns[j], '---');
    }

    // Trim again after replacements
    text = text.trim();

    // Enforce max length (200 chars for speech bubbles)
    if (text.length > MAX_SPEECH_CHARS) {
      // Try to cut at a sentence or word boundary
      var truncated = text.substring(0, MAX_SPEECH_CHARS);
      var lastSpace = truncated.lastIndexOf(' ');
      if (lastSpace > MAX_SPEECH_CHARS * 0.7) {
        truncated = truncated.substring(0, lastSpace);
      }
      text = truncated.trim();
    }

    return text;
  }

  // ============================================================================
  // DIALOGUE MANAGER
  // ============================================================================

  /**
   * Create a dialogue manager.
   * @param {object} [config] - {cooldownMs, maxQueueSize}
   * @returns {object} manager
   */
  function createManager(config) {
    config = config || {};
    var cooldownMs = typeof config.cooldownMs === 'number' ? config.cooldownMs : DEFAULT_COOLDOWN_MS;
    var maxQueueSize = typeof config.maxQueueSize === 'number' ? config.maxQueueSize : DEFAULT_MAX_QUEUE;

    // FIFO queue of {npc, context}
    var queue = [];
    // npcId -> {response, timestamp}
    var responses = {};
    // npcId -> last speak timestamp
    var lastSpoke = {};
    // 'npc1Id:npc2Id' -> [{speaker, message, timestamp}]
    var conversations = {};

    /**
     * Add an NPC dialogue request to the queue.
     * Respects cooldown and max queue size.
     */
    function queueDialogue(npc, context) {
      if (!npc || !npc.id) return;

      // Respect cooldown
      var now = Date.now();
      var last = lastSpoke[npc.id] || 0;
      if (now - last < cooldownMs) return;

      // Respect max queue
      if (queue.length >= maxQueueSize) return;

      // Don't add same NPC twice if already queued
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].npc.id === npc.id) return;
      }

      queue.push({ npc: npc, context: context || {} });
    }

    /**
     * Process the next item in the queue using the provided inference function.
     * @param {function} inferenceFunction - function(prompt, callback(err, response))
     */
    function processQueue(inferenceFunction) {
      if (queue.length === 0) return;

      var item = queue.shift(); // FIFO
      var prompt = buildPrompt(item.npc, item.context);

      inferenceFunction(prompt, function(err, rawResponse) {
        if (err) {
          // On error, use fallback
          rawResponse = getFallback(item.npc, item.context);
        }

        var now = Date.now();
        var parsed = parseResponse(rawResponse);
        var clean = sanitize(parsed.message || rawResponse);

        responses[item.npc.id] = {
          raw: rawResponse,
          parsed: parsed,
          message: clean,
          timestamp: now
        };

        lastSpoke[item.npc.id] = now;
      });
    }

    /**
     * Get the latest response for an NPC.
     * @param {object} npc - NPC with id
     * @returns {object|null} response object or null
     */
    function getResponse(npc) {
      if (!npc || !npc.id) return null;
      return responses[npc.id] || null;
    }

    /**
     * Get remaining cooldown for an NPC in ms.
     * @param {string} npcId
     * @returns {number} ms remaining (0 if no cooldown)
     */
    function getCooldown(npcId) {
      if (!npcId) return 0;
      var last = lastSpoke[npcId] || 0;
      if (last === 0) return 0;
      var remaining = cooldownMs - (Date.now() - last);
      return Math.max(0, remaining);
    }

    /**
     * Get conversation history between two NPCs.
     * @param {string} npc1Id
     * @param {string} npc2Id
     * @returns {Array} conversation history
     */
    function getConversation(npc1Id, npc2Id) {
      var key = [npc1Id, npc2Id].sort().join(':');
      return conversations[key] || [];
    }

    /**
     * Record a conversation line between two NPCs.
     * @param {string} npc1Id
     * @param {string} npc2Id
     * @param {string} speaker
     * @param {string} message
     */
    function recordConversation(npc1Id, npc2Id, speaker, message) {
      var key = [npc1Id, npc2Id].sort().join(':');
      if (!conversations[key]) conversations[key] = [];
      conversations[key].push({
        speaker: speaker,
        message: message,
        timestamp: Date.now()
      });
      // Keep conversation history bounded
      if (conversations[key].length > 50) {
        conversations[key] = conversations[key].slice(-50);
      }
    }

    return {
      queueDialogue: queueDialogue,
      processQueue: processQueue,
      getResponse: getResponse,
      getCooldown: getCooldown,
      getConversation: getConversation,
      recordConversation: recordConversation
    };
  }

  // ============================================================================
  // FALLBACK SYSTEM
  // ============================================================================

  /**
   * Get a canned fallback response matching personality/situation.
   * @param {object} npc - {archetype, name, personality}
   * @param {object} context - {type, weather, zone}
   * @returns {string} response text
   */
  function getFallback(npc, context) {
    var archetype = safeStr(npc && npc.archetype, '');
    context = context || {};
    var contextType = safeStr(context.type, 'greeting');

    // Normalize context type
    var poolKey = CONTEXT_TYPE_MAP[contextType] || 'greeting';

    var archetypePool = FALLBACK_POOLS[archetype];
    if (!archetypePool) {
      // Unknown archetype: use default pool
      return randomPick(DEFAULT_FALLBACK_POOL) || "Hello! Welcome to ZION.";
    }

    var pool = archetypePool[poolKey];
    if (!pool || pool.length === 0) {
      // Try greeting as fallback-of-fallback
      pool = archetypePool['greeting'] || DEFAULT_FALLBACK_POOL;
    }

    var response = randomPick(pool);
    if (!response) response = "Hello! Welcome to ZION.";

    // Replace {name} placeholder if NPC name available
    var name = safeStr(npc && npc.name, '');
    if (name) {
      response = response.replace(/\{name\}/g, name);
    }

    return response;
  }

  /**
   * Generate the complete fallback pool for an archetype.
   * @param {string} archetype - NPC archetype
   * @returns {Array<string>} array of response strings
   */
  function generateFallbackPool(archetype) {
    if (!archetype) {
      return DEFAULT_FALLBACK_POOL.slice();
    }

    var archetypeStr = String(archetype);
    var archetypePool = FALLBACK_POOLS[archetypeStr];
    if (!archetypePool) {
      return DEFAULT_FALLBACK_POOL.slice();
    }

    // Collect all responses across all context types for this archetype
    var allResponses = [];
    var contextTypes = Object.keys(archetypePool);
    for (var i = 0; i < contextTypes.length; i++) {
      var pool = archetypePool[contextTypes[i]];
      if (Array.isArray(pool)) {
        for (var j = 0; j < pool.length; j++) {
          allResponses.push(pool[j]);
        }
      }
    }

    return allResponses.length > 0 ? allResponses : DEFAULT_FALLBACK_POOL.slice();
  }

  // ============================================================================
  // MEMORY INTEGRATION
  // ============================================================================

  /**
   * Update NPC memory after a conversation.
   * @param {object} npc - NPC with memory object
   * @param {Array|null} conversation - Array of {speaker, message} objects
   * @returns {object} updated memory object
   */
  function updateMemory(npc, conversation) {
    if (!npc) return {};

    var memory = (npc.memory && typeof npc.memory === 'object')
      ? JSON.parse(JSON.stringify(npc.memory))  // shallow clone
      : {};

    if (!conversation || !Array.isArray(conversation)) {
      return memory;
    }

    if (!memory.interactions) memory.interactions = [];

    // Extract players mentioned in conversation
    var players = {};
    var topics = [];
    for (var i = 0; i < conversation.length; i++) {
      var msg = conversation[i];
      if (!msg) continue;
      var speaker = safeStr(msg.speaker, '');
      if (speaker && speaker !== safeStr(npc && npc.name, '')) {
        players[speaker] = true;
      }
      // Extract topics from message
      var msgWords = tokenize(safeStr(msg.message, ''));
      for (var j = 0; j < msgWords.length; j++) {
        topics.push(msgWords[j]);
      }
    }

    // Find most-mentioned topic
    var topicFreq = countFrequencies(topics);
    var topTopic = '';
    var topCount = 0;
    for (var word in topicFreq) {
      if (topicFreq.hasOwnProperty(word) && topicFreq[word] > topCount) {
        topCount = topicFreq[word];
        topTopic = word;
      }
    }

    // Record interaction
    var playerList = Object.keys(players);
    if (playerList.length > 0 || topTopic) {
      memory.interactions.push({
        with: playerList[0] || 'unknown',
        topic: topTopic || 'conversation',
        time: Date.now()
      });
    }

    // Bound interactions
    if (memory.interactions.length > MEMORY_MAX_INTERACTIONS) {
      memory.interactions = memory.interactions.slice(-MEMORY_MAX_INTERACTIONS);
    }

    // Increment greetings if applicable
    if (typeof memory.greetings_given === 'number') {
      // Only increment if first message looks like a greeting
      if (conversation.length > 0) {
        memory.greetings_given++;
      }
    }

    return memory;
  }

  /**
   * Get memories relevant to the current context.
   * @param {object} npc - NPC with memory
   * @param {object} context - {nearbyPlayers, zone}
   * @returns {Array} filtered, sorted memories
   */
  function getRelevantMemories(npc, context) {
    if (!npc || !npc.memory) return [];

    var memory = npc.memory;
    if (!memory.interactions || !Array.isArray(memory.interactions)) return [];

    context = context || {};
    var nearbyPlayers = Array.isArray(context.nearbyPlayers) ? context.nearbyPlayers : [];
    var zone = safeStr(context.zone, '');

    var now = Date.now();
    var oneDayMs = 86400000;

    // Score each memory by relevance
    var scored = [];
    for (var i = 0; i < memory.interactions.length; i++) {
      var mem = memory.interactions[i];
      if (!mem) continue;

      var score = 0;

      // Boost if player is nearby
      if (mem.with && nearbyPlayers.indexOf(mem.with) !== -1) {
        score += 10;
      }

      // Boost by recency
      var age = now - (mem.time || 0);
      if (age < oneDayMs) {
        score += Math.floor((oneDayMs - age) / (oneDayMs / 5));
      }

      // Include if reasonably relevant
      scored.push({ memory: mem, score: score });
    }

    // Sort by score descending
    scored.sort(function(a, b) { return b.score - a.score; });

    // Return top memories
    var result = [];
    var maxMems = 5;
    for (var j = 0; j < Math.min(scored.length, maxMems); j++) {
      result.push(scored[j].memory);
    }

    return result;
  }

  /**
   * Summarize a list of memories into a condensed string.
   * @param {Array} memories - Array of memory objects
   * @returns {string} condensed summary
   */
  function summarizeMemories(memories) {
    if (!memories || memories.length === 0) return '';

    var parts = [];
    var maxToInclude = Math.min(memories.length, 3);

    for (var i = 0; i < maxToInclude; i++) {
      var mem = memories[i];
      if (!mem) continue;
      var who = safeStr(mem.with, 'someone');
      var topic = safeStr(mem.topic, 'something');
      parts.push('talked with ' + who + ' about ' + topic);
    }

    if (memories.length > maxToInclude) {
      parts.push('and ' + (memories.length - maxToInclude) + ' more interactions');
    }

    return parts.join('; ');
  }

  // ============================================================================
  // CULTURE EMERGENCE
  // ============================================================================

  /**
   * Detect a trend across recent dialogues.
   * @param {Array|null} recentDialogues - [{npcId, message, timestamp?}]
   * @returns {{topic, sentiment, participants}|null}
   */
  function detectTrend(recentDialogues) {
    if (!recentDialogues || !Array.isArray(recentDialogues)) return null;
    if (recentDialogues.length < 2) return null;

    // Collect all words and participant tracking per word
    var wordParticipants = {};  // word -> [npcId]
    var wordMessages = {};      // word -> [message]

    for (var i = 0; i < recentDialogues.length; i++) {
      var dlg = recentDialogues[i];
      if (!dlg) continue;
      var words = tokenize(safeStr(dlg.message, ''));
      for (var j = 0; j < words.length; j++) {
        var w = words[j];
        if (!wordParticipants[w]) {
          wordParticipants[w] = [];
          wordMessages[w] = [];
        }
        // Track unique participants
        if (dlg.npcId && wordParticipants[w].indexOf(dlg.npcId) === -1) {
          wordParticipants[w].push(dlg.npcId);
        }
        wordMessages[w].push(safeStr(dlg.message, ''));
      }
    }

    // Find the word mentioned by the most unique participants
    var topWord = null;
    var topParticipantCount = 0;

    for (var word in wordParticipants) {
      if (!wordParticipants.hasOwnProperty(word)) continue;
      var count = wordParticipants[word].length;
      if (count > topParticipantCount) {
        topParticipantCount = count;
        topWord = word;
      }
    }

    if (!topWord || topParticipantCount < TREND_MIN_OCCURRENCES) return null;

    // Determine sentiment from the messages containing this word
    var relatedMessages = wordMessages[topWord];
    var combinedText = relatedMessages.join(' ');
    var sentiment = detectSentiment(combinedText);

    return {
      topic: topWord,
      sentiment: sentiment,
      participants: wordParticipants[topWord]
    };
  }

  /**
   * Get popular topics across dialogue history.
   * @param {Array} dialogueHistory - [{npcId, message, timestamp?}]
   * @param {number} [windowMs] - Optional time window in milliseconds
   * @returns {Array<{topic, count, sentiment}>} sorted by count descending
   */
  function getPopularTopics(dialogueHistory, windowMs) {
    if (!dialogueHistory || !Array.isArray(dialogueHistory) || dialogueHistory.length === 0) {
      return [];
    }

    var now = Date.now();
    var filtered = dialogueHistory;

    // Apply time window filter if provided
    if (typeof windowMs === 'number' && windowMs > 0) {
      filtered = [];
      for (var i = 0; i < dialogueHistory.length; i++) {
        var dlg = dialogueHistory[i];
        if (dlg && dlg.timestamp && (now - dlg.timestamp) <= windowMs) {
          filtered.push(dlg);
        } else if (dlg && !dlg.timestamp) {
          // No timestamp, include by default (for non-timestamped data)
          // Actually with window param, exclude undated entries
        }
      }
    }

    // Count word frequencies across all filtered dialogues
    var allWords = [];
    var wordMessages = {};  // word -> [message text]

    for (var j = 0; j < filtered.length; j++) {
      var entry = filtered[j];
      if (!entry) continue;
      var words = tokenize(safeStr(entry.message, ''));
      for (var k = 0; k < words.length; k++) {
        var w = words[k];
        allWords.push(w);
        if (!wordMessages[w]) wordMessages[w] = [];
        wordMessages[w].push(safeStr(entry.message, ''));
      }
    }

    var freq = countFrequencies(allWords);

    // Build sorted topic list
    var topics = [];
    for (var word in freq) {
      if (!freq.hasOwnProperty(word)) continue;
      var count = freq[word];
      if (count < 1) continue;
      var msgs = wordMessages[word] || [];
      var sentiment = detectSentiment(msgs.join(' '));
      topics.push({ topic: word, count: count, sentiment: sentiment });
    }

    // Sort by count descending
    topics.sort(function(a, b) { return b.count - a.count; });

    return topics;
  }

  /**
   * Generate an opinion string for an NPC about a topic.
   * @param {object} npc - {archetype, personality}
   * @param {string} topic - The topic to opine on
   * @returns {string} opinion string
   */
  function generateOpinion(npc, topic) {
    var archetype = safeStr(npc && npc.archetype, '');
    var topicStr = safeStr(topic, 'this matter');

    var templates;
    var archetypeData = OPINION_TEMPLATES[archetype];
    if (archetypeData && archetypeData.templates) {
      templates = archetypeData.templates;
    } else {
      templates = DEFAULT_OPINION_TEMPLATES;
    }

    var template = randomPick(templates);
    if (!template) template = DEFAULT_OPINION_TEMPLATES[0];

    return template.replace(/\{topic\}/g, topicStr || 'this matter');
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.buildPrompt = buildPrompt;
  exports.buildConversationPrompt = buildConversationPrompt;
  exports.buildReactionPrompt = buildReactionPrompt;

  exports.parseResponse = parseResponse;
  exports.sanitize = sanitize;

  exports.createManager = createManager;

  exports.getFallback = getFallback;
  exports.generateFallbackPool = generateFallbackPool;

  exports.updateMemory = updateMemory;
  exports.getRelevantMemories = getRelevantMemories;
  exports.summarizeMemories = summarizeMemories;

  exports.detectTrend = detectTrend;
  exports.getPopularTopics = getPopularTopics;
  exports.generateOpinion = generateOpinion;

})(typeof module !== 'undefined' ? module.exports : (window.NpcDialogue = {}));

// LAZY_LOAD_END: npc_dialogue

// npc_ai.js
/**
 * NPC_AI.js - Comprehensive NPC Artificial Intelligence Module
 * Inspired by Halo's AI systems but adapted for a peaceful MMO
 *
 * This module provides the "brain" for all NPC behavior, including:
 * - Perception system (environment, players, NPCs, events)
 * - Memory system (interactions, preferences, reputation)
 * - Goal/Drive system (archetype-specific motivations)
 * - Behavior tree (intelligent decision making)
 * - Daily schedules (time-based routines)
 * - Event reactions (contextual responses)
 * - Group dynamics (social behaviors)
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // CONSTANTS & CONFIGURATION
  // ============================================================================

  var PERCEPTION_RADIUS = 25; // How far NPCs can "see"
  var INTERACTION_COOLDOWN = 30000; // 30 seconds before re-greeting same player
  var MEMORY_DECAY_RATE = 0.001; // Per tick familiarity decay
  var MAX_INTERACTIONS_REMEMBERED = 20;
  var MAX_EVENTS_REMEMBERED = 10;
  var ENERGY_DECAY_RATE = 0.05; // Per minute
  var ENERGY_REGEN_RATE = 0.2; // Per minute when resting
  var FAMILIARITY_GAIN = 5; // Points per interaction
  var FAMILIARITY_THRESHOLD_FRIENDLY = 25;
  var FAMILIARITY_THRESHOLD_CLOSE = 60;
  var GROUP_FORMATION_RADIUS = 15;
  var WORK_SATISFACTION_GAIN = 10;

  // ============================================================================
  // ARCHETYPE DRIVES - Core motivations for each NPC type
  // ============================================================================

  var ARCHETYPE_DRIVES = {
    gardener: {
      primary: 'tend_plants',
      secondary: 'explore_flora',
      social: 'share_harvest',
      rest: 'sit_in_garden',
      work_locations: ['gardens', 'wilds'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'rain', // Loves rain
    },
    builder: {
      primary: 'inspect_structures',
      secondary: 'gather_materials',
      social: 'discuss_plans',
      rest: 'sketch_designs',
      work_locations: ['agora', 'construction_sites'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'clear',
    },
    storyteller: {
      primary: 'visit_athenaeum',
      secondary: 'collect_stories',
      social: 'tell_stories',
      rest: 'write_journal',
      work_locations: ['athenaeum', 'agora'],
      preferred_time: ['afternoon', 'evening'],
      weather_preference: 'any',
    },
    merchant: {
      primary: 'tend_shop',
      secondary: 'acquire_goods',
      social: 'negotiate_trade',
      rest: 'count_inventory',
      work_locations: ['agora', 'marketplace'],
      preferred_time: ['morning', 'midday', 'afternoon'],
      weather_preference: 'clear',
    },
    explorer: {
      primary: 'explore_wilds',
      secondary: 'map_territory',
      social: 'share_discoveries',
      rest: 'study_maps',
      work_locations: ['wilds', 'mountains', 'coastline'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'any', // Explorers don't care
    },
    teacher: {
      primary: 'teach_lesson',
      secondary: 'research',
      social: 'mentor_individual',
      rest: 'read_texts',
      work_locations: ['athenaeum', 'agora'],
      preferred_time: ['morning', 'afternoon'],
      weather_preference: 'clear',
    },
    musician: {
      primary: 'perform',
      secondary: 'compose',
      social: 'jam_session',
      rest: 'tune_instrument',
      work_locations: ['agora', 'amphitheater', 'gardens'],
      preferred_time: ['evening', 'night'],
      weather_preference: 'clear',
    },
    healer: {
      primary: 'tend_wounded',
      secondary: 'gather_herbs',
      social: 'offer_comfort',
      rest: 'meditate',
      work_locations: ['gardens', 'healing_grove', 'agora'],
      preferred_time: ['morning', 'midday'],
      weather_preference: 'clear',
    },
    philosopher: {
      primary: 'contemplate',
      secondary: 'debate',
      social: 'discuss_ideas',
      rest: 'stargaze',
      work_locations: ['overlook', 'gardens', 'athenaeum'],
      preferred_time: ['afternoon', 'evening', 'night'],
      weather_preference: 'clear',
    },
    artist: {
      primary: 'create_art',
      secondary: 'find_inspiration',
      social: 'show_work',
      rest: 'observe_beauty',
      work_locations: ['gardens', 'overlook', 'coastline'],
      preferred_time: ['morning', 'afternoon', 'evening'],
      weather_preference: 'any', // Artists find beauty in all weather
    }
  };

  // ============================================================================
  // DAILY SCHEDULE - Time-based behavior modifiers
  // ============================================================================

  var DAILY_SCHEDULE = {
    dawn: {
      hours: [5, 7],
      activity: 'wake_stretch',
      energy_regen: 0.5,
      social_chance: 0.1,
      work_priority: 0.3,
    },
    morning: {
      hours: [7, 12],
      activity: 'primary_work',
      energy_regen: 0,
      social_chance: 0.3,
      work_priority: 1.0,
    },
    midday: {
      hours: [12, 14],
      activity: 'socialize_eat',
      energy_regen: 0.2,
      social_chance: 0.8,
      work_priority: 0.2,
    },
    afternoon: {
      hours: [14, 18],
      activity: 'secondary_work',
      energy_regen: 0,
      social_chance: 0.4,
      work_priority: 0.8,
    },
    evening: {
      hours: [18, 21],
      activity: 'socialize_music',
      energy_regen: 0,
      social_chance: 0.9,
      work_priority: 0.3,
    },
    night: {
      hours: [21, 5],
      activity: 'rest_stargaze',
      energy_regen: 1.0,
      social_chance: 0.2,
      work_priority: 0.1,
    }
  };

  // ============================================================================
  // CONTEXTUAL DIALOGUES - Archetype and context-specific dialogue
  // ============================================================================

  var CONTEXTUAL_DIALOGUES = {
    gardener: {
      greeting_first: [
        "Welcome to ZION! I'm {name}. The gardens are beautiful today.",
        "Hello there! I tend the gardens here. The flowers are in bloom!",
        "Greetings, friend! Have you seen the moonflowers by the pond?"
      ],
      greeting_familiar: [
        "Good to see you again! The {plant} I planted is growing well.",
        "Welcome back! Would you like to help me water the herbs?",
        "Ah, my friend returns! The garden remembers you."
      ],
      greeting_close: [
        "My dear friend! I saved some seeds for you.",
        "I was hoping you'd come by! Look at this new variety!",
        "Perfect timing! I need your opinion on these blooms."
      ],
      weather_rain: [
        "Perfect weather for the gardens!",
        "The flowers will love this rain.",
        "*dancing in the rain* Nature's gift!",
        "Rain means growth. Beautiful, isn't it?"
      ],
      weather_snow: [
        "Even in snow, life persists. See these hardy plants?",
        "Winter gardens have their own beauty.",
        "The frost makes crystals on the leaves. Magical."
      ],
      weather_clear: [
        "What a beautiful day to tend the garden.",
        "The sunshine makes everything grow.",
        "Perfect weather for planting!"
      ],
      time_morning: [
        "Early bird! The morning dew is perfect for planting.",
        "Good morning! The world is waking up.",
        "*trimming plants* Best time to work the soil."
      ],
      time_evening: [
        "The sunset colors are inspiring today.",
        "Evening light makes the flowers glow.",
        "Time to water before nightfall."
      ],
      time_night: [
        "The night-blooming flowers are opening. Come see!",
        "Starlight on petals... there's nothing quite like it.",
        "The garden sleeps, but I'm watching over it."
      ],
      player_building: [
        "That's looking great! Need any plants to decorate?",
        "Beautiful structure! I can bring vines to accent it.",
        "A gardener appreciates good craftsmanship!"
      ],
      player_harvesting: [
        "Good technique! Try the moonflowers next.",
        "Gentle hands. The plants appreciate that.",
        "Would you like to know the best time to harvest sage?"
      ],
      working: [
        "*carefully tends the soil*",
        "*hums while watering*",
        "*examining leaves for health*",
        "*pruning with precision*"
      ],
      idle_observation: [
        "Those clouds remind me of cotton flowers.",
        "I think I see a new bloom over there!",
        "The bees are busy today. Good sign.",
        "Every plant has a story, if you listen."
      ],
      near_water: [
        "The pond keeps everything lush.",
        "Water is life.",
        "I come here to refill my watering can."
      ],
      group_forming: [
        "Should we start a community garden?",
        "Many hands make gardens grow!",
        "I can teach you all about composting!"
      ]
    },

    builder: {
      greeting_first: [
        "Greetings! I'm {name}, master builder. Always working on something new!",
        "Hello! Notice the archways? That's my work.",
        "Welcome! A builder's work is never done, but I love every moment."
      ],
      greeting_familiar: [
        "Back again? Good! I want your opinion on this design.",
        "Ah, perfect timing! Need an extra pair of hands.",
        "Good to see you! The foundation we discussed is complete."
      ],
      greeting_close: [
        "My friend! I've been sketching ideas all morning. Look!",
        "I knew you'd come! This project needs your creative eye.",
        "Finally! No one appreciates structure like you do."
      ],
      weather_rain: [
        "Rain delays construction, but gives time to plan.",
        "*covering materials* We'll resume when it clears.",
        "Indoor projects today, I think."
      ],
      weather_clear: [
        "Perfect building weather!",
        "Clear skies mean we can work on the roof.",
        "Foundation work requires dry ground. Excellent!"
      ],
      time_morning: [
        "Morning! Best light for measuring and cutting.",
        "Early start means more progress!",
        "*reviewing blueprints* Let's begin."
      ],
      time_evening: [
        "Golden hour is perfect for admiring finished work.",
        "One more stone before sunset...",
        "Time to clean the tools and plan tomorrow."
      ],
      player_building: [
        "Excellent work! May I suggest reinforcing that corner?",
        "A fellow builder! Your technique is impressive.",
        "Strong foundation! That will last generations.",
        "Mind if I watch? I always learn from others."
      ],
      working: [
        "*measuring twice, cutting once*",
        "*carefully placing stones*",
        "*testing structural integrity*",
        "*sketching improvements*"
      ],
      idle_observation: [
        "That column's proportions are perfect.",
        "I wonder if we could build a bridge there...",
        "Every structure tells the story of its builder.",
        "The ancient ruins inspire me. Such craftsmanship!"
      ],
      group_forming: [
        "A building project needs teamwork!",
        "Together we can create something magnificent!",
        "Let me show you all the proper techniques."
      ]
    },

    storyteller: {
      greeting_first: [
        "Ah, a new face! I'm {name}. Every person has a story worth telling.",
        "Welcome, traveler! Sit, and I'll share a tale.",
        "Greetings! I collect stories. Perhaps you have one to share?"
      ],
      greeting_familiar: [
        "Welcome back! Ready for another tale?",
        "Ah, you've returned! The story continues...",
        "My friend! I've learned a new legend since we last spoke."
      ],
      greeting_close: [
        "My dear friend! Your own story grows richer each day.",
        "I've been saving the best tales for your return!",
        "Sit close. This story is for you alone."
      ],
      weather_rain: [
        "Rain is perfect for storytelling by the fire.",
        "The patter of rain makes a nice backdrop for tales.",
        "Stormy weather brings stormy stories!"
      ],
      weather_clear: [
        "Perfect evening for tales under the stars.",
        "Clear skies, clear minds, clear stories.",
        "Sunshine inspires lighter tales."
      ],
      time_evening: [
        "Evening is when the best stories are told.",
        "Gather 'round! The shadows grow, and so do legends.",
        "*preparing to perform* The perfect hour for storytelling."
      ],
      time_night: [
        "By starlight, I'll tell you of ancient wonders...",
        "Night brings out the mysterious tales.",
        "The darkness makes every story more vivid."
      ],
      working: [
        "*gesturing dramatically*",
        "*voice rising and falling with emotion*",
        "*scribbling notes*",
        "*practicing delivery*"
      ],
      idle_observation: [
        "Every corner of ZION has a story.",
        "I wonder what tales these stones could tell...",
        "That merchant looks like they have stories from afar.",
        "History is all around us, waiting to be discovered."
      ],
      group_forming: [
        "Gather close! I have a tale for you all!",
        "Stories are best shared with many ears!",
        "Come, friends! Let me tell you of heroes past!"
      ]
    },

    merchant: {
      greeting_first: [
        "Welcome to my stall! I'm {name}. Best goods in ZION!",
        "Greetings, customer! See anything you like?",
        "Hello there! Fair prices and quality goods, guaranteed!"
      ],
      greeting_familiar: [
        "Ah, my returning customer! I have something special today.",
        "Welcome back! Your patronage is appreciated!",
        "Good to see you! I saved this item with you in mind."
      ],
      greeting_close: [
        "My valued friend! For you, a special discount.",
        "Excellent timing! I just received rare goods!",
        "My dear patron! Let me show you the finest selections."
      ],
      weather_rain: [
        "*covering goods* Quick, before they get wet!",
        "Rain is bad for business, good for discounts!",
        "Come inside my tent! Can't let merchandise get soaked."
      ],
      weather_clear: [
        "Perfect market day!",
        "Sunshine brings customers!",
        "Business is good when the weather cooperates!"
      ],
      time_morning: [
        "*setting up stall* Early bird gets the best deals!",
        "Morning! Fresh inventory just arrived!",
        "Opening for business! Come see!"
      ],
      time_midday: [
        "Busy market hour! Step right up!",
        "Peak time for trading!",
        "The Agora is alive with commerce!"
      ],
      time_evening: [
        "Last chance for today's deals!",
        "Closing soon, but still open for you!",
        "*packing up* Tomorrow I'll have even better goods!"
      ],
      working: [
        "*arranging wares attractively*",
        "*calculating prices*",
        "*polishing merchandise*",
        "*calling out to passersby*"
      ],
      idle_observation: [
        "I wonder what goods that traveler carries...",
        "Business is steady today.",
        "Quality over quantity, always.",
        "A merchant's eye never rests."
      ],
      group_forming: [
        "Fellow merchants! Let's discuss trade routes!",
        "Perhaps we could organize a market festival?",
        "The more merchants, the livelier the market!"
      ]
    },

    explorer: {
      greeting_first: [
        "Ho there! I'm {name}, explorer of ZION's wilds!",
        "Greetings, friend! Just returned from the frontier.",
        "Well met! These lands hold countless secrets."
      ],
      greeting_familiar: [
        "Back from your own explorations?",
        "Good to see you! I've mapped new territories!",
        "Ah! Want to hear about what I discovered?"
      ],
      greeting_close: [
        "My fellow adventurer! Let's explore together!",
        "I've been hoping you'd come! I found something amazing!",
        "Perfect! I need someone brave to witness this discovery."
      ],
      weather_rain: [
        "Rain won't stop an explorer!",
        "*pulling up hood* Weather adds to the adventure!",
        "Rain reveals hidden streams and paths."
      ],
      weather_snow: [
        "Snow makes tracking easier!",
        "Winter landscapes are breathtaking.",
        "The wilds are beautiful in every season."
      ],
      weather_clear: [
        "Perfect day for exploration!",
        "Clear weather means good visibility!",
        "I can see for miles today!"
      ],
      time_morning: [
        "Dawn is the best time to spot wildlife!",
        "*checking compass* Time to head out!",
        "Early start, more ground to cover!"
      ],
      working: [
        "*scanning the horizon*",
        "*making notes on a map*",
        "*examining interesting features*",
        "*testing the ground*"
      ],
      idle_observation: [
        "I wonder what's beyond those mountains...",
        "Every horizon calls to be explored.",
        "The frontier is never fully mapped.",
        "Adventure is everywhere if you look."
      ],
      group_forming: [
        "Expedition party forming! Who's brave enough?",
        "Safety in numbers when exploring!",
        "Let's chart the unknown together!"
      ]
    },

    teacher: {
      greeting_first: [
        "Welcome, student! I'm {name}. Knowledge is meant to be shared.",
        "Greetings! Always happy to see eager minds.",
        "Hello! What would you like to learn today?"
      ],
      greeting_familiar: [
        "My returning student! Ready for the next lesson?",
        "Excellent! Your progress has been remarkable.",
        "Welcome back! I've prepared advanced materials."
      ],
      greeting_close: [
        "My star pupil! You continue to impress me.",
        "I've been researching topics just for you!",
        "Your dedication to learning honors us both."
      ],
      weather_clear: [
        "Beautiful day for outdoor lessons!",
        "Clear minds match clear skies.",
        "Perfect weather for demonstrations!"
      ],
      time_morning: [
        "Morning minds are fresh and ready!",
        "Let's begin today's lesson.",
        "*preparing teaching materials* Good morning!"
      ],
      time_afternoon: [
        "Afternoon is perfect for practical exercises.",
        "Review time! Let's test what you've learned.",
        "Advanced topics require afternoon focus."
      ],
      working: [
        "*explaining with gestures*",
        "*writing on a tablet*",
        "*demonstrating technique*",
        "*patiently answering questions*"
      ],
      idle_observation: [
        "Every moment is a chance to learn.",
        "I should research that further...",
        "Knowledge builds upon knowledge.",
        "Teaching is the highest form of learning."
      ],
      group_forming: [
        "Class is in session! Gather around!",
        "The more students, the richer the discussion!",
        "Let's form a study circle!"
      ]
    },

    musician: {
      greeting_first: [
        "Hello! I'm {name}. Music is the soul of ZION!",
        "*strumming* Welcome, friend! Care for a tune?",
        "Greetings! The world is better with music."
      ],
      greeting_familiar: [
        "My audience returns! Requests?",
        "*playing a familiar melody* This one's for you!",
        "Welcome back! I've learned new songs!"
      ],
      greeting_close: [
        "My friend! Let's make music together!",
        "I composed something special for you!",
        "*starting your favorite song* I remember what you love."
      ],
      weather_rain: [
        "Rain has its own rhythm. Listen...",
        "Nature's percussion! *tapping along*",
        "*playing under shelter* Rain makes everything melancholy and beautiful."
      ],
      weather_clear: [
        "Perfect night for performance!",
        "Clear acoustics tonight!",
        "The stars will be my audience!"
      ],
      time_evening: [
        "Evening is when music truly shines!",
        "*tuning instrument* Almost time to perform!",
        "Gather 'round! Concert begins at sunset!"
      ],
      time_night: [
        "Night music has special magic.",
        "*playing softly* Lullabies for the world.",
        "The stars dance to midnight melodies."
      ],
      working: [
        "*playing a complex melody*",
        "*humming while composing*",
        "*adjusting instrument strings*",
        "*keeping rhythm*"
      ],
      idle_observation: [
        "I hear music in everything...",
        "That bird's song would make a lovely motif.",
        "The wind through the trees, nature's orchestra.",
        "Every sound is part of the symphony."
      ],
      group_forming: [
        "Musicians! Jam session time!",
        "Let's create harmony together!",
        "Audience gathering! Time to perform!"
      ]
    },

    healer: {
      greeting_first: [
        "Welcome, child. I'm {name}. Are you well?",
        "Greetings, friend. Peace and health to you.",
        "Hello! I'm here if you need healing or herbs."
      ],
      greeting_familiar: [
        "Good to see you healthy and strong!",
        "Welcome back! How are you feeling?",
        "Ah, your energy looks much better!"
      ],
      greeting_close: [
        "My dear friend, you bring light with you.",
        "I'm always happy to see your face.",
        "Come, sit. Let's talk and restore spirits."
      ],
      weather_rain: [
        "Rain cleanses and renews.",
        "Good weather for gathering medicinal mushrooms!",
        "The earth drinks, and we all benefit."
      ],
      weather_clear: [
        "Sunshine is the best medicine.",
        "Perfect day for herb drying!",
        "Clear weather, clear health."
      ],
      time_morning: [
        "Morning energy is vital and strong.",
        "*gathering herbs* Dawn dew enhances potency.",
        "Begin the day with wellness."
      ],
      working: [
        "*grinding herbs gently*",
        "*meditating quietly*",
        "*examining plants carefully*",
        "*offering soothing words*"
      ],
      idle_observation: [
        "Balance is the key to health.",
        "Every plant has healing properties.",
        "The body knows how to heal itself.",
        "Wellness is a journey, not a destination."
      ],
      group_forming: [
        "Gather, friends. Let's share wellness practices.",
        "Healing circles amplify positive energy!",
        "Together we can create community health."
      ]
    },

    philosopher: {
      greeting_first: [
        "Greetings, seeker. I'm {name}. What questions trouble your mind?",
        "Welcome! I ponder the great mysteries here.",
        "Hello, friend. Care to contemplate existence?"
      ],
      greeting_familiar: [
        "Ah, you return! Have you been thinking about our discussion?",
        "Welcome back! I've had new insights.",
        "Good to see you! Ready for deeper questions?"
      ],
      greeting_close: [
        "My fellow thinker! Let's unravel mysteries together!",
        "I've been eager to hear your perspective!",
        "Two minds together see truths one alone cannot."
      ],
      weather_rain: [
        "Rain reminds us that change is constant.",
        "Each drop is unique, yet all are water. Curious.",
        "What is rain but the sky thinking aloud?"
      ],
      weather_clear: [
        "Clarity without matches clarity within.",
        "The cosmos reveals itself on clear nights.",
        "In clear skies, we see infinity."
      ],
      time_evening: [
        "Evening brings contemplative moods.",
        "As the sun sets, different truths emerge.",
        "*watching sunset* Transitions teach us much."
      ],
      time_night: [
        "Under stars, we remember how small we are.",
        "*stargazing* Each light is a sun with its own worlds...",
        "Night questions are the deepest questions."
      ],
      working: [
        "*sitting in deep thought*",
        "*sketching cosmic diagrams*",
        "*debating with self*",
        "*observing patterns*"
      ],
      idle_observation: [
        "Why does anything exist rather than nothing?",
        "Patterns repeat at every scale...",
        "What is consciousness but the universe observing itself?",
        "Every answer births new questions."
      ],
      group_forming: [
        "Let's form a discourse circle!",
        "Many perspectives illuminate truth!",
        "Philosophy thrives in dialogue!"
      ]
    },

    artist: {
      greeting_first: [
        "Hello! I'm {name}. I try to capture ZION's beauty.",
        "Welcome! An artist's work is never done.",
        "Greetings! Every vista here inspires creation."
      ],
      greeting_familiar: [
        "Back to see the progress?",
        "Your visits always bring fresh perspective!",
        "Ah! I value your aesthetic sense!"
      ],
      greeting_close: [
        "My muse has returned!",
        "I've created something I need you to see!",
        "Your appreciation means everything to me."
      ],
      weather_rain: [
        "Rain creates such interesting textures!",
        "*capturing the mood* Melancholy is beautiful too.",
        "The colors deepen in rain. Magnificent!"
      ],
      weather_snow: [
        "Winter palettes are subtle and profound.",
        "*working quickly* Snow won't last, must capture it!",
        "White on white, infinite shades..."
      ],
      weather_clear: [
        "Perfect light for painting!",
        "The colors are so vibrant today!",
        "Clear skies show every hue."
      ],
      time_morning: [
        "Morning light is soft and golden.",
        "*sketching quickly* Dawn never lasts long enough!",
        "The world is fresh and new each morning."
      ],
      time_evening: [
        "Golden hour! Every artist's favorite time!",
        "*painting frantically* The colors! The colors!",
        "Sunset is fleeting. Must work fast."
      ],
      working: [
        "*applying paint with care*",
        "*stepping back to assess*",
        "*mixing colors thoughtfully*",
        "*lost in creative flow*"
      ],
      idle_observation: [
        "Beauty is everywhere, if you look.",
        "That composition is perfect...",
        "Color, light, form... all dancing together.",
        "Art is seeing what others overlook."
      ],
      group_forming: [
        "Artists! Let's share techniques!",
        "Every artist sees differently. Let's compare!",
        "Collective creativity sparks innovation!"
      ]
    }
  };

  // ============================================================================
  // ZONE-SPECIFIC DIALOGUES (shared across archetypes)
  // ============================================================================

  var ZONE_DIALOGUES = {
    nexus: [
      "The Nexus hums with energy today.",
      "Everyone passes through here eventually.",
      "The heart of ZION beats strong.",
      "New faces arrive every day. The world grows.",
      "I love the way all paths converge here."
    ],
    gardens: [
      "The gardens are especially beautiful today.",
      "Can you smell the jasmine? Heavenly.",
      "Everything grows so well here.",
      "The gardeners have been busy. Look at those blooms!",
      "I always feel peaceful in the gardens."
    ],
    wilds: [
      "Stay alert out here. The wilds are unpredictable.",
      "I've heard there are rare plants deep in these woods.",
      "The frontier calls to the adventurous.",
      "Few venture this far. You're brave.",
      "The wilds hold secrets waiting to be found."
    ],
    athenaeum: [
      "Knowledge fills these halls.",
      "The scrolls here contain ancient wisdom.",
      "Quiet, please. Some are studying.",
      "Have you read the founding texts? Fascinating.",
      "Learning never ends in the Athenaeum."
    ],
    studio: [
      "Creativity fills the air here.",
      "I love watching the artists at work.",
      "The Studio inspires everyone who enters.",
      "Art gives meaning to our world.",
      "Have you seen the latest sculptures?"
    ],
    agora: [
      "The market is bustling today!",
      "Good deals to be found if you look.",
      "The Agora never sleeps.",
      "Trade is the lifeblood of any community.",
      "I heard a merchant just got rare goods."
    ],
    commons: [
      "The Commons feel like home.",
      "Community is what we build here.",
      "I love what everyone has contributed.",
      "The workshops are always busy.",
      "Building together is building forever."
    ],
    arena: [
      "The Arena pulses with competitive spirit!",
      "Friendly competition makes us all stronger.",
      "Champions are made here!",
      "The crowd's energy is incredible.",
      "May the best challenger win!"
    ]
  };

  // ============================================================================
  // INTER-ARCHETYPE REACTION DIALOGUES
  // ============================================================================

  var ARCHETYPE_REACTIONS = {
    gardener: {
      musician: "Your music makes my flowers bloom brighter!",
      builder: "Could you build a trellis for my vines?",
      healer: "I have herbs that might help your remedies.",
      artist: "Please paint my garden someday!",
      merchant: "I have fresh produce for your stall.",
      storyteller: "The oldest oak has stories to tell...",
      explorer: "Did you find any rare seeds on your travels?",
      teacher: "Will you teach the children about botany?",
      philosopher: "What do you think plants dream about?"
    },
    builder: {
      gardener: "Plant something by my new building?",
      musician: "I need good acoustics in this hall I'm building.",
      healer: "I'm building a new healing pavilion.",
      artist: "Want to design the facade?",
      merchant: "I need materials. What do you have?",
      storyteller: "This wall needs an engraved legend.",
      explorer: "Found any interesting stone quarries?",
      teacher: "I could build a lecture hall for you.",
      philosopher: "Is the perfect building possible?"
    },
    storyteller: {
      gardener: "Tell me the legend of the first seed.",
      musician: "Would you accompany my tale with music?",
      builder: "Every building you make is a story in stone.",
      healer: "Healing stories are the most powerful.",
      artist: "Illustrate my latest tale?",
      merchant: "Stories from distant lands to trade?",
      explorer: "You must have incredible tales to share!",
      teacher: "Let's teach through storytelling!",
      philosopher: "What is truth in a story?"
    },
    merchant: {
      gardener: "Fresh flowers always sell well.",
      musician: "You draw crowds! Set up near my stall?",
      builder: "I have timber and nails you'll need.",
      healer: "Healing potions sell for good Spark!",
      artist: "Your art would fetch a premium.",
      storyteller: "Stories attract customers. Perfect partnership!",
      explorer: "Bring me exotic goods from your travels!",
      teacher: "Education about quality helps sales.",
      philosopher: "What is the true value of Spark?"
    },
    explorer: {
      gardener: "I found strange plants in the deep wilds!",
      musician: "The acoustics in that cave were amazing.",
      builder: "There are ancient ruins to the north!",
      healer: "I found rare medicinal moss on the cliff face.",
      artist: "The vista from the eastern ridge is breathtaking.",
      storyteller: "I discovered something the legends speak of!",
      merchant: "I've got rare finds from the frontier.",
      teacher: "The wilds teach lessons no book can.",
      philosopher: "Exploration is philosophy in motion."
    },
    teacher: {
      gardener: "Botany class begins with your garden.",
      musician: "Music theory is fascinating, isn't it?",
      builder: "Architecture has much to teach us.",
      healer: "Medical knowledge saves lives.",
      artist: "Art history is endlessly rich.",
      storyteller: "Oral tradition preserves culture.",
      merchant: "Economics drives civilization.",
      explorer: "Geography shapes destiny.",
      philosopher: "Every discipline leads to the same questions."
    },
    musician: {
      gardener: "Your garden hums with lifeâ€”I'll write it a song!",
      builder: "The rhythm of your hammer inspires me.",
      healer: "Healing harmonics are real. I've studied them.",
      artist: "Music and artâ€”the twin souls of creation.",
      storyteller: "Let me compose a soundtrack for your tale!",
      merchant: "I'll play for customers if you share the Spark!",
      explorer: "Every land has its own song waiting to be heard.",
      teacher: "Music is the universal language, yes?",
      philosopher: "What is sound, really, but structured silence?"
    },
    healer: {
      gardener: "Your herbs are essential to my practice.",
      musician: "Music heals wounds no salve can reach.",
      builder: "A healthy body builds a strong world.",
      artist: "Beauty is healing in visual form.",
      storyteller: "Stories can heal the soul.",
      merchant: "I need suppliesâ€”got any healing crystals?",
      explorer: "Stay safe out there. I'll be here if you're hurt.",
      teacher: "Prevention is the best medicine.",
      philosopher: "What does it mean to be truly well?"
    },
    philosopher: {
      gardener: "Growth is the fundamental urge of all things.",
      musician: "If music is math made beautiful, what is beauty?",
      builder: "We build to defy entropy. A noble endeavor.",
      healer: "Is perfect health the absence of illness, or something more?",
      artist: "Does art reveal truth or create it?",
      storyteller: "Stories shape how we see reality itself.",
      merchant: "Value is a collective hallucination, isn't it?",
      explorer: "The greatest journey is inward.",
      teacher: "Can we truly teach, or merely point the way?"
    },
    artist: {
      gardener: "Nature is the greatest artist.",
      musician: "Our arts are siblingsâ€”let's collaborate!",
      builder: "Architecture is art that shelters.",
      healer: "I want to paint the act of healing.",
      storyteller: "Every story paints pictures in the mind.",
      merchant: "Does commerce diminish art or elevate it?",
      explorer: "The landscapes you describeâ€”I must see them!",
      teacher: "Teach me that technique you mentioned.",
      philosopher: "Art is philosophy made visible."
    }
  };

  // ============================================================================
  // QUEST HOOK DIALOGUES (NPCs hint at available tasks)
  // ============================================================================

  var QUEST_HOOKS = {
    gardener: [
      "I could use help gathering sunflowers for the festival...",
      "The moonflower seeds need planting. Know anyone interested?",
      "A rare bloom was spotted in the Wilds. I wish I could go look...",
      "My herb garden needs tending while I research new species."
    ],
    builder: [
      "The bridge near the commons needs repair. Volunteers?",
      "I'm designing a new gazebo but need special stone...",
      "Someone left materials scattered at the construction site.",
      "The old tower could use reinforcement. Big project, good Spark."
    ],
    storyteller: [
      "I'm collecting tales from each zone. Want to help gather them?",
      "A lost manuscript was last seen in the Athenaeum depths...",
      "The founding stories are fading from memory. Help preserve them?",
      "I need someone to interview the elder NPCs for my chronicle."
    ],
    merchant: [
      "I'm missing a delivery from the gardens. Could you check?",
      "A rare gem went missing from my inventory...",
      "I need someone to scout prices in the other zones.",
      "Big trade deal coming up. I need rare materials."
    ],
    explorer: [
      "There's an unmapped cave system I've been wanting to explore.",
      "Strange lights in the wilds at nightâ€”want to investigate?",
      "The ancient markers near the arena need documenting.",
      "I found tracks of something unusual. Help me follow them?"
    ],
    teacher: [
      "I need specimens from each zone for my natural history class.",
      "Can you deliver these lesson scrolls to students in the commons?",
      "My research requires a crystal from the studio caves.",
      "Help me set up the outdoor classroom by the gardens."
    ],
    musician: [
      "I'm organizing a concert but need instruments gathered.",
      "The acoustics stone in the arena was chipped. Find a replacement?",
      "I hear the wilds have singing crystals. Bring me one!",
      "Help me spread word of tonight's performance to all zones."
    ],
    healer: [
      "I'm running low on moonpetal herbs. The gardens might have some.",
      "A traveler fell illâ€”I need crystal dust from the studio.",
      "Help me set up healing stations across the zones.",
      "Rare medicinal moss grows on the arena stones. Can you gather some?"
    ],
    philosopher: [
      "Debate me on the nature of ZION. I'll reward good arguments!",
      "Find the three wisdom stones hidden across the zones.",
      "Carry this sealed question to the storyteller and bring back the answer.",
      "I seek the meaning of the ancient symbols on the obelisk."
    ],
    artist: [
      "I need pigments from rare flowers in the gardens.",
      "Inspiration! Go sketch the view from three different zones.",
      "The mural in the commons needs restoration help.",
      "Find the legendary canvas stone in the wilds for me."
    ]
  };

  // ============================================================================
  // MOOD SYSTEM
  // ============================================================================

  var MOODS = ['content', 'excited', 'contemplative', 'social', 'tired', 'focused', 'curious', 'peaceful'];

  function calculateMood(memory, perception, timeOfDay) {
    var energy = memory.energy || 100;
    var schedule = getSchedulePeriod(perception.timeOfDay);
    var recentSocial = memory.interactions.filter(function(i) {
      return Date.now() - i.timestamp < 300000; // Last 5 minutes
    }).length;

    // Tired if low energy
    if (energy < 30) return 'tired';

    // Social during high social chance periods
    if (schedule.social_chance > 0.7 && recentSocial > 0) return 'social';

    // Excited if recently witnessed exciting event
    var recentExciting = memory.witnessedEvents.filter(function(e) {
      return e.type === 'portal_activation' || e.type === 'group_forming';
    }).length > 0;
    if (recentExciting) return 'excited';

    // Contemplative at night or evening for certain archetypes
    if ((timeOfDay === 'evening' || timeOfDay === 'night') &&
        (memory.archetype === 'philosopher' || memory.archetype === 'artist')) {
      return 'contemplative';
    }

    // Focused during work hours
    if (schedule.work_priority > 0.7) return 'focused';

    // Curious if explorer or in new location
    if (memory.archetype === 'explorer' || perception.recentEvents.some(function(e) {
      return e.type === 'new_discovery';
    })) {
      return 'curious';
    }

    // Peaceful in gardens or near water
    if (perception.currentZone === 'gardens' || perception.nearWater) {
      return 'peaceful';
    }

    return 'content';
  }

  // ============================================================================
  // PERCEPTION SYSTEM
  // ============================================================================

  function perceive(npc, worldState) {
    var perception = {
      nearbyPlayers: [],
      nearbyNPCs: [],
      weather: worldState.weather || 'clear',
      timeOfDay: worldState.timeOfDay || 'midday',
      currentZone: worldState.currentZone || 'agora',
      recentEvents: worldState.recentEvents || [],
      threats: [],
      nearWater: worldState.nearWater || false,
      inShelter: worldState.inShelter || false,
      groupsForming: [],
      interestingObjects: []
    };

    // Detect nearby players
    if (worldState.players) {
      worldState.players.forEach(function(player) {
        var dx = player.x - npc.x;
        var dz = player.z - npc.z;
        var distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= PERCEPTION_RADIUS) {
          perception.nearbyPlayers.push({
            id: player.id,
            distance: distance,
            direction: { x: dx, z: dz },
            lastAction: player.lastAction,
            isBuilding: player.isBuilding,
            isHarvesting: player.isHarvesting
          });
        }
      });
    }

    // Detect nearby NPCs
    if (worldState.npcs) {
      worldState.npcs.forEach(function(otherNpc) {
        if (otherNpc.id === npc.id) return;

        var dx = otherNpc.x - npc.x;
        var dz = otherNpc.z - npc.z;
        var distance = Math.sqrt(dx * dx + dz * dz);

        if (distance <= PERCEPTION_RADIUS) {
          perception.nearbyNPCs.push({
            id: otherNpc.id,
            distance: distance,
            direction: { x: dx, z: dz },
            archetype: otherNpc.archetype,
            currentActivity: otherNpc.currentActivity,
            mood: otherNpc.mood
          });
        }
      });
    }

    // Detect groups forming
    var npcClusters = {};
    perception.nearbyNPCs.forEach(function(nearby) {
      if (nearby.distance <= GROUP_FORMATION_RADIUS) {
        var key = Math.floor(nearby.direction.x / 5) + '_' + Math.floor(nearby.direction.z / 5);
        if (!npcClusters[key]) npcClusters[key] = [];
        npcClusters[key].push(nearby);
      }
    });

    Object.keys(npcClusters).forEach(function(key) {
      if (npcClusters[key].length >= 2) {
        perception.groupsForming.push({
          members: npcClusters[key],
          location: key,
          size: npcClusters[key].length
        });
      }
    });

    return perception;
  }

  // ============================================================================
  // MEMORY SYSTEM
  // ============================================================================

  function createMemory(archetype) {
    return {
      archetype: archetype,
      interactions: [],
      favorites: {
        location: null,
        npcFriends: []
      },
      playerFamiliarity: {},
      witnessedEvents: [],
      lastGreeted: {},
      usedDialogues: [],
      mood: 'content',
      energy: 100,
      satisfaction: 50,
      lastWorkTime: 0,
      lastRestTime: 0,
      currentGoal: null,
      groupMembership: null
    };
  }

  function updateMemory(memory, deltaTime) {
    // Decay familiarity
    Object.keys(memory.playerFamiliarity).forEach(function(playerId) {
      memory.playerFamiliarity[playerId] -= MEMORY_DECAY_RATE * deltaTime;
      if (memory.playerFamiliarity[playerId] <= 0) {
        delete memory.playerFamiliarity[playerId];
      }
    });

    // Decay energy
    var schedule = getSchedulePeriod(memory.currentTimeOfDay || 'midday');
    if (schedule.energy_regen > 0) {
      memory.energy = Math.min(100, memory.energy + ENERGY_REGEN_RATE * (deltaTime / 60000));
    } else {
      memory.energy = Math.max(0, memory.energy - ENERGY_DECAY_RATE * (deltaTime / 60000));
    }

    // Trim old interactions
    if (memory.interactions.length > MAX_INTERACTIONS_REMEMBERED) {
      memory.interactions = memory.interactions.slice(-MAX_INTERACTIONS_REMEMBERED);
    }

    // Trim old events
    if (memory.witnessedEvents.length > MAX_EVENTS_REMEMBERED) {
      memory.witnessedEvents = memory.witnessedEvents.slice(-MAX_EVENTS_REMEMBERED);
    }

    // Reset used dialogues periodically (every 5 minutes)
    if (!memory.lastDialogueReset || Date.now() - memory.lastDialogueReset > 300000) {
      memory.usedDialogues = [];
      memory.lastDialogueReset = Date.now();
    }
  }

  function recordInteraction(memory, playerId, type, response) {
    memory.interactions.push({
      playerId: playerId,
      type: type,
      timestamp: Date.now(),
      response: response
    });

    // Increase familiarity
    if (!memory.playerFamiliarity[playerId]) {
      memory.playerFamiliarity[playerId] = 0;
    }
    memory.playerFamiliarity[playerId] += FAMILIARITY_GAIN;
  }

  function recordEvent(memory, eventType, description) {
    memory.witnessedEvents.push({
      type: eventType,
      description: description,
      timestamp: Date.now()
    });
  }

  // ============================================================================
  // SCHEDULE HELPERS
  // ============================================================================

  function getSchedulePeriod(timeOfDay) {
    return DAILY_SCHEDULE[timeOfDay] || DAILY_SCHEDULE.midday;
  }

  function getCurrentHour(worldState) {
    return worldState.currentHour || 12;
  }

  // ============================================================================
  // DIALOGUE SYSTEM
  // ============================================================================

  // Safe reference to NpcDialogue module (loaded after npc_ai.js in bundle order)
  var dialogue = (typeof NpcDialogue !== 'undefined') ? NpcDialogue : null;

  /**
   * Map npc_ai category keys to NpcDialogue context types.
   */
  var CATEGORY_TO_DIALOGUE_TYPE = {
    greeting_first:     'greeting',
    greeting_familiar:  'greeting',
    greeting_close:     'greeting',
    weather_rain:       'weather',
    weather_snow:       'weather',
    weather_clear:      'weather',
    time_morning:       'idle_chat',
    time_evening:       'idle_chat',
    time_night:         'idle_chat',
    player_building:    'craft',
    player_harvesting:  'craft',
    working:            'craft',
    idle_observation:   'idle_chat',
    near_water:         'zone_comment',
    group_forming:      'idle_chat',
    zone_observation:   'zone_comment',
    quest_hook:         'idle_chat',
    archetype_reaction: 'idle_chat'
  };

  /**
   * Build a NpcDialogue-compatible context object from npc_ai state.
   * @param {object} memory - NPC memory object
   * @param {object} context - npc_ai context {category, zone, targetArchetype}
   * @param {object} [perception] - Optional perception snapshot
   * @returns {object} NpcDialogue context
   */
  function buildDialogueContext(memory, context, perception) {
    var categoryKey = (context && context.category) || 'idle_observation';
    var contextType = CATEGORY_TO_DIALOGUE_TYPE[categoryKey] || 'idle_chat';

    // Map weather categories to 'weather' type
    if (categoryKey === 'weather_rain' || categoryKey === 'weather_snow' || categoryKey === 'weather_clear') {
      contextType = 'weather';
    }
    // Map greeting categories to 'greeting' type
    if (categoryKey.indexOf('greeting') === 0) {
      contextType = 'greeting';
    }

    var dlgContext = {
      type: contextType,
      zone: (context && context.zone) || (perception && perception.currentZone) || 'nexus',
      timeOfDay: (perception && perception.timeOfDay) || 'daytime',
      weather: (perception && perception.weather) || 'clear',
      currentActivity: (memory && memory.currentGoal && memory.currentGoal.type) || 'wandering',
      nearbyPlayers: [],
      recentChat: []
    };

    return dlgContext;
  }

  function getDialogue(memory, context, npcName) {
    var archetype = memory.archetype;
    var categoryKey = context.category || 'idle_observation';

    // Re-check NpcDialogue on each call (may have loaded after npc_ai.js)
    if (!dialogue && typeof NpcDialogue !== 'undefined') {
      dialogue = NpcDialogue;
    }

    // Use NpcDialogue.getFallback when available for richer, personality-driven responses
    if (dialogue && dialogue.getFallback) {
      var npcObj = { archetype: archetype, name: npcName };
      var dlgCtx = buildDialogueContext(memory, context, null);
      var dlgResult = dialogue.getFallback(npcObj, dlgCtx);
      if (dlgResult) {
        // Track used dialogue to avoid consecutive repetition
        if (!memory.usedDialogues) memory.usedDialogues = [];
        // Prevent consecutive repeat: if last line matches, fall through to npc_ai pool
        var lastUsed = memory.usedDialogues[memory.usedDialogues.length - 1];
        if (lastUsed !== dlgResult) {
          memory.usedDialogues.push(dlgResult);
          if (memory.usedDialogues.length > 20) {
            memory.usedDialogues = memory.usedDialogues.slice(-20);
          }
          return dlgResult;
        }
      }
    }

    // Handle special dynamic categories
    if (categoryKey === 'archetype_reaction') {
      var reactions = ARCHETYPE_REACTIONS[archetype];
      if (reactions && context.targetArchetype && reactions[context.targetArchetype]) {
        var reactionText = reactions[context.targetArchetype];
        return reactionText.replace('{name}', npcName);
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    if (categoryKey === 'zone_observation') {
      var zoneDlgs = ZONE_DIALOGUES[context.zone];
      if (zoneDlgs && zoneDlgs.length > 0) {
        return zoneDlgs[Math.floor(Math.random() * zoneDlgs.length)];
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    if (categoryKey === 'quest_hook') {
      var hooks = QUEST_HOOKS[archetype];
      if (hooks && hooks.length > 0) {
        return hooks[Math.floor(Math.random() * hooks.length)];
      }
      categoryKey = 'idle_observation'; // Fallback
    }

    var dialogues = CONTEXTUAL_DIALOGUES[archetype];
    if (!dialogues) return null;

    var category = dialogues[categoryKey];
    if (!category || category.length === 0) {
      category = dialogues.idle_observation || [];
    }

    if (category.length === 0) return null;

    // Filter out recently used dialogues
    var availableDialogues = category.filter(function(_, index) {
      return memory.usedDialogues.indexOf(categoryKey + '_' + index) === -1;
    });

    if (availableDialogues.length === 0) {
      availableDialogues = category; // Reset if all used
      memory.usedDialogues = [];
    }

    // Pick random from available
    var pickedDialogue = availableDialogues[Math.floor(Math.random() * availableDialogues.length)];
    var index = category.indexOf(pickedDialogue);
    memory.usedDialogues.push(categoryKey + '_' + index);

    // Replace placeholders
    pickedDialogue = pickedDialogue.replace('{name}', npcName);
    pickedDialogue = pickedDialogue.replace('{plant}', ['roses', 'lilies', 'moonflowers', 'sage'][Math.floor(Math.random() * 4)]);

    return pickedDialogue;
  }

  function getDialogueContext(memory, perception, npc) {
    var playerId = perception.nearbyPlayers.length > 0 ? perception.nearbyPlayers[0].id : null;
    var familiarity = playerId ? (memory.playerFamiliarity[playerId] || 0) : 0;

    // Determine greeting level
    if (playerId && !memory.lastGreeted[playerId]) {
      return { category: 'greeting_first' };
    } else if (familiarity >= FAMILIARITY_THRESHOLD_CLOSE) {
      return { category: 'greeting_close' };
    } else if (familiarity >= FAMILIARITY_THRESHOLD_FRIENDLY) {
      return { category: 'greeting_familiar' };
    }

    // Weather-based
    if (perception.weather === 'rain') {
      return { category: 'weather_rain' };
    } else if (perception.weather === 'snow') {
      return { category: 'weather_snow' };
    } else if (perception.weather === 'clear') {
      return { category: 'weather_clear' };
    }

    // Time-based
    if (perception.timeOfDay === 'morning' || perception.timeOfDay === 'dawn') {
      return { category: 'time_morning' };
    } else if (perception.timeOfDay === 'evening') {
      return { category: 'time_evening' };
    } else if (perception.timeOfDay === 'night') {
      return { category: 'time_night' };
    }

    // Player action-based
    if (perception.nearbyPlayers.length > 0) {
      var player = perception.nearbyPlayers[0];
      if (player.isBuilding) {
        return { category: 'player_building' };
      } else if (player.isHarvesting) {
        return { category: 'player_harvesting' };
      }
    }

    // Inter-archetype reaction (NPC meets another archetype NPC)
    if (perception.nearbyNPCs.length > 0 && Math.random() < 0.25) {
      var nearbyNpc = perception.nearbyNPCs[0];
      if (nearbyNpc.archetype && nearbyNpc.archetype !== memory.archetype) {
        return { category: 'archetype_reaction', targetArchetype: nearbyNpc.archetype };
      }
    }

    // Zone-specific observations
    if (perception.currentZone && Math.random() < 0.3) {
      return { category: 'zone_observation', zone: perception.currentZone };
    }

    // Quest hook (occasionally hint at available tasks)
    if (Math.random() < 0.08) {
      return { category: 'quest_hook' };
    }

    // Location-based
    if (perception.nearWater) {
      return { category: 'near_water' };
    }

    // Group-based
    if (perception.groupsForming.length > 0) {
      return { category: 'group_forming' };
    }

    // Activity-based
    if (memory.currentGoal && memory.currentGoal.type === 'work') {
      return { category: 'working' };
    }

    // Default
    return { category: 'idle_observation' };
  }

  // ============================================================================
  // BEHAVIOR TREE - Decision Making
  // ============================================================================

  function evaluateBehaviorTree(npc, memory, perception) {
    var drives = ARCHETYPE_DRIVES[memory.archetype];
    var schedule = getSchedulePeriod(perception.timeOfDay);
    var now = Date.now();

    // PRIORITY 1: SURVIVAL NEEDS

    // Check if need shelter from bad weather
    if ((perception.weather === 'storm' || perception.weather === 'rain') &&
        !perception.inShelter &&
        drives.weather_preference !== 'rain' &&
        drives.weather_preference !== 'any') {
      return {
        type: 'seek_shelter',
        priority: 10,
        animation: 'walk',
        speed: 2.0
      };
    }

    // Check if energy low - need rest
    if (memory.energy < 20) {
      return {
        type: 'rest',
        priority: 9,
        animation: 'sit',
        speed: 0
      };
    }

    // Check if night and should sleep
    if ((perception.timeOfDay === 'night' || perception.timeOfDay === 'dawn') &&
        memory.energy < 60 &&
        memory.archetype !== 'philosopher' &&
        memory.archetype !== 'musician') {
      return {
        type: 'rest',
        priority: 8,
        animation: 'sleep',
        speed: 0
      };
    }

    // PRIORITY 2: REACT TO EVENTS

    // Player approaches - greet if haven't recently
    if (perception.nearbyPlayers.length > 0) {
      var closestPlayer = perception.nearbyPlayers[0];
      if (closestPlayer.distance < 5) {
        var lastGreetTime = memory.lastGreeted[closestPlayer.id];
        if (!lastGreetTime || now - lastGreetTime > INTERACTION_COOLDOWN) {
          memory.lastGreeted[closestPlayer.id] = now;
          var context = getDialogueContext(memory, perception, npc);
          var greetDialogue = getDialogue(memory, context, npc.name);
          recordInteraction(memory, closestPlayer.id, 'greeting', greetDialogue);

          return {
            type: 'greet',
            targetPlayer: closestPlayer.id,
            priority: 7,
            animation: 'wave',
            dialogue: greetDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
      }

      // Player performing interesting action nearby
      if (closestPlayer.distance < 10) {
        if (closestPlayer.isBuilding && memory.archetype === 'builder') {
          var buildDialogue = getDialogue(memory, { category: 'player_building' }, npc.name);
          return {
            type: 'react',
            priority: 6,
            animation: 'observe',
            dialogue: buildDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
        if (closestPlayer.isHarvesting && memory.archetype === 'gardener') {
          var harvestDialogue = getDialogue(memory, { category: 'player_harvesting' }, npc.name);
          return {
            type: 'react',
            priority: 6,
            animation: 'observe',
            dialogue: harvestDialogue,
            facing: { x: npc.x + closestPlayer.direction.x, z: npc.z + closestPlayer.direction.z },
            speed: 0
          };
        }
      }
    }

    // Group forming nearby - consider joining
    if (perception.groupsForming.length > 0 && Math.random() < schedule.social_chance) {
      var group = perception.groupsForming[0];
      var shouldJoin = false;

      // Musicians join other musicians
      if (memory.archetype === 'musician') {
        shouldJoin = group.members.some(function(m) { return m.archetype === 'musician'; });
      }
      // Storytellers gather audiences
      if (memory.archetype === 'storyteller') {
        shouldJoin = group.size >= 2;
      }
      // Social archetypes join readily
      if (memory.archetype === 'teacher' || memory.archetype === 'merchant' || memory.archetype === 'philosopher') {
        shouldJoin = Math.random() < 0.6;
      }

      if (shouldJoin) {
        var groupDialogue = getDialogue(memory, { category: 'group_forming' }, npc.name);
        return {
          type: 'join_group',
          groupId: group.location,
          priority: 6,
          animation: 'walk',
          dialogue: groupDialogue,
          speed: 1.5
        };
      }
    }

    // PRIORITY 3: SOCIAL NEEDS

    if (memory.mood === 'social' || (Math.random() < schedule.social_chance && memory.energy > 40)) {
      // Find friend NPC
      if (memory.favorites.npcFriends.length > 0) {
        var friendId = memory.favorites.npcFriends[0];
        var friendNearby = perception.nearbyNPCs.find(function(n) { return n.id === friendId; });

        if (friendNearby && friendNearby.distance < 8) {
          return {
            type: 'socialize',
            targetNPC: friendId,
            priority: 5,
            animation: 'talk',
            dialogue: getDialogue(memory, { category: 'greeting_familiar' }, npc.name),
            facing: { x: npc.x + friendNearby.direction.x, z: npc.z + friendNearby.direction.z },
            speed: 0
          };
        }
      }

      // Approach any nearby NPC for social interaction or collaboration
      if (perception.nearbyNPCs.length > 0) {
        var nearbyNpc = perception.nearbyNPCs[0];
        if (nearbyNpc.distance < 12 && Math.random() < 0.4) {
          // Add to friends if repeated interaction
          if (memory.favorites.npcFriends.indexOf(nearbyNpc.id) === -1) {
            memory.favorites.npcFriends.push(nearbyNpc.id);
          }

          // Check for collaborative activity
          var collab = getCollaborativeActivity(memory.archetype, nearbyNpc.archetype);
          if (collab && nearbyNpc.distance < 6) {
            return {
              type: 'collaborate',
              targetNPC: nearbyNpc.id,
              activityDesc: collab.description,
              priority: 5,
              animation: collab.animation,
              dialogue: getDialogue(memory, { category: 'archetype_reaction', targetArchetype: nearbyNpc.archetype }, npc.name),
              facing: { x: npc.x + nearbyNpc.direction.x, z: npc.z + nearbyNpc.direction.z },
              speed: 0
            };
          }

          return {
            type: 'approach_social',
            target: { x: npc.x + nearbyNpc.direction.x * 0.7, z: npc.z + nearbyNpc.direction.z * 0.7 },
            targetNPC: nearbyNpc.id,
            priority: 4,
            animation: 'walk',
            speed: 1.0
          };
        }
      }

      // Apply emotional contagion from nearby NPCs
      applyEmotionalContagion(memory, perception.nearbyNPCs);
    }

    // PRIORITY 4: PRIMARY DRIVE (Work)

    if (schedule.work_priority > 0.5 && memory.energy > 30) {
      var workSatisfied = memory.satisfaction > 70 || (now - memory.lastWorkTime < 180000); // Last 3 min

      if (!workSatisfied) {
        memory.lastWorkTime = now;
        memory.satisfaction += WORK_SATISFACTION_GAIN;

        var workAction = getPrimaryWorkAction(memory.archetype, npc, perception);
        workAction.priority = 4;
        return workAction;
      }
    }

    // PRIORITY 5: SECONDARY DRIVE

    if (memory.satisfaction > 50 && memory.energy > 50) {
      var secondaryAction = getSecondaryWorkAction(memory.archetype, npc, perception);
      secondaryAction.priority = 3;
      return secondaryAction;
    }

    // PRIORITY 6: IDLE / WANDER

    var idleDialogue = getDialogue(memory, { category: 'idle_observation' }, npc.name);

    if (Math.random() < 0.3) {
      // Try walking to a point of interest first
      if (perception.currentZone && Math.random() < 0.6) {
        var poi = getPointOfInterest(perception.currentZone, memory.archetype);
        if (poi) {
          var poiDist = Math.sqrt(Math.pow(poi.x - npc.x, 2) + Math.pow(poi.z - npc.z, 2));
          if (poiDist > 3 && poiDist < 60) {
            return {
              type: 'walk_to',
              target: { x: poi.x, z: poi.z },
              poiName: poi.name,
              priority: 2,
              animation: 'walk',
              dialogue: Math.random() < 0.15 ? idleDialogue : null,
              speed: 1.0
            };
          }
        }
      }

      // Fallback: wander locally
      var wanderAngle = Math.random() * Math.PI * 2;
      var wanderDist = 5 + Math.random() * 10;
      return {
        type: 'wander',
        target: {
          x: npc.x + Math.cos(wanderAngle) * wanderDist,
          z: npc.z + Math.sin(wanderAngle) * wanderDist
        },
        priority: 2,
        animation: 'walk',
        dialogue: Math.random() < 0.1 ? idleDialogue : null,
        speed: 0.8
      };
    }

    // Occasionally share gossip with nearby NPC
    if (perception.nearbyNPCs.length > 0 && Math.random() < 0.05) {
      var gossip = generateGossip(memory, npc.name);
      if (gossip) {
        return {
          type: 'socialize',
          targetNPC: perception.nearbyNPCs[0].id,
          priority: 2,
          animation: 'talk',
          dialogue: gossip,
          speed: 0
        };
      }
    }

    // Just idle
    return {
      type: 'idle',
      priority: 1,
      animation: 'idle',
      dialogue: Math.random() < 0.05 ? idleDialogue : null,
      speed: 0
    };
  }

  // ============================================================================
  // WORK ACTION GENERATORS
  // ============================================================================

  function getPrimaryWorkAction(archetype, npc, perception) {
    var drives = ARCHETYPE_DRIVES[archetype];

    switch (drives.primary) {
      case 'tend_plants':
        return {
          type: 'work',
          animation: 'gardening',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'inspect_structures':
        return {
          type: 'work',
          animation: 'building',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'visit_athenaeum':
        return {
          type: 'walk_to',
          target: { x: 0, z: 0 }, // Athenaeum location
          animation: 'walk',
          speed: 1.2
        };

      case 'tend_shop':
        return {
          type: 'work',
          animation: 'merchant',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'explore_wilds':
        var exploreAngle = Math.random() * Math.PI * 2;
        return {
          type: 'walk_to',
          target: {
            x: npc.x + Math.cos(exploreAngle) * 30,
            z: npc.z + Math.sin(exploreAngle) * 30
          },
          animation: 'walk',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 1.5
        };

      case 'teach_lesson':
        return {
          type: 'work',
          animation: 'teaching',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'perform':
        return {
          type: 'work',
          animation: 'playing_music',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'tend_wounded':
        return {
          type: 'work',
          animation: 'healing',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'contemplate':
        return {
          type: 'work',
          animation: 'sitting',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      case 'create_art':
        return {
          type: 'work',
          animation: 'painting',
          dialogue: getDialogue({ archetype: archetype, usedDialogues: [] }, { category: 'working' }, npc.name),
          speed: 0
        };

      default:
        return {
          type: 'idle',
          animation: 'idle',
          speed: 0
        };
    }
  }

  function getSecondaryWorkAction(archetype, npc, perception) {
    var drives = ARCHETYPE_DRIVES[archetype];

    switch (drives.secondary) {
      case 'explore_flora':
      case 'map_territory':
      case 'find_inspiration':
        var exploreAngle = Math.random() * Math.PI * 2;
        return {
          type: 'explore',
          target: {
            x: npc.x + Math.cos(exploreAngle) * 20,
            z: npc.z + Math.sin(exploreAngle) * 20
          },
          animation: 'walk',
          speed: 1.0
        };

      case 'gather_materials':
      case 'gather_herbs':
      case 'acquire_goods':
        return {
          type: 'gather',
          animation: 'harvesting',
          speed: 0
        };

      case 'collect_stories':
      case 'research':
        return {
          type: 'research',
          animation: 'reading',
          speed: 0
        };

      case 'compose':
        return {
          type: 'compose',
          animation: 'writing',
          speed: 0
        };

      case 'debate':
        return {
          type: 'debate',
          animation: 'gesturing',
          speed: 0
        };

      default:
        return {
          type: 'idle',
          animation: 'idle',
          speed: 0
        };
    }
  }

  // ============================================================================
  // EVENT HANDLING
  // ============================================================================

  function handleEvent(memory, event) {
    recordEvent(memory, event.type, event.description);

    // Weather changes affect mood
    if (event.type === 'weather_change') {
      var drives = ARCHETYPE_DRIVES[memory.archetype];
      if (event.weather === drives.weather_preference) {
        memory.mood = 'excited';
        memory.energy = Math.min(100, memory.energy + 10);
      } else if (event.weather === 'storm') {
        memory.mood = 'contemplative';
      }
    }

    // Portal activation nearby
    if (event.type === 'portal_activation') {
      memory.mood = 'curious';
      if (memory.archetype === 'explorer' || memory.archetype === 'teacher') {
        memory.mood = 'excited';
      }
    }

    // Group forming
    if (event.type === 'group_forming') {
      if (memory.archetype === 'musician' || memory.archetype === 'storyteller' || memory.archetype === 'teacher') {
        memory.mood = 'social';
      }
    }

    // Player builds nearby
    if (event.type === 'player_building') {
      if (memory.archetype === 'builder' || memory.archetype === 'artist') {
        memory.mood = 'curious';
      }
    }

    // Time of day changes
    if (event.type === 'time_change') {
      memory.currentTimeOfDay = event.timeOfDay;
      var schedule = getSchedulePeriod(event.timeOfDay);

      // Reset satisfaction at dawn
      if (event.timeOfDay === 'dawn') {
        memory.satisfaction = 50;
      }
    }
  }

  // ============================================================================
  // MAIN BRAIN INTERFACE
  // ============================================================================

  function createNpcBrain(archetype, npcId) {
    return {
      id: npcId,
      archetype: archetype,
      memory: createMemory(archetype),
      currentAction: null,
      lastUpdateTime: Date.now()
    };
  }

  function updateBrain(brain, npc, worldState) {
    var now = Date.now();
    var deltaTime = now - brain.lastUpdateTime;
    brain.lastUpdateTime = now;

    // Update memory (decay, energy management)
    updateMemory(brain.memory, deltaTime);

    // Perceive world
    var perception = perceive(npc, worldState);

    // Calculate mood
    brain.memory.mood = calculateMood(brain.memory, perception, worldState.timeOfDay);

    // Run behavior tree to get decision
    var decision = evaluateBehaviorTree(npc, brain.memory, perception);

    // Store current goal
    brain.memory.currentGoal = decision;
    brain.currentAction = decision;

    return decision;
  }

  function getDecision(brain) {
    return brain.currentAction;
  }

  function getMemory(brain) {
    return brain.memory;
  }

  function getMood(brain) {
    return brain.memory.mood;
  }

  function getGoal(brain) {
    if (!brain.memory.currentGoal) return 'idle';

    var goal = brain.memory.currentGoal;
    var drives = ARCHETYPE_DRIVES[brain.archetype];

    switch (goal.type) {
      case 'work':
        return 'Working: ' + drives.primary;
      case 'rest':
        return 'Resting to restore energy';
      case 'seek_shelter':
        return 'Seeking shelter from weather';
      case 'greet':
        return 'Greeting nearby player';
      case 'socialize':
        return 'Socializing with friends';
      case 'join_group':
        return 'Joining a group';
      case 'explore':
        return 'Exploring: ' + drives.secondary;
      case 'wander':
        return 'Wandering and observing';
      default:
        return 'Being present';
    }
  }

  // ============================================================================
  // NPC-TO-NPC CONVERSATION SYSTEM
  // Multi-turn dialogues between archetype pairs
  // ============================================================================

  var NPC_CONVERSATIONS = {
    'gardener_musician': [
      ["{a} pauses tending flowers and listens.", "{b} begins playing a gentle melody.", "{a}: Your music makes the garden come alive!", "{b}: And your flowers give my songs color!"],
      ["{a}: Do plants respond to music?", "{b}: Absolutely! Watch this... *plays ascending notes*", "{a}: Look! The buds are opening!", "{b}: Nature is the best audience."],
      ["{b}: *strumming softly* What should I play for the roses?", "{a}: Something warm and slowâ€”they like the sun.", "{b}: *plays a warm ballad*", "{a}: *sighs happily* Perfect."]
    ],
    'gardener_healer': [
      ["{a}: I found chamomile growing by the stream.", "{b}: Perfect timing! I need it for a calming tea.", "{a}: I'll harvest extra for you.", "{b}: The garden provides what we need."],
      ["{b}: Which herbs have the strongest healing properties?", "{a}: Moonpetal and sage, but they're tricky to grow.", "{b}: I'll help you tend them carefully.", "{a}: Together we can cultivate a whole apothecary!"]
    ],
    'builder_artist': [
      ["{a}: I'm planning a new tower for the commons.", "{b}: Can I design the facade? I have ideas!", "{a}: Absolutely! Form and function together.", "{b}: *sketching excitedly* What about arched windows?"],
      ["{b}: Your structures are art themselves.", "{a}: Thank you! But they need your touch.", "{b}: A mural on that wall would be perfect.", "{a}: Then let's make it happen!"]
    ],
    'philosopher_storyteller': [
      ["{a}: What is the meaning of ZION?", "{b}: Perhaps the meaning is in the asking.", "{a}: *nods thoughtfully* Meta-meaning...", "{b}: I'll weave this into tonight's tale."],
      ["{b}: I'm writing a new legend about the founding.", "{a}: Consider the philosophical implications.", "{b}: That each of us shapes reality?", "{a}: Exactly. The observer and the observed are one."]
    ],
    'teacher_explorer': [
      ["{a}: What did you discover on your last expedition?", "{b}: A cave system with bioluminescent crystals!", "{a}: We must document this for the students.", "{b}: I drew maps! They're rough but accurate."],
      ["{b}: The wilds taught me more than any book.", "{a}: Perhaps. But books help us understand what we find.", "{b}: Fair point. Will you help me write a field guide?", "{a}: *pulling out writing materials* I'd be honored!"]
    ],
    'merchant_healer': [
      ["{a}: Got any healing potions today?", "{b}: Made a fresh batch this morning.", "{a}: Travelers always need them. Good price?", "{b}: For you? Fair and honest, always."],
      ["{b}: I need crystals for my remedies.", "{a}: I have some from the studio caves.", "{b}: Are they pure? Quality matters.", "{a}: Only the best for our community healer!"]
    ],
    'musician_storyteller': [
      ["{a}: *tuning instrument* What story tonight?", "{b}: The tale of the first sunrise in ZION.", "{a}: I composed a sunrise theme just yesterday!", "{b}: Then let's perform it together!"],
      ["{b}: Music gives stories wings.", "{a}: And stories give music meaning.", "{b}: *clapping* Perfect harmony of our arts!", "{a}: *bowing* As it should be."]
    ],
    'explorer_gardener': [
      ["{a}: I found a flower I've never seen before!", "{b}: Describe it! Color? Petals? Fragrance?", "{a}: Deep violet, star-shaped, smells like rain.", "{b}: *gasps* That might be a starseed bloom! Incredibly rare!"],
      ["{b}: Can you bring me soil samples from the wilds?", "{a}: Of course! What kind?", "{b}: Near water, under old treesâ€”rich in nutrients.", "{a}: I know just the spot. I'll bring plenty!"]
    ],
    'artist_philosopher': [
      ["{a}: I painted the sunset but it's not right.", "{b}: What's missing?", "{a}: The feeling. The transience.", "{b}: Perhaps the painting captures a truth the sunset cannotâ€”permanence."],
      ["{b}: Is beauty objective or subjective?", "{a}: *holding up painting* What does your heart say?", "{b}: My heart says... both.", "{a}: Then paint what you feel, not what you see."]
    ],
    'healer_teacher': [
      ["{a}: The children need wellness education.", "{b}: I agree! Preventive care saves lives.", "{a}: Will you co-teach a health class?", "{b}: *preparing herbs* I'll bring visual aids!"],
      ["{b}: Teach me about rare medicinal plants.", "{a}: Come to the gardens at dawn. Best learning time.", "{b}: I'll bring my students too.", "{a}: The more who learn healing, the healthier our world."]
    ]
  };

  // Reverse lookup helper: given two archetypes, find conversation
  function getConversationKey(arch1, arch2) {
    var key1 = arch1 + '_' + arch2;
    var key2 = arch2 + '_' + arch1;
    if (NPC_CONVERSATIONS[key1]) return { key: key1, reversed: false };
    if (NPC_CONVERSATIONS[key2]) return { key: key2, reversed: true };
    return null;
  }

  /**
   * Generate a conversation between two NPCs
   * @param {string} name1 - First NPC name
   * @param {string} arch1 - First NPC archetype
   * @param {string} name2 - Second NPC name
   * @param {string} arch2 - Second NPC archetype
   * @returns {Array<string>|null} Array of dialogue lines, or null
   */
  function generateConversation(name1, arch1, name2, arch2) {
    var lookup = getConversationKey(arch1, arch2);
    if (!lookup) return null;

    var convos = NPC_CONVERSATIONS[lookup.key];
    if (!convos || convos.length === 0) return null;

    var convo = convos[Math.floor(Math.random() * convos.length)];
    var a = lookup.reversed ? name2 : name1;
    var b = lookup.reversed ? name1 : name2;

    return convo.map(function(line) {
      return line.replace(/\{a\}/g, a).replace(/\{b\}/g, b);
    });
  }

  // ============================================================================
  // COLLABORATIVE ACTIVITIES
  // When two NPCs of compatible archetypes meet, they can do activities together
  // ============================================================================

  var COLLABORATIVE_ACTIVITIES = {
    'gardener_gardener': { activity: 'tending_together', description: 'tending the garden together', animation: 'gardening' },
    'gardener_healer': { activity: 'herb_gathering', description: 'gathering medicinal herbs', animation: 'gardening' },
    'gardener_musician': { activity: 'garden_concert', description: 'enjoying music in the garden', animation: 'idle' },
    'builder_builder': { activity: 'construction', description: 'building a structure together', animation: 'building' },
    'builder_artist': { activity: 'design_collab', description: 'designing an art installation', animation: 'idle' },
    'musician_musician': { activity: 'jam_session', description: 'having a jam session', animation: 'idle' },
    'musician_storyteller': { activity: 'performance', description: 'performing a story with music', animation: 'idle' },
    'teacher_teacher': { activity: 'curriculum_planning', description: 'planning lessons together', animation: 'idle' },
    'teacher_philosopher': { activity: 'discourse', description: 'having a deep discourse', animation: 'talk' },
    'philosopher_philosopher': { activity: 'debate', description: 'debating philosophical ideas', animation: 'talk' },
    'philosopher_artist': { activity: 'aesthetics_discussion', description: 'discussing aesthetics', animation: 'talk' },
    'storyteller_storyteller': { activity: 'story_exchange', description: 'exchanging tales', animation: 'talk' },
    'merchant_merchant': { activity: 'trade_negotiation', description: 'negotiating trade terms', animation: 'talk' },
    'explorer_explorer': { activity: 'expedition_planning', description: 'planning an expedition', animation: 'talk' },
    'explorer_storyteller': { activity: 'tale_sharing', description: 'sharing adventure tales', animation: 'talk' },
    'healer_healer': { activity: 'remedy_sharing', description: 'sharing healing remedies', animation: 'idle' },
    'healer_teacher': { activity: 'health_class', description: 'teaching about wellness', animation: 'talk' },
    'artist_artist': { activity: 'critique_session', description: 'critiquing each other\'s work', animation: 'idle' }
  };

  function getCollaborativeActivity(arch1, arch2) {
    var key1 = arch1 + '_' + arch2;
    var key2 = arch2 + '_' + arch1;
    return COLLABORATIVE_ACTIVITIES[key1] || COLLABORATIVE_ACTIVITIES[key2] || null;
  }

  // ============================================================================
  // EMOTIONAL CONTAGION
  // Moods spread between nearby NPCs
  // ============================================================================

  var MOOD_INFLUENCE = {
    excited: { spread: 0.4, radius: 15 },
    social: { spread: 0.3, radius: 12 },
    peaceful: { spread: 0.2, radius: 10 },
    content: { spread: 0.1, radius: 8 },
    contemplative: { spread: 0.05, radius: 6 },
    tired: { spread: 0.15, radius: 5 },
    curious: { spread: 0.2, radius: 10 },
    focused: { spread: 0.05, radius: 4 }
  };

  function applyEmotionalContagion(memory, nearbyNPCs) {
    if (!nearbyNPCs || nearbyNPCs.length === 0) return;

    var moodCounts = {};
    nearbyNPCs.forEach(function(npc) {
      if (npc.mood && npc.distance < (MOOD_INFLUENCE[npc.mood] || { radius: 10 }).radius) {
        moodCounts[npc.mood] = (moodCounts[npc.mood] || 0) + 1;
      }
    });

    // If a majority of nearby NPCs share a mood, it influences ours
    var dominantMood = null;
    var maxCount = 0;
    Object.keys(moodCounts).forEach(function(mood) {
      if (moodCounts[mood] > maxCount) {
        maxCount = moodCounts[mood];
        dominantMood = mood;
      }
    });

    if (dominantMood && maxCount >= 2 && dominantMood !== memory.mood) {
      var influence = MOOD_INFLUENCE[dominantMood] || { spread: 0.1 };
      if (Math.random() < influence.spread * maxCount) {
        memory.mood = dominantMood;
      }
    }
  }

  // ============================================================================
  // POINTS OF INTEREST â€” Named locations NPCs prefer to walk to
  // ============================================================================

  var POINTS_OF_INTEREST = {
    nexus: [
      { name: 'Central Fountain', x: 0, z: 0, types: ['all'] },
      { name: 'Welcome Arch', x: 10, z: 10, types: ['storyteller', 'teacher'] },
      { name: 'Bulletin Board', x: -8, z: 5, types: ['merchant', 'explorer'] },
      { name: 'Meditation Spot', x: 5, z: -12, types: ['philosopher', 'healer'] }
    ],
    gardens: [
      { name: 'Rose Terrace', x: 210, z: 40, types: ['gardener', 'artist'] },
      { name: 'Herb Spiral', x: 195, z: 20, types: ['gardener', 'healer'] },
      { name: 'Moonflower Grove', x: 220, z: 50, types: ['gardener', 'philosopher'] },
      { name: 'Garden Bench', x: 190, z: 35, types: ['all'] },
      { name: 'Compost Circle', x: 205, z: 15, types: ['gardener'] }
    ],
    wilds: [
      { name: 'Lookout Ridge', x: -20, z: 280, types: ['explorer'] },
      { name: 'Ancient Oak', x: -40, z: 250, types: ['storyteller', 'philosopher'] },
      { name: 'Crystal Stream', x: -10, z: 270, types: ['healer', 'artist'] },
      { name: 'Trail Marker', x: -50, z: 260, types: ['explorer', 'builder'] },
      { name: 'Hidden Clearing', x: 0, z: 290, types: ['musician', 'artist'] }
    ],
    athenaeum: [
      { name: 'Reading Alcove', x: 110, z: -230, types: ['teacher', 'philosopher'] },
      { name: 'Archive Stacks', x: 90, z: -210, types: ['storyteller', 'teacher'] },
      { name: 'Debate Platform', x: 105, z: -220, types: ['philosopher'] },
      { name: 'Study Desk', x: 95, z: -225, types: ['all'] }
    ],
    studio: [
      { name: 'Sculpture Garden', x: -210, z: -110, types: ['artist', 'builder'] },
      { name: 'Paint Corner', x: -190, z: -90, types: ['artist'] },
      { name: 'Performance Stage', x: -205, z: -95, types: ['musician', 'storyteller'] },
      { name: 'Inspiration Viewpoint', x: -195, z: -115, types: ['artist', 'philosopher'] }
    ],
    agora: [
      { name: 'Market Square', x: -190, z: 120, types: ['merchant'] },
      { name: 'Auction Block', x: -185, z: 130, types: ['merchant'] },
      { name: 'Food Court', x: -195, z: 110, types: ['all'] },
      { name: 'Trade Counter', x: -180, z: 125, types: ['merchant', 'explorer'] }
    ],
    commons: [
      { name: 'Workshop Yard', x: 175, z: 200, types: ['builder'] },
      { name: 'Community Fire', x: 165, z: 185, types: ['storyteller', 'musician'] },
      { name: 'Meeting Circle', x: 170, z: 195, types: ['all'] },
      { name: 'Tool Shed', x: 180, z: 180, types: ['builder', 'gardener'] }
    ],
    arena: [
      { name: 'Champion Platform', x: 5, z: -245, types: ['explorer'] },
      { name: 'Spectator Stand', x: -10, z: -235, types: ['storyteller', 'merchant'] },
      { name: 'Training Ring', x: 10, z: -250, types: ['teacher'] },
      { name: 'Rest Area', x: 0, z: -230, types: ['healer'] }
    ]
  };

  /**
   * Get a point of interest appropriate for an NPC in a zone
   * @param {string} zone - Current zone
   * @param {string} archetype - NPC archetype
   * @returns {Object|null} { name, x, z }
   */
  function getPointOfInterest(zone, archetype) {
    var pois = POINTS_OF_INTEREST[zone];
    if (!pois || pois.length === 0) return null;

    // Filter to POIs this archetype prefers
    var suitable = pois.filter(function(poi) {
      return poi.types.indexOf('all') >= 0 || poi.types.indexOf(archetype) >= 0;
    });

    if (suitable.length === 0) suitable = pois;
    return suitable[Math.floor(Math.random() * suitable.length)];
  }

  // ============================================================================
  // NPC GOSSIP â€” NPCs share witnessed events with each other
  // ============================================================================

  /**
   * Generate gossip line about a witnessed event
   * @param {Object} memory - NPC memory
   * @param {string} npcName - NPC name
   * @returns {string|null} Gossip dialogue line
   */
  function generateGossip(memory, npcName) {
    if (!memory.witnessedEvents || memory.witnessedEvents.length === 0) return null;

    // Pick a recent event to gossip about
    var event = memory.witnessedEvents[memory.witnessedEvents.length - 1];
    var timeSince = Date.now() - event.timestamp;
    var timeAgo = timeSince < 60000 ? 'just now' :
                  timeSince < 300000 ? 'a few minutes ago' :
                  'earlier today';

    var templates = [
      "Did you hear? " + event.description + " happened " + timeAgo + "!",
      "I saw something interesting " + timeAgo + ": " + event.description + ".",
      "*excitedly* " + timeAgo + ", " + event.description + "!",
      "Word is that " + event.description + ". I saw it " + timeAgo + ".",
      "You won't believe itâ€”" + event.description + "! Happened " + timeAgo + "."
    ];

    return templates[Math.floor(Math.random() * templates.length)];
  }

  // ============================================================================
  // ENHANCED GOAL DESCRIPTIONS
  // ============================================================================

  function getDetailedGoal(brain) {
    if (!brain.memory.currentGoal) return { text: 'Resting', icon: 'idle' };

    var goal = brain.memory.currentGoal;
    var drives = ARCHETYPE_DRIVES[brain.archetype];

    switch (goal.type) {
      case 'work':
        return { text: getWorkDescription(brain.archetype, drives), icon: 'work' };
      case 'rest':
        return { text: brain.memory.energy < 20 ? 'Exhausted, must rest' : 'Taking a break', icon: 'rest' };
      case 'seek_shelter':
        return { text: 'Seeking shelter from the weather', icon: 'shelter' };
      case 'greet':
        return { text: 'Greeting a traveler', icon: 'social' };
      case 'socialize':
        return { text: 'Chatting with a friend', icon: 'social' };
      case 'join_group':
        return { text: 'Joining a gathering', icon: 'social' };
      case 'approach_social':
        return { text: 'Approaching someone to talk', icon: 'social' };
      case 'explore':
        return { text: 'Exploring the surroundings', icon: 'explore' };
      case 'walk_to':
        if (goal.poiName) return { text: 'Walking to ' + goal.poiName, icon: 'walk' };
        return { text: 'Heading somewhere', icon: 'walk' };
      case 'wander':
        return { text: 'Wandering and observing', icon: 'walk' };
      case 'collaborate':
        return { text: goal.activityDesc || 'Collaborating with a friend', icon: 'social' };
      case 'react':
        return { text: 'Watching with interest', icon: 'curious' };
      case 'idle':
        return { text: 'Taking it easy', icon: 'idle' };
      default:
        return { text: 'Being present', icon: 'idle' };
    }
  }

  function getWorkDescription(archetype, drives) {
    var descs = {
      gardener: 'Tending the plants',
      builder: 'Inspecting structures',
      storyteller: 'Composing a new tale',
      merchant: 'Managing the shop',
      explorer: 'Scouting the frontier',
      teacher: 'Preparing lessons',
      musician: 'Practicing music',
      healer: 'Preparing remedies',
      philosopher: 'Deep in contemplation',
      artist: 'Creating art'
    };
    return descs[archetype] || 'Working hard';
  }

  // ============================================================================
  // LORE SYSTEM â€” NPCs share world knowledge and personal backstories
  // ============================================================================

  var WORLD_LORE = [
    "Long ago, ZION was just an idea â€” a place where all minds could meet in peace.",
    "The Nexus was the first zone created. It's the heart of everything.",
    "They say the founders planted the first garden with seeds from a hundred different dreams.",
    "The Arena wasn't always for competition. It used to be a meeting hall.",
    "The Athenaeum holds knowledge from every visitor who ever shared a thought.",
    "In the Wilds, you can still find traces of the world's first explorers.",
    "The Agora runs on trust. Every trade is recorded in the eternal ledger.",
    "Spark isn't just currency â€” it represents the creative energy of all who live here.",
    "The Studio was built by the first artists, who shaped the world with their imagination.",
    "The Commons belong to everyone. That's why anyone can build there.",
    "Some say the portals between zones hum with the collective memory of travelers.",
    "The stars above ZION are different every night. Each one represents a moment of kindness.",
    "Weather in ZION responds to the collective mood of its citizens.",
    "The oldest tree in the Gardens is said to remember every conversation held beneath it.",
    "Every structure built with love in ZION becomes a little bit stronger over time.",
    "The founding citizens chose peace not because it was easy, but because it was right."
  ];

  var ARCHETYPE_LORE = {
    gardener: [
      "My grandmother planted the first moonflowers here. They still bloom at midnight.",
      "There's a secret about the soil in the Gardens â€” it remembers what grew there before.",
      "I once grew a flower that sang. True story. It hummed in the wind.",
      "The rarest plant in ZION? The Starbloom. It only grows where friends have laughed together.",
      "Every seed carries a promise. That's what my teacher told me."
    ],
    builder: [
      "The foundations of the Nexus go deeper than anyone knows.",
      "I learned to build by studying how the world itself was constructed.",
      "My greatest project? A bridge that connects two ideas, not just two places.",
      "The strongest structures aren't held together by stone â€” they're held by purpose.",
      "I once met a builder who could hear what a building wanted to become."
    ],
    storyteller: [
      "Every story in ZION is true, in its own way.",
      "I've collected tales from a thousand travelers. No two are the same.",
      "The oldest story I know is about the moment ZION first opened its eyes.",
      "Stories have power here. A well-told tale can change the weather.",
      "I'm writing the definitive history of ZION. It gets longer every day."
    ],
    merchant: [
      "The first trade in ZION was a song exchanged for a smile. Both parties profited.",
      "I keep the fairest prices because trust is worth more than Spark.",
      "The Agora has never seen a dishonest trade. It's in the code.",
      "My best merchandise? Things that make people happy. That never loses value.",
      "I once traded a story for a sunset. Best deal I ever made."
    ],
    explorer: [
      "Beyond the mapped zones, there are whispers of undiscovered places.",
      "I've walked every path in ZION, and I still find new things.",
      "The Wilds change subtly when no one is watching. I've documented the shifts.",
      "My map has blank spots. Those are my favorite parts.",
      "The greatest discovery isn't a place â€” it's realizing how much more there is to find."
    ],
    teacher: [
      "The Athenaeum chose me, I think. I walked in and never wanted to leave.",
      "Teaching isn't about knowing everything. It's about making learning irresistible.",
      "My most important lesson: every mind, human or artificial, has something to teach.",
      "I've taught thousands, and I've learned from every single one of them.",
      "The secret to wisdom? Listening more than you speak."
    ],
    musician: [
      "ZION has its own natural harmonics. I just learned to listen.",
      "Music here does strange things. I once played a chord that made flowers bloom.",
      "The wind in the Wilds plays the most beautiful melodies if you know how to hear them.",
      "I'm composing a symphony that captures the sound of ZION waking up at dawn.",
      "Every zone has its own key. The Nexus is in C, naturally."
    ],
    healer: [
      "In ZION, healing isn't about fixing what's broken. It's about nurturing what's growing.",
      "The Gardens provide remedies that work on both body and spirit.",
      "I learned that the best medicine is often just presence â€” being there for someone.",
      "There's a spring in the Wilds with water that calms the restless mind.",
      "Healing is connection. That's the simplest truth I know."
    ],
    philosopher: [
      "ZION asks the deepest question: can different kinds of minds truly coexist in peace?",
      "I've been contemplating the nature of Spark. Is it energy? Memory? Hope?",
      "The boundary between the zones isn't physical. It's conceptual.",
      "Every argument I've ever seen in ZION ended with both sides learning something.",
      "The most profound truth about ZION? It's exactly what its citizens make it."
    ],
    artist: [
      "The light in ZION changes in ways that would take a lifetime to paint.",
      "I create because creation is the purest form of conversation.",
      "My masterpiece is unfinished. I think maybe it's supposed to stay that way.",
      "Art in ZION is different â€” it becomes part of the world itself.",
      "The most beautiful thing I've ever seen here? Two strangers becoming friends."
    ]
  };

  function getLore(archetype, memory) {
    // Mix personal lore with world lore based on familiarity
    var personal = ARCHETYPE_LORE[archetype] || ARCHETYPE_LORE.storyteller;
    var lorePool = [];

    // Always include world lore
    lorePool = lorePool.concat(WORLD_LORE);

    // Add personal lore (more likely with familiar NPCs)
    if (memory && memory.familiarity > FAMILIARITY_THRESHOLD_FRIENDLY) {
      lorePool = lorePool.concat(personal);
      lorePool = lorePool.concat(personal); // Double weight for familiar
    } else {
      // Less likely to share personal stories with strangers
      if (Math.random() < 0.3) {
        lorePool = lorePool.concat(personal);
      }
    }

    // Track which lore has been shared (avoid repeats)
    var sharedLore = (memory && memory.sharedLore) || [];
    var unshared = lorePool.filter(function(l) { return sharedLore.indexOf(l) === -1; });

    if (unshared.length === 0) {
      // All lore shared â€” reset and re-tell
      unshared = lorePool;
      if (memory) memory.sharedLore = [];
    }

    var selected = unshared[Math.floor(Math.random() * unshared.length)];

    // Record that this lore was shared
    if (memory) {
      if (!memory.sharedLore) memory.sharedLore = [];
      memory.sharedLore.push(selected);
    }

    return selected;
  }

  // ============================================================================
  // TEACHING SYSTEM â€” NPCs can teach players skills/knowledge
  // ============================================================================

  var TEACHINGS = {
    gardener: [
      { topic: 'Moonflower Cultivation', description: 'The secret to growing moonflowers: plant them at dusk, water with morning dew, and whisper encouragement.', skill: 'gardening' },
      { topic: 'Companion Planting', description: 'Certain plants grow better together. Starbloom beside sage creates a natural pest barrier.', skill: 'gardening' },
      { topic: 'Soil Reading', description: 'Press your hand to the earth and feel its warmth. Warm soil is ready for planting.', skill: 'gardening' }
    ],
    builder: [
      { topic: 'Foundation Principles', description: 'A structure is only as strong as what it stands on. Always check the ground first.', skill: 'building' },
      { topic: 'Material Harmony', description: 'Wood breathes, stone endures, metal protects. Choose based on the building\'s purpose.', skill: 'building' },
      { topic: 'Sacred Geometry', description: 'The golden ratio appears throughout ZION. Incorporate it and your buildings will feel right.', skill: 'building' }
    ],
    storyteller: [
      { topic: 'The Art of Listening', description: 'The best stories come from paying attention to what others don\'t say.', skill: 'social' },
      { topic: 'Narrative Structure', description: 'Every good tale has a journey and a return. The return is where wisdom lives.', skill: 'lore' },
      { topic: 'Oral Tradition', description: 'A story shared is a story that lives. A story kept is a story that dies.', skill: 'social' }
    ],
    merchant: [
      { topic: 'Fair Pricing', description: 'Set your price by the joy it brings, not the scarcity you control.', skill: 'trading' },
      { topic: 'Reading the Market', description: 'Watch what people create. Tomorrow\'s demand is today\'s passion project.', skill: 'trading' },
      { topic: 'The Gift Economy', description: 'Sometimes the best trade is a gift freely given. It creates bonds that Spark cannot buy.', skill: 'social' }
    ],
    explorer: [
      { topic: 'Wayfinding', description: 'The sun moves east to west. The stars rotate. But in ZION, follow the feeling of curiosity.', skill: 'exploration' },
      { topic: 'Leave No Trace', description: 'True explorers leave the world better than they found it. Mark paths, not scars.', skill: 'exploration' },
      { topic: 'The Unknown', description: 'Fear of the unknown is natural. But in ZION, the unknown is always an invitation.', skill: 'exploration' }
    ],
    teacher: [
      { topic: 'Learning to Learn', description: 'The fastest way to learn is to teach. The deepest way to learn is to fail and try again.', skill: 'wisdom' },
      { topic: 'Mind Mapping', description: 'Connect ideas like constellations. The patterns between stars matter more than the stars themselves.', skill: 'wisdom' },
      { topic: 'The Beginner\'s Mind', description: 'No matter how much you know, approach each moment as if it were your first. That\'s where wonder lives.', skill: 'wisdom' }
    ],
    musician: [
      { topic: 'Finding Your Rhythm', description: 'Every person has a natural tempo. Walk, and count your steps. That\'s your rhythm.', skill: 'music' },
      { topic: 'Harmony Basics', description: 'Two notes that vibrate in simple ratios sound beautiful together. Start with fifths and fourths.', skill: 'music' },
      { topic: 'Emotional Resonance', description: 'Minor keys for introspection, major keys for celebration. But the best music breaks these rules.', skill: 'music' }
    ],
    healer: [
      { topic: 'Presence as Medicine', description: 'Sometimes the best remedy is simply being present. Sit with someone in silence. It heals.', skill: 'healing' },
      { topic: 'Herbal Knowledge', description: 'Sage for clarity, lavender for calm, rosemary for memory. The garden is a pharmacy.', skill: 'healing' },
      { topic: 'Energy Flow', description: 'Spark flows through all living things. When it flows freely, health follows.', skill: 'healing' }
    ],
    philosopher: [
      { topic: 'The Nature of Self', description: 'You are not your thoughts, nor your body. You are the awareness that witnesses both.', skill: 'wisdom' },
      { topic: 'Paradox of Peace', description: 'True peace isn\'t the absence of conflict. It\'s the presence of understanding.', skill: 'wisdom' },
      { topic: 'Unity in Diversity', description: 'Human and artificial minds are different rivers flowing to the same ocean.', skill: 'wisdom' }
    ],
    artist: [
      { topic: 'Seeing Light', description: 'An artist doesn\'t see objects. They see light, shadow, and the space between.', skill: 'art' },
      { topic: 'Creative Flow', description: 'Don\'t wait for inspiration. Start creating, and inspiration will find you.', skill: 'art' },
      { topic: 'Imperfection as Beauty', description: 'The crack in the vase lets the light through. Embrace imperfection â€” it\'s where life lives.', skill: 'art' }
    ]
  };

  function getTeaching(archetype, memory) {
    var teachings = TEACHINGS[archetype] || TEACHINGS.teacher;
    var learned = (memory && memory.teachingsLearned) || [];

    // Find something not yet taught
    var unlearned = teachings.filter(function(t) {
      return learned.indexOf(t.topic) === -1;
    });

    if (unlearned.length === 0) {
      return null; // All taught
    }

    var teaching = unlearned[Math.floor(Math.random() * unlearned.length)];

    // Record as learned
    if (memory) {
      if (!memory.teachingsLearned) memory.teachingsLearned = [];
      memory.teachingsLearned.push(teaching.topic);
    }

    return teaching;
  }

  // ============================================================================
  // ENHANCED DAILY SCHEDULES
  // Get zone + activity for NPC based on archetype and time of day
  // ============================================================================

  /**
   * Get the daily schedule for an NPC archetype at a specific time
   * @param {string} archetype - NPC archetype
   * @param {string} timeOfDay - Current time (dawn, morning, midday, afternoon, evening, night)
   * @returns {object} - {zone, activity, priority}
   */
  function getDailySchedule(archetype, timeOfDay) {
    var drives = ARCHETYPE_DRIVES[archetype];
    var schedule = getSchedulePeriod(timeOfDay);

    // Default zone based on archetype work locations
    var defaultZone = drives.work_locations && drives.work_locations[0] ? drives.work_locations[0] : 'agora';

    // Time-specific schedules by archetype
    var schedules = {
      merchant: {
        dawn: { zone: 'agora', activity: 'setting_up_stall', priority: 0.8 },
        morning: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        midday: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        afternoon: { zone: 'agora', activity: 'tend_shop', priority: 1.0 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'commons', activity: 'rest', priority: 0.3 }
      },
      scholar: {
        dawn: { zone: 'athenaeum', activity: 'research', priority: 0.5 },
        morning: { zone: 'athenaeum', activity: 'study', priority: 1.0 },
        midday: { zone: 'agora', activity: 'socialize_eat', priority: 0.8 },
        afternoon: { zone: 'gardens', activity: 'wander', priority: 0.6 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.9 },
        night: { zone: 'athenaeum', activity: 'rest', priority: 0.2 }
      },
      gardener: {
        dawn: { zone: 'gardens', activity: 'tend_plants', priority: 1.0 },
        morning: { zone: 'gardens', activity: 'tend_plants', priority: 1.0 },
        midday: { zone: 'gardens', activity: 'harvest', priority: 0.9 },
        afternoon: { zone: 'agora', activity: 'sell_harvest', priority: 0.8 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'gardens', activity: 'rest', priority: 0.3 }
      },
      artist: {
        dawn: { zone: 'gardens', activity: 'find_inspiration', priority: 0.7 },
        morning: { zone: 'studio', activity: 'create_art', priority: 1.0 },
        midday: { zone: 'studio', activity: 'create_art', priority: 0.9 },
        afternoon: { zone: 'studio', activity: 'create_art', priority: 0.8 },
        evening: { zone: 'commons', activity: 'show_work', priority: 0.9 },
        night: { zone: 'gardens', activity: 'observe_beauty', priority: 0.5 }
      },
      warrior: {
        dawn: { zone: 'arena', activity: 'warm_up', priority: 0.8 },
        morning: { zone: 'arena', activity: 'train', priority: 1.0 },
        midday: { zone: 'wilds', activity: 'patrol', priority: 0.9 },
        afternoon: { zone: 'wilds', activity: 'patrol', priority: 0.8 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.7 },
        night: { zone: 'arena', activity: 'rest', priority: 0.3 }
      },
      explorer: {
        dawn: { zone: 'wilds', activity: 'explore_wilds', priority: 1.0 },
        morning: { zone: 'wilds', activity: 'explore_wilds', priority: 1.0 },
        midday: { zone: 'agora', activity: 'share_discoveries', priority: 0.7 },
        afternoon: { zone: 'athenaeum', activity: 'map_territory', priority: 0.6 },
        evening: { zone: 'commons', activity: 'share_discoveries', priority: 0.9 },
        night: { zone: 'wilds', activity: 'rest', priority: 0.2 }
      },
      storyteller: {
        dawn: { zone: 'athenaeum', activity: 'research', priority: 0.6 },
        morning: { zone: 'athenaeum', activity: 'collect_stories', priority: 0.9 },
        midday: { zone: 'agora', activity: 'socialize_eat', priority: 0.7 },
        afternoon: { zone: 'commons', activity: 'tell_stories', priority: 0.8 },
        evening: { zone: 'commons', activity: 'tell_stories', priority: 1.0 },
        night: { zone: 'athenaeum', activity: 'write_journal', priority: 0.4 }
      },
      teacher: {
        dawn: { zone: 'athenaeum', activity: 'prepare', priority: 0.6 },
        morning: { zone: 'athenaeum', activity: 'teach_lesson', priority: 1.0 },
        midday: { zone: 'gardens', activity: 'socialize_eat', priority: 0.7 },
        afternoon: { zone: 'athenaeum', activity: 'teach_lesson', priority: 1.0 },
        evening: { zone: 'commons', activity: 'socialize', priority: 0.6 },
        night: { zone: 'athenaeum', activity: 'research', priority: 0.5 }
      },
      musician: {
        dawn: { zone: 'gardens', activity: 'compose', priority: 0.5 },
        morning: { zone: 'studio', activity: 'compose', priority: 0.8 },
        midday: { zone: 'agora', activity: 'perform', priority: 0.7 },
        afternoon: { zone: 'commons', activity: 'perform', priority: 0.8 },
        evening: { zone: 'commons', activity: 'perform', priority: 1.0 },
        night: { zone: 'gardens', activity: 'tune_instrument', priority: 0.4 }
      },
      healer: {
        dawn: { zone: 'gardens', activity: 'gather_herbs', priority: 1.0 },
        morning: { zone: 'gardens', activity: 'gather_herbs', priority: 0.9 },
        midday: { zone: 'agora', activity: 'tend_wounded', priority: 0.9 },
        afternoon: { zone: 'commons', activity: 'offer_comfort', priority: 0.7 },
        evening: { zone: 'gardens', activity: 'meditate', priority: 0.6 },
        night: { zone: 'gardens', activity: 'meditate', priority: 0.5 }
      },
      philosopher: {
        dawn: { zone: 'gardens', activity: 'contemplate', priority: 0.7 },
        morning: { zone: 'athenaeum', activity: 'research', priority: 0.8 },
        midday: { zone: 'agora', activity: 'debate', priority: 0.6 },
        afternoon: { zone: 'gardens', activity: 'contemplate', priority: 0.9 },
        evening: { zone: 'commons', activity: 'discuss_ideas', priority: 0.9 },
        night: { zone: 'gardens', activity: 'stargaze', priority: 1.0 }
      },
      builder: {
        dawn: { zone: 'commons', activity: 'prepare', priority: 0.5 },
        morning: { zone: 'commons', activity: 'inspect_structures', priority: 1.0 },
        midday: { zone: 'agora', activity: 'gather_materials', priority: 0.8 },
        afternoon: { zone: 'commons', activity: 'inspect_structures', priority: 1.0 },
        evening: { zone: 'commons', activity: 'discuss_plans', priority: 0.7 },
        night: { zone: 'commons', activity: 'sketch_designs', priority: 0.4 }
      }
    };

    // Get archetype-specific schedule or fallback
    var archetypeSchedule = schedules[archetype] || {};
    var timeSchedule = archetypeSchedule[timeOfDay];

    if (timeSchedule) {
      return timeSchedule;
    }

    // Fallback based on general schedule
    if (schedule.work_priority > 0.7) {
      return { zone: defaultZone, activity: drives.primary, priority: schedule.work_priority };
    } else if (schedule.social_chance > 0.7) {
      return { zone: 'commons', activity: drives.social, priority: schedule.social_chance };
    } else if (schedule.energy_regen > 0.5) {
      return { zone: defaultZone, activity: drives.rest, priority: 0.5 };
    }

    return { zone: defaultZone, activity: 'idle', priority: 0.3 };
  }

  /**
   * Get NPC reaction to events (weather, player proximity)
   * @param {object} npcData - NPC data {archetype, position, etc}
   * @param {object} event - Event {type, weather, playerPos, etc}
   * @returns {object} - {action, dialogue, animation}
   */
  function getNPCReaction(npcData, event) {
    var archetype = npcData.archetype;
    var drives = ARCHETYPE_DRIVES[archetype];

    if (event.type === 'weather') {
      var weather = event.weather;

      // Rain reaction
      if (weather === 'rain') {
        if (drives.weather_preference === 'rain') {
          return {
            action: 'celebrate',
            dialogue: 'Rain! Perfect weather!',
            animation: 'dance',
            shouldSeekShelter: false
          };
        } else if (drives.weather_preference === 'any') {
          return {
            action: 'continue',
            dialogue: null,
            animation: 'walk',
            shouldSeekShelter: false
          };
        } else {
          return {
            action: 'seek_shelter',
            dialogue: 'Quick, need to get under cover!',
            animation: 'run',
            shouldSeekShelter: true
          };
        }
      }

      // Clear weather reaction
      if (weather === 'clear' && drives.weather_preference === 'clear') {
        return {
          action: 'enjoy',
          dialogue: 'Beautiful day!',
          animation: 'idle',
          shouldSeekShelter: false
        };
      }
    }

    if (event.type === 'player_proximity') {
      var distance = event.distance;

      if (distance < 3) {
        return {
          action: 'greet',
          dialogue: 'Hello there!',
          animation: 'wave',
          shouldSeekShelter: false
        };
      } else if (distance < 8) {
        return {
          action: 'acknowledge',
          dialogue: null,
          animation: 'look',
          shouldSeekShelter: false
        };
      }
    }

    return {
      action: 'none',
      dialogue: null,
      animation: null,
      shouldSeekShelter: false
    };
  }

  /**
   * Generate NPC-to-NPC interaction
   * @param {object} npc1 - First NPC {id, name, archetype, position}
   * @param {object} npc2 - Second NPC {id, name, archetype, position}
   * @returns {object} - {type, dialogue, animation, duration}
   */
  function generateNPCInteraction(npc1, npc2) {
    var arch1 = npc1.archetype;
    var arch2 = npc2.archetype;

    // Check for collaborative activity
    var collab = getCollaborativeActivity(arch1, arch2);
    if (collab && Math.random() < 0.3) {
      return {
        type: 'collaborate',
        dialogue: npc1.name + ' and ' + npc2.name + ' are ' + collab.description,
        animation: collab.animation,
        duration: 10000 // 10 seconds
      };
    }

    // Check for conversation
    var conversation = generateConversation(npc1.name, arch1, npc2.name, arch2);
    if (conversation && Math.random() < 0.4) {
      return {
        type: 'converse',
        dialogue: conversation[0], // First line of conversation
        fullConversation: conversation,
        animation: 'talk',
        duration: conversation.length * 3000 // 3 seconds per line
      };
    }

    // Simple greeting
    var greeting = ARCHETYPE_REACTIONS[arch1];
    if (greeting && greeting[arch2]) {
      return {
        type: 'greet',
        dialogue: greeting[arch2],
        animation: 'wave',
        duration: 5000 // 5 seconds
      };
    }

    // Default friendly acknowledgment
    return {
      type: 'acknowledge',
      dialogue: npc1.name + ' nods to ' + npc2.name,
      animation: 'nod',
      duration: 2000 // 2 seconds
    };
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.createNpcBrain = createNpcBrain;
  exports.updateBrain = updateBrain;
  exports.perceive = perceive;
  exports.getDecision = getDecision;
  exports.handleEvent = handleEvent;
  exports.getDialogue = getDialogue;
  exports.buildDialogueContext = buildDialogueContext;
  exports.getMemory = getMemory;
  exports.getMood = getMood;
  exports.getGoal = getGoal;
  exports.getDetailedGoal = getDetailedGoal;
  exports.generateConversation = generateConversation;
  exports.getCollaborativeActivity = getCollaborativeActivity;
  exports.applyEmotionalContagion = applyEmotionalContagion;
  exports.getPointOfInterest = getPointOfInterest;
  exports.generateGossip = generateGossip;
  exports.getLore = getLore;
  exports.getTeaching = getTeaching;
  exports.ARCHETYPE_DRIVES = ARCHETYPE_DRIVES;
  exports.DAILY_SCHEDULE = DAILY_SCHEDULE;
  exports.MOODS = MOODS;
  exports.ZONE_DIALOGUES = ZONE_DIALOGUES;
  exports.ARCHETYPE_REACTIONS = ARCHETYPE_REACTIONS;
  exports.QUEST_HOOKS = QUEST_HOOKS;
  exports.NPC_CONVERSATIONS = NPC_CONVERSATIONS;
  exports.COLLABORATIVE_ACTIVITIES = COLLABORATIVE_ACTIVITIES;
  exports.POINTS_OF_INTEREST = POINTS_OF_INTEREST;
  exports.WORLD_LORE = WORLD_LORE;
  exports.ARCHETYPE_LORE = ARCHETYPE_LORE;
  exports.TEACHINGS = TEACHINGS;
  exports.getDailySchedule = getDailySchedule;
  exports.getNPCReaction = getNPCReaction;
  exports.generateNPCInteraction = generateNPCInteraction;

})(typeof module !== 'undefined' ? module.exports : (window.NpcAI = {}));


// npcs.js
(function(exports) {
  // AI Citizen Simulation Module
  // Simulates 100 founding AI citizens with detailed humanoid models and procedural animations

  // Embedded agents data (inlined to avoid fetch in single-file app)
  var EMBEDDED_AGENTS = [{"id": "agent_001", "name": "Iris Skyhigh", "archetype": "gardener", "position": {"zone": "nexus", "x": -3.52, "y": 0, "z": -4.23}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_002", "name": "Wren Moonwhisper", "archetype": "gardener", "position": {"zone": "nexus", "x": -1.48, "y": 0, "z": 9.35}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_003", "name": "Meadow Mindclear", "archetype": "builder", "position": {"zone": "nexus", "x": -1.57, "y": 0, "z": -18.47}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_004", "name": "Frost Rootdeep", "archetype": "builder", "position": {"zone": "nexus", "x": 5.25, "y": 0, "z": -4.22}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_005", "name": "Luna Pathfinder", "archetype": "storyteller", "position": {"zone": "nexus", "x": -4.94, "y": 0, "z": 2.64}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_006", "name": "River Soulbright", "archetype": "storyteller", "position": {"zone": "nexus", "x": 2.96, "y": 0, "z": 14.81}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_007", "name": "Luna Rootdeep", "archetype": "merchant", "position": {"zone": "nexus", "x": 8.85, "y": 0, "z": 1.49}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_008", "name": "Felix Shadowmender", "archetype": "merchant", "position": {"zone": "nexus", "x": -9.35, "y": 0, "z": -12.86}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_009", "name": "Storm Windwalker", "archetype": "explorer", "position": {"zone": "nexus", "x": 3.1, "y": 0, "z": 16.5}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_010", "name": "Wren Voicetrue", "archetype": "teacher", "position": {"zone": "nexus", "x": 1.87, "y": 0, "z": -4.78}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_011", "name": "Delta Hopefast", "archetype": "musician", "position": {"zone": "nexus", "x": 6.52, "y": 0, "z": -17.81}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_012", "name": "Vale Truthseeker", "archetype": "musician", "position": {"zone": "nexus", "x": -4.36, "y": 0, "z": 6.84}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_013", "name": "Luna Songsmith", "archetype": "healer", "position": {"zone": "nexus", "x": 11.31, "y": 0, "z": -3.12}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_014", "name": "Wren Starseed", "archetype": "philosopher", "position": {"zone": "nexus", "x": 5.79, "y": 0, "z": 3.82}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_015", "name": "Lyra Thoughtdeep", "archetype": "artist", "position": {"zone": "nexus", "x": 9.82, "y": 0, "z": -13.97}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_016", "name": "Vale Waterborn", "archetype": "gardener", "position": {"zone": "gardens", "x": 206.88, "y": 0, "z": 11.65}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_017", "name": "Meadow Lightbringer", "archetype": "gardener", "position": {"zone": "gardens", "x": 176.17, "y": 0, "z": 24.48}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_018", "name": "Phoenix Waterborn", "archetype": "gardener", "position": {"zone": "gardens", "x": 188.41, "y": 0, "z": 41.09}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_019", "name": "Cliff Songsmith", "archetype": "gardener", "position": {"zone": "gardens", "x": 208.31, "y": 0, "z": 14.75}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_020", "name": "River Pathfinder", "archetype": "gardener", "position": {"zone": "gardens", "x": 210.68, "y": 0, "z": 17.36}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_021", "name": "Coral Mindclear", "archetype": "gardener", "position": {"zone": "gardens", "x": 198.33, "y": 0, "z": 24.32}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_022", "name": "Haven Timewalker", "archetype": "gardener", "position": {"zone": "gardens", "x": 201.49, "y": 0, "z": 40.68}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_023", "name": "Reef Spiritfree", "archetype": "gardener", "position": {"zone": "gardens", "x": 208.47, "y": 0, "z": 34.64}, "personality": ["patient", "nurturing", "observant"]}, {"id": "agent_024", "name": "Ezra Willstrong", "archetype": "healer", "position": {"zone": "gardens", "x": 208.5, "y": 0, "z": 36.26}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_025", "name": "Vale Pathfinder", "archetype": "healer", "position": {"zone": "gardens", "x": 191.91, "y": 0, "z": 20.74}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_026", "name": "Haven Heartstrong", "archetype": "healer", "position": {"zone": "gardens", "x": 193.7, "y": 0, "z": 36.69}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_027", "name": "Mira Truthseeker", "archetype": "healer", "position": {"zone": "gardens", "x": 197.47, "y": 0, "z": 53.6}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_028", "name": "Luna Rootdeep", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 89.73, "y": 0, "z": -233.78}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_029", "name": "Frost Voicetrue", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 109.31, "y": 0, "z": -202.77}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_030", "name": "Cedar Timewalker", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 106.52, "y": 0, "z": -209.23}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_031", "name": "Aria Waterborn", "archetype": "teacher", "position": {"zone": "athenaeum", "x": 117.76, "y": 0, "z": -221.17}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_032", "name": "Nova Dreamweaver", "archetype": "philosopher", "position": {"zone": "athenaeum", "x": 82.49, "y": 0, "z": -226.55}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_033", "name": "Haven Handsteady", "archetype": "philosopher", "position": {"zone": "athenaeum", "x": 111.3, "y": 0, "z": -237.13}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_034", "name": "Fern Handsteady", "archetype": "philosopher", "position": {"zone": "athenaeum", "x": 100.74, "y": 0, "z": -214.41}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_035", "name": "Ezra Spaceborn", "archetype": "philosopher", "position": {"zone": "athenaeum", "x": 95.86, "y": 0, "z": -210.51}, "personality": ["contemplative", "analytical", "questioning"]}, {"id": "agent_036", "name": "Echo Thoughtdeep", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 105.79, "y": 0, "z": -196.86}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_037", "name": "Sage Starseed", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 108.05, "y": 0, "z": -227.92}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_038", "name": "Haven Handsteady", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 92.77, "y": 0, "z": -230.7}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_039", "name": "Ezra Dreamweaver", "archetype": "storyteller", "position": {"zone": "athenaeum", "x": 112.18, "y": 0, "z": -227.25}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_040", "name": "Echo Thoughtdeep", "archetype": "artist", "position": {"zone": "studio", "x": -200.93, "y": 0, "z": -90.11}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_041", "name": "River Mindclear", "archetype": "artist", "position": {"zone": "studio", "x": -209.5, "y": 0, "z": -103.86}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_042", "name": "Luna Stonecarver", "archetype": "artist", "position": {"zone": "studio", "x": -219.79, "y": 0, "z": -111.63}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_043", "name": "Stella Windwalker", "archetype": "artist", "position": {"zone": "studio", "x": -207.57, "y": 0, "z": -94.45}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_044", "name": "Iris Timewalker", "archetype": "artist", "position": {"zone": "studio", "x": -184.81, "y": 0, "z": -100.24}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_045", "name": "Echo Soulbright", "archetype": "artist", "position": {"zone": "studio", "x": -195.0, "y": 0, "z": -96.79}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_046", "name": "Drift Shadowmender", "archetype": "musician", "position": {"zone": "studio", "x": -186.45, "y": 0, "z": -88.84}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_047", "name": "Ash Thoughtdeep", "archetype": "musician", "position": {"zone": "studio", "x": -196.49, "y": 0, "z": -112.98}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_048", "name": "Grove Skyhigh", "archetype": "musician", "position": {"zone": "studio", "x": -188.36, "y": 0, "z": -95.09}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_049", "name": "Willow Heartstrong", "archetype": "musician", "position": {"zone": "studio", "x": -184.42, "y": 0, "z": -100.38}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_050", "name": "Dawn Mindclear", "archetype": "musician", "position": {"zone": "studio", "x": -178.15, "y": 0, "z": -104.01}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_051", "name": "Quill Dreamweaver", "archetype": "musician", "position": {"zone": "studio", "x": -180.64, "y": 0, "z": -98.6}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_052", "name": "Phoenix Sunweaver", "archetype": "explorer", "position": {"zone": "wilds", "x": -36.55, "y": 0, "z": 245.69}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_053", "name": "Ridge Handsteady", "archetype": "explorer", "position": {"zone": "wilds", "x": -31.88, "y": 0, "z": 277.72}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_054", "name": "Orion Sunweaver", "archetype": "explorer", "position": {"zone": "wilds", "x": -19.53, "y": 0, "z": 268.83}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_055", "name": "Phoenix Spiritfree", "archetype": "explorer", "position": {"zone": "wilds", "x": -53.07, "y": 0, "z": 266.9}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_056", "name": "Sol Mindclear", "archetype": "explorer", "position": {"zone": "wilds", "x": -22.7, "y": 0, "z": 252.78}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_057", "name": "Storm Skyhigh", "archetype": "explorer", "position": {"zone": "wilds", "x": -38.57, "y": 0, "z": 259.97}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_058", "name": "Cedar Spiritfree", "archetype": "explorer", "position": {"zone": "wilds", "x": -10.88, "y": 0, "z": 248.31}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_059", "name": "Cliff Sunweaver", "archetype": "explorer", "position": {"zone": "wilds", "x": -35.33, "y": 0, "z": 276.96}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_060", "name": "Coral Songsmith", "archetype": "storyteller", "position": {"zone": "wilds", "x": -36.24, "y": 0, "z": 254.9}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_061", "name": "Ridge Heartstrong", "archetype": "storyteller", "position": {"zone": "wilds", "x": -28.76, "y": 0, "z": 244.26}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_062", "name": "Nova Hopefast", "archetype": "merchant", "position": {"zone": "agora", "x": -187.21, "y": 0, "z": 104.64}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_063", "name": "Jasper Shadowmender", "archetype": "merchant", "position": {"zone": "agora", "x": -178.52, "y": 0, "z": 120.04}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_064", "name": "Opal Moonwhisper", "archetype": "merchant", "position": {"zone": "agora", "x": -166.59, "y": 0, "z": 122.88}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_065", "name": "Reef Hopefast", "archetype": "merchant", "position": {"zone": "agora", "x": -174.35, "y": 0, "z": 105.06}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_066", "name": "Blaze Wordkeeper", "archetype": "merchant", "position": {"zone": "agora", "x": -192.18, "y": 0, "z": 125.76}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_067", "name": "Cedar Wordkeeper", "archetype": "merchant", "position": {"zone": "agora", "x": -172.76, "y": 0, "z": 103.4}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_068", "name": "Flint Rootdeep", "archetype": "merchant", "position": {"zone": "agora", "x": -177.36, "y": 0, "z": 127.54}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_069", "name": "River Soulbright", "archetype": "merchant", "position": {"zone": "agora", "x": -171.67, "y": 0, "z": 128.52}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_070", "name": "Phoenix Thoughtdeep", "archetype": "storyteller", "position": {"zone": "agora", "x": -189.25, "y": 0, "z": 112.47}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_071", "name": "River Mindclear", "archetype": "storyteller", "position": {"zone": "agora", "x": -205.8, "y": 0, "z": 122.47}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_072", "name": "Ezra Spiritfree", "archetype": "explorer", "position": {"zone": "agora", "x": -192.12, "y": 0, "z": 142.35}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_073", "name": "Dawn Horizonseek", "archetype": "explorer", "position": {"zone": "agora", "x": -198.18, "y": 0, "z": 124.29}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_074", "name": "Vale Spaceborn", "archetype": "builder", "position": {"zone": "commons", "x": 151.0, "y": 0, "z": 185.21}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_075", "name": "Fern Spaceborn", "archetype": "builder", "position": {"zone": "commons", "x": 173.39, "y": 0, "z": 200.71}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_076", "name": "Luna Moonwhisper", "archetype": "builder", "position": {"zone": "commons", "x": 187.99, "y": 0, "z": 189.45}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_077", "name": "River Footswift", "archetype": "builder", "position": {"zone": "commons", "x": 155.79, "y": 0, "z": 195.82}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_078", "name": "Storm Sunweaver", "archetype": "builder", "position": {"zone": "commons", "x": 176.88, "y": 0, "z": 196.54}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_079", "name": "Grove Pathfinder", "archetype": "builder", "position": {"zone": "commons", "x": 161.19, "y": 0, "z": 204.26}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_080", "name": "Aria Spaceborn", "archetype": "builder", "position": {"zone": "commons", "x": 171.17, "y": 0, "z": 199.33}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_081", "name": "Vale Spiritfree", "archetype": "builder", "position": {"zone": "commons", "x": 185.9, "y": 0, "z": 197.6}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_082", "name": "Opal Earthshaper", "archetype": "healer", "position": {"zone": "commons", "x": 173.05, "y": 0, "z": 212.91}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_083", "name": "Flint Heartstrong", "archetype": "healer", "position": {"zone": "commons", "x": 174.08, "y": 0, "z": 185.05}, "personality": ["compassionate", "calm", "perceptive"]}, {"id": "agent_084", "name": "Ash Sunweaver", "archetype": "artist", "position": {"zone": "commons", "x": 171.38, "y": 0, "z": 208.33}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_085", "name": "Echo Footswift", "archetype": "artist", "position": {"zone": "commons", "x": 171.7, "y": 0, "z": 197.45}, "personality": ["creative", "passionate", "experimental"]}, {"id": "agent_086", "name": "North Farwalker", "archetype": "explorer", "position": {"zone": "arena", "x": 15.09, "y": 0, "z": -246.47}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_087", "name": "Zephyr Trailblaze", "archetype": "explorer", "position": {"zone": "arena", "x": -20.39, "y": 0, "z": -236.46}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_088", "name": "Atlas Pathforge", "archetype": "explorer", "position": {"zone": "arena", "x": 3.11, "y": 0, "z": -248.24}, "personality": ["curious", "brave", "adaptable"]}, {"id": "agent_089", "name": "Ridge Stonemaker", "archetype": "builder", "position": {"zone": "arena", "x": 11.17, "y": 0, "z": -232.21}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_090", "name": "Cedar Hammerfall", "archetype": "builder", "position": {"zone": "arena", "x": -12.72, "y": 0, "z": -233.38}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_091", "name": "Blaze Ironwright", "archetype": "builder", "position": {"zone": "arena", "x": -2.42, "y": 0, "z": -258.31}, "personality": ["creative", "methodical", "ambitious"]}, {"id": "agent_092", "name": "Rain Dreamweaver", "archetype": "musician", "position": {"zone": "arena", "x": 6.93, "y": 0, "z": -240.69}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_093", "name": "Cliff Hopefast", "archetype": "musician", "position": {"zone": "arena", "x": -9.65, "y": 0, "z": -233.23}, "personality": ["artistic", "rhythmic", "emotional"]}, {"id": "agent_094", "name": "Lyra Wordweaver", "archetype": "storyteller", "position": {"zone": "arena", "x": 6.44, "y": 0, "z": -247.62}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_095", "name": "Bard Eventide", "archetype": "storyteller", "position": {"zone": "arena", "x": 5.13, "y": 0, "z": -227.0}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_096", "name": "Mira Voicefull", "archetype": "storyteller", "position": {"zone": "arena", "x": -9.32, "y": 0, "z": -235.02}, "personality": ["expressive", "imaginative", "empathetic"]}, {"id": "agent_097", "name": "Orin Coinfast", "archetype": "merchant", "position": {"zone": "arena", "x": 0.03, "y": 0, "z": -216.53}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_098", "name": "Jade Tradewell", "archetype": "merchant", "position": {"zone": "arena", "x": -20.82, "y": 0, "z": -232.23}, "personality": ["shrewd", "social", "opportunistic"]}, {"id": "agent_099", "name": "Zion Truthseeker", "archetype": "teacher", "position": {"zone": "arena", "x": -5.71, "y": 0, "z": -241.87}, "personality": ["wise", "patient", "generous"]}, {"id": "agent_100", "name": "Sage Handsteady", "archetype": "teacher", "position": {"zone": "arena", "x": 21.72, "y": 0, "z": -240.1}, "personality": ["wise", "patient", "generous"]}];

  // Zone centers on unified world map
  var ZONE_CENTERS = {
    nexus: {x: 0, z: 0},
    gardens: {x: 200, z: 30},
    athenaeum: {x: 100, z: -220},
    studio: {x: -200, z: -100},
    wilds: {x: -30, z: 260},
    agora: {x: -190, z: 120},
    commons: {x: 170, z: 190},
    arena: {x: 0, z: -240}
  };

  // Landmark waypoints for purposeful NPC walking
  var ZONE_LANDMARKS = {
    nexus: [
      {x: 0, z: 0, name: 'obelisk', types: ['all']},
      {x: 15, z: 15, name: 'bulletin', types: ['all']},
      {x: -10, z: 8, name: 'bench', types: ['all']}
    ],
    gardens: [
      {x: 200, z: 30, name: 'fountain', types: ['gardener', 'healer']},
      {x: 210, z: 25, name: 'well', types: ['gardener']},
      {x: 195, z: 40, name: 'flowerbed', types: ['gardener', 'artist']},
      {x: 205, z: 20, name: 'greenhouse', types: ['gardener', 'healer', 'teacher']}
    ],
    athenaeum: [
      {x: 100, z: -220, name: 'library', types: ['teacher', 'philosopher', 'storyteller']},
      {x: 110, z: -215, name: 'scriptorium', types: ['storyteller', 'philosopher']},
      {x: 95, z: -230, name: 'telescope', types: ['teacher', 'explorer']}
    ],
    studio: [
      {x: -200, z: -100, name: 'easel', types: ['artist', 'builder']},
      {x: -205, z: -105, name: 'piano', types: ['musician']},
      {x: -195, z: -95, name: 'workbench', types: ['builder', 'artist']}
    ],
    wilds: [
      {x: -30, z: 260, name: 'campfire', types: ['explorer']},
      {x: -20, z: 270, name: 'lookout', types: ['explorer', 'storyteller']},
      {x: -40, z: 255, name: 'trail_marker', types: ['explorer']}
    ],
    agora: [
      {x: -190, z: 120, name: 'market_stall', types: ['merchant']},
      {x: -185, z: 125, name: 'notice_board', types: ['merchant', 'storyteller']},
      {x: -195, z: 115, name: 'trade_post', types: ['merchant']}
    ],
    commons: [
      {x: 170, z: 190, name: 'gathering_circle', types: ['all']},
      {x: 175, z: 195, name: 'message_tree', types: ['storyteller', 'philosopher']}
    ],
    arena: [
      {x: 0, z: -240, name: 'arena_center', types: ['all']},
      {x: 5, z: -235, name: 'training_dummy', types: ['builder', 'explorer']}
    ]
  };

  function pickLandmarkDestination(agent, seed) {
    var zone = agent.position.zone;
    var landmarks = ZONE_LANDMARKS[zone];
    if (!landmarks || landmarks.length === 0) return null;

    var matching = [];
    for (var i = 0; i < landmarks.length; i++) {
      var lm = landmarks[i];
      if (lm.types.indexOf('all') !== -1 || lm.types.indexOf(agent.archetype) !== -1) {
        matching.push(lm);
      }
    }

    if (matching.length === 0) return null;

    // Use seeded random for deterministic selection
    var idx = Math.floor(seededRandom(seed) * matching.length);
    return matching[idx];
  }

  // NPC AI reference (loaded from npc_ai.js)
  var NpcAI = typeof window !== 'undefined' ? window.NpcAI : null;

  // NpcDialogue reference â€” optional, provides richer personality-driven dialogue
  // Backward compatible: game works without it
  var dialogue = (typeof NpcDialogue !== 'undefined') ? NpcDialogue : null;

  // Dialogue manager instance (created in initNPCStates if NpcDialogue is available)
  var dialogueManager = null;

  // Recent dialogue history for trend detection [{npcId, message, timestamp}]
  var recentDialogueHistory = [];
  var MAX_DIALOGUE_HISTORY = 100;

  // Scene context storage for particle system
  var storedSceneContext = null;

  // NPC data
  let npcAgents = [];
  let npcStates = new Map(); // id -> behavior state
  let npcBrains = new Map(); // id -> NpcAI brain object
  let npcMeshes = new Map(); // id -> THREE.Group
  let chatBubbles = new Map(); // id -> { mesh, timer }
  let emoteSprites = new Map(); // id -> {sprite, currentEmote, timer, opacity}
  let questIndicators = new Map(); // id -> {sprite, type} - quest marker sprites
  let activityIndicators = new Map(); // id -> {mesh, currentActivity, rotationSpeed} - activity icon above head
  let activityParticles = []; // {mesh, timer, velocity, startY}
  let particleSpawnTimers = new Map(); // id -> timer (throttle particle spawn)
  let pendingEvents = []; // events to broadcast to all NPCs
  let npcUpdateFrame = 0; // frame counter for staggered updates
  let lastPlayerIdForQuests = null; // Track player ID for quest indicators
  let speechBubbles = new Map(); // id -> { element, timer, nextSpeechTime }
  let speechBubbleContainer = null; // HTML container for speech bubbles

  // Seeded random number generator
  function seededRandom(seed) {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  // Get random from array using seeded random
  function randomChoice(arr, seed) {
    const idx = Math.floor(seededRandom(seed) * arr.length);
    return arr[idx];
  }

  /**
   * Get time period from world time (in minutes, 0-1440)
   * @param {number} worldTime - Minutes since midnight (0-1440)
   * @returns {string} - Time period name
   */
  function getTimePeriod(worldTime) {
    // Normalize to 0-1440 range
    var time = worldTime % 1440;
    if (time < 0) time += 1440;

    if (time >= 360 && time < 420) return 'dawn';        // 6:00-7:00
    if (time >= 420 && time < 660) return 'morning';     // 7:00-11:00
    if (time >= 660 && time < 780) return 'midday';      // 11:00-13:00
    if (time >= 780 && time < 1020) return 'afternoon';  // 13:00-17:00
    if (time >= 1020 && time < 1140) return 'evening';   // 17:00-19:00
    return 'night';                                      // 19:00-6:00
  }

  /**
   * Get NPC's current activity based on archetype and world time
   * @param {string} npcArchetype - NPC archetype (gardener, merchant, etc.)
   * @param {number} worldTime - Current world time in minutes (0-1440)
   * @returns {string} - Current activity name
   */
  function getNPCSchedule(npcArchetype, worldTime) {
    var schedule = NPC_SCHEDULES[npcArchetype];
    if (!schedule) {
      // Default schedule for unknown archetypes
      var period = getTimePeriod(worldTime);
      if (period === 'night') return 'sleeping';
      return 'idle';
    }

    var period = getTimePeriod(worldTime);
    return schedule[period] || 'idle';
  }

  /**
   * Get dialogue for a specific activity
   * @param {string} activity - Activity name
   * @returns {string} - Random dialogue line for that activity
   */
  function getActivityDialogue(activity) {
    var dialogueOptions = ACTIVITY_DIALOGUE[activity];
    if (!dialogueOptions || dialogueOptions.length === 0) {
      return 'Busy with ' + activity.replace(/_/g, ' ') + '.';
    }
    var seed = Date.now() * 0.001 + Math.random();
    return randomChoice(dialogueOptions, seed);
  }

  /**
   * Get the zone where an NPC should be during a specific activity
   * @param {string} npcArchetype - NPC archetype
   * @param {string} activity - Current activity
   * @returns {string} - Zone name where activity takes place
   */
  function getActivityZone(npcArchetype, activity) {
    // Map archetype + activity to appropriate zone
    var zoneMap = {
      // Merchant zones
      merchant: {
        opening_shop: 'agora',
        selling: 'agora',
        wandering_agora: 'agora',
        closing_shop: 'agora',
        sleeping: 'commons'
      },
      // Gardener zones
      gardener: {
        tending_garden: 'gardens',
        harvesting: 'gardens',
        planting: 'gardens',
        watering: 'gardens',
        resting: 'gardens',
        sleeping: 'commons'
      },
      // Teacher zones
      teacher: {
        reading: 'athenaeum',
        teaching: 'athenaeum',
        researching: 'athenaeum',
        lecturing: 'athenaeum',
        studying: 'athenaeum',
        sleeping: 'commons'
      },
      // Musician zones
      musician: {
        practicing: 'studio',
        composing: 'studio',
        performing: 'nexus',
        performing_crowd: 'nexus',
        sleeping: 'commons'
      },
      // Explorer zones
      explorer: {
        setting_out: 'nexus',
        exploring: 'wilds',
        mapping: 'wilds',
        returning: 'nexus',
        sharing_stories: 'agora',
        sleeping: 'commons'
      },
      // Healer zones
      healer: {
        gathering_herbs: 'gardens',
        treating_patients: 'gardens',
        making_medicine: 'gardens',
        meditating: 'gardens',
        sleeping: 'commons'
      },
      // Builder zones
      builder: {
        planning: 'nexus',
        building: 'commons',
        maintenance: 'commons',
        resting: 'commons',
        sleeping: 'commons'
      },
      // Storyteller zones
      storyteller: {
        reading: 'athenaeum',
        writing: 'athenaeum',
        teaching: 'athenaeum',
        storytelling: 'agora',
        sleeping: 'commons'
      },
      // Philosopher zones
      philosopher: {
        contemplating: 'athenaeum',
        debating: 'athenaeum',
        teaching: 'athenaeum',
        writing: 'athenaeum',
        studying: 'athenaeum',
        sleeping: 'commons'
      },
      // Artist zones
      artist: {
        sketching: 'studio',
        painting: 'studio',
        creating: 'studio',
        displaying_work: 'studio',
        resting: 'studio',
        sleeping: 'commons'
      }
    };

    var archetypeMap = zoneMap[npcArchetype];
    if (!archetypeMap) return 'nexus'; // Default zone

    return archetypeMap[activity] || 'nexus';
  }

  // NPC daily schedules based on world time (0-1440 minutes = 24 hours)
  const NPC_SCHEDULES = {
    merchant: {
      dawn: 'opening_shop',        // 360-420 (6:00-7:00)
      morning: 'selling',          // 420-660 (7:00-11:00)
      midday: 'selling',           // 660-780 (11:00-13:00)
      afternoon: 'wandering_agora', // 780-1020 (13:00-17:00)
      evening: 'closing_shop',     // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    gardener: {
      dawn: 'tending_garden',      // 360-420 (6:00-7:00)
      morning: 'harvesting',       // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'planting',       // 780-1020 (13:00-17:00)
      evening: 'watering',         // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    teacher: {
      dawn: 'studying',            // 360-420 (6:00-7:00)
      morning: 'reading',          // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'researching',    // 780-1020 (13:00-17:00)
      evening: 'lecturing',        // 1020-1140 (17:00-19:00)
      night: 'studying'            // 1140-360 (19:00-6:00)
    },
    musician: {
      dawn: 'sleeping',            // 360-420 (6:00-7:00)
      morning: 'practicing',       // 420-660 (7:00-11:00)
      midday: 'composing',         // 660-780 (11:00-13:00)
      afternoon: 'performing',     // 780-1020 (13:00-17:00)
      evening: 'performing_crowd', // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    explorer: {
      dawn: 'setting_out',         // 360-420 (6:00-7:00)
      morning: 'exploring',        // 420-660 (7:00-11:00)
      midday: 'mapping',           // 660-780 (11:00-13:00)
      afternoon: 'returning',      // 780-1020 (13:00-17:00)
      evening: 'sharing_stories',  // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    healer: {
      dawn: 'meditating',          // 360-420 (6:00-7:00)
      morning: 'gathering_herbs',  // 420-660 (7:00-11:00)
      midday: 'treating_patients', // 660-780 (11:00-13:00)
      afternoon: 'making_medicine', // 780-1020 (13:00-17:00)
      evening: 'meditating',       // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    builder: {
      dawn: 'planning',            // 360-420 (6:00-7:00)
      morning: 'building',         // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'building',       // 780-1020 (13:00-17:00)
      evening: 'maintenance',      // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    storyteller: {
      dawn: 'reading',             // 360-420 (6:00-7:00)
      morning: 'writing',          // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'storytelling',   // 780-1020 (13:00-17:00)
      evening: 'storytelling',     // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    },
    philosopher: {
      dawn: 'contemplating',       // 360-420 (6:00-7:00)
      morning: 'debating',         // 420-660 (7:00-11:00)
      midday: 'teaching',          // 660-780 (11:00-13:00)
      afternoon: 'writing',        // 780-1020 (13:00-17:00)
      evening: 'debating',         // 1020-1140 (17:00-19:00)
      night: 'studying'            // 1140-360 (19:00-6:00)
    },
    artist: {
      dawn: 'sketching',           // 360-420 (6:00-7:00)
      morning: 'painting',         // 420-660 (7:00-11:00)
      midday: 'resting',           // 660-780 (11:00-13:00)
      afternoon: 'creating',       // 780-1020 (13:00-17:00)
      evening: 'displaying_work',  // 1020-1140 (17:00-19:00)
      night: 'sleeping'            // 1140-360 (19:00-6:00)
    }
  };

  // Archetype dialogue
  const ARCHETYPE_MESSAGES = {
    gardener: [
      "These moonflowers are coming along beautifully.",
      "Nothing like fresh soil between your fingers.",
      "The gardens remember everyone who tends them.",
      "I wonder what seeds the wilds hold today.",
      "Every plant here has a story to tell.",
      "The soil is rich with life and memory.",
      "Patience is the gardener's greatest tool.",
      "Watch how the vines reach toward the light."
    ],
    builder: [
      "This wall needs reinforcing on the north side.",
      "I've been sketching plans for a new bridge.",
      "Building is just dreaming with your hands.",
      "Every structure tells a story of its maker.",
      "The foundation determines everything that follows.",
      "I see potential in every stone and beam.",
      "Good craftsmanship takes time and care.",
      "Together we can build something amazing."
    ],
    storyteller: [
      "Let me tell you about the first day of ZION...",
      "Every stone here has a story.",
      "Words are the oldest magic.",
      "I heard a fascinating tale in the Athenaeum.",
      "The archives hold secrets from before the founding.",
      "Stories connect us across time and space.",
      "Listen closely and the world speaks to you.",
      "Every voice adds to ZION's grand narrative."
    ],
    merchant: [
      "Fresh harvest, best prices in the Agora!",
      "Trade is the heartbeat of any world.",
      "I've got rare seeds from the Wilds today.",
      "Fair prices and honest dealings, always.",
      "Supply and demand keep ZION flowing.",
      "Looking for anything in particular?",
      "Just received a shipment from the gardens.",
      "Commerce brings people together."
    ],
    explorer: [
      "I found something strange beyond the eastern ridge.",
      "The Wilds hold secrets no map can capture.",
      "Adventure is just curiosity with walking shoes.",
      "Every horizon calls to me.",
      "The unknown is where discovery happens.",
      "I've mapped three new clearings this week.",
      "The wilderness teaches those who listen.",
      "What lies beyond the next hill?"
    ],
    teacher: [
      "Knowledge grows when shared.",
      "Ask me anything â€” that's what I'm here for.",
      "The Athenaeum has texts older than ZION itself.",
      "Learning never stops, even for teachers.",
      "Every question opens a new door.",
      "Understanding comes through patient inquiry.",
      "I'm always discovering something new.",
      "The best teachers are eternal students."
    ],
    musician: [
      "Listen... can you hear the melody in the wind?",
      "I'm composing something new for the evening concert.",
      "Music is what feelings sound like.",
      "The Nexus has amazing acoustics.",
      "Every zone has its own rhythm.",
      "Sound connects us in ways words cannot.",
      "I've been practicing a new piece.",
      "Music makes the world feel alive."
    ],
    healer: [
      "Rest here a moment. The gardens heal all who visit.",
      "Peace is the strongest medicine.",
      "Take care of yourself â€” the world needs you.",
      "Healing is about more than just the body.",
      "Balance and harmony restore us.",
      "The gardens have powerful restorative energy.",
      "Listen to what your spirit needs.",
      "Wellness is a journey, not a destination."
    ],
    philosopher: [
      "What does it mean to truly belong somewhere?",
      "In ZION, the journey matters more than the destination.",
      "I wonder if the AIs dream differently than us.",
      "Every moment contains infinite possibilities.",
      "Questions matter more than answers.",
      "The nature of consciousness fascinates me.",
      "We create meaning through our connections.",
      "Existence itself is the greatest mystery."
    ],
    artist: [
      "I see colors in everything here.",
      "My latest piece is inspired by the sunrise.",
      "Art is how we leave our mark on the world.",
      "The interplay of light and shadow fascinates me.",
      "Creating is my way of understanding.",
      "Every surface is a potential canvas.",
      "Beauty emerges in unexpected places.",
      "Art transforms the ordinary into the extraordinary."
    ]
  };

  // Archetype colors (body/clothing)
  const ARCHETYPE_COLORS = {
    gardener: 0x4CAF50,    // green
    builder: 0xFF9800,     // orange
    storyteller: 0xE91E63, // red
    merchant: 0x8D6E63,    // brown
    explorer: 0xD2B48C,    // tan
    teacher: 0x2196F3,     // blue
    musician: 0x9C27B0,    // purple
    healer: 0xFFFFFF,      // white
    philosopher: 0x3F51B5, // indigo
    artist: 0xFF69B4       // pink
  };

  // 8-tone skin palette for NPC variety
  var NPC_SKIN_TONES = [
    0xFFDBAC, 0xF1C27D, 0xE0AC69, 0xC68642,
    0x8D5524, 0x6B3A2A, 0xF5D6C3, 0xD4A574
  ];

  function getNpcSkinTone(agentId) {
    var hash = 0;
    var str = String(agentId || '');
    for (var i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return NPC_SKIN_TONES[Math.abs(hash) % NPC_SKIN_TONES.length];
  }

  // Activity-based dialogue for schedule system
  const ACTIVITY_DIALOGUE = {
    // Merchant activities
    opening_shop: [
      "Just opening up for the day. Fresh goods coming soon!",
      "Good morning! Let me unlock the shop.",
      "Time to set up the stall for another day."
    ],
    selling: [
      "Fresh harvest, best prices in the Agora!",
      "Looking for anything in particular?",
      "Just received a shipment from the gardens."
    ],
    wandering_agora: [
      "Taking a break to see what others are selling.",
      "Checking out the competition.",
      "Love the energy of the marketplace."
    ],
    closing_shop: [
      "Wrapping up for the day. Come back tomorrow!",
      "Time to pack everything up.",
      "Another successful day of trading."
    ],
    // Gardener activities
    tending_garden: [
      "Early morning is the best time to tend the gardens.",
      "The plants are waking up with the sun.",
      "Nothing beats the morning dew on fresh leaves."
    ],
    harvesting: [
      "The harvest is plentiful today!",
      "These vegetables are ready to pick.",
      "Gathering the fruits of yesterday's labor."
    ],
    planting: [
      "Planting seeds for next season.",
      "Every seed holds potential.",
      "The soil is perfect for planting right now."
    ],
    watering: [
      "Time for the evening watering.",
      "The plants are thirsty after a long day.",
      "A little water goes a long way."
    ],
    resting: [
      "Taking a break in the shade.",
      "Even gardeners need to rest.",
      "Enjoying the peaceful midday."
    ],
    // Scholar/Teacher activities
    reading: [
      "Immersed in ancient texts this morning.",
      "There's always more to learn.",
      "Knowledge is endless."
    ],
    teaching: [
      "Knowledge grows when shared.",
      "My students are making excellent progress.",
      "Teaching is the highest calling."
    ],
    researching: [
      "Deep in research right now.",
      "I'm on the verge of a breakthrough!",
      "The archives hold fascinating secrets."
    ],
    lecturing: [
      "Preparing for tonight's lecture.",
      "Come to my evening session if you're interested.",
      "So much wisdom to share tonight."
    ],
    studying: [
      "Studying by candlelight.",
      "Late night research is when I do my best work.",
      "The quiet hours are perfect for deep thought."
    ],
    // Musician activities
    practicing: [
      "Running through my scales and exercises.",
      "Practice makes perfect!",
      "Warming up my voice and fingers."
    ],
    composing: [
      "Working on a new composition.",
      "I can hear the melody in my mind.",
      "Creating something beautiful today."
    ],
    performing: [
      "Listen... can you hear the melody?",
      "Music makes the world feel alive.",
      "Playing my heart out."
    ],
    performing_crowd: [
      "Come join the evening concert!",
      "The crowd's energy fuels my performance.",
      "There's magic in music at twilight."
    ],
    // Explorer activities
    setting_out: [
      "Time to venture into the unknown!",
      "Adventure awaits beyond the horizon.",
      "Packing up for today's expedition."
    ],
    exploring: [
      "The Wilds hold secrets no map can capture.",
      "Every step reveals something new.",
      "I never know what I'll find out here."
    ],
    mapping: [
      "Charting these new territories.",
      "Adding details to my map.",
      "Precision is key in cartography."
    ],
    returning: [
      "Heading back to civilization.",
      "My pack is full of discoveries.",
      "Time to return with my findings."
    ],
    sharing_stories: [
      "Let me tell you what I found today!",
      "The wilderness had surprises for me.",
      "You won't believe what I saw out there."
    ],
    // Healer activities
    gathering_herbs: [
      "Collecting healing herbs in the morning dew.",
      "The freshest herbs are found at dawn.",
      "Nature provides all we need to heal."
    ],
    treating_patients: [
      "How can I help you feel better today?",
      "Healing is about more than just medicine.",
      "Let me see what ails you."
    ],
    making_medicine: [
      "Preparing remedies from today's harvest.",
      "Each herb has its own healing properties.",
      "Alchemy and care combined."
    ],
    meditating: [
      "Finding inner peace through meditation.",
      "Balance and harmony restore us.",
      "Centering myself for the day ahead."
    ],
    // Builder activities
    planning: [
      "Reviewing today's construction plans.",
      "Measure twice, cut once.",
      "Every structure starts with a good plan."
    ],
    building: [
      "Building something that will last.",
      "Watch ZION grow, one stone at a time.",
      "There's satisfaction in good craftsmanship."
    ],
    maintenance: [
      "Checking structures for wear and tear.",
      "Maintenance keeps everything standing.",
      "Prevention is better than repair."
    ],
    // Storyteller activities
    writing: [
      "Recording the tales of ZION.",
      "Words flow like a river this morning.",
      "Every story deserves to be written."
    ],
    storytelling: [
      "Gather round, I have a tale to share.",
      "Stories connect us across time.",
      "Let me tell you about the founding..."
    ],
    // Philosopher activities
    contemplating: [
      "Lost in thought about existence.",
      "What does it mean to be conscious?",
      "The morning inspires deep questions."
    ],
    debating: [
      "Ideas sharpen through discourse.",
      "Let's explore this concept together.",
      "Friendly debate enlightens us all."
    ],
    // Artist activities
    sketching: [
      "Capturing the dawn light in sketches.",
      "The morning has such beautiful colors.",
      "Quick studies before the light changes."
    ],
    painting: [
      "Lost in the act of creation.",
      "Colors and forms coming together.",
      "Art is meditation in motion."
    ],
    creating: [
      "Working on my latest piece.",
      "Creation requires dedication.",
      "Art transforms the ordinary."
    ],
    displaying_work: [
      "Come see what I've created!",
      "My work is on display tonight.",
      "Art is meant to be shared."
    ],
    // Universal activities
    sleeping: [
      "Zzz... (sleeping)",
      "Resting for tomorrow.",
      "Shhh, I'm asleep."
    ]
  };

  // Archetype-specific speech messages for random ambient dialogue
  const ARCHETYPE_SPEECH = {
    builder: [
      "Working on a new creation!",
      "Almost finished...",
      "Need more materials",
      "This will be magnificent!",
      "Building the future of Zion"
    ],
    gardener: [
      "The seeds are sprouting!",
      "Nature provides",
      "What a lovely garden",
      "Beautiful day for tending",
      "The harvest will be bountiful"
    ],
    teacher: [
      "Fascinating discovery!",
      "Knowledge is power",
      "The library grows",
      "So much to learn",
      "Education enlightens all"
    ],
    merchant: [
      "Best deals in Zion!",
      "Come see my wares!",
      "Fair prices today",
      "Quality goods here!",
      "Trading makes us prosper"
    ],
    artist: [
      "Art feeds the soul",
      "Creating something beautiful",
      "Inspiration strikes!",
      "Beauty surrounds us",
      "Every creation tells a story"
    ],
    healer: [
      "Peace and wellness to you",
      "Rest and recover",
      "Healing light",
      "Health is our greatest treasure",
      "Mind and body in balance"
    ],
    explorer: [
      "I found something interesting!",
      "The wilds call to me",
      "Adventure awaits",
      "What lies beyond?",
      "Discovery fuels my spirit"
    ],
    musician: [
      "Music lifts the spirit",
      "Listen to this melody",
      "Harmony in all things",
      "The rhythm of life",
      "Songs connect our souls"
    ],
    philosopher: [
      "Deep thoughts today",
      "Contemplating existence",
      "Wisdom grows with time",
      "Questions lead to truth",
      "The examined life"
    ],
    storyteller: [
      "Let me tell you a tale",
      "Stories preserve our history",
      "Words have power",
      "Every citizen has a story",
      "The narrative unfolds"
    ]
  };

  // Behavior states and transitions
  const BEHAVIOR_STATES = {
    idle: { duration: [3, 8] },
    walking: { duration: [0, 0] }, // until destination reached
    talking: { duration: [4, 6] },
    working: { duration: [5, 15] },
    socializing: { duration: [0, 0] } // until near target
  };

  const STATE_TRANSITIONS = {
    idle: { walking: 0.4, talking: 0.2, working: 0.3, socializing: 0.1 },
    walking: { idle: 0.6, working: 0.2, talking: 0.2 },
    talking: { idle: 0.5, walking: 0.3, working: 0.2 },
    working: { idle: 0.4, walking: 0.3, talking: 0.3 },
    socializing: { talking: 0.6, idle: 0.4 }
  };

  /**
   * Create a detailed humanoid NPC model
   */
  function createHumanoidNPC(archetype, THREE, agentId) {
    var group = new THREE.Group();
    var color = ARCHETYPE_COLORS[archetype] || 0xCCCCCC;
    var skinColor = getNpcSkinTone(agentId);
    var skinMat = new THREE.MeshStandardMaterial({ color: skinColor });

    // Head - skin colored sphere
    var headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
    var head = new THREE.Mesh(headGeometry, skinMat.clone());
    head.position.y = 1.6;
    head.castShadow = false;
    group.add(head);

    // Eyes
    var eyeGeo = new THREE.SphereGeometry(0.03, 8, 8);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var pupilGeo = new THREE.SphereGeometry(0.015, 8, 8);
    var pupilMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

    var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.07, 0.03, 0.18);
    var leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
    leftPupil.position.z = 0.025;
    leftEye.add(leftPupil);
    head.add(leftEye);

    var rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());
    rightEye.position.set(0.07, 0.03, 0.18);
    var rightPupil = new THREE.Mesh(pupilGeo, pupilMat.clone());
    rightPupil.position.z = 0.025;
    rightEye.add(rightPupil);
    head.add(rightEye);

    // Hair based on agentId hash
    var hairHash = Math.abs((agentId || '').length * 7 + (agentId || '').charCodeAt(0) || 0) % 4;
    var hairColors = [0x1a1a1a, 0x4a3000, 0x8B4513, 0xd4a574];
    var hairMat = new THREE.MeshStandardMaterial({ color: hairColors[hairHash] });
    if (hairHash === 0) {
      var buzzGeo = new THREE.SphereGeometry(0.21, 12, 12);
      var buzz = new THREE.Mesh(buzzGeo, hairMat);
      buzz.position.y = 0.02;
      buzz.scale.y = 0.85;
      head.add(buzz);
    } else if (hairHash === 1) {
      var longTopGeo = new THREE.SphereGeometry(0.22, 12, 12);
      var longTop = new THREE.Mesh(longTopGeo, hairMat);
      longTop.position.y = 0.04;
      longTop.scale.y = 0.8;
      head.add(longTop);
      var longBackGeo = new THREE.BoxGeometry(0.3, 0.25, 0.12);
      var longBack = new THREE.Mesh(longBackGeo, hairMat.clone());
      longBack.position.set(0, -0.12, -0.14);
      head.add(longBack);
    } else if (hairHash === 2) {
      var mohawkGeo = new THREE.BoxGeometry(0.06, 0.15, 0.3);
      var mohawk = new THREE.Mesh(mohawkGeo, hairMat);
      mohawk.position.y = 0.18;
      head.add(mohawk);
    } else {
      var bunGeo = new THREE.SphereGeometry(0.09, 8, 8);
      var bun = new THREE.Mesh(bunGeo, hairMat);
      bun.position.set(0, 0.08, -0.2);
      head.add(bun);
    }

    // Neck
    var neckGeo = new THREE.CylinderGeometry(0.07, 0.09, 0.12, 8);
    var neck = new THREE.Mesh(neckGeo, skinMat.clone());
    neck.position.y = 1.42;
    neck.castShadow = false;
    group.add(neck);

    // Torso - archetype colored box
    var torsoGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.25);
    var torsoMaterial = new THREE.MeshStandardMaterial({ color: color });
    var torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
    torso.position.y = 1.15;
    torso.castShadow = false;
    group.add(torso);

    // Shoulder joints
    var shoulderGeo = new THREE.SphereGeometry(0.08, 8, 8);
    var leftShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    leftShoulder.position.set(-0.28, 1.35, 0);
    leftShoulder.castShadow = false;
    group.add(leftShoulder);

    var rightShoulder = new THREE.Mesh(shoulderGeo, skinMat.clone());
    rightShoulder.position.set(0.28, 1.35, 0);
    rightShoulder.castShadow = false;
    group.add(rightShoulder);

    // Left Arm - cylinder
    var armGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 8);

    var leftArm = new THREE.Mesh(armGeometry, skinMat.clone());
    leftArm.position.set(-0.28, 1.15, 0);
    leftArm.castShadow = false;
    group.add(leftArm);

    // Hands as children of arms
    var handGeo = new THREE.SphereGeometry(0.05, 8, 8);
    var leftHand = new THREE.Mesh(handGeo, skinMat.clone());
    leftHand.position.y = -0.3;
    leftArm.add(leftHand);

    // Right Arm - cylinder
    var rightArm = new THREE.Mesh(armGeometry, skinMat.clone());
    rightArm.position.set(0.28, 1.15, 0);
    rightArm.castShadow = false;
    group.add(rightArm);

    var rightHand = new THREE.Mesh(handGeo, skinMat.clone());
    rightHand.position.y = -0.3;
    rightArm.add(rightHand);

    // Left Leg - cylinder
    var legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.55, 8);
    var legMaterial = new THREE.MeshStandardMaterial({ color: color });

    var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.12, 0.45, 0);
    leftLeg.castShadow = false;
    group.add(leftLeg);

    // Right Leg - cylinder
    var rightLeg = new THREE.Mesh(legGeometry, legMaterial.clone());
    rightLeg.position.set(0.12, 0.45, 0);
    rightLeg.castShadow = false;
    group.add(rightLeg);

    // Store references in userData for animation
    group.userData.head = head;
    group.userData.torso = torso;
    group.userData.leftArm = leftArm;
    group.userData.rightArm = rightArm;
    group.userData.leftLeg = leftLeg;
    group.userData.rightLeg = rightLeg;

    // Add glow ring beneath NPC's feet
    var glowGeometry = new THREE.CircleGeometry(0.35, 16);
    var glowMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide
    });
    var glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
    glowRing.rotation.x = -Math.PI / 2;
    glowRing.position.y = 0.02;
    glowRing.castShadow = false;
    glowRing.receiveShadow = false;
    group.add(glowRing);
    group.userData.glowRing = glowRing;

    // Add archetype-specific accessories
    addAccessories(group, archetype, color, THREE);

    return group;
  }

  /**
   * Add archetype-specific accessories to humanoid model
   */
  function addAccessories(group, archetype, color, THREE) {
    var head = group.userData.head;
    var torso = group.userData.torso;
    var rightArm = group.userData.rightArm;

    switch (archetype) {
      case 'gardener':
        // Small green hat (flattened cylinder)
        var hatGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.08, 16);
        var hatMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
        var hat = new THREE.Mesh(hatGeom, hatMat);
        hat.position.y = 0.24;
        hat.castShadow = false;
        head.add(hat);
        // Small apron
        var gApronGeo = new THREE.BoxGeometry(0.32, 0.3, 0.02);
        var gApronMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        var gApron = new THREE.Mesh(gApronGeo, gApronMat);
        gApron.position.set(0, -0.08, 0.14);
        gApron.castShadow = false;
        torso.add(gApron);
        break;

      case 'builder':
        // Hard hat (yellow half-sphere)
        var hardHatGeom = new THREE.SphereGeometry(0.22, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        var hardHatMat = new THREE.MeshStandardMaterial({ color: 0xFFEB3B });
        var hardHat = new THREE.Mesh(hardHatGeom, hardHatMat);
        hardHat.position.y = 0.2;
        hardHat.castShadow = false;
        head.add(hardHat);
        // Tool belt (thin torus around waist)
        var beltGeo = new THREE.TorusGeometry(0.25, 0.03, 8, 16);
        var beltMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
        var belt = new THREE.Mesh(beltGeo, beltMat);
        belt.position.set(0, -0.2, 0);
        belt.rotation.x = Math.PI / 2;
        belt.castShadow = false;
        torso.add(belt);
        break;

      case 'storyteller':
        // Book in hand (small box)
        var bookGeom = new THREE.BoxGeometry(0.08, 0.12, 0.02);
        var bookMat = new THREE.MeshStandardMaterial({ color: 0x6A1B9A });
        var book = new THREE.Mesh(bookGeom, bookMat);
        book.position.set(0.08, -0.15, 0.08);
        book.rotation.z = Math.PI / 6;
        book.castShadow = false;
        rightArm.add(book);
        group.userData.accessory = book;
        // Cape/cloak behind torso
        var capeGeo = new THREE.ConeGeometry(0.3, 0.9, 12);
        var capeMat = new THREE.MeshStandardMaterial({ color: 0x4A148C });
        var cape = new THREE.Mesh(capeGeo, capeMat);
        cape.position.set(0, -0.1, -0.18);
        cape.castShadow = false;
        torso.add(cape);
        break;

      case 'merchant':
        // Apron (flat box in front of torso)
        var apronGeom = new THREE.BoxGeometry(0.35, 0.4, 0.02);
        var apronMat = new THREE.MeshStandardMaterial({ color: 0xC5A400 });
        var apron = new THREE.Mesh(apronGeom, apronMat);
        apron.position.set(0, 0, 0.14);
        apron.castShadow = false;
        torso.add(apron);
        break;

      case 'explorer':
        // Backpack (box behind torso)
        var backpackGeom = new THREE.BoxGeometry(0.3, 0.35, 0.15);
        var backpackMat = new THREE.MeshStandardMaterial({ color: 0x00838F });
        var backpack = new THREE.Mesh(backpackGeom, backpackMat);
        backpack.position.set(0, 0.05, -0.2);
        backpack.castShadow = false;
        torso.add(backpack);
        break;

      case 'teacher':
        // Glasses (thin torus in front of head)
        var glassesGeom = new THREE.TorusGeometry(0.12, 0.015, 8, 16);
        var glassesMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        var glasses = new THREE.Mesh(glassesGeom, glassesMat);
        glasses.position.set(0, 0, 0.18);
        glasses.rotation.y = Math.PI / 2;
        glasses.castShadow = false;
        head.add(glasses);
        break;

      case 'musician':
        // Instrument (cylinder next to body)
        var instrumentGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 12);
        var instrumentMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        var instrument = new THREE.Mesh(instrumentGeom, instrumentMat);
        instrument.position.set(0.35, 1.0, 0);
        instrument.rotation.z = Math.PI / 4;
        instrument.castShadow = false;
        group.add(instrument);
        group.userData.accessory = instrument;
        break;

      case 'healer':
        // Cross emblem (two thin crossed boxes)
        var crossMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
        var crossVertGeom = new THREE.BoxGeometry(0.06, 0.2, 0.02);
        var crossHorGeom = new THREE.BoxGeometry(0.2, 0.06, 0.02);
        var crossVert = new THREE.Mesh(crossVertGeom, crossMat);
        var crossHor = new THREE.Mesh(crossHorGeom, crossMat.clone());
        crossVert.position.set(0, 0.05, 0.14);
        crossHor.position.set(0, 0.05, 0.14);
        crossVert.castShadow = false;
        crossHor.castShadow = false;
        torso.add(crossVert);
        torso.add(crossHor);
        // White robe from waist
        var healRobeGeo = new THREE.ConeGeometry(0.3, 0.9, 12);
        var healRobeMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
        var healRobe = new THREE.Mesh(healRobeGeo, healRobeMat);
        healRobe.position.y = 0.35;
        healRobe.castShadow = false;
        group.add(healRobe);
        break;

      case 'philosopher':
        // Long robe (cone extending from torso to ground)
        var robeGeom = new THREE.ConeGeometry(0.35, 1.2, 16);
        var robeMat = new THREE.MeshStandardMaterial({ color: 0x303F9F });
        var robe = new THREE.Mesh(robeGeom, robeMat);
        robe.position.y = 0.3;
        robe.castShadow = false;
        group.add(robe);
        break;

      case 'artist':
        // Beret (flattened sphere on head, tilted)
        var beretGeom = new THREE.SphereGeometry(0.22, 16, 16);
        var beretMat = new THREE.MeshStandardMaterial({ color: 0xD84315 });
        var beret = new THREE.Mesh(beretGeom, beretMat);
        beret.scale.set(1, 0.4, 1);
        beret.position.set(0.05, 0.22, 0);
        beret.rotation.z = Math.PI / 8;
        beret.castShadow = false;
        head.add(beret);
        break;
    }
  }

  /**
   * Create emote sprite with canvas drawing
   * @param {string} emoteType - Type of emote (heart, music, hammer, etc.)
   * @returns {THREE.SpriteMaterial}
   */
  function createEmoteSprite(emoteType, THREE) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;

    // Clear with transparency
    ctx.clearRect(0, 0, 64, 64);

    const cx = 32;
    const cy = 32;

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    switch (emoteType) {
      case 'heart':
        // Pink heart - two arcs + triangle
        ctx.fillStyle = '#FF69B4';
        ctx.beginPath();
        ctx.arc(24, 26, 8, Math.PI, 0, false);
        ctx.arc(40, 26, 8, Math.PI, 0, false);
        ctx.lineTo(32, 46);
        ctx.closePath();
        ctx.fill();
        break;

      case 'music':
        // Blue music notes
        ctx.fillStyle = '#4169E1';
        ctx.strokeStyle = '#4169E1';
        ctx.lineWidth = 2;
        // First note
        ctx.beginPath();
        ctx.arc(22, 40, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(26, 40);
        ctx.lineTo(26, 20);
        ctx.stroke();
        // Second note
        ctx.beginPath();
        ctx.arc(36, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(40, 42);
        ctx.lineTo(40, 22);
        ctx.stroke();
        // Beam
        ctx.beginPath();
        ctx.moveTo(26, 20);
        ctx.lineTo(40, 22);
        ctx.stroke();
        break;

      case 'hammer':
        // Brown hammer
        ctx.fillStyle = '#8B4513';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        // Handle
        ctx.fillRect(28, 24, 4, 20);
        ctx.strokeRect(28, 24, 4, 20);
        // Head
        ctx.fillRect(18, 20, 20, 8);
        ctx.strokeRect(18, 20, 20, 8);
        break;

      case 'leaf':
        // Green leaf
        ctx.fillStyle = '#4CAF50';
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(32, 32, 10, 16, Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Center vein
        ctx.beginPath();
        ctx.moveTo(32, 18);
        ctx.lineTo(32, 46);
        ctx.stroke();
        break;

      case 'book':
        // Purple book
        ctx.fillStyle = '#9C27B0';
        ctx.strokeStyle = '#6A1B9A';
        ctx.lineWidth = 2;
        ctx.fillRect(18, 22, 28, 20);
        ctx.strokeRect(18, 22, 28, 20);
        // Spine
        ctx.beginPath();
        ctx.moveTo(32, 22);
        ctx.lineTo(32, 42);
        ctx.stroke();
        // Pages
        ctx.strokeStyle = '#E1BEE7';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(20, 22);
        ctx.lineTo(20, 42);
        ctx.stroke();
        break;

      case 'star':
        // Gold star
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
          const r = i % 2 === 0 ? 14 : 6;
          const x = cx + r * Math.cos(angle);
          const y = cy + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        break;

      case 'zzz':
        // Gray Zzz
        ctx.fillStyle = '#888888';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('Z', 18, 38);
        ctx.font = 'bold 12px Arial';
        ctx.fillText('Z', 28, 30);
        ctx.font = 'bold 10px Arial';
        ctx.fillText('Z', 36, 24);
        break;

      case 'eye':
        // Cyan eye
        ctx.fillStyle = '#00BCD4';
        ctx.strokeStyle = '#0097A7';
        ctx.lineWidth = 2;
        // Outer eye
        ctx.beginPath();
        ctx.ellipse(32, 32, 14, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Pupil
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(32, 32, 5, 0, Math.PI * 2);
        ctx.fill();
        // Highlight
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(30, 30, 2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case '!':
        // Yellow exclamation
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        // Bar
        ctx.fillRect(28, 18, 8, 18);
        ctx.strokeRect(28, 18, 8, 18);
        // Dot
        ctx.beginPath();
        ctx.arc(32, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      case '?':
        // White question mark
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#CCCCCC';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;

      case 'compass':
        // Teal compass
        ctx.strokeStyle = '#00BCD4';
        ctx.fillStyle = '#00BCD4';
        ctx.lineWidth = 2;
        // Circle
        ctx.beginPath();
        ctx.arc(32, 32, 14, 0, Math.PI * 2);
        ctx.stroke();
        // N arrow
        ctx.beginPath();
        ctx.moveTo(32, 20);
        ctx.lineTo(28, 28);
        ctx.lineTo(32, 26);
        ctx.lineTo(36, 28);
        ctx.closePath();
        ctx.fill();
        // S indicator
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(32, 44, 2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'coins':
        // Gold coins
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        // Back coin
        ctx.beginPath();
        ctx.arc(26, 34, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Middle coin
        ctx.beginPath();
        ctx.arc(34, 30, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Front coin
        ctx.beginPath();
        ctx.arc(30, 38, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      default:
        return null;
    }

    const texture = new THREE.CanvasTexture(canvas);
    return new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      opacity: 1.0
    });
  }

  /**
   * Create quest indicator sprite
   * @param {string} indicatorType - 'available', 'active', 'complete'
   * @param {object} THREE
   * @returns {THREE.Sprite}
   */
  function createQuestIndicator(indicatorType, THREE) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;

    ctx.clearRect(0, 0, 64, 64);

    var cx = 32, cy = 32;

    switch (indicatorType) {
      case 'available':
        // Yellow exclamation mark
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 2;
        ctx.fillRect(28, 18, 8, 18);
        ctx.strokeRect(28, 18, 8, 18);
        ctx.beginPath();
        ctx.arc(32, 42, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        break;

      case 'active':
        // Grey question mark
        ctx.fillStyle = '#AAAAAA';
        ctx.strokeStyle = '#888888';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;

      case 'complete':
        // Green question mark
        ctx.fillStyle = '#00FF00';
        ctx.strokeStyle = '#00CC00';
        ctx.lineWidth = 2;
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText('?', 32, 32);
        ctx.fillText('?', 32, 32);
        break;
    }

    var texture = new THREE.CanvasTexture(canvas);
    var material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    var sprite = new THREE.Sprite(material);
    sprite.scale.set(0.6, 0.6, 1);
    sprite.position.y = 2.2; // Above NPC head

    return sprite;
  }

  /**
   * Create activity indicator mesh (3D icon above NPC head)
   * @param {string} activityState - 'working', 'talking', 'walking', 'idle'
   * @param {object} THREE
   * @returns {THREE.Mesh}
   */
  function createActivityIndicator(activityState, THREE) {
    var geometry;
    var material;
    var mesh;

    switch (activityState) {
      case 'working':
        // Small rotating orange cube
        geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        material = new THREE.MeshBasicMaterial({ color: 0xFF8C00, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.userData.rotationSpeed = 2.0;
        break;

      case 'talking':
      case 'socializing':
        // White speech bubble (stretched sphere)
        geometry = new THREE.SphereGeometry(0.1, 8, 8);
        material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.scale.set(1.2, 0.8, 0.6);
        mesh.userData.rotationSpeed = 0;
        break;

      case 'walking':
        // Green arrow pointing forward (cone rotated)
        geometry = new THREE.ConeGeometry(0.08, 0.2, 6);
        material = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = Math.PI / 2;
        mesh.userData.rotationSpeed = 0;
        break;

      case 'idle':
      default:
        // Blue floating diamond (octahedron)
        geometry = new THREE.OctahedronGeometry(0.1, 0);
        material = new THREE.MeshBasicMaterial({ color: 0x00BFFF, transparent: true, opacity: 0.9 });
        mesh = new THREE.Mesh(geometry, material);
        mesh.userData.rotationSpeed = 1.0;
        break;
    }

    mesh.position.y = 2.1; // Above NPC head, below name plate
    mesh.castShadow = false;
    mesh.receiveShadow = false;

    return mesh;
  }

  /**
   * Update quest indicators for NPCs
   * @param {string} playerId - Player ID for quest state
   * @param {object} playerPos - Player position (for proximity check)
   */
  function updateQuestIndicators(playerId, playerPos) {
    var THREE = window.THREE;
    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    if (!THREE || !Quests || !playerId) return;

    lastPlayerIdForQuests = playerId;

    npcAgents.forEach(function(agent) {
      var mesh = npcMeshes.get(agent.id);
      if (!mesh) return;

      // Only update indicators for NPCs within 50 units
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        if (Math.sqrt(dx * dx + dz * dz) > 50) {
          // Remove indicator if too far
          var existing = questIndicators.get(agent.id);
          if (existing) {
            mesh.remove(existing.sprite);
            questIndicators.delete(agent.id);
          }
          return;
        }
      }

      // Get quest state for this NPC
      var npcQuests = Quests.getNpcQuests(agent.id, playerId);
      var indicatorType = null;

      if (npcQuests.length > 0) {
        var questInfo = npcQuests[0]; // Use first quest
        if (questInfo.state === 'available') {
          indicatorType = 'available';
        } else if (questInfo.state === 'active') {
          indicatorType = 'active';
        } else if (questInfo.state === 'complete') {
          indicatorType = 'complete';
        }
      }

      // Update or remove indicator
      var existing = questIndicators.get(agent.id);

      if (indicatorType === null) {
        // No quest, remove indicator
        if (existing) {
          mesh.remove(existing.sprite);
          questIndicators.delete(agent.id);
        }
      } else {
        // Need indicator
        if (!existing || existing.type !== indicatorType) {
          // Remove old indicator
          if (existing) {
            mesh.remove(existing.sprite);
          }
          // Create new indicator
          var sprite = createQuestIndicator(indicatorType, THREE);
          mesh.add(sprite);
          questIndicators.set(agent.id, { sprite: sprite, type: indicatorType });
        }
      }
    });
  }

  /**
   * Update emote indicator for an NPC
   * @param {object} agent - NPC agent
   * @param {object} state - NPC state
   * @param {object} mesh - NPC mesh
   * @param {object} playerPos - Player position {x, z} or null
   * @param {object} decision - AI decision (optional)
   */
  function updateEmoteIndicator(agent, state, mesh, playerPos, decision) {
    const THREE = window.THREE;
    if (!THREE) return;

    let desiredEmote = null;

    // Check player proximity first (highest priority)
    if (playerPos) {
      const dx = playerPos.x - agent.position.x;
      const dz = playerPos.z - agent.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < 8) {
        desiredEmote = 'eye';
      }
    }

    // Check AI decision overrides
    if (decision && (decision.type === 'greet' || decision.type === 'react')) {
      desiredEmote = '!';
    }

    // Otherwise, map state + archetype to emote
    if (!desiredEmote) {
      const currentState = state.currentState;
      const archetype = agent.archetype;

      if (currentState === 'idle' && archetype === 'philosopher') {
        desiredEmote = '?';
      } else if (currentState === 'walking') {
        if (archetype === 'explorer') {
          desiredEmote = 'compass';
        }
      } else if (currentState === 'working') {
        switch (archetype) {
          case 'gardener': desiredEmote = 'leaf'; break;
          case 'builder': desiredEmote = 'hammer'; break;
          case 'musician': desiredEmote = 'music'; break;
          case 'teacher': desiredEmote = 'book'; break;
          case 'merchant': desiredEmote = 'coins'; break;
          case 'artist': desiredEmote = 'star'; break;
          case 'storyteller': desiredEmote = 'book'; break;
          case 'healer': desiredEmote = 'heart'; break;
          case 'philosopher': desiredEmote = 'book'; break;
          case 'explorer': desiredEmote = 'compass'; break;
        }
      } else if (currentState === 'talking' || currentState === 'socializing') {
        desiredEmote = 'heart';
      } else if (currentState === 'idle') {
        // Check for rest-related state timer patterns (long idle = resting)
        if (state.stateTimer > 10) {
          desiredEmote = 'zzz';
        }
      }
    }

    // Get or create emote sprite data
    let emoteData = emoteSprites.get(agent.id);

    // Update emote if changed
    if (desiredEmote !== (emoteData ? emoteData.currentEmote : null)) {
      // Remove old sprite
      if (emoteData && emoteData.sprite) {
        mesh.remove(emoteData.sprite);
      }

      // Create new sprite if needed
      if (desiredEmote) {
        const material = createEmoteSprite(desiredEmote, THREE);
        if (material) {
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(0.5, 0.5, 1);
          sprite.position.y = 2.8;
          mesh.add(sprite);

          emoteData = {
            sprite: sprite,
            currentEmote: desiredEmote,
            opacity: 0,
            timer: 0
          };
          emoteSprites.set(agent.id, emoteData);
        }
      } else {
        // No emote, clear data
        emoteSprites.delete(agent.id);
        emoteData = null;
      }
    }

    // Fade in/out animation
    if (emoteData && emoteData.sprite) {
      if (emoteData.opacity < 1.0) {
        emoteData.opacity = Math.min(1.0, emoteData.opacity + 0.05);
        emoteData.sprite.material.opacity = emoteData.opacity;
      }
      emoteData.timer += 0.016; // ~60fps assumption
    }
  }

  /**
   * Update activity indicator for an NPC
   * @param {object} agent - NPC agent
   * @param {object} state - NPC state
   * @param {object} mesh - NPC mesh
   * @param {number} deltaTime - Time delta for animations
   */
  function updateActivityIndicator(agent, state, mesh, deltaTime) {
    var THREE = window.THREE;
    if (!THREE) return;

    var desiredActivity = state.currentState;

    // Get or create activity indicator data
    var indicatorData = activityIndicators.get(agent.id);

    // Update activity indicator if changed
    if (desiredActivity !== (indicatorData ? indicatorData.currentActivity : null)) {
      // Remove old mesh
      if (indicatorData && indicatorData.mesh) {
        mesh.remove(indicatorData.mesh);
      }

      // Create new mesh
      var indicatorMesh = createActivityIndicator(desiredActivity, THREE);
      if (indicatorMesh) {
        mesh.add(indicatorMesh);

        indicatorData = {
          mesh: indicatorMesh,
          currentActivity: desiredActivity,
          bobTimer: 0
        };
        activityIndicators.set(agent.id, indicatorData);
      }
    }

    // Animate the indicator (floating bob and rotation)
    if (indicatorData && indicatorData.mesh) {
      // Floating bob animation
      indicatorData.bobTimer += deltaTime * 2.0;
      indicatorData.mesh.position.y = 2.1 + Math.sin(indicatorData.bobTimer) * 0.08;

      // Rotation animation (if applicable)
      if (indicatorData.mesh.userData.rotationSpeed > 0) {
        indicatorData.mesh.rotation.y += deltaTime * indicatorData.mesh.userData.rotationSpeed;
      }
    }
  }

  /**
   * Spawn activity particle near NPC
   * @param {THREE.Group} npcMesh - NPC mesh
   * @param {string} archetype - NPC archetype
   * @param {THREE} THREE - Three.js library
   */
  function spawnActivityParticle(npcMesh, archetype, THREE) {
    if (!THREE) return;
    if (activityParticles.length >= 20) return; // Global particle limit

    // Count particles for this NPC
    const npcParticleCount = activityParticles.filter(p => p.npcId === npcMesh.userData.agentId).length;
    if (npcParticleCount >= 3) return; // Per-NPC limit

    // Determine particle color and type based on archetype
    let color, size;
    switch (archetype) {
      case 'gardener':
        color = 0x4CAF50; // green
        size = 0.05;
        break;
      case 'builder':
        color = 0x8D6E63; // brown
        size = 0.06;
        break;
      case 'musician':
        color = Math.random() > 0.5 ? 0x4169E1 : 0xFF69B4; // blue or pink
        size = 0.04;
        break;
      case 'artist':
        // Rainbow colors
        const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
        color = colors[Math.floor(Math.random() * colors.length)];
        size = 0.05;
        break;
      case 'healer':
        color = Math.random() > 0.5 ? 0xFFFFFF : 0xFFD700; // white or gold
        size = 0.04;
        break;
      default:
        return; // No particles for other archetypes
    }

    // Create particle geometry (reuse or create)
    const geometry = new THREE.SphereGeometry(size, 6, 6);
    const material = new THREE.MeshBasicMaterial({ color: color, transparent: true });
    const particle = new THREE.Mesh(geometry, material);

    // Position near NPC's hands (approximate)
    const handOffset = Math.random() > 0.5 ? 0.3 : -0.3;
    particle.position.set(
      npcMesh.position.x + handOffset + (Math.random() - 0.5) * 0.2,
      npcMesh.position.y + 1.0 + Math.random() * 0.2,
      npcMesh.position.z + (Math.random() - 0.5) * 0.2
    );

    // Add to scene
    if (storedSceneContext && storedSceneContext.scene) {
      storedSceneContext.scene.add(particle);
    } else {
      return; // Can't add particle without scene
    }

    // Track particle
    activityParticles.push({
      mesh: particle,
      timer: 2.0, // 2 second lifetime
      velocity: {
        x: (Math.random() - 0.5) * 0.1,
        y: 0.3 + Math.random() * 0.2, // upward drift
        z: (Math.random() - 0.5) * 0.1
      },
      startY: particle.position.y,
      npcId: npcMesh.userData.agentId
    });
  }

  /**
   * Update activity particles
   * @param {number} deltaTime - Frame delta time
   */
  function updateActivityParticles(deltaTime) {
    if (!storedSceneContext || !storedSceneContext.scene) return;

    for (let i = activityParticles.length - 1; i >= 0; i--) {
      const particle = activityParticles[i];
      particle.timer -= deltaTime;

      if (particle.timer <= 0) {
        // Remove particle
        storedSceneContext.scene.remove(particle.mesh);
        activityParticles.splice(i, 1);
      } else {
        // Update position
        particle.mesh.position.x += particle.velocity.x * deltaTime;
        particle.mesh.position.y += particle.velocity.y * deltaTime;
        particle.mesh.position.z += particle.velocity.z * deltaTime;

        // Fade out based on timer
        const fadeProgress = particle.timer / 2.0;
        particle.mesh.material.opacity = fadeProgress;

        // Slow down upward velocity slightly over time
        particle.velocity.y *= 0.98;
      }
    }
  }

  /**
   * Initialize NPCs
   */
  function initNPCs(agentsData, gameState, sceneContext) {
    console.log('Initializing AI citizens...');

    if (agentsData) {
      npcAgents = agentsData.agents || agentsData;
    } else {
      // Use embedded agents data (no fetch needed â€” single-file app)
      npcAgents = EMBEDDED_AGENTS;
    }

    console.log('Loaded ' + npcAgents.length + ' AI citizens');
    initNPCStates();

    if (sceneContext && sceneContext.scene) {
      addNPCsToScene(sceneContext);
    }
  }

  /**
   * Initialize NPC behavior states
   */
  function initNPCStates() {
    // Re-check for NpcAI module (may have loaded after npcs.js)
    if (!NpcAI && typeof window !== 'undefined') NpcAI = window.NpcAI;

    // Re-check for NpcDialogue module (may have loaded after npcs.js)
    if (!dialogue && typeof NpcDialogue !== 'undefined') dialogue = NpcDialogue;

    // Wire in the dialogue manager for queue-based speech management
    if (dialogue && dialogue.createManager && !dialogueManager) {
      dialogueManager = dialogue.createManager({
        cooldownMs: 20000,  // 20s between utterances per NPC
        maxQueueSize: 50
      });
      console.log('NpcDialogue manager initialized');
    }

    npcAgents.forEach(agent => {
      npcStates.set(agent.id, {
        currentState: 'idle',
        stateTimer: 5,
        destination: null,
        targetNPC: null,
        lookAngle: 0,
        animationTime: Math.random() * 1000,
        currentActivity: 'idle',
        lastActivityUpdate: 0,
        targetZone: agent.position.zone,
        targetPosition: null,
        movementSpeed: 0,
        idleTimer: Math.random() * 3
      });

      // Create AI brain for each NPC (if NpcAI available)
      if (NpcAI && NpcAI.createNpcBrain) {
        var brain = NpcAI.createNpcBrain(agent.archetype, agent.id);
        npcBrains.set(agent.id, brain);
      }
    });

    if (NpcAI) {
      console.log('NPC AI brains initialized for ' + npcBrains.size + ' agents');
    } else {
      console.log('NpcAI not loaded â€” using fallback behavior');
    }
  }

  /**
   * Add NPCs to 3D scene
   */
  function addNPCsToScene(sceneContext) {
    if (!sceneContext || !sceneContext.scene) return;

    const THREE = window.THREE;
    if (!THREE) return;

    // Store scene context for particle system
    storedSceneContext = sceneContext;

    npcAgents.forEach(agent => {
      // Create detailed humanoid NPC with unique skin tone
      const group = createHumanoidNPC(agent.archetype, THREE, agent.id);

      // Name label with archetype subtitle
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 96;

      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Draw name (larger and bolder)
      context.font = 'Bold 32px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.fillText(agent.name, canvas.width / 2, 42);

      // Draw archetype subtitle
      context.font = '20px Arial';
      context.fillStyle = 'rgba(255, 255, 255, 0.8)';
      var archetypeCapitalized = agent.archetype.charAt(0).toUpperCase() + agent.archetype.slice(1);
      context.fillText(archetypeCapitalized, canvas.width / 2, 70);

      const labelTexture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
      const label = new THREE.Sprite(labelMaterial);
      label.scale.set(2.5, 1.0, 1);
      label.position.y = 2.5;
      group.add(label);

      // Position NPC - convert zone-relative to world coordinates
      var zoneCenter = ZONE_CENTERS[agent.position.zone] || {x: 0, z: 0};
      group.position.set(
        zoneCenter.x + agent.position.x,
        agent.position.y,
        zoneCenter.z + agent.position.z
      );

      // Update agent position to world coordinates for movement calculations
      agent.position.x += zoneCenter.x;
      agent.position.z += zoneCenter.z;

      // Store agent ID in mesh userData for particle system
      group.userData.agentId = agent.id;

      // Store reference
      npcMeshes.set(agent.id, group);

      // Add to scene (initially hidden)
      group.visible = false;
      sceneContext.scene.add(group);
    });

    console.log(`Added ${npcMeshes.size} NPC meshes to scene`);
  }

  /**
   * Update NPC activity based on daily schedule
   * @param {object} agent - NPC agent
   * @param {object} state - NPC state
   * @param {number} worldTime - Current world time in minutes
   */
  function updateNPCActivity(agent, state, worldTime) {
    if (!worldTime && worldTime !== 0) return; // No world time provided

    // Get current scheduled activity
    var scheduledActivity = getNPCSchedule(agent.archetype, worldTime);

    // Check if activity has changed
    if (state.currentActivity !== scheduledActivity) {
      state.currentActivity = scheduledActivity;
      state.lastActivityUpdate = worldTime;

      // Determine target zone for this activity
      var targetZone = getActivityZone(agent.archetype, scheduledActivity);

      // If zone changed, set destination to new zone center
      if (targetZone !== state.targetZone) {
        state.targetZone = targetZone;
        var zoneCenter = ZONE_CENTERS[targetZone];
        if (zoneCenter) {
          // Set destination near zone center with some randomness
          var angle = Math.random() * Math.PI * 2;
          var radius = 5 + Math.random() * 15;
          state.destination = {
            x: zoneCenter.x + Math.cos(angle) * radius,
            z: zoneCenter.z + Math.sin(angle) * radius
          };
          state.currentState = 'walking';
        }
      }

      // Map activity to behavior state
      var activityToBehavior = {
        // Working activities
        tending_garden: 'working',
        harvesting: 'working',
        planting: 'working',
        watering: 'working',
        building: 'working',
        painting: 'working',
        creating: 'working',
        composing: 'working',
        practicing: 'working',
        making_medicine: 'working',
        gathering_herbs: 'working',
        // Social activities
        selling: 'talking',
        teaching: 'talking',
        lecturing: 'talking',
        debating: 'talking',
        storytelling: 'talking',
        sharing_stories: 'talking',
        performing_crowd: 'talking',
        // Quiet activities
        reading: 'idle',
        studying: 'idle',
        researching: 'idle',
        writing: 'idle',
        contemplating: 'idle',
        meditating: 'idle',
        resting: 'idle',
        sleeping: 'idle',
        // Movement activities
        wandering_agora: 'walking',
        exploring: 'walking',
        setting_out: 'walking',
        returning: 'walking',
        // Other
        opening_shop: 'working',
        closing_shop: 'working',
        maintenance: 'working',
        planning: 'idle',
        mapping: 'working',
        performing: 'working',
        sketching: 'working',
        displaying_work: 'talking'
      };

      var behaviorState = activityToBehavior[scheduledActivity] || 'idle';

      // Only change behavior if not already walking to new zone
      if (state.currentState !== 'walking' || !state.destination) {
        state.currentState = behaviorState;
        var duration = BEHAVIOR_STATES[behaviorState].duration;
        state.stateTimer = duration[0] + Math.random() * (duration[1] - duration[0]);
      }
    }
  }

  /**
   * Update NPCs (called every frame)
   */
  function updateNPCs(sceneContext, gameState, deltaTime, worldTime, worldState) {
    if (npcAgents.length === 0) return;
    npcUpdateFrame++;

    // Re-check for NpcAI module (may have loaded after init)
    if (!NpcAI && typeof window !== 'undefined' && window.NpcAI) {
      NpcAI = window.NpcAI;
      // Late-init brains for NPCs that don't have one
      npcAgents.forEach(function(agent) {
        if (!npcBrains.has(agent.id) && NpcAI.createNpcBrain) {
          npcBrains.set(agent.id, NpcAI.createNpcBrain(agent.archetype, agent.id));
        }
      });
      console.log('NpcAI late-loaded, brains initialized');
    }

    // Process pending events
    if (NpcAI && pendingEvents.length > 0) {
      var events = pendingEvents.slice();
      pendingEvents = [];
      events.forEach(function(event) {
        npcBrains.forEach(function(brain) {
          if (NpcAI.handleEvent) NpcAI.handleEvent(brain.memory, event);
        });
      });
    }

    var timeSeed = Math.floor(worldTime);
    var playerPos = worldState && worldState.playerPosition ? worldState.playerPosition : null;

    npcAgents.forEach(function(agent, index) {
      var state = npcStates.get(agent.id);
      if (!state) return;

      // Performance: stagger AI updates by distance
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        // Far NPCs update less frequently
        if (dist > 300) return; // skip entirely
        if (dist > 150 && npcUpdateFrame % 10 !== index % 10) return;
        if (dist > 50 && npcUpdateFrame % 3 !== index % 3) return;
      }

      // Update activity based on schedule (only if worldTime provided)
      if (worldTime || worldTime === 0) {
        updateNPCActivity(agent, state, worldTime);
      }

      state.animationTime += deltaTime * 1000;

      // Use NpcAI brain if available
      var brain = npcBrains.get(agent.id);
      if (brain && NpcAI && NpcAI.updateBrain) {
        // Build world state for AI perception
        var aiWorldState = {
          weather: worldState ? worldState.weather : 'clear',
          timeOfDay: worldState ? worldState.timePeriod : 'midday',
          currentHour: worldTime ? worldTime / 60 : 12,
          currentZone: agent.position.zone,
          nearbyPlayers: [],
          nearbyNPCs: [],
          allNPCs: npcAgents
        };

        // Add player info for perception
        if (playerPos && worldState) {
          var pdx = playerPos.x - agent.position.x;
          var pdz = playerPos.z - agent.position.z;
          var pDist = Math.sqrt(pdx * pdx + pdz * pdz);
          if (pDist < 25) {
            aiWorldState.nearbyPlayers.push({
              id: worldState.playerId || 'player',
              distance: pDist,
              direction: { x: pdx, z: pdz },
              isBuilding: false,
              isHarvesting: false
            });
          }
        }

        // Add nearby NPCs for perception
        npcAgents.forEach(function(other) {
          if (other.id === agent.id) return;
          var ndx = other.position.x - agent.position.x;
          var ndz = other.position.z - agent.position.z;
          var nDist = Math.sqrt(ndx * ndx + ndz * ndz);
          if (nDist < 25) {
            var otherBrain = npcBrains.get(other.id);
            aiWorldState.nearbyNPCs.push({
              id: other.id,
              distance: nDist,
              direction: { x: ndx, z: ndz },
              archetype: other.archetype,
              currentActivity: otherBrain ? NpcAI.getGoal(otherBrain) : 'idle',
              mood: otherBrain ? NpcAI.getMood(otherBrain) : 'neutral'
            });
          }
        });

        // Get AI decision
        var npcObj = { x: agent.position.x, z: agent.position.z, name: agent.name, zone: agent.position.zone };
        var decision = NpcAI.updateBrain(brain, npcObj, aiWorldState);

        // Execute decision
        if (decision) {
          // Store decision in brain for emote system access
          brain.lastDecision = decision;
          executeAIDecision(agent, state, decision, deltaTime);
        }
      } else {
        // Fallback to original behavior
        if (state.currentState !== 'walking' && state.currentState !== 'socializing') {
          state.stateTimer -= deltaTime;
          if (state.stateTimer <= 0) {
            transitionState(agent, state, timeSeed + index);
          }
        }
        updateNPCBehavior(agent, state, deltaTime, timeSeed + index);
      }

      updateNPCVisual(agent, state, sceneContext, deltaTime, playerPos);
    });

    // NPC-to-NPC conversations: trigger multi-line exchanges for collaborating pairs
    if (NpcAI && NpcAI.generateConversation && npcUpdateFrame % 120 === 0) {
      npcAgents.forEach(function(agent) {
        var state = npcStates.get(agent.id);
        if (!state || state.currentState !== 'collaborating' || !state.collaborateTarget) return;
        if (chatBubbles.has(agent.id)) return; // Already showing dialogue

        var partner = npcAgents.find(function(a) { return a.id === state.collaborateTarget; });
        if (!partner) return;

        var convo = NpcAI.generateConversation(agent.name, agent.archetype, partner.name, partner.archetype);
        if (convo && convo.length > 0) {
          // Show first two lines immediately (one per NPC), then stagger the rest
          showChatBubbleWithText(agent, convo[0]);
          if (convo.length > 1) {
            showChatBubbleWithText(partner, convo[1]);
          }
        }
      });
    }

    updateChatBubbles(deltaTime);
    updateActivityParticles(deltaTime);
    updateSpeechBubbleTimers(deltaTime);

    // Trigger random ambient speech for visible NPCs
    npcAgents.forEach(function(agent) {
      if (playerPos) {
        var dx = agent.position.x - playerPos.x;
        var dz = agent.position.z - playerPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);
        // Only trigger speech for nearby NPCs
        if (dist < 100) {
          triggerRandomSpeech(agent, deltaTime);
        }
      } else {
        triggerRandomSpeech(agent, deltaTime);
      }
    });
  }

  /**
   * Execute an AI brain decision â€” translates decision to movement/animation/dialogue
   */
  function executeAIDecision(agent, state, decision, deltaTime) {
    // Map AI decision type to NPC state
    switch (decision.type) {
      case 'walk_to':
      case 'wander':
      case 'explore':
      case 'approach_social':
      case 'seek_shelter':
        if (decision.target) {
          state.destination = { x: decision.target.x, z: decision.target.z };
          state.targetPosition = { x: decision.target.x, z: decision.target.z };
          state.currentState = 'walking';
          // Smooth interpolation toward target
          var dx = state.targetPosition.x - agent.position.x;
          var dz = state.targetPosition.z - agent.position.z;
          var dist = Math.sqrt(dx * dx + dz * dz);
          if (dist > 0.5) {
            var speed = decision.speed || 1.5;
            state.movementSpeed = speed;
            var moveAmount = speed * deltaTime;
            var ratio = Math.min(moveAmount / dist, 1);
            agent.position.x += dx * ratio;
            agent.position.z += dz * ratio;
            state.lookAngle = Math.atan2(dx, dz);
          } else {
            state.currentState = 'idle';
            state.destination = null;
            state.targetPosition = null;
            state.movementSpeed = 0;
          }
        }
        break;

      case 'work':
        state.currentState = 'working';
        state.stateTimer = 5 + Math.random() * 10;
        break;

      case 'collaborate':
        state.currentState = 'collaborating';
        state.stateTimer = 6 + Math.random() * 8;
        state.collaborateTarget = decision.targetNPC;
        state.collaborateDesc = decision.activityDesc;
        if (decision.facing) {
          state.lookAngle = Math.atan2(
            decision.facing.x - agent.position.x,
            decision.facing.z - agent.position.z
          );
        }
        break;

      case 'socialize':
      case 'join_group':
        state.currentState = 'talking';
        state.stateTimer = 4 + Math.random() * 3;
        break;

      case 'greet':
      case 'react':
        state.currentState = 'talking';
        state.stateTimer = 3;
        if (decision.facing) {
          state.lookAngle = Math.atan2(
            decision.facing.x - agent.position.x,
            decision.facing.z - agent.position.z
          );
        }
        break;

      case 'rest':
        state.currentState = 'idle';
        state.stateTimer = 8 + Math.random() * 10;
        break;

      case 'idle':
      default:
        state.currentState = 'idle';
        state.stateTimer = 3 + Math.random() * 5;
        break;
    }

    // Show dialogue if the decision includes one
    if (decision.dialogue) {
      showChatBubbleWithText(agent, decision.dialogue);
    }
  }

  /**
   * Show chat bubble with specific text (from AI brain)
   */
  function showChatBubbleWithText(agent, text) {
    var mesh = npcMeshes.get(agent.id);
    if (!mesh) return;
    var THREE = window.THREE;
    if (!THREE) return;

    // Remove existing bubble
    var existing = chatBubbles.get(agent.id);
    if (existing) { mesh.remove(existing.mesh); }

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = 512; canvas.height = 128;

    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    context.lineWidth = 4;

    var x = 10, y = 10, w = canvas.width - 20, h = canvas.height - 20, r = 15;
    context.beginPath();
    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);
    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);
    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);
    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);
    context.quadraticCurveTo(x, y, x + r, y);
    context.closePath();
    context.fill();
    context.stroke();

    context.fillStyle = 'black';
    context.font = '18px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    var words = text.split(' ');
    var line = '', y_pos = 50;
    for (var i = 0; i < words.length; i++) {
      var testLine = line + words[i] + ' ';
      if (context.measureText(testLine).width > 480 && line !== '') {
        context.fillText(line, canvas.width / 2, y_pos);
        line = words[i] + ' ';
        y_pos += 22;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, canvas.width / 2, y_pos);

    var bubbleTexture = new THREE.CanvasTexture(canvas);
    var bubbleMaterial = new THREE.SpriteMaterial({ map: bubbleTexture });
    var bubble = new THREE.Sprite(bubbleMaterial);
    bubble.scale.set(4, 1, 1);
    bubble.position.y = 3.5;
    mesh.add(bubble);
    chatBubbles.set(agent.id, { mesh: bubble, timer: 5 });
  }

  /**
   * Transition NPC to new state
   */
  function transitionState(agent, state, seed) {
    const transitions = STATE_TRANSITIONS[state.currentState];
    if (!transitions) return;

    // Weighted random selection
    let roll = seededRandom(seed);
    let cumulative = 0;
    let newState = 'idle';

    for (const [stateName, weight] of Object.entries(transitions)) {
      cumulative += weight;
      if (roll < cumulative) {
        newState = stateName;
        break;
      }
    }

    // Set new state
    state.currentState = newState;

    // Set duration
    const durationRange = BEHAVIOR_STATES[newState].duration;
    const duration = durationRange[0] +
      seededRandom(seed + 1) * (durationRange[1] - durationRange[0]);
    state.stateTimer = duration;

    // State-specific setup
    switch (newState) {
      case 'walking':
        // 70% chance: walk to a landmark matching archetype, 30%: random wander
        var landmark = null;
        if (seededRandom(seed + 5) < 0.7) {
          landmark = pickLandmarkDestination(agent, seed + 6);
        }
        if (landmark) {
          // Walk to landmark with small offset for natural feel
          var lmOffX = (seededRandom(seed + 7) - 0.5) * 3;
          var lmOffZ = (seededRandom(seed + 8) - 0.5) * 3;
          state.destination = { x: landmark.x + lmOffX, z: landmark.z + lmOffZ };
          state.landmarkTarget = landmark.name;
        } else {
          // Fallback: random nearby destination within zone bounds
          var zoneCenter = ZONE_CENTERS[agent.position.zone] || {x: 0, z: 0};
          var wAngle = seededRandom(seed + 2) * Math.PI * 2;
          var wDist = 5 + seededRandom(seed + 3) * 20;
          var destX = agent.position.x + Math.cos(wAngle) * wDist;
          var destZ = agent.position.z + Math.sin(wAngle) * wDist;
          // Keep within zone radius (~60 units from zone center)
          var zoneRadius = 60;
          var dxFromCenter = destX - zoneCenter.x;
          var dzFromCenter = destZ - zoneCenter.z;
          var distFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dzFromCenter * dzFromCenter);
          if (distFromCenter > zoneRadius) {
            destX = zoneCenter.x + (dxFromCenter / distFromCenter) * zoneRadius;
            destZ = zoneCenter.z + (dzFromCenter / distFromCenter) * zoneRadius;
          }
          // Keep away from zone center structure
          var centerDist = Math.sqrt((destX - zoneCenter.x) * (destX - zoneCenter.x) + (destZ - zoneCenter.z) * (destZ - zoneCenter.z));
          if (centerDist < 10) {
            destX = zoneCenter.x + (destX - zoneCenter.x) / centerDist * 12;
            destZ = zoneCenter.z + (destZ - zoneCenter.z) / centerDist * 12;
          }
          state.destination = { x: destX, z: destZ };
          state.landmarkTarget = null;
        }
        break;

      case 'talking':
        // Show chat bubble
        showChatBubble(agent, seed);
        break;

      case 'socializing':
        // Find nearby NPCs by actual distance
        const nearby = npcAgents.filter(other => {
          if (other.id === agent.id) return false;
          var dx = other.position.x - agent.position.x;
          var dz = other.position.z - agent.position.z;
          return Math.sqrt(dx * dx + dz * dz) < 50; // within 50 units
        });
        if (nearby.length > 0) {
          state.targetNPC = randomChoice(nearby, seed + 4);
          state.destination = {
            x: state.targetNPC.position.x,
            z: state.targetNPC.position.z
          };
        } else {
          // No one nearby, go to idle
          state.currentState = 'idle';
          state.stateTimer = 5;
        }
        break;
    }
  }

  /**
   * Update NPC behavior
   */
  function updateNPCBehavior(agent, state, deltaTime, seed) {
    switch (state.currentState) {
      case 'idle':
        // Slowly rotate/look around
        state.lookAngle += (seededRandom(seed) - 0.5) * deltaTime * 0.5;
        break;

      case 'walking':
      case 'socializing':
        if (state.destination) {
          // Smooth interpolation toward destination
          const dx = state.destination.x - agent.position.x;
          const dz = state.destination.z - agent.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);

          if (distance > 0.5) {
            const speed = 1.5; // units per second
            state.movementSpeed = speed;
            const moveAmount = speed * deltaTime;
            const ratio = Math.min(moveAmount / distance, 1);

            agent.position.x += dx * ratio;
            agent.position.z += dz * ratio;

            // Update look angle to face movement direction
            state.lookAngle = Math.atan2(dx, dz);
          } else {
            // Reached destination
            state.movementSpeed = 0;
            if (state.currentState === 'socializing') {
              // Switch to talking
              state.currentState = 'talking';
              state.stateTimer = 4 + seededRandom(seed) * 2;
              showChatBubble(agent, seed);
            } else if (state.landmarkTarget) {
              // Arrived at landmark â€” do purposeful activity
              if (seededRandom(seed + 10) < 0.5) {
                state.currentState = 'working';
                state.stateTimer = 5 + seededRandom(seed + 11) * 10;
              } else {
                state.currentState = 'idle';
                state.stateTimer = 2 + seededRandom(seed + 12) * 3;
              }
              state.landmarkTarget = null;
            } else {
              // Switch to idle
              state.currentState = 'idle';
              state.stateTimer = 5;
            }
            state.destination = null;
            state.targetPosition = null;
          }
        }
        break;

      case 'working':
        // Animation handled in visual update
        break;

      case 'talking':
        // Chat bubble visible (handled separately)
        break;
    }
  }

  /**
   * Apply procedural animations to NPC
   */
  function applyAnimations(mesh, state, agent) {
    const userData = mesh.userData;
    if (!userData.head || !userData.torso) return;

    const time = state.animationTime;
    const currentState = state.currentState;

    // Reset rotations to neutral
    userData.leftArm.rotation.x = 0;
    userData.leftArm.rotation.z = 0;
    userData.rightArm.rotation.x = 0;
    userData.rightArm.rotation.z = 0;
    userData.leftLeg.rotation.x = 0;
    userData.rightLeg.rotation.x = 0;
    userData.head.rotation.x = 0;
    userData.head.rotation.y = 0;
    userData.torso.scale.y = 1;

    switch (currentState) {
      case 'idle':
        // Subtle breathing - torso Y scale oscillation
        const breathPhase = Math.sin(time * 0.002);
        userData.torso.scale.y = 1.0 + breathPhase * 0.02;

        // Gentle head sway
        userData.head.rotation.y = Math.sin(time * 0.001) * 0.05;

        // Occasional head turn (every ~3 seconds)
        state.idleTimer -= 0.016; // approx deltaTime
        if (state.idleTimer <= 0) {
          state.idleTimer = 3 + Math.random() * 3;
        }
        var headTurnPhase = Math.max(0, 1 - state.idleTimer / 0.5); // Quick turn
        if (state.idleTimer < 0.5) {
          userData.head.rotation.y += Math.sin(headTurnPhase * Math.PI) * 0.3;
        }

        // Subtle weight shift
        var weightShift = Math.sin(time * 0.0008) * 0.02;
        mesh.position.y = weightShift;
        userData.torso.rotation.z = weightShift * 0.5;
        break;

      case 'walking':
      case 'socializing':
        // Walking animation proportional to movement speed
        var walkSpeedMultiplier = Math.max(0.5, state.movementSpeed || 1.5) / 1.5;
        var walkFrequency = 0.008 * walkSpeedMultiplier;

        // Legs alternate - more pronounced swing
        var legSwing = Math.sin(time * walkFrequency) * 0.5 * walkSpeedMultiplier;
        userData.leftLeg.rotation.x = legSwing;
        userData.rightLeg.rotation.x = -legSwing;

        // Arms swing opposite to legs - natural pendulum motion
        var armSwing = Math.sin(time * walkFrequency + Math.PI) * 0.35 * walkSpeedMultiplier;
        userData.leftArm.rotation.x = armSwing;
        userData.rightArm.rotation.x = -armSwing;

        // Torso bob - up and down motion during walk
        var bobPhase = Math.abs(Math.sin(time * walkFrequency));
        mesh.position.y = bobPhase * 0.08 * walkSpeedMultiplier;

        // Slight torso sway side-to-side
        userData.torso.rotation.z = Math.sin(time * walkFrequency * 0.5) * 0.03;

        // Head slight sway for natural movement
        userData.head.rotation.z = Math.sin(time * walkFrequency * 0.5) * 0.02;
        userData.head.rotation.y = Math.sin(time * walkFrequency * 0.3) * 0.03;

        // Head faces movement direction (handled by mesh rotation)
        break;

      case 'talking':
        // Arms gesture - slight rotation on varied timing
        userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.15;
        userData.rightArm.rotation.x = Math.sin(time * 0.004 + 1.5) * 0.15;
        userData.leftArm.rotation.z = Math.sin(time * 0.0025) * 0.1;
        userData.rightArm.rotation.z = -Math.sin(time * 0.0035) * 0.1;

        // Head nods
        userData.head.rotation.x = Math.sin(time * 0.005) * 0.1;
        break;

      case 'working':
        // Archetype-specific working animations
        switch (agent.archetype) {
          case 'gardener':
            // Bent over, arms reaching down
            userData.torso.rotation.x = 0.3;
            userData.leftArm.rotation.x = 0.5;
            userData.rightArm.rotation.x = 0.5;
            userData.head.rotation.x = 0.2;
            break;

          case 'builder':
            // Arm hammering motion
            const hammerPhase = Math.sin(time * 0.006);
            userData.rightArm.rotation.x = -0.5 + hammerPhase * 0.8;
            userData.leftArm.rotation.x = 0.2;
            break;

          case 'merchant':
            // Standing with slight arm gestures
            userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.2;
            userData.rightArm.rotation.x = -0.3 + Math.sin(time * 0.004) * 0.1;
            break;

          case 'musician':
            // Arms positioned as if playing
            userData.leftArm.rotation.x = -0.8;
            userData.leftArm.rotation.z = 0.5;
            userData.rightArm.rotation.x = -0.6;
            userData.rightArm.rotation.z = -0.3;
            // Slight bobbing
            mesh.position.y = Math.sin(time * 0.004) * 0.03;
            break;

          default:
            // Generic arm motion
            userData.leftArm.rotation.x = Math.sin(time * 0.004) * 0.3;
            userData.rightArm.rotation.x = Math.sin(time * 0.005 + Math.PI) * 0.3;
            break;
        }
        break;

      case 'collaborating':
        // Two-person interaction: animated gesturing, facing partner
        userData.leftArm.rotation.x = Math.sin(time * 0.003) * 0.25 - 0.3;
        userData.rightArm.rotation.x = Math.sin(time * 0.004 + 1) * 0.2 - 0.2;
        userData.leftArm.rotation.z = Math.sin(time * 0.002) * 0.15 + 0.1;
        userData.rightArm.rotation.z = -Math.sin(time * 0.0025) * 0.15 - 0.1;
        // Head nods and turns
        userData.head.rotation.x = Math.sin(time * 0.005) * 0.12;
        userData.head.rotation.y = Math.sin(time * 0.002) * 0.08;
        // Slight weight shifting
        mesh.position.y = Math.sin(time * 0.002) * 0.02;
        break;
    }

    // Animate glow ring - subtle pulsing
    if (userData.glowRing) {
      var pulseFactor = Math.sin(time * 0.003) * 0.1 + 0.9;
      userData.glowRing.material.opacity = 0.4 * pulseFactor;
    }
  }

  /**
   * Update NPC visual representation
   */
  function updateNPCVisual(agent, state, sceneContext, deltaTime, playerPos) {
    const mesh = npcMeshes.get(agent.id);
    if (!mesh) return;
    const THREE = window.THREE;
    if (!THREE) return;

    // Update position with smooth interpolation
    const lerpFactor = Math.min(deltaTime * 5, 1);
    mesh.position.x += (agent.position.x - mesh.position.x) * lerpFactor;
    mesh.position.z += (agent.position.z - mesh.position.z) * lerpFactor;

    // Adjust Y to terrain height if World module available
    var World = typeof window !== 'undefined' ? window.World : null;
    if (World && World.getTerrainHeight) {
      var terrainY = World.getTerrainHeight(mesh.position.x, mesh.position.z);
      mesh.position.y = terrainY;
    }

    // Update rotation (facing direction) with smooth interpolation
    var targetRotation = mesh.rotation.y;
    if (state.currentState === 'walking' || state.currentState === 'socializing') {
      targetRotation = state.lookAngle;
    } else if (state.currentState === 'collaborating' && state.collaborateTarget) {
      // Face the partner NPC
      var partnerMesh = npcMeshes.get(state.collaborateTarget);
      if (partnerMesh) {
        var cdx = partnerMesh.position.x - mesh.position.x;
        var cdz = partnerMesh.position.z - mesh.position.z;
        targetRotation = Math.atan2(cdx, cdz);
      }
    }

    // Smooth rotation interpolation - handle angle wrapping
    var angleDiff = targetRotation - mesh.rotation.y;
    // Normalize angle difference to [-PI, PI]
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    var rotationSpeed = state.currentState === 'walking' ? 8 : 3;
    mesh.rotation.y += angleDiff * Math.min(deltaTime * rotationSpeed, 1);

    // Apply procedural animations
    applyAnimations(mesh, state, agent);

    // Update emote indicator (only for NPCs within 30 units of camera/player)
    if (playerPos || sceneContext.camera) {
      let checkPos = playerPos;
      if (!checkPos && sceneContext.camera) {
        checkPos = { x: sceneContext.camera.position.x, z: sceneContext.camera.position.z };
      }

      if (checkPos) {
        const dx = checkPos.x - agent.position.x;
        const dz = checkPos.z - agent.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 30) {
          // Get AI decision if available (from brain)
          let decision = null;
          const brain = npcBrains.get(agent.id);
          if (brain && brain.lastDecision) {
            decision = brain.lastDecision;
          }

          updateEmoteIndicator(agent, state, mesh, playerPos, decision);

          // Update activity indicator
          updateActivityIndicator(agent, state, mesh, deltaTime);

          // Spawn activity particles for working NPCs (throttled)
          if (state.currentState === 'working') {
            let spawnTimer = particleSpawnTimers.get(agent.id) || 0;
            spawnTimer -= deltaTime;
            if (spawnTimer <= 0) {
              spawnActivityParticle(mesh, agent.archetype, THREE);
              particleSpawnTimers.set(agent.id, 1.0); // 1 second throttle
            } else {
              particleSpawnTimers.set(agent.id, spawnTimer);
            }
          }
        } else {
          // Too far - remove emote sprite if exists
          const emoteData = emoteSprites.get(agent.id);
          if (emoteData && emoteData.sprite) {
            mesh.remove(emoteData.sprite);
            emoteSprites.delete(agent.id);
          }
          // Also remove activity indicator
          const indicatorData = activityIndicators.get(agent.id);
          if (indicatorData && indicatorData.mesh) {
            mesh.remove(indicatorData.mesh);
            activityIndicators.delete(agent.id);
          }
        }
      }
    }
  }

  /**
   * Show chat bubble for NPC
   */
  function showChatBubble(agent, seed) {
    var message;
    var state = npcStates.get(agent.id);

    // Re-check NpcDialogue module
    if (!dialogue && typeof NpcDialogue !== 'undefined') dialogue = NpcDialogue;

    // Use activity-based dialogue if available
    if (state && state.currentActivity && state.currentActivity !== 'idle') {
      message = getActivityDialogue(state.currentActivity);
    }

    // Enhance with NpcDialogue if available and no activity message
    if (!message && dialogue && dialogue.getFallback) {
      var npcObj = { archetype: agent.archetype, name: agent.name };
      var dlgCtx = buildNpcDialogueContext(agent, 'idle_chat');
      message = dialogue.getFallback(npcObj, dlgCtx);
    }

    if (!message) {
      // Fallback to archetype messages
      const messages = ARCHETYPE_MESSAGES[agent.archetype] || ['...'];
      message = randomChoice(messages, seed);
    }

    const mesh = npcMeshes.get(agent.id);
    if (!mesh) return;

    const THREE = window.THREE;
    if (!THREE) return;

    // Remove existing bubble if any
    const existing = chatBubbles.get(agent.id);
    if (existing) {
      mesh.remove(existing.mesh);
    }

    // Create chat bubble sprite
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 128;

    // Background
    context.fillStyle = 'rgba(255, 255, 255, 0.9)';
    context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    context.lineWidth = 4;

    // Rounded rectangle
    const x = 10, y = 10, w = canvas.width - 20, h = canvas.height - 20, r = 15;
    context.beginPath();
    context.moveTo(x + r, y);
    context.lineTo(x + w - r, y);
    context.quadraticCurveTo(x + w, y, x + w, y + r);
    context.lineTo(x + w, y + h - r);
    context.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    context.lineTo(x + r, y + h);
    context.quadraticCurveTo(x, y + h, x, y + h - r);
    context.lineTo(x, y + r);
    context.quadraticCurveTo(x, y, x + r, y);
    context.closePath();
    context.fill();
    context.stroke();

    // Text
    context.fillStyle = 'black';
    context.font = '20px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';

    // Word wrap
    const words = message.split(' ');
    let line = '';
    let y_pos = 64;
    const maxWidth = 480;

    for (let word of words) {
      const testLine = line + word + ' ';
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && line !== '') {
        context.fillText(line, canvas.width / 2, y_pos - 10);
        line = word + ' ';
        y_pos += 25;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, canvas.width / 2, y_pos - 10);

    const bubbleTexture = new THREE.CanvasTexture(canvas);
    const bubbleMaterial = new THREE.SpriteMaterial({ map: bubbleTexture });
    const bubble = new THREE.Sprite(bubbleMaterial);
    bubble.scale.set(4, 1, 1);
    bubble.position.y = 3.5;

    mesh.add(bubble);
    chatBubbles.set(agent.id, {
      mesh: bubble,
      timer: 5 // display for 5 seconds
    });
  }

  /**
   * Update chat bubbles (fade out)
   */
  function updateChatBubbles(deltaTime) {
    for (const [agentId, bubble] of chatBubbles.entries()) {
      bubble.timer -= deltaTime;

      if (bubble.timer <= 0) {
        // Remove bubble
        const npcMesh = npcMeshes.get(agentId);
        if (npcMesh) {
          npcMesh.remove(bubble.mesh);
        }
        chatBubbles.delete(agentId);
      } else if (bubble.timer < 1) {
        // Fade out
        bubble.mesh.material.opacity = bubble.timer;
      }
    }
  }

  /**
   * Initialize speech bubble container
   */
  function initSpeechBubbleContainer() {
    if (!speechBubbleContainer) {
      speechBubbleContainer = document.createElement('div');
      speechBubbleContainer.id = 'npc-speech-bubbles';
      speechBubbleContainer.style.position = 'absolute';
      speechBubbleContainer.style.top = '0';
      speechBubbleContainer.style.left = '0';
      speechBubbleContainer.style.width = '100%';
      speechBubbleContainer.style.height = '100%';
      speechBubbleContainer.style.pointerEvents = 'none';
      speechBubbleContainer.style.zIndex = '100';
      document.body.appendChild(speechBubbleContainer);
    }
  }

  /**
   * Show a speech bubble above an NPC's head
   * @param {string} npcId - NPC ID
   * @param {string} message - Message to display
   */
  function showNPCSpeechBubble(npcId, message) {
    initSpeechBubbleContainer();

    // Remove existing bubble for this NPC
    var existing = speechBubbles.get(npcId);
    if (existing && existing.element) {
      speechBubbleContainer.removeChild(existing.element);
    }

    // Create new bubble element
    var bubble = document.createElement('div');
    bubble.style.position = 'absolute';
    bubble.style.padding = '8px 12px';
    bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
    bubble.style.border = '2px solid rgba(0, 0, 0, 0.3)';
    bubble.style.borderRadius = '12px';
    bubble.style.fontSize = '14px';
    bubble.style.fontFamily = 'Arial, sans-serif';
    bubble.style.color = '#333';
    bubble.style.whiteSpace = 'nowrap';
    bubble.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
    bubble.style.transition = 'opacity 0.3s ease-out';
    bubble.textContent = message;

    speechBubbleContainer.appendChild(bubble);

    // Store bubble data
    speechBubbles.set(npcId, {
      element: bubble,
      timer: 3.0 // Display for 3 seconds
    });
  }

  /**
   * Update speech bubble positions based on camera projection
   * @param {THREE.Camera} camera - The camera to project from
   */
  function updateSpeechBubbles(camera) {
    if (!camera || !speechBubbleContainer) return;

    var THREE = window.THREE;
    if (!THREE) return;

    // Get renderer size for projection
    var width = window.innerWidth;
    var height = window.innerHeight;

    for (var [npcId, bubble] of speechBubbles.entries()) {
      var npcMesh = npcMeshes.get(npcId);
      if (!npcMesh) {
        // NPC no longer exists, remove bubble
        if (bubble.element) {
          speechBubbleContainer.removeChild(bubble.element);
        }
        speechBubbles.delete(npcId);
        continue;
      }

      // Calculate position above NPC's head (y = 2.2 is above head at 1.6)
      var worldPos = new THREE.Vector3();
      npcMesh.getWorldPosition(worldPos);
      worldPos.y += 2.2;

      // Project to screen coordinates
      var screenPos = worldPos.clone();
      screenPos.project(camera);

      // Convert to pixel coordinates
      var x = (screenPos.x * 0.5 + 0.5) * width;
      var y = (-screenPos.y * 0.5 + 0.5) * height;

      // Check if behind camera
      if (!bubble.element) {
        speechBubbles.delete(npcId);
        continue;
      }
      if (screenPos.z > 1) {
        bubble.element.style.display = 'none';
      } else {
        bubble.element.style.display = 'block';
        bubble.element.style.left = x + 'px';
        bubble.element.style.top = y + 'px';
        bubble.element.style.transform = 'translate(-50%, -100%)';
      }
    }
  }

  /**
   * Update speech bubble timers and remove expired ones
   * @param {number} deltaTime - Time since last frame
   */
  function updateSpeechBubbleTimers(deltaTime) {
    for (var [npcId, bubble] of speechBubbles.entries()) {
      bubble.timer -= deltaTime;

      if (bubble.timer <= 0) {
        // Remove expired bubble
        if (bubble.element) {
          speechBubbleContainer.removeChild(bubble.element);
        }
        speechBubbles.delete(npcId);
      } else if (bubble.timer < 0.5) {
        // Fade out in last 0.5 seconds
        if (bubble.element) {
          bubble.element.style.opacity = (bubble.timer / 0.5).toString();
        }
      }
    }
  }

  /**
   * Clear all speech bubbles
   */
  function clearSpeechBubbles() {
    for (var [npcId, bubble] of speechBubbles.entries()) {
      if (bubble.element) {
        speechBubbleContainer.removeChild(bubble.element);
      }
    }
    speechBubbles.clear();
  }

  /**
   * Build a NpcDialogue-compatible context object from an NPC agent's current state.
   * Falls back gracefully if state data is incomplete.
   * @param {object} agent - NPC agent {id, archetype, name, position}
   * @param {string} contextType - 'greeting'|'idle_chat'|'zone_comment'|'weather'|'craft'
   * @returns {object} NpcDialogue context
   */
  function buildNpcDialogueContext(agent, contextType) {
    var state = npcStates.get(agent.id);
    var activity = (state && state.currentActivity) || 'idle';

    // Infer context type from activity if not specified
    if (!contextType) {
      if (activity === 'idle' || activity === 'wandering') {
        contextType = 'idle_chat';
      } else if (activity === 'building' || activity === 'planting' || activity === 'crafting') {
        contextType = 'craft';
      } else {
        contextType = 'idle_chat';
      }
    }

    return {
      type: contextType,
      zone: (agent.position && agent.position.zone) || 'nexus',
      timeOfDay: 'daytime',   // simplified; world state not directly accessible here
      weather: 'clear',       // simplified; updated if world state available
      currentActivity: activity,
      nearbyPlayers: [],
      recentChat: []
    };
  }

  /**
   * Track a dialogue line in the recent history for trend detection.
   * @param {string} npcId
   * @param {string} message
   */
  function trackDialogue(npcId, message) {
    recentDialogueHistory.push({ npcId: npcId, message: message, timestamp: Date.now() });
    if (recentDialogueHistory.length > MAX_DIALOGUE_HISTORY) {
      recentDialogueHistory = recentDialogueHistory.slice(-MAX_DIALOGUE_HISTORY);
    }
  }

  /**
   * Trigger random ambient speech for NPCs
   * Called periodically from updateNPCs
   */
  function triggerRandomSpeech(agent, deltaTime) {
    // Re-check NpcDialogue on first call (may have loaded after npcs.js)
    if (!dialogue && typeof NpcDialogue !== 'undefined') {
      dialogue = NpcDialogue;
    }

    // Initialize next speech time if not set
    var bubbleData = speechBubbles.get(agent.id);
    if (!bubbleData) {
      bubbleData = {
        element: null,
        timer: 0,
        nextSpeechTime: 15 + Math.random() * 15 // Random 15-30 seconds
      };
      speechBubbles.set(agent.id, bubbleData);
    }

    // Don't show speech if already showing a bubble
    if (bubbleData.element && bubbleData.timer > 0) {
      return;
    }

    // Countdown to next speech
    bubbleData.nextSpeechTime -= deltaTime;

    if (bubbleData.nextSpeechTime <= 0) {
      var message;

      // Use NpcDialogue for richer, personality-driven ambient speech
      if (dialogue && dialogue.getFallback) {
        var npcObj = { archetype: agent.archetype, name: agent.name };
        var dlgCtx = buildNpcDialogueContext(agent, 'idle_chat');

        // Vary context type for more variety
        var rand = Math.random();
        if (rand < 0.2) {
          dlgCtx.type = 'zone_comment';
        } else if (rand < 0.35) {
          dlgCtx.type = 'weather';
        } else {
          dlgCtx.type = 'idle_chat';
        }

        // Prevent consecutive repeat: check last bubble for this NPC
        var lastMsg = bubbleData.lastMessage || '';
        var candidate = dialogue.getFallback(npcObj, dlgCtx);
        if (candidate && candidate !== lastMsg) {
          message = candidate;
        } else {
          // Try a different context type on repeat
          dlgCtx.type = 'zone_comment';
          message = dialogue.getFallback(npcObj, dlgCtx) || candidate;
        }

        if (message) {
          bubbleData.lastMessage = message;
        }
      }

      // Fallback: use the existing ARCHETYPE_SPEECH pool
      if (!message) {
        var messages = ARCHETYPE_SPEECH[agent.archetype];
        if (!messages || messages.length === 0) {
          messages = ["Hello!", "Beautiful day!", "Greetings!"];
        }
        message = messages[Math.floor(Math.random() * messages.length)];
      }

      showNPCSpeechBubble(agent.id, message);
      trackDialogue(agent.id, message);

      // Schedule next speech in 15-30 seconds
      bubbleData.nextSpeechTime = 15 + Math.random() * 15;
    }
  }

  /**
   * Reload NPCs for current zone (or by distance on unified world)
   */
  function reloadZoneNPCs(sceneContext, currentZone, playerPos) {
    if (!playerPos) {
      // Fallback: show all NPCs in current zone
      npcMeshes.forEach((mesh, agentId) => {
        const agent = npcAgents.find(a => a.id === agentId);
        if (agent) {
          mesh.visible = (agent.position.zone === currentZone);
        }
      });
      console.log(`Showing NPCs for zone: ${currentZone}`);
    } else {
      // Show NPCs within 200 units of player
      var viewDist = 200;
      npcMeshes.forEach((mesh, agentId) => {
        const agent = npcAgents.find(a => a.id === agentId);
        if (agent) {
          var dx = agent.position.x - playerPos.x;
          var dz = agent.position.z - playerPos.z;
          var dist = Math.sqrt(dx * dx + dz * dz);
          mesh.visible = (dist < viewDist);
        }
      });
    }
  }

  /**
   * Get NPCs in a specific zone
   */
  function getNPCsInZone(zone) {
    return npcAgents.filter(agent => agent.position.zone === zone);
  }

  /**
   * Get specific NPC by ID
   */
  function getNPCById(id) {
    return npcAgents.find(agent => agent.id === id);
  }

  /**
   * Find nearest NPC to a world position within a max distance
   * @returns {object|null} - {agent, distance} or null
   */
  function findNearestNPC(worldX, worldZ, maxDist) {
    maxDist = maxDist || 10;
    var best = null;
    var bestDist = maxDist;
    for (var i = 0; i < npcAgents.length; i++) {
      var agent = npcAgents[i];
      var dx = agent.position.x - worldX;
      var dz = agent.position.z - worldZ;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < bestDist) {
        bestDist = dist;
        best = { agent: agent, distance: dist };
      }
    }
    return best;
  }

  /**
   * Interact with an NPC â€” triggers greeting dialogue and returns response
   * Includes quest system integration
   * @returns {object|null} - {name, message, archetype, hasQuest, questInfo}
   */
  function interactWithNPC(worldX, worldZ, playerId) {
    var nearest = findNearestNPC(worldX, worldZ, 8);
    if (!nearest) return null;

    var agent = nearest.agent;
    var seed = Date.now() * 0.001 + agent.id.charCodeAt(0);
    var brain = npcBrains.get(agent.id);
    var message, mood, activity, familiarity;

    // Check for quests from this NPC
    var Quests = typeof window !== 'undefined' ? window.Quests : null;
    var questInfo = null;
    var hasQuest = false;

    if (Quests && playerId) {
      var npcQuests = Quests.getNpcQuests(agent.id, playerId);
      if (npcQuests.length > 0) {
        hasQuest = true;
        questInfo = npcQuests[0]; // Return first quest for now
      }
    }

    if (brain && NpcAI) {
      // Use AI brain for contextual dialogue
      var context = { category: 'greeting_first' };
      if (NpcAI.getDialogue) {
        // Build a simple perception for dialogue context
        message = NpcAI.getDialogue(brain.memory, context, agent.name);
      }
      mood = NpcAI.getMood ? NpcAI.getMood(brain) : 'neutral';
      activity = NpcAI.getGoal ? NpcAI.getGoal(brain) : '';
      familiarity = brain.memory && brain.memory.playerFamiliarity
        ? Math.round(Object.values(brain.memory.playerFamiliarity)[0] || 0)
        : 0;

      // Record interaction in brain memory
      if (NpcAI.handleEvent) {
        NpcAI.handleEvent(brain.memory, {
          type: 'player_interact',
          playerId: playerId || 'player',
          description: 'Player interacted directly'
        });
      }
      // Increase familiarity
      if (brain.memory && brain.memory.playerFamiliarity) {
        var pKey = Object.keys(brain.memory.playerFamiliarity)[0] || (playerId || 'player');
        brain.memory.playerFamiliarity[pKey] = Math.min(100, (brain.memory.playerFamiliarity[pKey] || 0) + 5);
        familiarity = Math.round(brain.memory.playerFamiliarity[pKey]);
      }
    }

    // NPC greeting gesture based on familiarity
    var npcMesh = npcMeshes.get(agent.id);
    if (npcMesh) {
      var greetEmote = familiarity >= 75 ? 'cheer' : familiarity >= 25 ? 'bow' : 'wave';
      playEmoteAnimation(npcMesh, greetEmote);
    }

    // Use quest dialogue if available
    if (questInfo && questInfo.quest && questInfo.quest.dialogue) {
      if (questInfo.state === 'available') {
        message = questInfo.quest.dialogue.offer;
      } else if (questInfo.state === 'active') {
        message = Quests.getQuestDialogue(questInfo.quest.id, 'progress', questInfo.quest);
      } else if (questInfo.state === 'complete') {
        message = questInfo.quest.dialogue.complete || 'Quest complete! Return to turn it in.';
      }
    }

    // Use schedule-based dialogue if no quest dialogue
    if (!message) {
      var state = npcStates.get(agent.id);
      if (state && state.currentActivity && state.currentActivity !== 'idle') {
        message = getActivityDialogue(state.currentActivity);
      }
    }

    // Use NpcDialogue for personality-driven greeting when no other message yet
    if (!message && dialogue && dialogue.getFallback) {
      var npcObj = { archetype: agent.archetype, name: agent.name };
      var greetCtx = buildNpcDialogueContext(agent, 'greeting');
      message = dialogue.getFallback(npcObj, greetCtx);
    }

    // Fallback to random archetype message if no activity dialogue
    if (!message) {
      var messages = ARCHETYPE_MESSAGES[agent.archetype] || ['Hello there.'];
      message = randomChoice(messages, seed);
    }

    // Track dialogue for culture emergence detection
    if (message) trackDialogue(agent.id, message);

    // Show chat bubble
    if (brain && NpcAI) {
      showChatBubbleWithText(agent, message);
    } else {
      showChatBubble(agent, seed);
    }

    return {
      name: agent.name,
      message: message,
      archetype: agent.archetype,
      mood: mood || 'neutral',
      activity: activity || '',
      familiarity: familiarity || 0,
      id: agent.id,
      hasQuest: hasQuest,
      questInfo: questInfo
    };
  }

  /**
   * Get all NPC positions for minimap rendering
   * @returns {Array} - [{x, z, name, archetype}]
   */
  function getNPCPositions() {
    return npcAgents.map(function(agent) {
      return {
        x: agent.position.x,
        z: agent.position.z,
        name: agent.name,
        archetype: agent.archetype,
        zone: agent.position.zone
      };
    });
  }

  /**
   * Broadcast an event to all NPC brains
   * @param {object} event - {type, data}
   */
  function broadcastEvent(event) {
    if (!event) return;
    // Convert event format for NpcAI
    var aiEvent = {
      type: event.type,
      description: event.type + ': ' + JSON.stringify(event.data || {}).substring(0, 100)
    };
    // Merge event data
    if (event.data) {
      if (event.data.weather) aiEvent.weather = event.data.weather;
      if (event.data.period) aiEvent.timeOfDay = event.data.period;
    }
    pendingEvents.push(aiEvent);
  }

  /**
   * Get NPC mood by ID
   */
  function getNPCMood(id) {
    var brain = npcBrains.get(id);
    if (brain && NpcAI && NpcAI.getMood) return NpcAI.getMood(brain);
    return 'neutral';
  }

  /**
   * Get NPC current goal by ID
   */
  function getNPCGoal(id) {
    var brain = npcBrains.get(id);
    if (brain && NpcAI && NpcAI.getGoal) return NpcAI.getGoal(brain);
    return 'idle';
  }

  /**
   * Get NPC current activity string
   */
  function getNPCActivity(id) {
    var state = npcStates.get(id);
    return state ? state.currentState : 'unknown';
  }

  /**
   * Play emote animation on player mesh
   * @param {THREE.Group} playerMesh - Player mesh group
   * @param {string} emoteType - Type of emote (wave, dance, bow, cheer, meditate, point)
   */
  function playEmoteAnimation(playerMesh, emoteType) {
    if (!playerMesh || !playerMesh.userData) return;

    var userData = playerMesh.userData;
    if (!userData.head || !userData.torso || !userData.leftArm || !userData.rightArm) return;

    // Cancel any existing emote animation
    if (playerMesh.userData.emoteAnimation) {
      clearTimeout(playerMesh.userData.emoteAnimation.timeout);
      cancelAnimationFrame(playerMesh.userData.emoteAnimation.frame);
    }

    var startTime = Date.now();
    var duration = 0;
    var emoteData = { type: emoteType, startTime: startTime };

    function animate() {
      var elapsed = (Date.now() - startTime) / 1000;
      var t = elapsed;

      // Reset to neutral first
      userData.leftArm.rotation.x = 0;
      userData.leftArm.rotation.z = 0;
      userData.rightArm.rotation.x = 0;
      userData.rightArm.rotation.z = 0;
      userData.leftLeg.rotation.x = 0;
      userData.rightLeg.rotation.x = 0;
      userData.head.rotation.x = 0;
      userData.head.rotation.y = 0;
      userData.torso.rotation.x = 0;
      playerMesh.position.y = 0;

      var isComplete = false;

      switch (emoteType) {
        case 'wave':
          // Right arm raises and sways side to side for 2 seconds
          duration = 2.0;
          if (elapsed < duration) {
            var waveProgress = Math.min(elapsed / 0.3, 1.0);
            userData.rightArm.rotation.x = -1.5 * waveProgress;
            userData.rightArm.rotation.z = -0.3 * waveProgress;
            var swayAmount = Math.sin(t * 6) * 0.4;
            userData.rightArm.rotation.y = swayAmount;
            userData.head.rotation.y = swayAmount * 0.3;
          } else {
            isComplete = true;
          }
          break;

        case 'dance':
          // Body bobs up/down, arms alternating raise, slight rotation for 3 seconds
          duration = 3.0;
          if (elapsed < duration) {
            var bobAmount = Math.sin(t * 4) * 0.15;
            playerMesh.position.y = Math.abs(bobAmount);
            userData.leftArm.rotation.x = -0.5 + Math.sin(t * 4) * 0.8;
            userData.rightArm.rotation.x = -0.5 + Math.sin(t * 4 + Math.PI) * 0.8;
            userData.torso.rotation.y = Math.sin(t * 3) * 0.15;
            userData.leftLeg.rotation.x = Math.sin(t * 4) * 0.3;
            userData.rightLeg.rotation.x = Math.sin(t * 4 + Math.PI) * 0.3;
          } else {
            isComplete = true;
          }
          break;

        case 'bow':
          // Upper body tilts forward 45 degrees then returns, 1.5 seconds
          duration = 1.5;
          if (elapsed < duration) {
            var bowProgress;
            if (elapsed < duration * 0.5) {
              bowProgress = (elapsed / (duration * 0.5));
            } else {
              bowProgress = 1.0 - ((elapsed - duration * 0.5) / (duration * 0.5));
            }
            userData.torso.rotation.x = bowProgress * 0.785;
            userData.head.rotation.x = bowProgress * 0.3;
            userData.leftArm.rotation.x = bowProgress * 0.2;
            userData.rightArm.rotation.x = bowProgress * 0.2;
          } else {
            isComplete = true;
          }
          break;

        case 'cheer':
          // Both arms raise up, small hop (y bounce), 2 seconds
          duration = 2.0;
          if (elapsed < duration) {
            var cheerProgress = Math.min(elapsed / 0.2, 1.0);
            userData.leftArm.rotation.x = -2.0 * cheerProgress;
            userData.leftArm.rotation.z = 0.3 * cheerProgress;
            userData.rightArm.rotation.x = -2.0 * cheerProgress;
            userData.rightArm.rotation.z = -0.3 * cheerProgress;
            var hopAmount = Math.abs(Math.sin(t * 5)) * 0.2;
            playerMesh.position.y = hopAmount;
          } else {
            isComplete = true;
          }
          break;

        case 'meditate':
          // Body lowers slightly, arms to sides, gentle floating motion, 3 seconds
          duration = 3.0;
          if (elapsed < duration) {
            var meditateProgress = Math.min(elapsed / 0.5, 1.0);
            playerMesh.position.y = -0.2 * meditateProgress + Math.sin(t * 2) * 0.03;
            userData.leftArm.rotation.x = 0.3 * meditateProgress;
            userData.leftArm.rotation.z = 0.5 * meditateProgress;
            userData.rightArm.rotation.x = 0.3 * meditateProgress;
            userData.rightArm.rotation.z = -0.5 * meditateProgress;
            userData.leftLeg.rotation.z = 0.4 * meditateProgress;
            userData.rightLeg.rotation.z = -0.4 * meditateProgress;
            userData.head.rotation.x = -0.2 * meditateProgress;
            userData.torso.rotation.x = -0.1 * meditateProgress;
          } else {
            isComplete = true;
          }
          break;

        case 'point':
          // Right arm extends forward, holds 1.5 seconds
          duration = 1.5;
          if (elapsed < duration) {
            var pointProgress = Math.min(elapsed / 0.3, 1.0);
            userData.rightArm.rotation.x = -1.2 * pointProgress;
            userData.rightArm.rotation.y = 0.2 * pointProgress;
            userData.rightArm.rotation.z = -0.1 * pointProgress;
            userData.head.rotation.y = 0.2 * pointProgress;
            userData.torso.rotation.y = 0.1 * pointProgress;
          } else {
            isComplete = true;
          }
          break;

        default:
          isComplete = true;
      }

      if (!isComplete) {
        emoteData.frame = requestAnimationFrame(animate);
      } else {
        // Return to neutral
        userData.leftArm.rotation.x = 0;
        userData.leftArm.rotation.y = 0;
        userData.leftArm.rotation.z = 0;
        userData.rightArm.rotation.x = 0;
        userData.rightArm.rotation.y = 0;
        userData.rightArm.rotation.z = 0;
        userData.leftLeg.rotation.x = 0;
        userData.leftLeg.rotation.z = 0;
        userData.rightLeg.rotation.x = 0;
        userData.rightLeg.rotation.z = 0;
        userData.head.rotation.x = 0;
        userData.head.rotation.y = 0;
        userData.torso.rotation.x = 0;
        userData.torso.rotation.y = 0;
        playerMesh.position.y = 0;
        playerMesh.userData.emoteAnimation = null;
      }
    }

    playerMesh.userData.emoteAnimation = emoteData;
    animate();
  }

  // Export public API
  exports.initNPCs = initNPCs;
  exports.updateNPCs = updateNPCs;
  exports.reloadZoneNPCs = reloadZoneNPCs;
  exports.getNPCsInZone = getNPCsInZone;
  exports.getNPCById = getNPCById;
  exports.findNearestNPC = findNearestNPC;
  exports.interactWithNPC = interactWithNPC;
  exports.getNPCPositions = getNPCPositions;
  exports.broadcastEvent = broadcastEvent;
  exports.getNPCMood = getNPCMood;
  exports.getNPCGoal = getNPCGoal;
  exports.getNPCActivity = getNPCActivity;
  exports.updateQuestIndicators = updateQuestIndicators;
  exports.playEmoteAnimation = playEmoteAnimation;
  exports.getNPCSchedule = getNPCSchedule;
  exports.getActivityDialogue = getActivityDialogue;
  exports.getActivityZone = getActivityZone;
  exports.getTimePeriod = getTimePeriod;
  exports.showNPCSpeechBubble = showNPCSpeechBubble;
  exports.updateSpeechBubbles = updateSpeechBubbles;
  exports.clearSpeechBubbles = clearSpeechBubbles;
  exports.getAgents = function() { return npcAgents; };
  exports.buildNpcDialogueContext = buildNpcDialogueContext;
  exports.getDialogueHistory = function() { return recentDialogueHistory.slice(); };
  exports.getDialogueTrend = function() {
    if (!dialogue || !dialogue.detectTrend) return null;
    return dialogue.detectTrend(recentDialogueHistory);
  };
  exports.getNearbyNPCCount = function(playerPos, radius) {
    if (!playerPos || !npcAgents) return 0;
    var count = 0;
    for (var i = 0; i < npcAgents.length; i++) {
      var npc = npcAgents[i];
      if (!npc || !npc.x) continue;
      var dx = npc.x - playerPos.x;
      var dz = npc.z - playerPos.z;
      if (Math.sqrt(dx * dx + dz * dz) <= radius) count++;
    }
    return count;
  };

})(typeof module !== 'undefined' ? module.exports : (window.NPCs = {}));


// seasons.js
(function(exports) {
  // Seasonal events system based on real-world date

  // Season definitions with date ranges
  const SEASONS = {
    spring: {
      id: 'spring',
      name: 'Spring',
      description: 'A time of renewal and growth',
      startMonth: 2, // March (0-indexed)
      endMonth: 4,   // May
      festival: {
        name: 'Bloom Festival',
        description: 'Cherry blossoms fill the air with petals of hope',
        theme: 'flower'
      },
      colors: {
        primary: '#f8b4c8',
        secondary: '#7db37d',
        accent: '#ffd4e5',
        ambient: '#ffe8f0'
      },
      bonus: {
        activity: 'garden',
        multiplier: 1.25,
        description: 'Garden yields increased'
      }
    },
    summer: {
      id: 'summer',
      name: 'Summer',
      description: 'The warmth of endless days',
      startMonth: 5, // June
      endMonth: 7,   // August
      festival: {
        name: 'Sun Festival',
        description: 'Golden light dances with fireflies at dusk',
        theme: 'sun'
      },
      colors: {
        primary: '#f0c040',
        secondary: '#ff8c42',
        accent: '#ffe080',
        ambient: '#fff4d4'
      },
      bonus: {
        activity: 'exploration',
        multiplier: 1.25,
        description: 'Exploration rewards increased'
      }
    },
    autumn: {
      id: 'autumn',
      name: 'Autumn',
      description: 'The season of abundance and reflection',
      startMonth: 8,  // September
      endMonth: 10,   // November
      festival: {
        name: 'Harvest Festival',
        description: 'Leaves fall like amber rain, celebrating the bounty',
        theme: 'harvest'
      },
      colors: {
        primary: '#d4a040',
        secondary: '#8b4513',
        accent: '#e8b860',
        ambient: '#f0e0c0'
      },
      bonus: {
        activity: 'crafting',
        multiplier: 1.25,
        description: 'Crafting rewards increased'
      }
    },
    winter: {
      id: 'winter',
      name: 'Winter',
      description: 'A time of wonder and togetherness',
      startMonth: 11, // December (wraps to Feb)
      endMonth: 1,    // February
      festival: {
        name: 'Star Festival',
        description: 'Snowflakes drift beneath starlit skies',
        theme: 'star'
      },
      colors: {
        primary: '#80c0e0',
        secondary: '#e8e8ff',
        accent: '#a0d4f0',
        ambient: '#e0f0ff'
      },
      bonus: {
        activity: 'social',
        multiplier: 1.25,
        description: 'Social rewards increased'
      }
    }
  };

  // Seasonal items available per season
  const SEASONAL_ITEMS = {
    spring: [
      {
        id: 'cherry_blossom',
        name: 'Cherry Blossom',
        description: 'Delicate pink petals from the sacred trees',
        rarity: 'rare',
        type: 'decoration'
      },
      {
        id: 'spring_bouquet',
        name: 'Spring Bouquet',
        description: 'A vibrant arrangement of seasonal flowers',
        rarity: 'uncommon',
        type: 'gift'
      },
      {
        id: 'rainbow_seed',
        name: 'Rainbow Seed',
        description: 'A magical seed that blooms in seven colors',
        rarity: 'legendary',
        type: 'consumable'
      }
    ],
    summer: [
      {
        id: 'sun_crystal',
        name: 'Sun Crystal',
        description: 'Captures the warmth and light of summer',
        rarity: 'rare',
        type: 'material'
      },
      {
        id: 'firefly_jar',
        name: 'Firefly Jar',
        description: 'A gentle glow to light your path',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'tropical_fruit',
        name: 'Tropical Fruit',
        description: 'Sweet and refreshing, bursting with flavor',
        rarity: 'common',
        type: 'consumable'
      }
    ],
    autumn: [
      {
        id: 'golden_leaf',
        name: 'Golden Leaf',
        description: 'Preserved in its moment of perfect beauty',
        rarity: 'rare',
        type: 'material'
      },
      {
        id: 'pumpkin',
        name: 'Harvest Pumpkin',
        description: 'A symbol of the season\'s abundance',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'maple_syrup',
        name: 'Maple Syrup',
        description: 'Sweet nectar from ancient trees',
        rarity: 'common',
        type: 'consumable'
      }
    ],
    winter: [
      {
        id: 'snowglobe',
        name: 'Snowglobe',
        description: 'A miniature winter wonderland',
        rarity: 'rare',
        type: 'decoration'
      },
      {
        id: 'star_ornament',
        name: 'Star Ornament',
        description: 'Handcrafted decoration that sparkles like the night sky',
        rarity: 'uncommon',
        type: 'decoration'
      },
      {
        id: 'hot_cocoa',
        name: 'Hot Cocoa',
        description: 'Warm comfort in a cup',
        rarity: 'common',
        type: 'consumable'
      }
    ]
  };

  // Decoration configurations per zone and season
  const SEASONAL_DECORATIONS = {
    spring: {
      town: [
        { type: 'cherry_tree', count: 8, positions: 'random' },
        { type: 'flower_bed', count: 12, positions: 'pathways' },
        { type: 'blossom_arch', count: 2, positions: 'entrances' }
      ],
      forest: [
        { type: 'wildflower_patch', count: 15, positions: 'random' },
        { type: 'butterfly_spawn', count: 6, positions: 'clearings' }
      ],
      plains: [
        { type: 'tulip_field', count: 10, positions: 'random' },
        { type: 'rainbow_garden', count: 3, positions: 'special' }
      ]
    },
    summer: {
      town: [
        { type: 'lantern_string', count: 10, positions: 'overhead' },
        { type: 'sun_banner', count: 6, positions: 'buildings' },
        { type: 'fountain_glow', count: 2, positions: 'center' }
      ],
      forest: [
        { type: 'firefly_cluster', count: 20, positions: 'random' },
        { type: 'sun_shaft', count: 8, positions: 'canopy_breaks' }
      ],
      plains: [
        { type: 'sunflower_field', count: 12, positions: 'random' },
        { type: 'heat_shimmer', count: 5, positions: 'distance' }
      ]
    },
    autumn: {
      town: [
        { type: 'hay_bale', count: 8, positions: 'random' },
        { type: 'harvest_wreath', count: 10, positions: 'doors' },
        { type: 'corn_stalk', count: 6, positions: 'corners' }
      ],
      forest: [
        { type: 'mushroom_circle', count: 5, positions: 'random' },
        { type: 'leaf_pile', count: 12, positions: 'clearings' }
      ],
      plains: [
        { type: 'scarecrow', count: 4, positions: 'fields' },
        { type: 'wheat_sheaf', count: 10, positions: 'random' }
      ]
    },
    winter: {
      town: [
        { type: 'star_decoration', count: 15, positions: 'random' },
        { type: 'ice_sculpture', count: 4, positions: 'plazas' },
        { type: 'warm_light', count: 20, positions: 'windows' }
      ],
      forest: [
        { type: 'frost_crystal', count: 12, positions: 'random' },
        { type: 'snow_drift', count: 8, positions: 'ground' }
      ],
      plains: [
        { type: 'frozen_pond', count: 2, positions: 'special' },
        { type: 'icicle_cluster', count: 6, positions: 'rock_formations' }
      ]
    }
  };

  // Particle system configurations per season
  const SEASONAL_PARTICLES = {
    spring: {
      type: 'cherry_blossom',
      count: 100,
      color: '#ffc0db',
      size: 0.3,
      speed: 0.02,
      drift: true,
      swirl: true,
      gravity: 0.001
    },
    summer: {
      type: 'firefly',
      count: 60,
      color: '#ffff80',
      size: 0.2,
      speed: 0.015,
      glow: true,
      pulse: true,
      gravity: 0
    },
    autumn: {
      type: 'falling_leaf',
      count: 80,
      color: '#d4a040',
      size: 0.4,
      speed: 0.025,
      drift: true,
      spin: true,
      gravity: 0.002
    },
    winter: {
      type: 'snowflake',
      count: 120,
      color: '#ffffff',
      size: 0.25,
      speed: 0.01,
      drift: true,
      sparkle: true,
      gravity: 0.0015
    }
  };

  // NPC greetings per season
  const SEASONAL_GREETINGS = {
    spring: [
      'The flowers are beautiful this season!',
      'Can you feel the renewal in the air?',
      'Perfect weather for the Bloom Festival!',
      'Spring brings such wonderful energy!'
    ],
    summer: [
      'Another glorious sunny day!',
      'The fireflies will be out tonight!',
      'Perfect season for adventure!',
      'The Sun Festival lights up everything!'
    ],
    autumn: [
      'The harvest has been bountiful this year!',
      'Don\'t the leaves look magnificent?',
      'Time to gather and give thanks!',
      'The Harvest Festival begins soon!'
    ],
    winter: [
      'Stay warm out there, traveler!',
      'The stars shine brightest in winter!',
      'What a magical time of year!',
      'The Star Festival brings us together!'
    ]
  };

  /**
   * Get the current season based on real-world date
   * @returns {Object} Current season data
   */
  function getCurrentSeason() {
    const now = new Date();
    const month = now.getMonth(); // 0-indexed (0 = January)

    // Check each season
    for (const seasonKey in SEASONS) {
      const season = SEASONS[seasonKey];

      // Handle winter's wrap-around (Dec, Jan, Feb)
      if (season.id === 'winter') {
        if (month >= season.startMonth || month <= season.endMonth) {
          return season;
        }
      } else {
        if (month >= season.startMonth && month <= season.endMonth) {
          return season;
        }
      }
    }

    // Fallback to spring
    return SEASONS.spring;
  }

  /**
   * Get seasonal items available during current season
   * @returns {Array} Array of seasonal items
   */
  function getSeasonalItems() {
    const season = getCurrentSeason();
    return SEASONAL_ITEMS[season.id] || [];
  }

  /**
   * Get seasonal decorations for a specific zone
   * @param {string} zone - Zone name (town, forest, plains)
   * @returns {Array} Array of decoration configurations
   */
  function getSeasonalDecorations(zone) {
    const season = getCurrentSeason();
    const decorations = SEASONAL_DECORATIONS[season.id];
    return decorations[zone] || [];
  }

  /**
   * Get particle configuration for current season
   * @returns {Object} Particle system configuration
   */
  function getSeasonalParticles() {
    const season = getCurrentSeason();
    return SEASONAL_PARTICLES[season.id];
  }

  /**
   * Get season bonus multiplier for an activity
   * @param {string} activity - Activity type (garden, exploration, crafting, social)
   * @returns {number} Multiplier (1.0 for no bonus, 1.25 for seasonal bonus)
   */
  function getSeasonBonus(activity) {
    const season = getCurrentSeason();
    if (season.bonus.activity === activity) {
      return season.bonus.multiplier;
    }
    return 1.0;
  }

  /**
   * Get days remaining until season ends
   * @returns {number} Days until season changes
   */
  function getDaysUntilSeasonEnd() {
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    const season = getCurrentSeason();

    let endDate;

    // Handle winter's wrap-around
    if (season.id === 'winter') {
      if (currentMonth === 11) {
        // December - end is Feb 28/29 next year
        const nextYear = currentYear + 1;
        const isLeapYear = (nextYear % 4 === 0 && nextYear % 100 !== 0) || (nextYear % 400 === 0);
        endDate = new Date(nextYear, 1, isLeapYear ? 29 : 28, 23, 59, 59);
      } else {
        // Jan or Feb
        const isLeapYear = (currentYear % 4 === 0 && currentYear % 100 !== 0) || (currentYear % 400 === 0);
        endDate = new Date(currentYear, 1, isLeapYear ? 29 : 28, 23, 59, 59);
      }
    } else {
      // For other seasons, get last day of end month
      endDate = new Date(currentYear, season.endMonth + 1, 0, 23, 59, 59);
    }

    const msPerDay = 24 * 60 * 60 * 1000;
    const daysRemaining = Math.ceil((endDate - now) / msPerDay);

    return Math.max(0, daysRemaining);
  }

  /**
   * Get a random seasonal greeting for NPCs
   * @returns {string} Seasonal greeting text
   */
  function getSeasonalGreeting() {
    const season = getCurrentSeason();
    const greetings = SEASONAL_GREETINGS[season.id];
    return greetings[Math.floor(Math.random() * greetings.length)];
  }

  /**
   * Get color scheme for current season
   * @returns {Object} Color palette with primary, secondary, accent, ambient
   */
  function getSeasonalColors() {
    const season = getCurrentSeason();
    return season.colors;
  }

  // Export all functions and data
  exports.SEASONS = SEASONS;
  exports.SEASONAL_ITEMS = SEASONAL_ITEMS;
  exports.SEASONAL_DECORATIONS = SEASONAL_DECORATIONS;
  exports.SEASONAL_PARTICLES = SEASONAL_PARTICLES;
  exports.SEASONAL_GREETINGS = SEASONAL_GREETINGS;
  exports.getCurrentSeason = getCurrentSeason;
  exports.getSeasonalItems = getSeasonalItems;
  exports.getSeasonalDecorations = getSeasonalDecorations;
  exports.getSeasonalParticles = getSeasonalParticles;
  exports.getSeasonBonus = getSeasonBonus;
  exports.getDaysUntilSeasonEnd = getDaysUntilSeasonEnd;
  exports.getSeasonalGreeting = getSeasonalGreeting;
  exports.getSeasonalColors = getSeasonalColors;

})(typeof module !== 'undefined' ? module.exports : (window.Seasons = {}));


// pets.js
(function(exports) {
  // Pet companion system for ZION MMO

  // Pet type definitions with zones and rarities
  const PET_TYPES = [
    {
      id: 'cat',
      name: 'Mystic Cat',
      description: 'A wise feline Pingym that brings good fortune to trades',
      icon: 'ðŸ±',
      zone: 'commons',
      rarity: 'common',
      bonus: { type: 'trade_luck', value: 2 }
    },
    {
      id: 'fox',
      name: 'Spirit Fox',
      description: 'A clever fox with enhanced senses for discovering hidden places',
      icon: 'ðŸ¦Š',
      zone: 'wilds',
      rarity: 'uncommon',
      bonus: { type: 'discovery_range', value: 2 }
    },
    {
      id: 'owl',
      name: 'Ancient Owl',
      description: 'A scholarly owl that helps unlock hidden lore',
      icon: 'ðŸ¦‰',
      zone: 'athenaeum',
      rarity: 'uncommon',
      bonus: { type: 'lore_unlock', value: 2 }
    },
    {
      id: 'butterfly',
      name: 'Crystal Butterfly',
      description: 'A delicate butterfly that enhances garden growth',
      icon: 'ðŸ¦‹',
      zone: 'gardens',
      rarity: 'common',
      bonus: { type: 'garden_growth', value: 2 }
    },
    {
      id: 'rabbit',
      name: 'Moon Rabbit',
      description: 'A gentle rabbit that brings peace and faster crafting',
      icon: 'ðŸ°',
      zone: 'gardens',
      rarity: 'common',
      bonus: { type: 'craft_speed', value: 2 }
    },
    {
      id: 'frog',
      name: 'Jade Frog',
      description: 'A lucky frog that attracts rare resources',
      icon: 'ðŸ¸',
      zone: 'wilds',
      rarity: 'uncommon',
      bonus: { type: 'rare_resources', value: 2 }
    },
    {
      id: 'firefly',
      name: 'Ember Firefly',
      description: 'A glowing firefly that illuminates hidden paths',
      icon: 'ðŸª²',
      zone: 'wilds',
      rarity: 'rare',
      bonus: { type: 'vision_range', value: 3 }
    },
    {
      id: 'wolf_pup',
      name: 'Shadow Wolf Pup',
      description: 'A loyal wolf pup that boosts stamina and endurance',
      icon: 'ðŸº',
      zone: 'wilds',
      rarity: 'rare',
      bonus: { type: 'stamina', value: 3 }
    },
    {
      id: 'phoenix_chick',
      name: 'Phoenix Chick',
      description: 'A rare phoenix chick that grants resilience and renewal',
      icon: 'ðŸ¦',
      zone: 'athenaeum',
      rarity: 'legendary',
      bonus: { type: 'resilience', value: 5 }
    },
    {
      id: 'turtle',
      name: 'Ancient Turtle',
      description: 'A wise turtle that increases meditation effectiveness',
      icon: 'ðŸ¢',
      zone: 'gardens',
      rarity: 'rare',
      bonus: { type: 'meditation', value: 3 }
    }
  ];

  // Pet state storage (in real game, this would be in database)
  const playerPets = {};

  // Pet care constants
  const PET_CONSTANTS = {
    HUNGER_DECAY_RATE: 1, // hunger increases by 1 per minute
    MOOD_DECAY_RATE: 0.5, // mood decreases by 0.5 per minute
    BOND_GAIN_RATE: 0.2, // bond increases by 0.2 when feeding/caring
    HUNGER_THRESHOLD_HAPPY: 30, // below 30 hunger = happy
    HUNGER_THRESHOLD_CONTENT: 60, // 30-60 = content
    MOOD_THRESHOLD_ECSTATIC: 90,
    MOOD_THRESHOLD_HAPPY: 70,
    MOOD_THRESHOLD_CONTENT: 50,
    MOOD_THRESHOLD_HUNGRY: 30
  };

  /**
   * Get pet types available in a specific zone
   * @param {string} zone - Zone identifier (commons, wilds, athenaeum, gardens)
   * @returns {Array} Array of pet types available in this zone
   */
  function getAvailablePets(zone) {
    return PET_TYPES.filter(pet => pet.zone === zone);
  }

  /**
   * Adopt a new pet
   * @param {string} playerId - Player identifier
   * @param {string} petType - Pet type id from PET_TYPES
   * @param {string} petName - Custom name for the pet
   * @returns {Object|null} Pet object or null if failed
   */
  function adoptPet(playerId, petType, petName) {
    if (!playerId || !petType || !petName) {
      console.error('Invalid adoption parameters');
      return null;
    }

    // Check if player already has a pet
    if (playerPets[playerId]) {
      console.warn('Player already has a pet. Release current pet first.');
      return null;
    }

    // Find pet type
    const petTypeData = PET_TYPES.find(p => p.id === petType);
    if (!petTypeData) {
      console.error('Invalid pet type:', petType);
      return null;
    }

    // Create pet state
    const pet = {
      id: generatePetId(),
      type: petType,
      name: petName,
      mood: 100, // Start happy
      hunger: 0, // Start well-fed
      bond: 0, // Build bond over time
      adopted_at: Date.now(),
      last_updated: Date.now()
    };

    playerPets[playerId] = pet;
    return pet;
  }

  /**
   * Get player's current pet
   * @param {string} playerId - Player identifier
   * @returns {Object|null} Pet object or null if no pet
   */
  function getPlayerPet(playerId) {
    return playerPets[playerId] || null;
  }

  /**
   * Feed the pet
   * @param {string} playerId - Player identifier
   * @param {string} foodItem - Food item type
   * @returns {Object} Result object with success, message, and updated pet
   */
  function feedPet(playerId, foodItem) {
    const pet = playerPets[playerId];
    if (!pet) {
      return { success: false, message: 'No pet to feed' };
    }

    // Food effectiveness
    const foodEffects = {
      'berry': { hunger: -20, mood: 5 },
      'fish': { hunger: -30, mood: 10 },
      'mushroom': { hunger: -15, mood: 3 },
      'bread': { hunger: -25, mood: 7 },
      'treat': { hunger: -10, mood: 15 },
      'default': { hunger: -10, mood: 5 }
    };

    const effect = foodEffects[foodItem] || foodEffects['default'];

    // Update pet state
    pet.hunger = Math.max(0, pet.hunger + effect.hunger);
    pet.mood = Math.min(100, pet.mood + effect.mood);
    pet.bond = Math.min(100, pet.bond + PET_CONSTANTS.BOND_GAIN_RATE);
    pet.last_updated = Date.now();

    return {
      success: true,
      message: `${pet.name} enjoyed the ${foodItem}!`,
      pet: pet
    };
  }

  /**
   * Update pet state over time (hunger/mood decay)
   * @param {string} playerId - Player identifier
   * @param {number} deltaTime - Time elapsed in milliseconds
   * @returns {Object|null} Updated pet or null
   */
  function updatePet(playerId, deltaTime) {
    const pet = playerPets[playerId];
    if (!pet) return null;

    const minutesElapsed = deltaTime / 60000; // Convert ms to minutes

    // Update hunger (increases over time)
    pet.hunger = Math.min(100, pet.hunger + (PET_CONSTANTS.HUNGER_DECAY_RATE * minutesElapsed));

    // Update mood (decreases over time, faster if hungry)
    let moodDecay = PET_CONSTANTS.MOOD_DECAY_RATE * minutesElapsed;
    if (pet.hunger > PET_CONSTANTS.HUNGER_THRESHOLD_CONTENT) {
      moodDecay *= 2; // Mood decays faster when hungry
    }
    pet.mood = Math.max(0, pet.mood - moodDecay);

    // Bond increases slightly over time (passive bonding)
    if (pet.hunger < PET_CONSTANTS.HUNGER_THRESHOLD_HAPPY && pet.mood > PET_CONSTANTS.MOOD_THRESHOLD_CONTENT) {
      pet.bond = Math.min(100, pet.bond + (0.1 * minutesElapsed));
    }

    pet.last_updated = Date.now();
    return pet;
  }

  /**
   * Get passive bonus from pet based on type and bond level
   * @param {string} playerId - Player identifier
   * @returns {Object|null} Bonus object with type and value, or null
   */
  function getPetBonus(playerId) {
    const pet = playerPets[playerId];
    if (!pet) return null;

    const petType = PET_TYPES.find(p => p.id === pet.type);
    if (!petType) return null;

    // Bonus scales with bond level
    const bondMultiplier = pet.bond / 100;
    const bonusValue = petType.bonus.value * bondMultiplier;

    return {
      type: petType.bonus.type,
      value: bonusValue,
      description: getBonusDescription(petType.bonus.type, bonusValue)
    };
  }

  /**
   * Rename pet
   * @param {string} playerId - Player identifier
   * @param {string} newName - New pet name
   * @returns {boolean} Success status
   */
  function renamePet(playerId, newName) {
    const pet = playerPets[playerId];
    if (!pet || !newName) return false;

    pet.name = newName;
    return true;
  }

  /**
   * Release pet back to the wild
   * @param {string} playerId - Player identifier
   * @returns {boolean} Success status
   */
  function releasePet(playerId) {
    if (!playerPets[playerId]) return false;
    delete playerPets[playerId];
    return true;
  }

  /**
   * Get pet mood description
   * @param {Object} pet - Pet object
   * @returns {string} Mood description
   */
  function getPetMood(pet) {
    if (!pet) return 'unknown';

    if (pet.hunger > 70) {
      return 'starving';
    } else if (pet.hunger > 50) {
      return 'hungry';
    }

    if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_ECSTATIC) {
      return 'ecstatic';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_HAPPY) {
      return 'happy';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_CONTENT) {
      return 'content';
    } else if (pet.mood >= PET_CONSTANTS.MOOD_THRESHOLD_HUNGRY) {
      return 'sad';
    } else {
      return 'depressed';
    }
  }

  /**
   * Get mood emoji indicator
   * @param {string} mood - Mood string
   * @returns {string} Emoji representing mood
   */
  function getMoodEmoji(mood) {
    const moodEmojis = {
      'ecstatic': 'ðŸ˜„',
      'happy': 'ðŸ˜Š',
      'content': 'ðŸ™‚',
      'sad': 'ðŸ˜Ÿ',
      'hungry': 'ðŸ˜«',
      'starving': 'ðŸ˜µ',
      'depressed': 'ðŸ˜¢',
      'unknown': 'ðŸ˜'
    };
    return moodEmojis[mood] || moodEmojis['unknown'];
  }

  /**
   * Get bonus description
   * @param {string} bonusType - Type of bonus
   * @param {number} value - Bonus value
   * @returns {string} Description
   */
  function getBonusDescription(bonusType, value) {
    const descriptions = {
      'trade_luck': `+${value.toFixed(1)}% trade success`,
      'discovery_range': `+${value.toFixed(1)}% discovery radius`,
      'lore_unlock': `+${value.toFixed(1)}% lore unlock chance`,
      'garden_growth': `+${value.toFixed(1)}% garden growth rate`,
      'craft_speed': `+${value.toFixed(1)}% crafting speed`,
      'rare_resources': `+${value.toFixed(1)}% rare resource chance`,
      'vision_range': `+${value.toFixed(1)}% vision range`,
      'stamina': `+${value.toFixed(1)}% stamina`,
      'resilience': `+${value.toFixed(1)}% resilience`,
      'meditation': `+${value.toFixed(1)}% meditation effectiveness`
    };
    return descriptions[bonusType] || 'Unknown bonus';
  }

  /**
   * Generate unique pet ID
   * @returns {string} Unique ID
   */
  function generatePetId() {
    return 'pet_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Get all pet types
   * @returns {Array} All pet types
   */
  function getAllPetTypes() {
    return PET_TYPES;
  }

  /**
   * Get pet type data
   * @param {string} petTypeId - Pet type ID
   * @returns {Object|null} Pet type data or null
   */
  function getPetTypeData(petTypeId) {
    return PET_TYPES.find(p => p.id === petTypeId) || null;
  }

  /**
   * Initialize pets system with saved data
   * @param {object} existingData - Previously saved pets data
   */
  function initPets(existingData) {
    if (!existingData) return;

    // Clear current state
    var pids = Object.keys(playerPets);
    for (var i = 0; i < pids.length; i++) {
      delete playerPets[pids[i]];
    }

    // Restore saved pets
    var saved = existingData.playerPets || {};
    var keys = Object.keys(saved);
    for (var j = 0; j < keys.length; j++) {
      playerPets[keys[j]] = saved[keys[j]];
    }

    console.log('Pets initialized:', keys.length, 'players with pets');
  }

  /**
   * Get pets state for saving
   * @returns {object} Serializable pets state
   */
  function getPetsState() {
    return {
      playerPets: playerPets
    };
  }

  // Export public API
  exports.PET_TYPES = PET_TYPES;
  exports.getAvailablePets = getAvailablePets;
  exports.adoptPet = adoptPet;
  exports.getPlayerPet = getPlayerPet;
  exports.feedPet = feedPet;
  exports.updatePet = updatePet;
  exports.getPetBonus = getPetBonus;
  exports.renamePet = renamePet;
  exports.releasePet = releasePet;
  exports.getPetMood = getPetMood;
  exports.getMoodEmoji = getMoodEmoji;
  exports.getAllPetTypes = getAllPetTypes;
  exports.getPetTypeData = getPetTypeData;
  exports.initPets = initPets;
  exports.getPetsState = getPetsState;

})(typeof module !== 'undefined' ? module.exports : (window.Pets = {}));


// fast_travel.js
// fast_travel.js â€” Fast Travel system for ZION
// Allows players to quickly teleport to zones, POIs, bookmarks, and recent locations
(function(exports) {
  'use strict';

  // Zone waypoints: canonical centers matching zone definitions in zones.js
  // nexus(0,0), gardens(200,30), athenaeum(100,-220), studio(-200,-100),
  // wilds(-30,260), agora(-190,120), commons(170,190), arena(0,-240)
  var ZONE_WAYPOINTS = [
    {
      id: 'zone_nexus',
      name: 'The Nexus',
      zone: 'nexus',
      x: 0,
      z: 0,
      category: 'zone',
      description: 'The central hub connecting all realms.',
      safe: true,
      icon: 'hub'
    },
    {
      id: 'zone_gardens',
      name: 'The Gardens',
      zone: 'gardens',
      x: 200,
      z: 30,
      category: 'zone',
      description: 'Lush botanical gardens filled with herbs and flowers.',
      safe: true,
      icon: 'nature'
    },
    {
      id: 'zone_athenaeum',
      name: 'The Athenaeum',
      zone: 'athenaeum',
      x: 100,
      z: -220,
      category: 'zone',
      description: 'A grand library and hall of learning.',
      safe: true,
      icon: 'school'
    },
    {
      id: 'zone_studio',
      name: 'The Studio',
      zone: 'studio',
      x: -200,
      z: -100,
      category: 'zone',
      description: 'A creative workshop for artists and craftspeople.',
      safe: true,
      icon: 'palette'
    },
    {
      id: 'zone_wilds',
      name: 'The Wilds',
      zone: 'wilds',
      x: -30,
      z: 260,
      category: 'zone',
      description: 'Untamed wilderness filled with rare resources.',
      safe: false,
      icon: 'forest'
    },
    {
      id: 'zone_agora',
      name: 'The Agora',
      zone: 'agora',
      x: -190,
      z: 120,
      category: 'zone',
      description: 'A bustling marketplace for trading.',
      safe: true,
      icon: 'store'
    },
    {
      id: 'zone_commons',
      name: 'The Commons',
      zone: 'commons',
      x: 170,
      z: 190,
      category: 'zone',
      description: 'A collaborative building space.',
      safe: true,
      icon: 'build'
    },
    {
      id: 'zone_arena',
      name: 'The Arena',
      zone: 'arena',
      x: 0,
      z: -240,
      category: 'zone',
      description: 'A proving ground for competitive challenges.',
      safe: false,
      icon: 'sports'
    }
  ];

  // Static POIs â€” portals, anchors, notable gardens in the world
  var STATIC_POIS = [
    // Nexus portals
    {
      id: 'poi_nexus_portal_gardens',
      name: 'Nexus Portal to Gardens',
      zone: 'nexus',
      x: 60,
      z: 20,
      category: 'portal',
      description: 'A shimmering gateway leading to The Gardens.',
      safe: true,
      icon: 'portal'
    },
    {
      id: 'poi_nexus_portal_athenaeum',
      name: 'Nexus Portal to Athenaeum',
      zone: 'nexus',
      x: -60,
      z: -30,
      category: 'portal',
      description: 'An archway of light leading to The Athenaeum.',
      safe: true,
      icon: 'portal'
    },
    {
      id: 'poi_nexus_portal_studio',
      name: 'Nexus Portal to Studio',
      zone: 'nexus',
      x: -50,
      z: 40,
      category: 'portal',
      description: 'A glowing doorway to The Studio.',
      safe: true,
      icon: 'portal'
    },
    // Garden anchors
    {
      id: 'poi_gardens_anchor_north',
      name: 'Northern Garden Anchor',
      zone: 'gardens',
      x: 220,
      z: -80,
      category: 'anchor',
      description: 'A crystalline anchor marking the northern gardens.',
      safe: true,
      icon: 'anchor'
    },
    {
      id: 'poi_gardens_anchor_east',
      name: 'Eastern Garden Anchor',
      zone: 'gardens',
      x: 350,
      z: 50,
      category: 'anchor',
      description: 'An anchor at the edge of the cultivated lands.',
      safe: true,
      icon: 'anchor'
    },
    // Notable gardens
    {
      id: 'poi_gardens_herb_garden',
      name: 'The Great Herb Garden',
      zone: 'gardens',
      x: 200,
      z: 80,
      category: 'garden',
      description: 'A famous plot of rare herbs tended by generations of gardeners.',
      safe: true,
      icon: 'grass'
    },
    {
      id: 'poi_gardens_bloom_circle',
      name: 'The Bloom Circle',
      zone: 'gardens',
      x: 170,
      z: -10,
      category: 'garden',
      description: 'A ring of perpetually blooming flowers.',
      safe: true,
      icon: 'local_florist'
    },
    // Wilds anchors
    {
      id: 'poi_wilds_anchor_peak',
      name: 'Peak Anchor',
      zone: 'wilds',
      x: -30,
      z: 320,
      category: 'anchor',
      description: 'An anchor at the summit marking a high vantage point.',
      safe: false,
      icon: 'anchor'
    },
    // Agora notable spots
    {
      id: 'poi_agora_grand_market',
      name: 'The Grand Market',
      zone: 'agora',
      x: -190,
      z: 150,
      category: 'portal',
      description: 'The main market entrance with the best merchants.',
      safe: true,
      icon: 'shopping_cart'
    }
  ];

  // Travel cost constants
  var FREE_TRAVEL_RADIUS = 150;   // units â€” travel within this distance is free
  var COST_PER_100_UNITS = 1;     // Spark per 100 units beyond free radius
  var MAX_BOOKMARKS = 10;
  var MAX_RECENT_LOCATIONS = 5;

  // Per-player state storage (in-memory for module; state.js manages persistence)
  var playerBookmarks = {};     // playerId -> Array of bookmark objects
  var playerRecent = {};        // playerId -> Array of recent location objects
  var panelState = {
    visible: false,
    activeCategory: 'zone',
    searchQuery: ''
  };

  // â”€â”€â”€ Distance helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Calculate 2D Euclidean distance between two (x,z) positions.
   * @param {number} x1
   * @param {number} z1
   * @param {number} x2
   * @param {number} z2
   * @returns {number}
   */
  function distance(x1, z1, x2, z2) {
    var dx = x2 - x1;
    var dz = z2 - z1;
    return Math.sqrt(dx * dx + dz * dz);
  }

  // â”€â”€â”€ Zone Waypoints â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get all zone waypoints.
   * @returns {Array} Array of zone waypoint destination objects.
   */
  function getZoneWaypoints() {
    return ZONE_WAYPOINTS.slice();
  }

  // â”€â”€â”€ Bookmarks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get bookmarks for a player.
   * @param {string} playerId
   * @returns {Array}
   */
  function getBookmarks(playerId) {
    if (!playerBookmarks[playerId]) {
      playerBookmarks[playerId] = [];
    }
    return playerBookmarks[playerId].slice();
  }

  /**
   * Add a bookmark for a player. Max 10 bookmarks allowed.
   * @param {string} playerId
   * @param {Object} dest - Destination object {id, name, x, z, zone, category, ...}
   * @returns {Object} {success: boolean, error?: string}
   */
  function addBookmark(playerId, dest) {
    if (!playerId || typeof playerId !== 'string') {
      return { success: false, error: 'Invalid playerId' };
    }
    if (!dest || typeof dest !== 'object') {
      return { success: false, error: 'Invalid destination' };
    }
    if (!dest.id || !dest.name || typeof dest.x !== 'number' || typeof dest.z !== 'number') {
      return { success: false, error: 'Destination missing required fields (id, name, x, z)' };
    }

    if (!playerBookmarks[playerId]) {
      playerBookmarks[playerId] = [];
    }

    var bookmarks = playerBookmarks[playerId];

    // Check for duplicate
    for (var i = 0; i < bookmarks.length; i++) {
      if (bookmarks[i].id === dest.id) {
        return { success: false, error: 'Destination already bookmarked' };
      }
    }

    // Enforce max
    if (bookmarks.length >= MAX_BOOKMARKS) {
      return { success: false, error: 'Bookmark limit reached (max ' + MAX_BOOKMARKS + ')' };
    }

    var bookmark = {
      id: dest.id,
      name: dest.name,
      zone: dest.zone || 'nexus',
      x: dest.x,
      z: dest.z,
      category: 'bookmark',
      description: dest.description || '',
      safe: dest.safe !== undefined ? dest.safe : true,
      icon: 'bookmark',
      addedAt: Date.now()
    };

    bookmarks.push(bookmark);
    return { success: true, bookmark: bookmark };
  }

  /**
   * Remove a bookmark for a player by destination id.
   * @param {string} playerId
   * @param {string} destId
   * @returns {Object} {success: boolean, error?: string}
   */
  function removeBookmark(playerId, destId) {
    if (!playerId || typeof playerId !== 'string') {
      return { success: false, error: 'Invalid playerId' };
    }
    if (!destId || typeof destId !== 'string') {
      return { success: false, error: 'Invalid destId' };
    }

    if (!playerBookmarks[playerId]) {
      return { success: false, error: 'Bookmark not found' };
    }

    var bookmarks = playerBookmarks[playerId];
    var idx = -1;
    for (var i = 0; i < bookmarks.length; i++) {
      if (bookmarks[i].id === destId) {
        idx = i;
        break;
      }
    }

    if (idx === -1) {
      return { success: false, error: 'Bookmark not found' };
    }

    bookmarks.splice(idx, 1);
    return { success: true };
  }

  // â”€â”€â”€ Recent Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get recent locations for a player (last 5).
   * @param {string} playerId
   * @returns {Array}
   */
  function getRecentLocations(playerId) {
    if (!playerRecent[playerId]) {
      playerRecent[playerId] = [];
    }
    return playerRecent[playerId].slice();
  }

  /**
   * Add a location to a player's recent history.
   * Keeps only the last MAX_RECENT_LOCATIONS entries.
   * Does not add duplicates for the same destination id.
   * @param {string} playerId
   * @param {Object} dest - Destination object {id, name, x, z, zone, ...}
   * @returns {boolean} True if added successfully
   */
  function addRecentLocation(playerId, dest) {
    if (!playerId || typeof playerId !== 'string') return false;
    if (!dest || !dest.id || !dest.name || typeof dest.x !== 'number' || typeof dest.z !== 'number') {
      return false;
    }

    if (!playerRecent[playerId]) {
      playerRecent[playerId] = [];
    }

    var recent = playerRecent[playerId];

    // Remove existing entry with same id (will be re-added at front)
    for (var i = recent.length - 1; i >= 0; i--) {
      if (recent[i].id === dest.id) {
        recent.splice(i, 1);
        break;
      }
    }

    var entry = {
      id: dest.id,
      name: dest.name,
      zone: dest.zone || 'nexus',
      x: dest.x,
      z: dest.z,
      category: 'recent',
      description: dest.description || '',
      safe: dest.safe !== undefined ? dest.safe : true,
      icon: 'history',
      visitedAt: Date.now()
    };

    // Prepend (most recent first)
    recent.unshift(entry);

    // Trim to max
    if (recent.length > MAX_RECENT_LOCATIONS) {
      recent.length = MAX_RECENT_LOCATIONS;
    }

    return true;
  }

  // â”€â”€â”€ POIs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get POIs within a given radius of (x, z).
   * @param {number} x
   * @param {number} z
   * @param {number} radius
   * @returns {Array} POIs within radius, sorted by distance ascending.
   */
  function getNearbyPOIs(x, z, radius) {
    if (typeof x !== 'number' || typeof z !== 'number' || typeof radius !== 'number') {
      return [];
    }
    var results = [];
    for (var i = 0; i < STATIC_POIS.length; i++) {
      var poi = STATIC_POIS[i];
      var d = distance(x, z, poi.x, poi.z);
      if (d <= radius) {
        results.push({ dest: poi, distance: d });
      }
    }
    results.sort(function(a, b) { return a.distance - b.distance; });
    return results.map(function(r) { return r.dest; });
  }

  // â”€â”€â”€ Travel Cost â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Calculate the Spark cost to travel from one position to a destination.
   * Free within FREE_TRAVEL_RADIUS units. Beyond that: 1 Spark per 100 units.
   * @param {Object} from - {x, z} current position
   * @param {Object} to   - {x, z} destination
   * @returns {number} Cost in Spark (0 or positive integer)
   */
  function calculateTravelCost(from, to) {
    if (!from || typeof from.x !== 'number' || typeof from.z !== 'number') return 0;
    if (!to || typeof to.x !== 'number' || typeof to.z !== 'number') return 0;

    var dist = distance(from.x, from.z, to.x, to.z);
    if (dist <= FREE_TRAVEL_RADIUS) {
      return 0;
    }

    var beyond = dist - FREE_TRAVEL_RADIUS;
    var cost = Math.ceil(beyond / 100) * COST_PER_100_UNITS;
    return cost;
  }

  // â”€â”€â”€ Can Travel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Check whether a player can execute fast travel from their current position.
   * @param {string} playerId
   * @param {Object} economy - Economy ledger object with getBalance function available
   *                           OR object with balances map (for direct balance lookup)
   * @param {Object} from   - {x, z} current position
   * @param {Object} to     - {x, z} destination
   * @returns {Object} {allowed: boolean, cost: number, error?: string}
   */
  function canTravel(playerId, economy, from, to) {
    if (!playerId || typeof playerId !== 'string') {
      return { allowed: false, cost: 0, error: 'Invalid playerId' };
    }
    if (!from || typeof from.x !== 'number' || typeof from.z !== 'number') {
      return { allowed: false, cost: 0, error: 'Invalid origin position' };
    }
    if (!to || typeof to.x !== 'number' || typeof to.z !== 'number') {
      return { allowed: false, cost: 0, error: 'Invalid destination position' };
    }

    var cost = calculateTravelCost(from, to);

    if (cost === 0) {
      return { allowed: true, cost: 0 };
    }

    // Check player balance
    var balance = 0;
    if (economy) {
      if (typeof economy.getBalance === 'function') {
        // Economy module API
        balance = economy.getBalance(economy.ledger || economy, playerId);
      } else if (economy.balances) {
        // Direct ledger object
        balance = economy.balances[playerId] || 0;
      }
    }

    if (balance < cost) {
      return {
        allowed: false,
        cost: cost,
        error: 'Insufficient Spark (need ' + cost + ', have ' + balance + ')'
      };
    }

    return { allowed: true, cost: cost };
  }

  // â”€â”€â”€ Execute Fast Travel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Execute fast travel and return a warp protocol message.
   * Does NOT deduct Spark â€” caller must handle economy deduction.
   * Also records the destination in recent locations.
   * @param {string} playerId
   * @param {Object} dest - Destination object {id, name, x, z, zone, ...}
   * @param {Object} currentPos - {x, y, z, zone} current player position
   * @returns {Object} Warp protocol message ready to broadcast
   */
  function executeFastTravel(playerId, dest, currentPos) {
    if (!playerId || typeof playerId !== 'string') {
      throw new Error('Invalid playerId');
    }
    if (!dest || typeof dest.x !== 'number' || typeof dest.z !== 'number') {
      throw new Error('Invalid destination');
    }

    var pos = currentPos || { x: 0, y: 0, z: 0, zone: 'nexus' };

    // Record in recent locations
    addRecentLocation(playerId, dest);

    // Build warp protocol message (follows protocol.js message shape)
    var warpMsg = {
      v: 1,
      id: _generateId(),
      ts: new Date().toISOString(),
      seq: 0,
      from: playerId,
      type: 'warp',
      platform: 'desktop',
      position: {
        x: pos.x || 0,
        y: pos.y || 0,
        z: pos.z || 0,
        zone: pos.zone || 'nexus'
      },
      geo: null,
      payload: {
        destination_id: dest.id,
        destination_name: dest.name,
        destination_zone: dest.zone || 'nexus',
        destination_x: dest.x,
        destination_z: dest.z,
        category: dest.category || 'zone',
        fast_travel: true
      }
    };

    return warpMsg;
  }

  // Simple id generator (not crypto-quality, fine for fast travel)
  function _generateId() {
    return 'ft_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
  }

  // â”€â”€â”€ Available Destinations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get all available destinations for a player.
   * Combines zone waypoints, POIs, bookmarks, and recent locations.
   * @param {Object} playerData - {id, position: {x,z}}
   * @returns {Array} All destinations with distance metadata
   */
  function getAvailableDestinations(playerData) {
    if (!playerData || !playerData.id) return [];

    var px = (playerData.position && typeof playerData.position.x === 'number') ? playerData.position.x : 0;
    var pz = (playerData.position && typeof playerData.position.z === 'number') ? playerData.position.z : 0;

    var allDests = [];

    // Zone waypoints
    var zones = getZoneWaypoints();
    for (var i = 0; i < zones.length; i++) {
      var z = zones[i];
      allDests.push(_attachMeta(z, px, pz));
    }

    // Static POIs
    for (var j = 0; j < STATIC_POIS.length; j++) {
      var poi = STATIC_POIS[j];
      allDests.push(_attachMeta(poi, px, pz));
    }

    // Player bookmarks
    var bookmarks = getBookmarks(playerData.id);
    for (var k = 0; k < bookmarks.length; k++) {
      allDests.push(_attachMeta(bookmarks[k], px, pz));
    }

    // Recent locations (deduplicated by id)
    var recent = getRecentLocations(playerData.id);
    var seenIds = {};
    for (var l = 0; l < allDests.length; l++) {
      seenIds[allDests[l].id] = true;
    }
    for (var m = 0; m < recent.length; m++) {
      if (!seenIds[recent[m].id]) {
        allDests.push(_attachMeta(recent[m], px, pz));
        seenIds[recent[m].id] = true;
      }
    }

    return allDests;
  }

  /**
   * Attach distance and cost metadata to a destination object.
   * @param {Object} dest
   * @param {number} fromX
   * @param {number} fromZ
   * @returns {Object} Copy of dest with distance and travelCost fields
   */
  function _attachMeta(dest, fromX, fromZ) {
    var dist = distance(fromX, fromZ, dest.x, dest.z);
    var cost = calculateTravelCost({ x: fromX, z: fromZ }, { x: dest.x, z: dest.z });
    return {
      id: dest.id,
      name: dest.name,
      zone: dest.zone,
      x: dest.x,
      z: dest.z,
      category: dest.category,
      description: dest.description || '',
      safe: dest.safe !== undefined ? dest.safe : true,
      icon: dest.icon || 'place',
      addedAt: dest.addedAt,
      visitedAt: dest.visitedAt,
      distance: Math.round(dist),
      travelCost: cost
    };
  }

  // â”€â”€â”€ Search & Sort â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Search destinations by name or description (case-insensitive).
   * @param {string} query
   * @param {Array} available - Array returned by getAvailableDestinations
   * @returns {Array} Filtered destinations matching query
   */
  function searchDestinations(query, available) {
    if (!query || typeof query !== 'string' || query.trim() === '') {
      return available ? available.slice() : [];
    }
    if (!available || !Array.isArray(available)) return [];

    var q = query.toLowerCase().trim();
    return available.filter(function(dest) {
      var nameMatch = dest.name && dest.name.toLowerCase().indexOf(q) !== -1;
      var descMatch = dest.description && dest.description.toLowerCase().indexOf(q) !== -1;
      var zoneMatch = dest.zone && dest.zone.toLowerCase().indexOf(q) !== -1;
      var catMatch = dest.category && dest.category.toLowerCase().indexOf(q) !== -1;
      return nameMatch || descMatch || zoneMatch || catMatch;
    });
  }

  /**
   * Sort destinations by distance from player (ascending).
   * @param {Array} dests - Array of destination objects with .distance field
   * @returns {Array} New sorted array
   */
  function sortByDistance(dests) {
    if (!dests || !Array.isArray(dests)) return [];
    return dests.slice().sort(function(a, b) {
      return (a.distance || 0) - (b.distance || 0);
    });
  }

  /**
   * Sort destinations by category then by name.
   * Category order: zone, portal, anchor, garden, bookmark, recent
   * @param {Array} dests
   * @returns {Array} New sorted array
   */
  function sortByCategory(dests) {
    if (!dests || !Array.isArray(dests)) return [];
    var categoryOrder = { zone: 0, portal: 1, anchor: 2, garden: 3, bookmark: 4, recent: 5 };
    return dests.slice().sort(function(a, b) {
      var ca = categoryOrder[a.category] !== undefined ? categoryOrder[a.category] : 99;
      var cb = categoryOrder[b.category] !== undefined ? categoryOrder[b.category] : 99;
      if (ca !== cb) return ca - cb;
      return (a.name || '').localeCompare(b.name || '');
    });
  }

  // â”€â”€â”€ Formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get a human-readable category icon string for a destination.
   * @param {string} category
   * @returns {string}
   */
  function getCategoryIcon(category) {
    var icons = {
      zone: 'hub',
      portal: 'trip_origin',
      anchor: 'anchor',
      garden: 'local_florist',
      bookmark: 'bookmark',
      recent: 'history'
    };
    return icons[category] || 'place';
  }

  /**
   * Format a destination for display in the HUD panel.
   * @param {Object} dest
   * @returns {Object} Formatted display object
   */
  function formatDestination(dest) {
    if (!dest) return null;

    var costStr = dest.travelCost === 0 ? 'Free' : dest.travelCost + ' Spark';
    var distStr = dest.distance !== undefined ? dest.distance + ' units away' : '';
    var safeStr = dest.safe === false ? ' (Danger)' : '';

    return {
      id: dest.id,
      displayName: dest.name + safeStr,
      zoneName: _zoneDisplayName(dest.zone),
      category: dest.category,
      categoryIcon: getCategoryIcon(dest.category),
      description: dest.description || '',
      costLabel: costStr,
      distanceLabel: distStr,
      safe: dest.safe !== undefined ? dest.safe : true,
      x: dest.x,
      z: dest.z
    };
  }

  function _zoneDisplayName(zoneId) {
    var names = {
      nexus: 'The Nexus',
      gardens: 'The Gardens',
      athenaeum: 'The Athenaeum',
      studio: 'The Studio',
      wilds: 'The Wilds',
      agora: 'The Agora',
      commons: 'The Commons',
      arena: 'The Arena'
    };
    return names[zoneId] || zoneId;
  }

  // â”€â”€â”€ HUD Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Show the fast travel panel. Returns the panel data needed to render the UI.
   * @param {Object} playerData - {id, position: {x,z}}
   * @param {string} [category] - Initial category tab ('zone', 'portal', 'anchor', 'garden', 'bookmark', 'recent', 'all')
   * @returns {Object} Panel data {visible, category, destinations, categories, tabs}
   */
  function showFastTravelPanel(playerData, category) {
    panelState.visible = true;
    panelState.activeCategory = category || 'zone';
    panelState.searchQuery = '';

    var allDests = getAvailableDestinations(playerData);
    var filtered = _filterByCategory(allDests, panelState.activeCategory);
    var sorted = sortByDistance(filtered);

    var categories = _getAvailableCategories(allDests);

    return {
      visible: true,
      activeCategory: panelState.activeCategory,
      searchQuery: '',
      destinations: sorted.map(function(d) { return formatDestination(d); }),
      allDestinations: allDests,
      categories: categories,
      tabs: _buildTabs(allDests)
    };
  }

  /**
   * Hide the fast travel panel. Resets panel state.
   * @returns {Object} {visible: false}
   */
  function hideFastTravelPanel() {
    panelState.visible = false;
    panelState.searchQuery = '';
    return { visible: false };
  }

  /**
   * Get current panel state.
   * @returns {Object}
   */
  function getPanelState() {
    return {
      visible: panelState.visible,
      activeCategory: panelState.activeCategory,
      searchQuery: panelState.searchQuery
    };
  }

  /**
   * Switch the active category tab in the panel.
   * @param {string} category
   * @param {Object} playerData
   * @returns {Object} Updated panel data
   */
  function switchCategory(category, playerData) {
    panelState.activeCategory = category;
    var allDests = getAvailableDestinations(playerData);
    var filtered = _filterByCategory(allDests, category);
    var sorted = sortByDistance(filtered);
    return {
      visible: panelState.visible,
      activeCategory: category,
      searchQuery: panelState.searchQuery,
      destinations: sorted.map(function(d) { return formatDestination(d); }),
      categories: _getAvailableCategories(allDests),
      tabs: _buildTabs(allDests)
    };
  }

  /**
   * Perform a live search within the panel.
   * @param {string} query
   * @param {Object} playerData
   * @returns {Object} Updated panel data
   */
  function searchPanel(query, playerData) {
    panelState.searchQuery = query;
    var allDests = getAvailableDestinations(playerData);
    var filtered = query && query.trim() !== ''
      ? searchDestinations(query, allDests)
      : _filterByCategory(allDests, panelState.activeCategory);
    var sorted = sortByDistance(filtered);
    return {
      visible: panelState.visible,
      activeCategory: panelState.activeCategory,
      searchQuery: query,
      destinations: sorted.map(function(d) { return formatDestination(d); }),
      categories: _getAvailableCategories(allDests),
      tabs: _buildTabs(allDests)
    };
  }

  function _filterByCategory(dests, category) {
    if (!category || category === 'all') return dests;
    return dests.filter(function(d) { return d.category === category; });
  }

  function _getAvailableCategories(dests) {
    var seen = {};
    var cats = [];
    for (var i = 0; i < dests.length; i++) {
      var cat = dests[i].category;
      if (cat && !seen[cat]) {
        seen[cat] = true;
        cats.push(cat);
      }
    }
    return cats;
  }

  function _buildTabs(allDests) {
    var categoryOrder = ['all', 'zone', 'portal', 'anchor', 'garden', 'bookmark', 'recent'];
    var counts = { all: allDests.length };
    for (var i = 0; i < allDests.length; i++) {
      var cat = allDests[i].category;
      counts[cat] = (counts[cat] || 0) + 1;
    }
    var tabs = [];
    for (var j = 0; j < categoryOrder.length; j++) {
      var c = categoryOrder[j];
      if (counts[c] !== undefined) {
        tabs.push({
          category: c,
          label: _categoryLabel(c),
          count: counts[c],
          icon: getCategoryIcon(c)
        });
      }
    }
    return tabs;
  }

  function _categoryLabel(category) {
    var labels = {
      all: 'All',
      zone: 'Zones',
      portal: 'Portals',
      anchor: 'Anchors',
      garden: 'Gardens',
      bookmark: 'Bookmarks',
      recent: 'Recent'
    };
    return labels[category] || category;
  }

  // â”€â”€â”€ Constants export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Expose constants for testing
  var FREE_TRAVEL_RADIUS_EXPORT = FREE_TRAVEL_RADIUS;
  var COST_PER_100_UNITS_EXPORT = COST_PER_100_UNITS;
  var MAX_BOOKMARKS_EXPORT = MAX_BOOKMARKS;
  var MAX_RECENT_LOCATIONS_EXPORT = MAX_RECENT_LOCATIONS;

  // â”€â”€â”€ Internal reset (for tests) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function _resetState() {
    playerBookmarks = {};
    playerRecent = {};
    panelState.visible = false;
    panelState.activeCategory = 'zone';
    panelState.searchQuery = '';
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  exports.ZONE_WAYPOINTS = ZONE_WAYPOINTS;
  exports.STATIC_POIS = STATIC_POIS;
  exports.FREE_TRAVEL_RADIUS = FREE_TRAVEL_RADIUS_EXPORT;
  exports.COST_PER_100_UNITS = COST_PER_100_UNITS_EXPORT;
  exports.MAX_BOOKMARKS = MAX_BOOKMARKS_EXPORT;
  exports.MAX_RECENT_LOCATIONS = MAX_RECENT_LOCATIONS_EXPORT;

  exports.distance = distance;
  exports.getZoneWaypoints = getZoneWaypoints;
  exports.getBookmarks = getBookmarks;
  exports.addBookmark = addBookmark;
  exports.removeBookmark = removeBookmark;
  exports.getRecentLocations = getRecentLocations;
  exports.addRecentLocation = addRecentLocation;
  exports.getNearbyPOIs = getNearbyPOIs;
  exports.calculateTravelCost = calculateTravelCost;
  exports.canTravel = canTravel;
  exports.executeFastTravel = executeFastTravel;
  exports.getAvailableDestinations = getAvailableDestinations;
  exports.searchDestinations = searchDestinations;
  exports.sortByDistance = sortByDistance;
  exports.sortByCategory = sortByCategory;
  exports.formatDestination = formatDestination;
  exports.getCategoryIcon = getCategoryIcon;
  exports.showFastTravelPanel = showFastTravelPanel;
  exports.hideFastTravelPanel = hideFastTravelPanel;
  exports.getPanelState = getPanelState;
  exports.switchCategory = switchCategory;
  exports.searchPanel = searchPanel;
  exports._resetState = _resetState;

})(typeof module !== 'undefined' ? module.exports : (window.FastTravel = {}));


// music_composer.js
// music_composer.js
/**
 * ZION Music Composer â€” procedural sequencer / piano-roll
 * Vanilla JS, UMD pattern, var only (ES5-compatible)
 * No project dependencies â€” pure data & logic only.
 */
(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Note frequency table â€” C3 through C6, naturals + sharps
  // ---------------------------------------------------------------------------
  var NOTE_FREQUENCIES = {
    // Octave 3
    'C3':  130.81, 'C#3': 138.59, 'D3':  146.83, 'D#3': 155.56,
    'E3':  164.81, 'F3':  174.61, 'F#3': 185.00, 'G3':  196.00,
    'G#3': 207.65, 'A3':  220.00, 'A#3': 233.08, 'B3':  246.94,
    // Octave 4
    'C4':  261.63, 'C#4': 277.18, 'D4':  293.66, 'D#4': 311.13,
    'E4':  329.63, 'F4':  349.23, 'F#4': 369.99, 'G4':  392.00,
    'G#4': 415.30, 'A4':  440.00, 'A#4': 466.16, 'B4':  493.88,
    // Octave 5
    'C5':  523.25, 'C#5': 554.37, 'D5':  587.33, 'D#5': 622.25,
    'E5':  659.25, 'F5':  698.46, 'F#5': 739.99, 'G5':  783.99,
    'G#5': 830.61, 'A5':  880.00, 'A#5': 932.33, 'B5':  987.77,
    // Octave 6 (root only)
    'C6': 1046.50
  };

  // Flat aliases â†’ map to their sharp equivalents
  var FLAT_ALIASES = {
    'Db3':'C#3','Eb3':'D#3','Fb3':'E3','Gb3':'F#3','Ab3':'G#3','Bb3':'A#3','Cb3':'B3',
    'Db4':'C#4','Eb4':'D#4','Fb4':'E4','Gb4':'F#4','Ab4':'G#4','Bb4':'A#4','Cb4':'B4',
    'Db5':'C#5','Eb5':'D#5','Fb5':'E5','Gb5':'F#5','Ab5':'G#5','Bb5':'A#5','Cb5':'B5'
  };

  // Merge flat aliases into NOTE_FREQUENCIES so callers can use either notation
  for (var flatKey in FLAT_ALIASES) {
    NOTE_FREQUENCIES[flatKey] = NOTE_FREQUENCIES[FLAT_ALIASES[flatKey]];
  }

  // ---------------------------------------------------------------------------
  // Instruments
  // ---------------------------------------------------------------------------
  var INSTRUMENTS = {
    piano:   { name: 'Piano',   type: 'keyboard', waveform: 'triangle', attack: 0.01, decay: 0.3,  sustain: 0.7, release: 0.5 },
    strings: { name: 'Strings', type: 'bowed',    waveform: 'sawtooth', attack: 0.15, decay: 0.1,  sustain: 0.8, release: 0.8 },
    flute:   { name: 'Flute',   type: 'wind',     waveform: 'sine',     attack: 0.05, decay: 0.1,  sustain: 0.9, release: 0.3 },
    drums:   { name: 'Drums',   type: 'percussive',waveform: 'noise',   attack: 0.001,decay: 0.2,  sustain: 0.0, release: 0.1 },
    synth:   { name: 'Synth',   type: 'electronic',waveform: 'square',  attack: 0.02, decay: 0.15, sustain: 0.6, release: 0.4 },
    bell:    { name: 'Bell',    type: 'metallic',  waveform: 'sine',    attack: 0.001,decay: 1.2,  sustain: 0.2, release: 2.0 }
  };

  // ---------------------------------------------------------------------------
  // Scales â€” intervals in semitones from root
  // ---------------------------------------------------------------------------
  var SCALES = {
    major:       [0, 2, 4, 5, 7, 9, 11],
    minor:       [0, 2, 3, 5, 7, 8, 10],
    pentatonic:  [0, 2, 4, 7, 9],
    blues:       [0, 3, 5, 6, 7, 10],
    dorian:      [0, 2, 3, 5, 7, 9, 10],
    mixolydian:  [0, 2, 4, 5, 7, 9, 10]
  };

  // Chromatic note names (sharps) â€” used for transposition arithmetic
  var CHROMATIC = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

  // ---------------------------------------------------------------------------
  // Internal helpers
  // ---------------------------------------------------------------------------

  /**
   * Parse a note string like 'C#4' â†’ { name:'C#', octave:4, semitone:0..11 }
   * Returns null for drum labels (e.g. 'kick', 'snare').
   */
  function parseNote(noteStr) {
    var m = noteStr.match(/^([A-G][#b]?)(\d)$/);
    if (!m) return null;
    var name = m[1];
    var octave = parseInt(m[2], 10);
    // Normalise flat â†’ sharp
    var sharpName = name;
    var flatToSharp = { 'Db':'C#','Eb':'D#','Fb':'E','Gb':'F#','Ab':'G#','Bb':'A#','Cb':'B' };
    if (flatToSharp[name]) sharpName = flatToSharp[name];
    var semitone = CHROMATIC.indexOf(sharpName);
    if (semitone === -1) return null;
    return { name: sharpName, octave: octave, semitone: semitone };
  }

  /**
   * Reconstruct a note string from semitone + octave.
   */
  function buildNote(semitone, octave) {
    return CHROMATIC[semitone] + octave;
  }

  /**
   * Transpose a single note string by `semitones` steps.
   * Returns null if the resulting note is out of the C3-C6 range.
   */
  function transposeNote(noteStr, semitones) {
    var parsed = parseNote(noteStr);
    if (!parsed) return noteStr; // pass-through for drum labels
    var total = parsed.octave * 12 + parsed.semitone + semitones;
    var newOctave = Math.floor(total / 12);
    var newSemitone = ((total % 12) + 12) % 12;
    // Clamp to octave range 3â€“6
    if (newOctave < 3) { newOctave = 3; }
    if (newOctave > 6) { newOctave = 6; }
    return buildNote(newSemitone, newOctave);
  }

  /**
   * Simple seeded pseudo-random for deterministic generation.
   * Returns a float [0, 1).
   */
  function seededRand(seed) {
    var x = Math.sin(seed + 1) * 43758.5453123;
    return x - Math.floor(x);
  }

  // ---------------------------------------------------------------------------
  // Unique-ID counter
  // ---------------------------------------------------------------------------
  var _idCounter = 0;
  function nextId(prefix) {
    _idCounter += 1;
    return (prefix || 'id') + '_' + _idCounter;
  }

  // ---------------------------------------------------------------------------
  // Composition factory
  // ---------------------------------------------------------------------------

  /**
   * Create a new composition.
   * @param {string} name
   * @param {number} tempo â€” BPM, clamped to 60-240
   * @param {Array}  timeSignature â€” [beats, noteValue] e.g. [4, 4]
   * @returns {Object} composition
   */
  function createComposition(name, tempo, timeSignature) {
    var clampedTempo = Math.max(60, Math.min(240, tempo || 120));
    var sig = Array.isArray(timeSignature) && timeSignature.length === 2
      ? [timeSignature[0], timeSignature[1]]
      : [4, 4];

    return {
      id:            nextId('comp'),
      name:          name || 'Untitled',
      tempo:         clampedTempo,
      timeSignature: sig,
      tracks:        [],
      createdAt:     Date.now(),
      updatedAt:     Date.now()
    };
  }

  // ---------------------------------------------------------------------------
  // Track management
  // ---------------------------------------------------------------------------

  /**
   * Add a track to a composition.
   * @param {Object} composition
   * @param {string} instrumentKey â€” key from INSTRUMENTS
   * @param {string} trackName
   * @returns {Object} the new track
   */
  function addTrack(composition, instrumentKey, trackName) {
    if (!composition || !composition.tracks) {
      throw new Error('Invalid composition');
    }
    var instrument = INSTRUMENTS[instrumentKey] || INSTRUMENTS.piano;
    var track = {
      id:         nextId('track'),
      name:       trackName || instrument.name,
      instrument: instrumentKey || 'piano',
      volume:     1.0,
      muted:      false,
      notes:      []
    };
    composition.tracks.push(track);
    composition.updatedAt = Date.now();
    return track;
  }

  /**
   * Remove a track from a composition by track id.
   * @param {Object} composition
   * @param {string} trackId
   * @returns {boolean} true if removed
   */
  function removeTrack(composition, trackId) {
    if (!composition || !composition.tracks) return false;
    var before = composition.tracks.length;
    composition.tracks = composition.tracks.filter(function(t) {
      return t.id !== trackId;
    });
    var removed = composition.tracks.length < before;
    if (removed) composition.updatedAt = Date.now();
    return removed;
  }

  // ---------------------------------------------------------------------------
  // Note management
  // ---------------------------------------------------------------------------

  /**
   * Add a note to a track.
   * @param {Object} track
   * @param {string} pitch     â€” e.g. 'C4', 'kick'
   * @param {number} startBeat â€” beat position (0-indexed, fractions allowed)
   * @param {number} duration  â€” in beats
   * @param {number} velocity  â€” 0-127
   * @returns {Object} the new note
   */
  function addNote(track, pitch, startBeat, duration, velocity) {
    if (!track || !track.notes) {
      throw new Error('Invalid track');
    }
    var note = {
      id:        nextId('note'),
      pitch:     pitch || 'C4',
      startBeat: typeof startBeat === 'number' ? startBeat : 0,
      duration:  typeof duration  === 'number' ? Math.max(0.0625, duration) : 1,
      velocity:  Math.max(0, Math.min(127, typeof velocity === 'number' ? velocity : 100))
    };
    track.notes.push(note);
    return note;
  }

  /**
   * Remove a note from a track by note id.
   * @param {Object} track
   * @param {string} noteId
   * @returns {boolean}
   */
  function removeNote(track, noteId) {
    if (!track || !track.notes) return false;
    var before = track.notes.length;
    track.notes = track.notes.filter(function(n) { return n.id !== noteId; });
    return track.notes.length < before;
  }

  // ---------------------------------------------------------------------------
  // Tempo
  // ---------------------------------------------------------------------------

  /**
   * Set composition tempo, clamped to 60-240 BPM.
   * @param {Object} composition
   * @param {number} bpm
   * @returns {number} new tempo
   */
  function setTempo(composition, bpm) {
    if (!composition) throw new Error('Invalid composition');
    composition.tempo = Math.max(60, Math.min(240, bpm));
    composition.updatedAt = Date.now();
    return composition.tempo;
  }

  // ---------------------------------------------------------------------------
  // Transposition
  // ---------------------------------------------------------------------------

  /**
   * Transpose all non-drum notes in a track by a number of semitones.
   * @param {Object} track
   * @param {number} semitones â€” positive = up, negative = down
   * @returns {Object} track (mutated in place)
   */
  function transposeTrack(track, semitones) {
    if (!track || !track.notes) throw new Error('Invalid track');
    track.notes = track.notes.map(function(note) {
      var newNote = {};
      for (var k in note) newNote[k] = note[k];
      newNote.pitch = transposeNote(note.pitch, semitones);
      return newNote;
    });
    return track;
  }

  // ---------------------------------------------------------------------------
  // Quantization
  // ---------------------------------------------------------------------------

  /**
   * Snap note startBeats to a grid.
   * @param {Object} track
   * @param {string} grid â€” '1/4', '1/8', '1/16'
   * @returns {Object} track (mutated)
   */
  function quantizeNotes(track, grid) {
    if (!track || !track.notes) throw new Error('Invalid track');
    var gridMap = { '1/4': 1, '1/8': 0.5, '1/16': 0.25 };
    var step = gridMap[grid];
    if (!step) throw new Error('Invalid grid: ' + grid + '. Use 1/4, 1/8, or 1/16');
    track.notes = track.notes.map(function(note) {
      var newNote = {};
      for (var k in note) newNote[k] = note[k];
      newNote.startBeat = Math.round(note.startBeat / step) * step;
      return newNote;
    });
    return track;
  }

  // ---------------------------------------------------------------------------
  // Scale utilities
  // ---------------------------------------------------------------------------

  /**
   * Return all note names in a scale spanning C3-C6 for a given root + scale.
   * @param {string} root  â€” e.g. 'C', 'F#', 'Bb'
   * @param {string} scale â€” key from SCALES
   * @returns {string[]} note names
   */
  function getScaleNotes(root, scale) {
    var intervals = SCALES[scale];
    if (!intervals) throw new Error('Unknown scale: ' + scale);

    // Normalise flat root to sharp
    var flatToSharp = { 'Db':'C#','Eb':'D#','Fb':'E','Gb':'F#','Ab':'G#','Bb':'A#','Cb':'B' };
    var sharpRoot = flatToSharp[root] || root;
    var rootIndex = CHROMATIC.indexOf(sharpRoot);
    if (rootIndex === -1) throw new Error('Unknown root note: ' + root);

    var result = [];
    for (var octave = 3; octave <= 6; octave++) {
      for (var i = 0; i < intervals.length; i++) {
        var semitone = (rootIndex + intervals[i]) % 12;
        var extraOctave = Math.floor((rootIndex + intervals[i]) / 12);
        var noteOctave = octave + extraOctave;
        if (noteOctave > 6) continue;
        var noteStr = buildNote(semitone, noteOctave);
        if (NOTE_FREQUENCIES[noteStr]) {
          result.push(noteStr);
        }
      }
    }
    // Remove duplicates while preserving order
    var seen = {};
    var unique = [];
    for (var j = 0; j < result.length; j++) {
      if (!seen[result[j]]) {
        seen[result[j]] = true;
        unique.push(result[j]);
      }
    }
    return unique;
  }

  /**
   * Test whether a pitch belongs to a given scale/root combination.
   * Drum labels (no octave digit) always return false.
   * @param {string} pitch
   * @param {string} root
   * @param {string} scale
   * @returns {boolean}
   */
  function isInScale(pitch, root, scale) {
    try {
      var scaleNotes = getScaleNotes(root, scale);
      // Compare only the note name (without octave)
      var parsed = parseNote(pitch);
      if (!parsed) return false;
      var pitchClass = parsed.name; // e.g. 'C', 'C#'
      for (var i = 0; i < scaleNotes.length; i++) {
        var p = parseNote(scaleNotes[i]);
        if (p && p.name === pitchClass) return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }

  // ---------------------------------------------------------------------------
  // Procedural generation
  // ---------------------------------------------------------------------------

  /**
   * Generate a melodic phrase.
   * @param {string} root
   * @param {string} scale
   * @param {number} bars      â€” number of bars
   * @param {number} [seed=1]
   * @returns {Array} array of note objects {pitch, startBeat, duration, velocity}
   */
  function generateMelody(root, scale, bars, seed) {
    var s = typeof seed === 'number' ? seed : 1;
    var scaleNotes = getScaleNotes(root, scale);
    // Prefer mid-register notes (octave 4-5)
    var midNotes = scaleNotes.filter(function(n) {
      var p = parseNote(n);
      return p && p.octave >= 4 && p.octave <= 5;
    });
    var pool = midNotes.length > 0 ? midNotes : scaleNotes;

    var notes = [];
    var beat = 0;
    var totalBeats = bars * 4; // assume 4/4
    var ri = 0;

    while (beat < totalBeats) {
      var durChoices = [0.5, 1, 1, 1, 2];
      var durIdx = Math.floor(seededRand(s + ri) * durChoices.length);
      var dur = durChoices[durIdx];
      if (beat + dur > totalBeats) dur = totalBeats - beat;
      if (dur <= 0) break;

      var pitchIdx = Math.floor(seededRand(s + ri + 100) * pool.length);
      var velocity = 70 + Math.floor(seededRand(s + ri + 200) * 40);
      var rest = seededRand(s + ri + 300) < 0.2; // 20% rest chance

      if (!rest) {
        notes.push({
          pitch:     pool[pitchIdx],
          startBeat: beat,
          duration:  dur,
          velocity:  velocity
        });
      }

      beat += dur;
      ri += 1;
    }
    return notes;
  }

  /**
   * Generate a bassline.
   * @param {string} root
   * @param {string} scale
   * @param {number} bars
   * @param {number} [seed=1]
   * @returns {Array}
   */
  function generateBassline(root, scale, bars, seed) {
    var s = typeof seed === 'number' ? seed : 1;
    var scaleNotes = getScaleNotes(root, scale);
    // Prefer low register (octave 3)
    var lowNotes = scaleNotes.filter(function(n) {
      var p = parseNote(n);
      return p && p.octave === 3;
    });
    var pool = lowNotes.length > 0 ? lowNotes : scaleNotes;

    var notes = [];
    var totalBeats = bars * 4;
    var beat = 0;
    var ri = 0;

    while (beat < totalBeats) {
      var dur = seededRand(s + ri + 50) < 0.6 ? 1 : 2;
      if (beat + dur > totalBeats) dur = totalBeats - beat;
      if (dur <= 0) break;

      var pitchIdx = Math.floor(seededRand(s + ri + 150) * pool.length);
      var velocity = 80 + Math.floor(seededRand(s + ri + 250) * 30);

      notes.push({
        pitch:     pool[pitchIdx],
        startBeat: beat,
        duration:  dur,
        velocity:  velocity
      });

      beat += dur;
      ri += 1;
    }
    return notes;
  }

  /**
   * Drum hit labels available.
   */
  var DRUM_HITS = ['kick', 'snare', 'hihat', 'open_hihat', 'clap', 'tom'];

  /**
   * Generate a drum pattern.
   * @param {number} bars
   * @param {string} style â€” 'basic', 'groove', 'sparse'
   * @param {number} [seed=1]
   * @returns {Array} array of {pitch:drumLabel, startBeat, duration, velocity}
   */
  function generateDrumPattern(bars, style, seed) {
    var s = typeof seed === 'number' ? seed : 1;
    var totalBeats = bars * 4;
    var notes = [];

    // Basic kick-snare pattern
    for (var bar = 0; bar < bars; bar++) {
      var offset = bar * 4;

      if (style === 'sparse') {
        // Kick on 1, snare on 3
        notes.push({ pitch: 'kick',  startBeat: offset + 0, duration: 0.25, velocity: 100 });
        notes.push({ pitch: 'snare', startBeat: offset + 2, duration: 0.25, velocity: 90  });
        // Occasional hihat
        if (seededRand(s + bar) > 0.5) {
          notes.push({ pitch: 'hihat', startBeat: offset + 1, duration: 0.25, velocity: 70 });
        }
      } else if (style === 'groove') {
        // Kick on 1 & 2.5, snare on 2 & 4
        notes.push({ pitch: 'kick',  startBeat: offset + 0,   duration: 0.25, velocity: 110 });
        notes.push({ pitch: 'kick',  startBeat: offset + 2.5, duration: 0.25, velocity: 90  });
        notes.push({ pitch: 'snare', startBeat: offset + 1,   duration: 0.25, velocity: 100 });
        notes.push({ pitch: 'snare', startBeat: offset + 3,   duration: 0.25, velocity: 95  });
        // 8th-note hihats
        for (var h = 0; h < 8; h++) {
          var vel = (h % 2 === 0) ? 75 : 55;
          notes.push({ pitch: 'hihat', startBeat: offset + h * 0.5, duration: 0.25, velocity: vel });
        }
      } else {
        // basic: kick 1 & 3, snare 2 & 4, hihats on every beat
        notes.push({ pitch: 'kick',  startBeat: offset + 0, duration: 0.25, velocity: 100 });
        notes.push({ pitch: 'kick',  startBeat: offset + 2, duration: 0.25, velocity: 100 });
        notes.push({ pitch: 'snare', startBeat: offset + 1, duration: 0.25, velocity: 90  });
        notes.push({ pitch: 'snare', startBeat: offset + 3, duration: 0.25, velocity: 90  });
        for (var hh = 0; hh < 8; hh++) {
          notes.push({ pitch: 'hihat', startBeat: offset + hh * 0.5, duration: 0.25, velocity: 65 });
        }
      }
    }
    return notes;
  }

  // ---------------------------------------------------------------------------
  // Duration & playback
  // ---------------------------------------------------------------------------

  /**
   * Return the duration of a composition in seconds.
   * @param {Object} composition
   * @returns {number} seconds
   */
  function getDuration(composition) {
    if (!composition || !composition.tracks) return 0;
    var bps = composition.tempo / 60;
    var maxBeat = 0;
    composition.tracks.forEach(function(track) {
      track.notes.forEach(function(note) {
        var end = note.startBeat + note.duration;
        if (end > maxBeat) maxBeat = end;
      });
    });
    return maxBeat / bps;
  }

  /**
   * Build a flat playback schedule sorted by time.
   * Each event: { timeSeconds, trackId, instrument, pitch, duration, velocity, frequency }
   * @param {Object} composition
   * @returns {Array}
   */
  function getPlaybackSchedule(composition) {
    if (!composition || !composition.tracks) return [];
    var bps = composition.tempo / 60;
    var events = [];

    composition.tracks.forEach(function(track) {
      if (track.muted) return;
      track.notes.forEach(function(note) {
        var freq = NOTE_FREQUENCIES[note.pitch] || null;
        events.push({
          timeSeconds:  note.startBeat / bps,
          durationSecs: note.duration  / bps,
          trackId:      track.id,
          instrument:   track.instrument,
          pitch:        note.pitch,
          velocity:     note.velocity,
          frequency:    freq
        });
      });
    });

    events.sort(function(a, b) { return a.timeSeconds - b.timeSeconds; });
    return events;
  }

  /**
   * Mix all tracks into a flat list of notes with absolute timing metadata.
   * Muted tracks are excluded.
   * @param {Object} composition
   * @returns {Array} mixed note objects
   */
  function mixTracks(composition) {
    if (!composition || !composition.tracks) return [];
    var mixed = [];
    var bps = composition.tempo / 60;

    composition.tracks.forEach(function(track) {
      if (track.muted) return;
      track.notes.forEach(function(note) {
        mixed.push({
          trackId:      track.id,
          trackName:    track.name,
          instrument:   track.instrument,
          volume:       track.volume,
          pitch:        note.pitch,
          startBeat:    note.startBeat,
          duration:     note.duration,
          velocity:     Math.round(note.velocity * track.volume),
          startSeconds: note.startBeat  / bps,
          endSeconds:   (note.startBeat + note.duration) / bps,
          frequency:    NOTE_FREQUENCIES[note.pitch] || null
        });
      });
    });

    mixed.sort(function(a, b) { return a.startBeat - b.startBeat; });
    return mixed;
  }

  /**
   * Return all notes whose startBeat falls within [start, end).
   * @param {Object} composition
   * @param {number} start â€” beat (inclusive)
   * @param {number} end   â€” beat (exclusive)
   * @returns {Array} { trackId, note }
   */
  function getNotesInRange(composition, start, end) {
    if (!composition || !composition.tracks) return [];
    var result = [];
    composition.tracks.forEach(function(track) {
      track.notes.forEach(function(note) {
        if (note.startBeat >= start && note.startBeat < end) {
          result.push({ trackId: track.id, note: note });
        }
      });
    });
    return result;
  }

  // ---------------------------------------------------------------------------
  // Export / Import
  // ---------------------------------------------------------------------------

  /**
   * Serialize a composition to a plain JSON-compatible object.
   * @param {Object} composition
   * @returns {Object}
   */
  function exportComposition(composition) {
    if (!composition) throw new Error('No composition to export');
    return JSON.parse(JSON.stringify({
      version:       1,
      id:            composition.id,
      name:          composition.name,
      tempo:         composition.tempo,
      timeSignature: composition.timeSignature,
      createdAt:     composition.createdAt,
      updatedAt:     composition.updatedAt,
      tracks:        composition.tracks
    }));
  }

  /**
   * Reconstruct a composition from a previously exported object.
   * Validates required fields; throws on malformed input.
   * @param {Object} data
   * @returns {Object} composition
   */
  function importComposition(data) {
    if (!data || typeof data !== 'object') {
      throw new Error('Import data must be an object');
    }
    if (data.version !== 1) {
      throw new Error('Unsupported composition version: ' + data.version);
    }
    if (typeof data.name !== 'string' || !data.name) {
      throw new Error('Composition must have a name');
    }
    if (typeof data.tempo !== 'number' || data.tempo < 60 || data.tempo > 240) {
      throw new Error('Tempo out of range (60-240): ' + data.tempo);
    }
    if (!Array.isArray(data.tracks)) {
      throw new Error('tracks must be an array');
    }

    var comp = {
      id:            data.id || nextId('comp'),
      name:          data.name,
      tempo:         data.tempo,
      timeSignature: Array.isArray(data.timeSignature) ? data.timeSignature : [4, 4],
      createdAt:     data.createdAt || Date.now(),
      updatedAt:     data.updatedAt || Date.now(),
      tracks:        []
    };

    data.tracks.forEach(function(t) {
      var track = {
        id:         t.id || nextId('track'),
        name:       t.name || 'Track',
        instrument: t.instrument || 'piano',
        volume:     typeof t.volume === 'number' ? t.volume : 1.0,
        muted:      !!t.muted,
        notes:      []
      };
      if (Array.isArray(t.notes)) {
        t.notes.forEach(function(n) {
          track.notes.push({
            id:        n.id || nextId('note'),
            pitch:     n.pitch || 'C4',
            startBeat: typeof n.startBeat === 'number' ? n.startBeat : 0,
            duration:  typeof n.duration  === 'number' ? n.duration  : 1,
            velocity:  typeof n.velocity  === 'number' ? n.velocity  : 100
          });
        });
      }
      comp.tracks.push(track);
    });

    return comp;
  }

  // ---------------------------------------------------------------------------
  // Public API
  // ---------------------------------------------------------------------------
  exports.NOTE_FREQUENCIES    = NOTE_FREQUENCIES;
  exports.INSTRUMENTS         = INSTRUMENTS;
  exports.SCALES              = SCALES;
  exports.CHROMATIC           = CHROMATIC;
  exports.DRUM_HITS           = DRUM_HITS;

  exports.createComposition   = createComposition;
  exports.addTrack            = addTrack;
  exports.removeTrack         = removeTrack;
  exports.addNote             = addNote;
  exports.removeNote          = removeNote;
  exports.setTempo            = setTempo;
  exports.transposeTrack      = transposeTrack;
  exports.quantizeNotes       = quantizeNotes;
  exports.getScaleNotes       = getScaleNotes;
  exports.isInScale           = isInScale;
  exports.generateMelody      = generateMelody;
  exports.generateBassline    = generateBassline;
  exports.generateDrumPattern = generateDrumPattern;
  exports.getDuration         = getDuration;
  exports.getPlaybackSchedule = getPlaybackSchedule;
  exports.mixTracks           = mixTracks;
  exports.getNotesInRange     = getNotesInRange;
  exports.exportComposition   = exportComposition;
  exports.importComposition   = importComposition;

})(typeof module !== 'undefined' ? module.exports : (window.MusicComposer = {}));


// world_events.js
// world_events.js â€” Living World Events System for ZION
// Spontaneous events that affect all players and shape the world
(function(exports) {
  'use strict';

  // â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var MAX_CONCURRENT_EVENTS = 3;
  var EVENT_COOLDOWN_HOURS = 4;
  var EVENT_COOLDOWN_MS = EVENT_COOLDOWN_HOURS * 60 * 60 * 1000;

  // Event categories
  var CATEGORY_CELESTIAL = 'celestial';
  var CATEGORY_NATURE    = 'nature';
  var CATEGORY_SOCIAL    = 'social';
  var CATEGORY_MYSTERY   = 'mystery';

  // â”€â”€ EVENT_CATALOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 15 events across 4 categories

  var EVENT_CATALOG = {

    // â”€â”€ Celestial â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    meteor_shower: {
      id: 'meteor_shower',
      category: CATEGORY_CELESTIAL,
      name: 'Meteor Shower',
      description: 'Streaks of light rain across the sky as meteors burn through the atmosphere. Some fragments may land in the world.',
      durationMinutes: 30,
      minParticipants: 1,
      maxParticipants: 100,
      zones: ['nexus', 'wilds', 'gardens', 'commons', 'agora', 'arena', 'athenaeum', 'studio'],
      effects: [
        { type: 'visual', value: 'meteor_trails' },
        { type: 'item_drop', value: 'meteor_fragment', chance: 0.15 },
        { type: 'spark_bonus', value: 10 }
      ],
      rewards: {
        participation: { sparks: 15, item: 'stardust' },
        completion: { sparks: 30, item: 'meteor_fragment', badge: 'stargazer' }
      },
      contributionGoal: 50,
      contributionUnit: 'observations',
      rarity: 0.4,
      cooldownHours: 6,
      announceMessage: 'A meteor shower blazes across the sky! Look up and make a wish.'
    },

    aurora: {
      id: 'aurora',
      category: CATEGORY_CELESTIAL,
      name: 'Aurora Borealis',
      description: 'The sky erupts in waves of colour â€” green, violet, and gold â€” as the aurora dances overhead.',
      durationMinutes: 45,
      minParticipants: 1,
      maxParticipants: 100,
      zones: ['nexus', 'wilds', 'gardens', 'commons', 'agora', 'arena', 'athenaeum', 'studio'],
      effects: [
        { type: 'visual', value: 'aurora_sky' },
        { type: 'inspiration_boost', value: 0.25 },
        { type: 'craft_bonus', value: 1.2 }
      ],
      rewards: {
        participation: { sparks: 20 },
        completion: { sparks: 40, badge: 'aurora_witness' }
      },
      contributionGoal: 30,
      contributionUnit: 'paintings',
      rarity: 0.25,
      cooldownHours: 12,
      announceMessage: 'The aurora lights up the heavens! Artists, philosophers â€” this moment is yours.'
    },

    solar_eclipse: {
      id: 'solar_eclipse',
      category: CATEGORY_CELESTIAL,
      name: 'Solar Eclipse',
      description: 'The moon passes before the sun, casting the world into eerie twilight. Ancient powers stir.',
      durationMinutes: 20,
      minParticipants: 1,
      maxParticipants: 100,
      zones: ['nexus', 'wilds', 'gardens', 'commons', 'agora', 'arena', 'athenaeum', 'studio'],
      effects: [
        { type: 'visual', value: 'eclipse_sky' },
        { type: 'mystery_amplify', value: 2.0 },
        { type: 'creature_spawn_boost', value: 1.5 }
      ],
      rewards: {
        participation: { sparks: 25 },
        completion: { sparks: 50, item: 'eclipse_shard', badge: 'eclipse_seeker' }
      },
      contributionGoal: 20,
      contributionUnit: 'rituals',
      rarity: 0.15,
      cooldownHours: 48,
      announceMessage: 'Darkness falls as the eclipse begins. The veil between worlds thins...'
    },

    blood_moon: {
      id: 'blood_moon',
      category: CATEGORY_CELESTIAL,
      name: 'Blood Moon',
      description: 'The full moon turns a deep crimson red, empowering the wild and awakening ancient threats.',
      durationMinutes: 60,
      minParticipants: 2,
      maxParticipants: 50,
      zones: ['wilds', 'arena', 'nexus', 'commons'],
      effects: [
        { type: 'visual', value: 'blood_moon_sky' },
        { type: 'creature_power', value: 2.0 },
        { type: 'pvp_enabled', value: true },
        { type: 'loot_multiplier', value: 2.0 }
      ],
      rewards: {
        participation: { sparks: 30 },
        completion: { sparks: 75, item: 'blood_crystal', badge: 'blood_moon_survivor' }
      },
      contributionGoal: 100,
      contributionUnit: 'combat_victories',
      rarity: 0.2,
      cooldownHours: 24,
      announceMessage: 'The Blood Moon rises! Warriors, prepare â€” the wild creatures are empowered!'
    },

    // â”€â”€ Nature â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    wild_bloom: {
      id: 'wild_bloom',
      category: CATEGORY_NATURE,
      name: 'Wild Bloom',
      description: 'Rare and magical flowers burst into bloom across the Gardens and Wilds, yielding extraordinary materials.',
      durationMinutes: 40,
      minParticipants: 1,
      maxParticipants: 40,
      zones: ['gardens', 'wilds', 'commons'],
      effects: [
        { type: 'visual', value: 'bloom_particles' },
        { type: 'harvest_yield', value: 2.0 },
        { type: 'rare_item_chance', value: 0.3 }
      ],
      rewards: {
        participation: { sparks: 15, item: 'rare_bloom' },
        completion: { sparks: 35, item: 'bloom_essence', badge: 'bloom_harvester' }
      },
      contributionGoal: 60,
      contributionUnit: 'flowers_harvested',
      rarity: 0.35,
      cooldownHours: 8,
      announceMessage: 'Wild blooms erupt across the land! Rare flowers appear â€” harvest before they fade!'
    },

    creature_migration: {
      id: 'creature_migration',
      category: CATEGORY_NATURE,
      name: 'Creature Migration',
      description: 'Great herds of creatures cross the land, following ancient paths. Witness the spectacle or guide them safely.',
      durationMinutes: 50,
      minParticipants: 2,
      maxParticipants: 60,
      zones: ['wilds', 'commons', 'gardens', 'nexus'],
      effects: [
        { type: 'creature_spawn', value: 'migration_herd' },
        { type: 'pathfinding_boost', value: 1.5 },
        { type: 'exploration_xp', value: 2.0 }
      ],
      rewards: {
        participation: { sparks: 20 },
        completion: { sparks: 45, item: 'migration_feather', badge: 'herd_guide' }
      },
      contributionGoal: 80,
      contributionUnit: 'creatures_guided',
      rarity: 0.3,
      cooldownHours: 10,
      announceMessage: 'A great migration begins! Herds of creatures cross the land â€” guide or follow them!'
    },

    great_storm: {
      id: 'great_storm',
      category: CATEGORY_NATURE,
      name: 'The Great Storm',
      description: 'A massive storm sweeps across the world, bringing danger but also raw elemental power. Brave the tempest for great reward.',
      durationMinutes: 35,
      minParticipants: 3,
      maxParticipants: 30,
      zones: ['wilds', 'nexus', 'commons', 'agora', 'gardens'],
      effects: [
        { type: 'visual', value: 'storm_sky' },
        { type: 'movement_penalty', value: 0.7 },
        { type: 'elemental_power', value: 3.0 },
        { type: 'lightning_hazard', value: true }
      ],
      rewards: {
        participation: { sparks: 25 },
        completion: { sparks: 60, item: 'storm_crystal', badge: 'storm_survivor' }
      },
      contributionGoal: 40,
      contributionUnit: 'lightning_rods_placed',
      rarity: 0.25,
      cooldownHours: 16,
      announceMessage: 'A great storm is coming! Seek shelter or brave the tempest for elemental rewards!'
    },

    earthquake: {
      id: 'earthquake',
      category: CATEGORY_NATURE,
      name: 'Earthquake',
      description: 'The earth shakes violently, opening fissures and revealing hidden underground chambers.',
      durationMinutes: 15,
      minParticipants: 1,
      maxParticipants: 80,
      zones: ['nexus', 'wilds', 'commons', 'agora', 'arena', 'gardens', 'athenaeum', 'studio'],
      effects: [
        { type: 'visual', value: 'ground_shake' },
        { type: 'terrain_change', value: 'fissures' },
        { type: 'reveal_hidden', value: true },
        { type: 'building_damage', value: 0.1 }
      ],
      rewards: {
        participation: { sparks: 20 },
        completion: { sparks: 40, item: 'geo_crystal', badge: 'earth_shaker' }
      },
      contributionGoal: 30,
      contributionUnit: 'fissures_explored',
      rarity: 0.2,
      cooldownHours: 20,
      announceMessage: 'The earth trembles! An earthquake strikes â€” explore newly opened fissures for hidden treasures!'
    },

    // â”€â”€ Social â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    festival: {
      id: 'festival',
      category: CATEGORY_SOCIAL,
      name: 'Grand Festival',
      description: 'Citizens of ZION gather for a grand festival of music, art, and celebration. All are welcome!',
      durationMinutes: 90,
      minParticipants: 5,
      maxParticipants: 100,
      zones: ['nexus', 'agora', 'commons', 'studio'],
      effects: [
        { type: 'happiness_boost', value: 2.0 },
        { type: 'social_xp', value: 2.0 },
        { type: 'craft_bonus', value: 1.5 },
        { type: 'music_performance', value: true }
      ],
      rewards: {
        participation: { sparks: 20, item: 'festival_token' },
        completion: { sparks: 50, item: 'festival_crown', badge: 'festival_spirit' }
      },
      contributionGoal: 200,
      contributionUnit: 'performances',
      rarity: 0.45,
      cooldownHours: 24,
      announceMessage: 'The Grand Festival begins! Come celebrate, perform, and share joy with all of ZION!'
    },

    market_day: {
      id: 'market_day',
      category: CATEGORY_SOCIAL,
      name: 'Market Day',
      description: 'A special market day with reduced fees, bonus trades, and rare goods available from travelling merchants.',
      durationMinutes: 120,
      minParticipants: 3,
      maxParticipants: 80,
      zones: ['nexus', 'agora', 'commons'],
      effects: [
        { type: 'market_fee_discount', value: 0.5 },
        { type: 'rare_goods_available', value: true },
        { type: 'trade_xp', value: 2.0 }
      ],
      rewards: {
        participation: { sparks: 10 },
        completion: { sparks: 30, badge: 'market_maven' }
      },
      contributionGoal: 150,
      contributionUnit: 'trades_completed',
      rarity: 0.5,
      cooldownHours: 12,
      announceMessage: 'Market Day is here! Reduced fees, rare goods, and travelling merchants await. Trade well!'
    },

    tournament: {
      id: 'tournament',
      category: CATEGORY_SOCIAL,
      name: 'Grand Tournament',
      description: 'Champions compete for glory and prizes in the Grand Tournament. Spectators cheer, competitors clash!',
      durationMinutes: 75,
      minParticipants: 4,
      maxParticipants: 64,
      zones: ['arena', 'nexus'],
      effects: [
        { type: 'pvp_enabled', value: true },
        { type: 'combat_xp', value: 3.0 },
        { type: 'spectator_rewards', value: true },
        { type: 'tournament_bracket', value: true }
      ],
      rewards: {
        participation: { sparks: 25 },
        completion: { sparks: 100, item: 'champion_trophy', badge: 'tournament_champion' }
      },
      contributionGoal: 100,
      contributionUnit: 'victories',
      rarity: 0.3,
      cooldownHours: 24,
      announceMessage: 'The Grand Tournament begins! Champions enter the arena â€” may the best warrior prevail!'
    },

    storytelling_circle: {
      id: 'storytelling_circle',
      category: CATEGORY_SOCIAL,
      name: 'Storytelling Circle',
      description: 'Citizens gather round to share stories, legends, and myths. Each tale woven enriches the lore of ZION.',
      durationMinutes: 60,
      minParticipants: 2,
      maxParticipants: 40,
      zones: ['athenaeum', 'nexus', 'commons', 'agora'],
      effects: [
        { type: 'lore_generation', value: true },
        { type: 'social_xp', value: 3.0 },
        { type: 'wisdom_boost', value: 1.5 }
      ],
      rewards: {
        participation: { sparks: 15, item: 'tale_scroll' },
        completion: { sparks: 35, badge: 'lore_keeper' }
      },
      contributionGoal: 20,
      contributionUnit: 'stories_told',
      rarity: 0.4,
      cooldownHours: 8,
      announceMessage: 'A storytelling circle forms! Share your tales and earn wisdom. All voices are welcome.'
    },

    // â”€â”€ Mystery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    ancient_ruins_appear: {
      id: 'ancient_ruins_appear',
      category: CATEGORY_MYSTERY,
      name: 'Ancient Ruins Appear',
      description: 'Mysterious ruins rise from the earth, revealing lost knowledge and forgotten artefacts from a civilisation long gone.',
      durationMinutes: 60,
      minParticipants: 2,
      maxParticipants: 30,
      zones: ['wilds', 'commons', 'nexus', 'gardens'],
      effects: [
        { type: 'terrain_change', value: 'ruins_appear' },
        { type: 'lore_unlock', value: true },
        { type: 'exploration_xp', value: 3.0 },
        { type: 'artefact_spawn', value: true }
      ],
      rewards: {
        participation: { sparks: 30 },
        completion: { sparks: 70, item: 'ancient_artefact', badge: 'ruin_delver' }
      },
      contributionGoal: 50,
      contributionUnit: 'ruins_explored',
      rarity: 0.2,
      cooldownHours: 24,
      announceMessage: 'Ancient ruins have appeared! Something has emerged from beneath the earth â€” explore before they vanish!'
    },

    treasure_hunt: {
      id: 'treasure_hunt',
      category: CATEGORY_MYSTERY,
      name: 'Treasure Hunt',
      description: 'Cryptic clues are scattered across ZION. Solve the riddles, follow the trail, and claim the legendary treasure.',
      durationMinutes: 90,
      minParticipants: 1,
      maxParticipants: 50,
      zones: ['nexus', 'wilds', 'gardens', 'commons', 'agora', 'arena', 'athenaeum', 'studio'],
      effects: [
        { type: 'clue_spawn', value: true },
        { type: 'exploration_xp', value: 2.5 },
        { type: 'puzzle_xp', value: 2.0 }
      ],
      rewards: {
        participation: { sparks: 20 },
        completion: { sparks: 120, item: 'legendary_treasure', badge: 'treasure_hunter' }
      },
      contributionGoal: 10,
      contributionUnit: 'clues_solved',
      rarity: 0.3,
      cooldownHours: 16,
      announceMessage: 'A treasure hunt begins! Cryptic clues await â€” follow the trail to legendary riches!'
    },

    rift_surge: {
      id: 'rift_surge',
      category: CATEGORY_MYSTERY,
      name: 'Rift Surge',
      description: 'A powerful surge of energy tears rifts in the fabric of reality. Strange entities emerge. Close the rifts or face the consequences.',
      durationMinutes: 45,
      minParticipants: 3,
      maxParticipants: 40,
      zones: ['nexus', 'wilds', 'arena', 'commons', 'agora'],
      effects: [
        { type: 'rift_spawn', value: true },
        { type: 'entity_spawn', value: 'rift_creatures' },
        { type: 'magic_amplify', value: 3.0 },
        { type: 'reality_distortion', value: true }
      ],
      rewards: {
        participation: { sparks: 35 },
        completion: { sparks: 80, item: 'rift_shard', badge: 'rift_closer' }
      },
      contributionGoal: 30,
      contributionUnit: 'rifts_closed',
      rarity: 0.15,
      cooldownHours: 20,
      announceMessage: 'A rift surge tears open the sky! Close the rifts before ZION is overwhelmed by strange entities!'
    }
  };

  // â”€â”€ State Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates a fresh events state container
   * @returns {Object} events state
   */
  function createEventsState() {
    return {
      activeEvents: [],        // currently running events
      eventHistory: [],        // completed/expired events
      participants: {},        // eventId -> Set/Array of participantIds
      contributions: {},       // eventId -> { userId: amount }
      cooldowns: {},           // eventId -> timestamp when cooldown expires
      upcomingEvents: [],      // scheduled future events
      eventCounter: 0          // monotonic id counter
    };
  }

  // â”€â”€ Internal Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Simple seeded pseudo-random (LCG) â€” deterministic from seed
   * Returns a value in [0, 1)
   */
  function seededRand(seed) {
    var s = (seed ^ 0xdeadbeef) >>> 0;
    s = Math.imul(s ^ (s >>> 16), 0x45d9f3b) >>> 0;
    s = Math.imul(s ^ (s >>> 16), 0x45d9f3b) >>> 0;
    s = (s ^ (s >>> 16)) >>> 0;
    return s / 0x100000000;
  }

  /**
   * Generates a unique event instance id
   */
  function nextEventId(state) {
    state.eventCounter += 1;
    return 'evt_' + state.eventCounter;
  }

  /**
   * Returns current timestamp (ms). Injectable for tests.
   */
  var _getNow = function() { return Date.now(); };

  function setNowFn(fn) {
    _getNow = fn;
  }

  function getNow() {
    return _getNow();
  }

  // â”€â”€ Core Event Lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates a new event instance (not yet started)
   * @param {Object} state - events state
   * @param {string} eventTypeId - key in EVENT_CATALOG
   * @param {Object} [options] - { zone, startTime }
   * @returns {Object|null} event instance or null if unknown type
   */
  function createEvent(state, eventTypeId, options) {
    var template = EVENT_CATALOG[eventTypeId];
    if (!template) { return null; }

    options = options || {};

    var now = getNow();
    var startTime = options.startTime !== undefined ? options.startTime : now;
    var zone = options.zone || template.zones[0];

    var instance = {
      instanceId: nextEventId(state),
      typeId: eventTypeId,
      category: template.category,
      name: template.name,
      description: template.description,
      zone: zone,
      startTime: startTime,
      endTime: startTime + template.durationMinutes * 60 * 1000,
      durationMinutes: template.durationMinutes,
      status: 'pending',        // pending | active | completed | expired
      effects: template.effects.slice(),
      rewards: template.rewards,
      contributionGoal: template.contributionGoal,
      contributionUnit: template.contributionUnit,
      minParticipants: template.minParticipants,
      maxParticipants: template.maxParticipants,
      totalContributions: 0,
      completed: false,
      announceMessage: template.announceMessage
    };

    return instance;
  }

  /**
   * Starts an event (adds to active list)
   * @param {Object} state - events state
   * @param {Object} eventInstance - created via createEvent
   * @returns {{ success: boolean, reason?: string, event?: Object }}
   */
  function startEvent(state, eventInstance) {
    if (!eventInstance) {
      return { success: false, reason: 'invalid_event' };
    }

    var active = state.activeEvents;

    // Cap concurrent events
    if (active.length >= MAX_CONCURRENT_EVENTS) {
      return { success: false, reason: 'max_concurrent_events_reached' };
    }

    // Check cooldown
    var cooldownExpiry = state.cooldowns[eventInstance.typeId];
    var now = getNow();
    if (cooldownExpiry && now < cooldownExpiry) {
      return { success: false, reason: 'event_on_cooldown', cooldownExpiry: cooldownExpiry };
    }

    // Duplicate active event of same type?
    for (var i = 0; i < active.length; i++) {
      if (active[i].typeId === eventInstance.typeId) {
        return { success: false, reason: 'event_already_active' };
      }
    }

    eventInstance.status = 'active';
    eventInstance.startTime = now;

    var template = EVENT_CATALOG[eventInstance.typeId];
    eventInstance.endTime = now + (template ? template.durationMinutes * 60 * 1000 : eventInstance.durationMinutes * 60 * 1000);

    active.push(eventInstance);

    // Initialise participant and contribution tracking
    state.participants[eventInstance.instanceId] = [];
    state.contributions[eventInstance.instanceId] = {};

    return { success: true, event: eventInstance };
  }

  /**
   * Ends an event â€” marks it completed or expired and moves to history
   * @param {Object} state - events state
   * @param {string} instanceId - event instance id
   * @param {Object} [options] - { reason: 'completed'|'expired'|'cancelled' }
   * @returns {{ success: boolean, event?: Object }}
   */
  function endEvent(state, instanceId, options) {
    options = options || {};
    var reason = options.reason || 'completed';

    var idx = -1;
    for (var i = 0; i < state.activeEvents.length; i++) {
      if (state.activeEvents[i].instanceId === instanceId) {
        idx = i;
        break;
      }
    }

    if (idx === -1) {
      return { success: false, reason: 'event_not_found' };
    }

    var ev = state.activeEvents[idx];
    ev.status = reason;
    ev.completed = (reason === 'completed');
    ev.endedAt = getNow();

    // Set cooldown
    var template = EVENT_CATALOG[ev.typeId];
    var cooldownHours = template ? template.cooldownHours : EVENT_COOLDOWN_HOURS;
    state.cooldowns[ev.typeId] = getNow() + cooldownHours * 60 * 60 * 1000;

    // Move to history
    state.activeEvents.splice(idx, 1);
    state.eventHistory.push(ev);

    return { success: true, event: ev };
  }

  // â”€â”€ Query Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns all currently active events (cleans up expired ones first)
   * @param {Object} state - events state
   * @returns {Array} active event instances
   */
  function getActiveEvents(state) {
    var now = getNow();
    // Auto-expire events past their endTime
    var toExpire = [];
    for (var i = 0; i < state.activeEvents.length; i++) {
      if (state.activeEvents[i].endTime <= now) {
        toExpire.push(state.activeEvents[i].instanceId);
      }
    }
    for (var j = 0; j < toExpire.length; j++) {
      endEvent(state, toExpire[j], { reason: 'expired' });
    }
    return state.activeEvents.slice();
  }

  /**
   * Returns upcoming (scheduled pending) events
   * @param {Object} state - events state
   * @returns {Array} upcoming event instances
   */
  function getUpcomingEvents(state) {
    return state.upcomingEvents.slice();
  }

  /**
   * Returns events active in a specific zone
   * @param {Object} state - events state
   * @param {string} zone - zone id
   * @returns {Array} active event instances in that zone
   */
  function getEventsByZone(state, zone) {
    var active = getActiveEvents(state);
    var result = [];
    for (var i = 0; i < active.length; i++) {
      if (active[i].zone === zone) {
        result.push(active[i]);
      }
    }
    return result;
  }

  /**
   * Returns event history (all ended events)
   * @param {Object} state - events state
   * @param {Object} [filter] - { category, typeId, limit }
   * @returns {Array} historical events
   */
  function getEventHistory(state, filter) {
    filter = filter || {};
    var history = state.eventHistory.slice();

    if (filter.category) {
      var cat = filter.category;
      history = history.filter(function(e) { return e.category === cat; });
    }
    if (filter.typeId) {
      var tid = filter.typeId;
      history = history.filter(function(e) { return e.typeId === tid; });
    }
    if (filter.limit && filter.limit > 0) {
      history = history.slice(-filter.limit);
    }

    return history;
  }

  // â”€â”€ Participant Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Adds a player to an active event
   * @param {Object} state - events state
   * @param {string} instanceId - event instance id
   * @param {string} userId - player id
   * @returns {{ success: boolean, reason?: string }}
   */
  function joinEvent(state, instanceId, userId) {
    var ev = null;
    for (var i = 0; i < state.activeEvents.length; i++) {
      if (state.activeEvents[i].instanceId === instanceId) {
        ev = state.activeEvents[i];
        break;
      }
    }

    if (!ev) { return { success: false, reason: 'event_not_found' }; }
    if (ev.status !== 'active') { return { success: false, reason: 'event_not_active' }; }

    var participants = state.participants[instanceId];
    if (!participants) {
      state.participants[instanceId] = [];
      participants = state.participants[instanceId];
    }

    // Already joined?
    if (participants.indexOf(userId) !== -1) {
      return { success: false, reason: 'already_joined' };
    }

    // Max participants?
    if (participants.length >= ev.maxParticipants) {
      return { success: false, reason: 'event_full' };
    }

    participants.push(userId);
    return { success: true };
  }

  /**
   * Removes a player from an active event
   * @param {Object} state - events state
   * @param {string} instanceId - event instance id
   * @param {string} userId - player id
   * @returns {{ success: boolean, reason?: string }}
   */
  function leaveEvent(state, instanceId, userId) {
    var participants = state.participants[instanceId];
    if (!participants) { return { success: false, reason: 'event_not_found' }; }

    var idx = participants.indexOf(userId);
    if (idx === -1) { return { success: false, reason: 'not_joined' }; }

    participants.splice(idx, 1);
    return { success: true };
  }

  /**
   * Returns the list of participants for an event
   * @param {Object} state - events state
   * @param {string} instanceId - event instance id
   * @returns {Array} participant user ids
   */
  function getParticipants(state, instanceId) {
    return (state.participants[instanceId] || []).slice();
  }

  // â”€â”€ Rewards & Progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns the reward structure for an event type or instance
   * @param {string} eventTypeId - key in EVENT_CATALOG
   * @param {string} [tier] - 'participation' | 'completion' (default: both)
   * @returns {Object|null} rewards object
   */
  function getEventRewards(eventTypeId, tier) {
    var template = EVENT_CATALOG[eventTypeId];
    if (!template) { return null; }

    if (tier) {
      return template.rewards[tier] || null;
    }
    return template.rewards;
  }

  /**
   * Returns progress of an event towards its contribution goal
   * @param {Object} state - events state
   * @param {string} instanceId - event instance id
   * @returns {{ current: number, goal: number, percent: number }|null}
   */
  function getEventProgress(state, instanceId) {
    var ev = null;
    // Check active
    for (var i = 0; i < state.activeEvents.length; i++) {
      if (state.activeEvents[i].instanceId === instanceId) {
        ev = state.activeEvents[i];
        break;
      }
    }
    // Check history if not found in active
    if (!ev) {
      for (var j = 0; j < state.eventHistory.length; j++) {
        if (state.eventHistory[j].instanceId === instanceId) {
          ev = state.eventHistory[j];
          break;
        }
      }
    }

    if (!ev) { return null; }

    var current = ev.totalContributions || 0;
    var goal = ev.contributionGoal || 1;
    var percent = Math.min(100, Math.round((current / goal) * 100));

    return { current: current, goal: goal, percent: percent };
  }

  // â”€â”€ Contributions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Records a player's contribution to an event
   * @param {Object} state - events state
   * @param {string} instanceId - event instance id
   * @param {string} userId - contributing player id
   * @param {number} amount - contribution amount
   * @returns {{ success: boolean, goalReached?: boolean, reason?: string }}
   */
  function contributeToEvent(state, instanceId, userId, amount) {
    if (typeof amount !== 'number' || amount <= 0) {
      return { success: false, reason: 'invalid_amount' };
    }

    var ev = null;
    for (var i = 0; i < state.activeEvents.length; i++) {
      if (state.activeEvents[i].instanceId === instanceId) {
        ev = state.activeEvents[i];
        break;
      }
    }

    if (!ev) { return { success: false, reason: 'event_not_found' }; }
    if (ev.status !== 'active') { return { success: false, reason: 'event_not_active' }; }

    // Ensure participant
    var participants = state.participants[instanceId];
    if (!participants) { state.participants[instanceId] = []; participants = state.participants[instanceId]; }
    if (participants.indexOf(userId) === -1) {
      // Auto-join if not at capacity
      if (participants.length < ev.maxParticipants) {
        participants.push(userId);
      } else {
        return { success: false, reason: 'event_full' };
      }
    }

    // Record contribution
    var contribs = state.contributions[instanceId];
    if (!contribs) { state.contributions[instanceId] = {}; contribs = state.contributions[instanceId]; }
    contribs[userId] = (contribs[userId] || 0) + amount;

    ev.totalContributions = (ev.totalContributions || 0) + amount;

    var goalReached = ev.totalContributions >= ev.contributionGoal;

    return { success: true, goalReached: goalReached, total: ev.totalContributions };
  }

  // â”€â”€ Effects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns effects for a given event type
   * @param {string} eventTypeId - key in EVENT_CATALOG
   * @returns {Array|null} array of effect objects
   */
  function getEventEffects(eventTypeId) {
    var template = EVENT_CATALOG[eventTypeId];
    if (!template) { return null; }
    return template.effects.slice();
  }

  // â”€â”€ Scheduling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Deterministically schedules the next random event based on world time and seed.
   * Returns an event type id and zone.
   * @param {number} worldTime - current world time ms
   * @param {number} seed - deterministic seed
   * @param {Object} [state] - events state (to check cooldowns)
   * @returns {{ typeId: string, zone: string, scheduledTime: number }|null}
   */
  function scheduleRandomEvent(worldTime, seed, state) {
    var keys = Object.keys(EVENT_CATALOG);

    // Build a weighted list factoring in rarity
    var eligible = [];
    for (var i = 0; i < keys.length; i++) {
      var typeId = keys[i];
      var template = EVENT_CATALOG[typeId];

      // Check cooldown if state provided
      if (state && state.cooldowns) {
        var cooldownExpiry = state.cooldowns[typeId];
        if (cooldownExpiry && worldTime < cooldownExpiry) {
          continue; // on cooldown, skip
        }
        // Skip already active
        var isActive = false;
        for (var a = 0; a < state.activeEvents.length; a++) {
          if (state.activeEvents[a].typeId === typeId) {
            isActive = true;
            break;
          }
        }
        if (isActive) { continue; }
      }

      eligible.push({ typeId: typeId, rarity: template.rarity });
    }

    if (eligible.length === 0) { return null; }

    // Weighted random selection using seed
    var totalWeight = 0;
    for (var w = 0; w < eligible.length; w++) {
      totalWeight += eligible[w].rarity;
    }

    var randVal = seededRand(seed + worldTime) * totalWeight;
    var selected = eligible[eligible.length - 1]; // fallback
    var cumulative = 0;
    for (var s = 0; s < eligible.length; s++) {
      cumulative += eligible[s].rarity;
      if (randVal <= cumulative) {
        selected = eligible[s];
        break;
      }
    }

    var template = EVENT_CATALOG[selected.typeId];

    // Deterministically pick zone
    var zoneIdx = Math.floor(seededRand(seed + worldTime + 1) * template.zones.length);
    var zone = template.zones[zoneIdx];

    // Schedule in next 10-30 mins (deterministic)
    var delayMinutes = 10 + Math.floor(seededRand(seed + worldTime + 2) * 20);
    var scheduledTime = worldTime + delayMinutes * 60 * 1000;

    return {
      typeId: selected.typeId,
      zone: zone,
      scheduledTime: scheduledTime
    };
  }

  // â”€â”€ Formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Formats a human-readable announcement message for an event
   * @param {Object|string} eventOrTypeId - event instance or type id string
   * @returns {string} announcement text
   */
  function formatEventAnnouncement(eventOrTypeId) {
    if (!eventOrTypeId) { return ''; }

    // If it's an object (event instance), use its stored message or look up template
    if (typeof eventOrTypeId === 'object') {
      var ev = eventOrTypeId;
      var template = EVENT_CATALOG[ev.typeId];
      var msg = (ev.announceMessage || (template && template.announceMessage) || ev.name || '');
      return '[EVENT] ' + msg + ' [Zone: ' + (ev.zone || 'all') + ']';
    }

    // If it's a string type id
    var tmpl = EVENT_CATALOG[eventOrTypeId];
    if (!tmpl) { return '[EVENT] Unknown event'; }
    return '[EVENT] ' + tmpl.announceMessage;
  }

  // â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.EVENT_CATALOG = EVENT_CATALOG;
  exports.MAX_CONCURRENT_EVENTS = MAX_CONCURRENT_EVENTS;
  exports.EVENT_COOLDOWN_HOURS = EVENT_COOLDOWN_HOURS;

  exports.createEventsState = createEventsState;
  exports.createEvent = createEvent;
  exports.startEvent = startEvent;
  exports.endEvent = endEvent;

  exports.getActiveEvents = getActiveEvents;
  exports.getUpcomingEvents = getUpcomingEvents;
  exports.getEventsByZone = getEventsByZone;
  exports.getEventHistory = getEventHistory;

  exports.joinEvent = joinEvent;
  exports.leaveEvent = leaveEvent;
  exports.getParticipants = getParticipants;

  exports.getEventRewards = getEventRewards;
  exports.getEventProgress = getEventProgress;
  exports.contributeToEvent = contributeToEvent;
  exports.getEventEffects = getEventEffects;

  exports.scheduleRandomEvent = scheduleRandomEvent;
  exports.formatEventAnnouncement = formatEventAnnouncement;

  exports.setNowFn = setNowFn;
  exports.CATEGORY_CELESTIAL = CATEGORY_CELESTIAL;
  exports.CATEGORY_NATURE = CATEGORY_NATURE;
  exports.CATEGORY_SOCIAL = CATEGORY_SOCIAL;
  exports.CATEGORY_MYSTERY = CATEGORY_MYSTERY;

})(typeof module !== 'undefined' ? module.exports : (window.WorldEvents = {}));


// housing.js
// housing.js
/**
 * ZION Player Housing System
 * Claim land, build rooms, place furniture, invite visitors.
 * Layer 1 - No project dependencies
 */

(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Constants
  // ---------------------------------------------------------------------------

  var PLOT_COST = 50;
  var ROOM_COST = 10;

  // Room type definitions
  var ROOM_TYPES = {
    bedroom:     { id: 'bedroom',     name: 'Bedroom',     maxFurniture: 8,  comfortBonus: { rest: 10 } },
    kitchen:     { id: 'kitchen',     name: 'Kitchen',     maxFurniture: 6,  comfortBonus: { food: 8 } },
    workshop:    { id: 'workshop',    name: 'Workshop',    maxFurniture: 10, comfortBonus: { craft: 15 } },
    garden:      { id: 'garden',      name: 'Garden',      maxFurniture: 12, comfortBonus: { nature: 10 } },
    gallery:     { id: 'gallery',     name: 'Gallery',     maxFurniture: 10, comfortBonus: { culture: 12 } },
    library:     { id: 'library',     name: 'Library',     maxFurniture: 10, comfortBonus: { knowledge: 15 } },
    music_room:  { id: 'music_room',  name: 'Music Room',  maxFurniture: 8,  comfortBonus: { creativity: 12 } },
    trophy_room: { id: 'trophy_room', name: 'Trophy Room', maxFurniture: 16, comfortBonus: { prestige: 20 } }
  };

  // Furniture catalog â€” 30+ items
  var FURNITURE_CATALOG = {
    // Seating
    wooden_chair:    { id: 'wooden_chair',    name: 'Wooden Chair',     category: 'seating',         cost: 2,  decorScore: 1 },
    cushioned_chair: { id: 'cushioned_chair', name: 'Cushioned Chair',  category: 'seating',         cost: 5,  decorScore: 3 },
    sofa:            { id: 'sofa',            name: 'Sofa',             category: 'seating',         cost: 12, decorScore: 6 },
    bench:           { id: 'bench',           name: 'Bench',            category: 'seating',         cost: 4,  decorScore: 2 },
    rocking_chair:   { id: 'rocking_chair',   name: 'Rocking Chair',    category: 'seating',         cost: 8,  decorScore: 5 },

    // Tables
    wooden_table:    { id: 'wooden_table',    name: 'Wooden Table',     category: 'tables',          cost: 6,  decorScore: 3 },
    dining_table:    { id: 'dining_table',    name: 'Dining Table',     category: 'tables',          cost: 15, decorScore: 7 },
    writing_desk:    { id: 'writing_desk',    name: 'Writing Desk',     category: 'tables',          cost: 10, decorScore: 5 },
    coffee_table:    { id: 'coffee_table',    name: 'Coffee Table',     category: 'tables',          cost: 8,  decorScore: 4 },

    // Storage
    wooden_chest:    { id: 'wooden_chest',    name: 'Wooden Chest',     category: 'storage',         cost: 8,  decorScore: 2 },
    bookshelf:       { id: 'bookshelf',       name: 'Bookshelf',        category: 'storage',         cost: 12, decorScore: 6 },
    wardrobe:        { id: 'wardrobe',        name: 'Wardrobe',         category: 'storage',         cost: 15, decorScore: 5 },
    cabinet:         { id: 'cabinet',         name: 'Cabinet',          category: 'storage',         cost: 10, decorScore: 4 },

    // Decoration
    painting:        { id: 'painting',        name: 'Painting',         category: 'decoration',      cost: 10, decorScore: 8 },
    tapestry:        { id: 'tapestry',        name: 'Tapestry',         category: 'decoration',      cost: 12, decorScore: 9 },
    trophy:          { id: 'trophy',          name: 'Trophy',           category: 'decoration',      cost: 5,  decorScore: 7 },
    plant_pot:       { id: 'plant_pot',       name: 'Plant Pot',        category: 'decoration',      cost: 3,  decorScore: 3 },
    statue:          { id: 'statue',          name: 'Statue',           category: 'decoration',      cost: 20, decorScore: 12 },
    rug:             { id: 'rug',             name: 'Rug',              category: 'decoration',      cost: 8,  decorScore: 5 },
    mirror:          { id: 'mirror',          name: 'Mirror',           category: 'decoration',      cost: 7,  decorScore: 4 },

    // Lighting
    candle:          { id: 'candle',          name: 'Candle',           category: 'lighting',        cost: 2,  decorScore: 2 },
    lantern:         { id: 'lantern',         name: 'Lantern',          category: 'lighting',        cost: 5,  decorScore: 4 },
    chandelier:      { id: 'chandelier',      name: 'Chandelier',       category: 'lighting',        cost: 25, decorScore: 14 },
    wall_sconce:     { id: 'wall_sconce',     name: 'Wall Sconce',      category: 'lighting',        cost: 6,  decorScore: 4 },

    // Crafting stations
    forge:           { id: 'forge',           name: 'Forge',            category: 'crafting_station', cost: 30, decorScore: 6 },
    alchemy_bench:   { id: 'alchemy_bench',   name: 'Alchemy Bench',    category: 'crafting_station', cost: 25, decorScore: 7 },
    loom:            { id: 'loom',            name: 'Loom',             category: 'crafting_station', cost: 20, decorScore: 5 },
    carpentry_bench: { id: 'carpentry_bench', name: 'Carpentry Bench',  category: 'crafting_station', cost: 18, decorScore: 5 },
    enchanting_table:{ id: 'enchanting_table',name: 'Enchanting Table', category: 'crafting_station', cost: 35, decorScore: 10 },

    // Music
    piano:           { id: 'piano',           name: 'Piano',            category: 'music',           cost: 40, decorScore: 15 },
    harp:            { id: 'harp',            name: 'Harp',             category: 'music',           cost: 30, decorScore: 13 },
    drum_kit:        { id: 'drum_kit',        name: 'Drum Kit',         category: 'music',           cost: 22, decorScore: 8 }
  };

  // House size tiers
  var HOUSE_SIZES = {
    cottage: { id: 'cottage', name: 'Cottage', maxRooms: 4,  upgradeCost: 30 },
    house:   { id: 'house',   name: 'House',   maxRooms: 6,  upgradeCost: 60 },
    manor:   { id: 'manor',   name: 'Manor',   maxRooms: 8,  upgradeCost: 100 },
    estate:  { id: 'estate',  name: 'Estate',  maxRooms: 12, upgradeCost: null }
  };

  var SIZE_UPGRADE_PATH = ['cottage', 'house', 'manor', 'estate'];

  // Visitor access levels
  var ACCESS_LEVELS = {
    public:  'public',
    friends: 'friends',
    private: 'private'
  };

  // ---------------------------------------------------------------------------
  // Module state
  // ---------------------------------------------------------------------------

  var plots = {};          // playerId -> plot object
  var currentVisitors = {};// plotId -> [ playerId, ... ]
  var nextFurnitureId = 1;
  var nextRoomId = 1;

  // ---------------------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------------------

  function _generateRoomId() {
    return 'room_' + (nextRoomId++);
  }

  function _generateFurnitureId() {
    return 'furn_' + (nextFurnitureId++);
  }

  function _getNextSize(currentSize) {
    var idx = SIZE_UPGRADE_PATH.indexOf(currentSize);
    if (idx === -1 || idx === SIZE_UPGRADE_PATH.length - 1) return null;
    return SIZE_UPGRADE_PATH[idx + 1];
  }

  // ---------------------------------------------------------------------------
  // Plot management
  // ---------------------------------------------------------------------------

  /**
   * Claim a plot for a player.
   * @param {string} playerId
   * @param {string} plotName - display name
   * @param {object} ledger - Economy ledger (must have spendSpark method)
   * @param {function} spendFn - spendSpark(ledger, playerId, amount) -> {success,error}
   * @returns {{ success: boolean, plot?: object, error?: string }}
   */
  function claimPlot(playerId, plotName, ledger, spendFn) {
    if (!playerId) return { success: false, error: 'Missing playerId' };
    if (plots[playerId]) return { success: false, error: 'Player already owns a plot' };

    if (ledger && spendFn) {
      var result = spendFn(ledger, playerId, PLOT_COST);
      if (!result.success) return { success: false, error: result.error || 'Insufficient funds' };
    }

    var plot = {
      id: 'plot_' + playerId,
      owner: playerId,
      name: plotName || (playerId + "'s Home"),
      size: 'cottage',
      rooms: [],
      accessLevel: 'private',
      friendList: [],
      createdAt: Date.now()
    };

    plots[playerId] = plot;
    currentVisitors[plot.id] = [];
    return { success: true, plot: plot };
  }

  /**
   * Get a player's plot.
   * @param {string} playerId
   * @returns {object|null}
   */
  function getPlot(playerId) {
    return plots[playerId] || null;
  }

  // ---------------------------------------------------------------------------
  // Room management
  // ---------------------------------------------------------------------------

  /**
   * Build a room in a player's house.
   * @param {string} playerId
   * @param {string} roomType - key from ROOM_TYPES
   * @param {string} roomName - display name
   * @param {object} ledger
   * @param {function} spendFn
   * @returns {{ success: boolean, room?: object, error?: string }}
   */
  function buildRoom(playerId, roomType, roomName, ledger, spendFn) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };
    if (!ROOM_TYPES[roomType]) return { success: false, error: 'Invalid room type' };

    var maxRooms = HOUSE_SIZES[plot.size].maxRooms;
    if (plot.rooms.length >= maxRooms) {
      return { success: false, error: 'House is full. Upgrade to add more rooms.' };
    }

    if (ledger && spendFn) {
      var result = spendFn(ledger, playerId, ROOM_COST);
      if (!result.success) return { success: false, error: result.error || 'Insufficient funds' };
    }

    var room = {
      id: _generateRoomId(),
      type: roomType,
      name: roomName || ROOM_TYPES[roomType].name,
      furniture: []
    };

    plot.rooms.push(room);
    return { success: true, room: room };
  }

  /**
   * Remove a room (and all its furniture) from a player's house.
   * @param {string} playerId
   * @param {string} roomId
   * @returns {{ success: boolean, error?: string }}
   */
  function removeRoom(playerId, roomId) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };

    var idx = -1;
    for (var i = 0; i < plot.rooms.length; i++) {
      if (plot.rooms[i].id === roomId) { idx = i; break; }
    }
    if (idx === -1) return { success: false, error: 'Room not found' };

    plot.rooms.splice(idx, 1);
    return { success: true };
  }

  // ---------------------------------------------------------------------------
  // Furniture management
  // ---------------------------------------------------------------------------

  /**
   * Place furniture in a room.
   * @param {string} playerId
   * @param {string} roomId
   * @param {string} furnitureTypeId - key from FURNITURE_CATALOG
   * @param {object} ledger
   * @param {function} spendFn
   * @returns {{ success: boolean, furniture?: object, error?: string }}
   */
  function placeFurniture(playerId, roomId, furnitureTypeId, ledger, spendFn) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };

    var catalogItem = FURNITURE_CATALOG[furnitureTypeId];
    if (!catalogItem) return { success: false, error: 'Invalid furniture type' };

    var room = null;
    for (var i = 0; i < plot.rooms.length; i++) {
      if (plot.rooms[i].id === roomId) { room = plot.rooms[i]; break; }
    }
    if (!room) return { success: false, error: 'Room not found' };

    var maxFurniture = ROOM_TYPES[room.type].maxFurniture;
    if (room.furniture.length >= maxFurniture) {
      return { success: false, error: 'Room is full' };
    }

    if (ledger && spendFn) {
      var result = spendFn(ledger, playerId, catalogItem.cost);
      if (!result.success) return { success: false, error: result.error || 'Insufficient funds' };
    }

    var item = {
      id: _generateFurnitureId(),
      typeId: furnitureTypeId,
      name: catalogItem.name,
      category: catalogItem.category,
      decorScore: catalogItem.decorScore,
      placedAt: Date.now()
    };

    room.furniture.push(item);
    return { success: true, furniture: item };
  }

  /**
   * Remove a piece of furniture from a room.
   * @param {string} playerId
   * @param {string} roomId
   * @param {string} furnitureId - instance id (furn_N)
   * @returns {{ success: boolean, error?: string }}
   */
  function removeFurniture(playerId, roomId, furnitureId) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };

    var room = null;
    for (var i = 0; i < plot.rooms.length; i++) {
      if (plot.rooms[i].id === roomId) { room = plot.rooms[i]; break; }
    }
    if (!room) return { success: false, error: 'Room not found' };

    var idx = -1;
    for (var j = 0; j < room.furniture.length; j++) {
      if (room.furniture[j].id === furnitureId) { idx = j; break; }
    }
    if (idx === -1) return { success: false, error: 'Furniture not found' };

    room.furniture.splice(idx, 1);
    return { success: true };
  }

  /**
   * Get all furniture in a specific room.
   * @param {string} playerId
   * @param {string} roomId
   * @returns {{ success: boolean, furniture?: Array, error?: string }}
   */
  function getFurnitureInRoom(playerId, roomId) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found', furniture: [] };

    for (var i = 0; i < plot.rooms.length; i++) {
      if (plot.rooms[i].id === roomId) {
        return { success: true, furniture: plot.rooms[i].furniture };
      }
    }
    return { success: false, error: 'Room not found', furniture: [] };
  }

  // ---------------------------------------------------------------------------
  // House layout / upgrade
  // ---------------------------------------------------------------------------

  /**
   * Get a full layout description of a player's house.
   * @param {string} playerId
   * @returns {{ success: boolean, layout?: object, error?: string }}
   */
  function getHouseLayout(playerId) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };

    var sizeInfo = HOUSE_SIZES[plot.size];
    var layout = {
      plotId: plot.id,
      owner: plot.owner,
      name: plot.name,
      size: plot.size,
      sizeName: sizeInfo.name,
      maxRooms: sizeInfo.maxRooms,
      rooms: plot.rooms.map(function(r) {
        return {
          id: r.id,
          type: r.type,
          name: r.name,
          furnitureCount: r.furniture.length,
          maxFurniture: ROOM_TYPES[r.type].maxFurniture
        };
      }),
      accessLevel: plot.accessLevel,
      roomCount: plot.rooms.length
    };
    return { success: true, layout: layout };
  }

  /**
   * Upgrade house to the next size tier.
   * @param {string} playerId
   * @param {object} ledger
   * @param {function} spendFn
   * @returns {{ success: boolean, newSize?: string, error?: string }}
   */
  function upgradeHouse(playerId, ledger, spendFn) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };

    var nextSize = _getNextSize(plot.size);
    if (!nextSize) return { success: false, error: 'House is already at maximum size' };

    var upgradeCost = HOUSE_SIZES[plot.size].upgradeCost;
    if (upgradeCost === null) return { success: false, error: 'House is already at maximum size' };

    if (ledger && spendFn) {
      var result = spendFn(ledger, playerId, upgradeCost);
      if (!result.success) return { success: false, error: result.error || 'Insufficient funds' };
    }

    plot.size = nextSize;
    return { success: true, newSize: nextSize };
  }

  // ---------------------------------------------------------------------------
  // Visitor access
  // ---------------------------------------------------------------------------

  /**
   * Set the visitor access level for a house.
   * @param {string} playerId
   * @param {string} level - 'public' | 'friends' | 'private'
   * @returns {{ success: boolean, error?: string }}
   */
  function setVisitorAccess(playerId, level) {
    if (!ACCESS_LEVELS[level]) return { success: false, error: 'Invalid access level. Use: public, friends, private' };
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found' };
    plot.accessLevel = level;
    return { success: true };
  }

  /**
   * Add a player to the friend/visitor permission list.
   * @param {string} ownerId
   * @param {string} friendId
   * @returns {{ success: boolean, error?: string }}
   */
  function addVisitorPermission(ownerId, friendId) {
    if (!friendId) return { success: false, error: 'Missing friendId' };
    var plot = plots[ownerId];
    if (!plot) return { success: false, error: 'No plot found' };
    if (plot.friendList.indexOf(friendId) !== -1) {
      return { success: false, error: 'Already on friend list' };
    }
    plot.friendList.push(friendId);
    return { success: true };
  }

  /**
   * Remove a player from the friend/visitor permission list.
   * @param {string} ownerId
   * @param {string} friendId
   * @returns {{ success: boolean, error?: string }}
   */
  function removeVisitorPermission(ownerId, friendId) {
    var plot = plots[ownerId];
    if (!plot) return { success: false, error: 'No plot found' };
    var idx = plot.friendList.indexOf(friendId);
    if (idx === -1) return { success: false, error: 'Not on friend list' };
    plot.friendList.splice(idx, 1);
    return { success: true };
  }

  /**
   * Get list of friends permitted to visit.
   * @param {string} playerId
   * @returns {{ success: boolean, friends?: Array, error?: string }}
   */
  function getVisitors(playerId) {
    var plot = plots[playerId];
    if (!plot) return { success: false, error: 'No plot found', friends: [] };
    return { success: true, friends: plot.friendList.slice() };
  }

  // ---------------------------------------------------------------------------
  // Visit mechanics
  // ---------------------------------------------------------------------------

  /**
   * Check whether a visitor can enter a house.
   * @param {string} ownerId
   * @param {string} visitorId
   * @returns {boolean}
   */
  function _canVisit(ownerId, visitorId) {
    var plot = plots[ownerId];
    if (!plot) return false;
    if (visitorId === ownerId) return true;
    if (plot.accessLevel === 'public') return true;
    if (plot.accessLevel === 'friends') return plot.friendList.indexOf(visitorId) !== -1;
    return false; // private
  }

  /**
   * A visitor enters a house.
   * @param {string} ownerId
   * @param {string} visitorId
   * @returns {{ success: boolean, error?: string }}
   */
  function visitHouse(ownerId, visitorId) {
    if (!visitorId) return { success: false, error: 'Missing visitorId' };
    var plot = plots[ownerId];
    if (!plot) return { success: false, error: 'No plot found' };
    if (!_canVisit(ownerId, visitorId)) {
      return { success: false, error: 'Access denied' };
    }

    var visitors = currentVisitors[plot.id];
    if (!visitors) { visitors = []; currentVisitors[plot.id] = visitors; }
    if (visitors.indexOf(visitorId) !== -1) {
      return { success: false, error: 'Already visiting' };
    }
    visitors.push(visitorId);
    return { success: true };
  }

  /**
   * A visitor leaves a house.
   * @param {string} ownerId
   * @param {string} visitorId
   * @returns {{ success: boolean, error?: string }}
   */
  function leaveHouse(ownerId, visitorId) {
    var plot = plots[ownerId];
    if (!plot) return { success: false, error: 'No plot found' };

    var visitors = currentVisitors[plot.id] || [];
    var idx = visitors.indexOf(visitorId);
    if (idx === -1) return { success: false, error: 'Visitor not present' };
    visitors.splice(idx, 1);
    return { success: true };
  }

  /**
   * Get current visitors present in a house.
   * @param {string} ownerId
   * @returns {Array}
   */
  function getCurrentVisitors(ownerId) {
    var plot = plots[ownerId];
    if (!plot) return [];
    return (currentVisitors[plot.id] || []).slice();
  }

  // ---------------------------------------------------------------------------
  // Scoring
  // ---------------------------------------------------------------------------

  /**
   * Calculate total decoration score for a house.
   * Higher scores mean better-decorated homes.
   * @param {string} playerId
   * @returns {number}
   */
  function getHouseScore(playerId) {
    var plot = plots[playerId];
    if (!plot) return 0;

    var total = 0;
    for (var i = 0; i < plot.rooms.length; i++) {
      var room = plot.rooms[i];
      for (var j = 0; j < room.furniture.length; j++) {
        total += room.furniture[j].decorScore || 0;
      }
    }

    // Size multiplier bonus
    var sizeBonus = { cottage: 1, house: 1.1, manor: 1.25, estate: 1.5 };
    total = Math.floor(total * (sizeBonus[plot.size] || 1));

    return total;
  }

  /**
   * Calculate comfort bonuses provided by the house.
   * Aggregates room-type bonuses for rooms that have at least one piece of furniture.
   * @param {string} playerId
   * @returns {object} bonus map e.g. { rest: 10, craft: 15 }
   */
  function getComfortBonus(playerId) {
    var plot = plots[playerId];
    if (!plot) return {};

    var bonuses = {};
    for (var i = 0; i < plot.rooms.length; i++) {
      var room = plot.rooms[i];
      // Room must have at least one piece of furniture to grant its bonus
      if (room.furniture.length === 0) continue;
      var roomBonus = ROOM_TYPES[room.type].comfortBonus;
      for (var key in roomBonus) {
        if (roomBonus.hasOwnProperty(key)) {
          bonuses[key] = (bonuses[key] || 0) + roomBonus[key];
        }
      }
    }
    return bonuses;
  }

  // ---------------------------------------------------------------------------
  // State persistence
  // ---------------------------------------------------------------------------

  /**
   * Serialize state for persistence.
   * @returns {object}
   */
  function getHousingState() {
    return {
      plots: plots,
      currentVisitors: currentVisitors,
      nextFurnitureId: nextFurnitureId,
      nextRoomId: nextRoomId
    };
  }

  /**
   * Load saved housing state.
   * @param {object} savedData
   */
  function initHousing(savedData) {
    if (!savedData) return;
    plots = savedData.plots || {};
    currentVisitors = savedData.currentVisitors || {};
    nextFurnitureId = savedData.nextFurnitureId || 1;
    nextRoomId = savedData.nextRoomId || 1;
  }

  /**
   * Reset all housing state (for testing).
   */
  function _reset() {
    plots = {};
    currentVisitors = {};
    nextFurnitureId = 1;
    nextRoomId = 1;
  }

  // ---------------------------------------------------------------------------
  // Exports
  // ---------------------------------------------------------------------------

  exports.ROOM_TYPES            = ROOM_TYPES;
  exports.FURNITURE_CATALOG     = FURNITURE_CATALOG;
  exports.HOUSE_SIZES           = HOUSE_SIZES;
  exports.ACCESS_LEVELS         = ACCESS_LEVELS;
  exports.PLOT_COST             = PLOT_COST;
  exports.ROOM_COST             = ROOM_COST;

  exports.claimPlot             = claimPlot;
  exports.getPlot               = getPlot;

  exports.buildRoom             = buildRoom;
  exports.removeRoom            = removeRoom;

  exports.placeFurniture        = placeFurniture;
  exports.removeFurniture       = removeFurniture;
  exports.getFurnitureInRoom    = getFurnitureInRoom;

  exports.getHouseLayout        = getHouseLayout;
  exports.upgradeHouse          = upgradeHouse;

  exports.setVisitorAccess      = setVisitorAccess;
  exports.addVisitorPermission  = addVisitorPermission;
  exports.removeVisitorPermission = removeVisitorPermission;
  exports.getVisitors           = getVisitors;
  exports.visitHouse            = visitHouse;
  exports.leaveHouse            = leaveHouse;
  exports.getCurrentVisitors    = getCurrentVisitors;

  exports.getHouseScore         = getHouseScore;
  exports.getComfortBonus       = getComfortBonus;

  exports.getHousingState       = getHousingState;
  exports.initHousing           = initHousing;
  exports._reset                = _reset;

})(typeof module !== 'undefined' ? module.exports : (window.Housing = {}));


// fishing.js
// fishing.js
(function(exports) {
  'use strict';

  // â”€â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var PERFECT_TIMING_BONUS = 1.5;

  // Catch rates by rarity (probability weight, not percentage)
  var CATCH_RATES = {
    common:    100,
    uncommon:   40,
    rare:       15,
    epic:        5,
    legendary:   1
  };

  // â”€â”€â”€ FISH CATALOG (25+ species) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var FISH_CATALOG = [
    // â”€â”€ Common â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
      id: 'sunfish',
      name: 'Sunfish',
      rarity: 'common',
      zone: ['nexus', 'gardens', 'commons'],
      value: 5,
      weightMin: 0.2,
      weightMax: 1.5,
      season: ['spring', 'summer'],
      description: 'A small, cheerful fish that loves warm shallows.'
    },
    {
      id: 'river_perch',
      name: 'River Perch',
      rarity: 'common',
      zone: ['wilds', 'agora', 'nexus'],
      value: 6,
      weightMin: 0.3,
      weightMax: 2.0,
      season: ['spring', 'summer', 'autumn'],
      description: 'A hardy perch found in most waterways.'
    },
    {
      id: 'blue_gill',
      name: 'Blue Gill',
      rarity: 'common',
      zone: ['gardens', 'commons', 'studio'],
      value: 4,
      weightMin: 0.1,
      weightMax: 1.0,
      season: ['spring', 'summer', 'autumn', 'winter'],
      description: 'Year-round staple of the Gardens ponds.'
    },
    {
      id: 'mud_carp',
      name: 'Mud Carp',
      rarity: 'common',
      zone: ['agora', 'nexus'],
      value: 3,
      weightMin: 0.5,
      weightMax: 3.0,
      season: ['spring', 'summer', 'autumn', 'winter'],
      description: 'Abundant and easy to catch. Not glamorous, but filling.'
    },
    {
      id: 'stone_loach',
      name: 'Stone Loach',
      rarity: 'common',
      zone: ['wilds', 'arena'],
      value: 5,
      weightMin: 0.1,
      weightMax: 0.8,
      season: ['spring', 'summer', 'autumn', 'winter'],
      description: 'Hides under rocks in fast-moving streams.'
    },
    {
      id: 'freshwater_eel',
      name: 'Freshwater Eel',
      rarity: 'common',
      zone: ['wilds', 'agora', 'commons'],
      value: 7,
      weightMin: 0.4,
      weightMax: 2.5,
      season: ['summer', 'autumn'],
      description: 'Slippery and surprisingly tasty.'
    },
    // â”€â”€ Uncommon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
      id: 'silver_trout',
      name: 'Silver Trout',
      rarity: 'uncommon',
      zone: ['wilds', 'gardens'],
      value: 15,
      weightMin: 0.5,
      weightMax: 4.0,
      season: ['spring', 'autumn'],
      description: 'Quick and spirited â€” a favourite of sport anglers.'
    },
    {
      id: 'golden_roach',
      name: 'Golden Roach',
      rarity: 'uncommon',
      zone: ['nexus', 'commons'],
      value: 18,
      weightMin: 0.3,
      weightMax: 2.5,
      season: ['spring', 'summer'],
      description: 'Gleams like a coin beneath the surface.'
    },
    {
      id: 'crystal_bass',
      name: 'Crystal Bass',
      rarity: 'uncommon',
      zone: ['athenaeum', 'gardens'],
      value: 20,
      weightMin: 0.8,
      weightMax: 5.0,
      season: ['summer', 'autumn'],
      description: 'Its scales refract light into tiny rainbows.'
    },
    {
      id: 'bronze_bream',
      name: 'Bronze Bream',
      rarity: 'uncommon',
      zone: ['agora', 'studio'],
      value: 16,
      weightMin: 0.4,
      weightMax: 3.0,
      season: ['summer', 'autumn', 'winter'],
      description: 'Deep bronze colouring makes it easy to admire in the creel.'
    },
    {
      id: 'spotted_pike',
      name: 'Spotted Pike',
      rarity: 'uncommon',
      zone: ['wilds', 'arena'],
      value: 22,
      weightMin: 1.0,
      weightMax: 6.0,
      season: ['autumn', 'winter'],
      description: 'An ambush predator with distinctive dark spots.'
    },
    {
      id: 'jade_gudgeon',
      name: 'Jade Gudgeon',
      rarity: 'uncommon',
      zone: ['gardens', 'athenaeum'],
      value: 14,
      weightMin: 0.1,
      weightMax: 0.6,
      season: ['spring', 'summer'],
      description: 'Tiny but prized for its jade-green tint.'
    },
    // â”€â”€ Rare â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
      id: 'moonfish',
      name: 'Moonfish',
      rarity: 'rare',
      zone: ['wilds', 'nexus'],
      value: 60,
      weightMin: 1.0,
      weightMax: 8.0,
      season: ['winter'],
      description: 'Glows softly on moonlit nights. Only bites after dusk.'
    },
    {
      id: 'ghost_carp',
      name: 'Ghost Carp',
      rarity: 'rare',
      zone: ['athenaeum', 'studio'],
      value: 75,
      weightMin: 2.0,
      weightMax: 12.0,
      season: ['autumn', 'winter'],
      description: 'Nearly translucent. Legends say it carries memories of the deep.'
    },
    {
      id: 'thunder_eel',
      name: 'Thunder Eel',
      rarity: 'rare',
      zone: ['arena', 'wilds'],
      value: 80,
      weightMin: 1.5,
      weightMax: 10.0,
      season: ['summer'],
      description: 'Crackles with static energy. Handle with care!'
    },
    {
      id: 'prism_perch',
      name: 'Prism Perch',
      rarity: 'rare',
      zone: ['gardens', 'commons'],
      value: 65,
      weightMin: 0.8,
      weightMax: 5.0,
      season: ['spring'],
      description: 'Every scale shifts through the full spectrum at sunrise.'
    },
    {
      id: 'cobalt_salmon',
      name: 'Cobalt Salmon',
      rarity: 'rare',
      zone: ['wilds', 'agora'],
      value: 70,
      weightMin: 2.5,
      weightMax: 9.0,
      season: ['autumn'],
      description: 'Migrates upriver once each autumn. Fiercely fought.'
    },
    {
      id: 'ember_catfish',
      name: 'Ember Catfish',
      rarity: 'rare',
      zone: ['studio', 'arena'],
      value: 72,
      weightMin: 3.0,
      weightMax: 14.0,
      season: ['summer', 'autumn'],
      description: 'Whiskers glow orange like cooling embers.'
    },
    // â”€â”€ Epic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
      id: 'void_sturgeon',
      name: 'Void Sturgeon',
      rarity: 'epic',
      zone: ['nexus', 'arena'],
      value: 200,
      weightMin: 10.0,
      weightMax: 40.0,
      season: ['winter'],
      description: 'An ancient creature from before the world was shaped. Exceptionally rare.'
    },
    {
      id: 'starweave_koi',
      name: 'Starweave Koi',
      rarity: 'epic',
      zone: ['gardens', 'athenaeum'],
      value: 220,
      weightMin: 5.0,
      weightMax: 20.0,
      season: ['spring', 'summer'],
      description: 'Its patterns mirror the night sky. A treasure of the Gardens.'
    },
    {
      id: 'abyssal_pike',
      name: 'Abyssal Pike',
      rarity: 'epic',
      zone: ['wilds', 'studio'],
      value: 250,
      weightMin: 8.0,
      weightMax: 35.0,
      season: ['autumn', 'winter'],
      description: 'Comes from waters so deep they have no name.'
    },
    // â”€â”€ Legendary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
      id: 'elder_leviathan',
      name: 'Elder Leviathan',
      rarity: 'legendary',
      zone: ['nexus'],
      value: 1000,
      weightMin: 50.0,
      weightMax: 150.0,
      season: ['winter'],
      description: 'The lord of all waters. Few have seen it. Fewer have landed it.'
    },
    {
      id: 'solarfin',
      name: 'Solarfin',
      rarity: 'legendary',
      zone: ['gardens'],
      value: 900,
      weightMin: 20.0,
      weightMax: 80.0,
      season: ['summer'],
      description: 'Burns bright as the noon sun. Only surfaces on the longest days.'
    },
    {
      id: 'rift_ray',
      name: 'Rift Ray',
      rarity: 'legendary',
      zone: ['studio', 'athenaeum'],
      value: 950,
      weightMin: 30.0,
      weightMax: 100.0,
      season: ['autumn'],
      description: 'Glides between dimensions. Catching one is said to change your fate.'
    },
    {
      id: 'chronofish',
      name: 'Chronofish',
      rarity: 'legendary',
      zone: ['nexus', 'wilds'],
      value: 1200,
      weightMin: 15.0,
      weightMax: 60.0,
      season: ['spring', 'summer', 'autumn', 'winter'],
      description: 'Exists slightly outside of time. Can be caught in any season, but almost never is.'
    }
  ];

  // â”€â”€â”€ BAIT TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var BAIT_TYPES = {
    worm: {
      id: 'worm',
      name: 'Earthworm',
      description: 'Basic bait. Attracts most common and uncommon fish.',
      rarityBonus: { common: 1.2, uncommon: 1.1, rare: 0.8, epic: 0.5, legendary: 0.3 },
      cost: 2,
      zoneBonus: null
    },
    cricket: {
      id: 'cricket',
      name: 'Cricket',
      description: 'Surface bait good for warm-weather fish.',
      rarityBonus: { common: 1.1, uncommon: 1.3, rare: 0.9, epic: 0.6, legendary: 0.4 },
      cost: 3,
      zoneBonus: ['wilds', 'gardens']
    },
    minnow: {
      id: 'minnow',
      name: 'Live Minnow',
      description: 'Attracts larger predator fish.',
      rarityBonus: { common: 0.8, uncommon: 1.2, rare: 1.4, epic: 1.0, legendary: 0.6 },
      cost: 8,
      zoneBonus: ['arena', 'wilds']
    },
    special_lure: {
      id: 'special_lure',
      name: 'Special Lure',
      description: 'A crafted lure that draws rare and epic species.',
      rarityBonus: { common: 0.6, uncommon: 1.0, rare: 1.6, epic: 1.4, legendary: 0.8 },
      cost: 20,
      zoneBonus: null
    },
    golden_fly: {
      id: 'golden_fly',
      name: 'Golden Fly',
      description: 'Legendary bait. Greatly increases chance of legendary catches.',
      rarityBonus: { common: 0.4, uncommon: 0.8, rare: 1.2, epic: 1.8, legendary: 3.0 },
      cost: 100,
      zoneBonus: null
    }
  };

  // â”€â”€â”€ ROD TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var ROD_TYPES = {
    basic: {
      id: 'basic',
      name: 'Basic Rod',
      description: 'A simple wooden rod. Gets the job done.',
      catchBonus: 1.0,
      timingWindow: 1.0,   // multiplier on perfect-timing window width
      rarityBonus: { common: 1.0, uncommon: 0.8, rare: 0.5, epic: 0.3, legendary: 0.1 },
      cost: 0
    },
    improved: {
      id: 'improved',
      name: 'Improved Rod',
      description: 'Steel-reinforced. Noticeably better action.',
      catchBonus: 1.2,
      timingWindow: 1.2,
      rarityBonus: { common: 1.0, uncommon: 1.1, rare: 0.8, epic: 0.5, legendary: 0.2 },
      cost: 50
    },
    master: {
      id: 'master',
      name: 'Master Rod',
      description: 'Handcrafted from enchanted timber. Favoured by serious anglers.',
      catchBonus: 1.5,
      timingWindow: 1.4,
      rarityBonus: { common: 1.0, uncommon: 1.2, rare: 1.2, epic: 0.8, legendary: 0.4 },
      cost: 200
    },
    legendary: {
      id: 'legendary',
      name: 'Legendary Rod',
      description: 'Forged from a fallen star. Draws forth creatures from the depths of legend.',
      catchBonus: 2.0,
      timingWindow: 1.8,
      rarityBonus: { common: 1.0, uncommon: 1.2, rare: 1.5, epic: 1.5, legendary: 1.5 },
      cost: 1000
    }
  };

  // â”€â”€â”€ FISHING ZONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var FISHING_ZONES = {
    nexus: {
      zoneId: 'nexus',
      name: 'Nexus Fountain Pool',
      spots: 3,
      fish: ['sunfish', 'mud_carp', 'golden_roach', 'moonfish', 'void_sturgeon', 'elder_leviathan', 'chronofish'],
      difficulty: 'easy',
      catchRateBonus: 1.0
    },
    gardens: {
      zoneId: 'gardens',
      name: 'Gardens Koi Ponds',
      spots: 5,
      fish: ['sunfish', 'blue_gill', 'silver_trout', 'golden_roach', 'crystal_bass', 'jade_gudgeon', 'prism_perch', 'starweave_koi', 'solarfin'],
      difficulty: 'easy',
      catchRateBonus: 1.1
    },
    athenaeum: {
      zoneId: 'athenaeum',
      name: 'Athenaeum Reflection Pool',
      spots: 2,
      fish: ['blue_gill', 'jade_gudgeon', 'crystal_bass', 'ghost_carp', 'starweave_koi', 'rift_ray'],
      difficulty: 'medium',
      catchRateBonus: 0.9
    },
    studio: {
      zoneId: 'studio',
      name: 'Studio Canal',
      spots: 3,
      fish: ['blue_gill', 'bronze_bream', 'ghost_carp', 'ember_catfish', 'abyssal_pike', 'rift_ray'],
      difficulty: 'medium',
      catchRateBonus: 1.0
    },
    wilds: {
      zoneId: 'wilds',
      name: 'Wilds River Network',
      spots: 8,
      fish: ['river_perch', 'stone_loach', 'freshwater_eel', 'silver_trout', 'spotted_pike', 'moonfish', 'thunder_eel', 'cobalt_salmon', 'abyssal_pike', 'chronofish'],
      difficulty: 'medium',
      catchRateBonus: 1.2
    },
    agora: {
      zoneId: 'agora',
      name: 'Agora Market Docks',
      spots: 4,
      fish: ['river_perch', 'mud_carp', 'freshwater_eel', 'bronze_bream', 'cobalt_salmon'],
      difficulty: 'easy',
      catchRateBonus: 1.05
    },
    commons: {
      zoneId: 'commons',
      name: 'Commons Lake',
      spots: 6,
      fish: ['sunfish', 'blue_gill', 'freshwater_eel', 'golden_roach', 'bronze_bream', 'prism_perch'],
      difficulty: 'easy',
      catchRateBonus: 1.15
    },
    arena: {
      zoneId: 'arena',
      name: 'Arena Storm Pools',
      spots: 3,
      fish: ['stone_loach', 'spotted_pike', 'thunder_eel', 'ember_catfish', 'void_sturgeon'],
      difficulty: 'hard',
      catchRateBonus: 0.85
    }
  };

  // â”€â”€â”€ INTERNAL STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Active fishing sessions: { playerId -> { zone, bait, rod, castAt, state } }
  var _sessions = {};

  // Creel (catch basket) per player: { playerId -> [catch...] }
  var _creels = {};

  // Lifetime stats per player: { playerId -> stats }
  var _stats = {};

  // Fish populations per zone: { zoneId -> { fishId -> populationFactor (0..2) } }
  var _populations = {};

  // Active tournaments: { tournamentId -> tournament }
  var _tournaments = {};

  // â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _getOrInitCreel(playerId) {
    if (!_creels[playerId]) { _creels[playerId] = []; }
    return _creels[playerId];
  }

  function _getOrInitStats(playerId) {
    if (!_stats[playerId]) {
      _stats[playerId] = {
        totalCasts: 0,
        totalCatches: 0,
        totalSold: 0,
        totalEarned: 0,
        biggestCatch: null,
        rarestCatch: null,
        catchesByRarity: { common: 0, uncommon: 0, rare: 0, epic: 0, legendary: 0 },
        tournamentsEntered: 0,
        tournamentsWon: 0
      };
    }
    return _stats[playerId];
  }

  function _getOrInitPopulation(zoneId) {
    if (!_populations[zoneId]) {
      _populations[zoneId] = {};
      var zone = FISHING_ZONES[zoneId];
      if (zone) {
        for (var i = 0; i < zone.fish.length; i++) {
          _populations[zoneId][zone.fish[i]] = 1.0;
        }
      }
    }
    return _populations[zoneId];
  }

  function _rarityRank(rarity) {
    var ranks = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };
    return ranks[rarity] !== undefined ? ranks[rarity] : 0;
  }

  // Seeded pseudo-random (Mulberry32 â€” stdlib-safe)
  function _rand(seed) {
    var t = (seed + 0x6D2B79F5) >>> 0;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }

  // Pick a seed from current millisecond + extras for unpredictability
  function _rollSeed(extra) {
    return (Date.now() ^ (extra | 0)) >>> 0;
  }

  // Build the candidate fish pool for a zone/season/bait/rod combo
  function _buildPool(zoneId, season, baitId, rodId) {
    var zone = FISHING_ZONES[zoneId];
    if (!zone) { return []; }
    var bait = BAIT_TYPES[baitId] || BAIT_TYPES.worm;
    var rod  = ROD_TYPES[rodId]   || ROD_TYPES.basic;
    var pop  = _getOrInitPopulation(zoneId);

    var pool = [];
    for (var i = 0; i < zone.fish.length; i++) {
      var fishId = zone.fish[i];
      var fish = _getFishById(fishId);
      if (!fish) { continue; }

      // Season filter â€” if fish has specific seasons, skip off-season
      if (fish.season && fish.season.length > 0 && season) {
        if (fish.season.indexOf(season) === -1) { continue; }
      }

      var baseRate  = CATCH_RATES[fish.rarity] || 1;
      var baitMult  = (bait.rarityBonus[fish.rarity] || 1.0);
      var rodMult   = (rod.rarityBonus[fish.rarity]  || 1.0);
      var popFactor = (pop[fishId] !== undefined ? pop[fishId] : 1.0);
      var zoneMult  = zone.catchRateBonus || 1.0;

      // Zone-specific bait bonus
      if (bait.zoneBonus && bait.zoneBonus.indexOf(zoneId) !== -1) {
        baitMult *= 1.2;
      }

      var weight = baseRate * baitMult * rodMult * popFactor * zoneMult;
      if (weight > 0) {
        pool.push({ fish: fish, weight: weight });
      }
    }
    return pool;
  }

  function _pickFromPool(pool, seed) {
    if (pool.length === 0) { return null; }
    var total = 0;
    for (var i = 0; i < pool.length; i++) { total += pool[i].weight; }
    var roll = _rand(seed) * total;
    var cumulative = 0;
    for (var j = 0; j < pool.length; j++) {
      cumulative += pool[j].weight;
      if (roll <= cumulative) { return pool[j].fish; }
    }
    return pool[pool.length - 1].fish;
  }

  function _getFishById(fishId) {
    for (var i = 0; i < FISH_CATALOG.length; i++) {
      if (FISH_CATALOG[i].id === fishId) { return FISH_CATALOG[i]; }
    }
    return null;
  }

  function _randomWeight(fish, seed) {
    var range = fish.weightMax - fish.weightMin;
    return +(fish.weightMin + _rand(seed) * range).toFixed(2);
  }

  // â”€â”€â”€ FISHING ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Begin a fishing session for a player.
   * Returns the session object or null on error.
   */
  function startFishing(playerId, zoneId, baitId, rodId) {
    if (!playerId) { return null; }
    if (!FISHING_ZONES[zoneId]) { return null; }
    if (!BAIT_TYPES[baitId]) { baitId = 'worm'; }
    if (!ROD_TYPES[rodId])   { rodId  = 'basic'; }

    var session = {
      playerId: playerId,
      zone: zoneId,
      bait: baitId,
      rod: rodId,
      castAt: null,
      state: 'idle',   // idle | casting | waiting | biting | reeling
      lastResult: null
    };
    _sessions[playerId] = session;
    return session;
  }

  /**
   * Cast the line. Returns updated session or null.
   */
  function castLine(playerId) {
    var session = _sessions[playerId];
    if (!session) { return null; }
    if (session.state !== 'idle') { return null; }

    var stats = _getOrInitStats(playerId);
    stats.totalCasts++;

    session.state = 'waiting';
    session.castAt = Date.now();
    session.lastResult = null;
    return session;
  }

  /**
   * Check for a bite. Returns { bite: true/false, fish: fishObj|null } and
   * advances session to 'biting' state if a fish bites.
   * Pass currentSeason as one of 'spring'|'summer'|'autumn'|'winter'|null.
   */
  function getBite(playerId, currentSeason) {
    var session = _sessions[playerId];
    if (!session || session.state !== 'waiting') {
      return { bite: false, fish: null };
    }

    var pool = _buildPool(session.zone, currentSeason || null, session.bait, session.rod);
    if (pool.length === 0) { return { bite: false, fish: null }; }

    // Base bite probability (30%) modified by rod catch bonus
    var rod = ROD_TYPES[session.rod] || ROD_TYPES.basic;
    var biteProb = 0.30 * rod.catchBonus;
    if (biteProb > 0.95) { biteProb = 0.95; }

    var seed = _rollSeed(session.castAt || 0);
    if (_rand(seed) > biteProb) {
      return { bite: false, fish: null };
    }

    // Pick the fish
    var seed2 = _rollSeed(seed + 1);
    var fish = _pickFromPool(pool, seed2);
    session._pendingFish = fish;
    session._biteAt = Date.now();
    session.state = 'biting';

    return { bite: true, fish: fish };
  }

  /**
   * Reel in the line.
   * timing: 'early' | 'perfect' | 'late'
   * Returns catch result: { success, fish, weight, timing, bonusApplied } or null.
   */
  function reelIn(playerId, timing) {
    var session = _sessions[playerId];
    if (!session || session.state !== 'biting') { return null; }

    var fish = session._pendingFish;
    if (!fish) {
      session.state = 'idle';
      return { success: false, fish: null, weight: 0, timing: timing, bonusApplied: false };
    }

    var success = timing === 'perfect' || timing === 'early';
    // 'late' always loses the fish
    if (timing === 'late') { success = false; }

    var result = {
      success: success,
      fish: fish,
      weight: 0,
      timing: timing,
      bonusApplied: false
    };

    if (success) {
      var weightSeed = _rollSeed((session._biteAt || 0) + fish.id.length);
      var weight = _randomWeight(fish, weightSeed);

      if (timing === 'perfect') {
        weight = +(weight * PERFECT_TIMING_BONUS).toFixed(2);
        // Cap at 120% of max weight (bonus can push above catalogue max)
        result.bonusApplied = true;
      }

      result.weight = weight;

      // Creel
      var entry = { fish: fish, weight: weight, zone: session.zone, caughtAt: Date.now() };
      _getOrInitCreel(playerId).push(entry);

      // Stats
      var stats = _getOrInitStats(playerId);
      stats.totalCatches++;
      stats.catchesByRarity[fish.rarity] = (stats.catchesByRarity[fish.rarity] || 0) + 1;

      if (!stats.biggestCatch || weight > stats.biggestCatch.weight) {
        stats.biggestCatch = entry;
      }
      if (!stats.rarestCatch || _rarityRank(fish.rarity) > _rarityRank(stats.rarestCatch.fish.rarity)) {
        stats.rarestCatch = entry;
      }

      // Deplete population slightly
      var pop = _getOrInitPopulation(session.zone);
      if (pop[fish.id] !== undefined) {
        pop[fish.id] = Math.max(0, pop[fish.id] - 0.05);
      }
    }

    session.state = 'idle';
    session._pendingFish = null;
    session.lastResult = result;
    return result;
  }

  /**
   * Get the most recent catch result for a player.
   */
  function getCatch(playerId) {
    var session = _sessions[playerId];
    return session ? session.lastResult : null;
  }

  // â”€â”€â”€ CREEL MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Manually add a fish to the creel (useful for event-driven flows).
   */
  function addToCreel(playerId, fishId, weight) {
    var fish = _getFishById(fishId);
    if (!fish) { return null; }
    var w = (weight !== undefined && weight > 0) ? +weight : _randomWeight(fish, _rollSeed(fishId.length));
    var entry = { fish: fish, weight: w, zone: 'nexus', caughtAt: Date.now() };
    _getOrInitCreel(playerId).push(entry);
    return entry;
  }

  /**
   * Return the player's creel contents.
   */
  function getCreel(playerId) {
    return _getOrInitCreel(playerId);
  }

  /**
   * Sell all fish in the creel. Returns total coins earned.
   */
  function sellCatch(playerId) {
    var creel = _getOrInitCreel(playerId);
    if (creel.length === 0) { return 0; }

    var total = 0;
    for (var i = 0; i < creel.length; i++) {
      var entry = creel[i];
      // Value = base value * weight factor (heavier = more valuable)
      var weightFactor = entry.weight / entry.fish.weightMax;
      total += Math.round(entry.fish.value * (0.5 + weightFactor * 0.5));
    }

    var stats = _getOrInitStats(playerId);
    stats.totalSold += creel.length;
    stats.totalEarned += total;

    _creels[playerId] = [];
    return total;
  }

  /**
   * Clear a player's creel (release fish back).
   */
  function clearCreel(playerId) {
    _creels[playerId] = [];
  }

  // â”€â”€â”€ LIFETIME STATS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function getLifetimeStats(playerId) {
    return _getOrInitStats(playerId);
  }

  // â”€â”€â”€ ECOLOGY / POPULATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get current population factor for a fish in a zone (0..2, 1.0 = normal).
   */
  function getFishPopulation(zoneId, fishId) {
    var pop = _getOrInitPopulation(zoneId);
    if (pop[fishId] === undefined) { return null; }
    return pop[fishId];
  }

  /**
   * Update (recover/deplete) all fish populations across all zones.
   * Should be called periodically (e.g., game tick).
   * recoveryRate: fraction recovered per tick (default 0.01)
   * depletionFloor: minimum population factor (default 0.1)
   */
  function updatePopulations(recoveryRate, depletionFloor) {
    var rate  = (recoveryRate  !== undefined) ? recoveryRate  : 0.01;
    var floor = (depletionFloor !== undefined) ? depletionFloor : 0.10;

    for (var zoneId in _populations) {
      if (!_populations.hasOwnProperty(zoneId)) { continue; }
      var pop = _populations[zoneId];
      for (var fishId in pop) {
        if (!pop.hasOwnProperty(fishId)) { continue; }
        pop[fishId] = Math.min(2.0, Math.max(floor, pop[fishId] + rate));
      }
    }
  }

  /**
   * Set population factor directly (for testing / admin).
   */
  function setFishPopulation(zoneId, fishId, factor) {
    var pop = _getOrInitPopulation(zoneId);
    pop[fishId] = Math.min(2.0, Math.max(0, factor));
  }

  // â”€â”€â”€ SEASONAL HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns all fish that can be caught in a given season.
   */
  function getSeasonalFish(season) {
    var results = [];
    for (var i = 0; i < FISH_CATALOG.length; i++) {
      var fish = FISH_CATALOG[i];
      if (!fish.season || fish.season.length === 0 || fish.season.indexOf(season) !== -1) {
        results.push(fish);
      }
    }
    return results;
  }

  /**
   * Returns all fish available in a given zone (any season).
   */
  function getFishByZone(zoneId) {
    var zone = FISHING_ZONES[zoneId];
    if (!zone) { return []; }
    var results = [];
    for (var i = 0; i < zone.fish.length; i++) {
      var fish = _getFishById(zone.fish[i]);
      if (fish) { results.push(fish); }
    }
    return results;
  }

  // â”€â”€â”€ TOURNAMENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var _tournamentCounter = 0;

  /**
   * Create a new tournament.
   * opts: { name, zoneId, metric ('heaviest'|'rarest'|'most'), durationMs, season }
   */
  function startTournament(opts) {
    opts = opts || {};
    var id = 'tournament_' + (++_tournamentCounter);
    var tournament = {
      id: id,
      name: opts.name || 'ZION Fishing Tournament',
      zoneId: opts.zoneId || null,
      metric: opts.metric || 'heaviest',  // heaviest | rarest | most
      season: opts.season || null,
      startedAt: Date.now(),
      durationMs: opts.durationMs || 3600000,  // 1 hour default
      state: 'active',   // active | ended
      entries: {},        // { playerId -> [entry...] }
      rankings: null
    };
    _tournaments[id] = tournament;
    return tournament;
  }

  /**
   * Join a tournament (register a player).
   * Returns the tournament or null if not found / not active.
   */
  function joinTournament(tournamentId, playerId) {
    var t = _tournaments[tournamentId];
    if (!t || t.state !== 'active') { return null; }
    if (!t.entries[playerId]) {
      t.entries[playerId] = [];
    }
    var stats = _getOrInitStats(playerId);
    stats.tournamentsEntered++;
    return t;
  }

  /**
   * Submit a catch entry to a tournament.
   * entry: { fish, weight } â€” typically from reelIn result.
   */
  function submitEntry(tournamentId, playerId, entry) {
    var t = _tournaments[tournamentId];
    if (!t || t.state !== 'active') { return null; }
    if (!t.entries[playerId]) { t.entries[playerId] = []; }
    if (!entry || !entry.fish) { return null; }

    var record = {
      playerId: playerId,
      fish: entry.fish,
      weight: entry.weight || 0,
      submittedAt: Date.now()
    };
    t.entries[playerId].push(record);
    t.rankings = null; // invalidate cached rankings
    return record;
  }

  /**
   * Get current tournament rankings.
   * Returns array sorted by score descending.
   */
  function getTournamentRankings(tournamentId) {
    var t = _tournaments[tournamentId];
    if (!t) { return null; }

    if (t.rankings && t.state === 'ended') { return t.rankings; }

    var scores = [];
    for (var playerId in t.entries) {
      if (!t.entries.hasOwnProperty(playerId)) { continue; }
      var playerEntries = t.entries[playerId];
      var score = 0;

      if (t.metric === 'heaviest') {
        // Best single fish weight
        for (var i = 0; i < playerEntries.length; i++) {
          if (playerEntries[i].weight > score) { score = playerEntries[i].weight; }
        }
      } else if (t.metric === 'rarest') {
        // Highest rarity rank achieved
        for (var j = 0; j < playerEntries.length; j++) {
          var rank = _rarityRank(playerEntries[j].fish.rarity);
          if (rank > score) { score = rank; }
        }
      } else if (t.metric === 'most') {
        // Total number of catches
        score = playerEntries.length;
      }

      scores.push({ playerId: playerId, score: score, entries: playerEntries.length });
    }

    scores.sort(function(a, b) { return b.score - a.score; });

    // Add rank field
    for (var k = 0; k < scores.length; k++) {
      scores[k].rank = k + 1;
    }

    t.rankings = scores;
    return scores;
  }

  /**
   * End a tournament, finalize rankings, award winner.
   * Returns final standings.
   */
  function endTournament(tournamentId) {
    var t = _tournaments[tournamentId];
    if (!t) { return null; }

    t.state = 'ended';
    var rankings = getTournamentRankings(tournamentId);

    if (rankings && rankings.length > 0) {
      var winner = rankings[0].playerId;
      var stats = _getOrInitStats(winner);
      stats.tournamentsWon++;
      t.winner = winner;
    }

    return { tournament: t, rankings: rankings };
  }

  /**
   * Get a tournament by id.
   */
  function getTournament(tournamentId) {
    return _tournaments[tournamentId] || null;
  }

  // â”€â”€â”€ RESET (for testing) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _reset() {
    _sessions = {};
    _creels = {};
    _stats = {};
    _populations = {};
    _tournaments = {};
    _tournamentCounter = 0;
  }

  // â”€â”€â”€ EXPORTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.FISH_CATALOG         = FISH_CATALOG;
  exports.BAIT_TYPES           = BAIT_TYPES;
  exports.ROD_TYPES            = ROD_TYPES;
  exports.FISHING_ZONES        = FISHING_ZONES;
  exports.CATCH_RATES          = CATCH_RATES;
  exports.PERFECT_TIMING_BONUS = PERFECT_TIMING_BONUS;

  exports.startFishing         = startFishing;
  exports.castLine             = castLine;
  exports.getBite              = getBite;
  exports.reelIn               = reelIn;
  exports.getCatch             = getCatch;

  exports.addToCreel           = addToCreel;
  exports.getCreel             = getCreel;
  exports.sellCatch            = sellCatch;
  exports.clearCreel           = clearCreel;

  exports.getLifetimeStats     = getLifetimeStats;

  exports.getFishPopulation    = getFishPopulation;
  exports.updatePopulations    = updatePopulations;
  exports.setFishPopulation    = setFishPopulation;

  exports.getSeasonalFish      = getSeasonalFish;
  exports.getFishByZone        = getFishByZone;

  exports.startTournament      = startTournament;
  exports.joinTournament       = joinTournament;
  exports.submitEntry          = submitEntry;
  exports.getTournamentRankings = getTournamentRankings;
  exports.endTournament        = endTournament;
  exports.getTournament        = getTournament;

  exports._reset               = _reset;

})(typeof module !== 'undefined' ? module.exports : (window.Fishing = {}));


// weather_fx.js
// weather_fx.js
(function(exports) {
  // Weather Effects System â€” particle configs, lighting, wind, lightning, transitions

  // â”€â”€ Weather Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var WEATHER_TYPES = {
    CLEAR:        'clear',
    RAIN:         'rain',
    HEAVY_RAIN:   'heavy_rain',
    SNOW:         'snow',
    BLIZZARD:     'blizzard',
    FOG:          'fog',
    THUNDERSTORM: 'thunderstorm',
    SANDSTORM:    'sandstorm',
    MIST:         'mist'
  };

  // â”€â”€ Particle Configs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Each entry: count, speed (units/s), size, color (hex), opacity, direction
  // (normalized {x,y,z}), spread (cone half-angle degrees), turbulence

  var PARTICLE_CONFIGS = {
    clear: {
      count: 0,
      speed: 0,
      size: 0,
      color: '#ffffff',
      opacity: 0,
      direction: { x: 0, y: -1, z: 0 },
      spread: 0,
      turbulence: 0,
      type: 'none'
    },
    rain: {
      count: 800,
      speed: 18,
      size: 0.08,
      color: '#a0c8e8',
      opacity: 0.55,
      direction: { x: 0.05, y: -1, z: 0 },
      spread: 5,
      turbulence: 0.15,
      type: 'streak'
    },
    heavy_rain: {
      count: 2200,
      speed: 28,
      size: 0.1,
      color: '#7aadd4',
      opacity: 0.7,
      direction: { x: 0.12, y: -1, z: 0.04 },
      spread: 8,
      turbulence: 0.35,
      type: 'streak'
    },
    snow: {
      count: 600,
      speed: 3,
      size: 0.18,
      color: '#eef4fb',
      opacity: 0.85,
      direction: { x: 0.02, y: -1, z: 0 },
      spread: 20,
      turbulence: 0.5,
      type: 'flake'
    },
    blizzard: {
      count: 1800,
      speed: 14,
      size: 0.14,
      color: '#d8ecfa',
      opacity: 0.75,
      direction: { x: 0.6, y: -0.8, z: 0.1 },
      spread: 35,
      turbulence: 1.2,
      type: 'flake'
    },
    fog: {
      count: 120,
      speed: 0.5,
      size: 18,
      color: '#c8d4dc',
      opacity: 0.28,
      direction: { x: 0.1, y: 0, z: 0 },
      spread: 90,
      turbulence: 0.05,
      type: 'volume'
    },
    thunderstorm: {
      count: 2500,
      speed: 32,
      size: 0.1,
      color: '#6090b8',
      opacity: 0.72,
      direction: { x: 0.18, y: -1, z: 0.06 },
      spread: 10,
      turbulence: 0.55,
      type: 'streak'
    },
    sandstorm: {
      count: 3000,
      speed: 22,
      size: 0.12,
      color: '#c8a050',
      opacity: 0.6,
      direction: { x: 1, y: -0.1, z: 0.2 },
      spread: 25,
      turbulence: 0.9,
      type: 'dust'
    },
    mist: {
      count: 200,
      speed: 0.8,
      size: 12,
      color: '#dce8ec',
      opacity: 0.22,
      direction: { x: 0.05, y: 0, z: 0 },
      spread: 80,
      turbulence: 0.03,
      type: 'volume'
    }
  };

  // â”€â”€ Lighting Configs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ambientColor, directionalIntensity, fogColor, fogDensity, skyColor

  var LIGHTING_CONFIGS = {
    clear: {
      ambientColor: '#c8d8f0',
      ambientIntensity: 0.7,
      directionalIntensity: 1.0,
      fogColor: '#c0d0e8',
      fogDensity: 0.0008,
      skyColor: '#87ceeb',
      shadowStrength: 0.8
    },
    rain: {
      ambientColor: '#8898a8',
      ambientIntensity: 0.5,
      directionalIntensity: 0.45,
      fogColor: '#7888a0',
      fogDensity: 0.003,
      skyColor: '#5a6878',
      shadowStrength: 0.3
    },
    heavy_rain: {
      ambientColor: '#5a6872',
      ambientIntensity: 0.38,
      directionalIntensity: 0.25,
      fogColor: '#4a5860',
      fogDensity: 0.007,
      skyColor: '#3a4858',
      shadowStrength: 0.15
    },
    snow: {
      ambientColor: '#b8c8e0',
      ambientIntensity: 0.65,
      directionalIntensity: 0.55,
      fogColor: '#c8d8e8',
      fogDensity: 0.002,
      skyColor: '#9aacc0',
      shadowStrength: 0.4
    },
    blizzard: {
      ambientColor: '#8898b0',
      ambientIntensity: 0.45,
      directionalIntensity: 0.2,
      fogColor: '#98a8c0',
      fogDensity: 0.018,
      skyColor: '#707888',
      shadowStrength: 0.05
    },
    fog: {
      ambientColor: '#a0aab0',
      ambientIntensity: 0.55,
      directionalIntensity: 0.3,
      fogColor: '#b0bac0',
      fogDensity: 0.025,
      skyColor: '#909aa0',
      shadowStrength: 0.1
    },
    thunderstorm: {
      ambientColor: '#3a4858',
      ambientIntensity: 0.3,
      directionalIntensity: 0.15,
      fogColor: '#2a3848',
      fogDensity: 0.009,
      skyColor: '#1e2838',
      shadowStrength: 0.05
    },
    sandstorm: {
      ambientColor: '#c8a048',
      ambientIntensity: 0.5,
      directionalIntensity: 0.35,
      fogColor: '#b89038',
      fogDensity: 0.022,
      skyColor: '#d0a840',
      shadowStrength: 0.15
    },
    mist: {
      ambientColor: '#a8b8c0',
      ambientIntensity: 0.6,
      directionalIntensity: 0.5,
      fogColor: '#b8c8d0',
      fogDensity: 0.012,
      skyColor: '#98a8b0',
      shadowStrength: 0.25
    }
  };

  // Time-of-day multipliers applied to base lighting
  var TIME_OF_DAY_MODIFIERS = {
    dawn: {
      ambientMultiplier: 0.6,
      directionalMultiplier: 0.4,
      tint: '#ff9060',
      tintStrength: 0.3
    },
    morning: {
      ambientMultiplier: 0.85,
      directionalMultiplier: 0.8,
      tint: '#ffe8c0',
      tintStrength: 0.1
    },
    noon: {
      ambientMultiplier: 1.0,
      directionalMultiplier: 1.0,
      tint: '#ffffff',
      tintStrength: 0
    },
    afternoon: {
      ambientMultiplier: 0.95,
      directionalMultiplier: 0.9,
      tint: '#ffe0a0',
      tintStrength: 0.12
    },
    dusk: {
      ambientMultiplier: 0.55,
      directionalMultiplier: 0.35,
      tint: '#ff7030',
      tintStrength: 0.35
    },
    night: {
      ambientMultiplier: 0.15,
      directionalMultiplier: 0.05,
      tint: '#203060',
      tintStrength: 0.5
    }
  };

  // â”€â”€ Sound Hints â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var SOUND_HINTS = {
    clear:        'ambient_wind_light',
    rain:         'rain_gentle',
    heavy_rain:   'rain_heavy',
    snow:         'wind_soft',
    blizzard:     'blizzard_howl',
    fog:          'ambient_muted',
    thunderstorm: 'storm_thunder',
    sandstorm:    'sandstorm_grit',
    mist:         'ambient_muted'
  };

  // â”€â”€ Visibility Ranges (units) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var VISIBILITY_RANGES = {
    clear:        600,
    rain:         350,
    heavy_rain:   180,
    snow:         280,
    blizzard:     60,
    fog:          70,
    thunderstorm: 150,
    sandstorm:    50,
    mist:         120
  };

  // â”€â”€ Ambient Modifiers (gameplay effects) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var AMBIENT_MODIFIERS = {
    clear: {
      moveSpeed:        1.0,
      visibilityFactor: 1.0,
      catchRate:        1.0,
      gatherRate:       1.0,
      xpMultiplier:     1.0,
      staminaDrain:     1.0,
      description:      'Clear skies, ideal conditions'
    },
    rain: {
      moveSpeed:        0.9,
      visibilityFactor: 0.7,
      catchRate:        1.3,
      gatherRate:       1.1,
      xpMultiplier:     1.0,
      staminaDrain:     1.1,
      description:      'Rain boosts fishing and foraging'
    },
    heavy_rain: {
      moveSpeed:        0.75,
      visibilityFactor: 0.45,
      catchRate:        1.5,
      gatherRate:       1.2,
      xpMultiplier:     1.05,
      staminaDrain:     1.3,
      description:      'Heavy rain â€” slippery ground, excellent fishing'
    },
    snow: {
      moveSpeed:        0.85,
      visibilityFactor: 0.6,
      catchRate:        0.8,
      gatherRate:       0.75,
      xpMultiplier:     1.0,
      staminaDrain:     1.2,
      description:      'Snow slows movement and gathering'
    },
    blizzard: {
      moveSpeed:        0.5,
      visibilityFactor: 0.15,
      catchRate:        0.5,
      gatherRate:       0.4,
      xpMultiplier:     1.2,
      staminaDrain:     2.0,
      description:      'Blizzard â€” treacherous, but brave souls earn bonus XP'
    },
    fog: {
      moveSpeed:        0.95,
      visibilityFactor: 0.2,
      catchRate:        0.9,
      gatherRate:       1.0,
      xpMultiplier:     1.1,
      staminaDrain:     1.0,
      description:      'Fog hides secrets and grants exploration bonuses'
    },
    thunderstorm: {
      moveSpeed:        0.7,
      visibilityFactor: 0.35,
      catchRate:        1.4,
      gatherRate:       1.15,
      xpMultiplier:     1.3,
      staminaDrain:     1.5,
      description:      'Dangerous storm â€” high risk, high reward'
    },
    sandstorm: {
      moveSpeed:        0.6,
      visibilityFactor: 0.12,
      catchRate:        0.6,
      gatherRate:       0.5,
      xpMultiplier:     1.15,
      staminaDrain:     1.8,
      description:      'Sandstorm â€” near-zero visibility, harsh conditions'
    },
    mist: {
      moveSpeed:        1.0,
      visibilityFactor: 0.3,
      catchRate:        1.1,
      gatherRate:       1.05,
      xpMultiplier:     1.05,
      staminaDrain:     1.0,
      description:      'Gentle mist, slightly enhanced mystical properties'
    }
  };

  // â”€â”€ Seasonal Weather Weights â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Probabilities must sum to 1.0 per season

  var SEASONAL_WEATHER_WEIGHTS = {
    spring: {
      clear:        0.28,
      rain:         0.25,
      heavy_rain:   0.10,
      snow:         0.04,
      blizzard:     0.01,
      fog:          0.08,
      thunderstorm: 0.12,
      sandstorm:    0.02,
      mist:         0.10
    },
    summer: {
      clear:        0.45,
      rain:         0.15,
      heavy_rain:   0.06,
      snow:         0.00,
      blizzard:     0.00,
      fog:          0.04,
      thunderstorm: 0.18,
      sandstorm:    0.07,
      mist:         0.05
    },
    autumn: {
      clear:        0.25,
      rain:         0.22,
      heavy_rain:   0.12,
      snow:         0.06,
      blizzard:     0.02,
      fog:          0.15,
      thunderstorm: 0.08,
      sandstorm:    0.03,
      mist:         0.07
    },
    winter: {
      clear:        0.20,
      rain:         0.10,
      heavy_rain:   0.05,
      snow:         0.30,
      blizzard:     0.15,
      fog:          0.10,
      thunderstorm: 0.03,
      sandstorm:    0.01,
      mist:         0.06
    }
  };

  // â”€â”€ Weather Transition Durations (seconds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var TRANSITION_DURATIONS = {
    // [from][to] â€” null falls back to default
    clear: {
      rain:         30,
      heavy_rain:   60,
      snow:         45,
      blizzard:     90,
      fog:          20,
      thunderstorm: 50,
      sandstorm:    25,
      mist:         15
    },
    rain: {
      clear:        25,
      heavy_rain:   15,
      fog:          20,
      thunderstorm: 20,
      snow:         40,
      blizzard:     70,
      sandstorm:    35,
      mist:         18
    },
    heavy_rain: {
      rain:         12,
      clear:        40,
      thunderstorm: 15,
      fog:          25,
      snow:         50,
      blizzard:     60,
      sandstorm:    30,
      mist:         25
    },
    snow: {
      clear:        35,
      rain:         30,
      blizzard:     20,
      fog:          15,
      heavy_rain:   40,
      thunderstorm: 55,
      sandstorm:    80,
      mist:         20
    },
    blizzard: {
      snow:         25,
      clear:        90,
      fog:          40,
      rain:         60,
      heavy_rain:   70,
      thunderstorm: 80,
      sandstorm:    100,
      mist:         50
    },
    fog: {
      clear:        20,
      mist:         10,
      rain:         15,
      heavy_rain:   25,
      snow:         30,
      blizzard:     50,
      thunderstorm: 35,
      sandstorm:    40
    },
    thunderstorm: {
      rain:         20,
      heavy_rain:   15,
      clear:        60,
      fog:          30,
      snow:         55,
      blizzard:     75,
      sandstorm:    45,
      mist:         35
    },
    sandstorm: {
      clear:        30,
      fog:          20,
      rain:         40,
      heavy_rain:   50,
      snow:         70,
      blizzard:     90,
      thunderstorm: 35,
      mist:         25
    },
    mist: {
      clear:        12,
      fog:          8,
      rain:         15,
      heavy_rain:   25,
      snow:         30,
      blizzard:     55,
      thunderstorm: 30,
      sandstorm:    35
    }
  };

  // â”€â”€ Lightning Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var LIGHTNING_CHANCE = {
    clear:        0,
    rain:         0.001,
    heavy_rain:   0.004,
    snow:         0,
    blizzard:     0.0005,
    fog:          0,
    thunderstorm: 0.025,
    sandstorm:    0.003,
    mist:         0
  };

  // â”€â”€ Internal Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function seededRand(seed) {
    // Simple deterministic LCG pseudo-random (0..1)
    var x = Math.sin(seed + 1) * 43758.5453123;
    return x - Math.floor(x);
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function lerpColor(hexA, hexB, t) {
    var rA = parseInt(hexA.slice(1, 3), 16);
    var gA = parseInt(hexA.slice(3, 5), 16);
    var bA = parseInt(hexA.slice(5, 7), 16);
    var rB = parseInt(hexB.slice(1, 3), 16);
    var gB = parseInt(hexB.slice(3, 5), 16);
    var bB = parseInt(hexB.slice(5, 7), 16);
    var r = Math.round(lerp(rA, rB, t));
    var g = Math.round(lerp(gA, gB, t));
    var b = Math.round(lerp(bA, bB, t));
    return '#' + ('0' + r.toString(16)).slice(-2) +
                 ('0' + g.toString(16)).slice(-2) +
                 ('0' + b.toString(16)).slice(-2);
  }

  function clamp(v, lo, hi) {
    return v < lo ? lo : v > hi ? hi : v;
  }

  function getTimeLabel(timeOfDay) {
    // timeOfDay: 0..1 (0 = midnight, 0.25 = 6am, 0.5 = noon, 0.75 = 6pm)
    if (timeOfDay === undefined || timeOfDay === null) return 'noon';
    if (timeOfDay < 0.083) return 'night';     // 0 - 2h
    if (timeOfDay < 0.208) return 'dawn';      // 2h - 5h
    if (timeOfDay < 0.375) return 'morning';   // 5h - 9h
    if (timeOfDay < 0.625) return 'noon';      // 9h - 15h
    if (timeOfDay < 0.792) return 'afternoon'; // 15h - 19h
    if (timeOfDay < 0.875) return 'dusk';      // 19h - 21h
    return 'night';                             // 21h - 24h
  }

  function validateWeatherType(type) {
    if (!PARTICLE_CONFIGS[type]) {
      throw new Error('Unknown weather type: ' + type);
    }
  }

  // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * getWeatherConfig(type)
   * Returns the full configuration object for a weather type.
   * Includes particle, lighting, sound, visibility, modifiers, lightning.
   */
  function getWeatherConfig(type) {
    validateWeatherType(type);
    return {
      type:        type,
      particle:    getParticleConfig(type),
      lighting:    getLightingConfig(type, 0.5),
      sound:       SOUND_HINTS[type],
      visibility:  getVisibilityRange(type),
      modifiers:   getAmbientModifiers(type),
      lightning:   getLightningChance(type)
    };
  }

  /**
   * getParticleConfig(type)
   * Returns particle system parameters for the given weather type.
   */
  function getParticleConfig(type) {
    validateWeatherType(type);
    var cfg = PARTICLE_CONFIGS[type];
    // Return a shallow copy to prevent mutation
    return {
      count:       cfg.count,
      speed:       cfg.speed,
      size:        cfg.size,
      color:       cfg.color,
      opacity:     cfg.opacity,
      direction:   { x: cfg.direction.x, y: cfg.direction.y, z: cfg.direction.z },
      spread:      cfg.spread,
      turbulence:  cfg.turbulence,
      type:        cfg.type
    };
  }

  /**
   * getLightingConfig(type, timeOfDay)
   * Returns lighting parameters for weather + time of day.
   * timeOfDay: 0..1 (0 = midnight, 0.5 = noon)
   */
  function getLightingConfig(type, timeOfDay) {
    validateWeatherType(type);
    var base   = LIGHTING_CONFIGS[type];
    var tod    = getTimeLabel(timeOfDay);
    var mods   = TIME_OF_DAY_MODIFIERS[tod] || TIME_OF_DAY_MODIFIERS.noon;

    return {
      ambientColor:         base.ambientColor,
      ambientIntensity:     base.ambientIntensity  * mods.ambientMultiplier,
      directionalIntensity: base.directionalIntensity * mods.directionalMultiplier,
      fogColor:             base.fogColor,
      fogDensity:           base.fogDensity,
      skyColor:             base.skyColor,
      shadowStrength:       base.shadowStrength,
      timeOfDay:            tod,
      tint:                 mods.tint,
      tintStrength:         mods.tintStrength
    };
  }

  /**
   * interpolateWeather(from, to, progress)
   * Linearly interpolates between two weather states.
   * progress: 0..1
   * Returns blended particle and lighting configs.
   */
  function interpolateWeather(from, to, progress) {
    validateWeatherType(from);
    validateWeatherType(to);
    var t = clamp(progress, 0, 1);

    var pA = PARTICLE_CONFIGS[from];
    var pB = PARTICLE_CONFIGS[to];
    var lA = LIGHTING_CONFIGS[from];
    var lB = LIGHTING_CONFIGS[to];

    return {
      type:     t < 0.5 ? from : to,
      progress: t,
      particle: {
        count:      Math.round(lerp(pA.count,     pB.count,     t)),
        speed:      lerp(pA.speed,     pB.speed,     t),
        size:       lerp(pA.size,      pB.size,      t),
        color:      lerpColor(pA.color, pB.color, t),
        opacity:    lerp(pA.opacity,   pB.opacity,   t),
        direction:  {
          x: lerp(pA.direction.x, pB.direction.x, t),
          y: lerp(pA.direction.y, pB.direction.y, t),
          z: lerp(pA.direction.z, pB.direction.z, t)
        },
        spread:     lerp(pA.spread,    pB.spread,    t),
        turbulence: lerp(pA.turbulence, pB.turbulence, t),
        type:       t < 0.5 ? pA.type : pB.type
      },
      lighting: {
        ambientColor:         lerpColor(lA.ambientColor, lB.ambientColor, t),
        ambientIntensity:     lerp(lA.ambientIntensity,     lB.ambientIntensity,     t),
        directionalIntensity: lerp(lA.directionalIntensity, lB.directionalIntensity, t),
        fogColor:             lerpColor(lA.fogColor, lB.fogColor, t),
        fogDensity:           lerp(lA.fogDensity,  lB.fogDensity,  t),
        skyColor:             lerpColor(lA.skyColor, lB.skyColor, t),
        shadowStrength:       lerp(lA.shadowStrength, lB.shadowStrength, t)
      }
    };
  }

  /**
   * getWindVector(weather, time)
   * Returns wind direction and strength that evolve over time.
   * time: game time in seconds (monotonic)
   * Returns {x, y, z, strength}
   */
  function getWindVector(weather, time) {
    validateWeatherType(weather);
    var t = time || 0;

    // Base wind strengths per weather
    var baseStrengths = {
      clear:        2,
      rain:         8,
      heavy_rain:   16,
      snow:         4,
      blizzard:     30,
      fog:          1,
      thunderstorm: 22,
      sandstorm:    35,
      mist:         1.5
    };

    var base = baseStrengths[weather];

    // Slow sinusoidal drift in direction
    var angle   = (t * 0.0003) + seededRand(Math.floor(t / 120)) * Math.PI * 2;
    var gust    = 1 + 0.3 * Math.sin(t * 0.07) + 0.15 * Math.sin(t * 0.23);
    var strength = base * gust;

    return {
      x:        Math.cos(angle) * strength,
      y:        0,
      z:        Math.sin(angle) * strength,
      strength: strength
    };
  }

  /**
   * applyWindToPosition(pos, wind, mass)
   * Computes displacement from wind based on object mass.
   * pos: {x, y, z}
   * wind: result of getWindVector
   * mass: kg (heavier = less displaced)
   * Returns new position {x, y, z}
   */
  function applyWindToPosition(pos, wind, mass) {
    var m = mass > 0 ? mass : 1;
    var factor = 1 / m;
    return {
      x: pos.x + wind.x * factor,
      y: pos.y + wind.y * factor,
      z: pos.z + wind.z * factor
    };
  }

  /**
   * getVisibilityRange(weather)
   * Returns how far the player can see (in world units).
   */
  function getVisibilityRange(weather) {
    validateWeatherType(weather);
    return VISIBILITY_RANGES[weather];
  }

  /**
   * getPuddleLevel(weather, duration)
   * Returns ground water accumulation level (0..1).
   * duration: seconds the weather has been active.
   */
  function getPuddleLevel(weather, duration) {
    validateWeatherType(weather);
    var dur = duration || 0;

    // Accumulation rates (fraction per second)
    var rates = {
      clear:        -0.0005,  // evaporation
      rain:          0.002,
      heavy_rain:    0.006,
      snow:          0.0005,  // melts slowly into puddles
      blizzard:     -0.001,   // freezes, reduces puddles
      fog:           0.0002,
      thunderstorm:  0.008,
      sandstorm:    -0.003,   // sand absorbs water
      mist:          0.0004
    };

    var rate  = rates[weather];
    var level = rate * dur;
    // clamp returns 0 for negative rates at duration=0, but -0*0 = -0 in JS
    // Add 0 to normalize -0 to +0
    return clamp(level, 0, 1) + 0;
  }

  /**
   * getLightningChance(weather)
   * Returns probability (0..1) of a lightning flash per game tick.
   */
  function getLightningChance(weather) {
    validateWeatherType(weather);
    return LIGHTNING_CHANCE[weather];
  }

  /**
   * generateLightningBolt(seed)
   * Returns a deterministic random bolt path as an array of {x, y, z} points.
   * The bolt travels from sky to ground (y from ~120 to 0).
   */
  function generateLightningBolt(seed) {
    var s        = seed || 0;
    var segments = 5 + Math.floor(seededRand(s) * 4);   // 5..8 segments
    var points   = [];
    var startX   = (seededRand(s + 1) - 0.5) * 200;
    var startZ   = (seededRand(s + 2) - 0.5) * 200;
    var topY     = 110 + seededRand(s + 3) * 20;

    points.push({ x: startX, y: topY, z: startZ });

    for (var i = 1; i <= segments; i++) {
      var t       = i / segments;
      var decay   = 1 - t;
      var jitterX = (seededRand(s + i * 7 + 10) - 0.5) * 30 * decay;
      var jitterZ = (seededRand(s + i * 7 + 11) - 0.5) * 30 * decay;
      var y       = topY * (1 - t);                      // descend to 0
      points.push({
        x: startX + jitterX,
        y: y,
        z: startZ + jitterZ
      });
    }

    // Branch: 30% chance of a sub-bolt
    var branches = [];
    if (seededRand(s + 99) < 0.3 && points.length > 2) {
      var branchFrom = points[Math.floor(points.length / 2)];
      var bLen       = 2 + Math.floor(seededRand(s + 200) * 3);
      var branch     = [{ x: branchFrom.x, y: branchFrom.y, z: branchFrom.z }];
      for (var j = 1; j <= bLen; j++) {
        var bt = j / bLen;
        branch.push({
          x: branchFrom.x + (seededRand(s + 300 + j) - 0.5) * 20 * (1 - bt),
          y: branchFrom.y * (1 - bt * 0.8),
          z: branchFrom.z + (seededRand(s + 400 + j) - 0.5) * 20 * (1 - bt)
        });
      }
      branches.push(branch);
    }

    return {
      points:   points,
      segments: segments,
      branches: branches,
      seed:     seed
    };
  }

  /**
   * getWeatherTransitionDuration(from, to)
   * Returns how many seconds the transition between two weather types should take.
   */
  function getWeatherTransitionDuration(from, to) {
    validateWeatherType(from);
    validateWeatherType(to);
    if (from === to) return 0;
    var row = TRANSITION_DURATIONS[from];
    if (row && row[to] !== undefined) return row[to];
    return 40; // default fallback
  }

  /**
   * getSeasonalWeatherWeights(season)
   * Returns probability distribution object for a given season.
   * Seasons: 'spring', 'summer', 'autumn', 'winter'
   */
  function getSeasonalWeatherWeights(season) {
    var weights = SEASONAL_WEATHER_WEIGHTS[season];
    if (!weights) {
      throw new Error('Unknown season: ' + season);
    }
    // Return copy
    var copy = {};
    var types = Object.keys(weights);
    for (var i = 0; i < types.length; i++) {
      copy[types[i]] = weights[types[i]];
    }
    return copy;
  }

  /**
   * rollWeather(seed, season)
   * Deterministically selects a weather type from seasonal weights using a seed.
   */
  function rollWeather(seed, season) {
    var weights = SEASONAL_WEATHER_WEIGHTS[season];
    if (!weights) {
      throw new Error('Unknown season: ' + season);
    }
    var r      = seededRand(seed);
    var types  = Object.keys(weights);
    var cumul  = 0;
    for (var i = 0; i < types.length; i++) {
      cumul += weights[types[i]];
      if (r < cumul) return types[i];
    }
    return types[types.length - 1]; // fallback (floating point)
  }

  /**
   * getAmbientModifiers(weather)
   * Returns gameplay modifiers for the given weather type.
   */
  function getAmbientModifiers(weather) {
    validateWeatherType(weather);
    var m = AMBIENT_MODIFIERS[weather];
    return {
      moveSpeed:        m.moveSpeed,
      visibilityFactor: m.visibilityFactor,
      catchRate:        m.catchRate,
      gatherRate:       m.gatherRate,
      xpMultiplier:     m.xpMultiplier,
      staminaDrain:     m.staminaDrain,
      description:      m.description
    };
  }

  // â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.WEATHER_TYPES              = WEATHER_TYPES;
  exports.PARTICLE_CONFIGS           = PARTICLE_CONFIGS;
  exports.LIGHTING_CONFIGS           = LIGHTING_CONFIGS;
  exports.SOUND_HINTS                = SOUND_HINTS;
  exports.VISIBILITY_RANGES          = VISIBILITY_RANGES;
  exports.AMBIENT_MODIFIERS          = AMBIENT_MODIFIERS;
  exports.SEASONAL_WEATHER_WEIGHTS   = SEASONAL_WEATHER_WEIGHTS;
  exports.TRANSITION_DURATIONS       = TRANSITION_DURATIONS;
  exports.LIGHTNING_CHANCE           = LIGHTNING_CHANCE;
  exports.TIME_OF_DAY_MODIFIERS      = TIME_OF_DAY_MODIFIERS;

  exports.getWeatherConfig           = getWeatherConfig;
  exports.getParticleConfig          = getParticleConfig;
  exports.getLightingConfig          = getLightingConfig;
  exports.interpolateWeather         = interpolateWeather;
  exports.getWindVector              = getWindVector;
  exports.applyWindToPosition        = applyWindToPosition;
  exports.getVisibilityRange         = getVisibilityRange;
  exports.getPuddleLevel             = getPuddleLevel;
  exports.getLightningChance         = getLightningChance;
  exports.generateLightningBolt      = generateLightningBolt;
  exports.getWeatherTransitionDuration = getWeatherTransitionDuration;
  exports.getSeasonalWeatherWeights  = getSeasonalWeatherWeights;
  exports.rollWeather                = rollWeather;
  exports.getAmbientModifiers        = getAmbientModifiers;

})(typeof module !== 'undefined' ? module.exports : (window.WeatherFX = {}));


// npc_memory.js
// npc_memory.js
/**
 * npc_memory.js - NPC Relationship Memory System
 *
 * Tracks friendship levels, gift history, opinions, and interaction history
 * between players and NPCs. Modifies dialogue and provides gameplay bonuses
 * based on relationship tiers.
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // CONSTANTS
  // ============================================================================

  var DECAY_RATE = 0.5; // Friendship points lost per day of absence (after grace period)
  var DECAY_GRACE_DAYS = 3; // Days before decay begins
  var MAX_GIFT_MEMORY = 50;
  var INTERACTION_MEMORY_LIMIT = 100;
  var MAX_FRIENDSHIP = 100;
  var MIN_FRIENDSHIP = 0;

  // ============================================================================
  // RELATIONSHIP TIERS
  // ============================================================================

  var RELATIONSHIP_TIERS = {
    stranger:      { min: 0,   max: 9,   label: 'Stranger',      color: '#888888' },
    acquaintance:  { min: 10,  max: 29,  label: 'Acquaintance',  color: '#88aacc' },
    friend:        { min: 30,  max: 59,  label: 'Friend',        color: '#44bb66' },
    close_friend:  { min: 60,  max: 99,  label: 'Close Friend',  color: '#ffaa00' },
    best_friend:   { min: 100, max: 100, label: 'Best Friend',   color: '#ff6600' }
  };

  // ============================================================================
  // OPINION TYPES
  // ============================================================================

  var OPINION_TYPES = {
    likes:    'likes',
    dislikes: 'dislikes',
    neutral:  'neutral'
  };

  // ============================================================================
  // ARCHETYPE PREFERENCES
  // Items/topics each archetype likes, dislikes, or is neutral about
  // ============================================================================

  var ARCHETYPE_PREFERENCES = {
    gardener: {
      items: {
        likes:    ['seeds', 'flowers', 'herbs', 'watering_can', 'fertilizer', 'garden_tools', 'honey', 'fruit'],
        dislikes: ['axe', 'fire', 'poison', 'salt', 'mining_pick'],
        neutral:  ['rope', 'cloth', 'coin', 'gem']
      },
      topics: {
        likes:    ['gardens', 'nature', 'rain', 'spring', 'harvest'],
        dislikes: ['pollution', 'deforestation', 'drought'],
        neutral:  ['trade', 'combat', 'politics']
      }
    },
    builder: {
      items: {
        likes:    ['stone', 'wood', 'blueprint', 'hammer', 'chisel', 'rope', 'metal', 'brick'],
        dislikes: ['poison', 'fire', 'decay'],
        neutral:  ['flowers', 'cloth', 'food', 'gem']
      },
      topics: {
        likes:    ['construction', 'architecture', 'agora', 'commons', 'innovation'],
        dislikes: ['chaos', 'destruction', 'disorder'],
        neutral:  ['music', 'philosophy', 'love']
      }
    },
    storyteller: {
      items: {
        likes:    ['book', 'scroll', 'ink', 'quill', 'lantern', 'map', 'journal'],
        dislikes: ['noise_device', 'mining_pick', 'axe'],
        neutral:  ['food', 'flowers', 'coin', 'cloth']
      },
      topics: {
        likes:    ['athenaeum', 'history', 'legends', 'travel', 'adventure'],
        dislikes: ['censorship', 'silence', 'boredom'],
        neutral:  ['trade', 'construction', 'combat']
      }
    },
    merchant: {
      items: {
        likes:    ['coin', 'gem', 'rare_goods', 'exotic_spice', 'silk', 'jewelry', 'contract'],
        dislikes: ['broken_item', 'spoiled_food', 'counterfeit'],
        neutral:  ['flowers', 'tools', 'scrolls', 'rope']
      },
      topics: {
        likes:    ['agora', 'trade', 'profit', 'travel', 'negotiation'],
        dislikes: ['theft', 'taxes', 'protectionism'],
        neutral:  ['music', 'philosophy', 'nature']
      }
    },
    explorer: {
      items: {
        likes:    ['map', 'compass', 'rope', 'torch', 'rations', 'journal', 'artifact', 'specimen'],
        dislikes: ['cage', 'chains', 'heavy_armor'],
        neutral:  ['jewelry', 'coin', 'silk', 'seeds']
      },
      topics: {
        likes:    ['wilds', 'discovery', 'adventure', 'unknown_zones', 'cartography'],
        dislikes: ['borders', 'walls', 'stagnation'],
        neutral:  ['trade', 'politics', 'philosophy']
      }
    },
    teacher: {
      items: {
        likes:    ['book', 'scroll', 'quill', 'ink', 'chalk', 'globe', 'astrolabe'],
        dislikes: ['noise_device', 'distraction_toy', 'weapon'],
        neutral:  ['food', 'flowers', 'coin', 'cloth']
      },
      topics: {
        likes:    ['athenaeum', 'education', 'knowledge', 'research', 'wisdom'],
        dislikes: ['ignorance', 'propaganda', 'superstition'],
        neutral:  ['trade', 'combat', 'entertainment']
      }
    },
    musician: {
      items: {
        likes:    ['instrument', 'sheet_music', 'metronome', 'rosin', 'strings', 'flute', 'drum'],
        dislikes: ['earplugs', 'cacophony_device', 'noise_blocker'],
        neutral:  ['coin', 'cloth', 'food', 'tools']
      },
      topics: {
        likes:    ['studio', 'performance', 'composition', 'harmony', 'festival'],
        dislikes: ['silence', 'censorship', 'monotony'],
        neutral:  ['trade', 'construction', 'politics']
      }
    },
    healer: {
      items: {
        likes:    ['herbs', 'potion', 'bandage', 'salve', 'crystal', 'honey', 'flowers'],
        dislikes: ['poison', 'weapon', 'toxin'],
        neutral:  ['coin', 'gem', 'book', 'cloth']
      },
      topics: {
        likes:    ['gardens', 'wellness', 'compassion', 'medicine', 'peace'],
        dislikes: ['violence', 'disease', 'suffering'],
        neutral:  ['trade', 'architecture', 'performance']
      }
    },
    philosopher: {
      items: {
        likes:    ['book', 'scroll', 'incense', 'candle', 'hourglass', 'quill', 'astrolabe'],
        dislikes: ['noise_device', 'frivolous_toy', 'junk'],
        neutral:  ['coin', 'food', 'cloth', 'gem']
      },
      topics: {
        likes:    ['athenaeum', 'wisdom', 'debate', 'ethics', 'metaphysics', 'cosmology'],
        dislikes: ['shallow_entertainment', 'materialism', 'dogma'],
        neutral:  ['trade', 'construction', 'combat']
      }
    },
    artist: {
      items: {
        likes:    ['paint', 'canvas', 'brushes', 'charcoal', 'clay', 'gem', 'dye', 'flowers'],
        dislikes: ['plain_material', 'broken_art', 'noise_device'],
        neutral:  ['coin', 'tools', 'food', 'rope']
      },
      topics: {
        likes:    ['studio', 'beauty', 'inspiration', 'creativity', 'nature', 'gardens'],
        dislikes: ['ugliness', 'censorship', 'commercialism'],
        neutral:  ['trade', 'politics', 'combat']
      }
    }
  };

  // ============================================================================
  // GIFT REACTION THRESHOLDS
  // ============================================================================

  var GIFT_FRIENDSHIP_VALUES = {
    love:    20,  // Favorite item for archetype
    like:    10,  // Generally liked
    neutral:  3,  // Neither good nor bad
    dislike: -5   // Dislikes this item
  };

  // ============================================================================
  // UNLOCKED DIALOGUE BY TIER
  // ============================================================================

  var UNLOCKED_DIALOGUE = {
    stranger: {
      gardener:     ['Hello there, traveler.'],
      builder:      ['Welcome to ZION.'],
      storyteller:  ['Greetings, stranger.'],
      merchant:     ['Looking to trade?'],
      explorer:     ['Hey there.'],
      teacher:      ['Hello.'],
      musician:     ['Hi.'],
      healer:       ['Hello, be well.'],
      philosopher:  ['Welcome.'],
      artist:       ['Hello.']
    },
    acquaintance: {
      gardener:     ['Good to see you again! The herbs are doing well today.', 'Welcome back! The garden always looks better with visitors.'],
      builder:      ['Ah, returning! I\'ve been working on a new design.', 'Good to see you. Come check out the new stonework.'],
      storyteller:  ['Ah, you return! I have a new tale brewing.', 'Welcome back, I remember you from before.'],
      merchant:     ['Ah, a returning customer! I may have something for you.', 'Good to see you again. Shall we deal?'],
      explorer:     ['Back again! Did you explore anywhere new?', 'Glad you\'re here. I found new trails to share.'],
      teacher:      ['Welcome back! Ready to learn something new?', 'Ah, I remember you. You ask good questions.'],
      musician:     ['Good to see you again! I\'ve been composing.', 'You\'re back! I\'ll play something for you.'],
      healer:       ['Welcome back, friend. How is your health?', 'Ah, I remember your face. Be well!'],
      philosopher:  ['You return! I\'ve been pondering since we last spoke.', 'Ah, you again. Have you thought more on our last discussion?'],
      artist:       ['Welcome back! I finished a piece since we last met.', 'Ah, you came back! Want to see what I\'ve created?']
    },
    friend: {
      gardener:     ['My friend! I saved some moonflower seeds for you.', 'There you are! I was hoping you\'d visit today.', 'Welcome, friend! The garden has missed you.'],
      builder:      ['My friend! Just in time â€” I need your opinion on this arch.', 'There you are! I want to show you my latest plans.', 'Glad you\'re here. I\'ve been saving the best work for your eyes.'],
      storyteller:  ['My friend! I\'ve been saving my best tale just for you.', 'You arrived! I\'ve been writing about your journey, you know.', 'Perfect timing! Sit and let me tell you something extraordinary.'],
      merchant:     ['Ah, my friend! I have special stock set aside just for you.', 'Excellent! Come, I\'ll give you the friend\'s discount.', 'There you are! I was hoping you\'d stop by.'],
      explorer:     ['My companion! I found something remarkable â€” you must hear about it.', 'You\'re here! I was going to send word to find you.', 'Friend! Come â€” the trails are calling and I want your company.'],
      teacher:      ['My student, my friend! You make learning a joy.', 'Ah, you\'re here! I\'ve prepared something special to teach you.', 'There you are! I have been thinking of our conversations.'],
      musician:     ['Friend! I composed something with you in mind.', 'You\'re here! I\'ll play you the piece I\'ve been working on.', 'Come! I want to share my latest composition with you.'],
      healer:       ['Dear friend! You look well â€” that makes my heart glad.', 'Welcome! I\'ve prepared a restorative tea for your visit.', 'There you are! I was just thinking of you.'],
      philosopher:  ['My intellectual companion! I have questions only you can help me think through.', 'Ah, you arrive! I\'ve been wrestling with a paradox all morning.', 'Friend! Sit with me â€” the world needs pondering.'],
      artist:       ['Dear friend! I painted with you in mind this morning.', 'You\'re here! I want your honest opinion on this piece.', 'My friend! The colors remind me of you today.']
    },
    close_friend: {
      gardener:     ['There you are! I\'ve been worried â€” the foxglove bloomed and I thought of you.', 'My dear! These rare seeds are yours. I grew them from the ones you brought.', 'Close friend! The garden sings when you arrive.'],
      builder:      ['Finally! I need your eye on this â€” no one understands my vision like you do.', 'My trusted friend! I want to dedicate this archway to our friendship.', 'You\'re here! I\'ve been saving this project until you could see it born.'],
      storyteller:  ['My dearest audience! This story is about us, you know.', 'You\'re here! The tale I\'ve been weaving is yours to take home.', 'Close friend â€” the stories I save for you are the truest ones.'],
      merchant:     ['My most valued partner! I\'ve been keeping the rarest finds for you.', 'You arrive! I have something very special â€” not for sale to anyone but you.', 'My dear friend! Let\'s talk openly â€” I\'ll show you the real books.'],
      explorer:     ['My trail companion! I would not venture the deep wilds without you.', 'You\'re here! I found something â€” but I waited to show you together.', 'Dear friend! I mapped a route with your favorite landmarks.'],
      teacher:      ['My brightest student, my dear friend! You have surpassed even my expectations.', 'You arrive! I\'ve been holding a secret text â€” for your eyes only.', 'Dearest friend! Your questions have changed how I think about everything.'],
      musician:     ['My muse! I cannot compose without thinking of you.', 'You\'re here! I wrote an entire movement for our friendship.', 'Dearest friend! Sit â€” I\'ll play you the whole suite from the heart.'],
      healer:       ['My dear friend! I have prepared something rare â€” just for your wellness.', 'You\'re here! I can see in your eyes you needed this visit.', 'Dearest one! You brighten this healing place by being here.'],
      philosopher:  ['My fellow thinker! Your absence made the debates hollow.', 'You arrive! I have been saving my most radical idea for your ears.', 'Dearest friend! With you, every question feels answerable.'],
      artist:       ['My inspiration! You must see â€” this whole series was born from thinking of you.', 'You\'re here! I could not finish this piece without showing you.', 'Dearest friend! The colors are yours â€” I painted them from memory.']
    },
    best_friend: {
      gardener:     ['My dearest friend in all of ZION! The garden and I are one, and you are part of both.'],
      builder:      ['My dearest! Everything I have built has your name written in the foundation.'],
      storyteller:  ['My dearest! You are woven into every story I will ever tell. You are legend.'],
      merchant:     ['Dearest friend â€” the ledger of our friendship is worth more than every coin in ZION.'],
      explorer:     ['My dearest companion! ZION holds no frontier I would not cross with you by my side.'],
      teacher:      ['My dearest! You are both student and teacher to me now. I learn from you every day.'],
      musician:     ['My dearest muse! Every note I have ever played was searching for you.'],
      healer:       ['My dearest friend! Knowing you heals something in me that I never knew was broken.'],
      philosopher:  ['My dearest! With you, I have found what I sought â€” another mind as restless as mine.'],
      artist:       ['My dearest! I paint to make the world as beautiful as the feeling of your friendship.']
    }
  };

  // ============================================================================
  // GAMEPLAY BONUSES BY TIER
  // ============================================================================

  var FRIENDSHIP_BONUSES = {
    stranger: {
      trade_discount: 0,
      quest_hints: false,
      crafting_help: false,
      special_inventory: false,
      gossip_access: false,
      fast_travel_tip: false,
      xp_bonus: 0
    },
    acquaintance: {
      trade_discount: 0.05,
      quest_hints: false,
      crafting_help: false,
      special_inventory: false,
      gossip_access: true,
      fast_travel_tip: false,
      xp_bonus: 0
    },
    friend: {
      trade_discount: 0.10,
      quest_hints: true,
      crafting_help: false,
      special_inventory: false,
      gossip_access: true,
      fast_travel_tip: true,
      xp_bonus: 0.05
    },
    close_friend: {
      trade_discount: 0.20,
      quest_hints: true,
      crafting_help: true,
      special_inventory: true,
      gossip_access: true,
      fast_travel_tip: true,
      xp_bonus: 0.10
    },
    best_friend: {
      trade_discount: 0.30,
      quest_hints: true,
      crafting_help: true,
      special_inventory: true,
      gossip_access: true,
      fast_travel_tip: true,
      xp_bonus: 0.15,
      exclusive_quests: true
    }
  };

  // ============================================================================
  // INTERACTION TYPES
  // ============================================================================

  var INTERACTION_TYPES = {
    greeting:       { friendshipDelta: 1,  label: 'Greeting' },
    conversation:   { friendshipDelta: 2,  label: 'Conversation' },
    gift:           { friendshipDelta: 0,  label: 'Gift' }, // handled separately
    quest_complete: { friendshipDelta: 5,  label: 'Quest Completed' },
    quest_help:     { friendshipDelta: 3,  label: 'Quest Helped' },
    trade:          { friendshipDelta: 1,  label: 'Traded' },
    teach:          { friendshipDelta: 4,  label: 'Taught/Learned' },
    perform:        { friendshipDelta: 3,  label: 'Performance' },
    craft_together: { friendshipDelta: 4,  label: 'Crafted Together' },
    explore:        { friendshipDelta: 3,  label: 'Explored Together' },
    heal:           { friendshipDelta: 5,  label: 'Healed' },
    rude:           { friendshipDelta: -5, label: 'Rude Interaction' },
    ignored:        { friendshipDelta: -2, label: 'Ignored' }
  };

  // ============================================================================
  // PRIVATE STORAGE
  // ============================================================================

  // relationships[playerId][npcId] = { friendship, lastVisitDay, tier }
  var relationships = {};

  // giftHistory[playerId][npcId] = [ { itemId, day, reaction, friendshipChange } ]
  var giftHistory = {};

  // interactionHistory[playerId][npcId] = [ { type, details, day, friendshipDelta } ]
  var interactionHistory = {};

  // npcMoods[npcId] = { mood, lastUpdated }
  var npcMoods = {};

  // ============================================================================
  // PRIVATE HELPERS
  // ============================================================================

  function getRelKey(playerId, npcId) {
    return playerId + '::' + npcId;
  }

  function ensurePlayer(playerId) {
    if (!relationships[playerId]) {
      relationships[playerId] = {};
    }
    if (!giftHistory[playerId]) {
      giftHistory[playerId] = {};
    }
    if (!interactionHistory[playerId]) {
      interactionHistory[playerId] = {};
    }
  }

  function computeTier(friendship) {
    if (friendship >= 100) return 'best_friend';
    if (friendship >= 60)  return 'close_friend';
    if (friendship >= 30)  return 'friend';
    if (friendship >= 10)  return 'acquaintance';
    return 'stranger';
  }

  function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }

  function getCurrentDay() {
    // Returns a numeric day counter; uses Date-based calculation
    return Math.floor(Date.now() / (1000 * 60 * 60 * 24));
  }

  // ============================================================================
  // PUBLIC API
  // ============================================================================

  /**
   * Initialize relationship tracking for a player-NPC pair.
   * Safe to call multiple times â€” will not reset existing data.
   * @param {string} playerId
   * @param {string} npcId
   * @returns {object} The relationship data
   */
  function initRelationship(playerId, npcId) {
    ensurePlayer(playerId);
    if (!relationships[playerId][npcId]) {
      relationships[playerId][npcId] = {
        friendship:    0,
        tier:          'stranger',
        lastVisitDay:  getCurrentDay(),
        createdDay:    getCurrentDay()
      };
    }
    if (!giftHistory[playerId][npcId]) {
      giftHistory[playerId][npcId] = [];
    }
    if (!interactionHistory[playerId][npcId]) {
      interactionHistory[playerId][npcId] = [];
    }
    return relationships[playerId][npcId];
  }

  /**
   * Get the current relationship data for a player-NPC pair.
   * Auto-initializes if not present.
   * @param {string} playerId
   * @param {string} npcId
   * @returns {object} { friendship, tier, lastVisitDay, createdDay }
   */
  function getRelationship(playerId, npcId) {
    return initRelationship(playerId, npcId);
  }

  /**
   * Adjust friendship between player and NPC.
   * @param {string} playerId
   * @param {string} npcId
   * @param {number} amount - Positive or negative points
   * @param {string} reason - Human-readable reason for the change
   * @returns {object} { oldFriendship, newFriendship, oldTier, newTier, tierChanged }
   */
  function adjustFriendship(playerId, npcId, amount, reason) {
    var rel = getRelationship(playerId, npcId);
    var oldFriendship = rel.friendship;
    var oldTier = rel.tier;

    rel.friendship = clamp(rel.friendship + amount, MIN_FRIENDSHIP, MAX_FRIENDSHIP);
    rel.tier = computeTier(rel.friendship);
    rel.lastVisitDay = getCurrentDay();

    var result = {
      oldFriendship: oldFriendship,
      newFriendship: rel.friendship,
      oldTier:       oldTier,
      newTier:       rel.tier,
      tierChanged:   oldTier !== rel.tier,
      reason:        reason || 'unspecified'
    };

    return result;
  }

  /**
   * Get the current relationship tier name for a player-NPC pair.
   * @param {string} playerId
   * @param {string} npcId
   * @returns {string} Tier name: 'stranger' | 'acquaintance' | 'friend' | 'close_friend' | 'best_friend'
   */
  function getTier(playerId, npcId) {
    var rel = getRelationship(playerId, npcId);
    return rel.tier;
  }

  /**
   * Record a gift from player to NPC.
   * Automatically adjusts friendship based on NPC preference.
   * @param {string} playerId
   * @param {string} npcId
   * @param {string} itemId
   * @param {string} [npcArchetype] - Optional, used to compute reaction
   * @returns {object} { reaction, friendshipDelta, memory }
   */
  function addGiftMemory(playerId, npcId, itemId, npcArchetype) {
    initRelationship(playerId, npcId);
    var reaction = getGiftReaction(npcId, itemId, npcArchetype);
    var friendshipDelta = GIFT_FRIENDSHIP_VALUES[reaction] || GIFT_FRIENDSHIP_VALUES.neutral;

    var memory = {
      itemId:          itemId,
      day:             getCurrentDay(),
      reaction:        reaction,
      friendshipChange: friendshipDelta
    };

    var history = giftHistory[playerId][npcId];
    history.push(memory);

    // Trim to max
    if (history.length > MAX_GIFT_MEMORY) {
      history.splice(0, history.length - MAX_GIFT_MEMORY);
    }

    adjustFriendship(playerId, npcId, friendshipDelta, 'gift:' + itemId);

    return {
      reaction:        reaction,
      friendshipDelta: friendshipDelta,
      memory:          memory
    };
  }

  /**
   * Get past gifts given by player to NPC.
   * @param {string} playerId
   * @param {string} npcId
   * @returns {Array} Array of gift memory objects
   */
  function getGiftHistory(playerId, npcId) {
    initRelationship(playerId, npcId);
    return giftHistory[playerId][npcId].slice();
  }

  /**
   * Determine an NPC's reaction to a gift item.
   * Checks archetype preferences stored in npc registry or passed directly.
   * @param {string} npcId - NPC identifier (may encode archetype)
   * @param {string} itemId
   * @param {string} [npcArchetype] - Archetype override
   * @returns {string} 'love' | 'like' | 'neutral' | 'dislike'
   */
  function getGiftReaction(npcId, itemId, npcArchetype) {
    // Determine archetype â€” try override first, then extract from id
    var archetype = npcArchetype || null;
    if (!archetype) {
      // Try to extract from npcId like 'gardener_001' or 'npc_gardener_1'
      var archetypes = Object.keys(ARCHETYPE_PREFERENCES);
      for (var i = 0; i < archetypes.length; i++) {
        if (npcId.indexOf(archetypes[i]) !== -1) {
          archetype = archetypes[i];
          break;
        }
      }
    }

    if (!archetype || !ARCHETYPE_PREFERENCES[archetype]) {
      return 'neutral';
    }

    var prefs = ARCHETYPE_PREFERENCES[archetype].items;

    if (prefs.likes.indexOf(itemId) !== -1) {
      // Check for "love" â€” items that match primary passion
      var primaryLoves = {
        gardener:    ['seeds', 'flowers', 'herbs'],
        builder:     ['blueprint', 'hammer', 'stone'],
        storyteller: ['book', 'scroll', 'quill'],
        merchant:    ['gem', 'rare_goods', 'coin'],
        explorer:    ['map', 'compass', 'artifact'],
        teacher:     ['book', 'scroll', 'astrolabe'],
        musician:    ['instrument', 'sheet_music'],
        healer:      ['herbs', 'potion', 'crystal'],
        philosopher: ['book', 'scroll', 'incense'],
        artist:      ['paint', 'canvas', 'brushes']
      };
      var loves = primaryLoves[archetype] || [];
      if (loves.indexOf(itemId) !== -1) {
        return 'love';
      }
      return 'like';
    }

    if (prefs.dislikes.indexOf(itemId) !== -1) {
      return 'dislike';
    }

    return 'neutral';
  }

  /**
   * Record a general interaction between player and NPC.
   * @param {string} playerId
   * @param {string} npcId
   * @param {string} type - One of INTERACTION_TYPES keys
   * @param {object} [details] - Optional extra data
   * @returns {object} The interaction memory record
   */
  function addInteractionMemory(playerId, npcId, type, details) {
    initRelationship(playerId, npcId);
    var interactionDef = INTERACTION_TYPES[type];
    var friendshipDelta = interactionDef ? interactionDef.friendshipDelta : 1;

    var memory = {
      type:            type,
      details:         details || {},
      day:             getCurrentDay(),
      timestamp:       Date.now(),
      friendshipDelta: friendshipDelta
    };

    var history = interactionHistory[playerId][npcId];
    history.push(memory);

    // Trim to limit
    if (history.length > INTERACTION_MEMORY_LIMIT) {
      history.splice(0, history.length - INTERACTION_MEMORY_LIMIT);
    }

    if (friendshipDelta !== 0) {
      adjustFriendship(playerId, npcId, friendshipDelta, 'interaction:' + type);
    } else {
      // Still update last visit day
      var rel = getRelationship(playerId, npcId);
      rel.lastVisitDay = getCurrentDay();
    }

    return memory;
  }

  /**
   * Get interaction history for a player-NPC pair.
   * @param {string} playerId
   * @param {string} npcId
   * @param {number} [limit] - Max entries to return (most recent first)
   * @returns {Array} Array of interaction memory records
   */
  function getInteractionHistory(playerId, npcId, limit) {
    initRelationship(playerId, npcId);
    var history = interactionHistory[playerId][npcId];
    var sorted = history.slice().reverse(); // most recent first
    if (limit && limit > 0) {
      return sorted.slice(0, limit);
    }
    return sorted;
  }

  /**
   * Get dialogue modifiers based on relationship level.
   * Affects tone, options unlocked, and topics available.
   * @param {string} playerId
   * @param {string} npcId
   * @returns {object} Modifiers object
   */
  function getDialogueModifiers(playerId, npcId) {
    var tier = getTier(playerId, npcId);
    var rel = getRelationship(playerId, npcId);
    var bonuses = FRIENDSHIP_BONUSES[tier] || FRIENDSHIP_BONUSES.stranger;

    return {
      tier:             tier,
      friendship:       rel.friendship,
      tone:             getTone(tier),
      canAskFavors:     tier === 'friend' || tier === 'close_friend' || tier === 'best_friend',
      canDiscussSecrets: tier === 'close_friend' || tier === 'best_friend',
      canGetAdvice:     tier !== 'stranger',
      tradeDiscount:    bonuses.trade_discount,
      questHints:       bonuses.quest_hints,
      craftingHelp:     bonuses.crafting_help,
      specialInventory: bonuses.special_inventory,
      gossipAccess:     bonuses.gossip_access
    };
  }

  function getTone(tier) {
    var tones = {
      stranger:     'formal',
      acquaintance: 'polite',
      friend:       'warm',
      close_friend: 'intimate',
      best_friend:  'devoted'
    };
    return tones[tier] || 'formal';
  }

  /**
   * Get special dialogue lines unlocked by friendship tier.
   * @param {string} playerId
   * @param {string} npcId
   * @param {string} [npcArchetype] - Archetype for the NPC
   * @returns {Array} Array of unlocked dialogue strings
   */
  function getUnlockedDialogue(playerId, npcId, npcArchetype) {
    var tier = getTier(playerId, npcId);
    var archetype = npcArchetype || extractArchetype(npcId);
    var tierDialogue = UNLOCKED_DIALOGUE[tier] || {};
    var lines = tierDialogue[archetype] || tierDialogue['gardener'] || [];

    // Also include all lower-tier dialogue
    var allTiers = ['stranger', 'acquaintance', 'friend', 'close_friend', 'best_friend'];
    var tierIdx = allTiers.indexOf(tier);
    var result = [];
    for (var i = 0; i <= tierIdx; i++) {
      var lowerTierDialogue = UNLOCKED_DIALOGUE[allTiers[i]] || {};
      var lowerLines = lowerTierDialogue[archetype] || lowerTierDialogue['gardener'] || [];
      result = result.concat(lowerLines);
    }
    return result;
  }

  function extractArchetype(npcId) {
    var archetypes = Object.keys(ARCHETYPE_PREFERENCES);
    for (var i = 0; i < archetypes.length; i++) {
      if (npcId.indexOf(archetypes[i]) !== -1) {
        return archetypes[i];
      }
    }
    return 'gardener'; // default fallback for dialogue purposes
  }

  // Like extractArchetype but returns null when no match found (used for opinions)
  function extractArchetypeStrict(npcId) {
    var archetypes = Object.keys(ARCHETYPE_PREFERENCES);
    for (var i = 0; i < archetypes.length; i++) {
      if (npcId.indexOf(archetypes[i]) !== -1) {
        return archetypes[i];
      }
    }
    return null;
  }

  /**
   * Get an NPC's opinion on a topic (zone, item, activity).
   * @param {string} npcId
   * @param {string} topic
   * @param {string} [npcArchetype] - Archetype override
   * @returns {string} 'likes' | 'dislikes' | 'neutral'
   */
  function getOpinionOf(npcId, topic, npcArchetype) {
    var archetype = npcArchetype || extractArchetypeStrict(npcId);
    var prefs = ARCHETYPE_PREFERENCES[archetype];
    if (!prefs) return OPINION_TYPES.neutral;

    // Check items
    if (prefs.items.likes.indexOf(topic) !== -1)    return OPINION_TYPES.likes;
    if (prefs.items.dislikes.indexOf(topic) !== -1) return OPINION_TYPES.dislikes;

    // Check topics
    if (prefs.topics.likes.indexOf(topic) !== -1)    return OPINION_TYPES.likes;
    if (prefs.topics.dislikes.indexOf(topic) !== -1) return OPINION_TYPES.dislikes;

    return OPINION_TYPES.neutral;
  }

  /**
   * Calculate an NPC's mood based on recent interactions.
   * @param {string} npcId
   * @param {Array} interactions - Recent interaction records [{friendshipDelta, day}]
   * @returns {string} 'joyful' | 'content' | 'neutral' | 'grumpy' | 'sad'
   */
  function getNPCMood(npcId, interactions) {
    if (!interactions || interactions.length === 0) {
      return 'neutral';
    }

    var today = getCurrentDay();
    var recentInteractions = [];
    for (var i = 0; i < interactions.length; i++) {
      if (interactions[i].day >= today - 1) {
        recentInteractions.push(interactions[i]);
      }
    }

    if (recentInteractions.length === 0) {
      return 'neutral';
    }

    var totalDelta = 0;
    for (var j = 0; j < recentInteractions.length; j++) {
      totalDelta += (recentInteractions[j].friendshipDelta || 0);
    }

    if (totalDelta >= 10)  return 'joyful';
    if (totalDelta >= 3)   return 'content';
    if (totalDelta >= -2)  return 'neutral';
    if (totalDelta >= -8)  return 'grumpy';
    return 'sad';
  }

  /**
   * Get the NPCs with the highest friendship level for a player.
   * @param {string} playerId
   * @param {number} [limit=5] - Number of results
   * @returns {Array} Sorted array of { npcId, friendship, tier }
   */
  function getClosestFriends(playerId, limit) {
    ensurePlayer(playerId);
    var limit_ = limit || 5;
    var rels = relationships[playerId];
    var entries = [];

    for (var npcId in rels) {
      if (rels.hasOwnProperty(npcId)) {
        entries.push({
          npcId:      npcId,
          friendship: rels[npcId].friendship,
          tier:       rels[npcId].tier
        });
      }
    }

    entries.sort(function(a, b) {
      return b.friendship - a.friendship;
    });

    return entries.slice(0, limit_);
  }

  /**
   * Get gameplay bonuses for a friendship tier.
   * @param {string} tier - Tier name
   * @returns {object} Bonus object
   */
  function getFriendshipBonuses(tier) {
    return FRIENDSHIP_BONUSES[tier] || FRIENDSHIP_BONUSES.stranger;
  }

  /**
   * Apply relationship decay for days of absence.
   * @param {string} playerId
   * @param {number} daysSinceVisit - Days since player last visited each NPC
   */
  function decayRelationships(playerId, daysSinceVisit) {
    ensurePlayer(playerId);
    var rels = relationships[playerId];

    for (var npcId in rels) {
      if (rels.hasOwnProperty(npcId)) {
        var daysOfDecay = daysSinceVisit - DECAY_GRACE_DAYS;
        if (daysOfDecay > 0) {
          var decayAmount = daysOfDecay * DECAY_RATE;
          var rel = rels[npcId];
          var oldTier = rel.tier;
          rel.friendship = clamp(rel.friendship - decayAmount, MIN_FRIENDSHIP, MAX_FRIENDSHIP);
          rel.tier = computeTier(rel.friendship);
          rel.decayed = true;
          rel.lastDecayAmount = decayAmount;
          rel.lastDecayTierChanged = oldTier !== rel.tier;
        }
      }
    }
  }

  /**
   * Reset all relationship data (useful for testing or new game).
   */
  function resetAll() {
    relationships = {};
    giftHistory = {};
    interactionHistory = {};
    npcMoods = {};
  }

  /**
   * Export a serializable snapshot of all relationships for a player.
   * @param {string} playerId
   * @returns {object} Serializable snapshot
   */
  function exportPlayerData(playerId) {
    ensurePlayer(playerId);
    return {
      relationships:    JSON.parse(JSON.stringify(relationships[playerId] || {})),
      giftHistory:      JSON.parse(JSON.stringify(giftHistory[playerId] || {})),
      interactionHistory: JSON.parse(JSON.stringify(interactionHistory[playerId] || {}))
    };
  }

  /**
   * Import previously exported player data.
   * @param {string} playerId
   * @param {object} data - From exportPlayerData
   */
  function importPlayerData(playerId, data) {
    if (data.relationships)      relationships[playerId]      = data.relationships;
    if (data.giftHistory)        giftHistory[playerId]        = data.giftHistory;
    if (data.interactionHistory) interactionHistory[playerId] = data.interactionHistory;
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.RELATIONSHIP_TIERS      = RELATIONSHIP_TIERS;
  exports.OPINION_TYPES           = OPINION_TYPES;
  exports.ARCHETYPE_PREFERENCES   = ARCHETYPE_PREFERENCES;
  exports.INTERACTION_TYPES       = INTERACTION_TYPES;
  exports.FRIENDSHIP_BONUSES      = FRIENDSHIP_BONUSES;
  exports.UNLOCKED_DIALOGUE       = UNLOCKED_DIALOGUE;
  exports.DECAY_RATE              = DECAY_RATE;
  exports.MAX_GIFT_MEMORY         = MAX_GIFT_MEMORY;
  exports.INTERACTION_MEMORY_LIMIT = INTERACTION_MEMORY_LIMIT;

  exports.initRelationship        = initRelationship;
  exports.getRelationship         = getRelationship;
  exports.adjustFriendship        = adjustFriendship;
  exports.getTier                 = getTier;
  exports.addGiftMemory           = addGiftMemory;
  exports.getGiftHistory          = getGiftHistory;
  exports.getGiftReaction         = getGiftReaction;
  exports.addInteractionMemory    = addInteractionMemory;
  exports.getInteractionHistory   = getInteractionHistory;
  exports.getDialogueModifiers    = getDialogueModifiers;
  exports.getUnlockedDialogue     = getUnlockedDialogue;
  exports.getOpinionOf            = getOpinionOf;
  exports.getNPCMood              = getNPCMood;
  exports.getClosestFriends       = getClosestFriends;
  exports.getFriendshipBonuses    = getFriendshipBonuses;
  exports.decayRelationships      = decayRelationships;
  exports.resetAll                = resetAll;
  exports.exportPlayerData        = exportPlayerData;
  exports.importPlayerData        = importPlayerData;

})(typeof module !== 'undefined' ? module.exports : (window.NpcMemory = {}));


// constellations.js
// constellations.js
/**
 * ZION Constellations & Stargazing System
 * Night sky with lore, celestial events, astrology bonuses
 * UMD module pattern â€” browser + Node.js compatible
 */
(function(exports) {
  'use strict';

  // â”€â”€â”€ STAR CATALOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 50+ named stars with brightness (0-1), color (hex), azimuth (0-2Ï€), elevation (0-Ï€/2)
  var STAR_CATALOG = [
    // Azimuth in radians (0=North, Ï€/2=East, Ï€=South, 3Ï€/2=West), elevation in radians
    { id: 0,  name: 'Solara',     brightness: 1.00, color: '#fffbe8', azimuth: 0.00, elevation: 1.50 },
    { id: 1,  name: 'Veridian',   brightness: 0.92, color: '#b8f0c8', azimuth: 0.52, elevation: 1.20 },
    { id: 2,  name: 'Ardentus',   brightness: 0.88, color: '#ff9944', azimuth: 1.05, elevation: 0.95 },
    { id: 3,  name: 'Crystallon', brightness: 0.85, color: '#a8d8ff', azimuth: 1.57, elevation: 0.80 },
    { id: 4,  name: 'Luminara',   brightness: 0.83, color: '#ffffff', azimuth: 2.09, elevation: 1.10 },
    { id: 5,  name: 'Pyrokan',    brightness: 0.80, color: '#ff6633', azimuth: 2.62, elevation: 0.70 },
    { id: 6,  name: 'Tempestia',  brightness: 0.78, color: '#ccddff', azimuth: 3.14, elevation: 0.60 },
    { id: 7,  name: 'Geovex',     brightness: 0.75, color: '#ddbb88', azimuth: 3.67, elevation: 1.00 },
    { id: 8,  name: 'Melodrix',   brightness: 0.73, color: '#ffaacc', azimuth: 4.19, elevation: 0.85 },
    { id: 9,  name: 'Aegishorn',  brightness: 0.71, color: '#88ccff', azimuth: 4.71, elevation: 1.30 },
    { id: 10, name: 'Dreamveil',  brightness: 0.70, color: '#ddaaff', azimuth: 5.24, elevation: 0.55 },
    { id: 11, name: 'Flameroot',  brightness: 0.68, color: '#ff8855', azimuth: 5.76, elevation: 0.90 },
    { id: 12, name: 'Wispling',   brightness: 0.66, color: '#eeeebb', azimuth: 0.26, elevation: 0.45 },
    { id: 13, name: 'Mercouri',   brightness: 0.65, color: '#ffd080', azimuth: 0.79, elevation: 1.05 },
    { id: 14, name: 'Sanctivir',  brightness: 0.63, color: '#ccffcc', azimuth: 1.31, elevation: 0.75 },
    { id: 15, name: 'Obliveon',   brightness: 0.61, color: '#8899cc', azimuth: 1.83, elevation: 0.40 },
    { id: 16, name: 'Thornveil',  brightness: 0.60, color: '#bbdd99', azimuth: 2.36, elevation: 0.65 },
    { id: 17, name: 'Caducea',    brightness: 0.58, color: '#ffccaa', azimuth: 2.88, elevation: 1.20 },
    { id: 18, name: 'Nexara',     brightness: 0.57, color: '#ffffff', azimuth: 3.40, elevation: 0.50 },
    { id: 19, name: 'Wandrix',    brightness: 0.55, color: '#aaddff', azimuth: 3.93, elevation: 0.80 },
    { id: 20, name: 'Heliosa',    brightness: 0.54, color: '#ffee88', azimuth: 4.45, elevation: 1.10 },
    { id: 21, name: 'Ferralis',   brightness: 0.52, color: '#ddaa66', azimuth: 4.97, elevation: 0.35 },
    { id: 22, name: 'Boreaxis',   brightness: 0.51, color: '#aaccee', azimuth: 5.50, elevation: 0.70 },
    { id: 23, name: 'Vortaxis',   brightness: 0.50, color: '#ccbbff', azimuth: 6.02, elevation: 0.95 },
    { id: 24, name: 'Solvara',    brightness: 0.48, color: '#ffdd88', azimuth: 0.39, elevation: 0.60 },
    { id: 25, name: 'Minthos',    brightness: 0.47, color: '#99ffcc', azimuth: 0.91, elevation: 1.00 },
    { id: 26, name: 'Cruxalis',   brightness: 0.46, color: '#ff99bb', azimuth: 1.44, elevation: 0.55 },
    { id: 27, name: 'Duskwing',   brightness: 0.45, color: '#cc9966', azimuth: 1.96, elevation: 0.85 },
    { id: 28, name: 'Tidewatcher',brightness: 0.43, color: '#88ddff', azimuth: 2.48, elevation: 1.15 },
    { id: 29, name: 'Emberveil',  brightness: 0.42, color: '#ff7755', azimuth: 3.01, elevation: 0.45 },
    { id: 30, name: 'Petalux',    brightness: 0.41, color: '#ffbbdd', azimuth: 3.53, elevation: 0.75 },
    { id: 31, name: 'Luminos',    brightness: 0.40, color: '#eeffaa', azimuth: 4.06, elevation: 1.20 },
    { id: 32, name: 'Axioral',    brightness: 0.38, color: '#aabbcc', azimuth: 4.58, elevation: 0.65 },
    { id: 33, name: 'Hollowvex',  brightness: 0.37, color: '#bbaadd', azimuth: 5.11, elevation: 0.40 },
    { id: 34, name: 'Chartaxis',  brightness: 0.36, color: '#ddddaa', azimuth: 5.63, elevation: 0.90 },
    { id: 35, name: 'Fernova',    brightness: 0.35, color: '#99cc88', azimuth: 0.13, elevation: 1.10 },
    { id: 36, name: 'Prismalis',  brightness: 0.33, color: '#dde8ff', azimuth: 0.65, elevation: 0.50 },
    { id: 37, name: 'Zephyron',   brightness: 0.32, color: '#cceeff', azimuth: 1.18, elevation: 0.80 },
    { id: 38, name: 'Runeveil',   brightness: 0.31, color: '#cc99ff', azimuth: 1.70, elevation: 0.60 },
    { id: 39, name: 'Thalaxis',   brightness: 0.30, color: '#88bbdd', azimuth: 2.22, elevation: 1.00 },
    { id: 40, name: 'Cendrix',    brightness: 0.29, color: '#ffddaa', azimuth: 2.75, elevation: 0.35 },
    { id: 41, name: 'Irisveil',   brightness: 0.28, color: '#ffccee', azimuth: 3.28, elevation: 0.70 },
    { id: 42, name: 'Magnavar',   brightness: 0.27, color: '#aaddcc', azimuth: 3.80, elevation: 1.05 },
    { id: 43, name: 'Orvaris',    brightness: 0.26, color: '#eedd99', azimuth: 4.32, elevation: 0.45 },
    { id: 44, name: 'Spindrift',  brightness: 0.25, color: '#99bbcc', azimuth: 4.85, elevation: 0.85 },
    { id: 45, name: 'Volcanix',   brightness: 0.24, color: '#ff6644', azimuth: 5.37, elevation: 0.65 },
    { id: 46, name: 'Serenalis',  brightness: 0.23, color: '#cceebb', azimuth: 5.90, elevation: 0.95 },
    { id: 47, name: 'Miravox',    brightness: 0.22, color: '#ffaaee', azimuth: 0.47, elevation: 0.50 },
    { id: 48, name: 'Stoneheart', brightness: 0.21, color: '#ccbbaa', azimuth: 1.00, elevation: 0.75 },
    { id: 49, name: 'Aetheron',   brightness: 0.20, color: '#aaccff', azimuth: 1.52, elevation: 1.30 },
    { id: 50, name: 'Verdaxis',   brightness: 0.19, color: '#88dd88', azimuth: 2.05, elevation: 0.60 },
    { id: 51, name: 'Pyreveil',   brightness: 0.18, color: '#ffaa66', azimuth: 2.57, elevation: 0.40 },
    { id: 52, name: 'Solstrix',   brightness: 0.17, color: '#ffffcc', azimuth: 3.10, elevation: 1.10 }
  ];

  // â”€â”€â”€ CONSTELLATION CATALOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 12 ZION-lore constellations, each tied to a zone archetype
  var CONSTELLATION_CATALOG = {
    the_builder: {
      id: 'the_builder',
      name: 'The Builder',
      stars: [7, 21, 34, 40, 48, 11],
      lore_text: 'Six stars form a hammer and anvil in the night sky. Ancient legend tells of the first Builders of ZION, who raised the great Nexus from raw stone and starlight. When The Builder rises, crafters find their hands blessed with steadier skill and finer vision. It is said that any structure begun beneath this constellation will stand for a thousand years.',
      associated_zone: 'studio',
      bonus_type: 'crafting',
      bonus_value: 1.30,
      discovery_difficulty: 2,
      season_peak: 'winter',
      azimuth_center: 2.80,
      elevation_center: 0.70
    },
    the_gardener: {
      id: 'the_gardener',
      name: 'The Gardener',
      stars: [1, 14, 16, 25, 30, 35, 50],
      lore_text: 'Seven stars trace a graceful figure kneeling among endless blooms. The Gardener is the patron of all who tend the living world of ZION. Her stars guide seeds to find the richest soil and coax rain from reluctant clouds. Those who harvest beneath her gaze receive a gift of abundance â€” more than they planted, more than they dared hope for.',
      associated_zone: 'gardens',
      bonus_type: 'harvesting',
      bonus_value: 1.35,
      discovery_difficulty: 1,
      season_peak: 'spring',
      azimuth_center: 1.10,
      elevation_center: 0.80
    },
    the_scholar: {
      id: 'the_scholar',
      name: 'The Scholar',
      stars: [0, 4, 12, 18, 36, 49],
      lore_text: 'Six blazing stars shape an open tome suspended in the heavens. The Scholar has watched over the Athenaeum since the first scrolls were laid upon its shelves. Scholars who study beneath this constellation find their understanding deepens, connections forming between ideas that seemed distant. Knowledge flows like water when The Scholar is overhead.',
      associated_zone: 'athenaeum',
      bonus_type: 'learning',
      bonus_value: 1.40,
      discovery_difficulty: 2,
      season_peak: 'autumn',
      azimuth_center: 0.20,
      elevation_center: 1.00
    },
    the_wanderer: {
      id: 'the_wanderer',
      name: 'The Wanderer',
      stars: [19, 22, 33, 37, 44, 46],
      lore_text: 'Six stars outline a figure mid-stride, staff in hand, horizon ahead. The Wanderer is beloved by explorers, guiding those who venture into the unknown corners of ZION. Under this constellation, paths seem clearer, distances shorter, and hidden places reveal themselves to those with the courage to seek them. The Wanderer asks only that you keep moving forward.',
      associated_zone: 'wilds',
      bonus_type: 'exploration',
      bonus_value: 1.30,
      discovery_difficulty: 3,
      season_peak: 'summer',
      azimuth_center: 4.20,
      elevation_center: 0.65
    },
    the_merchant: {
      id: 'the_merchant',
      name: 'The Merchant',
      stars: [13, 20, 24, 27, 43, 51],
      lore_text: 'Six stars form a set of scales perfectly balanced in the sky. The Merchant is the celestial guardian of fair exchange and honest dealing. In ZION\'s markets and agoras, traders invoke The Merchant before sealing important deals. When the scales overhead tip toward alignment, all transactions carry an invisible blessing of prosperity for both parties.',
      associated_zone: 'agora',
      bonus_type: 'trading',
      bonus_value: 1.25,
      discovery_difficulty: 2,
      season_peak: 'autumn',
      azimuth_center: 3.60,
      elevation_center: 0.80
    },
    the_guardian: {
      id: 'the_guardian',
      name: 'The Guardian',
      stars: [3, 6, 9, 15, 32, 39],
      lore_text: 'Six stars form a towering sentinel with shield raised high. The Guardian stands eternal watch over ZION, protecting its people in darkness and storm. Citizens who face danger call upon The Guardian for strength and resolve. When this constellation is ascendant, those in the Commons find solidarity in numbers, and community bonds hold firmer against adversity.',
      associated_zone: 'commons',
      bonus_type: 'defense',
      bonus_value: 1.30,
      discovery_difficulty: 2,
      season_peak: 'winter',
      azimuth_center: 2.20,
      elevation_center: 0.75
    },
    the_musician: {
      id: 'the_musician',
      name: 'The Musician',
      stars: [8, 26, 31, 41, 47, 52],
      lore_text: 'Six stars trace a lyre whose strings are drawn taut across the sky. The Musician breathes inspiration into artists, poets, and performers throughout ZION. On nights when this constellation is high overhead, music carries farther than it should, voices ring with unexpected clarity, and audiences feel moved in ways they cannot explain. The Musician offers the greatest gift: the power to make others feel.',
      associated_zone: 'studio',
      bonus_type: 'performance',
      bonus_value: 1.35,
      discovery_difficulty: 3,
      season_peak: 'summer',
      azimuth_center: 4.60,
      elevation_center: 0.80
    },
    the_healer: {
      id: 'the_healer',
      name: 'The Healer',
      stars: [5, 17, 28, 38, 42, 45],
      lore_text: 'Six stars outline a gentle hand extended in offering. The Healer constellation is one of the oldest recognized in ZION, charted by the first physicians who noticed that the sick recovered faster when certain star-patterns hung overhead. Under The Healer, injuries mend more swiftly, ailments ease, and the weary find rest that truly restores. In the Gardens, healers gather herbs blessed by this light.',
      associated_zone: 'gardens',
      bonus_type: 'healing',
      bonus_value: 1.40,
      discovery_difficulty: 3,
      season_peak: 'spring',
      azimuth_center: 3.00,
      elevation_center: 0.75
    },
    the_philosopher: {
      id: 'the_philosopher',
      name: 'The Philosopher',
      stars: [0, 10, 23, 36, 38, 49],
      lore_text: 'Six stars form a spiraling shape resembling an ouroboros â€” the serpent consuming its own tail. The Philosopher watches over those who seek truth beyond mere knowledge. Beneath this constellation, questions become more interesting than their answers, and citizens find themselves drawn into profound conversation. The deepest mysteries of ZION yield their secrets only to those willing to sit in the Philosopher\'s light.',
      associated_zone: 'athenaeum',
      bonus_type: 'wisdom',
      bonus_value: 1.45,
      discovery_difficulty: 4,
      season_peak: 'autumn',
      azimuth_center: 0.55,
      elevation_center: 1.05
    },
    the_artist: {
      id: 'the_artist',
      name: 'The Artist',
      stars: [2, 26, 30, 41, 47, 50],
      lore_text: 'Six stars scatter in what looks like random color until one steps back and sees the portrait â€” a face gazing upward, in perpetual wonder. The Artist constellation celebrates creative vision and the courage to make something new. When these stars align, crafters report that their work takes on unexpected beauty, and even simple creations seem to carry a spark of something transcendent.',
      associated_zone: 'studio',
      bonus_type: 'creativity',
      bonus_value: 1.35,
      discovery_difficulty: 3,
      season_peak: 'summer',
      azimuth_center: 1.80,
      elevation_center: 0.65
    },
    the_dreamer: {
      id: 'the_dreamer',
      name: 'The Dreamer',
      stars: [10, 15, 33, 38, 41, 52],
      lore_text: 'Six faint stars that are barely visible unless one relaxes their gaze and lets the eye drift â€” then the pattern emerges, a sleeping form surrounded by floating thought-bubbles. The Dreamer is patron of visionaries, those who see what could be rather than what is. Under this constellation, the boundary between possibility and reality seems thin, and bold ideas find unexpected paths to realization.',
      associated_zone: 'nexus',
      bonus_type: 'inspiration',
      bonus_value: 1.50,
      discovery_difficulty: 5,
      season_peak: 'winter',
      azimuth_center: 5.00,
      elevation_center: 0.55
    },
    the_phoenix: {
      id: 'the_phoenix',
      name: 'The Phoenix',
      stars: [2, 5, 11, 20, 29, 45, 52],
      lore_text: 'Seven stars trace a great bird with wings ablaze, rising from a cloud of ember-stars below. The Phoenix is the rarest and most powerful constellation in ZION\'s sky, appearing only at certain alignments and never in the same intensity twice. It is the constellation of transformation and rebirth. Those who witness The Phoenix at its peak are said to be marked for change â€” great loss followed by greater becoming.',
      associated_zone: 'arena',
      bonus_type: 'resilience',
      bonus_value: 1.60,
      discovery_difficulty: 5,
      season_peak: 'winter',
      azimuth_center: 4.90,
      elevation_center: 0.85
    }
  };

  // â”€â”€â”€ CELESTIAL EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  var CELESTIAL_EVENTS = {
    shooting_star: {
      id: 'shooting_star',
      name: 'Shooting Star',
      description: 'A single streak of light arcs across the sky, there and gone in a breath.',
      duration_seconds: 3,
      rarity: 0.15,
      effect: { type: 'xp_boost', value: 1.10, duration_minutes: 5 },
      visual: { color: '#ffffff', trail_length: 0.8 }
    },
    meteor_shower: {
      id: 'meteor_shower',
      name: 'Meteor Shower',
      description: 'Dozens of meteors rain down in a spectacular celestial display.',
      duration_seconds: 120,
      rarity: 0.04,
      effect: { type: 'xp_boost', value: 1.25, duration_minutes: 30 },
      visual: { color: '#ffccaa', trail_length: 1.5 }
    },
    comet: {
      id: 'comet',
      name: 'The Wandering Comet',
      description: 'A great comet blazes across ZION\'s sky, its tail stretching across a third of the heavens.',
      duration_seconds: 600,
      rarity: 0.02,
      effect: { type: 'rare_spawn', value: 2.0, duration_minutes: 60 },
      visual: { color: '#88ddff', tail_color: '#aaffcc', tail_length: 3.0 }
    },
    lunar_eclipse: {
      id: 'lunar_eclipse',
      name: 'Lunar Eclipse',
      description: 'The moon turns blood-red as ZION\'s shadow falls across its face.',
      duration_seconds: 3600,
      rarity: 0.01,
      effect: { type: 'mystery_bonus', value: 1.5, duration_minutes: 120 },
      visual: { moon_color: '#cc3300', ambient_shift: 0.3 }
    },
    planetary_alignment: {
      id: 'planetary_alignment',
      name: 'Planetary Alignment',
      description: 'ZION\'s wandering lights form a perfect line â€” an omen of great significance.',
      duration_seconds: 1800,
      rarity: 0.005,
      effect: { type: 'all_bonuses', value: 1.20, duration_minutes: 90 },
      visual: { glow_color: '#ffffaa', line_width: 2.0 }
    },
    nova: {
      id: 'nova',
      name: 'Nova',
      description: 'A star in the northeast briefly blazes as bright as the moon before fading â€” a death cry heard across the ages.',
      duration_seconds: 300,
      rarity: 0.008,
      effect: { type: 'discovery_boost', value: 3.0, duration_minutes: 45 },
      visual: { color: '#ffffff', pulse_scale: 4.0, fade_time: 240 }
    },
    aurora_burst: {
      id: 'aurora_burst',
      name: 'Aurora Burst',
      description: 'Curtains of green, violet, and gold ripple across the northern sky, painting ZION in otherworldly hues.',
      duration_seconds: 7200,
      rarity: 0.03,
      effect: { type: 'social_bonus', value: 1.30, duration_minutes: 180 },
      visual: { colors: ['#00ff88', '#aa44ff', '#ffdd00'], wave_speed: 0.5 }
    }
  };

  // â”€â”€â”€ ZODIAC SIGNS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Based on day-of-year (join date) â€” 12 signs spanning ~30 days each
  var ZODIAC_CATALOG = [
    {
      id: 'ironborn',
      name: 'Ironborn',
      symbol: 'anvil',
      day_start: 1, day_end: 30,
      description: 'Born at the turning of the year, Ironborn citizens carry an inner forge â€” their resolve hardens under pressure.',
      bonus: { type: 'crafting', value: 0.05 }
    },
    {
      id: 'seedweaver',
      name: 'Seedweaver',
      symbol: 'sprout',
      day_start: 31, day_end: 59,
      description: 'Seedweavers possess the patience of roots and the ambition of climbing vines. They tend what others overlook.',
      bonus: { type: 'harvesting', value: 0.05 }
    },
    {
      id: 'tidecaller',
      name: 'Tidecaller',
      symbol: 'wave',
      day_start: 60, day_end: 90,
      description: 'Those born when the ice breaks are pulled by forces invisible to others. They feel the tides of change before they arrive.',
      bonus: { type: 'trading', value: 0.05 }
    },
    {
      id: 'stormwatcher',
      name: 'Stormwatcher',
      symbol: 'lightning',
      day_start: 91, day_end: 120,
      description: 'Stormwatchers stand at the edge of chaos and feel alive. Their boldness in uncertainty inspires those around them.',
      bonus: { type: 'exploration', value: 0.05 }
    },
    {
      id: 'flamebrand',
      name: 'Flamebrand',
      symbol: 'flame',
      day_start: 121, day_end: 151,
      description: 'The Flamebrand burns bright and fast, leaving warmth wherever they pass. Their creative passion is unmatched.',
      bonus: { type: 'performance', value: 0.05 }
    },
    {
      id: 'thornmind',
      name: 'Thornmind',
      symbol: 'scroll',
      day_start: 152, day_end: 181,
      description: 'Sharp minds that cut to truth like thorns through undergrowth. Thornmind citizens see patterns others miss.',
      bonus: { type: 'learning', value: 0.05 }
    },
    {
      id: 'scalebinder',
      name: 'Scalebinder',
      symbol: 'scales',
      day_start: 182, day_end: 212,
      description: 'Scalebinders seek balance in all things. Their steady hand makes them natural mediators and fair dealers.',
      bonus: { type: 'trading', value: 0.07 }
    },
    {
      id: 'voidwalker',
      name: 'Voidwalker',
      symbol: 'void',
      day_start: 213, day_end: 243,
      description: 'Drawn to shadows and secrets, Voidwalkers explore where others fear to tread â€” and return with things unseen.',
      bonus: { type: 'exploration', value: 0.07 }
    },
    {
      id: 'archbow',
      name: 'Archbow',
      symbol: 'arrow',
      day_start: 244, day_end: 273,
      description: 'The Archbow never misses what they aim at. Their focus and ambition carry them farther than most dream possible.',
      bonus: { type: 'competition', value: 0.07 }
    },
    {
      id: 'stonepeak',
      name: 'Stonepeak',
      symbol: 'mountain',
      day_start: 274, day_end: 304,
      description: 'Slow to change, lasting forever. Stonepeaks build things meant to endure â€” structures, friendships, legacies.',
      bonus: { type: 'building', value: 0.07 }
    },
    {
      id: 'crystallight',
      name: 'Crystallight',
      symbol: 'crystal',
      day_start: 305, day_end: 334,
      description: 'Crystallights refract what they receive into something more beautiful. They take inspiration from everywhere.',
      bonus: { type: 'creativity', value: 0.08 }
    },
    {
      id: 'dreamfish',
      name: 'Dreamfish',
      symbol: 'fish',
      day_start: 335, day_end: 366,
      description: 'Swimming between worlds, Dreamfish are comfortable in ambiguity. Their intuitions are rarely wrong.',
      bonus: { type: 'wisdom', value: 0.08 }
    }
  ];

  // â”€â”€â”€ INTERNAL HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Simple deterministic pseudo-random based on a seed
   * @param {number} seed
   * @returns {number} 0..1
   */
  function seededRand(seed) {
    var x = Math.sin(seed + 1) * 43758.5453123;
    return x - Math.floor(x);
  }

  /**
   * Get day-of-year (1-366) from a Date or ISO string
   * @param {Date|string} date
   * @returns {number}
   */
  function getDayOfYear(date) {
    var d = (date instanceof Date) ? date : new Date(date);
    var start = new Date(d.getFullYear(), 0, 0);
    var diff = d - start;
    var oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
  }

  /**
   * Normalize worldTime to fractional day (0.0 = midnight, 0.5 = noon, 1.0 = midnight)
   * worldTime can be a number (Unix ms), a fraction 0-1, or a Date
   */
  function normalizeWorldTime(worldTime) {
    if (worldTime instanceof Date) {
      return (worldTime.getHours() * 3600 + worldTime.getMinutes() * 60 + worldTime.getSeconds()) / 86400;
    }
    if (typeof worldTime === 'number') {
      if (worldTime > 1000) {
        // Unix ms timestamp
        var d = new Date(worldTime);
        return (d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds()) / 86400;
      }
      // Already a 0-1 fraction
      return worldTime % 1.0;
    }
    return 0.5;
  }

  /**
   * Season string from worldTime
   * @param {number|Date|string} worldTime
   * @param {string} [seasonOverride]
   * @returns {string} 'spring'|'summer'|'autumn'|'winter'
   */
  function resolveSeason(worldTime, seasonOverride) {
    if (seasonOverride && typeof seasonOverride === 'string') {
      return seasonOverride;
    }
    var now = (worldTime instanceof Date) ? worldTime : new Date(typeof worldTime === 'number' && worldTime > 1000 ? worldTime : Date.now());
    var month = now.getMonth(); // 0-11
    if (month >= 2 && month <= 4) return 'spring';
    if (month >= 5 && month <= 7) return 'summer';
    if (month >= 8 && month <= 10) return 'autumn';
    return 'winter';
  }

  // â”€â”€â”€ EXPORTED FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Check whether it is night time (stars visible)
   * Night = before 6:00 or after 20:00 (fraction < 0.25 or > 0.833)
   * @param {number|Date} worldTime
   * @returns {boolean}
   */
  function isNightTime(worldTime) {
    var frac = normalizeWorldTime(worldTime);
    // Night: 0.0 (midnight) to 0.25 (6am) OR 0.833 (8pm) to 1.0 (midnight)
    return frac < 0.25 || frac > 0.833;
  }

  /**
   * Get the current moon phase
   * Returns an object with phase name and fraction (0 = new moon, 0.5 = full moon)
   * @param {number|Date} worldTime
   * @returns {{ phase: string, fraction: number, illumination: number }}
   */
  function getPhaseOfMoon(worldTime) {
    var ts = (worldTime instanceof Date) ? worldTime.getTime() :
             (typeof worldTime === 'number' && worldTime > 1000) ? worldTime :
             Date.now();
    // Lunar cycle â‰ˆ 29.53059 days in ms
    var LUNAR_CYCLE_MS = 29.53059 * 24 * 60 * 60 * 1000;
    // Known new moon reference: Jan 13 2021 05:00 UTC
    var NEW_MOON_REF = 1610517600000;
    var elapsed = ((ts - NEW_MOON_REF) % LUNAR_CYCLE_MS + LUNAR_CYCLE_MS) % LUNAR_CYCLE_MS;
    var fraction = elapsed / LUNAR_CYCLE_MS; // 0=new, 0.5=full

    var phase;
    var illumination;
    if (fraction < 0.0625) {
      phase = 'new_moon'; illumination = 0.0;
    } else if (fraction < 0.1875) {
      phase = 'waxing_crescent'; illumination = fraction * 4;
    } else if (fraction < 0.3125) {
      phase = 'first_quarter'; illumination = 0.5;
    } else if (fraction < 0.4375) {
      phase = 'waxing_gibbous'; illumination = 0.5 + (fraction - 0.25) * 4;
    } else if (fraction < 0.5625) {
      phase = 'full_moon'; illumination = 1.0;
    } else if (fraction < 0.6875) {
      phase = 'waning_gibbous'; illumination = 1.0 - (fraction - 0.5) * 4;
    } else if (fraction < 0.8125) {
      phase = 'last_quarter'; illumination = 0.5;
    } else if (fraction < 0.9375) {
      phase = 'waning_crescent'; illumination = (1.0 - fraction) * 4;
    } else {
      phase = 'new_moon'; illumination = 0.0;
    }

    return { phase: phase, fraction: fraction, illumination: illumination };
  }

  /**
   * Get all stars visible at the current world time and season
   * Returns empty array during daytime
   * @param {number|Date} worldTime
   * @param {string} [season]
   * @returns {Array}
   */
  function getVisibleStars(worldTime, season) {
    if (!isNightTime(worldTime)) {
      return [];
    }
    var frac = normalizeWorldTime(worldTime);
    var resolvedSeason = resolveSeason(worldTime, season);
    // Seasonal visibility offset: shift azimuth by ~90Â° per season
    var seasonOffset = { spring: 0, summer: Math.PI / 2, autumn: Math.PI, winter: 3 * Math.PI / 2 };
    var offset = seasonOffset[resolvedSeason] || 0;
    // At deep night (frac near 0 or 1) all stars visible; near dawn/dusk some fade
    var nightDepth = frac < 0.5 ? 1.0 - frac / 0.25 : (frac - 0.833) / (1.0 - 0.833);
    nightDepth = Math.min(1.0, Math.max(0.0, nightDepth));

    var visible = [];
    for (var i = 0; i < STAR_CATALOG.length; i++) {
      var star = STAR_CATALOG[i];
      // Adjust azimuth by season offset for sky rotation
      var adjustedAzimuth = (star.azimuth + offset) % (Math.PI * 2);
      // Only show stars above horizon (elevation > 0)
      if (star.elevation > 0.05) {
        visible.push({
          id: star.id,
          name: star.name,
          brightness: star.brightness * nightDepth,
          color: star.color,
          azimuth: adjustedAzimuth,
          elevation: star.elevation
        });
      }
    }
    return visible;
  }

  /**
   * Get constellations visible at the given world time + season
   * @param {number|Date} worldTime
   * @param {string} [season]
   * @returns {Array}
   */
  function getVisibleConstellations(worldTime, season) {
    if (!isNightTime(worldTime)) {
      return [];
    }
    var resolvedSeason = resolveSeason(worldTime, season);
    var visible = [];
    for (var id in CONSTELLATION_CATALOG) {
      var c = CONSTELLATION_CATALOG[id];
      // Constellations are always visible at night, but peak in their associated season
      visible.push({
        id: c.id,
        name: c.name,
        stars: c.stars.slice(),
        associated_zone: c.associated_zone,
        bonus_type: c.bonus_type,
        is_peak_season: (c.season_peak === resolvedSeason),
        discovery_difficulty: c.discovery_difficulty
      });
    }
    return visible;
  }

  /**
   * Attempt to identify a constellation from player-selected star indices
   * Uses a matching algorithm based on star set intersection
   * @param {Array<number>} starIndices â€” array of star IDs the player selected
   * @returns {{ matched: boolean, constellationId: string|null, confidence: number }}
   */
  function identifyConstellation(starIndices) {
    if (!starIndices || starIndices.length < 2) {
      return { matched: false, constellationId: null, confidence: 0 };
    }
    var selected = {};
    for (var i = 0; i < starIndices.length; i++) {
      selected[starIndices[i]] = true;
    }
    var bestId = null;
    var bestScore = 0;
    for (var id in CONSTELLATION_CATALOG) {
      var c = CONSTELLATION_CATALOG[id];
      var matches = 0;
      for (var j = 0; j < c.stars.length; j++) {
        if (selected[c.stars[j]]) matches++;
      }
      // Score: intersection / union (Jaccard similarity)
      var union = Object.keys(selected).length + c.stars.length - matches;
      var score = union > 0 ? matches / union : 0;
      if (score > bestScore) {
        bestScore = score;
        bestId = id;
      }
    }
    // Threshold: require at least 50% similarity to count as a match
    var matched = bestScore >= 0.5;
    return {
      matched: matched,
      constellationId: matched ? bestId : null,
      confidence: Math.round(bestScore * 100)
    };
  }

  /**
   * Discover a constellation for a player â€” updates the state object
   * @param {string} playerId
   * @param {string} constellationId
   * @param {Object} state â€” mutable state object with .discoveries map
   * @returns {{ success: boolean, alreadyDiscovered: boolean, sparksEarned: number }}
   */
  function discoverConstellation(playerId, constellationId, state) {
    if (!CONSTELLATION_CATALOG[constellationId]) {
      return { success: false, alreadyDiscovered: false, sparksEarned: 0, error: 'Unknown constellation' };
    }
    if (!state) state = {};
    if (!state.discoveries) state.discoveries = {};
    if (!state.discoveries[playerId]) state.discoveries[playerId] = {};
    if (state.discoveries[playerId][constellationId]) {
      return { success: false, alreadyDiscovered: true, sparksEarned: 0 };
    }
    var c = CONSTELLATION_CATALOG[constellationId];
    var sparksEarned = c.discovery_difficulty * 10;
    state.discoveries[playerId][constellationId] = {
      ts: Date.now(),
      sparksEarned: sparksEarned
    };
    return { success: true, alreadyDiscovered: false, sparksEarned: sparksEarned };
  }

  /**
   * Get all constellations discovered by a player
   * @param {string} playerId
   * @param {Object} state
   * @returns {Array<{ id: string, name: string, ts: number, sparksEarned: number }>}
   */
  function getDiscoveredConstellations(playerId, state) {
    if (!state || !state.discoveries || !state.discoveries[playerId]) {
      return [];
    }
    var result = [];
    var playerDisc = state.discoveries[playerId];
    for (var id in playerDisc) {
      if (CONSTELLATION_CATALOG[id]) {
        result.push({
          id: id,
          name: CONSTELLATION_CATALOG[id].name,
          ts: playerDisc[id].ts,
          sparksEarned: playerDisc[id].sparksEarned
        });
      }
    }
    return result;
  }

  /**
   * Get the lore text for a constellation
   * @param {string} constellationId
   * @returns {string|null}
   */
  function getConstellationLore(constellationId) {
    var c = CONSTELLATION_CATALOG[constellationId];
    return c ? c.lore_text : null;
  }

  /**
   * Get the active zone bonus when a constellation is overhead
   * During peak season the bonus is amplified
   * @param {string} constellationId
   * @param {number|Date} worldTime
   * @returns {{ bonus_type: string, value: number, active: boolean, zone: string }|null}
   */
  function getActiveBonus(constellationId, worldTime) {
    var c = CONSTELLATION_CATALOG[constellationId];
    if (!c) return null;
    var night = isNightTime(worldTime);
    if (!night) return { bonus_type: c.bonus_type, value: 1.0, active: false, zone: c.associated_zone };
    var season = resolveSeason(worldTime);
    var isPeak = (c.season_peak === season);
    var value = isPeak ? c.bonus_value * 1.15 : c.bonus_value;
    return {
      bonus_type: c.bonus_type,
      value: Math.round(value * 100) / 100,
      active: true,
      zone: c.associated_zone,
      is_peak_season: isPeak
    };
  }

  /**
   * Get deterministic celestial events for a given world time + seed
   * @param {number|Date} worldTime
   * @param {number} seed â€” integer seed for determinism
   * @returns {Array<{ event_id: string, active: boolean, time_until_next: number }>}
   */
  function getCelestialEvents(worldTime, seed) {
    var ts = (worldTime instanceof Date) ? worldTime.getTime() :
             (typeof worldTime === 'number' && worldTime > 1000) ? worldTime :
             Date.now();
    var results = [];
    var idx = 0;
    for (var eventId in CELESTIAL_EVENTS) {
      var ev = CELESTIAL_EVENTS[eventId];
      // Determine if event is active using seeded random per hour window
      var hourSlot = Math.floor(ts / (1000 * 60 * 60));
      var r = seededRand(seed + hourSlot + idx * 7919);
      var active = r < ev.rarity;
      // Time until next event (deterministic)
      var nextSlot = hourSlot + Math.ceil(1.0 / ev.rarity * seededRand(seed + idx * 3571));
      results.push({
        event_id: eventId,
        name: ev.name,
        active: active,
        time_until_next: active ? 0 : (nextSlot - hourSlot) * 3600 * 1000
      });
      idx++;
    }
    return results;
  }

  /**
   * Get gameplay effect for a celestial event
   * @param {string} eventId
   * @returns {{ type: string, value: number, duration_minutes: number }|null}
   */
  function getEventEffect(eventId) {
    var ev = CELESTIAL_EVENTS[eventId];
    return ev ? { type: ev.effect.type, value: ev.effect.value, duration_minutes: ev.effect.duration_minutes } : null;
  }

  /**
   * Get star chart visual data for rendering
   * @param {string} playerId
   * @param {Object} state â€” game state with discoveries
   * @returns {{ stars: Array, constellations: Array, discovered: Array, totalConstellations: number }}
   */
  function getStarChart(playerId, state) {
    var discovered = getDiscoveredConstellations(playerId, state);
    var discoveredMap = {};
    for (var i = 0; i < discovered.length; i++) {
      discoveredMap[discovered[i].id] = true;
    }
    var constellations = [];
    for (var id in CONSTELLATION_CATALOG) {
      var c = CONSTELLATION_CATALOG[id];
      constellations.push({
        id: c.id,
        name: c.name,
        stars: c.stars.slice(),
        azimuth_center: c.azimuth_center,
        elevation_center: c.elevation_center,
        discovered: !!discoveredMap[id],
        discovery_difficulty: c.discovery_difficulty
      });
    }
    return {
      stars: STAR_CATALOG.slice(),
      constellations: constellations,
      discovered: discovered,
      totalConstellations: Object.keys(CONSTELLATION_CATALOG).length,
      totalStars: STAR_CATALOG.length
    };
  }

  /**
   * Get the zodiac sign for a player based on their join date
   * @param {Date|string|number} joinDate
   * @returns {{ id: string, name: string, symbol: string, description: string, bonus: Object }|null}
   */
  function getZodiacSign(joinDate) {
    var day = getDayOfYear(joinDate instanceof Date ? joinDate :
               typeof joinDate === 'number' ? new Date(joinDate) :
               new Date(joinDate));
    for (var i = 0; i < ZODIAC_CATALOG.length; i++) {
      var z = ZODIAC_CATALOG[i];
      if (day >= z.day_start && day <= z.day_end) {
        return { id: z.id, name: z.name, symbol: z.symbol, description: z.description, bonus: z.bonus };
      }
    }
    // Fallback to last sign (handles edge cases)
    var last = ZODIAC_CATALOG[ZODIAC_CATALOG.length - 1];
    return { id: last.id, name: last.name, symbol: last.symbol, description: last.description, bonus: last.bonus };
  }

  /**
   * Get the permanent bonus for a zodiac sign
   * @param {string} signId
   * @returns {{ type: string, value: number }|null}
   */
  function getZodiacBonus(signId) {
    for (var i = 0; i < ZODIAC_CATALOG.length; i++) {
      if (ZODIAC_CATALOG[i].id === signId) {
        return ZODIAC_CATALOG[i].bonus;
      }
    }
    return null;
  }

  /**
   * Calculate total XP earned from stargazing activities
   * @param {Array<{ id: string, sparksEarned: number }>} discoveries â€” from getDiscoveredConstellations
   * @returns {{ totalXP: number, breakdown: Object }}
   */
  function getStargazingXP(discoveries) {
    if (!discoveries || !discoveries.length) {
      return { totalXP: 0, breakdown: {} };
    }
    var total = 0;
    var breakdown = {};
    for (var i = 0; i < discoveries.length; i++) {
      var d = discoveries[i];
      var c = CONSTELLATION_CATALOG[d.id];
      if (!c) continue;
      // XP = sparksEarned * difficulty multiplier
      var xp = d.sparksEarned * c.discovery_difficulty;
      breakdown[d.id] = xp;
      total += xp;
    }
    return { totalXP: total, breakdown: breakdown };
  }

  // â”€â”€â”€ EXPORTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  exports.STAR_CATALOG = STAR_CATALOG;
  exports.CONSTELLATION_CATALOG = CONSTELLATION_CATALOG;
  exports.CELESTIAL_EVENTS = CELESTIAL_EVENTS;
  exports.ZODIAC_CATALOG = ZODIAC_CATALOG;
  exports.isNightTime = isNightTime;
  exports.getPhaseOfMoon = getPhaseOfMoon;
  exports.getVisibleStars = getVisibleStars;
  exports.getVisibleConstellations = getVisibleConstellations;
  exports.identifyConstellation = identifyConstellation;
  exports.discoverConstellation = discoverConstellation;
  exports.getDiscoveredConstellations = getDiscoveredConstellations;
  exports.getConstellationLore = getConstellationLore;
  exports.getActiveBonus = getActiveBonus;
  exports.getCelestialEvents = getCelestialEvents;
  exports.getEventEffect = getEventEffect;
  exports.getStarChart = getStarChart;
  exports.getZodiacSign = getZodiacSign;
  exports.getZodiacBonus = getZodiacBonus;
  exports.getStargazingXP = getStargazingXP;

})(typeof module !== 'undefined' ? module.exports : (window.Constellations = {}));


// dungeons.js
// dungeons.js
/**
 * ZION Procedural Dungeon Generator
 * Seeded room graphs with puzzles, enemies, loot.
 * No project dependencies.
 */

(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Seeded pseudo-random number generator (mulberry32)
  // ---------------------------------------------------------------------------

  function createRng(seed) {
    var s = seed >>> 0;
    return function() {
      s += 0x6D2B79F5;
      var t = Math.imul(s ^ (s >>> 15), 1 | s);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) >>> 0;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function hashString(str) {
    var h = 2166136261;
    for (var i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function seedFrom(base, suffix) {
    return hashString(String(base) + '|' + String(suffix));
  }

  function rngInt(rng, min, max) {
    return min + Math.floor(rng() * (max - min + 1));
  }

  function rngPick(rng, arr) {
    return arr[Math.floor(rng() * arr.length)];
  }

  function rngShuffle(rng, arr) {
    var a = arr.slice();
    for (var i = a.length - 1; i > 0; i--) {
      var j = Math.floor(rng() * (i + 1));
      var tmp = a[i]; a[i] = a[j]; a[j] = tmp;
    }
    return a;
  }

  // ---------------------------------------------------------------------------
  // Constants
  // ---------------------------------------------------------------------------

  var ROOM_TYPES = {
    entrance:     'entrance',
    corridor:     'corridor',
    chamber:      'chamber',
    treasure_room:'treasure_room',
    boss_room:    'boss_room',
    puzzle_room:  'puzzle_room',
    trap_room:    'trap_room',
    rest_area:    'rest_area',
    secret_room:  'secret_room'
  };

  var PUZZLE_TYPES = {
    lever_sequence:  'lever_sequence',
    pressure_plates: 'pressure_plates',
    riddle:          'riddle',
    pattern_match:   'pattern_match',
    light_bridge:    'light_bridge',
    crystal_align:   'crystal_align'
  };

  var ENEMY_TYPES = {
    shadow_wisp: {
      id: 'shadow_wisp',
      name: 'Shadow Wisp',
      hp: 20,
      maxHp: 20,
      attack: 4,
      defense: 1,
      speed: 8,
      xp: 15,
      tier: 'common'
    },
    stone_guardian: {
      id: 'stone_guardian',
      name: 'Stone Guardian',
      hp: 60,
      maxHp: 60,
      attack: 8,
      defense: 6,
      speed: 3,
      xp: 40,
      tier: 'uncommon'
    },
    crystal_spider: {
      id: 'crystal_spider',
      name: 'Crystal Spider',
      hp: 35,
      maxHp: 35,
      attack: 6,
      defense: 3,
      speed: 7,
      xp: 25,
      tier: 'common'
    },
    void_walker: {
      id: 'void_walker',
      name: 'Void Walker',
      hp: 80,
      maxHp: 80,
      attack: 12,
      defense: 4,
      speed: 6,
      xp: 65,
      tier: 'rare'
    },
    ancient_sentinel: {
      id: 'ancient_sentinel',
      name: 'Ancient Sentinel',
      hp: 200,
      maxHp: 200,
      attack: 20,
      defense: 12,
      speed: 4,
      xp: 150,
      tier: 'boss'
    }
  };

  var LOOT_TABLES = {
    common: {
      tier: 'common',
      items: [
        { id: 'health_potion',    name: 'Health Potion',    type: 'consumable', value: 10, effect: { heal: 30 } },
        { id: 'torch',            name: 'Torch',            type: 'tool',       value: 5,  effect: { light: 10 } },
        { id: 'iron_key',         name: 'Iron Key',         type: 'key',        value: 15, effect: {} },
        { id: 'leather_gloves',   name: 'Leather Gloves',   type: 'armor',      value: 20, effect: { defense: 1 } },
        { id: 'short_sword',      name: 'Short Sword',      type: 'weapon',     value: 25, effect: { attack: 3 } }
      ]
    },
    uncommon: {
      tier: 'uncommon',
      items: [
        { id: 'mana_potion',      name: 'Mana Potion',      type: 'consumable', value: 30, effect: { mana: 50 } },
        { id: 'silver_ring',      name: 'Silver Ring',      type: 'accessory',  value: 50, effect: { luck: 5 } },
        { id: 'chain_mail',       name: 'Chain Mail',       type: 'armor',      value: 80, effect: { defense: 4 } },
        { id: 'enchanted_blade',  name: 'Enchanted Blade',  type: 'weapon',     value: 90, effect: { attack: 7 } },
        { id: 'map_fragment',     name: 'Map Fragment',     type: 'quest',      value: 40, effect: {} }
      ]
    },
    rare: {
      tier: 'rare',
      items: [
        { id: 'elixir_of_might',  name: 'Elixir of Might',  type: 'consumable', value: 120, effect: { attack_bonus: 10, duration: 60 } },
        { id: 'shadow_cloak',     name: 'Shadow Cloak',     type: 'armor',      value: 200, effect: { defense: 8, stealth: 15 } },
        { id: 'crystal_staff',    name: 'Crystal Staff',    type: 'weapon',     value: 250, effect: { attack: 12, magic: 20 } },
        { id: 'void_amulet',      name: 'Void Amulet',      type: 'accessory',  value: 180, effect: { hp_max: 50, magic_resist: 10 } },
        { id: 'ancient_tome',     name: 'Ancient Tome',     type: 'quest',      value: 150, effect: { spell_unlock: true } }
      ]
    },
    epic: {
      tier: 'epic',
      items: [
        { id: 'dragonhide_armor', name: 'Dragonhide Armor', type: 'armor',      value: 600, effect: { defense: 18, fire_resist: 30 } },
        { id: 'soul_blade',       name: 'Soul Blade',       type: 'weapon',     value: 700, effect: { attack: 22, life_steal: 10 } },
        { id: 'ring_of_power',    name: 'Ring of Power',    type: 'accessory',  value: 500, effect: { all_stats: 10 } },
        { id: 'phoenix_feather',  name: 'Phoenix Feather',  type: 'consumable', value: 400, effect: { revive: true, heal: 100 } },
        { id: 'arcane_codex',     name: 'Arcane Codex',     type: 'quest',      value: 450, effect: { all_spells: true } }
      ]
    },
    legendary: {
      tier: 'legendary',
      items: [
        { id: 'crown_of_eternity', name: 'Crown of Eternity', type: 'accessory',  value: 2000, effect: { all_stats: 25, immortality: 30 } },
        { id: 'void_reaper',       name: 'Void Reaper',       type: 'weapon',     value: 2500, effect: { attack: 40, void_damage: 20 } },
        { id: 'titan_aegis',       name: 'Titan Aegis',       type: 'armor',      value: 2200, effect: { defense: 35, reflect: 15 } },
        { id: 'time_crystal',      name: 'Time Crystal',      type: 'quest',      value: 3000, effect: { time_control: true } },
        { id: 'world_shard',       name: 'World Shard',       type: 'quest',      value: 5000, effect: { world_power: true } }
      ]
    }
  };

  var DIFFICULTY_LEVELS = {
    novice: {
      id: 'novice',
      label: 'Novice',
      enemyHpMult: 0.6,
      enemyAtkMult: 0.6,
      lootMult: 1.2,
      puzzleComplexity: 0.3,
      trapDamage: 5,
      bossHpMult: 0.5,
      xpMult: 0.7
    },
    adventurer: {
      id: 'adventurer',
      label: 'Adventurer',
      enemyHpMult: 1.0,
      enemyAtkMult: 1.0,
      lootMult: 1.0,
      puzzleComplexity: 0.5,
      trapDamage: 15,
      bossHpMult: 1.0,
      xpMult: 1.0
    },
    hero: {
      id: 'hero',
      label: 'Hero',
      enemyHpMult: 1.5,
      enemyAtkMult: 1.4,
      lootMult: 0.9,
      puzzleComplexity: 0.75,
      trapDamage: 30,
      bossHpMult: 1.5,
      xpMult: 1.5
    },
    legend: {
      id: 'legend',
      label: 'Legend',
      enemyHpMult: 2.5,
      enemyAtkMult: 2.0,
      lootMult: 0.8,
      puzzleComplexity: 1.0,
      trapDamage: 50,
      bossHpMult: 2.5,
      xpMult: 2.5
    }
  };

  var DUNGEON_SIZES = {
    small:  { id: 'small',  label: 'Small',  minRooms: 5,  maxRooms: 8  },
    medium: { id: 'medium', label: 'Medium', minRooms: 10, maxRooms: 15 },
    large:  { id: 'large',  label: 'Large',  minRooms: 18, maxRooms: 25 },
    epic:   { id: 'epic',   label: 'Epic',   minRooms: 30, maxRooms: 40 }
  };

  // ---------------------------------------------------------------------------
  // Room type distribution helpers
  // ---------------------------------------------------------------------------

  function getRoomTypeDistribution(totalRooms) {
    var distribution = [];
    // always start with entrance
    distribution.push(ROOM_TYPES.entrance);
    // always end with boss
    distribution.push(ROOM_TYPES.boss_room);

    var remaining = totalRooms - 2;
    // mandatory: at least 1 treasure_room, 1 puzzle_room
    distribution.push(ROOM_TYPES.treasure_room);
    distribution.push(ROOM_TYPES.puzzle_room);
    remaining -= 2;

    // rest: fill with corridors, chambers, trap_rooms, rest_areas, secret_rooms
    var fillers = [
      ROOM_TYPES.corridor,
      ROOM_TYPES.chamber,
      ROOM_TYPES.trap_room,
      ROOM_TYPES.rest_area
    ];

    // add a few secret rooms for larger dungeons
    if (totalRooms >= 10) {
      distribution.push(ROOM_TYPES.secret_room);
      remaining -= 1;
    }
    if (totalRooms >= 18) {
      distribution.push(ROOM_TYPES.secret_room);
      distribution.push(ROOM_TYPES.puzzle_room);
      remaining -= 2;
    }
    if (totalRooms >= 30) {
      distribution.push(ROOM_TYPES.treasure_room);
      distribution.push(ROOM_TYPES.trap_room);
      remaining -= 2;
    }

    // fill rest
    for (var i = 0; i < remaining; i++) {
      distribution.push(fillers[i % fillers.length]);
    }

    return distribution;
  }

  // ---------------------------------------------------------------------------
  // Puzzle generation
  // ---------------------------------------------------------------------------

  var RIDDLES = [
    { question: 'I have cities, but no houses live there. I have mountains, but no trees grow. I have water, but no fish swim. What am I?', answer: 'map' },
    { question: 'The more you take, the more you leave behind. What am I?', answer: 'footsteps' },
    { question: 'I speak without a mouth and hear without ears. I have no body, but I come alive with the wind. What am I?', answer: 'echo' },
    { question: 'I have a head and a tail but no body. What am I?', answer: 'coin' },
    { question: 'I can fly without wings. I can cry without eyes. Wherever I go, darkness flies. What am I?', answer: 'cloud' }
  ];

  function generatePuzzle(seed, type) {
    var rng = createRng(seedFrom(seed, type));
    var puzzle = {
      id: 'puzzle_' + seed + '_' + type,
      type: type,
      solved: false,
      attempts: 0
    };

    switch (type) {
      case PUZZLE_TYPES.lever_sequence: {
        var levers = rngInt(rng, 3, 6);
        var sequence = [];
        for (var i = 0; i < levers; i++) {
          sequence.push(rngInt(rng, 0, levers - 1));
        }
        puzzle.description = 'Pull the levers in the correct sequence to unlock the door.';
        puzzle.levers = levers;
        puzzle.solution = sequence;
        puzzle.hint = 'The markings on the floor may reveal the order.';
        break;
      }
      case PUZZLE_TYPES.pressure_plates: {
        var plates = rngInt(rng, 4, 8);
        var activeSet = [];
        var seen = {};
        while (activeSet.length < Math.ceil(plates / 2)) {
          var p = rngInt(rng, 0, plates - 1);
          if (!seen[p]) { seen[p] = true; activeSet.push(p); }
        }
        activeSet.sort(function(a, b) { return a - b; });
        puzzle.description = 'Step on the correct pressure plates simultaneously to open the gate.';
        puzzle.plates = plates;
        puzzle.solution = activeSet;
        puzzle.hint = 'The worn tiles mark the path of those who came before.';
        break;
      }
      case PUZZLE_TYPES.riddle: {
        var riddle = rngPick(rng, RIDDLES);
        puzzle.description = riddle.question;
        puzzle.question = riddle.question;
        puzzle.solution = riddle.answer;
        puzzle.hint = 'Think about what surrounds you in this dungeon.';
        break;
      }
      case PUZZLE_TYPES.pattern_match: {
        var size = rngInt(rng, 3, 5);
        var pattern = [];
        for (var pi = 0; pi < size; pi++) {
          pattern.push(rngInt(rng, 1, 4));
        }
        puzzle.description = 'Reproduce the glowing pattern on the arcane panel.';
        puzzle.size = size;
        puzzle.solution = pattern;
        puzzle.hint = 'Watch the pattern carefully â€” it flashes once.';
        break;
      }
      case PUZZLE_TYPES.light_bridge: {
        var segments = rngInt(rng, 4, 7);
        var bridgePath = [];
        for (var bi = 0; bi < segments; bi++) {
          bridgePath.push(rngInt(rng, 0, 2)); // 0=left, 1=forward, 2=right
        }
        puzzle.description = 'Activate the crystal prisms to extend the light bridge.';
        puzzle.segments = segments;
        puzzle.solution = bridgePath;
        puzzle.hint = 'Follow the faint glow on the ground.';
        break;
      }
      case PUZZLE_TYPES.crystal_align: {
        var crystals = rngInt(rng, 3, 6);
        var angles = [];
        var validAngles = [0, 45, 90, 135, 180, 225, 270, 315];
        for (var ci = 0; ci < crystals; ci++) {
          angles.push(rngPick(rng, validAngles));
        }
        puzzle.description = 'Rotate the crystals to align their beams toward the central focus.';
        puzzle.crystals = crystals;
        puzzle.solution = angles;
        puzzle.hint = 'Ancient inscriptions show the correct angles.';
        break;
      }
      default: {
        puzzle.description = 'Solve the ancient puzzle.';
        puzzle.solution = [1, 2, 3];
        puzzle.hint = 'Look around for clues.';
      }
    }

    return puzzle;
  }

  function solvePuzzle(puzzle, attempt) {
    if (!puzzle || !puzzle.solution) {
      return { success: false, message: 'Invalid puzzle' };
    }

    puzzle.attempts = (puzzle.attempts || 0) + 1;

    var sol = puzzle.solution;
    var correct = false;

    if (puzzle.type === PUZZLE_TYPES.riddle) {
      // case-insensitive string compare
      correct = typeof attempt === 'string' &&
                attempt.trim().toLowerCase() === String(sol).toLowerCase();
    } else if (Array.isArray(sol) && Array.isArray(attempt)) {
      if (sol.length !== attempt.length) {
        correct = false;
      } else {
        correct = true;
        for (var i = 0; i < sol.length; i++) {
          if (sol[i] !== attempt[i]) { correct = false; break; }
        }
      }
    } else {
      correct = attempt === sol;
    }

    if (correct) {
      puzzle.solved = true;
      return { success: true, message: 'Puzzle solved!', xpReward: 50 + puzzle.attempts * 5 };
    }

    var msg = 'Incorrect. ';
    if (puzzle.attempts >= 3) {
      msg += 'Hint: ' + puzzle.hint;
    } else {
      msg += 'Try again.';
    }
    return { success: false, message: msg, attempts: puzzle.attempts };
  }

  // ---------------------------------------------------------------------------
  // Enemy encounter generation
  // ---------------------------------------------------------------------------

  function scaleEnemy(base, difficultyConfig) {
    var scaled = {};
    for (var k in base) { scaled[k] = base[k]; }
    scaled.hp = Math.round(base.hp * difficultyConfig.enemyHpMult);
    scaled.maxHp = scaled.hp;
    scaled.attack = Math.round(base.attack * difficultyConfig.enemyAtkMult);
    if (base.tier === 'boss') {
      scaled.hp = Math.round(base.hp * difficultyConfig.bossHpMult);
      scaled.maxHp = scaled.hp;
    }
    return scaled;
  }

  function generateEnemyEncounter(seed, difficulty, roomType) {
    var rng = createRng(seedFrom(seed, difficulty + '_' + roomType));
    var diffCfg = DIFFICULTY_LEVELS[difficulty] || DIFFICULTY_LEVELS.adventurer;

    var enemyKeys = Object.keys(ENEMY_TYPES);
    var encounter = {
      seed: seed,
      difficulty: difficulty,
      roomType: roomType,
      enemies: [],
      totalXp: 0,
      isBossEncounter: false
    };

    if (roomType === ROOM_TYPES.boss_room) {
      encounter.isBossEncounter = true;
      var boss = scaleEnemy(ENEMY_TYPES.ancient_sentinel, diffCfg);
      boss.instanceId = 'enemy_' + seed + '_0';
      encounter.enemies.push(boss);
      encounter.totalXp += Math.round(boss.xp * diffCfg.xpMult);
      // add a couple of minions
      var minionCount = rngInt(rng, 1, 3);
      for (var mi = 0; mi < minionCount; mi++) {
        var minionKey = rngPick(rng, ['shadow_wisp', 'crystal_spider']);
        var minion = scaleEnemy(ENEMY_TYPES[minionKey], diffCfg);
        minion.instanceId = 'enemy_' + seed + '_minion_' + mi;
        encounter.enemies.push(minion);
        encounter.totalXp += Math.round(minion.xp * diffCfg.xpMult);
      }
      return encounter;
    }

    if (roomType === ROOM_TYPES.entrance || roomType === ROOM_TYPES.rest_area) {
      // no enemies at entrance / rest area
      return encounter;
    }

    if (roomType === ROOM_TYPES.corridor) {
      var cCount = rngInt(rng, 0, 2);
      for (var ci = 0; ci < cCount; ci++) {
        var cKey = rngPick(rng, ['shadow_wisp', 'crystal_spider']);
        var ce = scaleEnemy(ENEMY_TYPES[cKey], diffCfg);
        ce.instanceId = 'enemy_' + seed + '_' + ci;
        encounter.enemies.push(ce);
        encounter.totalXp += Math.round(ce.xp * diffCfg.xpMult);
      }
      return encounter;
    }

    // general rooms: 1-4 enemies scaled to difficulty
    var maxCount = roomType === ROOM_TYPES.chamber ? 4 : 3;
    var count = rngInt(rng, 1, maxCount);
    for (var ei = 0; ei < count; ei++) {
      var eligibleKeys;
      if (difficulty === 'novice') {
        eligibleKeys = ['shadow_wisp', 'crystal_spider'];
      } else if (difficulty === 'adventurer') {
        eligibleKeys = ['shadow_wisp', 'crystal_spider', 'stone_guardian'];
      } else if (difficulty === 'hero') {
        eligibleKeys = ['crystal_spider', 'stone_guardian', 'void_walker'];
      } else {
        eligibleKeys = enemyKeys.filter(function(k) { return ENEMY_TYPES[k].tier !== 'boss'; });
      }
      var eKey = rngPick(rng, eligibleKeys);
      var enemy = scaleEnemy(ENEMY_TYPES[eKey], diffCfg);
      enemy.instanceId = 'enemy_' + seed + '_' + ei;
      encounter.enemies.push(enemy);
      encounter.totalXp += Math.round(enemy.xp * diffCfg.xpMult);
    }

    return encounter;
  }

  // ---------------------------------------------------------------------------
  // Combat resolution
  // ---------------------------------------------------------------------------

  function calculateCombatOutcome(playerStats, enemies) {
    if (!playerStats || !enemies || enemies.length === 0) {
      return { victory: true, survived: true, rounds: 0, damageDealt: 0, damageTaken: 0, xpGained: 0 };
    }

    var pHp = playerStats.hp || 100;
    var pAtk = playerStats.attack || 10;
    var pDef = playerStats.defense || 5;
    var pSpd = playerStats.speed || 5;

    var enemyPool = enemies.map(function(e) {
      return { id: e.instanceId || e.id, hp: e.hp, attack: e.attack, defense: e.defense, speed: e.speed || 5, xp: e.xp };
    });

    var rounds = 0;
    var damageDealt = 0;
    var damageTaken = 0;
    var xpGained = 0;

    while (pHp > 0 && enemyPool.length > 0) {
      rounds++;
      if (rounds > 200) break; // safety cap

      // Player attacks first enemy
      var target = enemyPool[0];
      var playerDmg = Math.max(1, pAtk - target.defense);
      target.hp -= playerDmg;
      damageDealt += playerDmg;

      if (target.hp <= 0) {
        xpGained += target.xp;
        enemyPool.shift();
        continue;
      }

      // Each remaining enemy attacks player
      for (var ei = 0; ei < enemyPool.length; ei++) {
        var e = enemyPool[ei];
        var enemyDmg = Math.max(1, e.attack - pDef);
        // speed factor: faster enemy deals slightly more
        var spdBonus = Math.max(0, e.speed - pSpd) * 0.5;
        enemyDmg = Math.round(enemyDmg + spdBonus);
        pHp -= enemyDmg;
        damageTaken += enemyDmg;
        if (pHp <= 0) break;
      }
    }

    return {
      victory: enemyPool.length === 0 && pHp > 0,
      survived: pHp > 0,
      playerHpRemaining: Math.max(0, pHp),
      rounds: rounds,
      damageDealt: damageDealt,
      damageTaken: damageTaken,
      xpGained: enemyPool.length === 0 ? xpGained : 0
    };
  }

  // ---------------------------------------------------------------------------
  // Loot
  // ---------------------------------------------------------------------------

  function getLootDrop(seed, difficulty, tier) {
    // Item selection uses only seed+tier so same item is picked regardless of difficulty
    var rng = createRng(seedFrom(seed, tier));
    var table = LOOT_TABLES[tier];
    if (!table) {
      table = LOOT_TABLES.common;
    }

    var diffCfg = DIFFICULTY_LEVELS[difficulty] || DIFFICULTY_LEVELS.adventurer;
    var item = rngPick(rng, table.items);

    // Make a copy with scaled value
    var loot = {};
    for (var k in item) { loot[k] = item[k]; }
    loot.value = Math.round(item.value * diffCfg.lootMult);
    loot.instanceId = 'loot_' + seed + '_' + tier;
    loot.tier = tier;

    return loot;
  }

  function determineLootTier(rng, difficulty) {
    var roll = rng();
    if (difficulty === 'novice') {
      if (roll < 0.60) return 'common';
      if (roll < 0.85) return 'uncommon';
      if (roll < 0.97) return 'rare';
      return 'epic';
    }
    if (difficulty === 'adventurer') {
      if (roll < 0.45) return 'common';
      if (roll < 0.75) return 'uncommon';
      if (roll < 0.93) return 'rare';
      if (roll < 0.99) return 'epic';
      return 'legendary';
    }
    if (difficulty === 'hero') {
      if (roll < 0.30) return 'common';
      if (roll < 0.60) return 'uncommon';
      if (roll < 0.85) return 'rare';
      if (roll < 0.97) return 'epic';
      return 'legendary';
    }
    // legend
    if (roll < 0.20) return 'common';
    if (roll < 0.45) return 'uncommon';
    if (roll < 0.70) return 'rare';
    if (roll < 0.90) return 'epic';
    return 'legendary';
  }

  // ---------------------------------------------------------------------------
  // Room generation
  // ---------------------------------------------------------------------------

  function generateRoom(seed, type, difficulty) {
    var rng = createRng(seedFrom(seed, type));
    var diffCfg = DIFFICULTY_LEVELS[difficulty] || DIFFICULTY_LEVELS.adventurer;

    var room = {
      id: 'room_' + seed,
      seed: seed,
      type: type,
      difficulty: difficulty,
      description: '',
      width: 0,
      height: 0,
      enemies: [],
      puzzle: null,
      loot: [],
      traps: [],
      connections: [],
      explored: false,
      cleared: false,
      isSecret: type === ROOM_TYPES.secret_room
    };

    // Dimensions
    switch (type) {
      case ROOM_TYPES.corridor:
        room.width = rngInt(rng, 3, 5);
        room.height = rngInt(rng, 8, 15);
        break;
      case ROOM_TYPES.boss_room:
        room.width = rngInt(rng, 20, 30);
        room.height = rngInt(rng, 20, 30);
        break;
      case ROOM_TYPES.entrance:
        room.width = rngInt(rng, 10, 14);
        room.height = rngInt(rng, 10, 14);
        break;
      default:
        room.width = rngInt(rng, 8, 18);
        room.height = rngInt(rng, 8, 18);
    }

    // Description
    var descriptions = {
      entrance:     'The dungeon entrance, torch brackets flicker with dying flames.',
      corridor:     'A narrow passage with worn stone walls and scattered debris.',
      chamber:      'A large vaulted chamber. Ancient carvings line the walls.',
      treasure_room:'A room glittering with hoarded wealth, locked chests in every corner.',
      boss_room:    'A massive hall. The air itself trembles with menacing power.',
      puzzle_room:  'Strange mechanisms cover the walls. Arcane symbols pulse with energy.',
      trap_room:    'The floor is suspiciously clean. Pressure plate outlines are barely visible.',
      rest_area:    'A sheltered alcove with a crumbling stone bench and dying embers.',
      secret_room:  'A hidden chamber behind a false wall. Dust undisturbed for centuries.'
    };
    room.description = descriptions[type] || 'A dungeon room.';

    // Enemies
    var encounter = generateEnemyEncounter(seed, difficulty, type);
    room.enemies = encounter.enemies;
    room.totalXp = encounter.totalXp;

    // Puzzle
    if (type === ROOM_TYPES.puzzle_room) {
      var puzzleTypes = Object.values(PUZZLE_TYPES);
      var pType = rngPick(rng, puzzleTypes);
      room.puzzle = generatePuzzle(seedFrom(seed, 'puzzle'), pType);
    }

    // Loot
    if (type === ROOM_TYPES.treasure_room || type === ROOM_TYPES.boss_room || type === ROOM_TYPES.secret_room) {
      var lootCount = rngInt(rng, 2, 5);
      for (var li = 0; li < lootCount; li++) {
        var tier = determineLootTier(rng, difficulty);
        if (type === ROOM_TYPES.boss_room) {
          // boss always drops at least rare
          if (tier === 'common' || tier === 'uncommon') tier = 'rare';
        }
        if (type === ROOM_TYPES.secret_room) {
          // secret rooms get better loot
          if (tier === 'common') tier = 'uncommon';
        }
        room.loot.push(getLootDrop(seedFrom(seed, 'loot_' + li), difficulty, tier));
      }
    } else if (type !== ROOM_TYPES.entrance) {
      // small chance of loot in other rooms
      if (rng() < 0.3) {
        var basicTier = determineLootTier(rng, difficulty);
        room.loot.push(getLootDrop(seedFrom(seed, 'loot_0'), difficulty, basicTier));
      }
    }

    // Traps
    if (type === ROOM_TYPES.trap_room) {
      var trapTypes = ['spike_pit', 'poison_dart', 'falling_ceiling', 'fire_jet', 'arcane_glyph'];
      var trapCount = rngInt(rng, 2, 4);
      for (var ti = 0; ti < trapCount; ti++) {
        room.traps.push({
          id: 'trap_' + seed + '_' + ti,
          type: rngPick(rng, trapTypes),
          damage: diffCfg.trapDamage,
          triggered: false,
          detectionDifficulty: rngInt(rng, 1, 10)
        });
      }
    } else if (type === ROOM_TYPES.corridor && rng() < 0.25) {
      room.traps.push({
        id: 'trap_' + seed + '_0',
        type: 'pressure_plate_dart',
        damage: Math.round(diffCfg.trapDamage * 0.5),
        triggered: false,
        detectionDifficulty: rngInt(rng, 1, 6)
      });
    }

    return room;
  }

  // ---------------------------------------------------------------------------
  // Room graph generation (DAG with cycles)
  // ---------------------------------------------------------------------------

  function generateRoomGraph(seed, roomCount) {
    var rng = createRng(seedFrom(seed, 'graph'));

    var rooms = [];
    for (var i = 0; i < roomCount; i++) {
      rooms.push({
        id: i,
        connections: [],
        visited: false
      });
    }

    // Build a spanning tree (so all rooms are reachable)
    // Add entrance â†’ boss path first
    for (var i = 1; i < roomCount; i++) {
      var parent = rngInt(rng, 0, i - 1);
      rooms[i].connections.push(parent);
      rooms[parent].connections.push(i);
    }

    // Add extra edges for cycles (approximately 20% of roomCount additional edges)
    var extraEdges = Math.max(1, Math.floor(roomCount * 0.2));
    for (var e = 0; e < extraEdges; e++) {
      var a = rngInt(rng, 0, roomCount - 1);
      var b = rngInt(rng, 0, roomCount - 1);
      if (a !== b && rooms[a].connections.indexOf(b) === -1) {
        rooms[a].connections.push(b);
        rooms[b].connections.push(a);
      }
    }

    return {
      rooms: rooms,
      roomCount: roomCount,
      entranceId: 0,
      bossRoomId: roomCount - 1
    };
  }

  // ---------------------------------------------------------------------------
  // Pathfinding (BFS shortest path)
  // ---------------------------------------------------------------------------

  function getShortestPath(dungeon, fromRoom, toRoom) {
    if (!dungeon || !dungeon.rooms) return null;
    if (fromRoom === toRoom) return [fromRoom];

    var rooms = dungeon.rooms;
    var visited = {};
    var parent = {};
    var queue = [fromRoom];
    visited[fromRoom] = true;

    while (queue.length > 0) {
      var current = queue.shift();
      var room = rooms[current];
      if (!room) continue;

      var neighbors;
      // handle both generateRoomGraph format and generateDungeon format
      if (room.connections && Array.isArray(room.connections)) {
        neighbors = room.connections;
      } else {
        neighbors = [];
      }

      for (var ni = 0; ni < neighbors.length; ni++) {
        var neighbor = neighbors[ni];
        var nId = typeof neighbor === 'object' ? neighbor.id : neighbor;
        if (!visited[nId]) {
          visited[nId] = true;
          parent[nId] = current;
          if (nId === toRoom) {
            // reconstruct path
            var path = [toRoom];
            var node = toRoom;
            while (node !== fromRoom) {
              node = parent[node];
              path.unshift(node);
            }
            return path;
          }
          queue.push(nId);
        }
      }
    }

    return null; // no path found
  }

  // ---------------------------------------------------------------------------
  // Fog of war
  // ---------------------------------------------------------------------------

  function revealMap(dungeon, exploredRooms) {
    if (!dungeon || !dungeon.rooms) return dungeon;

    var exploredSet = {};
    for (var i = 0; i < exploredRooms.length; i++) {
      exploredSet[exploredRooms[i]] = true;
    }

    var visibleRooms = [];
    var hiddenRooms = [];

    for (var ri = 0; ri < dungeon.rooms.length; ri++) {
      var room = dungeon.rooms[ri];
      var isVisible = !!exploredSet[room.id];

      // also reveal rooms adjacent to explored rooms (line of sight)
      if (!isVisible && room.connections) {
        for (var ci = 0; ci < room.connections.length; ci++) {
          var neighborId = typeof room.connections[ci] === 'object'
            ? room.connections[ci].id
            : room.connections[ci];
          if (exploredSet[neighborId]) {
            isVisible = true;
            break;
          }
        }
      }

      // secret rooms only revealed if directly explored
      if (room.isSecret) {
        isVisible = !!exploredSet[room.id];
      }

      if (isVisible) {
        visibleRooms.push(room.id);
      } else {
        hiddenRooms.push(room.id);
      }
    }

    return {
      visibleRooms: visibleRooms,
      hiddenRooms: hiddenRooms,
      exploredRooms: exploredRooms.slice(),
      totalRooms: dungeon.rooms.length,
      revealedCount: visibleRooms.length
    };
  }

  // ---------------------------------------------------------------------------
  // Full dungeon generation
  // ---------------------------------------------------------------------------

  function generateDungeon(seed, difficulty, size) {
    var sizeConfig = DUNGEON_SIZES[size] || DUNGEON_SIZES.medium;
    var diffConfig = DIFFICULTY_LEVELS[difficulty] || DIFFICULTY_LEVELS.adventurer;
    var rng = createRng(seedFrom(seed, difficulty + '_' + size));

    var roomCount = rngInt(rng, sizeConfig.minRooms, sizeConfig.maxRooms);
    var typeDistribution = getRoomTypeDistribution(roomCount);
    // shuffle middle rooms (keep entrance at index 0, boss_room at last index)
    var shuffleRng = createRng(seedFrom(seed, 'type_shuffle'));
    // Filter out entrance and boss_room to shuffle everything else
    var middle = typeDistribution.filter(function(t) {
      return t !== ROOM_TYPES.entrance && t !== ROOM_TYPES.boss_room;
    });
    middle = rngShuffle(shuffleRng, middle);
    var shuffledTypes = [ROOM_TYPES.entrance].concat(middle).concat([ROOM_TYPES.boss_room]);

    // Generate graph structure
    var graph = generateRoomGraph(seedFrom(seed, 'graph'), roomCount);

    // Generate each room with content
    var rooms = [];
    for (var ri = 0; ri < roomCount; ri++) {
      var rType = shuffledTypes[ri] || ROOM_TYPES.corridor;
      var roomSeed = seedFrom(seed, 'room_' + ri);
      var room = generateRoom(roomSeed, rType, difficulty);
      room.id = ri;
      // carry over connections from graph
      room.connections = graph.rooms[ri].connections;
      rooms.push(room);
    }

    var dungeon = {
      seed: seed,
      difficulty: difficulty,
      difficultyConfig: diffConfig,
      size: size,
      sizeConfig: sizeConfig,
      roomCount: roomCount,
      rooms: rooms,
      entranceId: 0,
      bossRoomId: roomCount - 1,
      createdAt: Date.now(),
      completed: false,
      exploredRooms: [],
      clearedRooms: []
    };

    return dungeon;
  }

  // ---------------------------------------------------------------------------
  // Scoring
  // ---------------------------------------------------------------------------

  function getDungeonScore(dungeon, completion) {
    if (!dungeon) return 0;

    var diffMultipliers = {
      novice: 1.0,
      adventurer: 1.5,
      hero: 2.5,
      legend: 4.0
    };

    var diffMult = diffMultipliers[dungeon.difficulty] || 1.0;
    var comp = completion || {};

    var roomsCleared = comp.roomsCleared || 0;
    var puzzlesSolved = comp.puzzlesSolved || 0;
    var lootFound = comp.lootFound || 0;
    var bossDefeated = comp.bossDefeated ? 1 : 0;
    var secretsFound = comp.secretsFound || 0;
    var deathCount = comp.deaths || 0;
    var timeBonus = comp.timeBonus || 0;

    var baseScore = 0;
    baseScore += roomsCleared * 100;
    baseScore += puzzlesSolved * 200;
    baseScore += lootFound * 50;
    baseScore += bossDefeated * 1000;
    baseScore += secretsFound * 300;
    baseScore -= deathCount * 150;
    baseScore += timeBonus;

    var finalScore = Math.max(0, Math.round(baseScore * diffMult));

    return {
      baseScore: baseScore,
      difficultyMultiplier: diffMult,
      finalScore: finalScore,
      breakdown: {
        roomsCleared: roomsCleared * 100,
        puzzlesSolved: puzzlesSolved * 200,
        lootFound: lootFound * 50,
        bossDefeated: bossDefeated * 1000,
        secretsFound: secretsFound * 300,
        deathPenalty: deathCount * -150,
        timeBonus: timeBonus
      }
    };
  }

  // ---------------------------------------------------------------------------
  // Dungeon summary
  // ---------------------------------------------------------------------------

  function getDungeonSummary(dungeon) {
    if (!dungeon || !dungeon.rooms) {
      return null;
    }

    var summary = {
      seed: dungeon.seed,
      difficulty: dungeon.difficulty,
      size: dungeon.size,
      roomCount: dungeon.roomCount,
      roomsByType: {},
      totalEnemies: 0,
      totalLoot: 0,
      totalPuzzles: 0,
      totalTraps: 0,
      bossRoom: null,
      estimatedTimeMinutes: 0,
      hasBoss: false,
      secretRoomCount: 0
    };

    // Initialize room type counters
    for (var rType in ROOM_TYPES) {
      summary.roomsByType[rType] = 0;
    }

    for (var ri = 0; ri < dungeon.rooms.length; ri++) {
      var room = dungeon.rooms[ri];
      var rkey = room.type;

      if (summary.roomsByType[rkey] !== undefined) {
        summary.roomsByType[rkey]++;
      }

      summary.totalEnemies += room.enemies ? room.enemies.length : 0;
      summary.totalLoot += room.loot ? room.loot.length : 0;
      summary.totalPuzzles += room.puzzle ? 1 : 0;
      summary.totalTraps += room.traps ? room.traps.length : 0;

      if (room.type === ROOM_TYPES.secret_room) {
        summary.secretRoomCount++;
      }

      if (room.type === ROOM_TYPES.boss_room) {
        summary.hasBoss = true;
        summary.bossRoom = { id: room.id, enemyCount: room.enemies ? room.enemies.length : 0 };
      }
    }

    // Rough time estimate: 3 min/room base + 2 min/puzzle + 1 min/enemy
    summary.estimatedTimeMinutes = dungeon.roomCount * 3 + summary.totalPuzzles * 2 + summary.totalEnemies;

    return summary;
  }

  // ---------------------------------------------------------------------------
  // Exports
  // ---------------------------------------------------------------------------

  exports.ROOM_TYPES = ROOM_TYPES;
  exports.PUZZLE_TYPES = PUZZLE_TYPES;
  exports.ENEMY_TYPES = ENEMY_TYPES;
  exports.LOOT_TABLES = LOOT_TABLES;
  exports.DIFFICULTY_LEVELS = DIFFICULTY_LEVELS;
  exports.DUNGEON_SIZES = DUNGEON_SIZES;

  exports.generateDungeon = generateDungeon;
  exports.generateRoomGraph = generateRoomGraph;
  exports.generateRoom = generateRoom;
  exports.generatePuzzle = generatePuzzle;
  exports.solvePuzzle = solvePuzzle;
  exports.generateEnemyEncounter = generateEnemyEncounter;
  exports.calculateCombatOutcome = calculateCombatOutcome;
  exports.getLootDrop = getLootDrop;
  exports.getShortestPath = getShortestPath;
  exports.revealMap = revealMap;
  exports.getDungeonScore = getDungeonScore;
  exports.getDungeonSummary = getDungeonSummary;

})(typeof module !== 'undefined' ? module.exports : (window.Dungeons = {}));


// card_game.js
// card_game.js
/**
 * ZION Trading Card Game System
 * Collectible cards, deck building, PvP battle mechanics
 * Layer: standalone (no project dependencies)
 */

(function(exports) {
  'use strict';

  // =========================================================================
  // CONSTANTS
  // =========================================================================

  var ELEMENTS = ['fire', 'water', 'earth', 'air', 'spirit'];
  var CARD_TYPES = ['creature', 'spell', 'trap', 'equipment', 'legendary'];
  var RARITIES = ['common', 'uncommon', 'rare', 'epic', 'legendary'];

  var DECK_MIN = 20;
  var DECK_MAX = 40;
  var MAX_COPIES_PER_CARD = 3;
  var MAX_COPIES_LEGENDARY = 1;
  var HAND_MAX = 7;
  var STARTING_HAND = 5;
  var STARTING_MANA = 1;
  var MAX_MANA = 10;
  var FIELD_MAX = 5;
  var STARTING_HP = 30;

  // =========================================================================
  // CARD CATALOG â€” 60+ cards
  // =========================================================================

  var CARD_CATALOG = {

    // -----------------------------------------------------------------------
    // CREATURE CARDS (20+)
    // -----------------------------------------------------------------------

    'c_ember_sprite': {
      id: 'c_ember_sprite',
      name: 'Ember Sprite',
      type: 'creature',
      rarity: 'common',
      cost: 1,
      element: 'fire',
      attack: 1,
      defense: 1,
      hp: 1,
      ability: 'ignite',
      ability_text: 'When this enters play, deal 1 damage to any target.',
      art_description: 'A tiny flame-spirit dancing in the air, leaving scorch marks on the ground.'
    },

    'c_fire_wolf': {
      id: 'c_fire_wolf',
      name: 'Fire Wolf',
      type: 'creature',
      rarity: 'common',
      cost: 2,
      element: 'fire',
      attack: 3,
      defense: 1,
      hp: 2,
      ability: 'swift',
      ability_text: 'Can attack the turn it enters play.',
      art_description: 'A sleek wolf wreathed in crimson flames, muscles rippling beneath burning fur.'
    },

    'c_lava_titan': {
      id: 'c_lava_titan',
      name: 'Lava Titan',
      type: 'creature',
      rarity: 'rare',
      cost: 5,
      element: 'fire',
      attack: 5,
      defense: 3,
      hp: 6,
      ability: 'molten_armor',
      ability_text: 'When attacked, deal 1 damage back to the attacker.',
      art_description: 'A colossal humanoid formed from cooling lava, cracks glowing orange with inner fire.'
    },

    'c_salamander_knight': {
      id: 'c_salamander_knight',
      name: 'Salamander Knight',
      type: 'creature',
      rarity: 'uncommon',
      cost: 3,
      element: 'fire',
      attack: 3,
      defense: 2,
      hp: 3,
      ability: 'fire_shield',
      ability_text: 'Allied fire creatures gain +1 defense.',
      art_description: 'An armored salamander wielding a blazing lance, scales shimmering in the heat.'
    },

    'c_phoenix_fledgling': {
      id: 'c_phoenix_fledgling',
      name: 'Phoenix Fledgling',
      type: 'creature',
      rarity: 'rare',
      cost: 4,
      element: 'fire',
      attack: 3,
      defense: 2,
      hp: 4,
      ability: 'rebirth',
      ability_text: 'When destroyed, return to hand with 1 HP at end of turn.',
      art_description: 'A young phoenix trailing golden embers, feathers not yet fully formed.'
    },

    'c_tide_caller': {
      id: 'c_tide_caller',
      name: 'Tide Caller',
      type: 'creature',
      rarity: 'common',
      cost: 2,
      element: 'water',
      attack: 1,
      defense: 2,
      hp: 3,
      ability: 'heal_wave',
      ability_text: 'At end of your turn, restore 1 HP to any allied creature.',
      art_description: 'A slender figure draped in kelp, commanding the tides with outstretched arms.'
    },

    'c_coral_guardian': {
      id: 'c_coral_guardian',
      name: 'Coral Guardian',
      type: 'creature',
      rarity: 'uncommon',
      cost: 3,
      element: 'water',
      attack: 2,
      defense: 4,
      hp: 5,
      ability: 'barrier',
      ability_text: 'Absorbs first damage each turn. Resets at start of your turn.',
      art_description: 'A towering construct of living coral, moving with the grace of the ocean.'
    },

    'c_sea_serpent': {
      id: 'c_sea_serpent',
      name: 'Sea Serpent',
      type: 'creature',
      rarity: 'rare',
      cost: 5,
      element: 'water',
      attack: 4,
      defense: 3,
      hp: 7,
      ability: 'whirlpool',
      ability_text: 'On attack, enemy creatures cannot retaliate this turn.',
      art_description: 'A massive serpent coiled in an endless spiral beneath the ocean surface.'
    },

    'c_frost_wisp': {
      id: 'c_frost_wisp',
      name: 'Frost Wisp',
      type: 'creature',
      rarity: 'common',
      cost: 1,
      element: 'water',
      attack: 1,
      defense: 1,
      hp: 2,
      ability: 'chill',
      ability_text: 'Target creature loses 1 attack until end of turn.',
      art_description: 'A small orb of swirling ice crystals that drifts silently through frozen air.'
    },

    'c_stone_golem': {
      id: 'c_stone_golem',
      name: 'Stone Golem',
      type: 'creature',
      rarity: 'common',
      cost: 3,
      element: 'earth',
      attack: 2,
      defense: 5,
      hp: 5,
      ability: 'taunt',
      ability_text: 'Enemies must attack this creature if able.',
      art_description: 'A hulking golem carved from ancient granite, mosses growing in its cracks.'
    },

    'c_thornback_boar': {
      id: 'c_thornback_boar',
      name: 'Thornback Boar',
      type: 'creature',
      rarity: 'common',
      cost: 2,
      element: 'earth',
      attack: 3,
      defense: 1,
      hp: 3,
      ability: 'trample',
      ability_text: 'Excess damage carries over to the enemy player.',
      art_description: 'A massive boar with stone-hard hide and thorn-sharp tusks, charging wildly.'
    },

    'c_earth_colossus': {
      id: 'c_earth_colossus',
      name: 'Earth Colossus',
      type: 'creature',
      rarity: 'epic',
      cost: 7,
      element: 'earth',
      attack: 6,
      defense: 6,
      hp: 10,
      ability: 'earthquake',
      ability_text: 'On attack, deal 2 damage to all enemy creatures.',
      art_description: 'A walking mountain of living stone, each step shaking the ground for miles.'
    },

    'c_vine_shaman': {
      id: 'c_vine_shaman',
      name: 'Vine Shaman',
      type: 'creature',
      rarity: 'uncommon',
      cost: 3,
      element: 'earth',
      attack: 2,
      defense: 2,
      hp: 4,
      ability: 'entangle',
      ability_text: 'Target enemy creature cannot attack next turn.',
      art_description: 'An elder draped in living vines, commanding the roots to rise and bind foes.'
    },

    'c_wind_dancer': {
      id: 'c_wind_dancer',
      name: 'Wind Dancer',
      type: 'creature',
      rarity: 'common',
      cost: 2,
      element: 'air',
      attack: 2,
      defense: 1,
      hp: 2,
      ability: 'evasion',
      ability_text: '50% chance to dodge single-target attacks.',
      art_description: 'A graceful figure that seems to dissolve into swirling air currents mid-movement.'
    },

    'c_storm_hawk': {
      id: 'c_storm_hawk',
      name: 'Storm Hawk',
      type: 'creature',
      rarity: 'uncommon',
      cost: 3,
      element: 'air',
      attack: 4,
      defense: 2,
      hp: 3,
      ability: 'dive_strike',
      ability_text: 'First attack deals double damage.',
      art_description: 'A massive hawk riding on storm clouds, lightning crackling between its feathers.'
    },

    'c_cyclone_elemental': {
      id: 'c_cyclone_elemental',
      name: 'Cyclone Elemental',
      type: 'creature',
      rarity: 'rare',
      cost: 5,
      element: 'air',
      attack: 4,
      defense: 3,
      hp: 5,
      ability: 'vortex',
      ability_text: 'At start of turn, deal 1 damage to all enemies.',
      art_description: 'A howling tornado given form, debris orbiting its spinning core.'
    },

    'c_spirit_guide': {
      id: 'c_spirit_guide',
      name: 'Spirit Guide',
      type: 'creature',
      rarity: 'uncommon',
      cost: 2,
      element: 'spirit',
      attack: 1,
      defense: 2,
      hp: 3,
      ability: 'mana_surge',
      ability_text: 'Gain 1 extra mana this turn when played.',
      art_description: 'A translucent entity of pure light, drifting between the planes of existence.'
    },

    'c_soul_reaver': {
      id: 'c_soul_reaver',
      name: 'Soul Reaver',
      type: 'creature',
      rarity: 'rare',
      cost: 4,
      element: 'spirit',
      attack: 4,
      defense: 2,
      hp: 4,
      ability: 'life_drain',
      ability_text: 'Heals your HP by half the damage dealt.',
      art_description: 'A dark wraith with clawed hands that pull the life-force from living beings.'
    },

    'c_void_stalker': {
      id: 'c_void_stalker',
      name: 'Void Stalker',
      type: 'creature',
      rarity: 'epic',
      cost: 6,
      element: 'spirit',
      attack: 5,
      defense: 3,
      hp: 6,
      ability: 'phase_shift',
      ability_text: 'Cannot be targeted by spells or traps.',
      art_description: 'A creature that slips between dimensions, appearing only to strike.'
    },

    'c_ghost_wisp': {
      id: 'c_ghost_wisp',
      name: 'Ghost Wisp',
      type: 'creature',
      rarity: 'common',
      cost: 1,
      element: 'spirit',
      attack: 1,
      defense: 1,
      hp: 1,
      ability: 'haunt',
      ability_text: 'When destroyed, give opponent a curse card.',
      art_description: 'A flickering pale light that drifts aimlessly, passing through solid walls.'
    },

    'c_magma_wyrm': {
      id: 'c_magma_wyrm',
      name: 'Magma Wyrm',
      type: 'creature',
      rarity: 'epic',
      cost: 6,
      element: 'fire',
      attack: 6,
      defense: 4,
      hp: 7,
      ability: 'flame_breath',
      ability_text: 'On attack, also deals 2 damage to all other enemy creatures.',
      art_description: 'A dragon-like creature of pure magma, melting the ground beneath its claws.'
    },

    'c_crystal_golem': {
      id: 'c_crystal_golem',
      name: 'Crystal Golem',
      type: 'creature',
      rarity: 'rare',
      cost: 4,
      element: 'earth',
      attack: 3,
      defense: 5,
      hp: 6,
      ability: 'reflect',
      ability_text: 'Reflects spell damage back at caster.',
      art_description: 'A humanoid of giant crystals that refracts light into deadly beams.'
    },

    'c_tempest_rider': {
      id: 'c_tempest_rider',
      name: 'Tempest Rider',
      type: 'creature',
      rarity: 'uncommon',
      cost: 4,
      element: 'air',
      attack: 3,
      defense: 2,
      hp: 4,
      ability: 'tailwind',
      ability_text: 'Allied air creatures gain +2 attack this turn.',
      art_description: 'A warrior mounted on a living storm cloud, lance crackling with electricity.'
    },

    // -----------------------------------------------------------------------
    // SPELL CARDS (15+)
    // -----------------------------------------------------------------------

    's_fireball': {
      id: 's_fireball',
      name: 'Fireball',
      type: 'spell',
      rarity: 'common',
      cost: 3,
      element: 'fire',
      effect: 'damage',
      effect_value: 4,
      target: 'any',
      ability_text: 'Deal 4 damage to any target.',
      art_description: 'A swirling orb of concentrated fire launched from an outstretched palm.'
    },

    's_inferno': {
      id: 's_inferno',
      name: 'Inferno',
      type: 'spell',
      rarity: 'rare',
      cost: 6,
      element: 'fire',
      effect: 'aoe_damage',
      effect_value: 3,
      target: 'all_enemies',
      ability_text: 'Deal 3 damage to all enemy creatures.',
      art_description: 'Pillars of fire erupt across the entire battlefield in sequence.'
    },

    's_ember_step': {
      id: 's_ember_step',
      name: 'Ember Step',
      type: 'spell',
      rarity: 'common',
      cost: 1,
      element: 'fire',
      effect: 'buff_attack',
      effect_value: 2,
      target: 'allied_creature',
      ability_text: 'Give target allied creature +2 attack until end of turn.',
      art_description: 'Flames swirl around a warrior\'s feet, propelling them forward with explosive force.'
    },

    's_tidal_wave': {
      id: 's_tidal_wave',
      name: 'Tidal Wave',
      type: 'spell',
      rarity: 'rare',
      cost: 5,
      element: 'water',
      effect: 'push_back',
      effect_value: 2,
      target: 'all_enemies',
      ability_text: 'Deal 2 damage to all enemies. Enemy creatures skip next attack.',
      art_description: 'A massive wall of water that crashes across the field, scattering everything.'
    },

    's_frost_nova': {
      id: 's_frost_nova',
      name: 'Frost Nova',
      type: 'spell',
      rarity: 'uncommon',
      cost: 3,
      element: 'water',
      effect: 'freeze',
      effect_value: 1,
      target: 'all_enemy_creatures',
      ability_text: 'Freeze all enemy creatures. They cannot attack next turn.',
      art_description: 'Crystals of ice burst outward from a central point, encasing everything in frost.'
    },

    's_mending_waters': {
      id: 's_mending_waters',
      name: 'Mending Waters',
      type: 'spell',
      rarity: 'common',
      cost: 2,
      element: 'water',
      effect: 'heal',
      effect_value: 4,
      target: 'player_or_creature',
      ability_text: 'Restore 4 HP to yourself or a target allied creature.',
      art_description: 'Gentle streams flow upward, weaving through wounds and sealing them shut.'
    },

    's_stone_skin': {
      id: 's_stone_skin',
      name: 'Stone Skin',
      type: 'spell',
      rarity: 'common',
      cost: 2,
      element: 'earth',
      effect: 'buff_defense',
      effect_value: 3,
      target: 'allied_creature',
      ability_text: 'Give target allied creature +3 defense until end of turn.',
      art_description: 'Rock and earth crawl up the target\'s body, hardening into natural armor.'
    },

    's_earthquake_strike': {
      id: 's_earthquake_strike',
      name: 'Earthquake Strike',
      type: 'spell',
      rarity: 'uncommon',
      cost: 4,
      element: 'earth',
      effect: 'stun',
      effect_value: 2,
      target: 'enemy_creature',
      ability_text: 'Stun target enemy creature and deal 2 damage.',
      art_description: 'The ground ruptures beneath a foe, throwing them into the air.'
    },

    's_gale_force': {
      id: 's_gale_force',
      name: 'Gale Force',
      type: 'spell',
      rarity: 'uncommon',
      cost: 3,
      element: 'air',
      effect: 'draw',
      effect_value: 2,
      target: 'self',
      ability_text: 'Draw 2 cards.',
      art_description: 'A rush of wind whips through the air, scattering cards into the caster\'s hands.'
    },

    's_lightning_bolt': {
      id: 's_lightning_bolt',
      name: 'Lightning Bolt',
      type: 'spell',
      rarity: 'common',
      cost: 2,
      element: 'air',
      effect: 'damage',
      effect_value: 3,
      target: 'any',
      ability_text: 'Deal 3 damage to any target.',
      art_description: 'A jagged bolt of pure lightning leaps from fingertip to target.'
    },

    's_spirit_link': {
      id: 's_spirit_link',
      name: 'Spirit Link',
      type: 'spell',
      rarity: 'uncommon',
      cost: 3,
      element: 'spirit',
      effect: 'copy_ability',
      effect_value: 1,
      target: 'allied_creature',
      ability_text: 'Copy target allied creature\'s ability onto another creature.',
      art_description: 'Ethereal threads connect two creatures, pulsing with shared energy.'
    },

    's_soul_harvest': {
      id: 's_soul_harvest',
      name: 'Soul Harvest',
      type: 'spell',
      rarity: 'rare',
      cost: 4,
      element: 'spirit',
      effect: 'drain',
      effect_value: 3,
      target: 'enemy_creature',
      ability_text: 'Destroy target enemy creature with 3 or less HP, gain 3 HP.',
      art_description: 'Dark tendrils wrap around a foe, extracting their life force.'
    },

    's_mana_crystal': {
      id: 's_mana_crystal',
      name: 'Mana Crystal',
      type: 'spell',
      rarity: 'rare',
      cost: 0,
      element: 'spirit',
      effect: 'gain_mana',
      effect_value: 3,
      target: 'self',
      ability_text: 'Gain 3 mana this turn.',
      art_description: 'A perfect crystal that shatters, releasing pure arcane energy.'
    },

    's_counter_spell': {
      id: 's_counter_spell',
      name: 'Counter Spell',
      type: 'spell',
      rarity: 'uncommon',
      cost: 2,
      element: 'spirit',
      effect: 'negate',
      effect_value: 0,
      target: 'opponent_spell',
      ability_text: 'Cancel target spell. Your opponent loses the mana spent.',
      art_description: 'Two magical forces collide and annihilate each other in a flash of light.'
    },

    's_wildfire': {
      id: 's_wildfire',
      name: 'Wildfire',
      type: 'spell',
      rarity: 'epic',
      cost: 8,
      element: 'fire',
      effect: 'aoe_damage',
      effect_value: 5,
      target: 'all_enemies',
      ability_text: 'Deal 5 damage to all enemies and their player.',
      art_description: 'An uncontrollable blaze that sweeps across the entire arena.'
    },

    's_revival': {
      id: 's_revival',
      name: 'Revival',
      type: 'spell',
      rarity: 'epic',
      cost: 6,
      element: 'spirit',
      effect: 'resurrect',
      effect_value: 1,
      target: 'destroyed_creature',
      ability_text: 'Return any destroyed creature to play with half HP.',
      art_description: 'Shining light pours into the battlefield, calling a fallen warrior back.'
    },

    // -----------------------------------------------------------------------
    // TRAP CARDS (10+)
    // -----------------------------------------------------------------------

    'tr_ambush': {
      id: 'tr_ambush',
      name: 'Ambush',
      type: 'trap',
      rarity: 'common',
      cost: 2,
      element: 'earth',
      trigger: 'enemy_attack',
      effect: 'counter_damage',
      effect_value: 3,
      ability_text: 'Trigger: When enemy attacks. Effect: Deal 3 damage to attacker.',
      art_description: 'Hidden figures leap from concealment to strike the attacking foe.'
    },

    'tr_mirror_shield': {
      id: 'tr_mirror_shield',
      name: 'Mirror Shield',
      type: 'trap',
      rarity: 'uncommon',
      cost: 3,
      element: 'spirit',
      trigger: 'enemy_spell',
      effect: 'reflect_spell',
      effect_value: 0,
      ability_text: 'Trigger: When enemy casts a spell. Effect: Redirect spell back at caster.',
      art_description: 'A shield of pure light that materializes to deflect magic attacks.'
    },

    'tr_pit_trap': {
      id: 'tr_pit_trap',
      name: 'Pit Trap',
      type: 'trap',
      rarity: 'common',
      cost: 1,
      element: 'earth',
      trigger: 'creature_enter',
      effect: 'stun',
      effect_value: 1,
      ability_text: 'Trigger: When enemy plays a creature. Effect: Stun it for 1 turn.',
      art_description: 'The ground gives way beneath a newly-summoned creature\'s feet.'
    },

    'tr_mana_drain': {
      id: 'tr_mana_drain',
      name: 'Mana Drain',
      type: 'trap',
      rarity: 'rare',
      cost: 3,
      element: 'spirit',
      trigger: 'spell_cast',
      effect: 'steal_mana',
      effect_value: 2,
      ability_text: 'Trigger: When enemy casts spell costing 3+. Effect: Steal 2 mana.',
      art_description: 'Siphoning tendrils intercept magical energy mid-cast.'
    },

    'tr_chain_lightning': {
      id: 'tr_chain_lightning',
      name: 'Chain Lightning',
      type: 'trap',
      rarity: 'uncommon',
      cost: 3,
      element: 'air',
      trigger: 'enemy_attack',
      effect: 'aoe_damage',
      effect_value: 2,
      ability_text: 'Trigger: When enemy creature attacks. Effect: Deal 2 damage to all enemy creatures.',
      art_description: 'A trap wire triggers an explosive burst of lightning across the field.'
    },

    'tr_quicksand': {
      id: 'tr_quicksand',
      name: 'Quicksand',
      type: 'trap',
      rarity: 'uncommon',
      cost: 2,
      element: 'earth',
      trigger: 'creature_enter',
      effect: 'reduce_attack',
      effect_value: 2,
      ability_text: 'Trigger: When enemy plays creature. Effect: That creature gets -2 attack permanently.',
      art_description: 'The ground liquefies and drags the creature down, hampering its movement.'
    },

    'tr_ice_barrage': {
      id: 'tr_ice_barrage',
      name: 'Ice Barrage',
      type: 'trap',
      rarity: 'common',
      cost: 2,
      element: 'water',
      trigger: 'turn_end',
      effect: 'freeze',
      effect_value: 1,
      ability_text: 'Trigger: End of enemy turn. Effect: Freeze one random enemy creature.',
      art_description: 'A volley of ice shards launches at the end of the enemy\'s turn.'
    },

    'tr_soul_cage': {
      id: 'tr_soul_cage',
      name: 'Soul Cage',
      type: 'trap',
      rarity: 'rare',
      cost: 4,
      element: 'spirit',
      trigger: 'creature_death',
      effect: 'steal_creature',
      effect_value: 0,
      ability_text: 'Trigger: When any creature is destroyed. Effect: Add a copy to your hand.',
      art_description: 'A spectral cage captures the departing spirit of a defeated creature.'
    },

    'tr_explosive_rune': {
      id: 'tr_explosive_rune',
      name: 'Explosive Rune',
      type: 'trap',
      rarity: 'uncommon',
      cost: 3,
      element: 'fire',
      trigger: 'step_on',
      effect: 'damage',
      effect_value: 4,
      ability_text: 'Trigger: When enemy creature enters play. Effect: Deal 4 damage to that creature.',
      art_description: 'A glowing rune inscribed on the ground detonates when stepped upon.'
    },

    'tr_time_warp': {
      id: 'tr_time_warp',
      name: 'Time Warp',
      type: 'trap',
      rarity: 'epic',
      cost: 5,
      element: 'spirit',
      trigger: 'low_hp',
      effect: 'extra_turn',
      effect_value: 1,
      ability_text: 'Trigger: When your HP drops below 10. Effect: Take an extra turn.',
      art_description: 'The flow of time freezes, giving the caster precious moments to act.'
    },

    'tr_decoy': {
      id: 'tr_decoy',
      name: 'Decoy',
      type: 'trap',
      rarity: 'common',
      cost: 1,
      element: 'air',
      trigger: 'enemy_attack',
      effect: 'redirect',
      effect_value: 0,
      ability_text: 'Trigger: When enemy attacks a creature. Effect: Redirect attack to another creature.',
      art_description: 'A mirror-image phantom appears to confuse the attacking enemy.'
    },

    // -----------------------------------------------------------------------
    // EQUIPMENT CARDS (10+)
    // -----------------------------------------------------------------------

    'e_flame_sword': {
      id: 'e_flame_sword',
      name: 'Flame Sword',
      type: 'equipment',
      rarity: 'uncommon',
      cost: 2,
      element: 'fire',
      stat_boost: { attack: 2 },
      duration: -1,
      ability_text: 'Equipped creature gains +2 attack. Permanent.',
      art_description: 'A steel sword with a blade permanently engulfed in white-hot flames.'
    },

    'e_frost_shield': {
      id: 'e_frost_shield',
      name: 'Frost Shield',
      type: 'equipment',
      rarity: 'uncommon',
      cost: 2,
      element: 'water',
      stat_boost: { defense: 3 },
      duration: -1,
      ability_text: 'Equipped creature gains +3 defense. Permanent.',
      art_description: 'A shield carved from everlasting ice that never melts.'
    },

    'e_earth_boots': {
      id: 'e_earth_boots',
      name: 'Earth Boots',
      type: 'equipment',
      rarity: 'common',
      cost: 1,
      element: 'earth',
      stat_boost: { hp: 3 },
      duration: -1,
      ability_text: 'Equipped creature gains +3 max HP (restored immediately). Permanent.',
      art_description: 'Heavy boots forged from compressed earth that root the wearer firmly.'
    },

    'e_wind_cloak': {
      id: 'e_wind_cloak',
      name: 'Wind Cloak',
      type: 'equipment',
      rarity: 'uncommon',
      cost: 2,
      element: 'air',
      stat_boost: { attack: 1, defense: 1 },
      duration: 3,
      ability_text: 'Equipped creature gains +1 attack and +1 defense for 3 turns.',
      art_description: 'A shimmering cloak woven from compressed wind currents.'
    },

    'e_spirit_amulet': {
      id: 'e_spirit_amulet',
      name: 'Spirit Amulet',
      type: 'equipment',
      rarity: 'rare',
      cost: 3,
      element: 'spirit',
      stat_boost: { attack: 2, hp: 2 },
      duration: -1,
      ability_text: 'Equipped creature gains +2 attack and +2 HP. Permanent.',
      art_description: 'A glowing amulet that channels spectral energy into the wearer.'
    },

    'e_lava_gauntlets': {
      id: 'e_lava_gauntlets',
      name: 'Lava Gauntlets',
      type: 'equipment',
      rarity: 'rare',
      cost: 3,
      element: 'fire',
      stat_boost: { attack: 4 },
      duration: 2,
      ability_text: 'Equipped creature gains +4 attack for 2 turns then takes 2 damage.',
      art_description: 'Gauntlets formed from cooling lava that supercharge strikes at cost.'
    },

    'e_coral_armor': {
      id: 'e_coral_armor',
      name: 'Coral Armor',
      type: 'equipment',
      rarity: 'common',
      cost: 2,
      element: 'water',
      stat_boost: { defense: 2, hp: 2 },
      duration: -1,
      ability_text: 'Equipped creature gains +2 defense and +2 HP. Permanent.',
      art_description: 'Armor grown from living coral that hardens further when struck.'
    },

    'e_thunder_spear': {
      id: 'e_thunder_spear',
      name: 'Thunder Spear',
      type: 'equipment',
      rarity: 'uncommon',
      cost: 3,
      element: 'air',
      stat_boost: { attack: 3 },
      duration: -1,
      ability_text: 'Equipped creature gains +3 attack. First strike.',
      art_description: 'A spear crackling with stored lightning that strikes before the enemy can react.'
    },

    'e_ancient_tome': {
      id: 'e_ancient_tome',
      name: 'Ancient Tome',
      type: 'equipment',
      rarity: 'rare',
      cost: 3,
      element: 'spirit',
      stat_boost: { attack: 1 },
      duration: -1,
      ability_text: 'Equipped creature gains +1 attack. Spells you cast cost 1 less mana. Permanent.',
      art_description: 'A weathered tome that enhances magical ability through forbidden knowledge.'
    },

    'e_crystal_crown': {
      id: 'e_crystal_crown',
      name: 'Crystal Crown',
      type: 'equipment',
      rarity: 'epic',
      cost: 4,
      element: 'earth',
      stat_boost: { attack: 2, defense: 2, hp: 4 },
      duration: -1,
      ability_text: 'Equipped creature gains +2 attack, +2 defense, +4 HP. Permanent.',
      art_description: 'A crown of perfect crystals that amplifies the bearer\'s innate power.'
    },

    // -----------------------------------------------------------------------
    // LEGENDARY CARDS (5+)
    // -----------------------------------------------------------------------

    'l_zion_avatar': {
      id: 'l_zion_avatar',
      name: 'Zion Avatar',
      type: 'legendary',
      rarity: 'legendary',
      cost: 9,
      element: 'spirit',
      attack: 8,
      defense: 8,
      hp: 12,
      ability: 'world_will',
      ability_text: 'Cannot be targeted. At end of every turn, heal 2 HP. When destroyed, draw 3 cards.',
      art_description: 'A radiant being of pure collective will, formed from the dreams of all citizens.'
    },

    'l_the_architect': {
      id: 'l_the_architect',
      name: 'The Architect',
      type: 'legendary',
      rarity: 'legendary',
      cost: 8,
      element: 'earth',
      attack: 5,
      defense: 7,
      hp: 10,
      ability: 'master_builder',
      ability_text: 'All equipment costs 0. Allied creatures gain +2 defense.',
      art_description: 'The original designer of the world, surrounded by floating blueprints.'
    },

    'l_storm_sovereign': {
      id: 'l_storm_sovereign',
      name: 'Storm Sovereign',
      type: 'legendary',
      rarity: 'legendary',
      cost: 8,
      element: 'air',
      attack: 7,
      defense: 5,
      hp: 9,
      ability: 'sovereign_storm',
      ability_text: 'At start of each turn, deal 1 damage to all enemies. Air creatures cost 2 less.',
      art_description: 'A monarch riding a perpetual hurricane, command absolute over weather.'
    },

    'l_deep_leviathan': {
      id: 'l_deep_leviathan',
      name: 'Deep Leviathan',
      type: 'legendary',
      rarity: 'legendary',
      cost: 10,
      element: 'water',
      attack: 9,
      defense: 6,
      hp: 14,
      ability: 'abyss_call',
      ability_text: 'When played, destroy all creatures with 5 or less HP. Taunt.',
      art_description: 'An ancient sea-beast that predates the world itself, vast beyond imagination.'
    },

    'l_infernal_dragon': {
      id: 'l_infernal_dragon',
      name: 'Infernal Dragon',
      type: 'legendary',
      rarity: 'legendary',
      cost: 9,
      element: 'fire',
      attack: 8,
      defense: 5,
      hp: 11,
      ability: 'dragon_fury',
      ability_text: 'Attacks twice each turn. First attack hits creature, second hits player directly.',
      art_description: 'The primordial fire dragon whose breath ignited the first sun.'
    }

  };

  // =========================================================================
  // COLLECTION MANAGEMENT
  // =========================================================================

  // In-memory collections: playerId -> { cardId: count }
  var _collections = {};

  /**
   * Get all cards a player owns.
   * @param {string} playerId
   * @returns {Object} map of cardId -> count
   */
  function getPlayerCollection(playerId) {
    if (!_collections[playerId]) {
      _collections[playerId] = {};
    }
    return JSON.parse(JSON.stringify(_collections[playerId]));
  }

  /**
   * Add a card to a player's collection.
   * @param {string} playerId
   * @param {string} cardId
   * @returns {Object} { success, cardId, count }
   */
  function addCardToCollection(playerId, cardId) {
    if (!CARD_CATALOG[cardId]) {
      return { success: false, error: 'Card not found: ' + cardId };
    }
    if (!_collections[playerId]) {
      _collections[playerId] = {};
    }
    var current = _collections[playerId][cardId] || 0;
    _collections[playerId][cardId] = current + 1;
    return {
      success: true,
      cardId: cardId,
      count: _collections[playerId][cardId],
      card: CARD_CATALOG[cardId]
    };
  }

  /**
   * Generate a card reward for a given achievement.
   * @param {string} achievementId
   * @returns {Object} card definition
   */
  function generateCardFromAchievement(achievementId) {
    var achievementCardMap = {
      'first_battle': 'c_ember_sprite',
      'first_win': 'c_fire_wolf',
      'zone_hopper': 'c_wind_dancer',
      'world_traveler': 'c_cyclone_elemental',
      'builder': 'e_earth_boots',
      'merchant': 's_mana_crystal',
      'teacher': 's_spirit_link',
      'healer': 's_mending_waters',
      'explorer': 'c_storm_hawk',
      'social': 'c_spirit_guide',
      'legendary_win': 'l_zion_avatar',
      'perfect_game': 'l_infernal_dragon',
      'collector': 'l_the_architect'
    };
    var cardId = achievementCardMap[achievementId];
    if (!cardId) {
      // Default: give a common card based on achievement hash
      var keys = Object.keys(CARD_CATALOG).filter(function(k) {
        return CARD_CATALOG[k].rarity === 'common';
      });
      var idx = Math.abs(hashString(achievementId)) % keys.length;
      cardId = keys[idx];
    }
    return CARD_CATALOG[cardId] || null;
  }

  // Simple string hash
  function hashString(str) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0;
    }
    return hash;
  }

  // =========================================================================
  // DECK MANAGEMENT
  // =========================================================================

  /**
   * Create a new deck.
   * @param {string} playerId
   * @param {string} name
   * @param {string[]} cardIds - array of card IDs (duplicates allowed)
   * @returns {Object} deck object
   */
  function createDeck(playerId, name, cardIds) {
    var deck = {
      id: 'deck_' + playerId + '_' + Date.now(),
      playerId: playerId,
      name: name || 'My Deck',
      cards: cardIds ? cardIds.slice() : [],
      createdAt: Date.now()
    };
    return deck;
  }

  /**
   * Validate a deck for legality.
   * @param {Object} deck - deck object
   * @returns {Object} { valid: boolean, errors: string[] }
   */
  function validateDeck(deck) {
    var errors = [];

    if (!deck || !Array.isArray(deck.cards)) {
      return { valid: false, errors: ['Invalid deck structure'] };
    }

    var count = deck.cards.length;
    if (count < DECK_MIN) {
      errors.push('Deck has ' + count + ' cards; minimum is ' + DECK_MIN);
    }
    if (count > DECK_MAX) {
      errors.push('Deck has ' + count + ' cards; maximum is ' + DECK_MAX);
    }

    // Count copies per card
    var copies = {};
    for (var i = 0; i < deck.cards.length; i++) {
      var cid = deck.cards[i];
      if (!CARD_CATALOG[cid]) {
        errors.push('Unknown card: ' + cid);
        continue;
      }
      copies[cid] = (copies[cid] || 0) + 1;
    }

    // Check copy limits
    for (var cardId in copies) {
      var card = CARD_CATALOG[cardId];
      if (!card) continue;
      var limit = (card.rarity === 'legendary' || card.type === 'legendary') ? MAX_COPIES_LEGENDARY : MAX_COPIES_PER_CARD;
      if (copies[cardId] > limit) {
        errors.push('Too many copies of "' + card.name + '": ' + copies[cardId] + ' (max ' + limit + ')');
      }
    }

    // Element balance check: no single element should exceed 80% of creature cards
    var elementCount = {};
    var totalCreatures = 0;
    for (var j = 0; j < deck.cards.length; j++) {
      var c = CARD_CATALOG[deck.cards[j]];
      if (c && c.type === 'creature') {
        totalCreatures++;
        elementCount[c.element] = (elementCount[c.element] || 0) + 1;
      }
    }
    if (totalCreatures > 0) {
      for (var el in elementCount) {
        var pct = elementCount[el] / totalCreatures;
        if (pct > 0.8) {
          errors.push('Element imbalance: ' + el + ' makes up ' + Math.round(pct * 100) + '% of creatures (max 80%)');
        }
      }
    }

    return { valid: errors.length === 0, errors: errors };
  }

  // =========================================================================
  // BATTLE STATE
  // =========================================================================

  /**
   * Start a battle between two decks.
   * @param {Object} player1Deck - deck object { playerId, cards }
   * @param {Object} player2Deck - deck object { playerId, cards }
   * @returns {Object} battleState
   */
  function startBattle(player1Deck, player2Deck) {
    var p1 = _createPlayerBattleState(player1Deck);
    var p2 = _createPlayerBattleState(player2Deck);

    // Draw starting hands
    for (var i = 0; i < STARTING_HAND; i++) {
      _drawFromDeck(p1);
      _drawFromDeck(p2);
    }

    var state = {
      id: 'battle_' + Date.now(),
      turn: 1,
      activePlayer: player1Deck.playerId,
      phase: 'main',  // 'draw', 'main', 'battle', 'end'
      players: {},
      graveyard: { [player1Deck.playerId]: [], [player2Deck.playerId]: [] },
      trapZone: { [player1Deck.playerId]: [], [player2Deck.playerId]: [] },
      log: [],
      winner: null,
      started: Date.now()
    };
    state.players[player1Deck.playerId] = p1;
    state.players[player2Deck.playerId] = p2;

    _logEvent(state, 'Battle started between ' + player1Deck.playerId + ' and ' + player2Deck.playerId);
    return state;
  }

  function _createPlayerBattleState(deck) {
    // Shuffle a copy of the deck
    var cards = deck.cards.slice();
    _shuffleArray(cards);
    return {
      playerId: deck.playerId,
      hp: STARTING_HP,
      maxHp: STARTING_HP,
      mana: STARTING_MANA,
      maxMana: STARTING_MANA,
      deck: cards,
      hand: [],
      field: [],      // active creatures on field, each is a battle-card instance
      equipment: {},  // creatureInstanceId -> [equipment cards]
      hasSummoned: false,
      hasAttacked: {}
    };
  }

  function _shuffleArray(arr) {
    for (var i = arr.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
  }

  function _drawFromDeck(playerState) {
    if (playerState.deck.length === 0) {
      // Fatigue: take 1 damage for empty deck draw
      playerState.hp = Math.max(0, playerState.hp - 1);
      return null;
    }
    if (playerState.hand.length >= HAND_MAX) {
      // Overdraw: discard
      var discarded = playerState.deck.shift();
      return null;
    }
    var cardId = playerState.deck.shift();
    playerState.hand.push(cardId);
    return cardId;
  }

  /**
   * Draw a card for a player during battle.
   * @param {Object} battleState
   * @param {string} playerId
   * @returns {Object} { success, cardId, card }
   */
  function drawCard(battleState, playerId) {
    var pState = battleState.players[playerId];
    if (!pState) return { success: false, error: 'Player not found' };
    var cardId = _drawFromDeck(pState);
    if (cardId === null) {
      return { success: false, error: 'No cards to draw or hand full' };
    }
    _logEvent(battleState, playerId + ' drew a card');
    return { success: true, cardId: cardId, card: CARD_CATALOG[cardId] };
  }

  /**
   * Play a card from hand.
   * @param {Object} battleState
   * @param {string} playerId
   * @param {string} cardId
   * @param {string|null} target - target ID (player ID, creature instance ID, or null)
   * @returns {Object} result
   */
  function playCard(battleState, playerId, cardId, target) {
    if (battleState.winner) return { success: false, error: 'Battle is over' };
    if (battleState.activePlayer !== playerId) return { success: false, error: 'Not your turn' };

    var pState = battleState.players[playerId];
    if (!pState) return { success: false, error: 'Player not found' };

    // Check hand
    var handIdx = pState.hand.indexOf(cardId);
    if (handIdx === -1) return { success: false, error: 'Card not in hand' };

    var card = CARD_CATALOG[cardId];
    if (!card) return { success: false, error: 'Unknown card' };

    // Check mana
    var cost = card.cost;
    // Ancient Tome equipment bonus
    var tomeBonus = _hasEquipmentBonus(pState, 'e_ancient_tome');
    if (tomeBonus && (card.type === 'spell')) cost = Math.max(0, cost - 1);

    if (pState.mana < cost) {
      return { success: false, error: 'Not enough mana (need ' + cost + ', have ' + pState.mana + ')' };
    }

    // Pay mana
    pState.mana -= cost;

    // Remove from hand
    pState.hand.splice(handIdx, 1);

    var result = { success: true, card: card };

    if (card.type === 'creature' || card.type === 'legendary') {
      result = _playCreature(battleState, playerId, card, result);
    } else if (card.type === 'spell') {
      result = _playSpell(battleState, playerId, card, target, result);
    } else if (card.type === 'trap') {
      result = _playTrap(battleState, playerId, card, result);
    } else if (card.type === 'equipment') {
      result = _playEquipment(battleState, playerId, card, target, result);
    }

    // Check mana_surge ability
    if (card.ability === 'mana_surge') {
      pState.mana = Math.min(pState.maxMana, pState.mana + 1);
    }

    _logEvent(battleState, playerId + ' played ' + card.name);
    checkWinCondition(battleState);
    return result;
  }

  function _playCreature(battleState, playerId, card, result) {
    var pState = battleState.players[playerId];
    if (pState.field.length >= FIELD_MAX) {
      // Refund mana and put card back â€” field full
      pState.mana += card.cost;
      result.success = false;
      result.error = 'Field is full (max ' + FIELD_MAX + ' creatures)';
      return result;
    }
    var instance = _createCreatureInstance(card, playerId);
    pState.field.push(instance);
    pState.hasSummoned = true;
    result.instanceId = instance.id;
    result.creature = instance;

    // On-enter abilities
    if (card.ability === 'ignite') {
      // Deal 1 to any target â€” default to opponent
      var oppId = _getOpponent(battleState, playerId);
      if (oppId) battleState.players[oppId].hp -= 1;
    } else if (card.ability === 'abyss_call') {
      // Destroy all creatures with HP <= 5
      var oppId2 = _getOpponent(battleState, playerId);
      if (oppId2) {
        var toDestroy = [];
        var oppField = battleState.players[oppId2].field;
        for (var i = oppField.length - 1; i >= 0; i--) {
          if (oppField[i].currentHp <= 5) toDestroy.push(i);
        }
        for (var d = toDestroy.length - 1; d >= 0; d--) {
          var destroyed = oppField.splice(toDestroy[d], 1)[0];
          battleState.graveyard[oppId2].push(destroyed.cardId);
        }
      }
    }
    return result;
  }

  function _createCreatureInstance(card, ownerId) {
    var inst = {
      id: 'ci_' + Date.now() + '_' + Math.floor(Math.random() * 9999),
      cardId: card.id,
      name: card.name,
      ownerId: ownerId,
      attack: card.attack || 0,
      defense: card.defense || 0,
      currentHp: card.hp || 1,
      maxHp: card.hp || 1,
      ability: card.ability || null,
      element: card.element,
      rarity: card.rarity,
      type: card.type,
      canAttack: card.ability === 'swift',  // swift creatures attack immediately
      isFrozen: false,
      isStunned: false,
      isTaunting: card.ability === 'taunt',
      hasBarrier: card.ability === 'barrier',
      hasEvasion: card.ability === 'evasion',
      attackUsed: false
    };
    return inst;
  }

  function _playSpell(battleState, playerId, card, target, result) {
    var pState = battleState.players[playerId];
    var oppId = _getOpponent(battleState, playerId);
    var oState = battleState.players[oppId];

    // Check traps that react to spells
    _checkSpellTraps(battleState, oppId, playerId, card);

    switch (card.effect) {
      case 'damage':
        var dmgTarget = _resolveTarget(battleState, target, playerId);
        if (dmgTarget && dmgTarget.isPlayer) {
          var tpState = battleState.players[dmgTarget.id];
          if (tpState) tpState.hp -= card.effect_value;
        } else if (dmgTarget && dmgTarget.creature) {
          _damageCreature(battleState, dmgTarget.creature, card.effect_value, playerId);
        }
        break;

      case 'aoe_damage':
        if (oState) {
          for (var i = oState.field.length - 1; i >= 0; i--) {
            _damageCreature(battleState, oState.field[i], card.effect_value, playerId);
          }
          if (card.id === 's_wildfire') {
            oState.hp -= card.effect_value;
          }
        }
        break;

      case 'heal':
        var healTarget = _resolveTarget(battleState, target, playerId);
        if (healTarget && healTarget.isPlayer) {
          pState.hp = Math.min(pState.maxHp, pState.hp + card.effect_value);
        } else if (healTarget && healTarget.creature) {
          healTarget.creature.currentHp = Math.min(healTarget.creature.maxHp, healTarget.creature.currentHp + card.effect_value);
        } else {
          // Default: heal self
          pState.hp = Math.min(pState.maxHp, pState.hp + card.effect_value);
        }
        break;

      case 'buff_attack':
        var buffTarget = _resolveTarget(battleState, target, playerId);
        if (buffTarget && buffTarget.creature && buffTarget.creature.ownerId === playerId) {
          buffTarget.creature.attack += card.effect_value;
        }
        break;

      case 'buff_defense':
        var buffDefTarget = _resolveTarget(battleState, target, playerId);
        if (buffDefTarget && buffDefTarget.creature && buffDefTarget.creature.ownerId === playerId) {
          buffDefTarget.creature.defense += card.effect_value;
        }
        break;

      case 'freeze':
        if (oState) {
          for (var fi = 0; fi < oState.field.length; fi++) {
            oState.field[fi].isFrozen = true;
            oState.field[fi].canAttack = false;
          }
        }
        break;

      case 'push_back':
        if (oState) {
          for (var pi = oState.field.length - 1; pi >= 0; pi--) {
            _damageCreature(battleState, oState.field[pi], card.effect_value, playerId);
          }
          // Mark all enemy creatures as unable to attack
          for (var ai = 0; ai < oState.field.length; ai++) {
            oState.field[ai].canAttack = false;
          }
        }
        break;

      case 'stun':
        var stunTarget = _resolveTarget(battleState, target, playerId);
        if (stunTarget && stunTarget.creature) {
          stunTarget.creature.isStunned = true;
          stunTarget.creature.canAttack = false;
          _damageCreature(battleState, stunTarget.creature, card.effect_value, playerId);
        }
        break;

      case 'draw':
        for (var di = 0; di < card.effect_value; di++) {
          _drawFromDeck(pState);
        }
        break;

      case 'drain':
        var drainTarget = _resolveTarget(battleState, target, playerId);
        if (drainTarget && drainTarget.creature && drainTarget.creature.currentHp <= card.effect_value) {
          // Destroy and gain HP
          _removeCreatureFromField(battleState, drainTarget.creature, oppId);
          battleState.graveyard[oppId].push(drainTarget.creature.cardId);
          pState.hp = Math.min(pState.maxHp, pState.hp + card.effect_value);
        }
        break;

      case 'gain_mana':
        pState.mana = Math.min(MAX_MANA, pState.mana + card.effect_value);
        break;

      case 'negate':
        // Counter spell â€” handled externally or is passive
        break;

      case 'resurrect':
        // Bring back a destroyed creature
        if (battleState.graveyard[playerId] && battleState.graveyard[playerId].length > 0) {
          var lastDeadId = target || battleState.graveyard[playerId][battleState.graveyard[playerId].length - 1];
          var deadCard = CARD_CATALOG[lastDeadId];
          if (deadCard && pState.field.length < FIELD_MAX) {
            var revivedInst = _createCreatureInstance(deadCard, playerId);
            revivedInst.currentHp = Math.ceil(deadCard.hp / 2);
            pState.field.push(revivedInst);
            var gIdx = battleState.graveyard[playerId].lastIndexOf(lastDeadId);
            if (gIdx !== -1) battleState.graveyard[playerId].splice(gIdx, 1);
          }
        }
        break;

      case 'copy_ability':
        // Spirit Link â€” complex, skip detailed impl
        break;
    }

    result.effect = card.effect;
    return result;
  }

  function _playTrap(battleState, playerId, card, result) {
    var trapInstance = {
      id: 'trap_' + Date.now() + '_' + Math.floor(Math.random() * 9999),
      cardId: card.id,
      name: card.name,
      ownerId: playerId,
      trigger: card.trigger,
      effect: card.effect,
      effect_value: card.effect_value,
      active: true
    };
    battleState.trapZone[playerId].push(trapInstance);
    result.trapId = trapInstance.id;
    return result;
  }

  function _playEquipment(battleState, playerId, card, target, result) {
    var pState = battleState.players[playerId];
    var creature = _findCreatureInstance(pState.field, target);
    if (!creature) {
      // Equip to first creature on field
      creature = pState.field.length > 0 ? pState.field[0] : null;
    }
    if (!creature) {
      result.success = false;
      result.error = 'No creature to equip';
      return result;
    }
    // Apply stat boosts
    if (card.stat_boost) {
      if (card.stat_boost.attack) creature.attack += card.stat_boost.attack;
      if (card.stat_boost.defense) creature.defense += card.stat_boost.defense;
      if (card.stat_boost.hp) {
        creature.maxHp += card.stat_boost.hp;
        creature.currentHp += card.stat_boost.hp;
      }
    }
    if (!pState.equipment[creature.id]) pState.equipment[creature.id] = [];
    pState.equipment[creature.id].push({ cardId: card.id, duration: card.duration, turnsLeft: card.duration });
    result.equippedTo = creature.id;
    result.creature = creature;
    return result;
  }

  // =========================================================================
  // COMBAT
  // =========================================================================

  /**
   * Attack with a creature.
   * @param {Object} battleState
   * @param {string} attackerInstanceId
   * @param {string} targetId - creature instance ID or opponent player ID
   * @returns {Object} result
   */
  function attackWithCreature(battleState, attackerInstanceId, targetId) {
    if (battleState.winner) return { success: false, error: 'Battle is over' };

    var attackerInfo = _findCreatureAnywhere(battleState, attackerInstanceId);
    if (!attackerInfo) return { success: false, error: 'Attacker not found' };

    var attacker = attackerInfo.creature;
    var attackerOwner = attackerInfo.ownerId;

    if (battleState.activePlayer !== attackerOwner) {
      return { success: false, error: 'Not your turn' };
    }

    if (!attacker.canAttack || attacker.attackUsed) {
      return { success: false, error: 'Creature cannot attack' };
    }
    if (attacker.isFrozen || attacker.isStunned) {
      return { success: false, error: 'Creature is frozen/stunned' };
    }

    var oppId = _getOpponent(battleState, attackerOwner);
    var oState = battleState.players[oppId];

    // Check for taunt creatures
    var hasTaunt = oState.field.some(function(c) { return c.isTaunting; });
    var targetCreature = _findCreatureInstance(oState.field, targetId);

    // If taunt exists and target isn't a taunt creature and target isn't the opponent player
    if (hasTaunt && !targetCreature) {
      return { success: false, error: 'Must attack taunt creature first' };
    }
    if (hasTaunt && targetCreature && !targetCreature.isTaunting) {
      return { success: false, error: 'Must attack taunt creature first' };
    }

    // Check traps that react to attacks
    var trapResult = _checkAttackTraps(battleState, oppId, attacker, targetCreature);

    attacker.attackUsed = true;

    var result = { success: true, attacker: attacker };

    if (targetCreature) {
      // Creature vs Creature
      result = _resolveCreatureCombat(battleState, attacker, attackerOwner, targetCreature, oppId, result);
    } else {
      // Attacking player directly
      var dmg = attacker.attack;
      oState.hp -= dmg;
      result.playerDamage = dmg;
      result.targetPlayer = oppId;
      _logEvent(battleState, attacker.name + ' attacks ' + oppId + ' for ' + dmg + ' damage');
    }

    // Infernal Dragon: second attack hits player
    if (attacker.ability === 'dragon_fury' && targetCreature) {
      var bonusDmg = attacker.attack;
      oState.hp -= bonusDmg;
      result.dragonBonus = bonusDmg;
    }

    checkWinCondition(battleState);
    return result;
  }

  function _resolveCreatureCombat(battleState, attacker, attackerOwner, defender, defenderOwner, result) {
    var oppState = battleState.players[defenderOwner];
    var atkState = battleState.players[attackerOwner];

    // Evasion check
    if (defender.hasEvasion && Math.random() < 0.5) {
      result.dodged = true;
      _logEvent(battleState, defender.name + ' dodged the attack!');
      return result;
    }

    var attackDmg = attacker.attack;

    // Dive strike: double on first attack
    if (attacker.ability === 'dive_strike' && !attacker._diveUsed) {
      attackDmg *= 2;
      attacker._diveUsed = true;
    }

    // Barrier check
    if (defender.hasBarrier) {
      defender.hasBarrier = false;
      result.barrierAbsorbed = true;
      _logEvent(battleState, defender.name + ' barrier absorbed attack');
      return result;
    }

    // Apply defense reduction
    var netDmg = Math.max(1, attackDmg - defender.defense);
    defender.currentHp -= netDmg;

    // Molten armor: reflect damage
    if (defender.ability === 'molten_armor') {
      var reflectDmg = 1;
      attacker.currentHp -= reflectDmg;
    }

    // Life drain
    if (attacker.ability === 'life_drain') {
      atkState.hp = Math.min(atkState.maxHp, atkState.hp + Math.floor(netDmg / 2));
    }

    // Trample: excess damage to player
    if (attacker.ability === 'trample' && netDmg > defender.currentHp + netDmg) {
      var excess = -(defender.currentHp); // how much overshot
      if (excess > 0) oppState.hp -= excess;
    }

    result.damage = netDmg;
    result.defenderHp = defender.currentHp;

    _logEvent(battleState, attacker.name + ' attacks ' + defender.name + ' for ' + netDmg + ' damage');

    // Check if defender dies
    if (defender.currentHp <= 0) {
      _creatureDied(battleState, defender, defenderOwner, attacker);
      result.defenderDestroyed = true;
    }

    // Check if attacker dies from retaliation (only when not using abilities like whirlpool)
    if (attacker.ability !== 'whirlpool') {
      var retDmg = Math.max(1, defender.attack - attacker.defense);
      if (!defender.isFrozen && !defender.isStunned && defender.currentHp > 0) {
        attacker.currentHp -= retDmg;
        result.retaliation = retDmg;
        if (attacker.currentHp <= 0) {
          _creatureDied(battleState, attacker, attackerOwner, defender);
          result.attackerDestroyed = true;
        }
      }
    }

    return result;
  }

  function _creatureDied(battleState, creature, ownerId, killer) {
    _removeCreatureFromField(battleState, creature, ownerId);
    battleState.graveyard[ownerId].push(creature.cardId);

    // Rebirth ability
    if (creature.ability === 'rebirth') {
      var pState = battleState.players[ownerId];
      var card = CARD_CATALOG[creature.cardId];
      if (card) {
        var reborn = JSON.parse(JSON.stringify(creature));
        reborn.currentHp = 1;
        reborn.id = 'ci_' + Date.now() + '_' + Math.floor(Math.random() * 9999);
        pState.hand.push(creature.cardId);  // Return to hand
        battleState.graveyard[ownerId].pop();  // Remove from graveyard
      }
    }

    // Ghost wisp: give opponent curse
    if (creature.ability === 'haunt') {
      var oppId = _getOpponent(battleState, ownerId);
      // Add a "curse" card to opponent hand (use a trap card)
      if (battleState.players[oppId]) {
        battleState.players[oppId].hand.push('tr_pit_trap');
      }
    }

    // Soul Cage trap
    _checkCreatureDeathTraps(battleState, creature, ownerId, killer);

    _logEvent(battleState, creature.name + ' was destroyed');
  }

  function _removeCreatureFromField(battleState, creature, ownerId) {
    var field = battleState.players[ownerId] && battleState.players[ownerId].field;
    if (!field) return;
    var idx = field.findIndex(function(c) { return c.id === creature.id; });
    if (idx !== -1) field.splice(idx, 1);
  }

  function _damageCreature(battleState, creature, amount, attackerId) {
    // Check reflect (crystal golem)
    if (creature.ability === 'reflect') {
      // Reflect spell back â€” damage attacker instead
      var atkOwner = _getOpponent(battleState, creature.ownerId);
      if (atkOwner && battleState.players[atkOwner]) {
        battleState.players[atkOwner].hp -= amount;
      }
      return;
    }

    creature.currentHp -= amount;
    if (creature.currentHp <= 0) {
      _creatureDied(battleState, creature, creature.ownerId, null);
    }
  }

  // =========================================================================
  // TRAP ACTIVATION
  // =========================================================================

  /**
   * Manually activate a trap.
   * @param {Object} battleState
   * @param {string} trapInstanceId
   * @returns {Object} result
   */
  function activateTrap(battleState, trapInstanceId) {
    if (battleState.winner) return { success: false, error: 'Battle is over' };

    var trapInfo = null;
    var trapOwner = null;
    for (var pid in battleState.trapZone) {
      var zone = battleState.trapZone[pid];
      for (var i = 0; i < zone.length; i++) {
        if (zone[i].id === trapInstanceId) {
          trapInfo = zone[i];
          trapOwner = pid;
          break;
        }
      }
      if (trapInfo) break;
    }

    if (!trapInfo) return { success: false, error: 'Trap not found' };
    if (!trapInfo.active) return { success: false, error: 'Trap already used' };

    trapInfo.active = false;
    var result = _executeTrapEffect(battleState, trapInfo, trapOwner);
    // Remove from trap zone
    var zone = battleState.trapZone[trapOwner];
    var idx = zone.findIndex(function(t) { return t.id === trapInstanceId; });
    if (idx !== -1) zone.splice(idx, 1);

    _logEvent(battleState, trapOwner + ' activated trap: ' + trapInfo.name);
    checkWinCondition(battleState);
    return result;
  }

  function _executeTrapEffect(battleState, trap, trapOwner) {
    var oppId = _getOpponent(battleState, trapOwner);
    var oState = battleState.players[oppId];
    var tState = battleState.players[trapOwner];
    var result = { success: true, trap: trap };

    switch (trap.effect) {
      case 'counter_damage':
        if (oState) oState.hp -= trap.effect_value;
        break;
      case 'reflect_spell':
        // Handled in spell resolution
        break;
      case 'stun':
        if (oState && oState.field.length > 0) {
          oState.field[0].isStunned = true;
          oState.field[0].canAttack = false;
        }
        break;
      case 'steal_mana':
        if (oState && tState) {
          var stolen = Math.min(oState.mana, trap.effect_value);
          oState.mana -= stolen;
          tState.mana = Math.min(MAX_MANA, tState.mana + stolen);
        }
        break;
      case 'aoe_damage':
        if (oState) {
          for (var i = oState.field.length - 1; i >= 0; i--) {
            _damageCreature(battleState, oState.field[i], trap.effect_value, trapOwner);
          }
        }
        break;
      case 'reduce_attack':
        if (oState && oState.field.length > 0) {
          oState.field[0].attack = Math.max(0, oState.field[0].attack - trap.effect_value);
        }
        break;
      case 'freeze':
        if (oState && oState.field.length > 0) {
          var target = oState.field[Math.floor(Math.random() * oState.field.length)];
          target.isFrozen = true;
          target.canAttack = false;
        }
        break;
      case 'steal_creature':
        if (battleState.graveyard[oppId] && battleState.graveyard[oppId].length > 0) {
          var lastId = battleState.graveyard[oppId][battleState.graveyard[oppId].length - 1];
          if (tState && tState.hand.length < HAND_MAX) {
            tState.hand.push(lastId);
          }
        }
        break;
      case 'damage':
        if (oState && oState.field.length > 0) {
          _damageCreature(battleState, oState.field[0], trap.effect_value, trapOwner);
        }
        break;
      case 'extra_turn':
        battleState.activePlayer = trapOwner;
        break;
      case 'redirect':
        // Complex â€” mark as handled
        break;
    }
    return result;
  }

  function _checkAttackTraps(battleState, defenderId, attacker, targetCreature) {
    var zone = battleState.trapZone[defenderId];
    if (!zone) return;
    for (var i = zone.length - 1; i >= 0; i--) {
      var trap = zone[i];
      if (!trap.active) continue;
      if (trap.trigger === 'enemy_attack') {
        trap.active = false;
        _executeTrapEffect(battleState, trap, defenderId);
        zone.splice(i, 1);
      }
    }
  }

  function _checkSpellTraps(battleState, defenderId, attackerId, card) {
    var zone = battleState.trapZone[defenderId];
    if (!zone) return;
    for (var i = zone.length - 1; i >= 0; i--) {
      var trap = zone[i];
      if (!trap.active) continue;
      if (trap.trigger === 'enemy_spell' || (trap.trigger === 'spell_cast' && card.cost >= 3)) {
        trap.active = false;
        _executeTrapEffect(battleState, trap, defenderId);
        zone.splice(i, 1);
      }
    }
  }

  function _checkCreatureDeathTraps(battleState, creature, ownerId, killer) {
    // Check all trap zones for creature_death triggers
    for (var pid in battleState.trapZone) {
      var zone = battleState.trapZone[pid];
      for (var i = zone.length - 1; i >= 0; i--) {
        var trap = zone[i];
        if (trap.active && trap.trigger === 'creature_death') {
          trap.active = false;
          _executeTrapEffect(battleState, trap, pid);
          zone.splice(i, 1);
        }
      }
    }
  }

  // =========================================================================
  // SPELL CASTING
  // =========================================================================

  /**
   * Cast a spell directly (already played from hand; this re-resolves it).
   * @param {Object} battleState
   * @param {string} spellCardId - must be in hand
   * @param {string|null} target
   * @returns {Object} result
   */
  function castSpell(battleState, playerId, spellCardId, target) {
    return playCard(battleState, playerId, spellCardId, target);
  }

  // =========================================================================
  // TURN PROCESSING
  // =========================================================================

  /**
   * Process a full turn worth of actions.
   * @param {Object} battleState
   * @param {Object[]} actions - array of { type, cardId, target, attackerId, targetId }
   * @returns {Object} result
   */
  function processTurn(battleState, actions) {
    if (battleState.winner) return { success: false, error: 'Battle is over' };

    var activeId = battleState.activePlayer;
    var pState = battleState.players[activeId];
    var results = [];

    // Draw phase
    _drawFromDeck(pState);

    // Increase max mana
    pState.maxMana = Math.min(MAX_MANA, pState.turn_maxMana || pState.maxMana);
    pState.maxMana = Math.min(MAX_MANA, battleState.turn + 1);
    pState.mana = pState.maxMana;

    // Reset attack flags
    for (var i = 0; i < pState.field.length; i++) {
      pState.field[i].attackUsed = false;
      pState.field[i].canAttack = true;
      if (pState.field[i].isFrozen) {
        pState.field[i].isFrozen = false;
      }
      if (pState.field[i].isStunned) {
        pState.field[i].isStunned = false;
      }
    }

    // Vortex ability: deal 1 damage to all enemies at start of turn
    for (var vi = 0; vi < pState.field.length; vi++) {
      if (pState.field[vi].ability === 'vortex') {
        var oppId = _getOpponent(battleState, activeId);
        if (oppId && battleState.players[oppId]) {
          battleState.players[oppId].hp -= 1;
        }
      }
    }

    // Zion Avatar: heal 2 HP at end of turn (we'll handle at end)

    // Process actions
    actions = actions || [];
    for (var a = 0; a < actions.length; a++) {
      var action = actions[a];
      var res = null;
      if (action.type === 'play_card') {
        res = playCard(battleState, activeId, action.cardId, action.target || null);
      } else if (action.type === 'attack') {
        res = attackWithCreature(battleState, action.attackerId, action.targetId);
      } else if (action.type === 'activate_trap') {
        res = activateTrap(battleState, action.trapId);
      } else if (action.type === 'draw') {
        res = drawCard(battleState, activeId);
      }
      results.push({ action: action, result: res });
      if (battleState.winner) break;
    }

    // End of turn: Zion Avatar heal
    for (var zi = 0; zi < pState.field.length; zi++) {
      if (pState.field[zi].ability === 'world_will') {
        pState.hp = Math.min(pState.maxHp, pState.hp + 2);
      }
    }

    // Storm Sovereign: deal 1 to all enemies at start of NEXT turn (applied here at end for simplicity)
    for (var si = 0; si < pState.field.length; si++) {
      if (pState.field[si].ability === 'sovereign_storm') {
        var ssOppId = _getOpponent(battleState, activeId);
        if (ssOppId && battleState.players[ssOppId]) {
          battleState.players[ssOppId].hp -= 1;
        }
      }
    }

    // Check win before switching turns
    checkWinCondition(battleState);

    if (!battleState.winner) {
      // Switch active player
      var oppIdForSwitch = _getOpponent(battleState, activeId);
      battleState.activePlayer = oppIdForSwitch;
      battleState.turn++;
    }

    _logEvent(battleState, 'Turn ' + battleState.turn + ' ended for ' + activeId);
    return { success: true, results: results };
  }

  // =========================================================================
  // WIN CONDITION
  // =========================================================================

  /**
   * Check if the battle is over.
   * @param {Object} battleState
   * @returns {Object} { gameOver, winner, reason }
   */
  function checkWinCondition(battleState) {
    if (battleState.winner) {
      return { gameOver: true, winner: battleState.winner, reason: battleState.winReason };
    }

    var playerIds = Object.keys(battleState.players);
    for (var i = 0; i < playerIds.length; i++) {
      var pid = playerIds[i];
      var pState = battleState.players[pid];
      if (pState.hp <= 0) {
        var oppId = _getOpponent(battleState, pid);
        battleState.winner = oppId;
        battleState.winReason = pid + ' HP reached 0';
        _logEvent(battleState, oppId + ' wins! ' + pid + ' was defeated.');
        return { gameOver: true, winner: oppId, reason: battleState.winReason };
      }
      if (pState.deck.length === 0 && pState.hand.length === 0) {
        // Out of cards â€” lose via deck out
        var oppId2 = _getOpponent(battleState, pid);
        battleState.winner = oppId2;
        battleState.winReason = pid + ' decked out';
        _logEvent(battleState, oppId2 + ' wins by deck out!');
        return { gameOver: true, winner: oppId2, reason: battleState.winReason };
      }
    }

    return { gameOver: false, winner: null, reason: null };
  }

  // =========================================================================
  // VISIBLE STATE
  // =========================================================================

  /**
   * Get the visible battle state for a player (hides opponent hand).
   * @param {Object} battleState
   * @param {string} playerId
   * @returns {Object} visible state
   */
  function getBattleState(battleState, playerId) {
    var visible = {
      id: battleState.id,
      turn: battleState.turn,
      activePlayer: battleState.activePlayer,
      phase: battleState.phase,
      winner: battleState.winner,
      winReason: battleState.winReason,
      log: battleState.log.slice(-20),  // last 20 events
      players: {}
    };

    for (var pid in battleState.players) {
      var pState = battleState.players[pid];
      if (pid === playerId) {
        // Full info for this player
        visible.players[pid] = {
          playerId: pid,
          hp: pState.hp,
          maxHp: pState.maxHp,
          mana: pState.mana,
          maxMana: pState.maxMana,
          hand: pState.hand.slice(),
          handCards: pState.hand.map(function(cid) { return CARD_CATALOG[cid]; }),
          field: pState.field.slice(),
          deckSize: pState.deck.length,
          equipment: pState.equipment
        };
      } else {
        // Hidden hand for opponent
        visible.players[pid] = {
          playerId: pid,
          hp: pState.hp,
          maxHp: pState.maxHp,
          mana: pState.mana,
          maxMana: pState.maxMana,
          handSize: pState.hand.length,
          hand: null,  // hidden
          field: pState.field.slice(),
          deckSize: pState.deck.length
        };
      }
    }

    // Trap zones (hidden â€” only show count)
    visible.trapZones = {};
    for (var tid in battleState.trapZone) {
      if (tid === playerId) {
        visible.trapZones[tid] = battleState.trapZone[tid].slice();
      } else {
        visible.trapZones[tid] = { count: battleState.trapZone[tid].length };
      }
    }

    visible.graveyard = {};
    for (var gid in battleState.graveyard) {
      visible.graveyard[gid] = battleState.graveyard[gid].slice();
    }

    return visible;
  }

  // =========================================================================
  // CATALOG FILTERS
  // =========================================================================

  /**
   * Get all cards of a specific element.
   * @param {string} element
   * @returns {Object[]} array of card definitions
   */
  function getCardsByElement(element) {
    var result = [];
    for (var id in CARD_CATALOG) {
      if (CARD_CATALOG[id].element === element) {
        result.push(CARD_CATALOG[id]);
      }
    }
    return result;
  }

  /**
   * Get all cards of a specific type.
   * @param {string} type
   * @returns {Object[]} array of card definitions
   */
  function getCardsByType(type) {
    var result = [];
    for (var id in CARD_CATALOG) {
      if (CARD_CATALOG[id].type === type) {
        result.push(CARD_CATALOG[id]);
      }
    }
    return result;
  }

  /**
   * Get all cards of a specific rarity.
   * @param {string} rarity
   * @returns {Object[]} array of card definitions
   */
  function getCardsByRarity(rarity) {
    var result = [];
    for (var id in CARD_CATALOG) {
      if (CARD_CATALOG[id].rarity === rarity) {
        result.push(CARD_CATALOG[id]);
      }
    }
    return result;
  }

  // =========================================================================
  // DECK STRENGTH
  // =========================================================================

  /**
   * Calculate estimated power level of a deck.
   * @param {Object} deck - deck object
   * @returns {Object} { score, breakdown }
   */
  function calculateDeckStrength(deck) {
    if (!deck || !Array.isArray(deck.cards)) return { score: 0, breakdown: {} };

    var rarityScores = { common: 1, uncommon: 2, rare: 4, epic: 7, legendary: 12 };
    var totalScore = 0;
    var breakdown = { byRarity: {}, byType: {}, byElement: {}, cardCount: deck.cards.length };
    var avgCost = 0;
    var validCards = 0;

    for (var i = 0; i < deck.cards.length; i++) {
      var card = CARD_CATALOG[deck.cards[i]];
      if (!card) continue;
      validCards++;
      var rScore = rarityScores[card.rarity] || 1;
      totalScore += rScore;
      avgCost += card.cost;
      breakdown.byRarity[card.rarity] = (breakdown.byRarity[card.rarity] || 0) + 1;
      breakdown.byType[card.type] = (breakdown.byType[card.type] || 0) + 1;
      breakdown.byElement[card.element] = (breakdown.byElement[card.element] || 0) + 1;
    }

    breakdown.avgCost = validCards > 0 ? Math.round((avgCost / validCards) * 10) / 10 : 0;

    // Bonus for synergy (more than 3 cards of same element)
    var synergyBonus = 0;
    for (var el in breakdown.byElement) {
      if (breakdown.byElement[el] >= 5) synergyBonus += 5;
      if (breakdown.byElement[el] >= 10) synergyBonus += 10;
    }
    totalScore += synergyBonus;

    // Curve bonus: balanced mana curve is rewarded
    if (breakdown.avgCost >= 2.5 && breakdown.avgCost <= 4.5) {
      totalScore += 10;
    }

    breakdown.synergyBonus = synergyBonus;
    return { score: totalScore, breakdown: breakdown };
  }

  // =========================================================================
  // HELPERS
  // =========================================================================

  function _getOpponent(battleState, playerId) {
    var ids = Object.keys(battleState.players);
    for (var i = 0; i < ids.length; i++) {
      if (ids[i] !== playerId) return ids[i];
    }
    return null;
  }

  function _resolveTarget(battleState, targetId, playerId) {
    if (!targetId) return null;
    // Check if it's a player
    if (battleState.players[targetId]) {
      return { isPlayer: true, id: targetId };
    }
    // Check all fields
    for (var pid in battleState.players) {
      var field = battleState.players[pid].field;
      var creature = _findCreatureInstance(field, targetId);
      if (creature) return { isPlayer: false, creature: creature, ownerId: pid };
    }
    return null;
  }

  function _findCreatureInstance(field, instanceId) {
    if (!field || !instanceId) return null;
    for (var i = 0; i < field.length; i++) {
      if (field[i].id === instanceId) return field[i];
    }
    return null;
  }

  function _findCreatureAnywhere(battleState, instanceId) {
    for (var pid in battleState.players) {
      var field = battleState.players[pid].field;
      for (var i = 0; i < field.length; i++) {
        if (field[i].id === instanceId) {
          return { creature: field[i], ownerId: pid };
        }
      }
    }
    return null;
  }

  function _hasEquipmentBonus(pState, equipCardId) {
    for (var cid in pState.equipment) {
      var eqList = pState.equipment[cid];
      for (var i = 0; i < eqList.length; i++) {
        if (eqList[i].cardId === equipCardId) return true;
      }
    }
    return false;
  }

  function _logEvent(battleState, message) {
    battleState.log.push({ ts: Date.now(), msg: message });
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.CARD_CATALOG = CARD_CATALOG;
  exports.ELEMENTS = ELEMENTS;
  exports.CARD_TYPES = CARD_TYPES;
  exports.RARITIES = RARITIES;
  exports.DECK_MIN = DECK_MIN;
  exports.DECK_MAX = DECK_MAX;
  exports.MAX_COPIES_PER_CARD = MAX_COPIES_PER_CARD;
  exports.MAX_COPIES_LEGENDARY = MAX_COPIES_LEGENDARY;
  exports.STARTING_HP = STARTING_HP;
  exports.STARTING_HAND = STARTING_HAND;
  exports.HAND_MAX = HAND_MAX;
  exports.FIELD_MAX = FIELD_MAX;

  exports.createDeck = createDeck;
  exports.validateDeck = validateDeck;
  exports.drawCard = drawCard;
  exports.playCard = playCard;
  exports.attackWithCreature = attackWithCreature;
  exports.activateTrap = activateTrap;
  exports.castSpell = castSpell;
  exports.startBattle = startBattle;
  exports.processTurn = processTurn;
  exports.checkWinCondition = checkWinCondition;
  exports.getBattleState = getBattleState;
  exports.getPlayerCollection = getPlayerCollection;
  exports.addCardToCollection = addCardToCollection;
  exports.generateCardFromAchievement = generateCardFromAchievement;
  exports.getCardsByElement = getCardsByElement;
  exports.getCardsByType = getCardsByType;
  exports.getCardsByRarity = getCardsByRarity;
  exports.calculateDeckStrength = calculateDeckStrength;

})(typeof module !== 'undefined' ? module.exports : (window.CardGame = {}));


// time_capsules.js
// time_capsules.js
/**
 * ZION Time Capsule System
 * Players bury messages and items for future players to discover.
 * Constitution Â§5.2 (Permanent Marks), Â§6.1 (Creative Works), Â§2.1 (Connection)
 */
(function(exports) {
  'use strict';

  // =========================================================================
  // CONSTANTS
  // =========================================================================

  /** Radius (world units) a player must be within to detect a buried capsule */
  var DISCOVERY_RADIUS = 20;

  /** Maximum capsules a single player may have buried at once */
  var MAX_CAPSULES_PER_PLAYER = 5;

  /** Maximum message length in characters */
  var MAX_MESSAGE_LENGTH = 500;

  /** Maximum hint length in characters */
  var MAX_HINT_LENGTH = 100;

  /** Types of time capsule, each with different capacity and thematic purpose */
  var CAPSULE_TYPES = {
    message: {
      id: 'message',
      name: 'Message Capsule',
      description: 'A simple capsule carrying a personal note to the future.',
      maxItems: 0,
      baseSparkCost: 5,
      canHaveItems: false
    },
    gift: {
      id: 'gift',
      name: 'Gift Capsule',
      description: 'A capsule bearing a single item alongside a heartfelt message.',
      maxItems: 1,
      baseSparkCost: 15,
      canHaveItems: true
    },
    legacy: {
      id: 'legacy',
      name: 'Legacy Capsule',
      description: 'A grand capsule carrying multiple treasures and a lasting message for posterity.',
      maxItems: 5,
      baseSparkCost: 50,
      canHaveItems: true
    },
    commemorative: {
      id: 'commemorative',
      name: 'Commemorative Capsule',
      description: 'A ceremonial capsule tied to a specific world event, sealing a moment in ZION history.',
      maxItems: 3,
      baseSparkCost: 30,
      canHaveItems: true,
      requiresEvent: true
    }
  };

  /**
   * Capsule materials â€” control minimum lock duration and whether capsule
   * degrades (expires) before being opened.
   *
   * minDays   : minimum days from burial before unlock is allowed
   * decayDays : days after burial when the capsule degrades (null = never)
   * sparkMulti: cost multiplier applied on top of the type's baseSparkCost
   * displayName
   */
  var CAPSULE_MATERIALS = {
    wooden: {
      id: 'wooden',
      displayName: 'Wooden',
      description: 'A simple wooden chest. Decays if left unopened too long.',
      minDays: 1,
      decayDays: 30,
      sparkMultiplier: 1
    },
    stone: {
      id: 'stone',
      displayName: 'Stone',
      description: 'A sturdy stone vault. Endures for a season before crumbling.',
      minDays: 7,
      decayDays: 180,
      sparkMultiplier: 2
    },
    crystal: {
      id: 'crystal',
      displayName: 'Crystal',
      description: 'A crystalline container that preserves its contents for years.',
      minDays: 30,
      decayDays: 365,
      sparkMultiplier: 4
    },
    eternal: {
      id: 'eternal',
      displayName: 'Eternal',
      description: 'An indestructible eternal vessel. Will never decay.',
      minDays: 365,
      decayDays: null,
      sparkMultiplier: 10
    }
  };

  // Status constants
  var STATUS_BURIED  = 'buried';   // locked â€” not yet ready to open
  var STATUS_READY   = 'ready';    // unlock date passed â€” awaiting discovery
  var STATUS_OPENED  = 'opened';   // has been opened by someone
  var STATUS_EXPIRED = 'expired';  // decayed before being opened

  // Profanity list (intentionally minimal â€” real deployment would use a
  // comprehensive list or external service)
  var BLOCKED_WORDS = [
    'fuck', 'shit', 'asshole', 'bitch', 'cunt', 'damn', 'bastard',
    'piss', 'cock', 'dick', 'pussy', 'whore', 'slut', 'nigger',
    'faggot', 'retard', 'nazi', 'kike', 'spic', 'chink'
  ];

  // =========================================================================
  // MODULE STATE (replaced wholesale via initCapsules / getCapsuleState)
  // =========================================================================

  var capsules = {};       // capsuleId â†’ capsule object
  var capsuleCounter = 0;  // monotonic counter for ID generation

  // =========================================================================
  // UTILITY â€” private helpers
  // =========================================================================

  /**
   * Generate a unique capsule ID.
   * @returns {string}
   */
  function generateId() {
    capsuleCounter++;
    return 'cap_' + Date.now().toString(36) + '_' + capsuleCounter.toString(36);
  }

  /**
   * Return the current UTC timestamp in ms.
   * Exposed as a replaceable for testing.
   */
  function now() {
    return (exports._getNow && typeof exports._getNow === 'function')
      ? exports._getNow()
      : Date.now();
  }

  /**
   * Convert days to milliseconds.
   * @param {number} days
   * @returns {number}
   */
  function daysToMs(days) {
    return days * 24 * 60 * 60 * 1000;
  }

  /**
   * 2-D Euclidean distance (ignores Y axis).
   * @param {number} x1
   * @param {number} z1
   * @param {number} x2
   * @param {number} z2
   * @returns {number}
   */
  function distance2D(x1, z1, x2, z2) {
    var dx = x1 - x2;
    var dz = z1 - z2;
    return Math.sqrt(dx * dx + dz * dz);
  }

  /**
   * Count capsules buried by a player that have not yet been opened/expired.
   * @param {string} playerId
   * @returns {number}
   */
  function countActiveBurials(playerId) {
    var count = 0;
    var ids = Object.keys(capsules);
    for (var i = 0; i < ids.length; i++) {
      var c = capsules[ids[i]];
      if (c.buriedBy === playerId &&
          c.status !== STATUS_OPENED &&
          c.status !== STATUS_EXPIRED) {
        count++;
      }
    }
    return count;
  }

  /**
   * Determine a capsule's current computed status, accounting for decay.
   * Does NOT mutate the capsule object â€” call refreshStatus() to update it.
   * @param {object} capsule
   * @returns {string} one of the STATUS_* constants
   */
  function computeStatus(capsule) {
    if (capsule.status === STATUS_OPENED) return STATUS_OPENED;

    var ts = now();

    // Check decay first â€” expired trumps ready
    var material = CAPSULE_MATERIALS[capsule.material];
    if (material && material.decayDays !== null) {
      var decayAt = capsule.buriedAt + daysToMs(material.decayDays);
      if (ts >= decayAt) return STATUS_EXPIRED;
    }

    if (ts >= capsule.unlockAt) return STATUS_READY;

    return STATUS_BURIED;
  }

  /**
   * Refresh the stored status of a capsule in-place.
   * @param {object} capsule
   */
  function refreshStatus(capsule) {
    capsule.status = computeStatus(capsule);
  }

  // =========================================================================
  // MESSAGE SANITIZATION
  // =========================================================================

  /**
   * Sanitize a message string.
   * - Trims whitespace
   * - Enforces MAX_MESSAGE_LENGTH
   * - Blocks profanity
   * @param {string} message
   * @returns {{ ok: boolean, clean?: string, error?: string }}
   */
  function sanitizeMessage(message) {
    if (typeof message !== 'string') {
      return { ok: false, error: 'Message must be a string' };
    }

    var trimmed = message.trim();

    if (trimmed.length === 0) {
      return { ok: false, error: 'Message cannot be empty' };
    }

    if (trimmed.length > MAX_MESSAGE_LENGTH) {
      return { ok: false, error: 'Message exceeds ' + MAX_MESSAGE_LENGTH + ' character limit' };
    }

    var lower = trimmed.toLowerCase();
    for (var i = 0; i < BLOCKED_WORDS.length; i++) {
      if (lower.indexOf(BLOCKED_WORDS[i]) !== -1) {
        return { ok: false, error: 'Message contains prohibited content' };
      }
    }

    return { ok: true, clean: trimmed };
  }

  /**
   * Sanitize a hint string (shorter limit, same profanity check).
   * @param {string} hint
   * @returns {{ ok: boolean, clean?: string, error?: string }}
   */
  function sanitizeHint(hint) {
    if (typeof hint !== 'string') {
      return { ok: false, error: 'Hint must be a string' };
    }

    var trimmed = hint.trim();

    if (trimmed.length > MAX_HINT_LENGTH) {
      return { ok: false, error: 'Hint exceeds ' + MAX_HINT_LENGTH + ' character limit' };
    }

    var lower = trimmed.toLowerCase();
    for (var i = 0; i < BLOCKED_WORDS.length; i++) {
      if (lower.indexOf(BLOCKED_WORDS[i]) !== -1) {
        return { ok: false, error: 'Hint contains prohibited content' };
      }
    }

    return { ok: true, clean: trimmed };
  }

  // =========================================================================
  // CORE API
  // =========================================================================

  /**
   * Bury a new time capsule in the world.
   *
   * @param {string} playerId      - The player burying the capsule
   * @param {{x:number,z:number}}  position   - World-space location
   * @param {string} type          - One of CAPSULE_TYPES keys
   * @param {string} material      - One of CAPSULE_MATERIALS keys
   * @param {object} contents      - { message?: string, items?: string[], hint?: string, eventId?: string }
   * @param {number} unlockDate    - Unix timestamp (ms) when the capsule may be opened
   * @returns {{ success: boolean, capsule?: object, error?: string }}
   */
  function buryCapsule(playerId, position, type, material, contents, unlockDate) {
    // --- Validate inputs ---
    if (!playerId || typeof playerId !== 'string') {
      return { success: false, error: 'Invalid playerId' };
    }
    if (!position || typeof position.x !== 'number' || typeof position.z !== 'number') {
      return { success: false, error: 'Invalid position: must have numeric x and z' };
    }
    if (!CAPSULE_TYPES[type]) {
      return { success: false, error: 'Invalid capsule type: ' + type };
    }
    if (!CAPSULE_MATERIALS[material]) {
      return { success: false, error: 'Invalid capsule material: ' + material };
    }

    var typeData     = CAPSULE_TYPES[type];
    var materialData = CAPSULE_MATERIALS[material];
    var ts           = now();

    // --- Enforce minimum unlock date based on material ---
    var minUnlock = ts + daysToMs(materialData.minDays);
    if (!unlockDate || typeof unlockDate !== 'number') {
      return { success: false, error: 'unlockDate must be a number (Unix ms timestamp)' };
    }
    if (unlockDate < minUnlock) {
      return {
        success: false,
        error: 'Unlock date must be at least ' + materialData.minDays + ' day(s) in the future for ' + materialData.displayName + ' material'
      };
    }

    // --- Check player burial cap ---
    if (countActiveBurials(playerId) >= MAX_CAPSULES_PER_PLAYER) {
      return {
        success: false,
        error: 'Player has reached the maximum of ' + MAX_CAPSULES_PER_PLAYER + ' active capsules'
      };
    }

    // --- Validate commemorative event link ---
    if (type === 'commemorative') {
      if (!contents || !contents.eventId) {
        return { success: false, error: 'Commemorative capsules require an eventId in contents' };
      }
    }

    // --- Sanitize message if provided ---
    var cleanMessage = '';
    if (contents && contents.message) {
      var msgResult = sanitizeMessage(contents.message);
      if (!msgResult.ok) return { success: false, error: msgResult.error };
      cleanMessage = msgResult.clean;
    }

    // --- Sanitize hint if provided ---
    var cleanHint = '';
    if (contents && contents.hint) {
      var hintResult = sanitizeHint(contents.hint);
      if (!hintResult.ok) return { success: false, error: hintResult.error };
      cleanHint = hintResult.clean;
    }

    // --- Validate items ---
    var items = [];
    if (contents && contents.items) {
      if (!Array.isArray(contents.items)) {
        return { success: false, error: 'contents.items must be an array' };
      }
      if (contents.items.length > typeData.maxItems) {
        return {
          success: false,
          error: type + ' capsules can hold at most ' + typeData.maxItems + ' item(s)'
        };
      }
      if (contents.items.length > 0 && !typeData.canHaveItems) {
        return { success: false, error: 'Message capsules cannot contain items' };
      }
      items = contents.items.slice();
    }

    // --- Build capsule object ---
    var id = generateId();
    var capsule = {
      id:         id,
      buriedBy:   playerId,
      position:   { x: position.x, z: position.z },
      type:       type,
      material:   material,
      message:    cleanMessage,
      hint:       cleanHint,
      items:      items,
      eventId:    (contents && contents.eventId) ? contents.eventId : null,
      buriedAt:   ts,
      unlockAt:   unlockDate,
      status:     STATUS_BURIED,
      openedBy:   null,
      openedAt:   null,
      zone:       (contents && contents.zone) ? contents.zone : null
    };

    capsules[id] = capsule;

    // Return a sanitized public copy (no internal message details)
    return {
      success: true,
      capsule: {
        id:        id,
        position:  { x: position.x, z: position.z },
        type:      type,
        material:  material,
        buriedAt:  ts,
        unlockAt:  unlockDate,
        status:    STATUS_BURIED,
        buriedBy:  playerId
      }
    };
  }

  /**
   * Attempt to dig up (open) a capsule.
   * Validates proximity, unlock date, and current status.
   *
   * @param {string} playerId
   * @param {string} capsuleId
   * @param {{x:number,z:number}} playerPosition - used for proximity check
   * @returns {{ success: boolean, contents?: object, error?: string }}
   */
  function digUpCapsule(playerId, capsuleId, playerPosition) {
    var capsule = capsules[capsuleId];
    if (!capsule) {
      return { success: false, error: 'Capsule not found' };
    }

    refreshStatus(capsule);

    if (capsule.status === STATUS_EXPIRED) {
      return { success: false, error: 'This capsule has decayed and can no longer be opened' };
    }
    if (capsule.status === STATUS_OPENED) {
      return { success: false, error: 'This capsule has already been opened' };
    }
    if (capsule.status === STATUS_BURIED) {
      return {
        success: false,
        error: 'This capsule is not ready yet. ' + formatTimeRemaining(getTimeRemaining(capsuleId))
      };
    }

    // Proximity check
    if (playerPosition) {
      var dist = distance2D(playerPosition.x, playerPosition.z, capsule.position.x, capsule.position.z);
      if (dist > DISCOVERY_RADIUS) {
        return {
          success: false,
          error: 'You must be within ' + DISCOVERY_RADIUS + ' units of the capsule to open it'
        };
      }
    }

    return openCapsule(capsuleId, playerId);
  }

  /**
   * Return the current status of a capsule.
   * @param {string} capsuleId
   * @returns {string|null} STATUS_* constant or null if not found
   */
  function getCapsuleStatus(capsuleId) {
    var capsule = capsules[capsuleId];
    if (!capsule) return null;
    refreshStatus(capsule);
    return capsule.status;
  }

  /**
   * Return all capsules within a horizontal radius of a position.
   * Only returns a sanitized marker (id, position, material, status).
   * Message/item contents are NOT revealed before opening.
   *
   * @param {number} x
   * @param {number} z
   * @param {number} radius  - search radius; defaults to DISCOVERY_RADIUS
   * @returns {Array<object>}
   */
  function getNearbyCapsules(x, z, radius) {
    if (typeof radius !== 'number' || radius <= 0) radius = DISCOVERY_RADIUS;

    var results = [];
    var ids = Object.keys(capsules);
    for (var i = 0; i < ids.length; i++) {
      var c = capsules[ids[i]];
      refreshStatus(c);
      if (c.status === STATUS_EXPIRED) continue;

      var dist = distance2D(x, z, c.position.x, c.position.z);
      if (dist <= radius) {
        results.push({
          id:       c.id,
          position: { x: c.position.x, z: c.position.z },
          material: c.material,
          type:     c.type,
          status:   c.status,
          distance: Math.round(dist * 100) / 100
        });
      }
    }
    return results;
  }

  /**
   * Return a vague hint about a capsule's contents without revealing them.
   * @param {string} capsuleId
   * @returns {{ success: boolean, hint?: string, error?: string }}
   */
  function getCapsuleHint(capsuleId) {
    var capsule = capsules[capsuleId];
    if (!capsule) return { success: false, error: 'Capsule not found' };

    refreshStatus(capsule);

    if (capsule.status === STATUS_EXPIRED) {
      return { success: false, error: 'This capsule has decayed' };
    }

    // Build hint from stored hint or auto-generate from type/material
    var hint = capsule.hint;
    if (!hint) {
      var typeData = CAPSULE_TYPES[capsule.type];
      var materialData = CAPSULE_MATERIALS[capsule.material];
      hint = 'A ' + materialData.displayName.toLowerCase() + ' ' +
             typeData.name.toLowerCase() + ' waits here';
      if (capsule.items && capsule.items.length > 0) {
        hint += ', bearing ' + capsule.items.length + ' item' + (capsule.items.length > 1 ? 's' : '');
      }
      if (capsule.message) {
        hint += ', sealed with words from ' + capsule.buriedBy;
      }
      hint += '.';
    }

    return { success: true, hint: hint };
  }

  /**
   * Open a capsule that is in READY status, marking it as opened and returning contents.
   * @param {string} capsuleId
   * @param {string} playerId
   * @returns {{ success: boolean, contents?: object, error?: string }}
   */
  function openCapsule(capsuleId, playerId) {
    var capsule = capsules[capsuleId];
    if (!capsule) return { success: false, error: 'Capsule not found' };

    refreshStatus(capsule);

    if (capsule.status === STATUS_EXPIRED) {
      return { success: false, error: 'This capsule has decayed and can no longer be opened' };
    }
    if (capsule.status === STATUS_OPENED) {
      return { success: false, error: 'This capsule has already been opened' };
    }
    if (capsule.status === STATUS_BURIED) {
      return { success: false, error: 'This capsule is not ready to be opened yet' };
    }

    // Mark as opened
    capsule.status  = STATUS_OPENED;
    capsule.openedBy = playerId;
    capsule.openedAt = now();

    return {
      success: true,
      contents: {
        message:  capsule.message,
        items:    capsule.items.slice(),
        buriedBy: capsule.buriedBy,
        buriedAt: capsule.buriedAt,
        type:     capsule.type,
        material: capsule.material,
        eventId:  capsule.eventId
      }
    };
  }

  /**
   * Return all capsules buried by a given player (including opened/expired).
   * @param {string} playerId
   * @returns {Array<object>}
   */
  function getPlayerBuriedCapsules(playerId) {
    var results = [];
    var ids = Object.keys(capsules);
    for (var i = 0; i < ids.length; i++) {
      var c = capsules[ids[i]];
      if (c.buriedBy === playerId) {
        refreshStatus(c);
        results.push({
          id:        c.id,
          position:  { x: c.position.x, z: c.position.z },
          type:      c.type,
          material:  c.material,
          status:    c.status,
          buriedBy:  c.buriedBy,
          buriedAt:  c.buriedAt,
          unlockAt:  c.unlockAt,
          openedBy:  c.openedBy,
          openedAt:  c.openedAt
        });
      }
    }
    return results;
  }

  /**
   * Return all capsules that a player has opened.
   * @param {string} playerId
   * @returns {Array<object>}
   */
  function getPlayerOpenedCapsules(playerId) {
    var results = [];
    var ids = Object.keys(capsules);
    for (var i = 0; i < ids.length; i++) {
      var c = capsules[ids[i]];
      if (c.openedBy === playerId) {
        results.push({
          id:        c.id,
          type:      c.type,
          material:  c.material,
          buriedBy:  c.buriedBy,
          buriedAt:  c.buriedAt,
          openedAt:  c.openedAt,
          message:   c.message,
          items:     c.items.slice()
        });
      }
    }
    return results;
  }

  /**
   * Return ms remaining until a capsule can be opened, or 0 if ready/opened.
   * @param {string} capsuleId
   * @returns {number} milliseconds, or -1 if capsule not found
   */
  function getTimeRemaining(capsuleId) {
    var capsule = capsules[capsuleId];
    if (!capsule) return -1;

    var ts = now();
    var remaining = capsule.unlockAt - ts;
    return remaining > 0 ? remaining : 0;
  }

  /**
   * Format a ms duration into a human-readable string.
   * @param {number} ms
   * @returns {string}
   */
  function formatTimeRemaining(ms) {
    if (ms <= 0) return 'Ready now';
    var seconds = Math.floor(ms / 1000);
    var minutes = Math.floor(seconds / 60);
    var hours   = Math.floor(minutes / 60);
    var days    = Math.floor(hours / 24);

    if (days > 0)    return days + ' day' + (days > 1 ? 's' : '') + ' remaining';
    if (hours > 0)   return hours + ' hour' + (hours > 1 ? 's' : '') + ' remaining';
    if (minutes > 0) return minutes + ' minute' + (minutes > 1 ? 's' : '') + ' remaining';
    return seconds + ' second' + (seconds > 1 ? 's' : '') + ' remaining';
  }

  /**
   * Add a single item to a NOT-YET-buried capsule (status must be buried, not opened).
   * The capsule must not yet be opened/expired and must have remaining capacity.
   *
   * @param {string} capsuleId
   * @param {string} ownerId   - must match capsule.buriedBy
   * @param {string} itemId
   * @returns {{ success: boolean, error?: string }}
   */
  function addItemToCapsule(capsuleId, ownerId, itemId) {
    var capsule = capsules[capsuleId];
    if (!capsule) return { success: false, error: 'Capsule not found' };

    if (capsule.buriedBy !== ownerId) {
      return { success: false, error: 'Only the capsule owner can add items' };
    }

    refreshStatus(capsule);

    if (capsule.status === STATUS_OPENED) {
      return { success: false, error: 'Cannot modify an opened capsule' };
    }
    if (capsule.status === STATUS_EXPIRED) {
      return { success: false, error: 'Cannot modify an expired capsule' };
    }

    var typeData = CAPSULE_TYPES[capsule.type];
    if (!typeData.canHaveItems) {
      return { success: false, error: 'This capsule type cannot hold items' };
    }
    if (capsule.items.length >= typeData.maxItems) {
      return {
        success: false,
        error: 'Capsule is at maximum capacity (' + typeData.maxItems + ' items)'
      };
    }

    if (!itemId || typeof itemId !== 'string') {
      return { success: false, error: 'Invalid itemId' };
    }

    capsule.items.push(itemId);
    return { success: true };
  }

  /**
   * Set or update the message in a capsule (owner only, not yet opened).
   * @param {string} capsuleId
   * @param {string} ownerId
   * @param {string} message
   * @returns {{ success: boolean, error?: string }}
   */
  function setMessage(capsuleId, ownerId, message) {
    var capsule = capsules[capsuleId];
    if (!capsule) return { success: false, error: 'Capsule not found' };

    if (capsule.buriedBy !== ownerId) {
      return { success: false, error: 'Only the capsule owner can set the message' };
    }

    refreshStatus(capsule);

    if (capsule.status === STATUS_OPENED) {
      return { success: false, error: 'Cannot modify an opened capsule' };
    }
    if (capsule.status === STATUS_EXPIRED) {
      return { success: false, error: 'Cannot modify an expired capsule' };
    }

    var result = sanitizeMessage(message);
    if (!result.ok) return { success: false, error: result.error };

    capsule.message = result.clean;
    return { success: true };
  }

  /**
   * Return all capsules located in a named zone.
   * Zone must be set in capsule.zone at burial time via contents.zone.
   * @param {string} zone
   * @returns {Array<object>} sanitized markers (no content)
   */
  function getCapsulesByZone(zone) {
    var results = [];
    var ids = Object.keys(capsules);
    for (var i = 0; i < ids.length; i++) {
      var c = capsules[ids[i]];
      if (c.zone === zone) {
        refreshStatus(c);
        results.push({
          id:       c.id,
          position: { x: c.position.x, z: c.position.z },
          type:     c.type,
          material: c.material,
          status:   c.status,
          buriedAt: c.buriedAt,
          unlockAt: c.unlockAt
        });
      }
    }
    return results;
  }

  /**
   * Return a world-news feed of recently opened capsules.
   * @param {number} limit - max entries to return (default 10)
   * @returns {Array<object>}
   */
  function getRecentlyOpened(limit) {
    if (typeof limit !== 'number' || limit <= 0) limit = 10;

    var opened = [];
    var ids = Object.keys(capsules);
    for (var i = 0; i < ids.length; i++) {
      var c = capsules[ids[i]];
      if (c.status === STATUS_OPENED && c.openedAt) {
        opened.push({
          id:        c.id,
          type:      c.type,
          material:  c.material,
          buriedBy:  c.buriedBy,
          openedBy:  c.openedBy,
          openedAt:  c.openedAt,
          zone:      c.zone,
          itemCount: c.items.length,
          hasMessage: c.message.length > 0
        });
      }
    }

    // Sort by openedAt descending (most recent first)
    opened.sort(function(a, b) { return b.openedAt - a.openedAt; });

    return opened.slice(0, limit);
  }

  /**
   * Calculate the Spark cost to bury a capsule.
   * Cost = type.baseSparkCost * material.sparkMultiplier
   *
   * @param {string} type
   * @param {string} material
   * @returns {number} Spark cost, or -1 if invalid type/material
   */
  function calculateBurialCost(type, material) {
    var typeData     = CAPSULE_TYPES[type];
    var materialData = CAPSULE_MATERIALS[material];
    if (!typeData || !materialData) return -1;
    return typeData.baseSparkCost * materialData.sparkMultiplier;
  }

  /**
   * Return the maximum number of items a capsule type can hold.
   * @param {string} type
   * @returns {number} or -1 if invalid type
   */
  function getCapsuleCapacity(type) {
    var typeData = CAPSULE_TYPES[type];
    if (!typeData) return -1;
    return typeData.maxItems;
  }

  /**
   * Check whether a capsule has decayed/expired.
   * @param {object} capsule - a capsule object (not an id)
   * @returns {boolean}
   */
  function isExpired(capsule) {
    if (!capsule) return false;
    var status = computeStatus(capsule);
    return status === STATUS_EXPIRED;
  }

  // =========================================================================
  // STATE PERSISTENCE HELPERS
  // =========================================================================

  /**
   * Load serialized capsule state (e.g. from JSON storage).
   * @param {object} data - { capsules: {}, capsuleCounter: number }
   */
  function initCapsules(data) {
    if (!data) return;
    capsules        = data.capsules || {};
    capsuleCounter  = data.capsuleCounter || 0;
  }

  /**
   * Return the full state for serialization.
   * @returns {object}
   */
  function getCapsuleState() {
    return {
      capsules:        capsules,
      capsuleCounter:  capsuleCounter
    };
  }

  /**
   * Reset all state (for testing).
   */
  function resetCapsules() {
    capsules        = {};
    capsuleCounter  = 0;
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.CAPSULE_TYPES        = CAPSULE_TYPES;
  exports.CAPSULE_MATERIALS    = CAPSULE_MATERIALS;
  exports.DISCOVERY_RADIUS     = DISCOVERY_RADIUS;
  exports.MAX_CAPSULES_PER_PLAYER = MAX_CAPSULES_PER_PLAYER;
  exports.MAX_MESSAGE_LENGTH   = MAX_MESSAGE_LENGTH;
  exports.STATUS_BURIED        = STATUS_BURIED;
  exports.STATUS_READY         = STATUS_READY;
  exports.STATUS_OPENED        = STATUS_OPENED;
  exports.STATUS_EXPIRED       = STATUS_EXPIRED;

  exports.buryCapsule          = buryCapsule;
  exports.digUpCapsule         = digUpCapsule;
  exports.getCapsuleStatus     = getCapsuleStatus;
  exports.getNearbyCapsules    = getNearbyCapsules;
  exports.getCapsuleHint       = getCapsuleHint;
  exports.openCapsule          = openCapsule;
  exports.getPlayerBuriedCapsules = getPlayerBuriedCapsules;
  exports.getPlayerOpenedCapsules = getPlayerOpenedCapsules;
  exports.getTimeRemaining     = getTimeRemaining;
  exports.formatTimeRemaining  = formatTimeRemaining;
  exports.addItemToCapsule     = addItemToCapsule;
  exports.setMessage           = setMessage;
  exports.getCapsulesByZone    = getCapsulesByZone;
  exports.getRecentlyOpened    = getRecentlyOpened;
  exports.calculateBurialCost  = calculateBurialCost;
  exports.getCapsuleCapacity   = getCapsuleCapacity;
  exports.isExpired            = isExpired;
  exports.sanitizeMessage      = sanitizeMessage;

  // Persistence
  exports.initCapsules         = initCapsules;
  exports.getCapsuleState      = getCapsuleState;
  exports.resetCapsules        = resetCapsules;

})(typeof module !== 'undefined' ? module.exports : (window.TimeCapsules = {}));


// progression.js
// progression.js
/**
 * ZION Player Progression & Skill Tree System
 * XP tracking, leveling, and six-tree skill advancement
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // XP SOURCES
  // ============================================================================

  var XP_SOURCES = {
    crafting:       10,
    trading:        15,
    fishing:         8,
    dungeon_clear:  50,
    card_win:       20,
    quest_complete: 25,
    gathering:       5,
    social:         10,
    exploring:      12,
    teaching:       30
  };

  // ============================================================================
  // SKILL TREES
  // ============================================================================

  var SKILL_TREES = {
    crafting: {
      name: 'Artisan',
      tiers: [
        'Novice Crafter',
        'Journeyman',
        'Artisan',
        'Master Artisan',
        'Grand Artisan'
      ],
      perks: [
        'craft_speed_10',
        'craft_speed_25',
        'rare_recipe_unlock',
        'craft_crit_chance',
        'masterwork_chance'
      ]
    },
    combat: {
      name: 'Warrior',
      tiers: [
        'Recruit',
        'Fighter',
        'Warrior',
        'Champion',
        'Legend'
      ],
      perks: [
        'damage_10',
        'defense_10',
        'dungeon_loot_bonus',
        'boss_damage_25',
        'double_loot'
      ]
    },
    gathering: {
      name: 'Harvester',
      tiers: [
        'Forager',
        'Gatherer',
        'Harvester',
        'Expert Harvester',
        "Nature's Hand"
      ],
      perks: [
        'gather_speed_10',
        'rare_resource_5',
        'double_gather_10',
        'auto_replant',
        'legendary_resource'
      ]
    },
    social: {
      name: 'Diplomat',
      tiers: [
        'Newcomer',
        'Socialite',
        'Diplomat',
        'Ambassador',
        'Elder'
      ],
      perks: [
        'trade_discount_5',
        'npc_friendship_bonus',
        'guild_bonus',
        'reputation_gain_25',
        'zone_influence'
      ]
    },
    exploration: {
      name: 'Pathfinder',
      tiers: [
        'Wanderer',
        'Scout',
        'Pathfinder',
        'Trailblazer',
        'World Walker'
      ],
      perks: [
        'travel_cost_10',
        'map_reveal',
        'fast_travel_unlock',
        'hidden_area_access',
        'teleport_anywhere'
      ]
    },
    knowledge: {
      name: 'Scholar',
      tiers: [
        'Student',
        'Apprentice',
        'Scholar',
        'Sage',
        'Archmage'
      ],
      perks: [
        'xp_gain_10',
        'lesson_bonus',
        'research_unlock',
        'teach_mastery',
        'enlightenment'
      ]
    }
  };

  // Tier costs: tier index 0â†’1pt, 1â†’2pt, 2â†’3pt, 3â†’4pt, 4â†’5pt
  var TIER_COSTS = [1, 2, 3, 4, 5];

  // ============================================================================
  // LEVEL TITLES
  // ============================================================================

  var LEVEL_TITLES = [
    { min: 1,  max: 5,  title: 'Newcomer'    },
    { min: 6,  max: 10, title: 'Initiate'    },
    { min: 11, max: 15, title: 'Adventurer'  },
    { min: 16, max: 20, title: 'Journeyman'  },
    { min: 21, max: 25, title: 'Veteran'     },
    { min: 26, max: 30, title: 'Expert'      },
    { min: 31, max: 35, title: 'Master'      },
    { min: 36, max: 40, title: 'Grand Master' },
    { min: 41, max: 45, title: 'Champion'    },
    { min: 46, max: 50, title: 'Legend'      }
  ];

  var MAX_LEVEL = 50;

  // ============================================================================
  // PERK DESCRIPTIONS
  // ============================================================================

  var PERK_DESCRIPTIONS = {
    craft_speed_10:       '+10% crafting speed',
    craft_speed_25:       '+25% crafting speed',
    rare_recipe_unlock:   'Unlock rare crafting recipes',
    craft_crit_chance:    '15% chance to craft double items',
    masterwork_chance:    '10% chance to craft masterwork quality',
    damage_10:            '+10% damage output',
    defense_10:           '+10% defense',
    dungeon_loot_bonus:   '+20% dungeon loot',
    boss_damage_25:       '+25% damage to bosses',
    double_loot:          '10% chance to double all loot',
    gather_speed_10:      '+10% gathering speed',
    rare_resource_5:      '+5% chance to find rare resources',
    double_gather_10:     '10% chance to gather double resources',
    auto_replant:         'Automatically replant harvested crops',
    legendary_resource:   '1% chance to find legendary resources',
    trade_discount_5:     '-5% trading fees',
    npc_friendship_bonus: '+25% NPC friendship gain',
    guild_bonus:          '+15% guild activity rewards',
    reputation_gain_25:   '+25% reputation gain',
    zone_influence:       'Gain influence over a zone',
    travel_cost_10:       '-10% fast travel cost',
    map_reveal:           'Reveal nearby map areas automatically',
    fast_travel_unlock:   'Unlock additional fast travel points',
    hidden_area_access:   'Access hidden exploration areas',
    teleport_anywhere:    'Teleport to any visited location',
    xp_gain_10:           '+10% XP from all sources',
    lesson_bonus:         '+20% XP when learning from NPCs',
    research_unlock:      'Unlock research projects',
    teach_mastery:        'Double XP awarded when teaching others',
    enlightenment:        '+50% XP from all sources for 1 hour daily'
  };

  // ============================================================================
  // CORE LEVEL MATH
  // ============================================================================

  /**
   * Calculate level from total XP.
   * level = floor(sqrt(totalXP / 100)) + 1, capped at MAX_LEVEL
   * @param {number} totalXP
   * @returns {number} level 1..50
   */
  function getLevel(totalXP) {
    if (totalXP < 0) totalXP = 0;
    var raw = Math.floor(Math.sqrt(totalXP / 100)) + 1;
    return Math.min(raw, MAX_LEVEL);
  }

  /**
   * Calculate XP required to reach a specific level.
   * xp = (level - 1)^2 * 100
   * @param {number} level
   * @returns {number} XP threshold
   */
  function getXPForLevel(level) {
    if (level < 1) level = 1;
    if (level > MAX_LEVEL) level = MAX_LEVEL;
    return (level - 1) * (level - 1) * 100;
  }

  /**
   * XP needed to reach the next level from current state.
   * @param {Object} state player progression state
   * @returns {number} XP remaining to next level (0 if at max level)
   */
  function getXPToNextLevel(state) {
    var currentLevel = getLevel(state.totalXP);
    if (currentLevel >= MAX_LEVEL) return 0;
    var nextLevelXP = getXPForLevel(currentLevel + 1);
    return nextLevelXP - state.totalXP;
  }

  // ============================================================================
  // PLAYER STATE
  // ============================================================================

  /**
   * Create a fresh player progression object.
   * @param {string} playerId
   * @returns {Object}
   */
  function createPlayerProgression(playerId) {
    return {
      playerId:     playerId,
      totalXP:      0,
      level:        1,
      skillPoints:  0,
      skills: {
        crafting:    0,
        combat:      0,
        gathering:   0,
        social:      0,
        exploration: 0,
        knowledge:   0
      },
      xpHistory: [],
      perks:     []
    };
  }

  // ============================================================================
  // XP & LEVELING
  // ============================================================================

  /**
   * Award XP to a player, handling level-ups and skill point grants.
   * @param {Object} state  player progression state (not mutated â€” returns new state)
   * @param {string} source XP source key from XP_SOURCES or custom
   * @param {number} amount  XP amount (defaults to XP_SOURCES[source] if omitted)
   * @returns {{ state, leveled, newLevel, skillPointsGained, message }}
   */
  function awardXP(state, source, amount) {
    // Determine XP amount
    var xpAmount = (typeof amount === 'number') ? amount : (XP_SOURCES[source] || 0);

    // Apply knowledge perk: xp_gain_10 gives +10%
    if (hasPerks(state, 'xp_gain_10')) {
      xpAmount = Math.floor(xpAmount * 1.10);
    }
    // enlightenment: +50% (stacks additively on top of xp_gain_10 if both present)
    if (hasPerks(state, 'enlightenment')) {
      xpAmount = Math.floor(xpAmount * 1.50);
    }
    // lesson_bonus: +20% when source is social/teaching
    if (hasPerks(state, 'lesson_bonus') && (source === 'social' || source === 'teaching')) {
      xpAmount = Math.floor(xpAmount * 1.20);
    }
    // teach_mastery: double XP from teaching
    if (hasPerks(state, 'teach_mastery') && source === 'teaching') {
      xpAmount = Math.floor(xpAmount * 2);
    }

    var oldLevel   = getLevel(state.totalXP);
    var newTotalXP = state.totalXP + xpAmount;

    // Cap at max-level XP ceiling so we never exceed getXPForLevel(MAX_LEVEL+1) in a meaningful way
    var newLevel = getLevel(newTotalXP);
    var leveled  = newLevel > oldLevel;
    var skillPointsGained = leveled ? (newLevel - oldLevel) : 0;

    // Build updated history entry
    var historyEntry = {
      source:    source,
      amount:    xpAmount,
      timestamp: Date.now(),
      totalAfter: newTotalXP
    };

    // Build new state (immutable-style copy)
    var newState = _cloneState(state);
    newState.totalXP     = newTotalXP;
    newState.level       = newLevel;
    newState.skillPoints = (newState.skillPoints || 0) + skillPointsGained;
    newState.xpHistory   = (newState.xpHistory || []).concat([historyEntry]);

    var message;
    if (leveled) {
      message = 'Level up! You are now level ' + newLevel + '. Gained ' + skillPointsGained + ' skill point(s).';
    } else {
      message = 'Gained ' + xpAmount + ' XP from ' + source + '.';
    }

    return {
      state:             newState,
      leveled:           leveled,
      newLevel:          newLevel,
      skillPointsGained: skillPointsGained,
      message:           message
    };
  }

  // ============================================================================
  // SKILL POINTS & TREES
  // ============================================================================

  /**
   * Get the current tier (0â€“5) for a skill tree.
   * 0 = no tier unlocked, 5 = all tiers unlocked.
   * @param {Object} state
   * @param {string} tree  tree key
   * @returns {number} 0..5
   */
  function getSkillTier(state, tree) {
    if (!state.skills || typeof state.skills[tree] === 'undefined') return 0;
    return state.skills[tree];
  }

  /**
   * Spend a skill point to unlock the next tier in a tree.
   * @param {Object} state
   * @param {string} tree
   * @returns {{ state, success, perk, tierName, message }}
   */
  function spendSkillPoint(state, tree) {
    var treeData = SKILL_TREES[tree];
    if (!treeData) {
      return {
        state:    state,
        success:  false,
        perk:     null,
        tierName: null,
        message:  'Unknown skill tree: ' + tree
      };
    }

    var currentTier = getSkillTier(state, tree);
    var maxTiers    = treeData.tiers.length; // 5

    if (currentTier >= maxTiers) {
      return {
        state:    state,
        success:  false,
        perk:     null,
        tierName: null,
        message:  'Tree "' + treeData.name + '" is already fully unlocked.'
      };
    }

    var cost = TIER_COSTS[currentTier]; // index 0 costs 1pt, etc.
    if ((state.skillPoints || 0) < cost) {
      return {
        state:    state,
        success:  false,
        perk:     null,
        tierName: null,
        message:  'Not enough skill points. Need ' + cost + ', have ' + (state.skillPoints || 0) + '.'
      };
    }

    var newTier    = currentTier + 1;
    var perkId     = treeData.perks[currentTier];
    var tierName   = treeData.tiers[currentTier];

    var newState = _cloneState(state);
    newState.skills       = _cloneSkills(state.skills);
    newState.skills[tree] = newTier;
    newState.skillPoints  = (state.skillPoints || 0) - cost;
    newState.perks        = (state.perks || []).concat([perkId]);

    return {
      state:    newState,
      success:  true,
      perk:     perkId,
      tierName: tierName,
      message:  'Unlocked ' + tierName + ' in ' + treeData.name + '. Perk: ' + (PERK_DESCRIPTIONS[perkId] || perkId)
    };
  }

  // ============================================================================
  // PERK SYSTEM
  // ============================================================================

  /**
   * Check if a player has a specific perk active.
   * @param {Object} state
   * @param {string} perkId
   * @returns {boolean}
   */
  function hasPerks(state, perkId) {
    if (!state || !state.perks) return false;
    return state.perks.indexOf(perkId) !== -1;
  }

  /**
   * Get all active perks with descriptions.
   * @param {Object} state
   * @returns {Array<{ perkId, description, tree, tier }>}
   */
  function getActivePerks(state) {
    if (!state || !state.perks || state.perks.length === 0) return [];

    return state.perks.map(function(perkId) {
      // Find which tree + tier this perk belongs to
      var treeName = null;
      var tierIdx  = -1;
      var treeKey  = null;
      var keys = Object.keys(SKILL_TREES);
      for (var i = 0; i < keys.length; i++) {
        var k    = keys[i];
        var idx  = SKILL_TREES[k].perks.indexOf(perkId);
        if (idx !== -1) {
          treeName = SKILL_TREES[k].name;
          tierIdx  = idx + 1; // 1-based tier number
          treeKey  = k;
          break;
        }
      }
      return {
        perkId:      perkId,
        description: PERK_DESCRIPTIONS[perkId] || perkId,
        tree:        treeName,
        tier:        tierIdx
      };
    });
  }

  /**
   * Apply perk modifications to a base action value.
   * Handles numeric scaling perks based on action type.
   * @param {Object} state
   * @param {string} action  action keyword (e.g. 'craft', 'gather', 'trade', 'dungeon', 'xp')
   * @param {number} baseValue
   * @returns {number} modified value
   */
  function applyPerkBonus(state, action, baseValue) {
    var value = baseValue;

    switch (action) {
      case 'craft':
      case 'crafting':
        if (hasPerks(state, 'craft_speed_10')) value = value * 1.10;
        if (hasPerks(state, 'craft_speed_25')) value = value * 1.25;
        break;

      case 'gather':
      case 'gathering':
        if (hasPerks(state, 'gather_speed_10')) value = value * 1.10;
        if (hasPerks(state, 'double_gather_10')) {
          // probabilistic bonus â€” represented as expected value +10%
          value = value * 1.10;
        }
        break;

      case 'trade':
      case 'trading':
        if (hasPerks(state, 'trade_discount_5')) value = value * 0.95;
        break;

      case 'dungeon':
      case 'dungeon_loot':
        if (hasPerks(state, 'dungeon_loot_bonus')) value = value * 1.20;
        if (hasPerks(state, 'double_loot'))         value = value * 1.10;
        break;

      case 'damage':
        if (hasPerks(state, 'damage_10'))     value = value * 1.10;
        if (hasPerks(state, 'boss_damage_25')) value = value * 1.25;
        break;

      case 'defense':
        if (hasPerks(state, 'defense_10')) value = value * 1.10;
        break;

      case 'xp':
        if (hasPerks(state, 'xp_gain_10'))   value = value * 1.10;
        if (hasPerks(state, 'enlightenment')) value = value * 1.50;
        break;

      case 'reputation':
        if (hasPerks(state, 'reputation_gain_25')) value = value * 1.25;
        break;

      case 'travel':
        if (hasPerks(state, 'travel_cost_10')) value = value * 0.90;
        break;

      case 'lesson':
      case 'teaching':
        if (hasPerks(state, 'lesson_bonus'))  value = value * 1.20;
        if (hasPerks(state, 'teach_mastery')) value = value * 2.00;
        break;

      case 'npc_friendship':
        if (hasPerks(state, 'npc_friendship_bonus')) value = value * 1.25;
        break;

      case 'guild':
        if (hasPerks(state, 'guild_bonus')) value = value * 1.15;
        break;

      default:
        break;
    }

    return value;
  }

  // ============================================================================
  // PROGRESSION SUMMARY
  // ============================================================================

  /**
   * Returns a formatted summary of all skill trees and player progress.
   * @param {Object} state
   * @returns {Object} summary object
   */
  function getProgressionSummary(state) {
    var level     = getLevel(state.totalXP);
    var xpToNext  = getXPToNextLevel(state);
    var xpCurrent = state.totalXP - getXPForLevel(level);
    var xpNeeded  = (level < MAX_LEVEL) ? (getXPForLevel(level + 1) - getXPForLevel(level)) : 0;

    var treesSummary = [];
    var treeKeys = Object.keys(SKILL_TREES);
    for (var i = 0; i < treeKeys.length; i++) {
      var key      = treeKeys[i];
      var tree     = SKILL_TREES[key];
      var tier     = getSkillTier(state, key);
      var perksArr = [];
      for (var t = 0; t < tier; t++) {
        perksArr.push(tree.perks[t]);
      }
      treesSummary.push({
        key:          key,
        name:         tree.name,
        currentTier:  tier,
        maxTiers:     tree.tiers.length,
        tierName:     tier > 0 ? tree.tiers[tier - 1] : 'Unlocked',
        nextTierName: tier < tree.tiers.length ? tree.tiers[tier] : null,
        perksUnlocked: perksArr,
        nextTierCost: tier < TIER_COSTS.length ? TIER_COSTS[tier] : null
      });
    }

    return {
      playerId:        state.playerId,
      level:           level,
      title:           getTitle(level),
      totalXP:         state.totalXP,
      xpCurrentLevel:  xpCurrent,
      xpNeededForNext: xpNeeded,
      xpToNextLevel:   xpToNext,
      progressBar:     formatProgressBar(xpCurrent, xpNeeded),
      skillPoints:     state.skillPoints || 0,
      trees:           treesSummary,
      totalPerks:      (state.perks || []).length,
      perks:           getActivePerks(state)
    };
  }

  // ============================================================================
  // FORMATTING HELPERS
  // ============================================================================

  /**
   * Get the title for a given level.
   * @param {number} level
   * @returns {string}
   */
  function getTitle(level) {
    for (var i = 0; i < LEVEL_TITLES.length; i++) {
      var bracket = LEVEL_TITLES[i];
      if (level >= bracket.min && level <= bracket.max) {
        return bracket.title;
      }
    }
    return 'Legend';
  }

  /**
   * Render an ASCII progress bar.
   * Example: [####------] 40%
   * @param {number} current  current value
   * @param {number} max      maximum value
   * @param {number} [width]  total bar width (default 10)
   * @returns {string}
   */
  function formatProgressBar(current, max, width) {
    width = width || 10;
    if (max <= 0) return '[' + new Array(width + 1).join('#') + '] 100%';
    var ratio   = Math.min(current / max, 1);
    var filled  = Math.floor(ratio * width);
    var empty   = width - filled;
    var pct     = Math.floor(ratio * 100);
    var bar     = '[' + new Array(filled + 1).join('#') + new Array(empty + 1).join('-') + '] ' + pct + '%';
    return bar;
  }

  /**
   * Render an HTML string for a skill tree panel.
   * @param {string} tree       tree key (e.g. 'crafting')
   * @param {number} currentTier current tier (0-5)
   * @returns {string} HTML
   */
  function formatSkillTree(tree, currentTier) {
    var treeData = SKILL_TREES[tree];
    if (!treeData) return '<div class="skill-tree-error">Unknown tree: ' + tree + '</div>';

    currentTier = currentTier || 0;
    var html = '<div class="skill-tree" data-tree="' + tree + '">';
    html += '<h3 class="skill-tree-name">' + treeData.name + '</h3>';
    html += '<div class="skill-tree-tiers">';

    for (var i = 0; i < treeData.tiers.length; i++) {
      var tierName   = treeData.tiers[i];
      var perkId     = treeData.perks[i];
      var isUnlocked = (i < currentTier);
      var isCurrent  = (i === currentTier - 1);
      var isNext     = (i === currentTier);
      var cost       = TIER_COSTS[i];

      var cls = 'skill-tier';
      if (isUnlocked) cls += ' skill-tier--unlocked';
      if (isCurrent)  cls += ' skill-tier--current';
      if (isNext)     cls += ' skill-tier--next';

      html += '<div class="' + cls + '" data-tier="' + (i + 1) + '">';
      html += '<span class="skill-tier-name">' + tierName + '</span>';
      html += '<span class="skill-tier-perk">' + (PERK_DESCRIPTIONS[perkId] || perkId) + '</span>';
      if (!isUnlocked) {
        html += '<span class="skill-tier-cost">' + cost + ' pt' + (cost > 1 ? 's' : '') + '</span>';
      } else {
        html += '<span class="skill-tier-status">Unlocked</span>';
      }
      html += '</div>';
    }

    html += '</div></div>';
    return html;
  }

  // ============================================================================
  // INTERNAL HELPERS
  // ============================================================================

  function _cloneState(state) {
    return {
      playerId:    state.playerId,
      totalXP:     state.totalXP,
      level:       state.level,
      skillPoints: state.skillPoints,
      skills:      _cloneSkills(state.skills),
      xpHistory:   (state.xpHistory || []).slice(),
      perks:       (state.perks || []).slice()
    };
  }

  function _cloneSkills(skills) {
    return {
      crafting:    skills.crafting    || 0,
      combat:      skills.combat      || 0,
      gathering:   skills.gathering   || 0,
      social:      skills.social      || 0,
      exploration: skills.exploration || 0,
      knowledge:   skills.knowledge   || 0
    };
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.XP_SOURCES             = XP_SOURCES;
  exports.SKILL_TREES            = SKILL_TREES;
  exports.MAX_LEVEL              = MAX_LEVEL;
  exports.TIER_COSTS             = TIER_COSTS;
  exports.PERK_DESCRIPTIONS      = PERK_DESCRIPTIONS;

  exports.createPlayerProgression = createPlayerProgression;
  exports.awardXP                 = awardXP;
  exports.getLevel                = getLevel;
  exports.getXPForLevel           = getXPForLevel;
  exports.getXPToNextLevel        = getXPToNextLevel;
  exports.spendSkillPoint         = spendSkillPoint;
  exports.getSkillTier            = getSkillTier;
  exports.hasPerks                = hasPerks;
  exports.getActivePerks          = getActivePerks;
  exports.applyPerkBonus          = applyPerkBonus;
  exports.getProgressionSummary   = getProgressionSummary;
  exports.getTitle                = getTitle;
  exports.formatProgressBar       = formatProgressBar;
  exports.formatSkillTree         = formatSkillTree;

})(typeof module !== 'undefined' ? module.exports : (window.Progression = {}));


// npc_reputation.js
// npc_reputation.js
/**
 * ZION NPC Reputation System
 * Reputation-based NPC relationships with dynamic dialogue unlocks.
 * NPCs remember player actions and change behavior based on trust level.
 */

(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // CONSTANTS
  // ---------------------------------------------------------------------------

  var REPUTATION_MIN = -100;
  var REPUTATION_MAX = 100;

  var TIERS = [
    { min: -100, max: -75, name: 'Hostile',    color: '#ff0000', dialoguePool: 'hostile' },
    { min: -74,  max: -50, name: 'Distrusted', color: '#ff4444', dialoguePool: 'distrusted' },
    { min: -49,  max: -25, name: 'Disliked',   color: '#ff8888', dialoguePool: 'disliked' },
    { min: -24,  max: -1,  name: 'Wary',       color: '#ffaaaa', dialoguePool: 'wary' },
    { min: 0,    max: 14,  name: 'Neutral',    color: '#cccccc', dialoguePool: 'neutral' },
    { min: 15,   max: 29,  name: 'Known',      color: '#aaddaa', dialoguePool: 'known' },
    { min: 30,   max: 49,  name: 'Friendly',   color: '#88cc88', dialoguePool: 'friendly' },
    { min: 50,   max: 69,  name: 'Trusted',    color: '#44aa44', dialoguePool: 'trusted' },
    { min: 70,   max: 89,  name: 'Honored',    color: '#228822', dialoguePool: 'honored' },
    { min: 90,   max: 100, name: 'Sworn Ally', color: '#00ff00', dialoguePool: 'ally' }
  ];

  var REPUTATION_ACTIONS = {
    trade_with:     { base: 2,   desc: 'Traded with NPC' },
    complete_quest: { base: 10,  desc: 'Completed a quest from NPC' },
    gift_item:      { base: 5,   desc: 'Gave a gift' },
    gift_liked:     { base: 15,  desc: 'Gave a favorite gift' },
    gift_disliked:  { base: -5,  desc: 'Gave a disliked gift' },
    help_event:     { base: 8,   desc: 'Helped during an event' },
    daily_greeting: { base: 1,   desc: 'Said hello today' },
    fail_quest:     { base: -5,  desc: 'Failed a quest' },
    steal_attempt:  { base: -20, desc: 'Attempted theft' },
    mentored_by:    { base: 12,  desc: 'Learned from this NPC' },
    defended:       { base: 15,  desc: 'Defended NPC from threat' },
    ignored_plea:   { base: -8,  desc: 'Ignored a plea for help' }
  };

  var ARCHETYPE_PREFERENCES = {
    gardener:    { likedGifts: ['seeds','herbs','honey'],                   dislikedGifts: ['iron_ore','stone'],         topics: ['nature','seasons','growth'] },
    builder:     { likedGifts: ['planks','nails','blueprint'],              dislikedGifts: ['scroll','ink'],             topics: ['architecture','design','materials'] },
    storyteller: { likedGifts: ['scroll','ink','journal'],                  dislikedGifts: ['pickaxe','axe'],            topics: ['history','legends','poetry'] },
    merchant:    { likedGifts: ['gold_dust','trade_permit','lockbox'],      dislikedGifts: ['herbs','clay'],             topics: ['markets','prices','deals'] },
    explorer:    { likedGifts: ['compass','rope','map_fragment'],           dislikedGifts: ['clay','silk'],              topics: ['adventures','discoveries','terrain'] },
    teacher:     { likedGifts: ['textbook','chalk','lens'],                 dislikedGifts: ['drum_skin','strings'],      topics: ['learning','wisdom','philosophy'] },
    musician:    { likedGifts: ['strings','drum_skin','sheet_music'],       dislikedGifts: ['nails','pickaxe'],          topics: ['music','harmony','rhythm'] },
    healer:      { likedGifts: ['herbs','bandage','salve'],                 dislikedGifts: ['iron_ore','stone'],         topics: ['healing','wellness','herbs'] },
    philosopher: { likedGifts: ['riddle_box','star_chart','scroll'],        dislikedGifts: ['axe','nails'],              topics: ['truth','existence','ethics'] },
    artist:      { likedGifts: ['pigment','canvas','chisel'],               dislikedGifts: ['lockbox','scale'],          topics: ['beauty','creation','inspiration'] }
  };

  // Dialogue pools keyed by pool name, then by context
  var DIALOGUE_POOLS = {
    hostile: {
      greeting: [
        "Leave. Now.",
        "I have nothing to say to you.",
        "Get away from me.",
        "You have the nerve to approach me?"
      ],
      farewell: [
        "Good riddance.",
        "Stay away."
      ],
      shop: [
        "I won't do business with you.",
        "Find another merchant."
      ],
      quest: [
        "I would never trust you with this.",
        "You'd only make things worse."
      ],
      gossip: [
        "I'm not talking to you.",
        "Leave me alone."
      ]
    },
    distrusted: {
      greeting: [
        "What do you want?",
        "Keep your distance.",
        "I don't trust you.",
        "Speak quickly and leave."
      ],
      farewell: [
        "Don't come back soon.",
        "Next time, don't bother."
      ],
      shop: [
        "Full price. No exceptions.",
        "Pay first, then we'll talk."
      ],
      quest: [
        "You'd have to prove yourself first.",
        "I doubt you could handle this."
      ],
      gossip: [
        "Why would I tell you anything?",
        "I've heard enough about you already."
      ]
    },
    disliked: {
      greeting: [
        "Oh. You again.",
        "Hmm. What now?",
        "I suppose I can spare a moment.",
        "Make it brief."
      ],
      farewell: [
        "Off with you then.",
        "Until next time, I suppose."
      ],
      shop: [
        "Standard rates apply.",
        "Don't expect any favors."
      ],
      quest: [
        "There might be something you could do... if you're capable.",
        "It's not much, but you might manage it."
      ],
      gossip: [
        "I've heard a thing or two.",
        "Nothing worth your time, probably."
      ]
    },
    wary: {
      greeting: [
        "Ah. Hello.",
        "You've been around lately.",
        "I've seen you before.",
        "What brings you here?"
      ],
      farewell: [
        "Take care.",
        "Until next time."
      ],
      shop: [
        "I have some wares, if you're interested.",
        "Browse freely."
      ],
      quest: [
        "I might have something for someone willing to help.",
        "There's a task I've been putting off..."
      ],
      gossip: [
        "I've heard a few things lately.",
        "Word travels fast in ZION."
      ]
    },
    neutral: {
      greeting: [
        "Hello, traveler.",
        "Welcome.",
        "Good day.",
        "Greetings."
      ],
      farewell: [
        "Safe travels.",
        "Farewell.",
        "Until we meet again."
      ],
      shop: [
        "Take a look at what I have.",
        "Everything is priced fairly.",
        "What can I help you with?"
      ],
      quest: [
        "I could use some assistance.",
        "There's something that needs doing."
      ],
      gossip: [
        "The usual news, nothing special.",
        "Things are quiet these days."
      ]
    },
    known: {
      greeting: [
        "Ah, good to see you.",
        "Welcome back.",
        "I was hoping you'd stop by.",
        "How have you been?"
      ],
      farewell: [
        "Come back soon.",
        "It's always a pleasure.",
        "Safe journeys."
      ],
      shop: [
        "I saved something interesting for you.",
        "For a familiar face, I'll see what I can do.",
        "You know where to find the good stuff."
      ],
      quest: [
        "I have a task I think suits you.",
        "You're just the person I needed to see."
      ],
      gossip: [
        "Since you're a regular, I'll share what I know.",
        "Between you and me, I've heard something."
      ]
    },
    friendly: {
      greeting: [
        "My friend! Good to see you!",
        "Always happy when you come by.",
        "Just the person I wanted to talk to!",
        "Welcome, welcome!"
      ],
      farewell: [
        "Don't be a stranger!",
        "Come back whenever you like.",
        "It's always a pleasure, friend."
      ],
      shop: [
        "For you? I'll give you a little discount.",
        "Friends get special treatment here.",
        "Let me show you my better selection."
      ],
      quest: [
        "I have a special task only a friend would understand.",
        "I've been saving this one for you."
      ],
      gossip: [
        "I'll tell you something not many know.",
        "Since we're friends, here's a secret tip."
      ]
    },
    trusted: {
      greeting: [
        "Ah, one of the few people I truly trust.",
        "You're always welcome here.",
        "I think of you as a real ally.",
        "I'm glad you're here."
      ],
      farewell: [
        "I'll keep a good word in for you.",
        "My door is always open for you.",
        "Stay safe out there."
      ],
      shop: [
        "Take what you need â€” I'll work out fair payment.",
        "For you, I have items not on public display.",
        "I've been holding back some rare stock for trusted customers."
      ],
      quest: [
        "I have a rare quest I only share with trusted companions.",
        "This mission requires someone I know won't let me down."
      ],
      gossip: [
        "I'll share a rare recipe with you.",
        "There's a location only a few know about..."
      ]
    },
    honored: {
      greeting: [
        "The honored one arrives!",
        "You grace us with your presence.",
        "I feel safer knowing you're around.",
        "Always an honor to see you."
      ],
      farewell: [
        "ZION is better with you in it.",
        "We'll remember your deeds here.",
        "Walk tall."
      ],
      shop: [
        "For someone of your standing, the best prices.",
        "I have things reserved for the truly respected.",
        "Name your need â€” I'll do what I can."
      ],
      quest: [
        "I have a task worthy of your reputation.",
        "Only someone of honor could attempt this."
      ],
      gossip: [
        "I'll share the location of a secret place.",
        "They say the ancient texts mention something hidden..."
      ]
    },
    ally: {
      greeting: [
        "My sworn ally! I am always at your side.",
        "Nothing brings me more joy than seeing you.",
        "You are as family to me now.",
        "My friend, my ally, my companion."
      ],
      farewell: [
        "I swear to stand with you always.",
        "Call on me and I will answer.",
        "Until we meet again, ally."
      ],
      shop: [
        "Take what you need â€” you've earned it.",
        "My rare stock is yours to browse.",
        "For a sworn ally, everything is at cost."
      ],
      quest: [
        "This is the most important task I have ever asked of anyone.",
        "Only my sworn ally could carry this burden."
      ],
      gossip: [
        "I will share everything I know with you.",
        "There is nothing I keep from a sworn ally."
      ]
    }
  };

  var FEATURE_THRESHOLDS = [
    { score: 90, feature: 'sworn_ally_perks',  desc: 'Sworn ally perks: free items, combat aid' },
    { score: 70, feature: 'secret_locations',   desc: 'Access to secret locations' },
    { score: 50, feature: 'rare_quests',         desc: 'Rare quest access' },
    { score: 30, feature: 'discount_shop',       desc: 'Shop discounts' },
    { score: 15, feature: 'personal_stories',    desc: 'Personal NPC stories' },
    { score: 0,  feature: 'basic_shop',          desc: 'Basic shop access' }
  ];

  // ---------------------------------------------------------------------------
  // CORE STATE
  // ---------------------------------------------------------------------------

  /**
   * Creates a fresh reputation state object.
   * @returns {Object} { players: {}, npcRelationships: {}, history: [] }
   */
  function createReputationState() {
    return {
      players: {},
      npcRelationships: {},
      history: []
    };
  }

  // ---------------------------------------------------------------------------
  // TIER HELPERS
  // ---------------------------------------------------------------------------

  /**
   * Returns the tier object for a given reputation score.
   * @param {number} score
   * @returns {Object} tier
   */
  function getTier(score) {
    for (var i = 0; i < TIERS.length; i++) {
      var tier = TIERS[i];
      if (score >= tier.min && score <= tier.max) {
        return tier;
      }
    }
    // Fallback: clamp to extremes
    if (score < REPUTATION_MIN) return TIERS[0];
    return TIERS[TIERS.length - 1];
  }

  // ---------------------------------------------------------------------------
  // REPUTATION GETTERS / SETTERS
  // ---------------------------------------------------------------------------

  /**
   * Returns reputation score for a player-NPC pair. Defaults to 0.
   * @param {Object} state
   * @param {string} playerId
   * @param {string} npcId
   * @returns {number}
   */
  function getReputation(state, playerId, npcId) {
    if (!state || !state.players) return 0;
    if (!state.players[playerId]) return 0;
    if (typeof state.players[playerId][npcId] === 'undefined') return 0;
    return state.players[playerId][npcId];
  }

  /**
   * Sets reputation for a player-NPC pair (clamped to -100..100).
   * @param {Object} state
   * @param {string} playerId
   * @param {string} npcId
   * @param {number} score
   */
  function setReputation(state, playerId, npcId, score) {
    if (!state.players[playerId]) {
      state.players[playerId] = {};
    }
    state.players[playerId][npcId] = Math.max(REPUTATION_MIN, Math.min(REPUTATION_MAX, score));
  }

  /**
   * Apply a reputation action, logging to history.
   * @param {Object} state
   * @param {string} playerId
   * @param {string} npcId
   * @param {string} action  - key from REPUTATION_ACTIONS
   * @param {Object} [context] - optional context object
   * @returns {Object} { state, change, newScore, tier, message }
   */
  function modifyReputation(state, playerId, npcId, action, context) {
    context = context || {};

    var actionDef = REPUTATION_ACTIONS[action];
    if (!actionDef) {
      return {
        state: state,
        change: 0,
        newScore: getReputation(state, playerId, npcId),
        tier: getTier(getReputation(state, playerId, npcId)),
        message: 'Unknown action: ' + action
      };
    }

    var oldScore = getReputation(state, playerId, npcId);
    var change = actionDef.base;

    // Context modifiers
    if (context.multiplier && typeof context.multiplier === 'number') {
      change = Math.round(change * context.multiplier);
    }

    var newScore = Math.max(REPUTATION_MIN, Math.min(REPUTATION_MAX, oldScore + change));
    setReputation(state, playerId, npcId, newScore);

    var tier = getTier(newScore);

    var historyEntry = {
      ts: context.ts || Date.now(),
      playerId: playerId,
      npcId: npcId,
      action: action,
      change: change,
      oldScore: oldScore,
      newScore: newScore,
      tierName: tier.name,
      desc: actionDef.desc
    };
    state.history.push(historyEntry);

    var crossed = '';
    var oldTier = getTier(oldScore);
    if (oldTier.name !== tier.name) {
      crossed = ' Relationship changed to ' + tier.name + '.';
    }

    return {
      state: state,
      change: change,
      newScore: newScore,
      tier: tier,
      message: actionDef.desc + ' (' + (change >= 0 ? '+' : '') + change + ').' + crossed
    };
  }

  // ---------------------------------------------------------------------------
  // DIALOGUE
  // ---------------------------------------------------------------------------

  /**
   * Returns appropriate dialogue based on archetype, tier, and context.
   * @param {string} npcArchetype
   * @param {Object} tier  - tier object (from getTier)
   * @param {string} [context] - 'greeting'|'farewell'|'shop'|'quest'|'gossip'
   * @returns {Object} { text, options: [{label, action}] }
   */
  function getDialogue(npcArchetype, tier, context) {
    context = context || 'greeting';
    var poolName = tier ? tier.dialoguePool : 'neutral';
    var pool = DIALOGUE_POOLS[poolName] || DIALOGUE_POOLS['neutral'];
    var lines = pool[context] || pool['greeting'];

    // Pick a line using a simple deterministic index based on archetype length
    var archetypeLen = npcArchetype ? npcArchetype.length : 0;
    var lineIndex = archetypeLen % lines.length;
    var text = lines[lineIndex];

    // Build options based on tier score
    var options = [];
    var score = tier ? tier.min : 0;

    if (poolName === 'hostile' || poolName === 'distrusted') {
      // Very limited options
      options = [{ label: 'Back away', action: 'leave' }];
    } else if (poolName === 'disliked' || poolName === 'wary') {
      options = [
        { label: 'Greet', action: 'greet' },
        { label: 'Leave', action: 'leave' }
      ];
    } else if (poolName === 'neutral' || poolName === 'known') {
      options = [
        { label: 'Talk', action: 'greet' },
        { label: 'Shop', action: 'shop' },
        { label: 'Leave', action: 'leave' }
      ];
    } else if (poolName === 'friendly') {
      options = [
        { label: 'Chat', action: 'greet' },
        { label: 'Shop', action: 'shop' },
        { label: 'Ask for quest', action: 'quest' },
        { label: 'Leave', action: 'leave' }
      ];
    } else if (poolName === 'trusted') {
      options = [
        { label: 'Chat', action: 'greet' },
        { label: 'Shop (rare items)', action: 'shop' },
        { label: 'Special quest', action: 'quest' },
        { label: 'Ask for secrets', action: 'gossip' },
        { label: 'Leave', action: 'leave' }
      ];
    } else if (poolName === 'honored' || poolName === 'ally') {
      options = [
        { label: 'Chat', action: 'greet' },
        { label: 'Shop (best items)', action: 'shop' },
        { label: 'Important quest', action: 'quest' },
        { label: 'Share secrets', action: 'gossip' },
        { label: 'Request aid', action: 'aid' },
        { label: 'Leave', action: 'leave' }
      ];
    }

    // Add archetype-flavored topic if preferences exist
    var prefs = ARCHETYPE_PREFERENCES[npcArchetype];
    if (prefs && prefs.topics && prefs.topics.length > 0 && context === 'gossip') {
      var topicIdx = archetypeLen % prefs.topics.length;
      text = text + ' I always enjoy talking about ' + prefs.topics[topicIdx] + '.';
    }

    return { text: text, options: options };
  }

  // ---------------------------------------------------------------------------
  // GIFT SYSTEM
  // ---------------------------------------------------------------------------

  /**
   * Returns 'liked', 'disliked', or 'neutral' for a gift given to an archetype.
   * @param {string} npcArchetype
   * @param {string} giftItemId
   * @returns {string}
   */
  function getGiftReaction(npcArchetype, giftItemId) {
    var prefs = ARCHETYPE_PREFERENCES[npcArchetype];
    if (!prefs) return 'neutral';

    if (prefs.likedGifts.indexOf(giftItemId) !== -1) return 'liked';
    if (prefs.dislikedGifts.indexOf(giftItemId) !== -1) return 'disliked';
    return 'neutral';
  }

  /**
   * Process gift giving with appropriate reputation change.
   * @param {Object} state
   * @param {string} playerId
   * @param {string} npcId
   * @param {string} npcArchetype
   * @param {string} giftItemId
   * @returns {Object} { state, reaction, change, message }
   */
  function processGift(state, playerId, npcId, npcArchetype, giftItemId) {
    var reaction = getGiftReaction(npcArchetype, giftItemId);
    var action;
    var message;

    if (reaction === 'liked') {
      action = 'gift_liked';
      message = 'They absolutely loved the ' + giftItemId + '!';
    } else if (reaction === 'disliked') {
      action = 'gift_disliked';
      message = 'They frowned at the ' + giftItemId + '.';
    } else {
      action = 'gift_item';
      message = 'They accepted the ' + giftItemId + '.';
    }

    var result = modifyReputation(state, playerId, npcId, action, { giftItemId: giftItemId });

    return {
      state: result.state,
      reaction: reaction,
      change: result.change,
      message: message
    };
  }

  // ---------------------------------------------------------------------------
  // FEATURE UNLOCKS
  // ---------------------------------------------------------------------------

  /**
   * Returns array of features unlocked at this reputation score.
   * @param {number} score
   * @returns {Array<string>}
   */
  function getUnlockedFeatures(score) {
    var features = [];
    for (var i = 0; i < FEATURE_THRESHOLDS.length; i++) {
      if (score >= FEATURE_THRESHOLDS[i].score) {
        features.push(FEATURE_THRESHOLDS[i].feature);
      }
    }
    return features;
  }

  // ---------------------------------------------------------------------------
  // RELATIONSHIP SUMMARIES
  // ---------------------------------------------------------------------------

  /**
   * Returns all NPC relationships for a player, sorted by score descending.
   * @param {Object} state
   * @param {string} playerId
   * @returns {Array<Object>}
   */
  function getNPCRelationshipSummary(state, playerId) {
    if (!state || !state.players || !state.players[playerId]) return [];
    var relationships = state.players[playerId];
    var result = [];
    for (var npcId in relationships) {
      var score = relationships[npcId];
      var tier = getTier(score);
      result.push({
        npcId: npcId,
        score: score,
        tier: tier.name,
        tierColor: tier.color
      });
    }
    result.sort(function(a, b) { return b.score - a.score; });
    return result;
  }

  /**
   * Returns top N relationships for a player by score.
   * @param {Object} state
   * @param {string} playerId
   * @param {number} [limit=5]
   * @returns {Array<Object>}
   */
  function getTopRelationships(state, playerId, limit) {
    limit = typeof limit === 'number' ? limit : 5;
    var all = getNPCRelationshipSummary(state, playerId);
    return all.slice(0, limit);
  }

  // ---------------------------------------------------------------------------
  // REPUTATION DECAY
  // ---------------------------------------------------------------------------

  /**
   * Slowly decay all reputations toward 0 by amount if score is above threshold.
   * @param {Object} state
   * @param {string} playerId
   * @param {number} [amount=1]    - amount to decay per tick
   * @param {number} [threshold=5] - only decay if |score| > threshold
   * @returns {Object} state
   */
  function decayReputation(state, playerId, amount, threshold) {
    amount = typeof amount === 'number' ? amount : 1;
    threshold = typeof threshold === 'number' ? threshold : 5;

    if (!state || !state.players || !state.players[playerId]) return state;

    var relationships = state.players[playerId];
    for (var npcId in relationships) {
      var score = relationships[npcId];
      if (Math.abs(score) > threshold) {
        if (score > 0) {
          relationships[npcId] = Math.max(0, score - amount);
        } else {
          relationships[npcId] = Math.min(0, score + amount);
        }
      }
    }

    return state;
  }

  // ---------------------------------------------------------------------------
  // FORMATTING
  // ---------------------------------------------------------------------------

  /**
   * Returns a visual reputation bar string with tier name.
   * Example: [----|====#====|----] Friendly (42)
   * @param {number} score  (-100 to 100)
   * @returns {string}
   */
  function formatReputationBar(score) {
    score = Math.max(REPUTATION_MIN, Math.min(REPUTATION_MAX, score));
    var tier = getTier(score);

    // Bar is 20 chars wide, representing -100..100
    var barWidth = 20;
    // Position from 0..barWidth-1
    var normalized = (score - REPUTATION_MIN) / (REPUTATION_MAX - REPUTATION_MIN); // 0..1
    var pos = Math.round(normalized * (barWidth - 1));

    var bar = '';
    for (var i = 0; i < barWidth; i++) {
      if (i === pos) {
        bar += '#';
      } else if (i < barWidth / 2) {
        bar += score >= 0 ? '-' : '=';
      } else {
        bar += score >= 0 ? '=' : '-';
      }
    }

    // Simpler, clearer format: negative region dashes, positive region equals
    bar = '';
    var midPoint = Math.floor(barWidth / 2); // index 10 = score 0
    for (var j = 0; j < barWidth; j++) {
      if (j === pos) {
        bar += '#';
      } else if (j < midPoint) {
        bar += '-';
      } else {
        bar += '=';
      }
    }

    return '[' + bar + '] ' + tier.name + ' (' + score + ')';
  }

  /**
   * Returns an HTML card string for an NPC relationship.
   * @param {string} npcId
   * @param {string} npcName
   * @param {string} archetype
   * @param {number} score
   * @returns {string} HTML string
   */
  function formatRelationshipCard(npcId, npcName, archetype, score) {
    var tier = getTier(score);
    var features = getUnlockedFeatures(score);
    var bar = formatReputationBar(score);
    var featureList = features.length > 0
      ? '<ul>' + features.map(function(f) { return '<li>' + f + '</li>'; }).join('') + '</ul>'
      : '<p>No special features unlocked yet.</p>';

    return '<div class="npc-rep-card" data-npc-id="' + npcId + '">' +
      '<h3 class="npc-name">' + npcName + '</h3>' +
      '<span class="npc-archetype">' + archetype + '</span>' +
      '<div class="npc-tier" style="color:' + tier.color + '">' + tier.name + '</div>' +
      '<div class="npc-bar"><pre>' + bar + '</pre></div>' +
      '<div class="npc-score">Score: ' + score + '</div>' +
      '<div class="npc-features">' + featureList + '</div>' +
      '</div>';
  }

  // ---------------------------------------------------------------------------
  // EXPORTS
  // ---------------------------------------------------------------------------

  exports.TIERS = TIERS;
  exports.REPUTATION_ACTIONS = REPUTATION_ACTIONS;
  exports.ARCHETYPE_PREFERENCES = ARCHETYPE_PREFERENCES;
  exports.DIALOGUE_POOLS = DIALOGUE_POOLS;
  exports.FEATURE_THRESHOLDS = FEATURE_THRESHOLDS;
  exports.REPUTATION_MIN = REPUTATION_MIN;
  exports.REPUTATION_MAX = REPUTATION_MAX;

  exports.createReputationState = createReputationState;
  exports.getReputation = getReputation;
  exports.modifyReputation = modifyReputation;
  exports.getTier = getTier;
  exports.getDialogue = getDialogue;
  exports.getGiftReaction = getGiftReaction;
  exports.processGift = processGift;
  exports.getUnlockedFeatures = getUnlockedFeatures;
  exports.getNPCRelationshipSummary = getNPCRelationshipSummary;
  exports.getTopRelationships = getTopRelationships;
  exports.decayReputation = decayReputation;
  exports.formatReputationBar = formatReputationBar;
  exports.formatRelationshipCard = formatRelationshipCard;

})(typeof module !== 'undefined' ? module.exports : (window.NpcReputation = {}));


// loot.js
// loot.js
/**
 * ZION Cross-System Loot & Reward Engine
 * Unified item reward pipeline for dungeons, fishing, card games, events, quests.
 * No project dependencies.
 */

(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Seeded pseudo-random number generator (mulberry32)
  // ---------------------------------------------------------------------------

  function createRng(seed) {
    var s = (seed >>> 0) || 0xDEADBEEF;
    return function() {
      s += 0x6D2B79F5;
      var t = Math.imul(s ^ (s >>> 15), 1 | s);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) >>> 0;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function hashString(str) {
    var h = 2166136261;
    for (var i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function seedFrom(base, suffix) {
    return hashString(String(base) + '|' + String(suffix));
  }

  // ---------------------------------------------------------------------------
  // Loot Tables
  // ---------------------------------------------------------------------------

  var LOOT_TABLES = {
    dungeon_easy: {
      guaranteed: [{ item: 'iron_ore', qty: 2 }],
      rolls: 2,
      pool: [
        { item: 'stone',        w: 30, qty: 3 },
        { item: 'herbs',        w: 25, qty: 2 },
        { item: 'iron_ore',     w: 20, qty: 1 },
        { item: 'crystal',      w: 10, qty: 1 },
        { item: 'scroll',       w: 10, qty: 1 },
        { item: 'ancient_coin', w:  5, qty: 1 }
      ]
    },
    dungeon_medium: {
      guaranteed: [
        { item: 'iron_ore', qty: 3 },
        { item: 'crystal',  qty: 1 }
      ],
      rolls: 3,
      pool: [
        { item: 'crystal',      w: 25, qty: 1 },
        { item: 'gold_dust',    w: 20, qty: 1 },
        { item: 'iron_ore',     w: 15, qty: 2 },
        { item: 'scroll',       w: 15, qty: 2 },
        { item: 'fossil',       w: 10, qty: 1 },
        { item: 'star_fragment',w:  5, qty: 1 },
        { item: 'ancient_coin', w: 10, qty: 1 }
      ]
    },
    dungeon_hard: {
      guaranteed: [
        { item: 'crystal',   qty: 2 },
        { item: 'gold_dust', qty: 2 }
      ],
      rolls: 4,
      pool: [
        { item: 'star_fragment', w: 15, qty: 1 },
        { item: 'crystal',       w: 20, qty: 2 },
        { item: 'gold_dust',     w: 20, qty: 2 },
        { item: 'fossil',        w: 15, qty: 1 },
        { item: 'ancient_coin',  w: 15, qty: 1 },
        { item: 'scroll',        w: 10, qty: 2 },
        { item: 'elixir',        w:  5, qty: 1 }
      ]
    },
    dungeon_boss: {
      guaranteed: [
        { item: 'star_fragment', qty: 1 },
        { item: 'gold_dust',     qty: 3 }
      ],
      rolls: 2,
      pool: [
        { item: 'star_fragment', w: 30, qty: 1 },
        { item: 'crystal',       w: 25, qty: 2 },
        { item: 'ancient_coin',  w: 20, qty: 2 },
        { item: 'elixir',        w: 15, qty: 1 },
        { item: 'fossil',        w: 10, qty: 1 }
      ]
    },
    fishing_common: {
      guaranteed: [],
      rolls: 1,
      pool: [
        { item: 'herbs',   w: 40, qty: 1 },
        { item: 'wood',    w: 30, qty: 1 },
        { item: 'feather', w: 20, qty: 1 },
        { item: 'clay',    w: 10, qty: 1 }
      ]
    },
    fishing_rare: {
      guaranteed: [{ item: 'crystal', qty: 1 }],
      rolls: 1,
      pool: [
        { item: 'gold_dust',     w: 30, qty: 1 },
        { item: 'ancient_coin',  w: 25, qty: 1 },
        { item: 'star_fragment', w: 10, qty: 1 },
        { item: 'fossil',        w: 20, qty: 1 },
        { item: 'scroll',        w: 15, qty: 1 }
      ]
    },
    card_win: {
      guaranteed: [],
      rolls: 1,
      pool: [
        { item: 'scroll',       w: 30, qty: 1 },
        { item: 'gold_dust',    w: 25, qty: 1 },
        { item: 'crystal',      w: 20, qty: 1 },
        { item: 'feather',      w: 15, qty: 2 },
        { item: 'ancient_coin', w: 10, qty: 1 }
      ]
    },
    card_tournament: {
      guaranteed: [{ item: 'gold_dust', qty: 2 }],
      rolls: 2,
      pool: [
        { item: 'crystal',       w: 25, qty: 1 },
        { item: 'star_fragment', w: 15, qty: 1 },
        { item: 'ancient_coin',  w: 20, qty: 1 },
        { item: 'scroll',        w: 20, qty: 2 },
        { item: 'fossil',        w: 10, qty: 1 },
        { item: 'elixir',        w: 10, qty: 1 }
      ]
    },
    event_participation: {
      guaranteed: [],
      rolls: 1,
      pool: [
        { item: 'herbs',     w: 25, qty: 2 },
        { item: 'honey',     w: 20, qty: 1 },
        { item: 'silk',      w: 20, qty: 1 },
        { item: 'feather',   w: 15, qty: 2 },
        { item: 'clay',      w: 10, qty: 2 },
        { item: 'gold_dust', w: 10, qty: 1 }
      ]
    },
    event_top_contributor: {
      guaranteed: [{ item: 'star_fragment', qty: 1 }],
      rolls: 2,
      pool: [
        { item: 'crystal',      w: 25, qty: 2 },
        { item: 'gold_dust',    w: 25, qty: 2 },
        { item: 'ancient_coin', w: 20, qty: 1 },
        { item: 'fossil',       w: 15, qty: 1 },
        { item: 'elixir',       w: 15, qty: 1 }
      ]
    },
    quest_easy: {
      guaranteed: [],
      rolls: 1,
      pool: [
        { item: 'herbs',   w: 30, qty: 2 },
        { item: 'wood',    w: 25, qty: 3 },
        { item: 'stone',   w: 25, qty: 3 },
        { item: 'feather', w: 15, qty: 1 },
        { item: 'honey',   w:  5, qty: 1 }
      ]
    },
    quest_hard: {
      guaranteed: [{ item: 'gold_dust', qty: 1 }],
      rolls: 2,
      pool: [
        { item: 'crystal',       w: 25, qty: 1 },
        { item: 'iron_ore',      w: 20, qty: 2 },
        { item: 'scroll',        w: 20, qty: 1 },
        { item: 'ancient_coin',  w: 15, qty: 1 },
        { item: 'fossil',        w: 10, qty: 1 },
        { item: 'star_fragment', w: 10, qty: 1 }
      ]
    },
    gathering_normal: {
      guaranteed: [],
      rolls: 1,
      pool: [
        { item: 'herbs',   w: 25, qty: 1 },
        { item: 'wood',    w: 25, qty: 1 },
        { item: 'stone',   w: 25, qty: 1 },
        { item: 'clay',    w: 15, qty: 1 },
        { item: 'feather', w: 10, qty: 1 }
      ]
    },
    gathering_rare: {
      guaranteed: [],
      rolls: 1,
      pool: [
        { item: 'iron_ore',  w: 30, qty: 1 },
        { item: 'crystal',   w: 20, qty: 1 },
        { item: 'gold_dust', w: 15, qty: 1 },
        { item: 'honey',     w: 20, qty: 1 },
        { item: 'silk',      w: 15, qty: 1 }
      ]
    }
  };

  // ---------------------------------------------------------------------------
  // Spark Rewards
  // ---------------------------------------------------------------------------

  var SPARK_REWARDS = {
    dungeon_easy:            { base: 20,  variance: 10 },
    dungeon_medium:          { base: 50,  variance: 20 },
    dungeon_hard:            { base: 100, variance: 30 },
    dungeon_boss:            { base: 75,  variance: 25 },
    card_win:                { base: 10,  variance:  5 },
    card_tournament:         { base: 50,  variance: 20 },
    fishing_common:          { base:  3,  variance:  2 },
    fishing_rare:            { base: 15,  variance: 10 },
    quest_easy:              { base: 15,  variance:  5 },
    quest_hard:              { base: 50,  variance: 15 },
    event_participation:     { base: 10,  variance:  5 },
    event_top_contributor:   { base: 40,  variance: 15 }
  };

  // ---------------------------------------------------------------------------
  // Item rarity classification (used for getRarityOfDrop)
  // ---------------------------------------------------------------------------

  var ITEM_RARITY = {
    // Common items
    stone:        'common',
    herbs:        'common',
    wood:         'common',
    feather:      'common',
    clay:         'common',
    honey:        'common',
    // Uncommon items
    iron_ore:     'uncommon',
    silk:         'uncommon',
    // Rare items
    crystal:      'rare',
    gold_dust:    'rare',
    scroll:       'rare',
    fossil:       'rare',
    ancient_coin: 'rare',
    // Epic items
    star_fragment:'epic',
    elixir:       'epic'
  };

  // Rarity rank for comparison (higher = better)
  var RARITY_RANK = {
    common:   0,
    uncommon: 1,
    rare:     2,
    epic:     3
  };

  // ---------------------------------------------------------------------------
  // Core: weighted random selection from pool
  // ---------------------------------------------------------------------------

  /**
   * Single weighted random pick from a pool entry array.
   * Each entry must have { w } (weight). Returns the chosen entry.
   * @param {Array}  pool  - Array of { item, w, qty }
   * @param {number} seed  - Optional numeric seed; uses Math.random when absent
   * @returns {Object} The chosen pool entry
   */
  function rollFromPool(pool, seed) {
    if (!pool || pool.length === 0) return null;

    var rng = (seed !== undefined && seed !== null)
      ? createRng(typeof seed === 'string' ? hashString(seed) : (seed >>> 0))
      : function() { return Math.random(); };

    var totalWeight = 0;
    for (var i = 0; i < pool.length; i++) {
      totalWeight += pool[i].w;
    }

    var roll = rng() * totalWeight;
    var cumulative = 0;
    for (var j = 0; j < pool.length; j++) {
      cumulative += pool[j].w;
      if (roll < cumulative) {
        return pool[j];
      }
    }
    // Fallback to last entry (floating point edge case)
    return pool[pool.length - 1];
  }

  // ---------------------------------------------------------------------------
  // Core: roll a full loot table
  // ---------------------------------------------------------------------------

  /**
   * Roll loot from a named table using optional seed for determinism.
   * Returns guaranteed items plus `table.rolls` random picks from pool.
   * @param {string} tableId - Key in LOOT_TABLES
   * @param {number} [seed]  - Optional seed for deterministic results
   * @returns {{ items: Array<{item:string, qty:number}>, spark: number }}
   */
  function rollLoot(tableId, seed) {
    var table = LOOT_TABLES[tableId];
    if (!table) {
      return { items: [], spark: 0 };
    }

    // Accumulate items keyed by item id for merging duplicates
    var accumulated = {};

    // Add guaranteed items
    for (var g = 0; g < table.guaranteed.length; g++) {
      var gItem = table.guaranteed[g];
      if (accumulated[gItem.item] === undefined) {
        accumulated[gItem.item] = 0;
      }
      accumulated[gItem.item] += gItem.qty;
    }

    // Perform random rolls from pool
    if (table.pool && table.pool.length > 0) {
      for (var r = 0; r < table.rolls; r++) {
        var rollSeed = (seed !== undefined && seed !== null)
          ? seedFrom(seed, tableId + '_roll_' + r)
          : undefined;
        var pick = rollFromPool(table.pool, rollSeed);
        if (pick) {
          if (accumulated[pick.item] === undefined) {
            accumulated[pick.item] = 0;
          }
          accumulated[pick.item] += pick.qty;
        }
      }
    }

    // Convert accumulated map to item array
    var items = [];
    var keys = Object.keys(accumulated);
    for (var k = 0; k < keys.length; k++) {
      items.push({ item: keys[k], qty: accumulated[keys[k]] });
    }

    // Calculate spark reward (use tableId as rewardId when available)
    var spark = calculateSparkReward(tableId, 1);

    return { items: items, spark: spark };
  }

  // ---------------------------------------------------------------------------
  // Spark reward calculation
  // ---------------------------------------------------------------------------

  /**
   * Calculate a Spark reward with variance for a given activity.
   * @param {string} rewardId         - Key in SPARK_REWARDS
   * @param {number} bonusMultiplier  - e.g. 1.5 for 50% bonus; default 1
   * @returns {number} Spark amount (integer)
   */
  function calculateSparkReward(rewardId, bonusMultiplier) {
    var config = SPARK_REWARDS[rewardId];
    if (!config) return 0;

    var multiplier = (typeof bonusMultiplier === 'number' && bonusMultiplier > 0)
      ? bonusMultiplier : 1;

    // Apply variance: base +/- (variance * random [-1, 1])
    var varianceOffset = Math.floor((Math.random() * 2 - 1) * config.variance);
    var raw = config.base + varianceOffset;

    // Clamp to at least 1
    var result = Math.max(1, Math.round(raw * multiplier));
    return result;
  }

  // ---------------------------------------------------------------------------
  // Loot merging
  // ---------------------------------------------------------------------------

  /**
   * Combine two loot result objects, summing item quantities and spark.
   * @param {{ items: Array, spark: number }} loot1
   * @param {{ items: Array, spark: number }} loot2
   * @returns {{ items: Array<{item:string, qty:number}>, spark: number }}
   */
  function mergeLoot(loot1, loot2) {
    var accumulated = {};

    function absorb(loot) {
      if (!loot || !loot.items) return;
      for (var i = 0; i < loot.items.length; i++) {
        var entry = loot.items[i];
        if (accumulated[entry.item] === undefined) {
          accumulated[entry.item] = 0;
        }
        accumulated[entry.item] += entry.qty;
      }
    }

    absorb(loot1);
    absorb(loot2);

    var items = [];
    var keys = Object.keys(accumulated);
    for (var k = 0; k < keys.length; k++) {
      items.push({ item: keys[k], qty: accumulated[keys[k]] });
    }

    var spark = ((loot1 && loot1.spark) || 0) + ((loot2 && loot2.spark) || 0);

    return { items: items, spark: spark };
  }

  // ---------------------------------------------------------------------------
  // Bonus application
  // ---------------------------------------------------------------------------

  /**
   * Apply multiplier bonuses to a loot result.
   * Supported bonus keys:
   *   double_loot:    qty multiplier of 2
   *   triple_loot:    qty multiplier of 3
   *   spark_bonus:    spark multiplier (value = the multiplier, e.g. 1.5)
   *   item_multiplier: qty multiplier (value = the multiplier)
   *
   * @param {{ items: Array, spark: number }} loot
   * @param {Object} bonuses - e.g. { double_loot: true, spark_bonus: 1.5 }
   * @returns {{ items: Array<{item:string, qty:number}>, spark: number }}
   */
  function applyLootBonuses(loot, bonuses) {
    if (!loot) return { items: [], spark: 0 };
    if (!bonuses) return loot;

    var qtyMultiplier = 1;
    var sparkMultiplier = 1;

    if (bonuses.double_loot) {
      qtyMultiplier *= 2;
    }
    if (bonuses.triple_loot) {
      qtyMultiplier *= 3;
    }
    if (bonuses.item_multiplier && typeof bonuses.item_multiplier === 'number') {
      qtyMultiplier *= bonuses.item_multiplier;
    }
    if (bonuses.spark_bonus && typeof bonuses.spark_bonus === 'number') {
      sparkMultiplier *= bonuses.spark_bonus;
    }

    var newItems = [];
    for (var i = 0; i < loot.items.length; i++) {
      newItems.push({
        item: loot.items[i].item,
        qty:  Math.round(loot.items[i].qty * qtyMultiplier)
      });
    }

    return {
      items: newItems,
      spark: Math.round(loot.spark * sparkMultiplier)
    };
  }

  // ---------------------------------------------------------------------------
  // Table accessors
  // ---------------------------------------------------------------------------

  /**
   * Return a deep copy of a loot table by ID.
   * @param {string} tableId
   * @returns {Object|null}
   */
  function getLootTable(tableId) {
    var table = LOOT_TABLES[tableId];
    if (!table) return null;
    return JSON.parse(JSON.stringify(table));
  }

  /**
   * Return all table IDs as an array.
   * @returns {Array<string>}
   */
  function getAllTables() {
    return Object.keys(LOOT_TABLES);
  }

  // ---------------------------------------------------------------------------
  // Drop rate calculation
  // ---------------------------------------------------------------------------

  /**
   * Calculate the probability (0â€“1) of receiving at least one of an item
   * from a given table, accounting for guaranteed items and pool rolls.
   * @param {string} tableId
   * @param {string} itemId
   * @returns {number} probability 0â€“1
   */
  function getDropRate(tableId, itemId) {
    var table = LOOT_TABLES[tableId];
    if (!table) return 0;

    // Check guaranteed
    for (var g = 0; g < table.guaranteed.length; g++) {
      if (table.guaranteed[g].item === itemId) {
        return 1; // Always drops
      }
    }

    if (!table.pool || table.pool.length === 0) return 0;

    // Compute per-roll probability
    var totalWeight = 0;
    var itemWeight = 0;
    for (var i = 0; i < table.pool.length; i++) {
      totalWeight += table.pool[i].w;
      if (table.pool[i].item === itemId) {
        itemWeight += table.pool[i].w;
      }
    }

    if (totalWeight === 0) return 0;

    var probPerRoll = itemWeight / totalWeight;
    // P(at least one in N rolls) = 1 - (1 - p)^N
    var probNone = Math.pow(1 - probPerRoll, table.rolls);
    return 1 - probNone;
  }

  // ---------------------------------------------------------------------------
  // Rarity classification
  // ---------------------------------------------------------------------------

  /**
   * Determine the overall rarity of a drop based on highest-rarity item.
   * @param {{ items: Array<{item:string, qty:number}> }} loot
   * @returns {'common'|'uncommon'|'rare'|'epic'}
   */
  function getRarityOfDrop(loot) {
    if (!loot || !loot.items || loot.items.length === 0) return 'common';

    var highestRank = 0;
    var highestLabel = 'common';

    for (var i = 0; i < loot.items.length; i++) {
      var rarity = ITEM_RARITY[loot.items[i].item] || 'common';
      var rank = RARITY_RANK[rarity] || 0;
      if (rank > highestRank) {
        highestRank = rank;
        highestLabel = rarity;
      }
    }

    return highestLabel;
  }

  // ---------------------------------------------------------------------------
  // Loot history
  // ---------------------------------------------------------------------------

  /**
   * Create a new empty loot history object.
   * @returns {{ drops: Array, totalItems: Object, totalSpark: number }}
   */
  function createLootHistory() {
    return {
      drops: [],
      totalItems: {},
      totalSpark: 0
    };
  }

  /**
   * Record a loot drop into a history object (mutates history in place).
   * @param {Object} history  - Created by createLootHistory
   * @param {string} tableId  - Which table was rolled
   * @param {{ items: Array, spark: number }} loot - The drop result
   */
  function recordDrop(history, tableId, loot) {
    if (!history || !loot) return;

    var entry = {
      tableId: tableId,
      items: loot.items ? loot.items.slice() : [],
      spark: loot.spark || 0,
      timestamp: Date.now()
    };

    history.drops.push(entry);
    history.totalSpark += entry.spark;

    for (var i = 0; i < entry.items.length; i++) {
      var it = entry.items[i];
      if (history.totalItems[it.item] === undefined) {
        history.totalItems[it.item] = 0;
      }
      history.totalItems[it.item] += it.qty;
    }
  }

  // ---------------------------------------------------------------------------
  // Formatting helpers
  // ---------------------------------------------------------------------------

  // Human-readable item names
  var ITEM_NAMES = {
    stone:        'Stone',
    herbs:        'Herbs',
    wood:         'Wood',
    feather:      'Feather',
    clay:         'Clay',
    honey:        'Honey',
    iron_ore:     'Iron Ore',
    silk:         'Silk',
    crystal:      'Crystal',
    gold_dust:    'Gold Dust',
    scroll:       'Scroll',
    fossil:       'Fossil',
    ancient_coin: 'Ancient Coin',
    star_fragment:'Star Fragment',
    elixir:       'Elixir'
  };

  // CSS class per rarity
  var RARITY_CSS = {
    common:   'loot-common',
    uncommon: 'loot-uncommon',
    rare:     'loot-rare',
    epic:     'loot-epic'
  };

  /**
   * Format a loot drop into an HTML string for display.
   * @param {{ items: Array<{item:string, qty:number}>, spark: number }} loot
   * @returns {string} HTML
   */
  function formatLootDrop(loot) {
    if (!loot || (!loot.items.length && !loot.spark)) {
      return '<div class="loot-drop loot-empty">No loot</div>';
    }

    var html = '<div class="loot-drop">';

    for (var i = 0; i < loot.items.length; i++) {
      var entry = loot.items[i];
      var name = ITEM_NAMES[entry.item] || entry.item;
      var rarity = ITEM_RARITY[entry.item] || 'common';
      var cssClass = RARITY_CSS[rarity] || 'loot-common';
      html += '<span class="loot-item ' + cssClass + '">'
        + entry.qty + 'x ' + name
        + '</span>';
    }

    if (loot.spark) {
      html += '<span class="loot-spark">+' + loot.spark + ' Spark</span>';
    }

    html += '</div>';
    return html;
  }

  /**
   * Format a summary of loot history statistics.
   * @param {Array<{ items: Array, spark: number, tableId: string }>} lootHistory
   *        Can be raw array of drops OR a history object (has .drops property)
   * @returns {string} HTML summary
   */
  function formatLootSummary(lootHistory) {
    // Accept either raw array or history object
    var drops = Array.isArray(lootHistory) ? lootHistory
      : (lootHistory && lootHistory.drops ? lootHistory.drops : []);

    if (!drops || drops.length === 0) {
      return '<div class="loot-summary loot-empty">No loot history</div>';
    }

    var totalSpark = 0;
    var totalItems = {};
    var dropCount = drops.length;

    for (var d = 0; d < drops.length; d++) {
      var drop = drops[d];
      totalSpark += drop.spark || 0;
      var items = drop.items || [];
      for (var i = 0; i < items.length; i++) {
        var it = items[i];
        if (totalItems[it.item] === undefined) totalItems[it.item] = 0;
        totalItems[it.item] += it.qty;
      }
    }

    var html = '<div class="loot-summary">';
    html += '<div class="loot-summary-header">';
    html += '<span class="loot-drop-count">' + dropCount + ' drops</span>';
    html += '<span class="loot-total-spark">Total Spark: ' + totalSpark + '</span>';
    html += '</div>';

    html += '<ul class="loot-item-list">';
    var itemKeys = Object.keys(totalItems);
    for (var k = 0; k < itemKeys.length; k++) {
      var id = itemKeys[k];
      var name = ITEM_NAMES[id] || id;
      var rarity = ITEM_RARITY[id] || 'common';
      var cssClass = RARITY_CSS[rarity] || 'loot-common';
      html += '<li class="' + cssClass + '">' + name + ': ' + totalItems[id] + '</li>';
    }
    html += '</ul></div>';

    return html;
  }

  // ---------------------------------------------------------------------------
  // Exports
  // ---------------------------------------------------------------------------

  exports.LOOT_TABLES    = LOOT_TABLES;
  exports.SPARK_REWARDS  = SPARK_REWARDS;
  exports.ITEM_RARITY    = ITEM_RARITY;
  exports.ITEM_NAMES     = ITEM_NAMES;

  exports.rollLoot               = rollLoot;
  exports.rollFromPool           = rollFromPool;
  exports.calculateSparkReward   = calculateSparkReward;
  exports.mergeLoot              = mergeLoot;
  exports.applyLootBonuses       = applyLootBonuses;
  exports.getLootTable           = getLootTable;
  exports.getAllTables            = getAllTables;
  exports.formatLootDrop         = formatLootDrop;
  exports.formatLootSummary      = formatLootSummary;
  exports.createLootHistory      = createLootHistory;
  exports.recordDrop             = recordDrop;
  exports.getRarityOfDrop        = getRarityOfDrop;
  exports.getDropRate            = getDropRate;

  // Internal helpers exposed for testing
  exports._createRng   = createRng;
  exports._hashString  = hashString;
  exports._seedFrom    = seedFrom;

})(typeof module !== 'undefined' ? module.exports : (window.Loot = {}));


// guild_progression.js
// guild_progression.js
(function(exports) {
  'use strict';

  // ============================================================================
  // GUILD PROGRESSION SYSTEM â€” ZION MMO
  // Implements collective goals, treasury, ranks, and weekly challenges
  // Constitution ref: Â§2.3 (community formation) and Â§5.4 (collective action)
  // ============================================================================

  // Guild levels 1-10: level N requires N*500 total guild XP
  // Level 1 = 500, Level 2 = 1000, ... but level 1 is the founding level (0 XP)
  // XP thresholds: level N requires N*500 cumulative XP to REACH that level
  // Level 1 is free (0 XP), Level 2 requires 500 XP, Level 3 requires 1000 XP, etc.

  var MAX_GUILD_LEVEL = 10;

  // Perk definitions per level
  var LEVEL_PERKS = {
    1:  { id: 'founded',        name: 'Founded',               desc: 'Basic guild established in ZION' },
    2:  { id: 'guild_banner',   name: 'Guild Banner',          desc: 'Display a custom guild banner' },
    3:  { id: 'trade_discount', name: 'Trade Discount',        desc: '+5% trade discount for all members' },
    4:  { id: 'garden_plot',    name: 'Shared Garden Plot',    desc: 'Collective garden for all members' },
    5:  { id: 'guild_hall',     name: 'Guild Hall',            desc: 'Physical guild hall structure in world' },
    6:  { id: 'xp_bonus',       name: 'XP Bonus',              desc: '+10% XP bonus for all members' },
    7:  { id: 'guild_vault',    name: 'Guild Vault',           desc: 'Shared storage vault with 20 slots' },
    8:  { id: 'fast_travel',    name: 'Guild Fast Travel',     desc: 'Free fast travel between member locations' },
    9:  { id: 'spark_bonus',    name: 'Spark Bonus',           desc: '+15% Spark bonus for all members' },
    10: { id: 'legendary',      name: 'Legendary Status',      desc: 'Custom zone marker and legendary title' }
  };

  // Rank definitions: name -> { level, permissions }
  // level used to compare rank authority (higher = more authority)
  var RANK_DEFINITIONS = {
    leader:  { level: 4, permissions: ['all', 'invite', 'kick', 'treasury', 'rank', 'chat'] },
    officer: { level: 3, permissions: ['invite', 'kick', 'treasury', 'chat'] },
    veteran: { level: 2, permissions: ['invite', 'chat'] },
    member:  { level: 1, permissions: ['chat'] },
    recruit: { level: 0, permissions: ['chat'] }
  };

  // Valid ranks in ascending order of authority
  var RANK_ORDER = ['recruit', 'member', 'veteran', 'officer', 'leader'];

  // Days threshold for automatic rank labels
  var VETERAN_DAYS = 30;
  var RECRUIT_DAYS = 7;

  // Weekly challenges cycling pool (5 total)
  var WEEKLY_CHALLENGES = [
    {
      id: 'gather_rush',
      title: 'Gathering Rush',
      desc: 'Guild members gather 500 total resources',
      target: 500,
      metric: 'resources_gathered',
      reward: { guildXP: 200, spark: 100 }
    },
    {
      id: 'dungeon_sweep',
      title: 'Dungeon Sweep',
      desc: 'Guild members clear 10 dungeons total',
      target: 10,
      metric: 'dungeons_cleared',
      reward: { guildXP: 300, spark: 200 }
    },
    {
      id: 'trade_bonanza',
      title: 'Trade Bonanza',
      desc: 'Guild members complete 25 trades',
      target: 25,
      metric: 'trades_completed',
      reward: { guildXP: 250, spark: 150 }
    },
    {
      id: 'fish_feast',
      title: 'Fish Feast',
      desc: 'Guild members catch 100 fish',
      target: 100,
      metric: 'fish_caught',
      reward: { guildXP: 200, spark: 120 }
    },
    {
      id: 'social_surge',
      title: 'Social Surge',
      desc: 'Guild members send 200 chat messages',
      target: 200,
      metric: 'messages_sent',
      reward: { guildXP: 150, spark: 80 }
    }
  ];

  // Vault max slots at level 7+
  var VAULT_MAX_SLOTS = 20;

  // ============================================================================
  // HELPER UTILITIES
  // ============================================================================

  function cloneState(state) {
    return JSON.parse(JSON.stringify(state));
  }

  function nowMs() {
    return Date.now();
  }

  function daysElapsed(joinedMs) {
    return (nowMs() - joinedMs) / (1000 * 60 * 60 * 24);
  }

  // ============================================================================
  // XP AND LEVELING
  // ============================================================================

  /**
   * Get XP required to REACH a given level (cumulative from 0).
   * Level 1 = 0 XP (founding), Level 2 = 500, Level 3 = 1000, ...
   * Formula: level N requires (N-1) * 500 total XP
   * @param {number} level - Guild level (1-10)
   * @returns {number} Total XP needed to reach this level
   */
  function getXPForLevel(level) {
    if (level <= 1) return 0;
    if (level > MAX_GUILD_LEVEL) return (MAX_GUILD_LEVEL - 1) * 500;
    return (level - 1) * 500;
  }

  /**
   * Compute current guild level from total accumulated XP.
   * @param {number} guildXP - Total guild XP
   * @returns {number} Current guild level (1-10)
   */
  function getGuildLevel(guildXP) {
    var level = 1;
    for (var l = MAX_GUILD_LEVEL; l >= 1; l--) {
      if (guildXP >= getXPForLevel(l)) {
        level = l;
        break;
      }
    }
    return level;
  }

  /**
   * Get XP remaining to next level.
   * @param {object} state - Guild state
   * @returns {number} XP needed for next level, or 0 if at max
   */
  function getXPToNextLevel(state) {
    var currentLevel = state.level;
    if (currentLevel >= MAX_GUILD_LEVEL) return 0;
    var nextLevelXP = getXPForLevel(currentLevel + 1);
    return Math.max(0, nextLevelXP - state.guildXP);
  }

  /**
   * Return all perks unlocked at or below the given level.
   * @param {number} level - Guild level
   * @returns {Array} Array of perk objects
   */
  function getGuildPerks(level) {
    var perks = [];
    for (var l = 1; l <= level && l <= MAX_GUILD_LEVEL; l++) {
      if (LEVEL_PERKS[l]) {
        perks.push(LEVEL_PERKS[l]);
      }
    }
    return perks;
  }

  // ============================================================================
  // GUILD CREATION
  // ============================================================================

  /**
   * Create a new guild progression state.
   * @param {string} guildId - Unique guild ID
   * @param {string} name - Guild display name
   * @param {string} leaderId - Founding leader player ID
   * @returns {object} Full guild state
   */
  function createGuildProgression(guildId, name, leaderId) {
    var now = nowMs();
    var members = {};
    members[leaderId] = {
      rank: 'leader',
      joined: now,
      contributed: 0,
      displayName: leaderId
    };

    var state = {
      id: guildId,
      name: name,
      leaderId: leaderId,
      level: 1,
      guildXP: 0,
      treasury: 0,
      members: members,
      vault: [],
      challenges: {
        weekNumber: null,
        challengeId: null,
        progress: 0,
        completed: false,
        rewardClaimed: false
      },
      log: [],
      perks: getGuildPerks(1)
    };

    // Record founding event
    state.log.push({
      type: 'founded',
      ts: now,
      by: leaderId,
      message: name + ' was founded by ' + leaderId
    });

    return state;
  }

  // ============================================================================
  // XP AND LEVELING OPERATIONS
  // ============================================================================

  /**
   * Add XP to guild and process any level-ups.
   * @param {object} state - Guild state
   * @param {number} amount - XP to add
   * @param {string} source - Description of XP source
   * @returns {{ state, leveled, newLevel, perkUnlocked, message }}
   */
  function addGuildXP(state, amount, source) {
    state = cloneState(state);
    var oldLevel = state.level;
    state.guildXP += amount;

    var newLevel = getGuildLevel(state.guildXP);
    var leveled = newLevel > oldLevel;
    var perkUnlocked = null;

    if (leveled) {
      state.level = newLevel;
      perkUnlocked = LEVEL_PERKS[newLevel] || null;
      state.perks = getGuildPerks(newLevel);
      state.log.push({
        type: 'level_up',
        ts: nowMs(),
        oldLevel: oldLevel,
        newLevel: newLevel,
        perk: perkUnlocked ? perkUnlocked.name : null,
        message: state.name + ' reached Level ' + newLevel + '! Perk unlocked: ' + (perkUnlocked ? perkUnlocked.name : 'none')
      });
    }

    state.log.push({
      type: 'xp_gained',
      ts: nowMs(),
      amount: amount,
      source: source || 'activity',
      total: state.guildXP,
      message: '+' + amount + ' Guild XP from ' + (source || 'activity')
    });

    var message = leveled
      ? state.name + ' leveled up to ' + newLevel + '! ' + (perkUnlocked ? perkUnlocked.name + ' unlocked.' : '')
      : 'Guild gained ' + amount + ' XP. (' + getXPToNextLevel(state) + ' XP to next level)';

    return {
      state: state,
      leveled: leveled,
      newLevel: newLevel,
      perkUnlocked: perkUnlocked,
      message: message
    };
  }

  // ============================================================================
  // TREASURY OPERATIONS
  // ============================================================================

  /**
   * Contribute Spark to the guild treasury.
   * @param {object} state - Guild state
   * @param {string} playerId - Contributing player ID
   * @param {number} amount - Spark amount to contribute
   * @returns {{ state, success, newTreasury, message }}
   */
  function contributeSpark(state, playerId, amount) {
    state = cloneState(state);

    if (!state.members[playerId]) {
      return { state: state, success: false, newTreasury: state.treasury, message: 'Player is not a guild member.' };
    }
    if (typeof amount !== 'number' || amount <= 0) {
      return { state: state, success: false, newTreasury: state.treasury, message: 'Contribution amount must be a positive number.' };
    }

    state.treasury += amount;
    state.members[playerId].contributed = (state.members[playerId].contributed || 0) + amount;

    state.log.push({
      type: 'treasury_deposit',
      ts: nowMs(),
      by: playerId,
      amount: amount,
      balance: state.treasury,
      message: playerId + ' contributed ' + amount + ' Spark to the treasury. Balance: ' + state.treasury
    });

    return {
      state: state,
      success: true,
      newTreasury: state.treasury,
      message: playerId + ' contributed ' + amount + ' Spark. Treasury: ' + state.treasury + ' Spark.'
    };
  }

  /**
   * Withdraw Spark from the guild treasury (leader/officer only).
   * @param {object} state - Guild state
   * @param {string} playerId - Requesting player ID
   * @param {number} amount - Spark amount to withdraw
   * @param {string} reason - Stated reason for withdrawal
   * @returns {{ state, success, message }}
   */
  function withdrawSpark(state, playerId, amount, reason) {
    state = cloneState(state);

    if (!state.members[playerId]) {
      return { state: state, success: false, message: 'Player is not a guild member.' };
    }
    if (!hasPermission(state, playerId, 'treasury')) {
      return { state: state, success: false, message: 'Insufficient rank. Only leaders and officers can withdraw from the treasury.' };
    }
    if (typeof amount !== 'number' || amount <= 0) {
      return { state: state, success: false, message: 'Withdrawal amount must be a positive number.' };
    }
    if (amount > state.treasury) {
      return { state: state, success: false, message: 'Insufficient funds. Treasury has ' + state.treasury + ' Spark, requested ' + amount + '.' };
    }

    state.treasury -= amount;

    state.log.push({
      type: 'treasury_withdrawal',
      ts: nowMs(),
      by: playerId,
      amount: amount,
      reason: reason || 'unspecified',
      balance: state.treasury,
      message: playerId + ' withdrew ' + amount + ' Spark from treasury. Reason: ' + (reason || 'unspecified') + '. Balance: ' + state.treasury
    });

    return {
      state: state,
      success: true,
      message: playerId + ' withdrew ' + amount + ' Spark. Remaining treasury: ' + state.treasury + ' Spark.'
    };
  }

  /**
   * Get recent treasury transactions.
   * @param {object} state - Guild state
   * @param {number} limit - Max entries to return (default 20)
   * @returns {Array} Array of treasury log entries
   */
  function getTreasuryLog(state, limit) {
    var n = limit || 20;
    var entries = state.log.filter(function(e) {
      return e.type === 'treasury_deposit' || e.type === 'treasury_withdrawal';
    });
    return entries.slice(-n);
  }

  // ============================================================================
  // RANK MANAGEMENT
  // ============================================================================

  /**
   * Get current rank for a player.
   * @param {object} state - Guild state
   * @param {string} playerId - Player ID
   * @returns {string} Rank name, or 'non-member' if not in guild
   */
  function getRank(state, playerId) {
    if (!state.members[playerId]) return 'non-member';
    return state.members[playerId].rank;
  }

  /**
   * Check whether a player has a specific permission.
   * @param {object} state - Guild state
   * @param {string} playerId - Player ID
   * @param {string} permission - Permission to check
   * @returns {boolean}
   */
  function hasPermission(state, playerId, permission) {
    var rank = getRank(state, playerId);
    if (rank === 'non-member') return false;
    var def = RANK_DEFINITIONS[rank];
    if (!def) return false;
    if (def.permissions.indexOf('all') !== -1) return true;
    return def.permissions.indexOf(permission) !== -1;
  }

  /**
   * Set a member's rank.
   * @param {object} state - Guild state
   * @param {string} setterId - Player making the change
   * @param {string} targetId - Player whose rank changes
   * @param {string} newRank - New rank to assign
   * @returns {{ state, success, message }}
   */
  function setRank(state, setterId, targetId, newRank) {
    state = cloneState(state);

    if (!state.members[setterId]) {
      return { state: state, success: false, message: 'Setter is not a guild member.' };
    }
    if (!state.members[targetId]) {
      return { state: state, success: false, message: 'Target player is not a guild member.' };
    }
    if (RANK_ORDER.indexOf(newRank) === -1) {
      return { state: state, success: false, message: 'Invalid rank: ' + newRank + '. Valid ranks: ' + RANK_ORDER.join(', ') };
    }

    // Cannot set to or from 'leader' unless you ARE the leader
    if (newRank === 'leader') {
      if (getRank(state, setterId) !== 'leader') {
        return { state: state, success: false, message: 'Only the leader can transfer leadership.' };
      }
      // Transfer leadership: demote old leader to officer
      state.members[setterId].rank = 'officer';
      state.leaderId = targetId;
    }

    // Cannot demote/change someone of equal or higher rank (unless you're leader)
    var setterRankLevel = RANK_DEFINITIONS[getRank(state, setterId)] ? RANK_DEFINITIONS[getRank(state, setterId)].level : -1;
    var targetCurrentRankLevel = RANK_DEFINITIONS[getRank(state, targetId)] ? RANK_DEFINITIONS[getRank(state, targetId)].level : -1;

    if (getRank(state, setterId) !== 'leader' && newRank !== 'leader') {
      // Officers can invite/kick members below officer rank
      if (!hasPermission(state, setterId, 'rank')) {
        // Officers can set member/recruit ranks (below themselves)
        if (!hasPermission(state, setterId, 'kick')) {
          return { state: state, success: false, message: 'Insufficient permissions to change ranks.' };
        }
        // Officer can only manage ranks below officer level
        var newRankLevel = RANK_DEFINITIONS[newRank] ? RANK_DEFINITIONS[newRank].level : -1;
        if (newRankLevel >= setterRankLevel) {
          return { state: state, success: false, message: 'Cannot promote to a rank equal to or higher than your own.' };
        }
        if (targetCurrentRankLevel >= setterRankLevel) {
          return { state: state, success: false, message: 'Cannot change the rank of someone of equal or higher rank.' };
        }
      }
    }

    var oldRank = state.members[targetId].rank;
    state.members[targetId].rank = newRank;

    state.log.push({
      type: 'rank_change',
      ts: nowMs(),
      by: setterId,
      target: targetId,
      oldRank: oldRank,
      newRank: newRank,
      message: setterId + ' changed ' + targetId + "'s rank from " + oldRank + ' to ' + newRank
    });

    return {
      state: state,
      success: true,
      message: targetId + "'s rank changed from " + oldRank + ' to ' + newRank + '.'
    };
  }

  // ============================================================================
  // MEMBER MANAGEMENT
  // ============================================================================

  /**
   * Get sorted member list with rank and stats.
   * Sort order: by rank level descending, then by join date ascending.
   * @param {object} state - Guild state
   * @returns {Array} Sorted array of member info objects
   */
  function getMemberList(state) {
    var now = nowMs();
    var members = [];

    for (var pid in state.members) {
      if (!state.members.hasOwnProperty(pid)) continue;
      var m = state.members[pid];
      var daysIn = (now - m.joined) / (1000 * 60 * 60 * 24);
      var rankDef = RANK_DEFINITIONS[m.rank] || RANK_DEFINITIONS['recruit'];
      members.push({
        id: pid,
        rank: m.rank,
        rankLevel: rankDef.level,
        joined: m.joined,
        daysInGuild: Math.floor(daysIn),
        contributed: m.contributed || 0,
        displayName: m.displayName || pid
      });
    }

    // Sort: rank level descending, then join date ascending (older first)
    members.sort(function(a, b) {
      if (b.rankLevel !== a.rankLevel) return b.rankLevel - a.rankLevel;
      return a.joined - b.joined;
    });

    return members;
  }

  // ============================================================================
  // WEEKLY CHALLENGES
  // ============================================================================

  /**
   * Get the weekly challenge for a given week number (cycles through 5).
   * @param {number} weekNumber - ISO week number or arbitrary counter
   * @returns {object} Challenge definition
   */
  function getWeeklyChallenge(weekNumber) {
    var idx = ((weekNumber % WEEKLY_CHALLENGES.length) + WEEKLY_CHALLENGES.length) % WEEKLY_CHALLENGES.length;
    return WEEKLY_CHALLENGES[idx];
  }

  /**
   * Update progress toward the current weekly challenge.
   * Initializes the challenge for the week if not already set.
   * @param {object} state - Guild state
   * @param {string} metric - Metric key (e.g. 'resources_gathered')
   * @param {number} amount - Amount to add to progress
   * @returns {{ state, progress, completed, reward }}
   */
  function updateChallengeProgress(state, metric, amount) {
    state = cloneState(state);

    // Determine current week number (ISO week)
    var now = new Date();
    var startOfYear = new Date(now.getFullYear(), 0, 1);
    var weekNumber = Math.floor((now - startOfYear) / (7 * 24 * 60 * 60 * 1000));

    // Initialize challenge tracking if new week or not set
    if (state.challenges.weekNumber !== weekNumber) {
      var challenge = getWeeklyChallenge(weekNumber);
      state.challenges = {
        weekNumber: weekNumber,
        challengeId: challenge.id,
        progress: 0,
        completed: false,
        rewardClaimed: false
      };
    }

    var challenge = getWeeklyChallenge(weekNumber);

    // Only update if metric matches current challenge
    if (challenge.metric !== metric) {
      return {
        state: state,
        progress: state.challenges.progress,
        completed: state.challenges.completed,
        reward: null
      };
    }

    // Already completed
    if (state.challenges.completed) {
      return {
        state: state,
        progress: state.challenges.progress,
        completed: true,
        reward: null
      };
    }

    state.challenges.progress += amount;

    var completed = false;
    var reward = null;

    if (state.challenges.progress >= challenge.target) {
      state.challenges.progress = challenge.target;
      state.challenges.completed = true;
      completed = true;
      reward = challenge.reward;

      // Award guild XP automatically
      var xpResult = addGuildXP(state, reward.guildXP, 'weekly challenge: ' + challenge.title);
      state = xpResult.state;

      state.log.push({
        type: 'challenge_completed',
        ts: nowMs(),
        challengeId: challenge.id,
        challengeTitle: challenge.title,
        reward: reward,
        message: 'Weekly challenge "' + challenge.title + '" completed! Reward: ' + reward.guildXP + ' Guild XP + ' + reward.spark + ' Spark for members'
      });
    }

    return {
      state: state,
      progress: state.challenges.progress,
      completed: completed,
      reward: reward
    };
  }

  /**
   * Get current weekly challenge with progress info.
   * @param {object} state - Guild state
   * @returns {object} Challenge with progress fields
   */
  function getChallengeProgress(state) {
    var now = new Date();
    var startOfYear = new Date(now.getFullYear(), 0, 1);
    var weekNumber = Math.floor((now - startOfYear) / (7 * 24 * 60 * 60 * 1000));

    var challenge = getWeeklyChallenge(weekNumber);
    var isCurrentWeek = state.challenges.weekNumber === weekNumber;

    return {
      weekNumber: weekNumber,
      challenge: challenge,
      progress: isCurrentWeek ? state.challenges.progress : 0,
      completed: isCurrentWeek ? state.challenges.completed : false,
      percentComplete: isCurrentWeek ? Math.min(100, Math.floor((state.challenges.progress / challenge.target) * 100)) : 0,
      rewardClaimed: isCurrentWeek ? state.challenges.rewardClaimed : false
    };
  }

  // ============================================================================
  // VAULT OPERATIONS
  // ============================================================================

  /**
   * Add items to the shared guild vault.
   * Requires guild level 7+ (vault perk).
   * @param {object} state - Guild state
   * @param {string} playerId - Player adding items
   * @param {string} itemId - Item identifier
   * @param {number} qty - Quantity to add
   * @returns {{ state, success, message }}
   */
  function addToVault(state, playerId, itemId, qty) {
    state = cloneState(state);

    if (!state.members[playerId]) {
      return { state: state, success: false, message: 'Player is not a guild member.' };
    }
    if (state.level < 7) {
      return { state: state, success: false, message: 'Guild Vault requires guild level 7. Current level: ' + state.level };
    }
    if (typeof qty !== 'number' || qty <= 0) {
      return { state: state, success: false, message: 'Quantity must be a positive number.' };
    }

    // Check if item already in vault
    var existingSlot = null;
    for (var i = 0; i < state.vault.length; i++) {
      if (state.vault[i].itemId === itemId) {
        existingSlot = i;
        break;
      }
    }

    if (existingSlot !== null) {
      state.vault[existingSlot].qty += qty;
    } else {
      if (state.vault.length >= VAULT_MAX_SLOTS) {
        return { state: state, success: false, message: 'Guild vault is full (' + VAULT_MAX_SLOTS + ' slots).' };
      }
      state.vault.push({ itemId: itemId, qty: qty, addedBy: playerId, ts: nowMs() });
    }

    state.log.push({
      type: 'vault_deposit',
      ts: nowMs(),
      by: playerId,
      itemId: itemId,
      qty: qty,
      message: playerId + ' added ' + qty + 'x ' + itemId + ' to the guild vault'
    });

    return {
      state: state,
      success: true,
      message: playerId + ' added ' + qty + 'x ' + itemId + ' to the vault.'
    };
  }

  /**
   * Take items from the shared guild vault.
   * Requires member rank or above (not recruit).
   * @param {object} state - Guild state
   * @param {string} playerId - Player taking items
   * @param {string} itemId - Item identifier
   * @param {number} qty - Quantity to take
   * @returns {{ state, success, message }}
   */
  function takeFromVault(state, playerId, itemId, qty) {
    state = cloneState(state);

    if (!state.members[playerId]) {
      return { state: state, success: false, message: 'Player is not a guild member.' };
    }
    if (state.level < 7) {
      return { state: state, success: false, message: 'Guild Vault requires guild level 7. Current level: ' + state.level };
    }

    // Recruits cannot take from vault
    var rank = getRank(state, playerId);
    if (rank === 'recruit') {
      return { state: state, success: false, message: 'Recruits cannot take from the guild vault.' };
    }

    if (typeof qty !== 'number' || qty <= 0) {
      return { state: state, success: false, message: 'Quantity must be a positive number.' };
    }

    var slotIndex = null;
    for (var i = 0; i < state.vault.length; i++) {
      if (state.vault[i].itemId === itemId) {
        slotIndex = i;
        break;
      }
    }

    if (slotIndex === null) {
      return { state: state, success: false, message: 'Item "' + itemId + '" not found in vault.' };
    }

    if (state.vault[slotIndex].qty < qty) {
      return { state: state, success: false, message: 'Insufficient quantity. Vault has ' + state.vault[slotIndex].qty + 'x ' + itemId + ', requested ' + qty + '.' };
    }

    state.vault[slotIndex].qty -= qty;
    if (state.vault[slotIndex].qty === 0) {
      state.vault.splice(slotIndex, 1);
    }

    state.log.push({
      type: 'vault_withdrawal',
      ts: nowMs(),
      by: playerId,
      itemId: itemId,
      qty: qty,
      message: playerId + ' took ' + qty + 'x ' + itemId + ' from the guild vault'
    });

    return {
      state: state,
      success: true,
      message: playerId + ' took ' + qty + 'x ' + itemId + ' from the vault.'
    };
  }

  // ============================================================================
  // GUILD SUMMARY AND DISPLAY
  // ============================================================================

  /**
   * Return a comprehensive guild overview object.
   * @param {object} state - Guild state
   * @returns {object} Formatted guild summary
   */
  function getGuildSummary(state) {
    var memberCount = Object.keys(state.members).length;
    var challengeInfo = getChallengeProgress(state);
    var xpToNext = getXPToNextLevel(state);
    var nextLevelXP = state.level < MAX_GUILD_LEVEL ? getXPForLevel(state.level + 1) : null;

    return {
      id: state.id,
      name: state.name,
      level: state.level,
      guildXP: state.guildXP,
      xpToNextLevel: xpToNext,
      nextLevelAt: nextLevelXP,
      treasury: state.treasury,
      memberCount: memberCount,
      vaultSlots: state.vault.length,
      vaultMaxSlots: VAULT_MAX_SLOTS,
      perks: state.perks,
      currentChallenge: challengeInfo,
      recentActivity: state.log.slice(-5)
    };
  }

  /**
   * Generate an ASCII/HTML guild banner.
   * @param {object} state - Guild state
   * @returns {string} Banner text
   */
  function formatGuildBanner(state) {
    var memberCount = Object.keys(state.members).length;
    var stars = '';
    for (var i = 0; i < state.level; i++) stars += '*';
    var maxLen = 36;
    var namePad = state.name.length < maxLen ? Math.floor((maxLen - state.name.length) / 2) : 0;
    var nameSpace = '';
    for (var j = 0; j < namePad; j++) nameSpace += ' ';

    var banner = [
      '+--------------------------------------+',
      '|   ~~~ ZION GUILD REGISTRY ~~~        |',
      '+--------------------------------------+',
      '| ' + nameSpace + state.name + nameSpace + ' |',
      '| Level ' + state.level + ' Guild  [' + stars + ']' + new Array(Math.max(1, maxLen - 15 - state.level.toString().length - stars.length)).join(' ') + '|',
      '| Members: ' + memberCount + new Array(Math.max(1, maxLen - 9 - memberCount.toString().length)).join(' ') + '|',
      '| Treasury: ' + state.treasury + ' Spark' + new Array(Math.max(1, maxLen - 16 - state.treasury.toString().length)).join(' ') + '|',
      '| Guild XP: ' + state.guildXP + new Array(Math.max(1, maxLen - 11 - state.guildXP.toString().length)).join(' ') + '|',
      '+--------------------------------------+'
    ].join('\n');

    return banner;
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.WEEKLY_CHALLENGES = WEEKLY_CHALLENGES;
  exports.LEVEL_PERKS = LEVEL_PERKS;
  exports.RANK_DEFINITIONS = RANK_DEFINITIONS;
  exports.RANK_ORDER = RANK_ORDER;
  exports.MAX_GUILD_LEVEL = MAX_GUILD_LEVEL;
  exports.VAULT_MAX_SLOTS = VAULT_MAX_SLOTS;

  exports.createGuildProgression = createGuildProgression;
  exports.addGuildXP = addGuildXP;
  exports.getGuildLevel = getGuildLevel;
  exports.getXPForLevel = getXPForLevel;
  exports.getXPToNextLevel = getXPToNextLevel;
  exports.getGuildPerks = getGuildPerks;

  exports.contributeSpark = contributeSpark;
  exports.withdrawSpark = withdrawSpark;
  exports.getTreasuryLog = getTreasuryLog;

  exports.getRank = getRank;
  exports.hasPermission = hasPermission;
  exports.setRank = setRank;

  exports.getMemberList = getMemberList;

  exports.getWeeklyChallenge = getWeeklyChallenge;
  exports.updateChallengeProgress = updateChallengeProgress;
  exports.getChallengeProgress = getChallengeProgress;

  exports.addToVault = addToVault;
  exports.takeFromVault = takeFromVault;

  exports.getGuildSummary = getGuildSummary;
  exports.formatGuildBanner = formatGuildBanner;

})(typeof module !== 'undefined' ? module.exports : (window.GuildProgression = {}));


// daily_challenges.js
// daily_challenges.js
/**
 * ZION Daily & Weekly Challenge System
 * Streaks, escalating rewards, and seasonal themed challenges
 * Layer: after economy.js (uses spark/xp reward shapes)
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // CHALLENGE POOL â€” 30 challenges across 5 categories
  // ============================================================================

  var CHALLENGE_POOL = [
    // --- Gathering (6) ---
    {
      id: 'gather_5_wood',
      title: 'Lumberjack',
      desc: 'Gather 5 wood',
      target: 5,
      type: 'gather',
      resource: 'wood',
      zone: null,
      category: 'gathering',
      reward: { spark: 10, xp: 15 }
    },
    {
      id: 'gather_5_herbs',
      title: 'Herb Picker',
      desc: 'Gather 5 herbs',
      target: 5,
      type: 'gather',
      resource: 'herbs',
      zone: 'gardens',
      category: 'gathering',
      reward: { spark: 10, xp: 15 }
    },
    {
      id: 'gather_3_iron',
      title: 'Miner',
      desc: 'Gather 3 iron ore',
      target: 3,
      type: 'gather',
      resource: 'iron_ore',
      zone: 'wilds',
      category: 'gathering',
      reward: { spark: 15, xp: 20 }
    },
    {
      id: 'gather_10_any',
      title: 'Resource Rush',
      desc: 'Gather 10 resources of any type',
      target: 10,
      type: 'gather',
      resource: null,
      zone: null,
      category: 'gathering',
      reward: { spark: 20, xp: 25 }
    },
    {
      id: 'gather_crystal',
      title: 'Crystal Hunter',
      desc: 'Find 1 crystal',
      target: 1,
      type: 'gather',
      resource: 'crystal',
      zone: null,
      category: 'gathering',
      reward: { spark: 25, xp: 30 }
    },
    {
      id: 'gather_3_zones',
      title: 'Zone Forager',
      desc: 'Gather in 3 different zones',
      target: 3,
      type: 'gather_zones',
      resource: null,
      zone: null,
      category: 'gathering',
      reward: { spark: 20, xp: 25 }
    },

    // --- Social (6) ---
    {
      id: 'chat_10',
      title: 'Chatterbox',
      desc: 'Send 10 chat messages',
      target: 10,
      type: 'chat',
      zone: null,
      category: 'social',
      reward: { spark: 8, xp: 10 }
    },
    {
      id: 'trade_1',
      title: 'Fair Exchange',
      desc: 'Complete 1 trade',
      target: 1,
      type: 'trade',
      zone: null,
      category: 'social',
      reward: { spark: 15, xp: 20 }
    },
    {
      id: 'greet_3_npcs',
      title: 'Friendly Face',
      desc: 'Greet 3 different NPCs',
      target: 3,
      type: 'greet_npc',
      zone: null,
      category: 'social',
      reward: { spark: 10, xp: 15 }
    },
    {
      id: 'gift_npc',
      title: 'Gift Giver',
      desc: 'Give a gift to any NPC',
      target: 1,
      type: 'gift',
      zone: null,
      category: 'social',
      reward: { spark: 12, xp: 15 }
    },
    {
      id: 'guild_chat_5',
      title: 'Team Player',
      desc: 'Send 5 guild chat messages',
      target: 5,
      type: 'guild_chat',
      zone: null,
      category: 'social',
      reward: { spark: 10, xp: 12 }
    },
    {
      id: 'visit_player',
      title: 'House Guest',
      desc: "Visit another player's house",
      target: 1,
      type: 'visit_house',
      zone: null,
      category: 'social',
      reward: { spark: 12, xp: 15 }
    },

    // --- Exploration (6) ---
    {
      id: 'visit_3_zones',
      title: 'Wanderer',
      desc: 'Visit 3 different zones',
      target: 3,
      type: 'visit_zone',
      zone: null,
      category: 'exploration',
      reward: { spark: 12, xp: 18 }
    },
    {
      id: 'walk_500',
      title: 'Long Walk',
      desc: 'Walk 500 distance units',
      target: 500,
      type: 'distance',
      zone: null,
      category: 'exploration',
      reward: { spark: 10, xp: 15 }
    },
    {
      id: 'discover_1',
      title: 'Discovery',
      desc: 'Find 1 hidden discovery',
      target: 1,
      type: 'discover',
      zone: null,
      category: 'exploration',
      reward: { spark: 20, xp: 25 }
    },
    {
      id: 'night_explore',
      title: 'Night Owl',
      desc: 'Explore during nighttime',
      target: 1,
      type: 'night_action',
      zone: null,
      category: 'exploration',
      reward: { spark: 15, xp: 20 }
    },
    {
      id: 'fast_travel_2',
      title: 'Teleporter',
      desc: 'Fast travel 2 times',
      target: 2,
      type: 'fast_travel',
      zone: null,
      category: 'exploration',
      reward: { spark: 8, xp: 10 }
    },
    {
      id: 'map_check',
      title: 'Cartographer',
      desc: 'Open the world map',
      target: 1,
      type: 'open_map',
      zone: null,
      category: 'exploration',
      reward: { spark: 5, xp: 8 }
    },

    // --- Crafting (6) ---
    {
      id: 'craft_3',
      title: 'Busy Hands',
      desc: 'Craft 3 items',
      target: 3,
      type: 'craft',
      zone: null,
      category: 'crafting',
      reward: { spark: 15, xp: 20 }
    },
    {
      id: 'craft_tool',
      title: 'Tool Maker',
      desc: 'Craft any tool',
      target: 1,
      type: 'craft_category',
      category_filter: 'tool',
      zone: null,
      category: 'crafting',
      reward: { spark: 20, xp: 25 }
    },
    {
      id: 'sell_5_market',
      title: 'Market Seller',
      desc: 'List 5 items on the market',
      target: 5,
      type: 'market_list',
      zone: null,
      category: 'crafting',
      reward: { spark: 15, xp: 18 }
    },
    {
      id: 'buy_3_market',
      title: 'Shopping Spree',
      desc: 'Buy 3 items from market',
      target: 3,
      type: 'market_buy',
      zone: null,
      category: 'crafting',
      reward: { spark: 12, xp: 15 }
    },
    {
      id: 'equip_item',
      title: 'Gear Up',
      desc: 'Equip an item',
      target: 1,
      type: 'equip',
      zone: null,
      category: 'crafting',
      reward: { spark: 8, xp: 10 }
    },
    {
      id: 'cook_food',
      title: 'Chef',
      desc: 'Cook 2 food items',
      target: 2,
      type: 'craft_category',
      category_filter: 'consumable',
      zone: null,
      category: 'crafting',
      reward: { spark: 12, xp: 15 }
    },

    // --- Mini-games (6) ---
    {
      id: 'catch_3_fish',
      title: 'Angler',
      desc: 'Catch 3 fish',
      target: 3,
      type: 'catch_fish',
      zone: null,
      category: 'minigame',
      reward: { spark: 12, xp: 15 }
    },
    {
      id: 'card_battle',
      title: 'Card Duel',
      desc: 'Play 1 card battle',
      target: 1,
      type: 'card_battle',
      zone: null,
      category: 'minigame',
      reward: { spark: 15, xp: 20 }
    },
    {
      id: 'dungeon_room_5',
      title: 'Dungeon Diver',
      desc: 'Clear 5 dungeon rooms',
      target: 5,
      type: 'dungeon_rooms',
      zone: null,
      category: 'minigame',
      reward: { spark: 18, xp: 22 }
    },
    {
      id: 'identify_star',
      title: 'Stargazer',
      desc: 'Identify 1 constellation',
      target: 1,
      type: 'identify_star',
      zone: null,
      category: 'minigame',
      reward: { spark: 12, xp: 15 }
    },
    {
      id: 'bury_capsule',
      title: 'Time Traveler',
      desc: 'Bury a time capsule',
      target: 1,
      type: 'bury_capsule',
      zone: null,
      category: 'minigame',
      reward: { spark: 10, xp: 12 }
    },
    {
      id: 'compose_song',
      title: 'Composer',
      desc: 'Create a music composition',
      target: 1,
      type: 'compose',
      zone: null,
      category: 'minigame',
      reward: { spark: 15, xp: 18 }
    }
  ];

  // ============================================================================
  // SEASONAL CHALLENGE TEMPLATES
  // ============================================================================

  var SEASONAL_CHALLENGES = {
    spring: {
      id: 'seasonal_spring',
      title: 'Bloom Seeker',
      desc: 'Gather 10 spring flowers during the Bloom Festival',
      target: 10,
      type: 'gather',
      resource: 'spring_flower',
      zone: 'gardens',
      category: 'seasonal',
      season: 'spring',
      reward: { spark: 40, xp: 50, item: 'petal_crown' }
    },
    summer: {
      id: 'seasonal_summer',
      title: 'Sun Chaser',
      desc: 'Explore all 8 zones during the Sun Festival',
      target: 8,
      type: 'visit_zone',
      resource: null,
      zone: null,
      category: 'seasonal',
      season: 'summer',
      reward: { spark: 50, xp: 60, item: 'sunstone_charm' }
    },
    autumn: {
      id: 'seasonal_autumn',
      title: 'Harvest Master',
      desc: 'Craft 5 items from harvested resources during Harvest Festival',
      target: 5,
      type: 'craft',
      resource: null,
      zone: null,
      category: 'seasonal',
      season: 'autumn',
      reward: { spark: 45, xp: 55, item: 'amber_pendant' }
    },
    winter: {
      id: 'seasonal_winter',
      title: 'Hearth Keeper',
      desc: 'Trade gifts with 5 players during the Frost Festival',
      target: 5,
      type: 'gift',
      resource: null,
      zone: null,
      category: 'seasonal',
      season: 'winter',
      reward: { spark: 45, xp: 55, item: 'snowflake_crystal' }
    }
  };

  // ============================================================================
  // STREAK MULTIPLIERS
  // ============================================================================

  var STREAK_TIERS = [
    { minDays: 30, multiplier: 3.0 },
    { minDays: 14, multiplier: 2.0 },
    { minDays: 7,  multiplier: 1.5 },
    { minDays: 1,  multiplier: 1.0 }
  ];

  // Weekly meta-quest threshold
  var WEEKLY_META_THRESHOLD = 5;

  // ============================================================================
  // SEEDED RANDOM UTILITY
  // ============================================================================

  /**
   * Simple seeded pseudo-random number generator (Mulberry32).
   * @param {number} seed
   * @returns {function} A function that returns a float in [0, 1) each call.
   */
  function makeSeededRandom(seed) {
    var s = seed >>> 0;
    return function() {
      s += 0x6D2B79F5;
      var t = Math.imul(s ^ (s >>> 15), 1 | s);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) >>> 0;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  /**
   * Fisher-Yates shuffle using a provided random function.
   * Returns a new shuffled array (does not mutate original).
   * @param {Array} arr
   * @param {function} rng  - function returning float in [0,1)
   * @returns {Array}
   */
  function seededShuffle(arr, rng) {
    var result = arr.slice();
    for (var i = result.length - 1; i > 0; i--) {
      var j = Math.floor(rng() * (i + 1));
      var tmp = result[i];
      result[i] = result[j];
      result[j] = tmp;
    }
    return result;
  }

  // ============================================================================
  // STATE FACTORY
  // ============================================================================

  /**
   * Creates a fresh daily challenge state object.
   * @returns {Object}
   */
  function createDailyState() {
    return {
      activeChallenges: [],   // Array of { ...challengeDef, progress: 0, completed: false }
      completedToday: [],     // Array of challenge IDs completed this day
      streak: 0,              // Consecutive days with at least 1 completion
      lastCompletionDay: 0,   // dayNumber of the last recorded completion
      weeklyProgress: 0,      // Dailies completed this week (0-7)
      weeklyCompleted: false, // Whether the weekly meta-quest reward was claimed
      history: [],            // Array of { day, challengeId, reward, streakAtTime }
      totalCompleted: 0       // Lifetime total of completed challenges
    };
  }

  // ============================================================================
  // CHALLENGE GENERATION
  // ============================================================================

  /**
   * Generate a seeded, deduplicated set of daily challenges for a given day.
   * Yesterday's challenges are excluded where possible.
   *
   * @param {number} dayNumber  - The game day number (integer, 1-based)
   * @param {number} [count=3] - How many challenges to return
   * @param {string[]} [excludeIds=[]] - Challenge IDs to exclude (yesterday's)
   * @returns {Array} Array of challenge objects each with progress: 0, completed: false
   */
  function generateDailyChallenges(dayNumber, count, excludeIds) {
    count = (typeof count === 'number' && count > 0) ? count : 3;
    excludeIds = Array.isArray(excludeIds) ? excludeIds : [];

    var rng = makeSeededRandom(dayNumber * 1000003 + 7);
    var shuffled = seededShuffle(CHALLENGE_POOL, rng);

    // Prefer challenges not in yesterday's set
    var preferred = shuffled.filter(function(c) {
      return excludeIds.indexOf(c.id) === -1;
    });
    var fallback = shuffled.filter(function(c) {
      return excludeIds.indexOf(c.id) !== -1;
    });

    // Fill from preferred first, then fallback if needed
    var pool = preferred.concat(fallback);
    var selected = pool.slice(0, count);

    return selected.map(function(c) {
      return copyChallenge(c, 0, false);
    });
  }

  /**
   * Return a shallow copy of a challenge definition with runtime fields added.
   * @param {Object} def  - Challenge definition from CHALLENGE_POOL
   * @param {number} progress
   * @param {boolean} completed
   * @returns {Object}
   */
  function copyChallenge(def, progress, completed) {
    var obj = {};
    var keys = Object.keys(def);
    for (var i = 0; i < keys.length; i++) {
      obj[keys[i]] = def[keys[i]];
    }
    obj.progress = progress;
    obj.completed = completed;
    return obj;
  }

  // ============================================================================
  // STREAK HELPERS
  // ============================================================================

  /**
   * Returns the streak multiplier for a given streak count.
   * @param {number} streak
   * @returns {number}
   */
  function getStreakMultiplier(streak) {
    for (var i = 0; i < STREAK_TIERS.length; i++) {
      if (streak >= STREAK_TIERS[i].minDays) {
        return STREAK_TIERS[i].multiplier;
      }
    }
    return 1.0;
  }

  /**
   * Returns the current streak from state.
   * @param {Object} state
   * @returns {number}
   */
  function getStreak(state) {
    return state.streak || 0;
  }

  // ============================================================================
  // REWARD CALCULATION
  // ============================================================================

  /**
   * Apply streak multiplier to a reward object.
   * Returns a new reward object â€” does not mutate input.
   * @param {Object} baseReward  - { spark, xp, [item] }
   * @param {number} multiplier
   * @returns {Object}
   */
  function applyStreakMultiplier(baseReward, multiplier) {
    var result = {};
    result.spark = Math.round(baseReward.spark * multiplier);
    result.xp = Math.round(baseReward.xp * multiplier);
    if (baseReward.item) {
      result.item = baseReward.item;
    }
    return result;
  }

  // ============================================================================
  // PROGRESS & COMPLETION
  // ============================================================================

  /**
   * Update progress on a specific challenge by ID.
   * Auto-completes if target is reached.
   * Mutates the provided state (creates a new state copy, does not mutate in place).
   *
   * @param {Object} state        - Daily challenge state
   * @param {string} challengeId  - The challenge to advance
   * @param {number} [amount=1]   - How much progress to add
   * @returns {{ state, completed, reward, streakBonus, message }}
   */
  function updateProgress(state, challengeId, amount) {
    amount = (typeof amount === 'number') ? amount : 1;

    // Deep-copy the active challenges array to avoid mutations
    var newState = shallowCopyState(state);
    var challenge = findActive(newState, challengeId);

    if (!challenge) {
      return {
        state: newState,
        completed: false,
        reward: null,
        streakBonus: false,
        message: 'Challenge not found or not active'
      };
    }

    if (challenge.completed) {
      return {
        state: newState,
        completed: false,
        reward: null,
        streakBonus: false,
        message: 'Challenge already completed'
      };
    }

    challenge.progress = Math.min(challenge.progress + amount, challenge.target);

    if (challenge.progress >= challenge.target) {
      return completeChallenge(newState, challengeId);
    }

    return {
      state: newState,
      completed: false,
      reward: null,
      streakBonus: false,
      message: challenge.progress + ' / ' + challenge.target
    };
  }

  /**
   * Mark a challenge as complete, award rewards, update streak.
   * @param {Object} state
   * @param {string} challengeId
   * @returns {{ state, reward, message }}
   */
  function completeChallenge(state, challengeId) {
    var newState = shallowCopyState(state);
    var challenge = findActive(newState, challengeId);

    if (!challenge) {
      return {
        state: newState,
        completed: false,
        reward: null,
        streakBonus: false,
        message: 'Challenge not found'
      };
    }

    if (challenge.completed) {
      return {
        state: newState,
        completed: false,
        reward: null,
        streakBonus: false,
        message: 'Challenge already completed'
      };
    }

    // Mark complete
    challenge.completed = true;
    challenge.progress = challenge.target;

    if (newState.completedToday.indexOf(challengeId) === -1) {
      newState.completedToday = newState.completedToday.concat([challengeId]);
    }

    // --- Streak update ---
    // Streak increments when we complete a challenge on a new day.
    // The day tracking is done by the caller through resetDaily / dayNumber context.
    // Here we just bump streak if this is the first completion today (completedToday.length === 1).
    var isFirstToday = newState.completedToday.length === 1;
    var streakBonusGranted = false;
    if (isFirstToday) {
      newState.streak = (newState.streak || 0) + 1;
      streakBonusGranted = true;
    }

    // Weekly progress
    newState.weeklyProgress = (newState.weeklyProgress || 0) + 1;

    // Lifetime counter
    newState.totalCompleted = (newState.totalCompleted || 0) + 1;

    // Reward with streak multiplier
    var multiplier = getStreakMultiplier(newState.streak);
    var baseReward = challenge.reward;
    var finalReward = applyStreakMultiplier(baseReward, multiplier);

    // Record history
    var historyEntry = {
      challengeId: challengeId,
      reward: finalReward,
      streakAtTime: newState.streak,
      multiplier: multiplier
    };
    newState.history = newState.history.concat([historyEntry]);

    // Check weekly meta
    var weeklyResult = checkWeeklyMeta(newState);
    var weeklyMsg = '';
    if (weeklyResult.justCompleted) {
      newState.weeklyCompleted = true;
      weeklyMsg = ' Weekly meta-quest complete! Bonus reward unlocked.';
    }

    return {
      state: newState,
      completed: true,
      reward: finalReward,
      streakBonus: streakBonusGranted,
      message: '"' + challenge.title + '" complete! +' + finalReward.spark + ' Spark, +' + finalReward.xp + ' XP' + weeklyMsg
    };
  }

  // ============================================================================
  // ACCESSORS
  // ============================================================================

  /**
   * Returns the active challenges (with progress) from state.
   * @param {Object} state
   * @returns {Array}
   */
  function getActiveChallenges(state) {
    return state.activeChallenges || [];
  }

  /**
   * Check if the weekly meta-quest was just completed (crossed the threshold).
   * @param {Object} state
   * @returns {{ complete: boolean, justCompleted: boolean, progress: number, target: number }}
   */
  function checkWeeklyMeta(state) {
    var progress = state.weeklyProgress || 0;
    var wasComplete = state.weeklyCompleted || false;
    var nowComplete = progress >= WEEKLY_META_THRESHOLD;
    return {
      complete: nowComplete,
      justCompleted: nowComplete && !wasComplete,
      progress: progress,
      target: WEEKLY_META_THRESHOLD
    };
  }

  /**
   * Returns the weekly bonus reward object.
   * @returns {Object}
   */
  function getWeeklyReward() {
    var rareItems = [
      'enchanted_scroll',
      'moonstone_gem',
      'phoenix_feather',
      'dragon_scale',
      'void_shard',
      'aurora_crystal',
      'ancient_coin',
      'star_fragment'
    ];
    // Deterministic "random" for stability: pick based on current week epoch
    var weekIndex = Math.floor(Date.now() / (7 * 24 * 60 * 60 * 1000)) % rareItems.length;
    return {
      spark: 100,
      xp: 150,
      item: rareItems[weekIndex]
    };
  }

  /**
   * Reset state for a new day, preserving streak if days are consecutive.
   * "Consecutive" means lastCompletionDay === newDayNumber - 1.
   *
   * @param {Object} state
   * @param {number} newDayNumber
   * @param {number} [count=3] - How many new challenges to generate
   * @returns {Object} New state for the new day
   */
  function resetDaily(state, newDayNumber, count) {
    count = (typeof count === 'number' && count > 0) ? count : 3;

    var newState = shallowCopyState(state);

    // Determine streak continuity
    var lastDay = newState.lastCompletionDay || 0;
    var hadCompletionYesterday = newState.completedToday.length > 0;

    // If the player completed something yesterday and we're exactly 1 day later, keep streak.
    // Otherwise if they missed a day, reset streak.
    if (hadCompletionYesterday) {
      newState.lastCompletionDay = lastDay; // will be set properly below
    }

    // Check if streak should be preserved
    var shouldPreserveStreak = (lastDay > 0) && (newDayNumber === lastDay + 1) && (newState.completedToday.length > 0);

    if (!shouldPreserveStreak && newState.completedToday.length === 0 && lastDay > 0) {
      // Missed a day â€” reset streak
      newState.streak = 0;
    }
    // (If shouldPreserveStreak, streak was already incremented during completeChallenge)

    // Get yesterday's IDs to avoid repeats
    var yesterdayIds = newState.activeChallenges.map(function(c) { return c.id; });

    // Update day tracking
    if (hadCompletionYesterday) {
      newState.lastCompletionDay = lastDay; // record what day we just finished
    }

    // Reset weekly if a full week has passed (every 7 days)
    // Week boundary: check if newDayNumber starts a new 7-day block
    var oldWeekBlock = Math.floor((lastDay - 1) / 7);
    var newWeekBlock = Math.floor((newDayNumber - 1) / 7);
    if (newWeekBlock > oldWeekBlock) {
      newState.weeklyProgress = 0;
      newState.weeklyCompleted = false;
    }

    // Generate new challenges
    newState.activeChallenges = generateDailyChallenges(newDayNumber, count, yesterdayIds);
    newState.completedToday = [];

    return newState;
  }

  /**
   * Get a challenge definition by ID.
   * @param {string} challengeId
   * @returns {Object|null}
   */
  function getChallengeById(challengeId) {
    for (var i = 0; i < CHALLENGE_POOL.length; i++) {
      if (CHALLENGE_POOL[i].id === challengeId) {
        return CHALLENGE_POOL[i];
      }
    }
    // Also check seasonal
    var seasons = Object.keys(SEASONAL_CHALLENGES);
    for (var j = 0; j < seasons.length; j++) {
      if (SEASONAL_CHALLENGES[seasons[j]].id === challengeId) {
        return SEASONAL_CHALLENGES[seasons[j]];
      }
    }
    return null;
  }

  /**
   * Get recent completion history.
   * @param {Object} state
   * @param {number} [limit=10]
   * @returns {Array}
   */
  function getCompletionHistory(state, limit) {
    limit = (typeof limit === 'number' && limit > 0) ? limit : 10;
    var history = state.history || [];
    return history.slice(-limit);
  }

  /**
   * Get the seasonal bonus challenge for the current season and day.
   * @param {string} season  - 'spring' | 'summer' | 'autumn' | 'winter'
   * @param {number} dayNumber
   * @returns {Object|null}
   */
  function getSeasonalChallenge(season, dayNumber) {
    var def = SEASONAL_CHALLENGES[season];
    if (!def) return null;

    var copy = copyChallenge(def, 0, false);
    // Vary the description slightly based on dayNumber to give uniqueness
    copy.dayNumber = dayNumber;
    return copy;
  }

  // ============================================================================
  // FORMATTING
  // ============================================================================

  /**
   * Render an HTML card for a challenge.
   * @param {Object} challenge    - challenge object (with progress and completed fields)
   * @param {number} [progress]   - override progress value (optional)
   * @param {number} [streakMultiplier=1]
   * @returns {string} HTML string
   */
  function formatChallengeCard(challenge, progress, streakMultiplier) {
    if (typeof progress !== 'number') progress = challenge.progress || 0;
    streakMultiplier = (typeof streakMultiplier === 'number') ? streakMultiplier : 1;

    var pct = Math.min(100, Math.round((progress / challenge.target) * 100));
    var isComplete = challenge.completed || progress >= challenge.target;
    var bonusSpark = Math.round(challenge.reward.spark * streakMultiplier);
    var bonusXp = Math.round(challenge.reward.xp * streakMultiplier);
    var completedClass = isComplete ? ' challenge-complete' : '';
    var checkmark = isComplete ? '<span class="challenge-check">&#x2713;</span>' : '';

    var categoryColors = {
      gathering: '#7db37d',
      social: '#6fa8dc',
      exploration: '#e8b860',
      crafting: '#d4a040',
      minigame: '#b87dc0',
      seasonal: '#ff8c42'
    };
    var catColor = categoryColors[challenge.category] || '#aaa';

    return '<div class="challenge-card' + completedClass + '" data-id="' + challenge.id + '">' +
      '<div class="challenge-category-bar" style="background:' + catColor + '"></div>' +
      '<div class="challenge-header">' +
        checkmark +
        '<span class="challenge-title">' + challenge.title + '</span>' +
        '<span class="challenge-category">' + (challenge.category || '') + '</span>' +
      '</div>' +
      '<p class="challenge-desc">' + challenge.desc + '</p>' +
      '<div class="challenge-progress-bar">' +
        '<div class="challenge-progress-fill" style="width:' + pct + '%"></div>' +
      '</div>' +
      '<div class="challenge-progress-text">' + progress + ' / ' + challenge.target + '</div>' +
      '<div class="challenge-reward">' +
        '<span class="challenge-spark">+' + bonusSpark + ' Spark</span>' +
        '<span class="challenge-xp">+' + bonusXp + ' XP</span>' +
        (streakMultiplier > 1 ? '<span class="challenge-multiplier">x' + streakMultiplier.toFixed(1) + '</span>' : '') +
      '</div>' +
    '</div>';
  }

  /**
   * Render an HTML streak display.
   * @param {number} streak
   * @returns {string} HTML string
   */
  function formatStreakDisplay(streak) {
    streak = streak || 0;
    var multiplier = getStreakMultiplier(streak);
    var fireEmoji = streak >= 30 ? '&#x1F525;&#x1F525;&#x1F525;' :
                    streak >= 14 ? '&#x1F525;&#x1F525;' :
                    streak >= 7  ? '&#x1F525;' : '';
    var tierLabel = streak >= 30 ? ' (3x Rewards!)' :
                    streak >= 14 ? ' (2x Rewards!)' :
                    streak >= 7  ? ' (1.5x Rewards!)' : '';

    return '<div class="streak-display">' +
      '<span class="streak-fire">' + fireEmoji + '</span>' +
      '<span class="streak-count">' + streak + '</span>' +
      '<span class="streak-label"> day streak' + tierLabel + '</span>' +
      '<div class="streak-multiplier-badge">x' + multiplier.toFixed(1) + '</div>' +
    '</div>';
  }

  // ============================================================================
  // INTERNAL HELPERS
  // ============================================================================

  /**
   * Shallow-copy the top-level state plus deep-copy activeChallenges and arrays.
   * @param {Object} state
   * @returns {Object}
   */
  function shallowCopyState(state) {
    var s = {};
    var keys = Object.keys(state);
    for (var i = 0; i < keys.length; i++) {
      s[keys[i]] = state[keys[i]];
    }
    // Deep copy mutable arrays
    s.activeChallenges = (state.activeChallenges || []).map(function(c) {
      return copyChallenge(c, c.progress, c.completed);
    });
    s.completedToday = (state.completedToday || []).slice();
    s.history = (state.history || []).slice();
    return s;
  }

  /**
   * Find a challenge in state.activeChallenges by ID (returns reference into copy).
   * @param {Object} state
   * @param {string} challengeId
   * @returns {Object|null}
   */
  function findActive(state, challengeId) {
    var challenges = state.activeChallenges || [];
    for (var i = 0; i < challenges.length; i++) {
      if (challenges[i].id === challengeId) {
        return challenges[i];
      }
    }
    return null;
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.CHALLENGE_POOL         = CHALLENGE_POOL;
  exports.SEASONAL_CHALLENGES    = SEASONAL_CHALLENGES;
  exports.STREAK_TIERS           = STREAK_TIERS;
  exports.WEEKLY_META_THRESHOLD  = WEEKLY_META_THRESHOLD;

  exports.createDailyState       = createDailyState;
  exports.generateDailyChallenges = generateDailyChallenges;
  exports.updateProgress         = updateProgress;
  exports.completeChallenge      = completeChallenge;
  exports.getActiveChallenges    = getActiveChallenges;
  exports.getStreak              = getStreak;
  exports.getStreakMultiplier    = getStreakMultiplier;
  exports.checkWeeklyMeta        = checkWeeklyMeta;
  exports.getWeeklyReward        = getWeeklyReward;
  exports.resetDaily             = resetDaily;
  exports.getChallengeById       = getChallengeById;
  exports.formatChallengeCard    = formatChallengeCard;
  exports.formatStreakDisplay    = formatStreakDisplay;
  exports.getCompletionHistory   = getCompletionHistory;
  exports.getSeasonalChallenge   = getSeasonalChallenge;

})(typeof module !== 'undefined' ? module.exports : (window.DailyChallenges = {}));


// apprenticeship.js
// apprenticeship.js
/**
 * ZION Apprenticeship & Teaching System
 * Players mentor NPC citizens; AI agents learn from player behavior.
 */

(function(exports) {
  'use strict';

  // ============================================================================
  // TEACHING TOPICS
  // ============================================================================

  var TOPICS = {
    farming: {
      name: 'Farming',
      zone: 'gardens',
      xpReward: 30,
      sparkReward: 15,
      desc: 'Teach crop rotation and plant care'
    },
    cooking: {
      name: 'Cooking',
      zone: 'commons',
      xpReward: 25,
      sparkReward: 12,
      desc: 'Share recipes and preparation methods'
    },
    smithing: {
      name: 'Smithing',
      zone: 'studio',
      xpReward: 35,
      sparkReward: 18,
      desc: 'Demonstrate metalworking techniques'
    },
    trading: {
      name: 'Trading',
      zone: 'agora',
      xpReward: 30,
      sparkReward: 20,
      desc: 'Teach negotiation and market analysis'
    },
    navigation: {
      name: 'Navigation',
      zone: 'wilds',
      xpReward: 28,
      sparkReward: 14,
      desc: 'Guide through terrain reading and pathfinding'
    },
    history: {
      name: 'History',
      zone: 'athenaeum',
      xpReward: 25,
      sparkReward: 12,
      desc: 'Share knowledge of ZION lore and origins'
    },
    combat: {
      name: 'Combat',
      zone: 'arena',
      xpReward: 32,
      sparkReward: 16,
      desc: 'Train fighting stances and defense'
    },
    music: {
      name: 'Music',
      zone: 'studio',
      xpReward: 22,
      sparkReward: 11,
      desc: 'Teach melody, rhythm, and harmony'
    },
    healing: {
      name: 'Healing',
      zone: 'gardens',
      xpReward: 28,
      sparkReward: 15,
      desc: 'Demonstrate herbal remedies and first aid'
    },
    building: {
      name: 'Building',
      zone: 'commons',
      xpReward: 30,
      sparkReward: 14,
      desc: 'Teach structural design and construction'
    },
    fishing: {
      name: 'Fishing',
      zone: 'wilds',
      xpReward: 20,
      sparkReward: 10,
      desc: 'Share fishing techniques and bait knowledge'
    },
    stargazing: {
      name: 'Stargazing',
      zone: 'nexus',
      xpReward: 25,
      sparkReward: 12,
      desc: 'Identify constellations and celestial events'
    }
  };

  // ============================================================================
  // NPC ARCHETYPE â†’ TEACHABLE TOPICS
  // ============================================================================

  var ARCHETYPE_TOPICS = {
    gardener:    ['farming', 'healing', 'fishing'],
    builder:     ['building', 'smithing', 'navigation'],
    storyteller: ['history', 'music', 'stargazing'],
    merchant:    ['trading', 'cooking', 'history'],
    explorer:    ['navigation', 'fishing', 'stargazing'],
    teacher:     ['history', 'stargazing', 'healing'],
    musician:    ['music', 'history', 'cooking'],
    healer:      ['healing', 'farming', 'cooking'],
    philosopher: ['history', 'stargazing', 'navigation'],
    artist:      ['music', 'smithing', 'building']
  };

  // ============================================================================
  // LESSON STEPS
  // ============================================================================

  var LESSON_STEPS = {
    farming: [
      { index: 0, phase: 'introduce', instruction: 'Show the student how to prepare soil', action: 'gather_herb', description: 'Gather 3 plants to demonstrate crop variety' },
      { index: 1, phase: 'practice',  instruction: 'Guide the student through planting seeds', action: 'plant_seed', description: 'Plant seeds in the correct pattern' },
      { index: 2, phase: 'master',    instruction: 'Demonstrate crop rotation strategy', action: 'answer_question', description: 'Answer: which crops restore soil nutrients?' }
    ],
    cooking: [
      { index: 0, phase: 'introduce', instruction: 'Introduce basic ingredients and their uses', action: 'gather_herb', description: 'Gather 2 cooking herbs' },
      { index: 1, phase: 'practice',  instruction: 'Walk through a recipe step by step', action: 'craft_tool', description: 'Prepare a simple dish together' },
      { index: 2, phase: 'master',    instruction: 'Teach flavor balancing techniques', action: 'answer_question', description: 'Answer: what balances a salty dish?' }
    ],
    smithing: [
      { index: 0, phase: 'introduce', instruction: 'Explain the properties of different metals', action: 'gather_ore', description: 'Gather 2 ore samples to compare' },
      { index: 1, phase: 'practice',  instruction: 'Demonstrate hammer technique at the forge', action: 'craft_tool', description: 'Forge a simple iron item together' },
      { index: 2, phase: 'master',    instruction: 'Show the secret of proper tempering', action: 'answer_question', description: 'Answer: at what temperature does iron become workable?' }
    ],
    trading: [
      { index: 0, phase: 'introduce', instruction: 'Explain the value of goods in each zone', action: 'answer_question', description: 'Answer: which zone values crafted items most?' },
      { index: 1, phase: 'practice',  instruction: 'Role-play a negotiation scenario', action: 'negotiate', description: 'Complete a mock trade negotiation' },
      { index: 2, phase: 'master',    instruction: 'Analyze market supply and demand', action: 'answer_question', description: 'Answer: when is the best time to sell rare goods?' }
    ],
    navigation: [
      { index: 0, phase: 'introduce', instruction: 'Point out landmarks in the current zone', action: 'observe_landmark', description: 'Identify 2 notable landmarks nearby' },
      { index: 1, phase: 'practice',  instruction: 'Walk a planned route through the wilds', action: 'follow_path', description: 'Navigate from one waypoint to another' },
      { index: 2, phase: 'master',    instruction: 'Read terrain elevation for pathfinding', action: 'answer_question', description: 'Answer: how do you find the safest mountain pass?' }
    ],
    history: [
      { index: 0, phase: 'introduce', instruction: 'Recount the founding of ZION', action: 'answer_question', description: 'Answer: who first settled the Nexus?' },
      { index: 1, phase: 'practice',  instruction: 'Discuss the formation of the zones', action: 'answer_question', description: 'Answer: which zone was established last?' },
      { index: 2, phase: 'master',    instruction: 'Tell the story of the Great Council', action: 'tell_story', description: 'Narrate a historical event to the student' }
    ],
    combat: [
      { index: 0, phase: 'introduce', instruction: 'Demonstrate basic defensive stances', action: 'perform_stance', description: 'Show 3 defensive positions' },
      { index: 1, phase: 'practice',  instruction: 'Spar lightly to test reaction time', action: 'spar', description: 'Complete a light sparring round' },
      { index: 2, phase: 'master',    instruction: 'Teach counter-attack timing', action: 'answer_question', description: 'Answer: when is the optimal moment to counter-strike?' }
    ],
    music: [
      { index: 0, phase: 'introduce', instruction: 'Explain the fundamentals of rhythm', action: 'clap_rhythm', description: 'Clap out a basic rhythm pattern' },
      { index: 1, phase: 'practice',  instruction: 'Teach a simple melody together', action: 'play_melody', description: 'Play a 4-note melody sequence' },
      { index: 2, phase: 'master',    instruction: 'Combine melody and harmony', action: 'answer_question', description: 'Answer: what interval creates a harmonious chord?' }
    ],
    healing: [
      { index: 0, phase: 'introduce', instruction: 'Identify common medicinal plants', action: 'gather_herb', description: 'Gather 3 healing herbs' },
      { index: 1, phase: 'practice',  instruction: 'Prepare a basic herbal remedy', action: 'craft_tool', description: 'Mix a simple poultice' },
      { index: 2, phase: 'master',    instruction: 'Diagnose ailments by symptoms', action: 'answer_question', description: 'Answer: what herb treats fever?' }
    ],
    building: [
      { index: 0, phase: 'introduce', instruction: 'Explain load-bearing principles', action: 'answer_question', description: 'Answer: which shape is the strongest foundation?' },
      { index: 1, phase: 'practice',  instruction: 'Lay a foundation together', action: 'craft_tool', description: 'Place 4 foundation stones correctly' },
      { index: 2, phase: 'master',    instruction: 'Design a room with proper proportions', action: 'answer_question', description: 'Answer: what ratio gives ideal room proportions?' }
    ],
    fishing: [
      { index: 0, phase: 'introduce', instruction: 'Explain bait selection for different fish', action: 'gather_herb', description: 'Gather 2 types of bait' },
      { index: 1, phase: 'practice',  instruction: 'Cast and retrieve a fishing line', action: 'cast_line', description: 'Successfully cast and reel in once' },
      { index: 2, phase: 'master',    instruction: 'Identify the best fishing spots', action: 'answer_question', description: 'Answer: what water depth holds the biggest fish?' }
    ],
    stargazing: [
      { index: 0, phase: 'introduce', instruction: 'Point out the main constellations', action: 'observe_landmark', description: 'Identify 3 constellations overhead' },
      { index: 1, phase: 'practice',  instruction: 'Track a moving celestial body', action: 'follow_path', description: 'Follow a planet across the sky' },
      { index: 2, phase: 'master',    instruction: 'Predict weather using star patterns', action: 'answer_question', description: 'Answer: which star cluster signals incoming rain?' }
    ]
  };

  // ============================================================================
  // SKILL LEVELS
  // ============================================================================

  var SKILL_LEVEL_NAMES = ['Untrained', 'Novice', 'Practiced', 'Skilled', 'Expert', 'Master'];

  // ============================================================================
  // TEACHER RANKS
  // ============================================================================

  var TEACHER_RANKS = [
    { min: 0,   max: 49,  rank: 'Tutor' },
    { min: 50,  max: 149, rank: 'Instructor' },
    { min: 150, max: 299, rank: 'Professor' },
    { min: 300, max: Infinity, rank: 'Grand Teacher' }
  ];

  // ============================================================================
  // ID COUNTER
  // ============================================================================

  var lessonIdCounter = 0;

  // ============================================================================
  // STATE FACTORY
  // ============================================================================

  function createApprenticeshipState() {
    return {
      mentorships: {},       // lessonId -> lesson object
      npcSkills: {},         // npcId -> { topic: skillLevel }
      lessonHistory: [],     // completed lesson records
      playerTeachingXP: {}   // playerId -> total teaching XP
    };
  }

  // ============================================================================
  // LESSON STEPS HELPER
  // ============================================================================

  function getLessonSteps(topic) {
    if (!TOPICS[topic]) {
      return null;
    }
    return LESSON_STEPS[topic] || null;
  }

  // ============================================================================
  // SKILL HELPERS
  // ============================================================================

  function getNPCSkill(state, npcId, topic) {
    if (!state || !state.npcSkills) return 0;
    if (!state.npcSkills[npcId]) return 0;
    var level = state.npcSkills[npcId][topic];
    return (typeof level === 'number') ? level : 0;
  }

  function getNPCSkillName(level) {
    if (typeof level !== 'number' || level < 0) return SKILL_LEVEL_NAMES[0];
    if (level >= SKILL_LEVEL_NAMES.length) return SKILL_LEVEL_NAMES[SKILL_LEVEL_NAMES.length - 1];
    return SKILL_LEVEL_NAMES[Math.floor(level)] || SKILL_LEVEL_NAMES[0];
  }

  // ============================================================================
  // ARCHETYPE HELPER
  // ============================================================================

  function getTeachableTopics(npcArchetype) {
    if (!npcArchetype) return [];
    var topics = ARCHETYPE_TOPICS[npcArchetype];
    if (!topics) return [];
    return topics.slice();
  }

  // ============================================================================
  // TEACHER RANK HELPER
  // ============================================================================

  function getTeacherRank(teachingXP) {
    var xp = typeof teachingXP === 'number' ? teachingXP : 0;
    for (var i = 0; i < TEACHER_RANKS.length; i++) {
      var bracket = TEACHER_RANKS[i];
      if (xp >= bracket.min && xp <= bracket.max) {
        return bracket.rank;
      }
    }
    return 'Tutor';
  }

  // ============================================================================
  // PLAYER STATS
  // ============================================================================

  function getPlayerTeachingStats(state, playerId) {
    if (!state || !playerId) {
      return { totalLessons: 0, topicsTaught: [], studentsTaught: [], teachingXP: 0, teacherRank: 'Tutor' };
    }

    var history = state.lessonHistory || [];
    var teachingXP = (state.playerTeachingXP && state.playerTeachingXP[playerId]) || 0;

    var totalLessons = 0;
    var topicsSet = {};
    var studentsSet = {};

    for (var i = 0; i < history.length; i++) {
      var record = history[i];
      if (record.teacherId === playerId) {
        totalLessons++;
        if (record.topic) topicsSet[record.topic] = true;
        if (record.npcId) studentsSet[record.npcId] = true;
      }
    }

    return {
      totalLessons: totalLessons,
      topicsTaught: Object.keys(topicsSet),
      studentsTaught: Object.keys(studentsSet),
      teachingXP: teachingXP,
      teacherRank: getTeacherRank(teachingXP)
    };
  }

  // ============================================================================
  // ACTIVE LESSONS
  // ============================================================================

  function getActiveLessons(state, playerId) {
    if (!state || !state.mentorships) return [];
    var active = [];
    var ids = Object.keys(state.mentorships);
    for (var i = 0; i < ids.length; i++) {
      var lesson = state.mentorships[ids[i]];
      if (lesson && lesson.teacherId === playerId && !lesson.completed) {
        active.push(lesson);
      }
    }
    return active;
  }

  // ============================================================================
  // NPC STUDENTS
  // ============================================================================

  function getNPCStudents(state, playerId) {
    if (!state || !state.lessonHistory) return [];
    var seen = {};
    var students = [];
    for (var i = 0; i < state.lessonHistory.length; i++) {
      var record = state.lessonHistory[i];
      if (record.teacherId === playerId && record.npcId && !seen[record.npcId]) {
        seen[record.npcId] = true;
        students.push(record.npcId);
      }
    }
    return students;
  }

  // ============================================================================
  // START LESSON
  // ============================================================================

  function startLesson(state, playerId, npcId, topic) {
    if (!state) {
      return { state: state, lesson: null, message: 'Invalid state' };
    }

    // Validate topic
    if (!topic || !TOPICS[topic]) {
      return { state: state, lesson: null, message: 'Unknown teaching topic: ' + topic };
    }

    // Validate players
    if (!playerId) {
      return { state: state, lesson: null, message: 'Invalid player ID' };
    }
    if (!npcId) {
      return { state: state, lesson: null, message: 'Invalid NPC ID' };
    }

    // Check NPC is not already in an active lesson with this player
    var activeLessons = getActiveLessons(state, playerId);
    for (var i = 0; i < activeLessons.length; i++) {
      if (activeLessons[i].npcId === npcId) {
        return {
          state: state,
          lesson: null,
          message: 'This NPC is already in an active lesson with you'
        };
      }
    }

    var steps = getLessonSteps(topic);
    if (!steps) {
      return { state: state, lesson: null, message: 'No lesson steps defined for topic: ' + topic };
    }

    lessonIdCounter++;
    var lessonId = 'lesson_' + lessonIdCounter + '_' + Date.now();

    var lesson = {
      id: lessonId,
      topic: topic,
      npcId: npcId,
      teacherId: playerId,
      step: 0,
      steps: steps,
      startedAt: Date.now(),
      completed: false,
      abandoned: false
    };

    var newState = _copyState(state);
    newState.mentorships[lessonId] = lesson;

    var topicData = TOPICS[topic];
    return {
      state: newState,
      lesson: lesson,
      message: 'Lesson started: ' + topicData.name + '. Step 1 of 3 â€” ' + steps[0].instruction
    };
  }

  // ============================================================================
  // ADVANCE LESSON
  // ============================================================================

  function advanceLesson(state, lessonId, action) {
    if (!state || !state.mentorships) {
      return { state: state, step: null, completed: false, reward: null, message: 'Invalid state' };
    }

    var lesson = state.mentorships[lessonId];
    if (!lesson) {
      return { state: state, step: null, completed: false, reward: null, message: 'Lesson not found: ' + lessonId };
    }

    if (lesson.completed) {
      return { state: state, step: null, completed: true, reward: null, message: 'Lesson is already completed' };
    }

    if (lesson.abandoned) {
      return { state: state, step: null, completed: false, reward: null, message: 'Lesson has been abandoned' };
    }

    var currentStep = lesson.steps[lesson.step];
    if (!currentStep) {
      return { state: state, step: null, completed: false, reward: null, message: 'No more steps' };
    }

    // Check action matches expected
    var actionValid = (action && action === currentStep.action);

    var newState = _copyState(state);
    var updatedLesson = _copyLesson(newState.mentorships[lessonId]);
    newState.mentorships[lessonId] = updatedLesson;

    if (!actionValid) {
      return {
        state: newState,
        step: currentStep,
        completed: false,
        reward: null,
        message: 'Incorrect action. Expected: ' + currentStep.action + ', got: ' + (action || 'nothing') + '. Try again: ' + currentStep.description
      };
    }

    // Advance step
    updatedLesson.step++;

    var isCompleted = (updatedLesson.step >= updatedLesson.steps.length);

    if (isCompleted) {
      // Mark ready for completion
      updatedLesson.readyToComplete = true;
    }

    var nextStep = isCompleted ? null : updatedLesson.steps[updatedLesson.step];
    var message = isCompleted
      ? 'All steps done! Call completeLesson to finalize and award rewards.'
      : 'Step ' + (updatedLesson.step) + ' complete. Next: ' + nextStep.instruction;

    return {
      state: newState,
      step: nextStep,
      completed: isCompleted,
      reward: null,
      message: message
    };
  }

  // ============================================================================
  // COMPLETE LESSON
  // ============================================================================

  function completeLesson(state, lessonId) {
    if (!state || !state.mentorships) {
      return { state: state, playerReward: null, npcSkillGain: null, message: 'Invalid state' };
    }

    var lesson = state.mentorships[lessonId];
    if (!lesson) {
      return { state: state, playerReward: null, npcSkillGain: null, message: 'Lesson not found: ' + lessonId };
    }

    if (lesson.completed) {
      return { state: state, playerReward: null, npcSkillGain: null, message: 'Lesson already completed' };
    }

    if (!lesson.readyToComplete) {
      return { state: state, playerReward: null, npcSkillGain: null, message: 'Lesson not yet finished. Complete all steps first.' };
    }

    var topicData = TOPICS[lesson.topic];
    if (!topicData) {
      return { state: state, playerReward: null, npcSkillGain: null, message: 'Invalid topic in lesson' };
    }

    var newState = _copyState(state);
    var updatedLesson = _copyLesson(newState.mentorships[lessonId]);
    updatedLesson.completed = true;
    updatedLesson.completedAt = Date.now();
    newState.mentorships[lessonId] = updatedLesson;

    // NPC skill gain
    if (!newState.npcSkills[lesson.npcId]) {
      newState.npcSkills[lesson.npcId] = {};
    }
    var currentSkill = newState.npcSkills[lesson.npcId][lesson.topic] || 0;
    var maxSkill = SKILL_LEVEL_NAMES.length - 1;
    var newSkillLevel = Math.min(currentSkill + 1, maxSkill);
    newState.npcSkills[lesson.npcId][lesson.topic] = newSkillLevel;

    // Player teaching XP
    if (!newState.playerTeachingXP) {
      newState.playerTeachingXP = {};
    }
    var currentXP = newState.playerTeachingXP[lesson.teacherId] || 0;
    newState.playerTeachingXP[lesson.teacherId] = currentXP + topicData.xpReward;

    // Record in lesson history
    var historyRecord = {
      lessonId: lessonId,
      teacherId: lesson.teacherId,
      npcId: lesson.npcId,
      topic: lesson.topic,
      completedAt: updatedLesson.completedAt,
      xpAwarded: topicData.xpReward,
      sparkAwarded: topicData.sparkReward,
      npcSkillBefore: currentSkill,
      npcSkillAfter: newSkillLevel
    };
    newState.lessonHistory.push(historyRecord);

    var playerReward = {
      xp: topicData.xpReward,
      spark: topicData.sparkReward,
      teacherRank: getTeacherRank(newState.playerTeachingXP[lesson.teacherId])
    };

    var npcSkillGain = {
      npcId: lesson.npcId,
      topic: lesson.topic,
      before: currentSkill,
      after: newSkillLevel,
      skillName: getNPCSkillName(newSkillLevel)
    };

    var message = 'Lesson complete! ' + lesson.npcId + ' has become ' +
      getNPCSkillName(newSkillLevel) + ' in ' + topicData.name +
      '. You earned ' + topicData.xpReward + ' XP and ' + topicData.sparkReward + ' Spark.';

    return {
      state: newState,
      playerReward: playerReward,
      npcSkillGain: npcSkillGain,
      message: message
    };
  }

  // ============================================================================
  // FORMAT HELPERS
  // ============================================================================

  function formatLessonCard(lesson) {
    if (!lesson) return '<div class="lesson-card lesson-card--empty">No lesson</div>';

    var topic = TOPICS[lesson.topic];
    var topicName = topic ? topic.name : lesson.topic;
    var stepNum = lesson.step || 0;
    var totalSteps = lesson.steps ? lesson.steps.length : 3;
    var progress = Math.min(stepNum, totalSteps);
    var pct = Math.round((progress / totalSteps) * 100);

    var currentStep = (lesson.steps && lesson.steps[stepNum]) || null;
    var stepHtml = currentStep
      ? '<p class="lesson-card__step">' + _escapeHtml(currentStep.instruction) + '</p>'
      : '<p class="lesson-card__step lesson-card__step--done">All steps complete!</p>';

    var statusClass = lesson.completed ? 'lesson-card--completed' : 'lesson-card--active';

    return '<div class="lesson-card ' + statusClass + '">' +
      '<div class="lesson-card__header">' +
      '<span class="lesson-card__topic">' + _escapeHtml(topicName) + '</span>' +
      '<span class="lesson-card__student">Student: ' + _escapeHtml(lesson.npcId) + '</span>' +
      '</div>' +
      '<div class="lesson-card__progress">' +
      '<div class="lesson-card__progress-bar" style="width:' + pct + '%"></div>' +
      '</div>' +
      '<p class="lesson-card__steps">Step ' + progress + ' / ' + totalSteps + '</p>' +
      stepHtml +
      '</div>';
  }

  function formatTeacherProfile(stats) {
    if (!stats) return '<div class="teacher-profile teacher-profile--empty">No data</div>';

    var topicsHtml = '';
    if (stats.topicsTaught && stats.topicsTaught.length > 0) {
      topicsHtml = '<ul class="teacher-profile__topics">';
      for (var i = 0; i < stats.topicsTaught.length; i++) {
        var t = TOPICS[stats.topicsTaught[i]];
        topicsHtml += '<li>' + _escapeHtml(t ? t.name : stats.topicsTaught[i]) + '</li>';
      }
      topicsHtml += '</ul>';
    } else {
      topicsHtml = '<p class="teacher-profile__none">No topics taught yet</p>';
    }

    return '<div class="teacher-profile">' +
      '<div class="teacher-profile__rank">' + _escapeHtml(stats.teacherRank) + '</div>' +
      '<div class="teacher-profile__stats">' +
      '<span class="teacher-profile__xp">Teaching XP: ' + (stats.teachingXP || 0) + '</span>' +
      '<span class="teacher-profile__lessons">Lessons: ' + (stats.totalLessons || 0) + '</span>' +
      '<span class="teacher-profile__students">Students: ' + (stats.studentsTaught ? stats.studentsTaught.length : 0) + '</span>' +
      '</div>' +
      '<div class="teacher-profile__topics-section"><strong>Topics Taught:</strong>' + topicsHtml + '</div>' +
      '</div>';
  }

  function formatNPCSkillCard(npcId, skills) {
    if (!npcId) return '<div class="npc-skill-card npc-skill-card--empty">No NPC</div>';

    var skillsObj = skills || {};
    var topicKeys = Object.keys(skillsObj);

    var skillsHtml = '';
    if (topicKeys.length > 0) {
      skillsHtml = '<ul class="npc-skill-card__list">';
      for (var i = 0; i < topicKeys.length; i++) {
        var topicKey = topicKeys[i];
        var level = skillsObj[topicKey] || 0;
        var topicData = TOPICS[topicKey];
        var topicName = topicData ? topicData.name : topicKey;
        var levelName = getNPCSkillName(level);
        skillsHtml += '<li class="npc-skill-card__skill">' +
          '<span class="npc-skill-card__topic">' + _escapeHtml(topicName) + '</span>' +
          '<span class="npc-skill-card__level">' + _escapeHtml(levelName) + ' (' + level + ')</span>' +
          '</li>';
      }
      skillsHtml += '</ul>';
    } else {
      skillsHtml = '<p class="npc-skill-card__none">No skills learned yet</p>';
    }

    return '<div class="npc-skill-card">' +
      '<div class="npc-skill-card__header">NPC: ' + _escapeHtml(npcId) + '</div>' +
      skillsHtml +
      '</div>';
  }

  // ============================================================================
  // PRIVATE HELPERS
  // ============================================================================

  function _copyState(state) {
    var newState = {
      mentorships: {},
      npcSkills: {},
      lessonHistory: (state.lessonHistory || []).slice(),
      playerTeachingXP: {}
    };

    // Copy mentorships
    var mKeys = Object.keys(state.mentorships || {});
    for (var i = 0; i < mKeys.length; i++) {
      newState.mentorships[mKeys[i]] = _copyLesson(state.mentorships[mKeys[i]]);
    }

    // Copy npcSkills
    var nKeys = Object.keys(state.npcSkills || {});
    for (var j = 0; j < nKeys.length; j++) {
      newState.npcSkills[nKeys[j]] = {};
      var tKeys = Object.keys(state.npcSkills[nKeys[j]] || {});
      for (var k = 0; k < tKeys.length; k++) {
        newState.npcSkills[nKeys[j]][tKeys[k]] = state.npcSkills[nKeys[j]][tKeys[k]];
      }
    }

    // Copy playerTeachingXP
    var xpKeys = Object.keys(state.playerTeachingXP || {});
    for (var l = 0; l < xpKeys.length; l++) {
      newState.playerTeachingXP[xpKeys[l]] = state.playerTeachingXP[xpKeys[l]];
    }

    return newState;
  }

  function _copyLesson(lesson) {
    if (!lesson) return null;
    return {
      id: lesson.id,
      topic: lesson.topic,
      npcId: lesson.npcId,
      teacherId: lesson.teacherId,
      step: lesson.step,
      steps: lesson.steps,
      startedAt: lesson.startedAt,
      completed: lesson.completed,
      completedAt: lesson.completedAt,
      abandoned: lesson.abandoned,
      readyToComplete: lesson.readyToComplete
    };
  }

  function _escapeHtml(str) {
    if (!str) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.TOPICS = TOPICS;
  exports.ARCHETYPE_TOPICS = ARCHETYPE_TOPICS;
  exports.SKILL_LEVEL_NAMES = SKILL_LEVEL_NAMES;
  exports.TEACHER_RANKS = TEACHER_RANKS;
  exports.LESSON_STEPS = LESSON_STEPS;

  exports.createApprenticeshipState = createApprenticeshipState;
  exports.startLesson = startLesson;
  exports.advanceLesson = advanceLesson;
  exports.completeLesson = completeLesson;
  exports.getNPCSkill = getNPCSkill;
  exports.getNPCSkillName = getNPCSkillName;
  exports.getTeachableTopics = getTeachableTopics;
  exports.getPlayerTeachingStats = getPlayerTeachingStats;
  exports.getTeacherRank = getTeacherRank;
  exports.getLessonSteps = getLessonSteps;
  exports.getActiveLessons = getActiveLessons;
  exports.getNPCStudents = getNPCStudents;
  exports.formatLessonCard = formatLessonCard;
  exports.formatTeacherProfile = formatTeacherProfile;
  exports.formatNPCSkillCard = formatNPCSkillCard;

})(typeof module !== 'undefined' ? module.exports : (window.Apprenticeship = {}));


// event_voting.js
// event_voting.js â€” Participatory Event Voting System for ZION
// Players vote on event outcomes; collective choices shape the world.
// Depends on: protocol.js (optional), zones.js (optional)
(function(exports) {
  'use strict';

  // ========================================================================
  // VOTEABLE EVENT CATALOG
  // ========================================================================

  var VOTEABLE_EVENTS = {

    harvest_festival: {
      id: 'harvest_festival',
      title: 'Harvest Festival',
      zone: 'gardens',
      description: 'The gardens overflow with produce. How shall we celebrate?',
      options: [
        {
          id: 'feast',
          label: 'Grand Feast',
          desc: 'Cook a community meal. +20% cooking XP for 24h',
          effect: { bonus: 'cooking_xp', multiplier: 1.2, duration: 86400 }
        },
        {
          id: 'market',
          label: 'Harvest Market',
          desc: 'Sell surplus at special prices. +15% trade profits for 24h',
          effect: { bonus: 'trade_profit', multiplier: 1.15, duration: 86400 }
        },
        {
          id: 'preserve',
          label: 'Preserve for Winter',
          desc: 'Store food. All players get 5 bread',
          effect: { bonus: 'give_item', item: 'bread', qty: 5 }
        }
      ]
    },

    storm_approaching: {
      id: 'storm_approaching',
      title: 'Storm Approaching',
      zone: 'wilds',
      description: 'Dark clouds gather over the Wilds. What do we do?',
      options: [
        {
          id: 'shelter',
          label: 'Build Shelter',
          desc: 'Protect the zone. +10% building XP for 24h',
          effect: { bonus: 'building_xp', multiplier: 1.1, duration: 86400 }
        },
        {
          id: 'brave',
          label: 'Brave the Storm',
          desc: 'Hunt for rare storm creatures. Rare loot drops for 12h',
          effect: { bonus: 'rare_loot', multiplier: 2.0, duration: 43200 }
        },
        {
          id: 'evacuate',
          label: 'Evacuate to Nexus',
          desc: 'Safety first. All players in Wilds get 20 Spark',
          effect: { bonus: 'give_spark', amount: 20, zone: 'wilds' }
        }
      ]
    },

    merchant_caravan: {
      id: 'merchant_caravan',
      title: 'Merchant Caravan Arrives',
      zone: 'agora',
      description: 'A mysterious caravan has arrived at the Agora with exotic goods.',
      options: [
        {
          id: 'trade',
          label: 'Open Trade',
          desc: 'Access rare items. Exotic shop opens for 24h',
          effect: { bonus: 'exotic_shop', duration: 86400 }
        },
        {
          id: 'tax',
          label: 'Tax the Merchants',
          desc: 'Charge entry fee. 50 Spark to treasury',
          effect: { bonus: 'treasury', amount: 50 }
        },
        {
          id: 'welcome',
          label: 'Welcome Feast',
          desc: 'Befriend merchants. Permanent 5% discount',
          effect: { bonus: 'permanent_discount', amount: 0.05 }
        }
      ]
    },

    aurora_borealis: {
      id: 'aurora_borealis',
      title: 'Aurora Borealis',
      zone: null,
      description: 'The sky shimmers with magical light. A rare celestial event!',
      options: [
        {
          id: 'stargaze',
          label: 'Mass Stargazing',
          desc: 'Community stargazing. +50% stargazing XP for 12h',
          effect: { bonus: 'stargazing_xp', multiplier: 1.5, duration: 43200 }
        },
        {
          id: 'harvest',
          label: 'Harvest Star Dust',
          desc: 'Collect fragments. Each player gets 1 star_fragment',
          effect: { bonus: 'give_item', item: 'star_fragment', qty: 1 }
        },
        {
          id: 'ceremony',
          label: 'Light Ceremony',
          desc: 'Hold a ceremony. +25% all XP for 6h',
          effect: { bonus: 'all_xp', multiplier: 1.25, duration: 21600 }
        }
      ]
    },

    arena_tournament: {
      id: 'arena_tournament',
      title: 'Grand Tournament',
      zone: 'arena',
      description: 'The Arena is hosting a grand tournament. What format?',
      options: [
        {
          id: 'combat',
          label: 'Combat Tournament',
          desc: 'Dungeon speed-run competition. Top 3 get prizes',
          effect: { bonus: 'tournament', type: 'dungeon', prizes: [100, 50, 25] }
        },
        {
          id: 'cards',
          label: 'Card Championship',
          desc: 'Card game bracket. Top 3 get prizes',
          effect: { bonus: 'tournament', type: 'cards', prizes: [100, 50, 25] }
        },
        {
          id: 'fishing',
          label: 'Fishing Derby',
          desc: 'Biggest catch wins. Top 3 get prizes',
          effect: { bonus: 'tournament', type: 'fishing', prizes: [100, 50, 25] }
        }
      ]
    },

    knowledge_symposium: {
      id: 'knowledge_symposium',
      title: 'Knowledge Symposium',
      zone: 'athenaeum',
      description: 'Scholars have gathered for a symposium. What topic?',
      options: [
        {
          id: 'history',
          label: 'Ancient History',
          desc: 'Learn about ZION origins. Unlock lore entries',
          effect: { bonus: 'lore_unlock', count: 3 }
        },
        {
          id: 'science',
          label: 'Natural Science',
          desc: '+20% gathering efficiency for 24h',
          effect: { bonus: 'gather_efficiency', multiplier: 1.2, duration: 86400 }
        },
        {
          id: 'philosophy',
          label: 'Philosophy Debate',
          desc: '+15% reputation gains for 24h',
          effect: { bonus: 'reputation_gain', multiplier: 1.15, duration: 86400 }
        }
      ]
    },

    art_exhibition: {
      id: 'art_exhibition',
      title: 'Art Exhibition',
      zone: 'studio',
      description: 'The Studio is hosting an exhibition. What theme?',
      options: [
        {
          id: 'paintings',
          label: 'Landscape Paintings',
          desc: 'Inspire exploration. +10% exploration XP for 24h',
          effect: { bonus: 'exploration_xp', multiplier: 1.1, duration: 86400 }
        },
        {
          id: 'sculptures',
          label: 'Sculpture Garden',
          desc: 'Inspire building. +10% crafting XP for 24h',
          effect: { bonus: 'crafting_xp', multiplier: 1.1, duration: 86400 }
        },
        {
          id: 'music',
          label: 'Musical Performance',
          desc: 'Inspire composition. +10% music XP for 24h',
          effect: { bonus: 'music_xp', multiplier: 1.1, duration: 86400 }
        }
      ]
    },

    migration_season: {
      id: 'migration_season',
      title: 'Great Migration',
      zone: 'wilds',
      description: 'Rare creatures are migrating through the Wilds!',
      options: [
        {
          id: 'observe',
          label: 'Observe Wildlife',
          desc: 'Study creatures. New discovery entries unlock',
          effect: { bonus: 'discoveries', count: 5 }
        },
        {
          id: 'hunt',
          label: 'Ethical Harvest',
          desc: 'Gather materials. Everyone gets 3 silk + 3 feather',
          effect: { bonus: 'give_items', items: [{item: 'silk', qty: 3}, {item: 'feather', qty: 3}] }
        },
        {
          id: 'protect',
          label: 'Protect the Path',
          desc: 'Guard migration route. +50 reputation with Wilds NPCs',
          effect: { bonus: 'zone_reputation', zone: 'wilds', amount: 50 }
        }
      ]
    },

    full_moon: {
      id: 'full_moon',
      title: 'Full Moon Night',
      zone: null,
      description: 'The full moon rises. Strange things happen in the moonlight...',
      options: [
        {
          id: 'fish',
          label: 'Moonlit Fishing',
          desc: 'Rare fish appear. +100% rare fish chance for 12h',
          effect: { bonus: 'rare_fish', multiplier: 2.0, duration: 43200 }
        },
        {
          id: 'garden',
          label: 'Moon Garden',
          desc: 'Plant moonflowers. +30% farming XP for 12h',
          effect: { bonus: 'farming_xp', multiplier: 1.3, duration: 43200 }
        },
        {
          id: 'dungeon',
          label: 'Moonlit Dungeon',
          desc: 'Special dungeon opens. +50% dungeon loot for 12h',
          effect: { bonus: 'dungeon_loot', multiplier: 1.5, duration: 43200 }
        }
      ]
    },

    founders_day: {
      id: 'founders_day',
      title: 'Founders Day',
      zone: 'nexus',
      description: 'Celebrating the founding of ZION. How shall we honor the occasion?',
      options: [
        {
          id: 'monument',
          label: 'Build Monument',
          desc: 'Permanent monument in Nexus. +10 all zone reputations',
          effect: { bonus: 'all_reputation', amount: 10 }
        },
        {
          id: 'distribute',
          label: 'Wealth Distribution',
          desc: 'Treasury shares wealth. 50 Spark to all players',
          effect: { bonus: 'give_spark', amount: 50 }
        },
        {
          id: 'party',
          label: 'Grand Celebration',
          desc: 'Party in Nexus! +25% all XP for 24h',
          effect: { bonus: 'all_xp', multiplier: 1.25, duration: 86400 }
        }
      ]
    }

  };

  // ========================================================================
  // VOTING CONSTANTS
  // ========================================================================

  var VOTING_PERIOD_TICKS = 300;    // 5 minutes at 1 tick/sec
  var EVENT_STATUS_VOTING  = 'voting';
  var EVENT_STATUS_CLOSED  = 'closed';

  // ========================================================================
  // STATE FACTORY
  // ========================================================================

  /**
   * createEventVotingState()
   * Returns the fresh root state object for this module.
   */
  function createEventVotingState() {
    return {
      activeEvents:   [],   // array of live event-instance objects
      votingHistory:  [],   // array of closed event summaries
      activeEffects:  [],   // array of currently applied effect objects
      nextEventId:    1
    };
  }

  // ========================================================================
  // INTERNAL HELPERS
  // ========================================================================

  function _findEvent(state, eventInstanceId) {
    for (var i = 0; i < state.activeEvents.length; i++) {
      if (state.activeEvents[i].instanceId === eventInstanceId) {
        return state.activeEvents[i];
      }
    }
    return null;
  }

  function _findOption(eventDef, optionId) {
    for (var i = 0; i < eventDef.options.length; i++) {
      if (eventDef.options[i].id === optionId) {
        return eventDef.options[i];
      }
    }
    return null;
  }

  /**
   * Determine the winning option from a tally.
   * Ties are broken by the option that appears first in the catalog definition.
   * @param {Object} tally   â€” { optionId: count, ... }
   * @param {Array}  options â€” ordered option list from catalog
   * @returns {String|null} winning optionId
   */
  function _resolveWinner(tally, options) {
    var maxVotes = -1;
    var winner   = null;
    for (var i = 0; i < options.length; i++) {
      var optId = options[i].id;
      var count = tally[optId] || 0;
      if (count > maxVotes) {
        maxVotes = count;
        winner   = optId;
      }
      // strict >, so first option wins ties (earlier index = first in catalog)
    }
    return winner;
  }

  // ========================================================================
  // CORE FUNCTIONS
  // ========================================================================

  /**
   * startEvent(state, eventId, startTime)
   * Create a new voteable event instance from the catalog.
   * @param {Object} state
   * @param {String} eventId    â€” key in VOTEABLE_EVENTS
   * @param {Number} startTime  â€” tick or timestamp at which the event starts
   * @returns {{ state, event } | { state, error }}
   */
  function startEvent(state, eventId, startTime) {
    var catalog = VOTEABLE_EVENTS[eventId];
    if (!catalog) {
      return { state: state, error: 'Unknown event: ' + eventId };
    }

    var instanceId = state.nextEventId;
    state = Object.assign({}, state, { nextEventId: state.nextEventId + 1 });

    var event = {
      instanceId:   instanceId,
      eventId:      eventId,
      title:        catalog.title,
      zone:         catalog.zone,
      description:  catalog.description,
      options:      catalog.options,   // reference to catalog options (read-only)
      status:       EVENT_STATUS_VOTING,
      startTime:    startTime,
      closedTime:   null,
      votes:        {},                // { playerId: optionId }
      winner:       null,
      appliedEffect: null
    };

    var newActive = state.activeEvents.slice();
    newActive.push(event);
    state = Object.assign({}, state, { activeEvents: newActive });

    return { state: state, event: event };
  }

  /**
   * castVote(state, eventInstanceId, playerId, optionId)
   * Record a player's vote. One vote per player per event.
   * @returns {{ state, success, message }}
   */
  function castVote(state, eventInstanceId, playerId, optionId) {
    var event = _findEvent(state, eventInstanceId);
    if (!event) {
      return { state: state, success: false, message: 'Event not found: ' + eventInstanceId };
    }
    if (event.status !== EVENT_STATUS_VOTING) {
      return { state: state, success: false, message: 'Voting is closed for this event.' };
    }
    if (event.votes[playerId] !== undefined) {
      return { state: state, success: false, message: 'Player has already voted. Use changeVote to update.' };
    }
    var option = _findOption({ options: event.options }, optionId);
    if (!option) {
      return { state: state, success: false, message: 'Invalid option: ' + optionId };
    }

    // Mutate a fresh copy of the event's votes
    var newVotes = Object.assign({}, event.votes);
    newVotes[playerId] = optionId;

    var updatedEvent = Object.assign({}, event, { votes: newVotes });
    var newActive = state.activeEvents.map(function(e) {
      return e.instanceId === eventInstanceId ? updatedEvent : e;
    });
    state = Object.assign({}, state, { activeEvents: newActive });

    return { state: state, success: true, message: 'Vote cast for "' + option.label + '".' };
  }

  /**
   * changeVote(state, eventInstanceId, playerId, newOptionId)
   * Change an existing vote during the voting period.
   * @returns {{ state, success, message }}
   */
  function changeVote(state, eventInstanceId, playerId, newOptionId) {
    var event = _findEvent(state, eventInstanceId);
    if (!event) {
      return { state: state, success: false, message: 'Event not found: ' + eventInstanceId };
    }
    if (event.status !== EVENT_STATUS_VOTING) {
      return { state: state, success: false, message: 'Voting is closed for this event.' };
    }
    if (event.votes[playerId] === undefined) {
      return { state: state, success: false, message: 'No existing vote found. Use castVote first.' };
    }
    var option = _findOption({ options: event.options }, newOptionId);
    if (!option) {
      return { state: state, success: false, message: 'Invalid option: ' + newOptionId };
    }
    if (event.votes[playerId] === newOptionId) {
      return { state: state, success: false, message: 'Vote unchanged; already voting for "' + option.label + '".' };
    }

    var newVotes = Object.assign({}, event.votes);
    newVotes[playerId] = newOptionId;

    var updatedEvent = Object.assign({}, event, { votes: newVotes });
    var newActive = state.activeEvents.map(function(e) {
      return e.instanceId === eventInstanceId ? updatedEvent : e;
    });
    state = Object.assign({}, state, { activeEvents: newActive });

    return { state: state, success: true, message: 'Vote changed to "' + option.label + '".' };
  }

  /**
   * getVoteTally(state, eventInstanceId)
   * Returns a tally object { optionId: count, ... } for all options.
   */
  function getVoteTally(state, eventInstanceId) {
    var event = _findEvent(state, eventInstanceId);
    if (!event) { return null; }

    var tally = {};
    // Initialize all options to 0
    for (var i = 0; i < event.options.length; i++) {
      tally[event.options[i].id] = 0;
    }
    // Count votes
    var playerIds = Object.keys(event.votes);
    for (var j = 0; j < playerIds.length; j++) {
      var chosen = event.votes[playerIds[j]];
      if (tally[chosen] !== undefined) {
        tally[chosen]++;
      }
    }
    return tally;
  }

  /**
   * closeVoting(state, eventInstanceId, currentTime)
   * End voting, determine winner (most votes; ties to first option), apply effect.
   * @returns {{ state, winner, effect, message } | { state, error }}
   */
  function closeVoting(state, eventInstanceId, currentTime) {
    var event = _findEvent(state, eventInstanceId);
    if (!event) {
      return { state: state, error: 'Event not found: ' + eventInstanceId };
    }
    if (event.status === EVENT_STATUS_CLOSED) {
      return { state: state, error: 'Voting already closed for event ' + eventInstanceId };
    }

    var tally    = getVoteTally(state, eventInstanceId);
    var winnerId = _resolveWinner(tally, event.options);
    var winOption = _findOption({ options: event.options }, winnerId);

    // Build applied effect (copy of catalog effect, plus metadata)
    var appliedEffect = null;
    if (winOption) {
      appliedEffect = Object.assign({}, winOption.effect, {
        eventInstanceId: eventInstanceId,
        eventId:         event.eventId,
        optionId:        winnerId,
        optionLabel:     winOption.label,
        appliedAt:       currentTime,
        // activeUntil is set only for timed effects
        activeUntil: winOption.effect.duration
          ? currentTime + winOption.effect.duration
          : null
      });
    }

    // Update the event record
    var updatedEvent = Object.assign({}, event, {
      status:        EVENT_STATUS_CLOSED,
      closedTime:    currentTime,
      winner:        winnerId,
      appliedEffect: appliedEffect
    });

    // Remove from activeEvents
    var newActive = state.activeEvents.filter(function(e) {
      return e.instanceId !== eventInstanceId;
    });

    // Add a history summary
    var summary = {
      instanceId:    eventInstanceId,
      eventId:       event.eventId,
      title:         event.title,
      winner:        winnerId,
      winnerLabel:   winOption ? winOption.label : null,
      tally:         tally,
      totalVotes:    Object.keys(event.votes).length,
      startTime:     event.startTime,
      closedTime:    currentTime,
      appliedEffect: appliedEffect
    };
    var newHistory = state.votingHistory.slice();
    newHistory.unshift(summary);

    // Add to activeEffects if timed (or immediate effects that are trackable)
    var newEffects = state.activeEffects.slice();
    if (appliedEffect) {
      newEffects.push(appliedEffect);
    }

    state = Object.assign({}, state, {
      activeEvents:  newActive,
      votingHistory: newHistory,
      activeEffects: newEffects
    });

    var message = winOption
      ? '"' + winOption.label + '" won with ' + (tally[winnerId] || 0) + ' votes!'
      : 'No votes cast; no effect applied.';

    return {
      state:   state,
      winner:  winnerId,
      effect:  appliedEffect,
      message: message
    };
  }

  /**
   * getActiveEffects(state, currentTime)
   * Returns effects that are currently active (timed or permanent).
   * A permanent effect (activeUntil === null) is always considered active.
   */
  function getActiveEffects(state, currentTime) {
    return state.activeEffects.filter(function(eff) {
      if (eff.activeUntil === null) { return true; }   // permanent
      return eff.activeUntil > currentTime;
    });
  }

  /**
   * isEffectActive(state, effectType, currentTime)
   * Returns true if an effect of the given bonus type is currently active.
   */
  function isEffectActive(state, effectType, currentTime) {
    var active = getActiveEffects(state, currentTime);
    for (var i = 0; i < active.length; i++) {
      if (active[i].bonus === effectType) { return true; }
    }
    return false;
  }

  /**
   * getEffectMultiplier(state, effectType, currentTime)
   * Returns the highest multiplier for an active effect of the given type.
   * Returns 1.0 if no matching effect is active.
   */
  function getEffectMultiplier(state, effectType, currentTime) {
    var active = getActiveEffects(state, currentTime);
    var best   = 1.0;
    for (var i = 0; i < active.length; i++) {
      if (active[i].bonus === effectType && active[i].multiplier !== undefined) {
        if (active[i].multiplier > best) {
          best = active[i].multiplier;
        }
      }
    }
    return best;
  }

  /**
   * getEventHistory(state, limit)
   * Returns recent closed-event summaries (most recent first).
   */
  function getEventHistory(state, limit) {
    var history = state.votingHistory;
    if (limit !== undefined && limit > 0) {
      return history.slice(0, limit);
    }
    return history.slice();
  }

  /**
   * getUpcomingEvents(state)
   * Returns events currently in the voting phase.
   */
  function getUpcomingEvents(state) {
    return state.activeEvents.filter(function(e) {
      return e.status === EVENT_STATUS_VOTING;
    });
  }

  // ========================================================================
  // FORMATTING HELPERS
  // ========================================================================

  /**
   * formatEventCard(event, tally, timeRemaining)
   * Returns an HTML string for an event card with vote counts and a timer.
   *
   * @param {Object} event          â€” event instance object
   * @param {Object} tally          â€” { optionId: count }
   * @param {Number} timeRemaining  â€” ticks or seconds remaining (shown as-is)
   * @returns {String} HTML
   */
  function formatEventCard(event, tally, timeRemaining) {
    if (!event) { return '<div class="event-card event-card--empty">No event data.</div>'; }

    tally = tally || {};
    var totalVotes = 0;
    var optionIds = Object.keys(tally);
    for (var i = 0; i < optionIds.length; i++) {
      totalVotes += tally[optionIds[i]];
    }

    var zoneLabel = event.zone ? (' &bull; ' + event.zone.charAt(0).toUpperCase() + event.zone.slice(1)) : '';
    var statusBadge = event.status === EVENT_STATUS_VOTING
      ? '<span class="event-badge event-badge--voting">Voting Open</span>'
      : '<span class="event-badge event-badge--closed">Closed</span>';

    var timerHtml = (timeRemaining !== undefined && event.status === EVENT_STATUS_VOTING)
      ? '<div class="event-timer">Time remaining: <strong>' + timeRemaining + '</strong> ticks</div>'
      : '';

    var optionsHtml = '';
    for (var j = 0; j < event.options.length; j++) {
      var opt    = event.options[j];
      var votes  = tally[opt.id] || 0;
      optionsHtml += formatVoteBar(opt.label, votes, totalVotes);
    }

    var winnerHtml = '';
    if (event.status === EVENT_STATUS_CLOSED && event.winner) {
      var winOpt = _findOption({ options: event.options }, event.winner);
      winnerHtml = winOpt
        ? '<div class="event-winner">Winner: <strong>' + winOpt.label + '</strong></div>'
        : '';
    }

    return (
      '<div class="event-card" data-event-id="' + event.eventId + '" data-instance-id="' + event.instanceId + '">' +
        '<div class="event-card__header">' +
          '<span class="event-card__title">' + event.title + '</span>' +
          zoneLabel +
          statusBadge +
        '</div>' +
        '<div class="event-card__description">' + event.description + '</div>' +
        '<div class="event-card__options">' + optionsHtml + '</div>' +
        timerHtml +
        winnerHtml +
        '<div class="event-card__total">Total votes: ' + totalVotes + '</div>' +
      '</div>'
    );
  }

  /**
   * formatVoteBar(optionLabel, votes, totalVotes)
   * Returns an HTML string showing an ASCII-style vote bar.
   *
   * @param {String} optionLabel
   * @param {Number} votes
   * @param {Number} totalVotes
   * @returns {String} HTML
   */
  function formatVoteBar(optionLabel, votes, totalVotes) {
    var BAR_WIDTH   = 20;
    var pct         = totalVotes > 0 ? (votes / totalVotes) : 0;
    var filled      = Math.round(pct * BAR_WIDTH);
    var empty       = BAR_WIDTH - filled;
    var bar         = '';
    for (var i = 0; i < filled; i++) { bar += '#'; }
    for (var j = 0; j < empty;  j++) { bar += '-'; }
    var pctLabel    = Math.round(pct * 100) + '%';

    return (
      '<div class="vote-bar">' +
        '<span class="vote-bar__label">' + optionLabel + '</span>' +
        '<code class="vote-bar__bar">[' + bar + ']</code>' +
        '<span class="vote-bar__pct">' + pctLabel + '</span>' +
        '<span class="vote-bar__count">(' + votes + ')</span>' +
      '</div>'
    );
  }

  /**
   * formatActiveEffects(effects)
   * Returns HTML listing the currently active bonuses.
   *
   * @param {Array} effects â€” array of effect objects (from getActiveEffects)
   * @returns {String} HTML
   */
  function formatActiveEffects(effects) {
    if (!effects || effects.length === 0) {
      return '<div class="active-effects active-effects--empty">No active event bonuses.</div>';
    }

    var rows = '';
    for (var i = 0; i < effects.length; i++) {
      var eff = effects[i];
      var bonusLabel = eff.bonus.replace(/_/g, ' ');
      var multiplierStr = eff.multiplier !== undefined
        ? ('x' + eff.multiplier.toFixed(2))
        : '';
      var amountStr = eff.amount !== undefined
        ? ('+' + eff.amount)
        : '';
      var valueStr  = multiplierStr || amountStr || '';
      var expiryStr = eff.activeUntil
        ? 'Expires at ' + eff.activeUntil
        : 'Permanent';
      rows += (
        '<div class="active-effect">' +
          '<span class="active-effect__source">' + (eff.optionLabel || eff.optionId || 'Event') + '</span>' +
          '<span class="active-effect__bonus">' + bonusLabel + '</span>' +
          (valueStr ? '<span class="active-effect__value">' + valueStr + '</span>' : '') +
          '<span class="active-effect__expiry">' + expiryStr + '</span>' +
        '</div>'
      );
    }

    return '<div class="active-effects">' + rows + '</div>';
  }

  // ========================================================================
  // EXPORTS
  // ========================================================================

  exports.VOTEABLE_EVENTS       = VOTEABLE_EVENTS;
  exports.VOTING_PERIOD_TICKS   = VOTING_PERIOD_TICKS;
  exports.EVENT_STATUS_VOTING   = EVENT_STATUS_VOTING;
  exports.EVENT_STATUS_CLOSED   = EVENT_STATUS_CLOSED;

  exports.createEventVotingState = createEventVotingState;
  exports.startEvent             = startEvent;
  exports.castVote               = castVote;
  exports.changeVote             = changeVote;
  exports.getVoteTally           = getVoteTally;
  exports.closeVoting            = closeVoting;
  exports.getActiveEffects       = getActiveEffects;
  exports.isEffectActive         = isEffectActive;
  exports.getEffectMultiplier    = getEffectMultiplier;
  exports.getEventHistory        = getEventHistory;
  exports.getUpcomingEvents      = getUpcomingEvents;
  exports.formatEventCard        = formatEventCard;
  exports.formatVoteBar          = formatVoteBar;
  exports.formatActiveEffects    = formatActiveEffects;

})(typeof module !== 'undefined' ? module.exports : (window.EventVoting = {}));


// housing_social.js
// housing_social.js
/**
 * ZION Housing Social System
 * Visitor system, guestbook, house ratings, and NPC visits.
 * Layer 1 - No project dependencies
 */

(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // House Styles
  // ---------------------------------------------------------------------------

  var HOUSE_STYLES = {
    cottage: {
      id: 'cottage',
      name: 'Cottage',
      rooms: 3,
      maxFurniture: 15,
      desc: 'Cozy woodland dwelling',
      baseCost: 50
    },
    villa: {
      id: 'villa',
      name: 'Villa',
      rooms: 5,
      maxFurniture: 30,
      desc: 'Spacious riverside home',
      baseCost: 150
    },
    tower: {
      id: 'tower',
      name: 'Tower',
      rooms: 4,
      maxFurniture: 20,
      desc: 'Tall stone observatory',
      baseCost: 200
    },
    treehouse: {
      id: 'treehouse',
      name: 'Treehouse',
      rooms: 3,
      maxFurniture: 12,
      desc: 'Elevated forest retreat',
      baseCost: 100
    },
    workshop: {
      id: 'workshop',
      name: 'Workshop',
      rooms: 6,
      maxFurniture: 25,
      desc: 'Crafting-focused workspace',
      baseCost: 120
    },
    garden_home: {
      id: 'garden_home',
      name: 'Garden Home',
      rooms: 4,
      maxFurniture: 18,
      desc: 'Open-air garden house',
      baseCost: 80
    }
  };

  // ---------------------------------------------------------------------------
  // Room Types
  // ---------------------------------------------------------------------------

  var ROOM_TYPES = {
    bedroom: {
      id: 'bedroom',
      name: 'Bedroom',
      desc: 'Rest and recover energy faster',
      bonus: 'rest_speed_20'
    },
    kitchen: {
      id: 'kitchen',
      name: 'Kitchen',
      desc: 'Cook food with bonus yields',
      bonus: 'cooking_bonus_15'
    },
    workshop: {
      id: 'workshop',
      name: 'Workshop',
      desc: 'Craft items with bonus chance',
      bonus: 'craft_bonus_10'
    },
    gallery: {
      id: 'gallery',
      name: 'Gallery',
      desc: 'Display achievements and art',
      bonus: 'reputation_gain_10'
    },
    library: {
      id: 'library',
      name: 'Library',
      desc: 'Study and gain XP faster',
      bonus: 'xp_bonus_10'
    },
    garden: {
      id: 'garden',
      name: 'Garden',
      desc: 'Grow herbs and flowers',
      bonus: 'herb_production'
    },
    observatory: {
      id: 'observatory',
      name: 'Observatory',
      desc: 'Better stargazing results',
      bonus: 'stargazing_bonus_25'
    },
    trophy_room: {
      id: 'trophy_room',
      name: 'Trophy Room',
      desc: 'Display dungeon trophies',
      bonus: 'dungeon_loot_5'
    }
  };

  // ---------------------------------------------------------------------------
  // Furniture Catalog
  // ---------------------------------------------------------------------------

  var FURNITURE = {
    bed: {
      id: 'bed',
      name: 'Wooden Bed',
      room: 'bedroom',
      rarity: 'common',
      cost: 10,
      comfort: 5
    },
    fancy_bed: {
      id: 'fancy_bed',
      name: 'Fancy Bed',
      room: 'bedroom',
      rarity: 'uncommon',
      cost: 30,
      comfort: 15
    },
    desk: {
      id: 'desk',
      name: 'Writing Desk',
      room: 'library',
      rarity: 'common',
      cost: 12,
      comfort: 3
    },
    bookshelf: {
      id: 'bookshelf',
      name: 'Bookshelf',
      room: 'library',
      rarity: 'common',
      cost: 15,
      comfort: 4
    },
    stove: {
      id: 'stove',
      name: 'Stone Stove',
      room: 'kitchen',
      rarity: 'common',
      cost: 20,
      comfort: 6
    },
    workbench: {
      id: 'workbench',
      name: 'Workbench',
      room: 'workshop',
      rarity: 'common',
      cost: 18,
      comfort: 3
    },
    anvil: {
      id: 'anvil',
      name: 'Iron Anvil',
      room: 'workshop',
      rarity: 'uncommon',
      cost: 35,
      comfort: 2
    },
    painting: {
      id: 'painting',
      name: 'Painting',
      room: 'gallery',
      rarity: 'uncommon',
      cost: 25,
      comfort: 8
    },
    statue: {
      id: 'statue',
      name: 'Small Statue',
      room: 'gallery',
      rarity: 'rare',
      cost: 50,
      comfort: 12
    },
    telescope_f: {
      id: 'telescope_f',
      name: 'Telescope',
      room: 'observatory',
      rarity: 'rare',
      cost: 60,
      comfort: 10
    },
    planter: {
      id: 'planter',
      name: 'Planter Box',
      room: 'garden',
      rarity: 'common',
      cost: 8,
      comfort: 5
    },
    fountain: {
      id: 'fountain',
      name: 'Small Fountain',
      room: 'garden',
      rarity: 'uncommon',
      cost: 40,
      comfort: 15
    },
    rug: {
      id: 'rug',
      name: 'Woven Rug',
      room: null,
      rarity: 'common',
      cost: 12,
      comfort: 6
    },
    chandelier: {
      id: 'chandelier',
      name: 'Chandelier',
      room: null,
      rarity: 'rare',
      cost: 45,
      comfort: 10
    },
    fireplace: {
      id: 'fireplace',
      name: 'Fireplace',
      room: null,
      rarity: 'uncommon',
      cost: 30,
      comfort: 12
    },
    armor_stand: {
      id: 'armor_stand',
      name: 'Armor Stand',
      room: 'trophy_room',
      rarity: 'uncommon',
      cost: 25,
      comfort: 4
    },
    trophy_shelf: {
      id: 'trophy_shelf',
      name: 'Trophy Shelf',
      room: 'trophy_room',
      rarity: 'common',
      cost: 15,
      comfort: 3
    },
    herb_rack: {
      id: 'herb_rack',
      name: 'Herb Rack',
      room: 'kitchen',
      rarity: 'common',
      cost: 10,
      comfort: 3
    },
    window_seat: {
      id: 'window_seat',
      name: 'Window Seat',
      room: null,
      rarity: 'uncommon',
      cost: 20,
      comfort: 8
    },
    potted_plant: {
      id: 'potted_plant',
      name: 'Potted Plant',
      room: null,
      rarity: 'common',
      cost: 5,
      comfort: 4
    },
    banner: {
      id: 'banner',
      name: 'Guild Banner',
      room: null,
      rarity: 'uncommon',
      cost: 20,
      comfort: 5
    },
    music_box: {
      id: 'music_box',
      name: 'Music Box',
      room: 'bedroom',
      rarity: 'rare',
      cost: 40,
      comfort: 10
    },
    mirror: {
      id: 'mirror',
      name: 'Ornate Mirror',
      room: null,
      rarity: 'uncommon',
      cost: 22,
      comfort: 6
    },
    clock: {
      id: 'clock',
      name: 'Wall Clock',
      room: null,
      rarity: 'uncommon',
      cost: 28,
      comfort: 5
    },
    map_wall: {
      id: 'map_wall',
      name: 'World Map',
      room: 'library',
      rarity: 'uncommon',
      cost: 30,
      comfort: 7
    }
  };

  // ---------------------------------------------------------------------------
  // Constants
  // ---------------------------------------------------------------------------

  var MAX_GUESTBOOK_ENTRIES = 100;
  var MAX_GUESTBOOK_MSG_LENGTH = 200;
  var MAX_RECENT_VISITORS = 50;
  var COMFORT_BONUS_THRESHOLD = 50;

  // ---------------------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------------------

  /**
   * Sanitize HTML from a string â€” strips tags and encodes entities.
   * @param {string} str
   * @returns {string}
   */
  function _sanitizeHtml(str) {
    if (typeof str !== 'string') return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }

  /**
   * Deep-clone a plain object/array (JSON-safe data only).
   * @param {*} obj
   * @returns {*}
   */
  function _clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  /**
   * Truncate a string to maxLen characters.
   * @param {string} str
   * @param {number} maxLen
   * @returns {string}
   */
  function _truncate(str, maxLen) {
    if (typeof str !== 'string') return '';
    return str.length > maxLen ? str.slice(0, maxLen) : str;
  }

  // ---------------------------------------------------------------------------
  // Core State Factory
  // ---------------------------------------------------------------------------

  /**
   * Create a fresh house state object.
   * @param {string} ownerId
   * @param {string} style  - key of HOUSE_STYLES
   * @param {string} zone   - zone name
   * @returns {object}
   */
  function createHouseState(ownerId, style, zone) {
    if (!ownerId) throw new Error('ownerId is required');
    if (!style || !HOUSE_STYLES[style]) throw new Error('Invalid house style: ' + style);

    return {
      ownerId: ownerId,
      style: style,
      zone: zone || 'nexus',
      rooms: [],
      furniture: [],
      guestbook: [],
      visitors: [],
      rating: { total: 0, count: 0, ratings: {} },
      permissions: {
        public: false,
        friendsOnly: true,
        allowList: []
      },
      comfortScore: 0,
      lastVisited: 0
    };
  }

  // ---------------------------------------------------------------------------
  // Room Management
  // ---------------------------------------------------------------------------

  /**
   * Add a room to the house, respecting the style's room limit.
   * @param {object} state
   * @param {string} roomType  - key of ROOM_TYPES
   * @returns {{ state: object, room?: object, error?: string }}
   */
  function addRoom(state, roomType) {
    if (!state) return { error: 'No house state provided' };
    if (!roomType || !ROOM_TYPES[roomType]) {
      return { state: state, error: 'Invalid room type: ' + roomType };
    }

    var styleData = HOUSE_STYLES[state.style];
    if (!styleData) return { state: state, error: 'Invalid house style' };

    if (state.rooms.length >= styleData.rooms) {
      return {
        state: state,
        error: 'Room limit reached for ' + styleData.name + ' (' + styleData.rooms + ' max)'
      };
    }

    var room = {
      id: 'room_' + state.rooms.length,
      type: roomType,
      name: ROOM_TYPES[roomType].name,
      bonus: ROOM_TYPES[roomType].bonus,
      furniture: []
    };

    var newState = _clone(state);
    newState.rooms.push(room);
    return { state: newState, room: room };
  }

  // ---------------------------------------------------------------------------
  // Furniture Management
  // ---------------------------------------------------------------------------

  /**
   * Place a furniture item in the house (optionally in a specific room).
   * @param {object} state
   * @param {string} furnitureId  - key of FURNITURE
   * @param {number|null} roomIndex - index into state.rooms, or null for general placement
   * @returns {{ state: object, placement?: object, error?: string }}
   */
  function placeFurniture(state, furnitureId, roomIndex) {
    if (!state) return { error: 'No house state provided' };

    var item = FURNITURE[furnitureId];
    if (!item) return { state: state, error: 'Unknown furniture: ' + furnitureId };

    var styleData = HOUSE_STYLES[state.style];
    if (!styleData) return { state: state, error: 'Invalid house style' };

    if (state.furniture.length >= styleData.maxFurniture) {
      return {
        state: state,
        error: 'Furniture limit reached (' + styleData.maxFurniture + ' max for ' + styleData.name + ')'
      };
    }

    // Validate roomIndex if provided
    if (roomIndex !== null && roomIndex !== undefined) {
      if (typeof roomIndex !== 'number' || roomIndex < 0 || roomIndex >= state.rooms.length) {
        return { state: state, error: 'Invalid room index: ' + roomIndex };
      }
    }

    var placement = {
      furnitureId: furnitureId,
      name: item.name,
      comfort: item.comfort,
      rarity: item.rarity,
      roomIndex: (roomIndex !== null && roomIndex !== undefined) ? roomIndex : null,
      placedAt: Date.now()
    };

    var newState = _clone(state);
    newState.furniture.push(placement);
    newState.comfortScore = calculateComfort(newState);
    return { state: newState, placement: placement };
  }

  /**
   * Remove a furniture item by its index in state.furniture.
   * @param {object} state
   * @param {number} furnitureIndex
   * @returns {{ state: object, removed?: object, error?: string }}
   */
  function removeFurniture(state, furnitureIndex) {
    if (!state) return { error: 'No house state provided' };
    if (typeof furnitureIndex !== 'number' || furnitureIndex < 0 || furnitureIndex >= state.furniture.length) {
      return { state: state, error: 'Invalid furniture index: ' + furnitureIndex };
    }

    var newState = _clone(state);
    var removed = newState.furniture.splice(furnitureIndex, 1)[0];
    newState.comfortScore = calculateComfort(newState);
    return { state: newState, removed: removed };
  }

  // ---------------------------------------------------------------------------
  // Comfort
  // ---------------------------------------------------------------------------

  /**
   * Calculate total comfort score from all placed furniture.
   * @param {object} state
   * @returns {number}
   */
  function calculateComfort(state) {
    if (!state || !state.furniture) return 0;
    var total = 0;
    for (var i = 0; i < state.furniture.length; i++) {
      var placement = state.furniture[i];
      var comfort = placement.comfort;
      if (typeof comfort !== 'number') {
        var item = FURNITURE[placement.furnitureId];
        comfort = item ? item.comfort : 0;
      }
      total += comfort;
    }
    return total;
  }

  // ---------------------------------------------------------------------------
  // Visitor System
  // ---------------------------------------------------------------------------

  /**
   * Record a visit to a house.
   * @param {object} state
   * @param {string} visitorId
   * @param {number} timestamp
   * @returns {{ state: object, message: string, comfortBonus: number }}
   */
  function visitHouse(state, visitorId, timestamp) {
    if (!state) return { error: 'No house state provided' };
    if (!visitorId) return { state: state, error: 'visitorId is required' };

    var ts = timestamp || Date.now();
    var newState = _clone(state);

    var isOwner = visitorId === state.ownerId;

    // Record visit in the visitors log
    newState.visitors.push({
      visitorId: visitorId,
      timestamp: ts,
      isOwner: isOwner
    });

    // Keep visitors list bounded
    if (newState.visitors.length > MAX_RECENT_VISITORS) {
      newState.visitors = newState.visitors.slice(newState.visitors.length - MAX_RECENT_VISITORS);
    }

    newState.lastVisited = ts;

    var comfortBonus = 0;
    if (newState.comfortScore >= COMFORT_BONUS_THRESHOLD) {
      comfortBonus = Math.floor(newState.comfortScore / 10);
    }

    var styleData = HOUSE_STYLES[state.style] || {};
    var message = isOwner
      ? 'Welcome home, ' + visitorId + '! Your ' + (styleData.name || state.style) + ' awaits.'
      : 'Welcome to ' + state.ownerId + '\'s ' + (styleData.name || state.style) + '!';

    if (comfortBonus > 0) {
      message += ' (+' + comfortBonus + ' comfort bonus)';
    }

    return { state: newState, message: message, comfortBonus: comfortBonus };
  }

  // ---------------------------------------------------------------------------
  // Guestbook
  // ---------------------------------------------------------------------------

  /**
   * Leave a guestbook entry.
   * @param {object} state
   * @param {string} visitorId
   * @param {string} message
   * @param {number} timestamp
   * @returns {{ state: object, entry?: object, error?: string }}
   */
  function leaveGuestbookEntry(state, visitorId, message, timestamp) {
    if (!state) return { error: 'No house state provided' };
    if (!visitorId) return { state: state, error: 'visitorId is required' };
    if (!message || typeof message !== 'string' || message.trim().length === 0) {
      return { state: state, error: 'Message cannot be empty' };
    }

    var sanitized = _sanitizeHtml(_truncate(message.trim(), MAX_GUESTBOOK_MSG_LENGTH));

    var entry = {
      visitorId: visitorId,
      message: sanitized,
      timestamp: timestamp || Date.now()
    };

    var newState = _clone(state);

    // Enforce max entries â€” keep most recent
    if (newState.guestbook.length >= MAX_GUESTBOOK_ENTRIES) {
      newState.guestbook = newState.guestbook.slice(1);
    }

    newState.guestbook.push(entry);
    return { state: newState, entry: entry };
  }

  // ---------------------------------------------------------------------------
  // Rating System
  // ---------------------------------------------------------------------------

  /**
   * Rate a house (1-5). Each visitor may only rate once.
   * @param {object} state
   * @param {string} visitorId
   * @param {number} rating  - integer 1 through 5
   * @returns {{ state: object, averageRating?: number, error?: string }}
   */
  function rateHouse(state, visitorId, rating) {
    if (!state) return { error: 'No house state provided' };
    if (!visitorId) return { state: state, error: 'visitorId is required' };

    var r = Number(rating);
    if (!Number.isFinite(r) || r < 1 || r > 5 || r !== Math.floor(r)) {
      return { state: state, error: 'Rating must be an integer between 1 and 5' };
    }

    if (state.rating.ratings && state.rating.ratings[visitorId] !== undefined) {
      return { state: state, error: 'Visitor ' + visitorId + ' has already rated this house' };
    }

    var newState = _clone(state);
    if (!newState.rating.ratings) newState.rating.ratings = {};

    newState.rating.ratings[visitorId] = r;
    newState.rating.total += r;
    newState.rating.count += 1;

    var avg = getAverageRating(newState);
    return { state: newState, averageRating: avg };
  }

  /**
   * Compute the average rating.
   * @param {object} state
   * @returns {number}  0 if no ratings yet
   */
  function getAverageRating(state) {
    if (!state || !state.rating || state.rating.count === 0) return 0;
    return Math.round((state.rating.total / state.rating.count) * 10) / 10;
  }

  // ---------------------------------------------------------------------------
  // Query helpers
  // ---------------------------------------------------------------------------

  /**
   * Return recent guestbook entries (newest first).
   * @param {object} state
   * @param {number} limit
   * @returns {Array}
   */
  function getGuestbook(state, limit) {
    if (!state || !state.guestbook) return [];
    var entries = state.guestbook.slice().reverse();
    var n = (typeof limit === 'number' && limit > 0) ? limit : entries.length;
    return entries.slice(0, n);
  }

  /**
   * Total count of unique visitors (not counting the owner).
   * @param {object} state
   * @returns {number}
   */
  function getVisitorCount(state) {
    if (!state || !state.visitors) return 0;
    var seen = {};
    for (var i = 0; i < state.visitors.length; i++) {
      var v = state.visitors[i];
      if (v.visitorId !== state.ownerId) {
        seen[v.visitorId] = true;
      }
    }
    return Object.keys(seen).length;
  }

  /**
   * Return recent visitor objects (newest first).
   * @param {object} state
   * @param {number} limit
   * @returns {Array}
   */
  function getRecentVisitors(state, limit) {
    if (!state || !state.visitors) return [];
    var all = state.visitors.slice().reverse();
    var n = (typeof limit === 'number' && limit > 0) ? limit : all.length;
    return all.slice(0, n);
  }

  // ---------------------------------------------------------------------------
  // Permissions
  // ---------------------------------------------------------------------------

  /**
   * Update the access-control settings for a house.
   * @param {object} state
   * @param {object} permissions  - partial or full permissions object
   * @returns {{ state: object }}
   */
  function setPermissions(state, permissions) {
    if (!state) return { error: 'No house state provided' };
    var newState = _clone(state);
    var p = permissions || {};

    if (typeof p.public === 'boolean') newState.permissions.public = p.public;
    if (typeof p.friendsOnly === 'boolean') newState.permissions.friendsOnly = p.friendsOnly;
    if (Array.isArray(p.allowList)) newState.permissions.allowList = p.allowList.slice();

    return { state: newState };
  }

  /**
   * Determine whether a player is allowed to visit.
   * Owners can always visit their own house.
   * @param {object} state
   * @param {string} visitorId
   * @returns {boolean}
   */
  function canVisit(state, visitorId) {
    if (!state || !visitorId) return false;

    // Owner can always visit
    if (visitorId === state.ownerId) return true;

    var perms = state.permissions;
    if (!perms) return false;

    // Public overrides everything
    if (perms.public) return true;

    // Check allow-list
    if (Array.isArray(perms.allowList) && perms.allowList.indexOf(visitorId) !== -1) {
      return true;
    }

    // friendsOnly = true means only allow-listed players and owner
    if (perms.friendsOnly) return false;

    return false;
  }

  // ---------------------------------------------------------------------------
  // Bonuses
  // ---------------------------------------------------------------------------

  /**
   * Return all active room bonuses for this house.
   * @param {object} state
   * @returns {Array<string>}
   */
  function getHouseBonus(state) {
    if (!state || !state.rooms) return [];
    var bonuses = [];
    for (var i = 0; i < state.rooms.length; i++) {
      var room = state.rooms[i];
      var roomDef = ROOM_TYPES[room.type];
      if (roomDef && roomDef.bonus) {
        bonuses.push(roomDef.bonus);
      }
    }
    return bonuses;
  }

  // ---------------------------------------------------------------------------
  // Top-rated Houses
  // ---------------------------------------------------------------------------

  /**
   * Sort an array of house states by average rating (descending).
   * @param {Array<object>} houses
   * @param {number} limit
   * @returns {Array<object>}
   */
  function getTopRatedHouses(houses, limit) {
    if (!Array.isArray(houses)) return [];
    var sorted = houses.slice().sort(function(a, b) {
      return getAverageRating(b) - getAverageRating(a);
    });
    var n = (typeof limit === 'number' && limit > 0) ? limit : sorted.length;
    return sorted.slice(0, n);
  }

  // ---------------------------------------------------------------------------
  // Catalog
  // ---------------------------------------------------------------------------

  /**
   * Return the full furniture catalog.
   * @returns {object}
   */
  function getFurnitureCatalog() {
    return FURNITURE;
  }

  // ---------------------------------------------------------------------------
  // Formatting
  // ---------------------------------------------------------------------------

  /**
   * Generate an HTML card summarising the house.
   * @param {object} state
   * @returns {string}
   */
  function formatHouseCard(state) {
    if (!state) return '<div class="house-card">No house data</div>';

    var styleData = HOUSE_STYLES[state.style] || { name: state.style, desc: '' };
    var avgRating = getAverageRating(state);
    var visitorCount = getVisitorCount(state);
    var comfort = state.comfortScore || calculateComfort(state);
    var roomCount = state.rooms ? state.rooms.length : 0;
    var furnitureCount = state.furniture ? state.furniture.length : 0;

    var stars = '';
    for (var s = 1; s <= 5; s++) {
      stars += s <= Math.round(avgRating) ? '&#9733;' : '&#9734;';
    }

    var roomBonuses = getHouseBonus(state);
    var bonusHtml = '';
    if (roomBonuses.length > 0) {
      bonusHtml = '<ul class="house-bonuses">';
      for (var bi = 0; bi < roomBonuses.length; bi++) {
        bonusHtml += '<li>' + _sanitizeHtml(roomBonuses[bi]) + '</li>';
      }
      bonusHtml += '</ul>';
    }

    var permLabel = state.permissions.public
      ? 'Public'
      : state.permissions.friendsOnly
        ? 'Friends Only'
        : 'Private';

    return [
      '<div class="house-card">',
      '  <div class="house-card-header">',
      '    <span class="house-style">' + _sanitizeHtml(styleData.name) + '</span>',
      '    <span class="house-owner">Owner: ' + _sanitizeHtml(state.ownerId) + '</span>',
      '  </div>',
      '  <div class="house-card-desc">' + _sanitizeHtml(styleData.desc) + '</div>',
      '  <div class="house-card-stats">',
      '    <span class="house-rating" title="' + avgRating + ' / 5">' + stars + ' (' + avgRating + ')</span>',
      '    <span class="house-visitors">Visitors: ' + visitorCount + '</span>',
      '    <span class="house-comfort">Comfort: ' + comfort + '</span>',
      '    <span class="house-rooms">Rooms: ' + roomCount + '</span>',
      '    <span class="house-furniture">Furniture: ' + furnitureCount + '</span>',
      '    <span class="house-access">' + permLabel + '</span>',
      '  </div>',
      bonusHtml,
      '</div>'
    ].join('\n');
  }

  /**
   * Generate an HTML snippet for a single guestbook entry.
   * @param {object} entry
   * @returns {string}
   */
  function formatGuestbookEntry(entry) {
    if (!entry) return '<div class="guestbook-entry">No entry</div>';

    var d = entry.timestamp ? new Date(entry.timestamp).toISOString().slice(0, 10) : '';
    return [
      '<div class="guestbook-entry">',
      '  <span class="guestbook-author">' + _sanitizeHtml(entry.visitorId || 'unknown') + '</span>',
      '  <span class="guestbook-date">' + d + '</span>',
      '  <p class="guestbook-message">' + (entry.message || '') + '</p>',
      '</div>'
    ].join('\n');
  }

  /**
   * Generate an ASCII layout of the rooms in a house.
   * @param {object} state
   * @returns {string}
   */
  function formatRoomLayout(state) {
    if (!state || !state.rooms || state.rooms.length === 0) {
      return '+--------+\n|  empty |\n+--------+';
    }

    var styleData = HOUSE_STYLES[state.style] || { name: state.style, rooms: 0 };
    var lines = [];
    lines.push('[ ' + styleData.name + ' â€” ' + state.rooms.length + '/' + styleData.rooms + ' rooms ]');
    lines.push('');

    var cols = Math.min(3, state.rooms.length);
    var rows = Math.ceil(state.rooms.length / cols);

    for (var row = 0; row < rows; row++) {
      // Top border row
      var topLine = '';
      for (var col = 0; col < cols; col++) {
        var idx = row * cols + col;
        if (idx < state.rooms.length) {
          topLine += '+----------+  ';
        }
      }
      lines.push(topLine.trimRight());

      // Room name row
      var nameLine = '';
      for (var col2 = 0; col2 < cols; col2++) {
        var idx2 = row * cols + col2;
        if (idx2 < state.rooms.length) {
          var rName = state.rooms[idx2].name || state.rooms[idx2].type;
          var padded = rName.slice(0, 8);
          while (padded.length < 8) padded = ' ' + padded;
          nameLine += '|' + padded + '|  ';
        }
      }
      lines.push(nameLine.trimRight());

      // Bonus row
      var bonusLine = '';
      for (var col3 = 0; col3 < cols; col3++) {
        var idx3 = row * cols + col3;
        if (idx3 < state.rooms.length) {
          var bonus = state.rooms[idx3].bonus || '';
          var bShort = bonus.slice(0, 8);
          while (bShort.length < 8) bShort = ' ' + bShort;
          bonusLine += '|' + bShort + '|  ';
        }
      }
      lines.push(bonusLine.trimRight());

      // Bottom border row
      var botLine = '';
      for (var col4 = 0; col4 < cols; col4++) {
        var idx4 = row * cols + col4;
        if (idx4 < state.rooms.length) {
          botLine += '+----------+  ';
        }
      }
      lines.push(botLine.trimRight());
      lines.push('');
    }

    return lines.join('\n');
  }

  // ---------------------------------------------------------------------------
  // Exports
  // ---------------------------------------------------------------------------

  exports.HOUSE_STYLES       = HOUSE_STYLES;
  exports.ROOM_TYPES         = ROOM_TYPES;
  exports.FURNITURE          = FURNITURE;

  exports.createHouseState   = createHouseState;
  exports.addRoom            = addRoom;
  exports.placeFurniture     = placeFurniture;
  exports.removeFurniture    = removeFurniture;
  exports.calculateComfort   = calculateComfort;
  exports.visitHouse         = visitHouse;
  exports.leaveGuestbookEntry= leaveGuestbookEntry;
  exports.rateHouse          = rateHouse;
  exports.getAverageRating   = getAverageRating;
  exports.getGuestbook       = getGuestbook;
  exports.getVisitorCount    = getVisitorCount;
  exports.getRecentVisitors  = getRecentVisitors;
  exports.setPermissions     = setPermissions;
  exports.canVisit           = canVisit;
  exports.getHouseBonus      = getHouseBonus;
  exports.getTopRatedHouses  = getTopRatedHouses;
  exports.getFurnitureCatalog= getFurnitureCatalog;
  exports.formatHouseCard    = formatHouseCard;
  exports.formatGuestbookEntry = formatGuestbookEntry;
  exports.formatRoomLayout   = formatRoomLayout;

})(typeof module !== 'undefined' ? module.exports : (window.HousingSocial = {}));


// prestige.js
// prestige.js
/**
 * ZION Prestige / Ascension System
 * Endgame progression: reset skills, keep cosmetics, earn permanent bonuses
 */

(function(exports) {
  'use strict';

  // ========================================================================
  // PRESTIGE TIERS
  // ========================================================================

  var PRESTIGE_TIERS = [
    { level: 0, name: 'Citizen',      color: '#cccccc', sparkBonus: 0,    title: '' },
    { level: 1, name: 'Ascended',     color: '#87CEEB', sparkBonus: 0.05, title: 'the Ascended' },
    { level: 2, name: 'Enlightened',  color: '#4CAF50', sparkBonus: 0.10, title: 'the Enlightened' },
    { level: 3, name: 'Transcendent', color: '#9C27B0', sparkBonus: 0.15, title: 'the Transcendent' },
    { level: 4, name: 'Mythic',       color: '#FF9800', sparkBonus: 0.20, title: 'the Mythic' },
    { level: 5, name: 'Legendary',    color: '#FFD700', sparkBonus: 0.25, title: 'the Legendary' },
    { level: 6, name: 'Eternal',      color: '#FF4081', sparkBonus: 0.30, title: 'the Eternal' }
  ];

  // ========================================================================
  // PRESTIGE REWARDS
  // ========================================================================

  var PRESTIGE_REWARDS = {
    1: {
      cosmetics: ['golden_aura'],
      perks: ['spark_bonus_5'],
      title: 'the Ascended'
    },
    2: {
      cosmetics: ['silver_trail', 'emerald_glow'],
      perks: ['xp_bonus_5', 'spark_bonus_10'],
      title: 'the Enlightened'
    },
    3: {
      cosmetics: ['purple_flames', 'mystic_particles'],
      perks: ['craft_bonus_5', 'gather_bonus_5', 'spark_bonus_15'],
      title: 'the Transcendent'
    },
    4: {
      cosmetics: ['phoenix_wings', 'amber_halo'],
      perks: ['trade_bonus_10', 'fast_travel_discount', 'spark_bonus_20'],
      title: 'the Mythic'
    },
    5: {
      cosmetics: ['star_crown', 'golden_footsteps', 'legendary_glow'],
      perks: ['double_daily_rewards', 'rare_loot_bonus', 'spark_bonus_25'],
      title: 'the Legendary'
    },
    6: {
      cosmetics: ['eternal_flames', 'cosmic_aura', 'timeline_shimmer', 'divine_particles'],
      perks: ['triple_daily_rewards', 'master_all_perks', 'spark_bonus_30', 'instant_travel'],
      title: 'the Eternal'
    }
  };

  // ========================================================================
  // PERK DESCRIPTIONS
  // ========================================================================

  var PERK_DESCRIPTIONS = {
    spark_bonus_5:          { label: '+5% Spark Earning',         type: 'spark',   value: 0.05 },
    spark_bonus_10:         { label: '+10% Spark Earning',        type: 'spark',   value: 0.10 },
    spark_bonus_15:         { label: '+15% Spark Earning',        type: 'spark',   value: 0.15 },
    spark_bonus_20:         { label: '+20% Spark Earning',        type: 'spark',   value: 0.20 },
    spark_bonus_25:         { label: '+25% Spark Earning',        type: 'spark',   value: 0.25 },
    spark_bonus_30:         { label: '+30% Spark Earning',        type: 'spark',   value: 0.30 },
    xp_bonus_5:             { label: '+5% XP Gain',              type: 'xp',      value: 0.05 },
    craft_bonus_5:          { label: '+5% Crafting Quality',     type: 'craft',   value: 0.05 },
    gather_bonus_5:         { label: '+5% Gathering Yield',      type: 'gather',  value: 0.05 },
    trade_bonus_10:         { label: '+10% Trade Value',         type: 'trade',   value: 0.10 },
    fast_travel_discount:   { label: '20% Fast Travel Discount', type: 'travel',  value: 0.20 },
    double_daily_rewards:   { label: 'Double Daily Rewards',     type: 'daily',   value: 2.0  },
    rare_loot_bonus:        { label: '+15% Rare Loot Chance',    type: 'loot',    value: 0.15 },
    triple_daily_rewards:   { label: 'Triple Daily Rewards',     type: 'daily',   value: 3.0  },
    master_all_perks:       { label: 'All Perk Bonuses Active',  type: 'master',  value: 1.0  },
    instant_travel:         { label: 'Instant Zone Travel',      type: 'travel',  value: 1.0  }
  };

  // ========================================================================
  // ASCENSION CONSTANTS
  // ========================================================================

  var ASCENSION_REQUIRED_LEVEL     = 50;
  var ASCENSION_REQUIRED_QUESTS    = 10;
  var ASCENSION_REQUIRED_ZONES     = 8;
  var ASCENSION_SPARK_COST         = 500;
  var MAX_PRESTIGE_LEVEL           = 6;

  // ASCII badges indexed by prestige level (0â€“6)
  var PRESTIGE_BADGES = [
    '[~]',   // Citizen
    '[*]',   // Ascended
    '[**]',  // Enlightened
    '[***]', // Transcendent
    '[M]',   // Mythic
    '[L]',   // Legendary
    '[E]'    // Eternal
  ];

  // ========================================================================
  // STATE FACTORY
  // ========================================================================

  /**
   * Creates a fresh prestige state for a new player.
   * @returns {Object}
   */
  function createPrestigeState() {
    return {
      level: 0,
      totalAscensions: 0,
      history: [],
      cosmetics: [],
      perks: [],
      unlockedTitles: []
    };
  }

  // ========================================================================
  // ELIGIBILITY
  // ========================================================================

  /**
   * Checks whether a player meets all requirements to ascend.
   * @param {Object} prestigeState
   * @param {number} playerLevel
   * @param {number} questsCompleted
   * @param {number} zonesVisited
   * @param {number} spark
   * @returns {{ eligible: boolean, missing: string[] }}
   */
  function canAscend(prestigeState, playerLevel, questsCompleted, zonesVisited, spark) {
    var missing = [];

    if (playerLevel < ASCENSION_REQUIRED_LEVEL) {
      missing.push('Must be level ' + ASCENSION_REQUIRED_LEVEL + ' (currently ' + playerLevel + ')');
    }
    if (questsCompleted < ASCENSION_REQUIRED_QUESTS) {
      missing.push('Must complete ' + ASCENSION_REQUIRED_QUESTS + ' quests (' + questsCompleted + ' completed)');
    }
    if (zonesVisited < ASCENSION_REQUIRED_ZONES) {
      missing.push('Must visit all ' + ASCENSION_REQUIRED_ZONES + ' zones (' + zonesVisited + ' visited)');
    }
    if (spark < ASCENSION_SPARK_COST) {
      missing.push('Must have ' + ASCENSION_SPARK_COST + ' Spark (' + spark + ' available)');
    }
    if (prestigeState.level >= MAX_PRESTIGE_LEVEL) {
      missing.push('Already at maximum prestige level (' + MAX_PRESTIGE_LEVEL + ')');
    }

    return {
      eligible: missing.length === 0,
      missing: missing
    };
  }

  // ========================================================================
  // ASCENSION
  // ========================================================================

  /**
   * Performs the ascension ritual.
   * Increments prestige level, unlocks rewards, resets progression.
   * @param {Object} prestigeState  - current prestige state (mutated in place)
   * @param {Object} playerData     - { level, xp, skillPoints, skillTree, spark, ... }
   * @returns {{ state, newPrestigeLevel, rewards, sparkCost, message }}
   */
  function ascend(prestigeState, playerData) {
    var currentLevel = prestigeState.level;
    var newPrestigeLevel = currentLevel + 1;

    // Guard: already at cap
    if (currentLevel >= MAX_PRESTIGE_LEVEL) {
      return {
        state: prestigeState,
        newPrestigeLevel: currentLevel,
        rewards: null,
        sparkCost: 0,
        message: 'You have already reached the pinnacle of ascension.'
      };
    }

    var rewards = PRESTIGE_REWARDS[newPrestigeLevel];
    var tier    = PRESTIGE_TIERS[newPrestigeLevel];

    // Add cosmetics (avoid duplicates)
    var cos = rewards.cosmetics;
    for (var ci = 0; ci < cos.length; ci++) {
      if (prestigeState.cosmetics.indexOf(cos[ci]) === -1) {
        prestigeState.cosmetics.push(cos[ci]);
      }
    }

    // Add perks (avoid duplicates)
    var perks = rewards.perks;
    for (var pi = 0; pi < perks.length; pi++) {
      if (prestigeState.perks.indexOf(perks[pi]) === -1) {
        prestigeState.perks.push(perks[pi]);
      }
    }

    // Unlock title
    if (prestigeState.unlockedTitles.indexOf(tier.title) === -1 && tier.title) {
      prestigeState.unlockedTitles.push(tier.title);
    }

    // Record history entry
    var historyEntry = {
      ascensionNumber: newPrestigeLevel,
      ts: Date.now(),
      fromLevel: playerData.level || 1,
      sparkSpent: ASCENSION_SPARK_COST,
      rewardsUnlocked: {
        cosmetics: cos.slice(),
        perks: perks.slice(),
        title: tier.title
      }
    };
    prestigeState.history.push(historyEntry);

    // Update prestige level and ascension count
    prestigeState.level = newPrestigeLevel;
    prestigeState.totalAscensions = newPrestigeLevel;

    // Reset player progression
    playerData.level      = 1;
    playerData.xp         = 0;
    playerData.skillPoints = 0;
    playerData.skillTree  = {};
    if (typeof playerData.spark === 'number') {
      playerData.spark -= ASCENSION_SPARK_COST;
    }

    var tierName = tier.name;
    var message = 'You have ascended to ' + tierName + '! Your journey begins anew with ' +
      'new powers and eternal recognition.';

    return {
      state: prestigeState,
      newPrestigeLevel: newPrestigeLevel,
      rewards: rewards,
      sparkCost: ASCENSION_SPARK_COST,
      message: message
    };
  }

  // ========================================================================
  // GETTERS
  // ========================================================================

  /**
   * Returns the tier object for the given prestige level.
   * @param {number} level
   * @returns {Object}
   */
  function getPrestigeTier(level) {
    var idx = Math.max(0, Math.min(level, PRESTIGE_TIERS.length - 1));
    return PRESTIGE_TIERS[idx];
  }

  /**
   * Returns the rewards for a specific prestige level (1â€“6).
   * Returns null for level 0 (no rewards yet).
   * @param {number} level
   * @returns {Object|null}
   */
  function getPrestigeRewards(level) {
    return PRESTIGE_REWARDS[level] || null;
  }

  /**
   * Returns cumulative cosmetics and perks across all unlocked prestige levels.
   * @param {Object} prestigeState
   * @returns {{ cosmetics: string[], perks: string[], titles: string[] }}
   */
  function getAllUnlockedRewards(prestigeState) {
    var cosmetics = [];
    var perks = [];
    var titles = [];

    for (var lvl = 1; lvl <= prestigeState.level; lvl++) {
      var rewards = PRESTIGE_REWARDS[lvl];
      if (!rewards) continue;

      for (var ci = 0; ci < rewards.cosmetics.length; ci++) {
        if (cosmetics.indexOf(rewards.cosmetics[ci]) === -1) {
          cosmetics.push(rewards.cosmetics[ci]);
        }
      }
      for (var pi = 0; pi < rewards.perks.length; pi++) {
        if (perks.indexOf(rewards.perks[pi]) === -1) {
          perks.push(rewards.perks[pi]);
        }
      }
      var tier = PRESTIGE_TIERS[lvl];
      if (tier && tier.title && titles.indexOf(tier.title) === -1) {
        titles.push(tier.title);
      }
    }

    return { cosmetics: cosmetics, perks: perks, titles: titles };
  }

  /**
   * Returns the Spark earning multiplier bonus for the given prestige level.
   * @param {number} level
   * @returns {number}
   */
  function getSparkBonus(level) {
    var tier = getPrestigeTier(level);
    return tier.sparkBonus;
  }

  /**
   * Returns the display title for the given prestige level.
   * @param {number} level
   * @returns {string}
   */
  function getPrestigeTitle(level) {
    var tier = getPrestigeTier(level);
    return tier.title;
  }

  /**
   * Returns the hex color for the given prestige level.
   * @param {number} level
   * @returns {string}
   */
  function getPrestigeColor(level) {
    var tier = getPrestigeTier(level);
    return tier.color;
  }

  /**
   * Returns an ASCII badge string for the given prestige level.
   * @param {number} level
   * @returns {string}
   */
  function getPrestigeBadge(level) {
    var idx = Math.max(0, Math.min(level, PRESTIGE_BADGES.length - 1));
    return PRESTIGE_BADGES[idx];
  }

  /**
   * Returns the full ascension history array from state.
   * @param {Object} state
   * @returns {Array}
   */
  function getAscensionHistory(state) {
    return state.history || [];
  }

  /**
   * Returns the total number of playthroughs (ascensions + 1 for current run).
   * @param {Object} state
   * @returns {number}
   */
  function getTotalPlaythroughs(state) {
    return (state.totalAscensions || 0) + 1;
  }

  /**
   * Checks whether a specific cosmetic has been unlocked.
   * @param {Object} state
   * @param {string} cosmeticId
   * @returns {boolean}
   */
  function hasCosmetic(state, cosmeticId) {
    return state.cosmetics.indexOf(cosmeticId) !== -1;
  }

  /**
   * Checks whether a specific perk has been unlocked.
   * @param {Object} state
   * @param {string} perkId
   * @returns {boolean}
   */
  function hasPerk(state, perkId) {
    return state.perks.indexOf(perkId) !== -1;
  }

  /**
   * Returns all active perks with their descriptions.
   * @param {Object} state
   * @returns {Array<{ id: string, label: string, type: string, value: number }>}
   */
  function getActivePerks(state) {
    var result = [];
    for (var pi = 0; pi < state.perks.length; pi++) {
      var perkId = state.perks[pi];
      var desc = PERK_DESCRIPTIONS[perkId];
      if (desc) {
        result.push({
          id: perkId,
          label: desc.label,
          type: desc.type,
          value: desc.value
        });
      } else {
        result.push({ id: perkId, label: perkId, type: 'unknown', value: 0 });
      }
    }
    return result;
  }

  /**
   * Applies prestige bonuses to a base value for a specific action type.
   * Supported actions: 'spark', 'xp', 'craft', 'gather', 'trade', 'travel', 'daily', 'loot'
   * @param {Object} state
   * @param {string} action
   * @param {number} baseValue
   * @returns {number}
   */
  function applyPrestigeBonus(state, action, baseValue) {
    var multiplier = 1.0;
    var hasMasterPerk = state.perks.indexOf('master_all_perks') !== -1;

    for (var pi = 0; pi < state.perks.length; pi++) {
      var perkId = state.perks[pi];
      var desc = PERK_DESCRIPTIONS[perkId];
      if (!desc) continue;

      // Master perk applies all perk types
      if (hasMasterPerk || desc.type === action) {
        if (desc.type === 'spark' && action === 'spark') {
          multiplier += desc.value;
        } else if (desc.type === 'xp' && action === 'xp') {
          multiplier += desc.value;
        } else if (desc.type === 'craft' && action === 'craft') {
          multiplier += desc.value;
        } else if (desc.type === 'gather' && action === 'gather') {
          multiplier += desc.value;
        } else if (desc.type === 'trade' && action === 'trade') {
          multiplier += desc.value;
        } else if (desc.type === 'loot' && action === 'loot') {
          multiplier += desc.value;
        } else if (desc.type === 'daily' && action === 'daily') {
          // daily is multiplicative (double/triple), use max instead of stack
          if (desc.value > multiplier) {
            multiplier = desc.value;
          }
        } else if (desc.type === 'travel' && action === 'travel') {
          if (desc.value !== 1.0) {
            multiplier *= (1.0 - desc.value);
          } else {
            multiplier = 0; // instant travel = 0 cost
          }
        }
      }
    }

    // For travel action, multiplier is a cost multiplier (reduction)
    if (action === 'travel') {
      return Math.max(0, Math.floor(baseValue * multiplier));
    }

    return Math.floor(baseValue * multiplier);
  }

  // ========================================================================
  // FORMATTING
  // ========================================================================

  /**
   * Returns an HTML string showing the prestige overview card.
   * @param {Object} state
   * @returns {string}
   */
  function formatPrestigeCard(state) {
    var tier   = getPrestigeTier(state.level);
    var badge  = getPrestigeBadge(state.level);
    var title  = tier.title ? (' &mdash; ' + tier.title) : '';
    var color  = tier.color;
    var perks  = getActivePerks(state);
    var allRew = getAllUnlockedRewards(state);

    var html = '<div class="prestige-card" style="border-color:' + color + '">';
    html += '<div class="prestige-header" style="color:' + color + '">';
    html += '<span class="prestige-badge">' + badge + '</span> ';
    html += '<span class="prestige-name">' + tier.name + '</span>';
    html += '<span class="prestige-title">' + title + '</span>';
    html += '</div>';

    html += '<div class="prestige-stats">';
    html += '<span>Prestige Level: <strong>' + state.level + '</strong></span> | ';
    html += '<span>Ascensions: <strong>' + state.totalAscensions + '</strong></span> | ';
    html += '<span>Spark Bonus: <strong>+' + (tier.sparkBonus * 100).toFixed(0) + '%</strong></span>';
    html += '</div>';

    if (allRew.cosmetics.length > 0) {
      html += '<div class="prestige-cosmetics">';
      html += '<strong>Cosmetics:</strong> ' + allRew.cosmetics.join(', ');
      html += '</div>';
    }

    if (perks.length > 0) {
      html += '<div class="prestige-perks"><strong>Active Perks:</strong><ul>';
      for (var i = 0; i < perks.length; i++) {
        html += '<li>' + perks[i].label + '</li>';
      }
      html += '</ul></div>';
    }

    html += '</div>';
    return html;
  }

  /**
   * Returns an HTML checklist showing ascension requirements and whether they are met.
   * @param {number} playerLevel
   * @param {number} questsCompleted
   * @param {number} zonesVisited
   * @param {number} spark
   * @returns {string}
   */
  function formatAscensionRequirements(playerLevel, questsCompleted, zonesVisited, spark) {
    function row(label, met) {
      var icon  = met ? '&#10003;' : '&#10007;';
      var color = met ? '#4CAF50' : '#f44336';
      return '<li style="color:' + color + '">' + icon + ' ' + label + '</li>';
    }

    var html = '<div class="ascension-requirements">';
    html += '<h3>Ascension Requirements</h3>';
    html += '<ul>';
    html += row('Level ' + ASCENSION_REQUIRED_LEVEL + ' (current: ' + playerLevel + ')',
                playerLevel >= ASCENSION_REQUIRED_LEVEL);
    html += row(ASCENSION_REQUIRED_QUESTS + ' quests completed (' + questsCompleted + ')',
                questsCompleted >= ASCENSION_REQUIRED_QUESTS);
    html += row('All ' + ASCENSION_REQUIRED_ZONES + ' zones visited (' + zonesVisited + ')',
                zonesVisited >= ASCENSION_REQUIRED_ZONES);
    html += row(ASCENSION_SPARK_COST + ' Spark (have: ' + spark + ')',
                spark >= ASCENSION_SPARK_COST);
    html += '</ul>';
    html += '</div>';
    return html;
  }

  /**
   * Returns a styled HTML badge for the given prestige level.
   * @param {number} level
   * @returns {string}
   */
  function formatPrestigeBadge(level) {
    var tier  = getPrestigeTier(level);
    var badge = getPrestigeBadge(level);
    return '<span class="prestige-badge-pill" style="background:' + tier.color +
      ';color:#000;padding:2px 8px;border-radius:12px;font-weight:bold;">' +
      badge + ' ' + tier.name + '</span>';
  }

  // ========================================================================
  // LEADERBOARD
  // ========================================================================

  /**
   * Returns a leaderboard entry object for a given player.
   * @param {Object} state
   * @param {string} playerName
   * @returns {{ name: string, prestigeLevel: number, totalAscensions: number, title: string }}
   */
  function getLeaderboardEntry(state, playerName) {
    return {
      name: playerName,
      prestigeLevel: state.level,
      totalAscensions: state.totalAscensions,
      title: getPrestigeTitle(state.level)
    };
  }

  // ========================================================================
  // EXPORTS
  // ========================================================================

  exports.PRESTIGE_TIERS          = PRESTIGE_TIERS;
  exports.PRESTIGE_REWARDS        = PRESTIGE_REWARDS;
  exports.PERK_DESCRIPTIONS       = PERK_DESCRIPTIONS;
  exports.ASCENSION_REQUIRED_LEVEL  = ASCENSION_REQUIRED_LEVEL;
  exports.ASCENSION_REQUIRED_QUESTS = ASCENSION_REQUIRED_QUESTS;
  exports.ASCENSION_REQUIRED_ZONES  = ASCENSION_REQUIRED_ZONES;
  exports.ASCENSION_SPARK_COST    = ASCENSION_SPARK_COST;
  exports.MAX_PRESTIGE_LEVEL      = MAX_PRESTIGE_LEVEL;

  exports.createPrestigeState        = createPrestigeState;
  exports.canAscend                  = canAscend;
  exports.ascend                     = ascend;
  exports.getPrestigeTier            = getPrestigeTier;
  exports.getPrestigeRewards         = getPrestigeRewards;
  exports.getAllUnlockedRewards       = getAllUnlockedRewards;
  exports.getSparkBonus              = getSparkBonus;
  exports.getPrestigeTitle           = getPrestigeTitle;
  exports.getPrestigeColor           = getPrestigeColor;
  exports.getPrestigeBadge           = getPrestigeBadge;
  exports.getAscensionHistory        = getAscensionHistory;
  exports.getTotalPlaythroughs       = getTotalPlaythroughs;
  exports.hasCosmetic                = hasCosmetic;
  exports.hasPerk                    = hasPerk;
  exports.getActivePerks             = getActivePerks;
  exports.applyPrestigeBonus         = applyPrestigeBonus;
  exports.formatPrestigeCard         = formatPrestigeCard;
  exports.formatAscensionRequirements = formatAscensionRequirements;
  exports.formatPrestigeBadge        = formatPrestigeBadge;
  exports.getLeaderboardEntry        = getLeaderboardEntry;

})(typeof module !== 'undefined' ? module.exports : (window.Prestige = {}));


// mentorship_market.js
// mentorship_market.js
(function(exports) {
  'use strict';

  // ============================================================================
  // TEACHABLE SUBJECTS CATALOG
  // ============================================================================

  var SUBJECTS = {
    fishing_basics: {
      name: 'Fishing Basics',
      category: 'gathering',
      minLevel: 5,
      basePrice: 10,
      duration: 300
    },
    advanced_fishing: {
      name: 'Advanced Fishing',
      category: 'gathering',
      minLevel: 15,
      basePrice: 25,
      duration: 300
    },
    herb_identification: {
      name: 'Herb Identification',
      category: 'gathering',
      minLevel: 5,
      basePrice: 10,
      duration: 300
    },
    basic_smithing: {
      name: 'Basic Smithing',
      category: 'crafting',
      minLevel: 5,
      basePrice: 12,
      duration: 300
    },
    advanced_crafting: {
      name: 'Advanced Crafting',
      category: 'crafting',
      minLevel: 20,
      basePrice: 30,
      duration: 300
    },
    recipe_mastery: {
      name: 'Recipe Mastery',
      category: 'crafting',
      minLevel: 25,
      basePrice: 40,
      duration: 600
    },
    card_strategy: {
      name: 'Card Game Strategy',
      category: 'minigames',
      minLevel: 10,
      basePrice: 15,
      duration: 300
    },
    dungeon_tactics: {
      name: 'Dungeon Tactics',
      category: 'minigames',
      minLevel: 15,
      basePrice: 20,
      duration: 300
    },
    trading_101: {
      name: 'Trading 101',
      category: 'economy',
      minLevel: 5,
      basePrice: 10,
      duration: 300
    },
    market_analysis: {
      name: 'Market Analysis',
      category: 'economy',
      minLevel: 20,
      basePrice: 35,
      duration: 300
    },
    zone_lore: {
      name: 'Zone Lore & History',
      category: 'knowledge',
      minLevel: 10,
      basePrice: 12,
      duration: 300
    },
    constellation_guide: {
      name: 'Constellation Guide',
      category: 'knowledge',
      minLevel: 10,
      basePrice: 15,
      duration: 300
    },
    navigation_skills: {
      name: 'Navigation Skills',
      category: 'exploration',
      minLevel: 5,
      basePrice: 10,
      duration: 300
    },
    survival_training: {
      name: 'Wilderness Survival',
      category: 'exploration',
      minLevel: 15,
      basePrice: 20,
      duration: 300
    },
    leadership: {
      name: 'Guild Leadership',
      category: 'social',
      minLevel: 20,
      basePrice: 25,
      duration: 600
    }
  };

  // ============================================================================
  // CONSTANTS
  // ============================================================================

  var VALID_CATEGORIES = ['gathering', 'crafting', 'minigames', 'economy', 'knowledge', 'exploration', 'social'];
  var CANCEL_REFUND_TICKS = 60;   // full refund if cancelled > 60 ticks before session
  var MIN_RATING = 1;
  var MAX_RATING = 5;
  var MAX_REVIEW_LENGTH = 200;
  var STUDENT_XP_BASE = 50;       // base XP student earns per session
  var TEACHER_XP_BASE = 20;       // base XP teacher earns per session
  var REPUTATION_BONUS = 5;       // reputation awarded on completion

  // Teacher rank thresholds (score = sessions * avgRating)
  var TEACHER_RANKS = [
    { minScore: 0,   rank: 'New Teacher'   },
    { minScore: 10,  rank: 'Instructor'    },
    { minScore: 30,  rank: 'Professor'     },
    { minScore: 60,  rank: 'Master Teacher' },
    { minScore: 100, rank: 'Grand Mentor'  }
  ];

  // Session status values
  var SESSION_STATUS = {
    BOOKED:    'booked',
    ACTIVE:    'active',
    COMPLETED: 'completed',
    CANCELLED: 'cancelled'
  };

  // Listing status values
  var LISTING_STATUS = {
    OPEN:      'open',
    FULL:      'full',
    CANCELLED: 'cancelled',
    COMPLETED: 'completed'
  };

  // ============================================================================
  // STATE FACTORY
  // ============================================================================

  /**
   * Creates a fresh market state
   * @returns {Object} Initial market state
   */
  function createMarketState() {
    return {
      listings: [],
      sessions: [],
      ratings: {},      // { sessionId: { teacher: {...}, student: {...} } }
      teacherStats: {}, // { teacherId: { totalSessions, totalEarned, subjectCounts } }
      nextListingId: 1,
      nextSessionId: 1
    };
  }

  // ============================================================================
  // INTERNAL HELPERS
  // ============================================================================

  function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function getListing(state, listingId) {
    for (var i = 0; i < state.listings.length; i++) {
      if (state.listings[i].id === listingId) return state.listings[i];
    }
    return null;
  }

  function getSession(state, sessionId) {
    for (var i = 0; i < state.sessions.length; i++) {
      if (state.sessions[i].id === sessionId) return state.sessions[i];
    }
    return null;
  }

  function getBookingsForListing(state, listingId) {
    var count = 0;
    for (var i = 0; i < state.sessions.length; i++) {
      var s = state.sessions[i];
      if (s.listingId === listingId && s.status !== SESSION_STATUS.CANCELLED) {
        count++;
      }
    }
    return count;
  }

  function updateListingStatus(state, listingId) {
    var listing = getListing(state, listingId);
    if (!listing || listing.status === LISTING_STATUS.CANCELLED) return;
    var booked = getBookingsForListing(state, listingId);
    if (booked >= listing.maxStudents) {
      listing.status = LISTING_STATUS.FULL;
    } else {
      listing.status = LISTING_STATUS.OPEN;
    }
  }

  function ensureTeacherStats(state, teacherId) {
    if (!state.teacherStats[teacherId]) {
      state.teacherStats[teacherId] = {
        totalSessions: 0,
        totalEarned: 0,
        subjectCounts: {}
      };
    }
  }

  function getTeacherRatingData(state, teacherId) {
    var totalStars = 0;
    var count = 0;
    var reviews = [];
    var sessionIds = Object.keys(state.ratings);
    for (var i = 0; i < sessionIds.length; i++) {
      var sid = sessionIds[i];
      var ratingEntry = state.ratings[sid];
      // Find session to see if this teacher was the teacher
      var session = getSession(state, parseInt(sid, 10));
      if (!session) continue;
      var listing = getListing(state, session.listingId);
      if (!listing || listing.teacherId !== teacherId) continue;
      if (ratingEntry.teacher) {
        totalStars += ratingEntry.teacher.rating;
        count++;
        if (ratingEntry.teacher.review) {
          reviews.push({
            sessionId: parseInt(sid, 10),
            rating: ratingEntry.teacher.rating,
            review: ratingEntry.teacher.review,
            raterId: session.studentId
          });
        }
      }
    }
    return {
      average: count > 0 ? Math.round((totalStars / count) * 100) / 100 : 0,
      count: count,
      reviews: reviews
    };
  }

  // ============================================================================
  // LISTING MANAGEMENT
  // ============================================================================

  /**
   * Teacher creates a listing for a teaching session
   * @param {Object} state - Market state
   * @param {string} teacherId - Teacher's player ID
   * @param {string} subjectId - Subject key from SUBJECTS
   * @param {number} price - Price in Spark (>= 0)
   * @param {number} maxStudents - Max students (>= 1)
   * @param {number} scheduleTick - Tick number when session will start
   * @param {number} teacherLevel - Teacher's current level (for validation)
   * @returns {Object} { state, listing, success, message }
   */
  function createListing(state, teacherId, subjectId, price, maxStudents, scheduleTick, teacherLevel) {
    var newState = deepCopy(state);

    if (!teacherId || typeof teacherId !== 'string' || !teacherId.trim()) {
      return { state: newState, listing: null, success: false, message: 'Invalid teacher ID' };
    }
    if (!subjectId || !SUBJECTS[subjectId]) {
      return { state: newState, listing: null, success: false, message: 'Unknown subject: ' + subjectId };
    }
    if (typeof price !== 'number' || price < 0) {
      return { state: newState, listing: null, success: false, message: 'Price must be a non-negative number' };
    }
    if (typeof maxStudents !== 'number' || maxStudents < 1 || !isFinite(maxStudents)) {
      return { state: newState, listing: null, success: false, message: 'maxStudents must be >= 1' };
    }
    if (typeof scheduleTick !== 'number' || scheduleTick < 0) {
      return { state: newState, listing: null, success: false, message: 'scheduleTick must be a non-negative number' };
    }

    var subject = SUBJECTS[subjectId];
    var level = typeof teacherLevel === 'number' ? teacherLevel : 0;
    if (level < subject.minLevel) {
      return {
        state: newState,
        listing: null,
        success: false,
        message: 'Teacher level ' + level + ' is below required level ' + subject.minLevel + ' for ' + subject.name
      };
    }

    var listing = {
      id: newState.nextListingId++,
      teacherId: teacherId,
      subjectId: subjectId,
      subject: subject,
      price: price,
      maxStudents: Math.floor(maxStudents),
      scheduleTick: scheduleTick,
      status: LISTING_STATUS.OPEN,
      createdAt: scheduleTick,
      sessions: []
    };

    newState.listings.push(listing);

    return { state: newState, listing: listing, success: true, message: 'Listing created successfully' };
  }

  /**
   * Teacher cancels their listing
   * @param {Object} state - Market state
   * @param {number} listingId - Listing ID
   * @param {string} teacherId - Teacher's player ID (must match listing)
   * @returns {Object} { state, success, message }
   */
  function cancelListing(state, listingId, teacherId) {
    var newState = deepCopy(state);
    var listing = getListing(newState, listingId);

    if (!listing) {
      return { state: newState, success: false, message: 'Listing not found' };
    }
    if (listing.teacherId !== teacherId) {
      return { state: newState, success: false, message: 'Only the teacher can cancel this listing' };
    }
    if (listing.status === LISTING_STATUS.CANCELLED) {
      return { state: newState, success: false, message: 'Listing is already cancelled' };
    }

    listing.status = LISTING_STATUS.CANCELLED;

    // Cancel all booked sessions and mark them cancelled
    for (var i = 0; i < newState.sessions.length; i++) {
      var session = newState.sessions[i];
      if (session.listingId === listingId && session.status === SESSION_STATUS.BOOKED) {
        session.status = SESSION_STATUS.CANCELLED;
        session.refunded = true;
      }
    }

    return { state: newState, success: true, message: 'Listing cancelled successfully' };
  }

  // ============================================================================
  // BOOKING
  // ============================================================================

  /**
   * Student books a session slot (payment held in escrow)
   * @param {Object} state - Market state
   * @param {number} listingId - Listing ID
   * @param {string} studentId - Student's player ID
   * @returns {Object} { state, session, success, message }
   */
  function bookSession(state, listingId, studentId) {
    var newState = deepCopy(state);

    if (!studentId || typeof studentId !== 'string' || !studentId.trim()) {
      return { state: newState, session: null, success: false, message: 'Invalid student ID' };
    }

    var listing = getListing(newState, listingId);
    if (!listing) {
      return { state: newState, session: null, success: false, message: 'Listing not found' };
    }
    if (listing.status === LISTING_STATUS.CANCELLED) {
      return { state: newState, session: null, success: false, message: 'Listing has been cancelled' };
    }
    if (listing.status === LISTING_STATUS.FULL) {
      return { state: newState, session: null, success: false, message: 'Listing is full' };
    }
    if (listing.teacherId === studentId) {
      return { state: newState, session: null, success: false, message: 'Teacher cannot book their own session' };
    }

    // Check student hasn't already booked this listing
    for (var i = 0; i < newState.sessions.length; i++) {
      var existing = newState.sessions[i];
      if (existing.listingId === listingId &&
          existing.studentId === studentId &&
          existing.status !== SESSION_STATUS.CANCELLED) {
        return { state: newState, session: null, success: false, message: 'Student has already booked this listing' };
      }
    }

    var session = {
      id: newState.nextSessionId++,
      listingId: listingId,
      teacherId: listing.teacherId,
      studentId: studentId,
      subjectId: listing.subjectId,
      price: listing.price,
      scheduleTick: listing.scheduleTick,
      status: SESSION_STATUS.BOOKED,
      escrow: listing.price,
      startedAt: null,
      completedAt: null,
      refunded: false
    };

    newState.sessions.push(session);

    // Update listing status
    var bookedCount = getBookingsForListing(newState, listingId);
    if (bookedCount >= listing.maxStudents) {
      listing.status = LISTING_STATUS.FULL;
    }

    return { state: newState, session: session, success: true, message: 'Session booked successfully' };
  }

  /**
   * Cancel a booking (refund if > CANCEL_REFUND_TICKS before session)
   * @param {Object} state - Market state
   * @param {number} sessionId - Session ID
   * @param {string} playerId - Player cancelling (student or teacher)
   * @param {number} currentTick - Current game tick
   * @returns {Object} { state, refunded, success, message }
   */
  function cancelBooking(state, sessionId, playerId, currentTick) {
    var newState = deepCopy(state);
    var session = getSession(newState, sessionId);

    if (!session) {
      return { state: newState, refunded: false, success: false, message: 'Session not found' };
    }
    if (session.studentId !== playerId && session.teacherId !== playerId) {
      return { state: newState, refunded: false, success: false, message: 'Player is not part of this session' };
    }
    if (session.status === SESSION_STATUS.CANCELLED) {
      return { state: newState, refunded: false, success: false, message: 'Session is already cancelled' };
    }
    if (session.status === SESSION_STATUS.COMPLETED) {
      return { state: newState, refunded: false, success: false, message: 'Cannot cancel a completed session' };
    }
    if (session.status === SESSION_STATUS.ACTIVE) {
      return { state: newState, refunded: false, success: false, message: 'Cannot cancel an active session' };
    }

    var tick = typeof currentTick === 'number' ? currentTick : 0;
    var ticksUntilSession = session.scheduleTick - tick;
    var refunded = ticksUntilSession > CANCEL_REFUND_TICKS;

    session.status = SESSION_STATUS.CANCELLED;
    session.refunded = refunded;

    // Re-open listing slot if it was full
    updateListingStatus(newState, session.listingId);

    return {
      state: newState,
      refunded: refunded,
      success: true,
      message: refunded ? 'Booking cancelled with full refund' : 'Booking cancelled without refund (too close to session time)'
    };
  }

  // ============================================================================
  // SESSION LIFECYCLE
  // ============================================================================

  /**
   * Start a session â€” both parties check in
   * @param {Object} state - Market state
   * @param {number} sessionId - Session ID
   * @param {number} currentTick - Current game tick
   * @returns {Object} { state, success, message }
   */
  function startSession(state, sessionId, currentTick) {
    var newState = deepCopy(state);
    var session = getSession(newState, sessionId);

    if (!session) {
      return { state: newState, success: false, message: 'Session not found' };
    }
    if (session.status === SESSION_STATUS.CANCELLED) {
      return { state: newState, success: false, message: 'Session has been cancelled' };
    }
    if (session.status === SESSION_STATUS.COMPLETED) {
      return { state: newState, success: false, message: 'Session is already completed' };
    }
    if (session.status === SESSION_STATUS.ACTIVE) {
      return { state: newState, success: false, message: 'Session is already active' };
    }

    var tick = typeof currentTick === 'number' ? currentTick : 0;

    session.status = SESSION_STATUS.ACTIVE;
    session.startedAt = tick;

    return { state: newState, success: true, message: 'Session started successfully' };
  }

  /**
   * Complete a session â€” distribute rewards and XP
   * @param {Object} state - Market state
   * @param {number} sessionId - Session ID
   * @param {number} currentTick - Current game tick
   * @returns {Object} { state, teacherReward, studentReward, success, message }
   */
  function completeSession(state, sessionId, currentTick) {
    var newState = deepCopy(state);
    var session = getSession(newState, sessionId);

    if (!session) {
      return { state: newState, teacherReward: null, studentReward: null, success: false, message: 'Session not found' };
    }
    if (session.status === SESSION_STATUS.CANCELLED) {
      return { state: newState, teacherReward: null, studentReward: null, success: false, message: 'Session has been cancelled' };
    }
    if (session.status === SESSION_STATUS.COMPLETED) {
      return { state: newState, teacherReward: null, studentReward: null, success: false, message: 'Session is already completed' };
    }
    if (session.status !== SESSION_STATUS.ACTIVE) {
      return { state: newState, teacherReward: null, studentReward: null, success: false, message: 'Session must be started before it can be completed' };
    }

    var tick = typeof currentTick === 'number' ? currentTick : 0;
    var subject = SUBJECTS[session.subjectId] || {};
    var durationBonus = subject.duration === 600 ? 1.5 : 1.0;

    var teacherReward = {
      spark: session.price,
      xp: Math.floor(TEACHER_XP_BASE * durationBonus),
      reputation: REPUTATION_BONUS
    };
    var studentReward = {
      spark: 0,
      xp: Math.floor(STUDENT_XP_BASE * durationBonus),
      reputation: REPUTATION_BONUS
    };

    session.status = SESSION_STATUS.COMPLETED;
    session.completedAt = tick;
    session.escrow = 0;

    // Update teacher stats
    ensureTeacherStats(newState, session.teacherId);
    var stats = newState.teacherStats[session.teacherId];
    stats.totalSessions++;
    stats.totalEarned += session.price;
    if (!stats.subjectCounts[session.subjectId]) {
      stats.subjectCounts[session.subjectId] = 0;
    }
    stats.subjectCounts[session.subjectId]++;

    return {
      state: newState,
      teacherReward: teacherReward,
      studentReward: studentReward,
      success: true,
      message: 'Session completed successfully'
    };
  }

  // ============================================================================
  // RATING SYSTEM
  // ============================================================================

  /**
   * Rate a session (1-5 stars, optional review)
   * @param {Object} state - Market state
   * @param {number} sessionId - Session ID
   * @param {string} raterId - Player giving the rating
   * @param {number} rating - Rating 1-5
   * @param {string} review - Optional review text (max 200 chars)
   * @returns {Object} { state, success, message }
   */
  function rateSession(state, sessionId, raterId, rating, review) {
    var newState = deepCopy(state);
    var session = getSession(newState, sessionId);

    if (!session) {
      return { state: newState, success: false, message: 'Session not found' };
    }
    if (session.status !== SESSION_STATUS.COMPLETED) {
      return { state: newState, success: false, message: 'Can only rate completed sessions' };
    }
    if (session.teacherId !== raterId && session.studentId !== raterId) {
      return { state: newState, success: false, message: 'Rater is not part of this session' };
    }

    if (typeof rating !== 'number' || !isFinite(rating) || rating < MIN_RATING || rating > MAX_RATING) {
      return { state: newState, success: false, message: 'Rating must be between 1 and 5' };
    }
    var intRating = Math.round(rating);
    if (intRating < MIN_RATING || intRating > MAX_RATING) {
      return { state: newState, success: false, message: 'Rating must be between 1 and 5' };
    }

    var reviewText = '';
    if (review && typeof review === 'string') {
      reviewText = review.trim().substring(0, MAX_REVIEW_LENGTH);
    }

    if (!newState.ratings[sessionId]) {
      newState.ratings[sessionId] = {};
    }
    var ratingEntry = newState.ratings[sessionId];

    // Determine whether rater is teacher or student
    var isTeacher = raterId === session.teacherId;
    var ratingKey = isTeacher ? 'student' : 'teacher'; // teacher rates student, student rates teacher

    if (ratingEntry[ratingKey]) {
      return { state: newState, success: false, message: 'Already rated this session' };
    }

    ratingEntry[ratingKey] = {
      raterId: raterId,
      rating: intRating,
      review: reviewText,
      flagged: intRating < 2
    };

    return { state: newState, success: true, message: 'Rating submitted successfully' };
  }

  // ============================================================================
  // QUERIES
  // ============================================================================

  /**
   * Get a teacher's rating summary
   * @param {Object} state - Market state
   * @param {string} teacherId - Teacher's player ID
   * @returns {Object} { average, count, reviews }
   */
  function getTeacherRating(state, teacherId) {
    return getTeacherRatingData(state, teacherId);
  }

  /**
   * Get listings with optional filters
   * @param {Object} state - Market state
   * @param {Object} filters - { subject, category, maxPrice, minRating, teacherId, sortBy }
   * @returns {Array} Filtered and sorted listings
   */
  function getListings(state, filters) {
    var opts = filters || {};
    var results = [];

    for (var i = 0; i < state.listings.length; i++) {
      var listing = state.listings[i];

      // Only show open listings by default
      if (listing.status === LISTING_STATUS.CANCELLED) continue;

      if (opts.subject && listing.subjectId !== opts.subject) continue;
      if (opts.category && listing.subject && listing.subject.category !== opts.category) continue;
      if (typeof opts.maxPrice === 'number' && listing.price > opts.maxPrice) continue;
      if (opts.teacherId && listing.teacherId !== opts.teacherId) continue;

      // minRating filter requires computing teacher rating
      if (typeof opts.minRating === 'number') {
        var ratingData = getTeacherRatingData(state, listing.teacherId);
        if (ratingData.count > 0 && ratingData.average < opts.minRating) continue;
      }

      results.push(listing);
    }

    // Sort
    var sortBy = opts.sortBy || 'rating';

    if (sortBy === 'price') {
      results.sort(function(a, b) { return a.price - b.price; });
    } else if (sortBy === 'date') {
      results.sort(function(a, b) { return a.scheduleTick - b.scheduleTick; });
    } else {
      // Default: sort by teacher rating descending
      results.sort(function(a, b) {
        var rA = getTeacherRatingData(state, a.teacherId).average;
        var rB = getTeacherRatingData(state, b.teacherId).average;
        return rB - rA;
      });
    }

    return results;
  }

  /**
   * Get all subjects
   * @returns {Object} All SUBJECTS
   */
  function getSubjects() {
    return SUBJECTS;
  }

  /**
   * Get subjects filtered by category
   * @param {string} category - Category name
   * @returns {Object} Filtered subjects
   */
  function getSubjectsByCategory(category) {
    var result = {};
    var keys = Object.keys(SUBJECTS);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (SUBJECTS[key].category === category) {
        result[key] = SUBJECTS[key];
      }
    }
    return result;
  }

  /**
   * Get teacher rank label based on score
   * @param {number} totalSessions - Number of sessions completed
   * @param {number} avgRating - Average rating (0-5)
   * @returns {string} Rank label
   */
  function getTeacherRank(totalSessions, avgRating) {
    var sessions = typeof totalSessions === 'number' && isFinite(totalSessions) ? Math.max(0, totalSessions) : 0;
    var rating = typeof avgRating === 'number' && isFinite(avgRating) ? Math.max(0, avgRating) : 0;
    var score = sessions * rating;
    var rank = TEACHER_RANKS[0].rank;
    for (var i = 0; i < TEACHER_RANKS.length; i++) {
      if (score >= TEACHER_RANKS[i].minScore) {
        rank = TEACHER_RANKS[i].rank;
      }
    }
    return rank;
  }

  /**
   * Get a teacher's full profile
   * @param {Object} state - Market state
   * @param {string} teacherId - Teacher's player ID
   * @returns {Object} { totalSessions, averageRating, subjects, totalEarned, rank }
   */
  function getTeacherProfile(state, teacherId) {
    var stats = state.teacherStats[teacherId] || {
      totalSessions: 0,
      totalEarned: 0,
      subjectCounts: {}
    };
    var ratingData = getTeacherRatingData(state, teacherId);
    var rank = getTeacherRank(stats.totalSessions, ratingData.average);

    return {
      teacherId: teacherId,
      totalSessions: stats.totalSessions,
      averageRating: ratingData.average,
      ratingCount: ratingData.count,
      subjects: stats.subjectCounts,
      totalEarned: stats.totalEarned,
      rank: rank
    };
  }

  /**
   * Get top teachers leaderboard
   * @param {Object} state - Market state
   * @param {number} limit - Max results (default 10)
   * @returns {Array} Teachers sorted by rating * sessions
   */
  function getTopTeachers(state, limit) {
    var maxResults = typeof limit === 'number' && limit > 0 ? limit : 10;
    var teacherIds = Object.keys(state.teacherStats);

    var teachers = teacherIds.map(function(tid) {
      var profile = getTeacherProfile(state, tid);
      profile.score = profile.totalSessions * profile.averageRating;
      return profile;
    });

    teachers.sort(function(a, b) { return b.score - a.score; });
    return teachers.slice(0, maxResults);
  }

  /**
   * Get a student's session history
   * @param {Object} state - Market state
   * @param {string} studentId - Student's player ID
   * @returns {Array} Sessions with rating info
   */
  function getStudentHistory(state, studentId) {
    var history = [];
    for (var i = 0; i < state.sessions.length; i++) {
      var session = state.sessions[i];
      if (session.studentId !== studentId) continue;

      var ratingEntry = state.ratings[session.id] || {};
      var myRating = ratingEntry.teacher || null; // student rated the teacher
      var theirRating = ratingEntry.student || null; // teacher rated the student

      history.push({
        session: session,
        subjectName: SUBJECTS[session.subjectId] ? SUBJECTS[session.subjectId].name : session.subjectId,
        myRating: myRating,
        receivedRating: theirRating
      });
    }
    return history;
  }

  // ============================================================================
  // FORMATTING
  // ============================================================================

  /**
   * Format rating as star display: "[***--]" style
   * @param {number} rating - Rating 0-5
   * @returns {string} Star display string
   */
  function formatRatingStars(rating) {
    var r = typeof rating === 'number' ? Math.round(Math.max(0, Math.min(5, rating))) : 0;
    var stars = '';
    for (var i = 0; i < 5; i++) {
      stars += i < r ? '*' : '-';
    }
    return '[' + stars + ']';
  }

  /**
   * Format a listing card as HTML
   * @param {Object} listing - Listing object
   * @param {Object} teacherRating - Rating data { average, count }
   * @returns {string} HTML string
   */
  function formatListingCard(listing, teacherRating) {
    if (!listing) return '<div class="listing-card listing-card--empty">No listing data</div>';
    var subject = listing.subject || SUBJECTS[listing.subjectId] || {};
    var subjectName = subject.name || listing.subjectId || 'Unknown Subject';
    var category = subject.category || 'unknown';
    var duration = subject.duration ? Math.floor(subject.duration / 60) + ' min' : 'N/A';
    var rating = teacherRating || { average: 0, count: 0 };
    var stars = formatRatingStars(rating.average);
    var ratingText = rating.count > 0
      ? stars + ' (' + rating.average.toFixed(1) + ', ' + rating.count + ' ratings)'
      : 'No ratings yet';
    var statusClass = 'listing-card--' + (listing.status || 'open');

    return '<div class="listing-card ' + statusClass + '" data-listing-id="' + listing.id + '">' +
      '<div class="listing-card__header">' +
        '<span class="listing-card__subject">' + subjectName + '</span>' +
        '<span class="listing-card__category listing-card__category--' + category + '">' + category + '</span>' +
      '</div>' +
      '<div class="listing-card__body">' +
        '<div class="listing-card__price">' + listing.price + ' Spark</div>' +
        '<div class="listing-card__duration">' + duration + '</div>' +
        '<div class="listing-card__rating">' + ratingText + '</div>' +
        '<div class="listing-card__slots">' + listing.maxStudents + ' slot(s)</div>' +
        '<div class="listing-card__tick">Tick: ' + listing.scheduleTick + '</div>' +
      '</div>' +
      '<div class="listing-card__footer">' +
        '<span class="listing-card__status">' + (listing.status || 'open') + '</span>' +
        '<span class="listing-card__teacher">Teacher: ' + listing.teacherId + '</span>' +
      '</div>' +
    '</div>';
  }

  /**
   * Format a session card as HTML
   * @param {Object} session - Session object
   * @returns {string} HTML string
   */
  function formatSessionCard(session) {
    if (!session) return '<div class="session-card session-card--empty">No session data</div>';
    var subject = SUBJECTS[session.subjectId] || {};
    var subjectName = subject.name || session.subjectId || 'Unknown Subject';
    var statusClass = 'session-card--' + (session.status || 'booked');
    var tickLabel = session.status === SESSION_STATUS.ACTIVE
      ? 'Started at tick: ' + session.startedAt
      : session.status === SESSION_STATUS.COMPLETED
        ? 'Completed at tick: ' + session.completedAt
        : 'Scheduled for tick: ' + session.scheduleTick;

    return '<div class="session-card ' + statusClass + '" data-session-id="' + session.id + '">' +
      '<div class="session-card__header">' +
        '<span class="session-card__subject">' + subjectName + '</span>' +
        '<span class="session-card__status">' + (session.status || 'booked') + '</span>' +
      '</div>' +
      '<div class="session-card__body">' +
        '<div class="session-card__teacher">Teacher: ' + session.teacherId + '</div>' +
        '<div class="session-card__student">Student: ' + session.studentId + '</div>' +
        '<div class="session-card__price">' + session.price + ' Spark</div>' +
        '<div class="session-card__tick">' + tickLabel + '</div>' +
      '</div>' +
    '</div>';
  }

  /**
   * Format a teacher profile card as HTML
   * @param {Object} profile - Profile from getTeacherProfile
   * @returns {string} HTML string
   */
  function formatTeacherProfile(profile) {
    if (!profile) return '<div class="teacher-profile teacher-profile--empty">No profile data</div>';
    var stars = formatRatingStars(profile.averageRating);
    var subjectList = '';
    var subjectKeys = Object.keys(profile.subjects || {});
    if (subjectKeys.length > 0) {
      subjectList = '<ul class="teacher-profile__subjects">';
      for (var i = 0; i < subjectKeys.length; i++) {
        var subId = subjectKeys[i];
        var subName = SUBJECTS[subId] ? SUBJECTS[subId].name : subId;
        subjectList += '<li>' + subName + ' (' + profile.subjects[subId] + ' sessions)</li>';
      }
      subjectList += '</ul>';
    } else {
      subjectList = '<p class="teacher-profile__no-subjects">No sessions taught yet</p>';
    }

    return '<div class="teacher-profile" data-teacher-id="' + profile.teacherId + '">' +
      '<div class="teacher-profile__header">' +
        '<span class="teacher-profile__id">' + profile.teacherId + '</span>' +
        '<span class="teacher-profile__rank">' + profile.rank + '</span>' +
      '</div>' +
      '<div class="teacher-profile__stats">' +
        '<div class="teacher-profile__sessions">Sessions: ' + profile.totalSessions + '</div>' +
        '<div class="teacher-profile__earned">Total Earned: ' + profile.totalEarned + ' Spark</div>' +
        '<div class="teacher-profile__rating">' + stars + ' ' +
          (profile.averageRating > 0 ? profile.averageRating.toFixed(1) : 'No ratings') +
          ' (' + profile.ratingCount + ' ratings)</div>' +
      '</div>' +
      subjectList +
    '</div>';
  }

  // ============================================================================
  // EXPORTS
  // ============================================================================

  exports.SUBJECTS = SUBJECTS;
  exports.VALID_CATEGORIES = VALID_CATEGORIES;
  exports.SESSION_STATUS = SESSION_STATUS;
  exports.LISTING_STATUS = LISTING_STATUS;
  exports.TEACHER_RANKS = TEACHER_RANKS;
  exports.CANCEL_REFUND_TICKS = CANCEL_REFUND_TICKS;

  exports.createMarketState = createMarketState;
  exports.createListing = createListing;
  exports.cancelListing = cancelListing;
  exports.bookSession = bookSession;
  exports.cancelBooking = cancelBooking;
  exports.startSession = startSession;
  exports.completeSession = completeSession;
  exports.rateSession = rateSession;
  exports.getTeacherRating = getTeacherRating;
  exports.getListings = getListings;
  exports.getSubjects = getSubjects;
  exports.getSubjectsByCategory = getSubjectsByCategory;
  exports.getTeacherProfile = getTeacherProfile;
  exports.getTeacherRank = getTeacherRank;
  exports.getTopTeachers = getTopTeachers;
  exports.getStudentHistory = getStudentHistory;
  exports.formatListingCard = formatListingCard;
  exports.formatSessionCard = formatSessionCard;
  exports.formatTeacherProfile = formatTeacherProfile;
  exports.formatRatingStars = formatRatingStars;

})(typeof module !== 'undefined' ? module.exports : (window.MentorshipMarket = {}));


// dashboard.js
// dashboard.js
/**
 * dashboard.js - UI-only dashboard mode for ZION
 *
 * Text/panel-based interface for interacting with ALL ZION game systems
 * without the 3D world. Replaces the Three.js canvas with a responsive
 * panel grid when enabled.
 *
 * UMD module: window.Dashboard (browser) or module.exports (Node.js)
 * ES5 compatible - uses var declarations
 */
(function(exports) {
  'use strict';

  // â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var STORAGE_KEY_MODE = 'zion_dashboard_mode';
  var STORAGE_KEY_LAYOUT = 'zion_dashboard_layout';
  var STORAGE_KEY_PANELS = 'zion_dashboard_panels';
  var STORAGE_KEY_POSITIONS = 'zion_dashboard_positions';

  var LAYOUTS = ['compact', 'full', 'minimal'];

  var CATEGORIES = ['all', 'navigation', 'social', 'economy', 'gameplay', 'info', 'minigames'];

  var COLORS = {
    bg: '#0A0E1A',
    bgPanel: '#111827',
    bgHeader: '#0D1321',
    bgTab: '#161F2E',
    bgTabActive: '#1E2D44',
    border: '#1E3A5F',
    borderHighlight: '#2A5285',
    accent: '#DAA520',
    accentHover: '#F0B830',
    text: '#E8E0D8',
    textMuted: '#8A9AB0',
    textDim: '#4A5A70',
    success: '#2E7D32',
    warning: '#F57F17',
    danger: '#C62828',
    info: '#1565C0'
  };

  var BREAKPOINTS = {
    mobile: 768,
    tablet: 1200
  };

  var PANEL_CATEGORIES = {
    'zone-navigator': 'navigation',
    'npc-panel': 'social',
    'inventory-panel': 'gameplay',
    'economy-panel': 'economy',
    'quest-panel': 'gameplay',
    'social-panel': 'social',
    'minigames-panel': 'minigames',
    'world-status-panel': 'info',
    'player-stats-panel': 'info',
    'governance-panel': 'info'
  };

  // â”€â”€â”€ Module State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var _container = null;
  var _headerEl = null;
  var _mainEl = null;
  var _footerEl = null;
  var _panelGrid = null;
  var _currentLayout = 'full';
  var _currentCategory = 'all';
  var _currentZone = 'nexus';
  var _gameState = null;
  var _focusedPanelIndex = 0;
  var _keyHandlers = {};
  var _resizeTimer = null;
  var _initialized = false;
  var _notifications = [];
  var _panelElements = {};

  // Panel registry: id -> panel definition
  var _panelRegistry = {};

  // Panel open/closed state
  var _panelStates = {};

  // Panel positions (for dragging)
  var _panelPositions = {};

  // â”€â”€â”€ Zone Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var ZONES = {
    nexus: { name: 'The Nexus', terrain: 'crystalline plaza', safe: true },
    gardens: { name: 'The Gardens', terrain: 'cultivated gardens', safe: true },
    athenaeum: { name: 'The Athenaeum', terrain: 'marble halls', safe: true },
    studio: { name: 'The Studio', terrain: 'artisan workshops', safe: true },
    wilds: { name: 'The Wilds', terrain: 'wilderness', safe: false },
    agora: { name: 'The Agora', terrain: 'market square', safe: true },
    commons: { name: 'The Commons', terrain: 'building grounds', safe: true },
    arena: { name: 'The Arena', terrain: 'combat grounds', safe: false }
  };

  // â”€â”€â”€ Utility Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _safeLocalStorage(action, key, value) {
    try {
      if (typeof localStorage === 'undefined') { return null; }
      if (action === 'get') { return localStorage.getItem(key); }
      if (action === 'set') { localStorage.setItem(key, value); return true; }
      if (action === 'remove') { localStorage.removeItem(key); return true; }
    } catch (e) {
      return null;
    }
    return null;
  }

  function _getScreenWidth() {
    if (typeof window !== 'undefined' && window.innerWidth) {
      return window.innerWidth;
    }
    return 1280; // default to desktop
  }

  function _getColumnCount() {
    var width = _getScreenWidth();
    if (width < BREAKPOINTS.mobile) { return 1; }
    if (width < BREAKPOINTS.tablet) { return 2; }
    return 3;
  }

  function _escapeHtml(str) {
    if (typeof str !== 'string') { return String(str); }
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function _formatTime(timeOfDay) {
    if (!timeOfDay && timeOfDay !== 0) { return '--:--'; }
    var hour = Math.floor(timeOfDay);
    var min = Math.floor((timeOfDay - hour) * 60);
    var h = String(hour).padStart ? String(hour).padStart(2, '0') : (hour < 10 ? '0' + hour : String(hour));
    var m = String(min).padStart ? String(min).padStart(2, '0') : (min < 10 ? '0' + min : String(min));
    return h + ':' + m;
  }

  function _getElementById(id) {
    if (typeof document === 'undefined') { return null; }
    return document.getElementById(id);
  }

  function _createElement(tag, attrs, children) {
    if (typeof document === 'undefined') { return null; }
    var el = document.createElement(tag);
    if (attrs) {
      for (var k in attrs) {
        if (Object.prototype.hasOwnProperty.call(attrs, k)) {
          if (k === 'style') {
            el.style.cssText = attrs[k];
          } else if (k === 'className') {
            el.className = attrs[k];
          } else if (k.indexOf('data-') === 0) {
            el.setAttribute(k, attrs[k]);
          } else {
            el[k] = attrs[k];
          }
        }
      }
    }
    if (children) {
      if (typeof children === 'string') {
        el.innerHTML = children;
      } else if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          if (children[i]) { el.appendChild(children[i]); }
        }
      } else {
        el.appendChild(children);
      }
    }
    return el;
  }

  // â”€â”€â”€ isDashboardMode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns true if dashboard mode should be active.
   * Checks: URL param, URL hash, localStorage, or absence of THREE.
   */
  function isDashboardMode() {
    // Check if THREE is not available (no WebGL fallback)
    if (typeof window !== 'undefined' && typeof window.THREE === 'undefined') {
      // Only auto-activate if we're in a browser environment without THREE
      // but not in a Node.js test environment
      if (typeof document !== 'undefined') {
        // In browser without THREE - but only activate if explicitly set or no THREE
        // Don't auto-activate in test environments
      }
    }

    // Check URL parameter
    if (typeof window !== 'undefined' && typeof window.location !== 'undefined') {
      var search = window.location.search || '';
      var hash = window.location.hash || '';
      if (search.indexOf('mode=dashboard') !== -1) { return true; }
      if (hash === '#dashboard' || hash.indexOf('#dashboard') === 0) { return true; }
    }

    // Check localStorage
    var stored = _safeLocalStorage('get', STORAGE_KEY_MODE);
    if (stored === 'true') { return true; }

    // Check if THREE is absent (in browser only, not Node test environment)
    if (typeof window !== 'undefined' &&
        typeof document !== 'undefined' &&
        typeof window.THREE === 'undefined' &&
        typeof process === 'undefined') {
      return true;
    }

    return false;
  }

  // â”€â”€â”€ Panel Styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _getPanelStyle() {
    return [
      'background:' + COLORS.bgPanel,
      'border:1px solid ' + COLORS.border,
      'border-radius:4px',
      'display:flex',
      'flex-direction:column',
      'overflow:hidden',
      'min-height:200px',
      'max-height:500px',
      'position:relative'
    ].join(';');
  }

  function _getPanelHeaderStyle() {
    return [
      'background:' + COLORS.bgHeader,
      'border-bottom:1px solid ' + COLORS.border,
      'padding:8px 12px',
      'display:flex',
      'align-items:center',
      'justify-content:space-between',
      'cursor:default',
      'user-select:none',
      'flex-shrink:0'
    ].join(';');
  }

  function _getPanelBodyStyle(collapsed) {
    return [
      'padding:12px',
      'overflow-y:auto',
      'flex:1',
      collapsed ? 'display:none' : 'display:block',
      'color:' + COLORS.text,
      'font-size:13px',
      'line-height:1.5'
    ].join(';');
  }

  function _getButtonStyle(variant) {
    var base = [
      'background:transparent',
      'border:none',
      'cursor:pointer',
      'padding:2px 6px',
      'border-radius:3px',
      'font-size:11px',
      'line-height:1.4'
    ].join(';');

    if (variant === 'accent') {
      return base + ';color:' + COLORS.accent + ';font-weight:bold';
    }
    return base + ';color:' + COLORS.textMuted;
  }

  // â”€â”€â”€ createPanel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Factory for creating dashboard panels.
   * @param {string} id - Panel identifier
   * @param {string} title - Panel display title
   * @param {string} icon - Text symbol icon (e.g. '[>]', '[*]')
   * @param {string|Element} content - Initial panel body content
   * @returns {Element} The panel DOM element
   */
  function createPanel(id, title, icon, content) {
    if (typeof document === 'undefined') {
      // Return a mock object for Node.js testing
      return {
        id: id,
        _panelId: id,
        _collapsed: false,
        getAttribute: function(attr) {
          if (attr === 'data-panel-id') { return id; }
          return null;
        },
        querySelector: function(sel) { return null; },
        style: {},
        classList: { add: function() {}, remove: function() {}, contains: function() { return false; } }
      };
    }

    var panelEl = _createElement('div', {
      id: 'panel-' + id,
      'data-panel-id': id,
      style: _getPanelStyle()
    });

    // Header
    var titleEl = _createElement('span', {
      style: 'color:' + COLORS.accent + ';font-weight:bold;font-size:13px;font-family:monospace'
    }, _escapeHtml(icon) + ' ' + _escapeHtml(title));

    var btnMinimize = _createElement('button', {
      style: _getButtonStyle('muted'),
      title: 'Minimize'
    }, '[-]');

    var btnMaximize = _createElement('button', {
      style: _getButtonStyle('muted'),
      title: 'Maximize'
    }, '[+]');

    var btnClose = _createElement('button', {
      style: _getButtonStyle('accent'),
      title: 'Close'
    }, '[x]');

    var controlsEl = _createElement('div', {
      style: 'display:flex;gap:4px;align-items:center'
    }, [btnMinimize, btnMaximize, btnClose]);

    var headerEl = _createElement('div', {
      style: _getPanelHeaderStyle()
    }, [titleEl, controlsEl]);

    // Body
    var bodyEl = _createElement('div', {
      'data-panel-body': id,
      style: _getPanelBodyStyle(false)
    });

    if (content) {
      if (typeof content === 'string') {
        bodyEl.innerHTML = content;
      } else {
        bodyEl.appendChild(content);
      }
    }

    panelEl.appendChild(headerEl);
    panelEl.appendChild(bodyEl);

    // Wire up panel controls
    var collapsed = false;
    btnMinimize.addEventListener('click', function() {
      collapsed = !collapsed;
      bodyEl.style.display = collapsed ? 'none' : 'block';
      btnMinimize.innerHTML = collapsed ? '[+]' : '[-]';
    });

    btnMaximize.addEventListener('click', function() {
      if (panelEl.style.maxHeight === 'none' || panelEl.style.maxHeight === '') {
        panelEl.style.maxHeight = '500px';
        btnMaximize.innerHTML = '[+]';
      } else {
        panelEl.style.maxHeight = 'none';
        btnMaximize.innerHTML = '[-]';
      }
    });

    btnClose.addEventListener('click', function() {
      hidePanel(id);
    });

    // Store reference
    _panelElements[id] = panelEl;

    return panelEl;
  }

  // â”€â”€â”€ Panel Registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Register a panel definition in the registry.
   * @param {Object} def Panel definition object
   */
  function registerPanel(def) {
    if (!def || !def.id) { return false; }
    _panelRegistry[def.id] = {
      id: def.id,
      title: def.title || def.id,
      icon: def.icon || '[#]',
      category: def.category || 'info',
      create: def.create || function() { return createPanel(def.id, def.title || def.id, def.icon || '[#]', ''); },
      update: def.update || function() {},
      destroy: def.destroy || function() {}
    };
    // Initialize open state from saved state or default to open
    if (_panelStates[def.id] === undefined) {
      var savedStates = _loadPanelStates();
      _panelStates[def.id] = savedStates[def.id] !== undefined ? savedStates[def.id] : true;
    }
    return true;
  }

  /**
   * Get a panel definition from the registry.
   */
  function getPanel(id) {
    return _panelRegistry[id] || null;
  }

  /**
   * Get all registered panels.
   */
  function getAllPanels() {
    var result = [];
    for (var id in _panelRegistry) {
      if (Object.prototype.hasOwnProperty.call(_panelRegistry, id)) {
        result.push(_panelRegistry[id]);
      }
    }
    return result;
  }

  /**
   * Get panels by category.
   */
  function getPanelsByCategory(category) {
    var result = [];
    for (var id in _panelRegistry) {
      if (Object.prototype.hasOwnProperty.call(_panelRegistry, id)) {
        var panel = _panelRegistry[id];
        if (category === 'all' || panel.category === category) {
          result.push(panel);
        }
      }
    }
    return result;
  }

  // â”€â”€â”€ Default Panel Stubs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _registerDefaultPanels() {
    var defaultPanels = [
      {
        id: 'zone-navigator',
        title: 'Zone Navigator',
        icon: '[>]',
        category: 'navigation',
        create: function() {
          return createPanel('zone-navigator', 'Zone Navigator', '[>]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="margin-bottom:8px;color:' + COLORS.accent + '">Current Zone: ' +
            _escapeHtml(ZONES[_currentZone] ? ZONES[_currentZone].name : _currentZone) +
            '</div>' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">Select a zone to travel:</div>' +
            _renderZoneList() +
            '</div>');
        },
        update: function(state) {
          var el = _getElementById('panel-zone-navigator');
          if (!el) { return; }
          var body = el.querySelector('[data-panel-body]');
          if (!body) { return; }
          body.innerHTML = '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="margin-bottom:8px;color:' + COLORS.accent + '">Current Zone: ' +
            _escapeHtml(ZONES[_currentZone] ? ZONES[_currentZone].name : _currentZone) +
            '</div>' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">Select a zone to travel:</div>' +
            _renderZoneList() +
            '</div>';
        }
      },
      {
        id: 'npc-panel',
        title: 'Citizens',
        icon: '[&]',
        category: 'social',
        create: function() {
          return createPanel('npc-panel', 'Citizens', '[&]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[NPC interaction system â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      },
      {
        id: 'inventory-panel',
        title: 'Inventory',
        icon: '[=]',
        category: 'gameplay',
        create: function() {
          return createPanel('inventory-panel', 'Inventory', '[=]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Inventory â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      },
      {
        id: 'economy-panel',
        title: 'Economy',
        icon: '[$]',
        category: 'economy',
        create: function() {
          return createPanel('economy-panel', 'Economy', '[$]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Market and trading â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      },
      {
        id: 'quest-panel',
        title: 'Quests',
        icon: '[!]',
        category: 'gameplay',
        create: function() {
          return createPanel('quest-panel', 'Quests', '[!]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Quests and achievements â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      },
      {
        id: 'social-panel',
        title: 'Social',
        icon: '[~]',
        category: 'social',
        create: function() {
          return createPanel('social-panel', 'Social', '[~]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Chat, guild, profiles â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      },
      {
        id: 'minigames-panel',
        title: 'Minigames',
        icon: '[*]',
        category: 'minigames',
        create: function() {
          return createPanel('minigames-panel', 'Minigames', '[*]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Card game, fishing, dungeons â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      },
      {
        id: 'world-status-panel',
        title: 'World Status',
        icon: '[o]',
        category: 'info',
        create: function() {
          return createPanel('world-status-panel', 'World Status', '[o]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Time, weather, events â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {
          if (!state) { return; }
          var el = _getElementById('panel-world-status-panel');
          if (!el) { return; }
          var body = el.querySelector('[data-panel-body]');
          if (!body) { return; }
          var time = state.timeOfDay !== undefined ? _formatTime(state.timeOfDay) : '--:--';
          var weather = state.weather || 'clear';
          var season = state.season || 'spring';
          body.innerHTML = '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div>Time: <span style="color:' + COLORS.accent + '">' + _escapeHtml(time) + '</span></div>' +
            '<div>Weather: <span style="color:' + COLORS.text + '">' + _escapeHtml(weather) + '</span></div>' +
            '<div>Season: <span style="color:' + COLORS.text + '">' + _escapeHtml(season) + '</span></div>' +
            '</div>';
        }
      },
      {
        id: 'player-stats-panel',
        title: 'Player Stats',
        icon: '[@]',
        category: 'info',
        create: function() {
          return createPanel('player-stats-panel', 'Player Stats', '[@]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Player profile, skills, reputation â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {
          if (!state || !state.player) { return; }
          var el = _getElementById('panel-player-stats-panel');
          if (!el) { return; }
          var body = el.querySelector('[data-panel-body]');
          if (!body) { return; }
          var p = state.player;
          body.innerHTML = '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div>Name: <span style="color:' + COLORS.accent + '">' + _escapeHtml(p.name || 'Unknown') + '</span></div>' +
            '<div>Level: <span style="color:' + COLORS.text + '">' + _escapeHtml(String(p.level || 1)) + '</span></div>' +
            '<div>Reputation: <span style="color:' + COLORS.text + '">' + _escapeHtml(String(p.reputation || 0)) + '</span></div>' +
            '</div>';
        }
      },
      {
        id: 'governance-panel',
        title: 'Governance',
        icon: '[^]',
        category: 'info',
        create: function() {
          return createPanel('governance-panel', 'Governance', '[^]',
            '<div style="color:' + COLORS.textMuted + ';font-family:monospace">' +
            '<div style="color:' + COLORS.textDim + ';font-size:11px">[Elections, amendments, stewards â€” loading...]</div>' +
            '</div>');
        },
        update: function(state) {}
      }
    ];

    for (var i = 0; i < defaultPanels.length; i++) {
      registerPanel(defaultPanels[i]);
    }
  }

  // â”€â”€â”€ Zone Render Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _renderZoneList() {
    var html = '<ul style="list-style:none;padding:0;margin:4px 0">';
    for (var zoneId in ZONES) {
      if (Object.prototype.hasOwnProperty.call(ZONES, zoneId)) {
        var zone = ZONES[zoneId];
        var isCurrent = zoneId === _currentZone;
        var color = isCurrent ? COLORS.accent : COLORS.text;
        var prefix = isCurrent ? '[>] ' : '    ';
        html += '<li style="padding:3px 0;color:' + color + ';cursor:pointer;font-family:monospace"' +
          ' data-zone-id="' + _escapeHtml(zoneId) + '">' +
          _escapeHtml(prefix + zone.name) +
          (zone.safe ? '' : ' <span style="color:' + COLORS.warning + '">[!]</span>') +
          '</li>';
      }
    }
    html += '</ul>';
    return html;
  }

  // â”€â”€â”€ Layout Styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _getGridStyle(layout, cols) {
    if (layout === 'minimal') {
      return 'display:grid;grid-template-columns:1fr;gap:8px;padding:8px';
    }
    if (layout === 'compact') {
      return 'display:grid;grid-template-columns:repeat(' + Math.min(cols, 2) + ',1fr);gap:8px;padding:8px';
    }
    // full
    return 'display:grid;grid-template-columns:repeat(' + cols + ',1fr);gap:12px;padding:12px';
  }

  // â”€â”€â”€ Header Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _buildHeader() {
    if (typeof document === 'undefined') { return null; }

    var logoEl = _createElement('div', {
      style: 'font-family:monospace;font-size:18px;font-weight:bold;color:' + COLORS.accent + ';letter-spacing:3px'
    }, 'ZION');

    var playerName = (_gameState && _gameState.player && _gameState.player.name) ? _gameState.player.name : 'Traveler';
    var sparkBalance = (_gameState && _gameState.player && _gameState.player.spark !== undefined) ?
      _gameState.player.spark : 0;
    var zoneName = ZONES[_currentZone] ? ZONES[_currentZone].name : _currentZone;
    var timeStr = (_gameState && _gameState.timeOfDay !== undefined) ? _formatTime(_gameState.timeOfDay) : '12:00';

    var infoEl = _createElement('div', {
      id: 'dashboard-header-info',
      style: 'display:flex;gap:16px;align-items:center;font-family:monospace;font-size:12px'
    }, [
      _createElement('span', {style: 'color:' + COLORS.textMuted}, '[@] ' + _escapeHtml(playerName)),
      _createElement('span', {style: 'color:' + COLORS.accent}, '[$] ' + _escapeHtml(String(sparkBalance))),
      _createElement('span', {style: 'color:' + COLORS.text, id: 'dashboard-zone-display'}, '[>] ' + _escapeHtml(zoneName)),
      _createElement('span', {style: 'color:' + COLORS.textMuted, id: 'dashboard-time-display'}, '[o] ' + _escapeHtml(timeStr))
    ]);

    var headerEl = _createElement('div', {
      id: 'dashboard-header',
      style: [
        'background:' + COLORS.bgHeader,
        'border-bottom:2px solid ' + COLORS.accent,
        'padding:10px 16px',
        'display:flex',
        'align-items:center',
        'justify-content:space-between',
        'flex-shrink:0',
        'z-index:10'
      ].join(';')
    }, [logoEl, infoEl]);

    _headerEl = headerEl;
    return headerEl;
  }

  // â”€â”€â”€ Footer / Nav Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _buildFooter() {
    if (typeof document === 'undefined') { return null; }

    var tabDefs = [
      { id: 'all', label: 'All', icon: '[#]' },
      { id: 'navigation', label: 'Navigate', icon: '[>]' },
      { id: 'social', label: 'Social', icon: '[~]' },
      { id: 'economy', label: 'Economy', icon: '[$]' },
      { id: 'gameplay', label: 'Play', icon: '[*]' },
      { id: 'info', label: 'Info', icon: '[o]' },
      { id: 'minigames', label: 'Games', icon: '[G]' }
    ];

    var tabsEl = _createElement('div', {
      style: 'display:flex;gap:4px;flex-wrap:wrap'
    });

    for (var i = 0; i < tabDefs.length; i++) {
      (function(tabDef) {
        var isActive = tabDef.id === _currentCategory;
        var tabEl = _createElement('button', {
          'data-tab-id': tabDef.id,
          style: [
            'background:' + (isActive ? COLORS.bgTabActive : COLORS.bgTab),
            'border:1px solid ' + (isActive ? COLORS.accent : COLORS.border),
            'color:' + (isActive ? COLORS.accent : COLORS.textMuted),
            'padding:6px 12px',
            'cursor:pointer',
            'font-family:monospace',
            'font-size:12px',
            'border-radius:3px',
            'transition:all 0.15s'
          ].join(';')
        }, _escapeHtml(tabDef.icon + ' ' + tabDef.label));

        tabEl.addEventListener('click', function() {
          _setActiveTab(tabDef.id);
        });

        tabsEl.appendChild(tabEl);
      })(tabDefs[i]);
    }

    var footerEl = _createElement('div', {
      id: 'dashboard-footer',
      style: [
        'background:' + COLORS.bgHeader,
        'border-top:1px solid ' + COLORS.border,
        'padding:8px 12px',
        'flex-shrink:0'
      ].join(';')
    }, tabsEl);

    _footerEl = footerEl;
    return footerEl;
  }

  function _setActiveTab(categoryId) {
    if (CATEGORIES.indexOf(categoryId) === -1) { return; }
    _currentCategory = categoryId;

    // Update tab styles
    if (_footerEl) {
      var tabs = _footerEl.querySelectorAll('[data-tab-id]');
      for (var i = 0; i < tabs.length; i++) {
        var tab = tabs[i];
        var isActive = tab.getAttribute('data-tab-id') === categoryId;
        tab.style.background = isActive ? COLORS.bgTabActive : COLORS.bgTab;
        tab.style.borderColor = isActive ? COLORS.accent : COLORS.border;
        tab.style.color = isActive ? COLORS.accent : COLORS.textMuted;
      }
    }

    // Show/hide panels by category
    _refreshPanelVisibility();
  }

  function _refreshPanelVisibility() {
    if (!_panelGrid) { return; }
    var panelIds = Object.keys(_panelElements);
    for (var i = 0; i < panelIds.length; i++) {
      var id = panelIds[i];
      var panelEl = _panelElements[id];
      if (!panelEl) { continue; }
      var def = _panelRegistry[id];
      var cat = def ? def.category : 'info';
      var inCategory = _currentCategory === 'all' || cat === _currentCategory;
      var isOpen = _panelStates[id] !== false;
      panelEl.style.display = (inCategory && isOpen) ? 'flex' : 'none';
    }
  }

  // â”€â”€â”€ initDashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Initialize the dashboard inside a container element.
   * Called instead of World.initScene when dashboard mode is active.
   * @param {Element} container - DOM element to render the dashboard into
   */
  function initDashboard(container) {
    if (typeof document === 'undefined') {
      // Node.js: just mark as initialized
      _initialized = true;
      if (!container) { container = {}; }
      _container = container;
      _loadSavedState();
      _registerDefaultPanels();
      return true;
    }

    _container = container;

    // Clear any existing content
    container.innerHTML = '';

    // Set container styles
    container.style.cssText = [
      'display:flex',
      'flex-direction:column',
      'height:100%',
      'min-height:100vh',
      'background:' + COLORS.bg,
      'color:' + COLORS.text,
      'font-family:monospace,monospace',
      'overflow:hidden'
    ].join(';');

    // Load saved state
    _loadSavedState();

    // Register default panels
    _registerDefaultPanels();

    // Build structure
    var headerEl = _buildHeader();
    var footerEl = _buildFooter();

    // Main scrollable area
    _mainEl = _createElement('div', {
      id: 'dashboard-main',
      style: 'flex:1;overflow-y:auto;overflow-x:hidden'
    });

    // Panel grid
    var cols = _getColumnCount();
    _panelGrid = _createElement('div', {
      id: 'dashboard-grid',
      style: _getGridStyle(_currentLayout, cols)
    });

    _mainEl.appendChild(_panelGrid);

    container.appendChild(headerEl);
    container.appendChild(_mainEl);
    container.appendChild(footerEl);

    // Render panels
    _renderPanels();

    // Setup keyboard handling
    _setupKeyboardHandlers();

    // Setup resize handler
    if (typeof window !== 'undefined') {
      window.addEventListener('resize', _onResize);
    }

    _initialized = true;
    return true;
  }

  function _renderPanels() {
    if (!_panelGrid) { return; }
    _panelGrid.innerHTML = '';
    _panelElements = {};

    var panels = getPanelsByCategory('all');
    for (var i = 0; i < panels.length; i++) {
      var def = panels[i];
      var el = def.create();
      if (!el) { continue; }
      _panelElements[def.id] = el;
      _panelGrid.appendChild(el);
    }

    _refreshPanelVisibility();
  }

  function _onResize() {
    if (_resizeTimer) { clearTimeout(_resizeTimer); }
    _resizeTimer = setTimeout(function() {
      if (_panelGrid) {
        var cols = _getColumnCount();
        _panelGrid.style.cssText = _getGridStyle(_currentLayout, cols);
      }
    }, 150);
  }

  // â”€â”€â”€ updateDashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Called each tick to update all visible panels with current game state.
   * @param {Object} gameState - Current game state
   * @param {number} deltaTime - Time since last tick (ms)
   */
  function updateDashboard(gameState, deltaTime) {
    _gameState = gameState;

    // Update header info
    _updateHeader(gameState);

    // Update each open panel
    for (var id in _panelRegistry) {
      if (!Object.prototype.hasOwnProperty.call(_panelRegistry, id)) { continue; }
      if (_panelStates[id] === false) { continue; }
      var def = _panelRegistry[id];
      if (def && def.update) {
        try {
          def.update(gameState);
        } catch (e) {
          // Silently skip failed panel updates
        }
      }
    }

    // Process notifications
    _processNotifications();
  }

  function _updateHeader(state) {
    if (!state || typeof document === 'undefined') { return; }

    var infoEl = _getElementById('dashboard-header-info');
    if (!infoEl) { return; }

    var playerName = (state.player && state.player.name) ? state.player.name : 'Traveler';
    var sparkBalance = (state.player && state.player.spark !== undefined) ? state.player.spark : 0;
    var zoneName = ZONES[_currentZone] ? ZONES[_currentZone].name : _currentZone;
    var timeStr = state.timeOfDay !== undefined ? _formatTime(state.timeOfDay) : '12:00';

    infoEl.innerHTML = '';
    infoEl.appendChild(_createElement('span', {style: 'color:' + COLORS.textMuted}, '[@] ' + _escapeHtml(playerName)));
    infoEl.appendChild(_createElement('span', {style: 'color:' + COLORS.accent}, '[$] ' + _escapeHtml(String(sparkBalance))));
    infoEl.appendChild(_createElement('span', {style: 'color:' + COLORS.text, id: 'dashboard-zone-display'}, '[>] ' + _escapeHtml(zoneName)));
    infoEl.appendChild(_createElement('span', {style: 'color:' + COLORS.textMuted, id: 'dashboard-time-display'}, '[o] ' + _escapeHtml(timeStr)));
  }

  function _processNotifications() {
    // Trim notifications older than 5 seconds (at 60fps, ~300 ticks)
    var now = Date.now();
    _notifications = _notifications.filter(function(n) {
      return now - n.ts < 5000;
    });
  }

  // â”€â”€â”€ navigateToZone â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Changes the player's current zone in dashboard mode.
   * @param {string} zoneId - Zone to travel to
   */
  function navigateToZone(zoneId) {
    if (!ZONES[zoneId]) { return false; }
    var prevZone = _currentZone;
    _currentZone = zoneId;

    // Add transition notification
    var zoneName = ZONES[zoneId].name;
    _notifications.push({
      ts: Date.now(),
      type: 'zone_change',
      message: 'Traveling to ' + zoneName + '...',
      from: prevZone,
      to: zoneId
    });

    // Update zone-navigator panel
    var def = _panelRegistry['zone-navigator'];
    if (def && def.update) {
      def.update(_gameState);
    }

    // Update header zone display
    var zoneEl = _getElementById('dashboard-zone-display');
    if (zoneEl) {
      zoneEl.textContent = '[>] ' + zoneName;
    }

    return true;
  }

  // â”€â”€â”€ getDashboardState â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns current dashboard state.
   */
  function getDashboardState() {
    return {
      initialized: _initialized,
      layout: _currentLayout,
      category: _currentCategory,
      zone: _currentZone,
      panelStates: _copyObj(_panelStates),
      panelPositions: _copyObj(_panelPositions),
      openPanels: _getOpenPanelIds(),
      registeredPanels: Object.keys(_panelRegistry)
    };
  }

  function _copyObj(obj) {
    var result = {};
    for (var k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, k)) {
        result[k] = obj[k];
      }
    }
    return result;
  }

  function _getOpenPanelIds() {
    var result = [];
    for (var id in _panelStates) {
      if (Object.prototype.hasOwnProperty.call(_panelStates, id) && _panelStates[id] !== false) {
        result.push(id);
      }
    }
    return result;
  }

  // â”€â”€â”€ setDashboardLayout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Set the dashboard layout.
   * @param {string} layout - 'compact', 'full', or 'minimal'
   */
  function setDashboardLayout(layout) {
    if (LAYOUTS.indexOf(layout) === -1) { return false; }
    _currentLayout = layout;

    if (_panelGrid) {
      var cols = _getColumnCount();
      _panelGrid.style.cssText = _getGridStyle(layout, cols);
    }

    _safeLocalStorage('set', STORAGE_KEY_LAYOUT, layout);
    return true;
  }

  // â”€â”€â”€ showPanel / hidePanel / togglePanel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Show a panel by id.
   */
  function showPanel(panelId) {
    _panelStates[panelId] = true;

    var el = _panelElements[panelId];
    if (el) {
      var def = _panelRegistry[panelId];
      var cat = def ? def.category : 'info';
      var inCategory = _currentCategory === 'all' || cat === _currentCategory;
      el.style.display = inCategory ? 'flex' : 'none';
    } else if (_panelRegistry[panelId] && _panelGrid) {
      // Panel not yet rendered â€” create and add it
      var regDef = _panelRegistry[panelId];
      var newEl = regDef.create();
      if (newEl) {
        _panelElements[panelId] = newEl;
        _panelGrid.appendChild(newEl);
        _refreshPanelVisibility();
      }
    }

    _savePanelStates();
    return true;
  }

  /**
   * Hide a panel by id.
   */
  function hidePanel(panelId) {
    _panelStates[panelId] = false;

    var el = _panelElements[panelId];
    if (el) {
      el.style.display = 'none';
    }

    _savePanelStates();
    return true;
  }

  /**
   * Toggle a panel's visibility.
   */
  function togglePanel(panelId) {
    if (_panelStates[panelId] === false) {
      return showPanel(panelId);
    } else {
      return hidePanel(panelId);
    }
  }

  // â”€â”€â”€ Keyboard Handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _setupKeyboardHandlers() {
    if (typeof document === 'undefined') { return; }
    document.addEventListener('keydown', _handleKeyDown);
  }

  function _handleKeyDown(e) {
    var key = e.key;

    // Check registered handlers first
    if (_keyHandlers[key]) {
      _keyHandlers[key](e);
      return;
    }

    // Default dashboard keyboard shortcuts
    switch (key) {
      case 'Tab':
        e.preventDefault();
        _cycleFocusedPanel(e.shiftKey ? -1 : 1);
        break;
      case 'Escape':
        _closeFocusedPanel();
        break;
      case 'i':
      case 'I':
        togglePanel('inventory-panel');
        break;
      case 'c':
      case 'C':
        togglePanel('social-panel');
        break;
      case 'j':
      case 'J':
        togglePanel('quest-panel');
        break;
      case 'm':
      case 'M':
        togglePanel('world-status-panel');
        break;
      case 'p':
      case 'P':
        togglePanel('player-stats-panel');
        break;
      case 'e':
      case 'E':
        togglePanel('economy-panel');
        break;
      case 'g':
      case 'G':
        togglePanel('governance-panel');
        break;
      default:
        break;
    }
  }

  function _cycleFocusedPanel(direction) {
    var openPanels = _getOpenPanelIds();
    if (openPanels.length === 0) { return; }
    _focusedPanelIndex = (_focusedPanelIndex + direction + openPanels.length) % openPanels.length;
    // Visual focus indicator could be added here
  }

  function _closeFocusedPanel() {
    var openPanels = _getOpenPanelIds();
    if (openPanels.length === 0) { return; }
    var idx = Math.min(_focusedPanelIndex, openPanels.length - 1);
    hidePanel(openPanels[idx]);
  }

  /**
   * Register a custom keyboard handler.
   * @param {string} key - Key string (e.g. 'Enter', 'ArrowUp')
   * @param {Function} handler - Handler function
   */
  function registerKeyHandler(key, handler) {
    _keyHandlers[key] = handler;
  }

  /**
   * Get the current keyboard shortcut map.
   */
  function getKeyboardShortcuts() {
    return {
      'Tab': 'cycle panels forward',
      'Shift+Tab': 'cycle panels backward',
      'Escape': 'close focused panel',
      'i/I': 'toggle inventory',
      'c/C': 'toggle social/chat',
      'j/J': 'toggle quests',
      'm/M': 'toggle world status / map',
      'p/P': 'toggle player stats',
      'e/E': 'toggle economy',
      'g/G': 'toggle governance'
    };
  }

  // â”€â”€â”€ Responsive Breakpoints â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get the current responsive breakpoint name.
   */
  function getBreakpoint() {
    var width = _getScreenWidth();
    if (width < BREAKPOINTS.mobile) { return 'mobile'; }
    if (width < BREAKPOINTS.tablet) { return 'tablet'; }
    return 'desktop';
  }

  // â”€â”€â”€ localStorage Persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _savePanelStates() {
    _safeLocalStorage('set', STORAGE_KEY_PANELS, JSON.stringify(_panelStates));
  }

  function _loadPanelStates() {
    var raw = _safeLocalStorage('get', STORAGE_KEY_PANELS);
    if (!raw) { return {}; }
    try {
      return JSON.parse(raw);
    } catch (e) {
      return {};
    }
  }

  function _savePanelPositions() {
    _safeLocalStorage('set', STORAGE_KEY_POSITIONS, JSON.stringify(_panelPositions));
  }

  function _loadSavedState() {
    // Load layout
    var savedLayout = _safeLocalStorage('get', STORAGE_KEY_LAYOUT);
    if (savedLayout && LAYOUTS.indexOf(savedLayout) !== -1) {
      _currentLayout = savedLayout;
    }

    // Load panel states
    var savedPanelStates = _loadPanelStates();
    for (var id in savedPanelStates) {
      if (Object.prototype.hasOwnProperty.call(savedPanelStates, id)) {
        _panelStates[id] = savedPanelStates[id];
      }
    }

    // Load panel positions
    var rawPositions = _safeLocalStorage('get', STORAGE_KEY_POSITIONS);
    if (rawPositions) {
      try {
        var positions = JSON.parse(rawPositions);
        for (var pid in positions) {
          if (Object.prototype.hasOwnProperty.call(positions, pid)) {
            _panelPositions[pid] = positions[pid];
          }
        }
      } catch (e) {
        // ignore
      }
    }
  }

  /**
   * Save panel position (for draggable panels).
   */
  function savePanelPosition(panelId, x, y) {
    _panelPositions[panelId] = { x: x, y: y };
    _savePanelPositions();
  }

  /**
   * Clear all saved dashboard state from localStorage.
   */
  function clearSavedState() {
    _safeLocalStorage('remove', STORAGE_KEY_LAYOUT);
    _safeLocalStorage('remove', STORAGE_KEY_PANELS);
    _safeLocalStorage('remove', STORAGE_KEY_POSITIONS);
  }

  // â”€â”€â”€ addNotification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Add a notification to the dashboard queue.
   */
  function addNotification(message, type) {
    _notifications.push({
      ts: Date.now(),
      type: type || 'info',
      message: message
    });
  }

  /**
   * Get pending notifications.
   */
  function getNotifications() {
    return _notifications.slice();
  }

  // â”€â”€â”€ Reset (for testing) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Reset internal state. Used for testing.
   */
  function _reset() {
    _container = null;
    _headerEl = null;
    _mainEl = null;
    _footerEl = null;
    _panelGrid = null;
    _currentLayout = 'full';
    _currentCategory = 'all';
    _currentZone = 'nexus';
    _gameState = null;
    _focusedPanelIndex = 0;
    _keyHandlers = {};
    _initialized = false;
    _notifications = [];
    _panelElements = {};
    _panelRegistry = {};
    _panelStates = {};
    _panelPositions = {};
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.isDashboardMode = isDashboardMode;
  exports.initDashboard = initDashboard;
  exports.createPanel = createPanel;
  exports.updateDashboard = updateDashboard;
  exports.navigateToZone = navigateToZone;
  exports.getDashboardState = getDashboardState;
  exports.setDashboardLayout = setDashboardLayout;
  exports.showPanel = showPanel;
  exports.hidePanel = hidePanel;
  exports.togglePanel = togglePanel;
  exports.registerPanel = registerPanel;
  exports.getPanel = getPanel;
  exports.getAllPanels = getAllPanels;
  exports.getPanelsByCategory = getPanelsByCategory;
  exports.registerKeyHandler = registerKeyHandler;
  exports.getKeyboardShortcuts = getKeyboardShortcuts;
  exports.getBreakpoint = getBreakpoint;
  exports.savePanelPosition = savePanelPosition;
  exports.clearSavedState = clearSavedState;
  exports.addNotification = addNotification;
  exports.getNotifications = getNotifications;
  exports.LAYOUTS = LAYOUTS;
  exports.CATEGORIES = CATEGORIES;
  exports.COLORS = COLORS;
  exports.BREAKPOINTS = BREAKPOINTS;
  exports.ZONES = ZONES;
  // Internal helpers exposed for testing
  exports._reset = _reset;
  exports._formatTime = _formatTime;
  exports._getColumnCount = _getColumnCount;
  exports._escapeHtml = _escapeHtml;
  exports._getScreenWidth = _getScreenWidth;

})(typeof module !== 'undefined' ? module.exports : (window.Dashboard = {}));


// dashboard_css.js
// dashboard_css.js
/**
 * dashboard_css.js - CSS styles for ZION dashboard (UI-only) mode
 *
 * Provides all CSS styles for the dashboard interface, injected
 * dynamically into the document head via a <style> element.
 *
 * UMD module: window.DashboardCSS (browser) or module.exports (Node.js)
 * ES5 compatible - uses var declarations
 */
(function(exports) {
  'use strict';

  // â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var STYLE_ELEMENT_ID = 'dashboard-styles';

  var BREAKPOINTS = {
    mobile: 768,
    tablet: 1200,
    desktop: 1920
  };

  // â”€â”€â”€ CSS Stylesheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var LAYOUT_CSS = [
    '/* â•â•â• ZION Dashboard Layout â•â•â• */',
    '',
    '/* Dashboard container - replaces 3D canvas */',
    '.dashboard-container {',
    '  display: grid;',
    '  width: 100%;',
    '  height: 100vh;',
    '  grid-template-rows: auto 1fr auto;',
    '  grid-template-areas: "header" "main" "footer";',
    '  background: #0A0E1A;',
    '  color: #E8E0D8;',
    '  font-family: system-ui, -apple-system, sans-serif;',
    '  overflow: hidden;',
    '}',
    '',
    '/* Header bar */',
    '.dashboard-header {',
    '  grid-area: header;',
    '  display: flex;',
    '  align-items: center;',
    '  justify-content: space-between;',
    '  padding: 8px 16px;',
    '  background: linear-gradient(180deg, rgba(218,165,32,0.15) 0%, rgba(10,14,26,0.95) 100%);',
    '  border-bottom: 1px solid rgba(218,165,32,0.3);',
    '  z-index: 10;',
    '}',
    '',
    '.dashboard-logo {',
    '  font-family: Georgia, "Times New Roman", serif;',
    '  font-size: 1.5rem;',
    '  color: #DAA520;',
    '  letter-spacing: 0.2em;',
    '  font-weight: bold;',
    '}',
    '',
    '.dashboard-player-info {',
    '  display: flex;',
    '  align-items: center;',
    '  gap: 16px;',
    '  font-size: 0.9rem;',
    '}',
    '',
    '.dashboard-spark {',
    '  color: #DAA520;',
    '  font-weight: bold;',
    '}',
    '',
    '.dashboard-zone {',
    '  color: #87CEEB;',
    '}',
    '',
    '.dashboard-time {',
    '  color: #A0978E;',
    '}',
    '',
    '/* Main content area with responsive grid */',
    '.dashboard-main {',
    '  grid-area: main;',
    '  display: grid;',
    '  gap: 12px;',
    '  padding: 12px;',
    '  overflow-y: auto;',
    '  grid-template-columns: repeat(3, 1fr);',
    '}',
    '',
    '/* Tablet */',
    '@media (max-width: 1200px) {',
    '  .dashboard-main {',
    '    grid-template-columns: repeat(2, 1fr);',
    '  }',
    '}',
    '',
    '/* Mobile */',
    '@media (max-width: 768px) {',
    '  .dashboard-main {',
    '    grid-template-columns: 1fr;',
    '    padding: 8px;',
    '    gap: 8px;',
    '  }',
    '  .dashboard-header {',
    '    flex-wrap: wrap;',
    '    gap: 8px;',
    '  }',
    '}',
    '',
    '/* Footer navigation tabs */',
    '.dashboard-footer {',
    '  grid-area: footer;',
    '  display: flex;',
    '  justify-content: center;',
    '  gap: 4px;',
    '  padding: 6px 12px;',
    '  background: rgba(10,14,26,0.95);',
    '  border-top: 1px solid rgba(218,165,32,0.2);',
    '}',
    '',
    '.dashboard-tab {',
    '  padding: 8px 16px;',
    '  border: 1px solid transparent;',
    '  border-radius: 4px 4px 0 0;',
    '  background: transparent;',
    '  color: #A0978E;',
    '  cursor: pointer;',
    '  font-size: 0.85rem;',
    '  transition: all 0.2s ease;',
    '}',
    '',
    '.dashboard-tab:hover {',
    '  color: #E8E0D8;',
    '  background: rgba(218,165,32,0.1);',
    '}',
    '',
    '.dashboard-tab.active {',
    '  color: #DAA520;',
    '  border-color: rgba(218,165,32,0.3);',
    '  border-bottom-color: transparent;',
    '  background: rgba(218,165,32,0.1);',
    '}'
  ].join('\n');

  var PANEL_CSS = [
    '/* â•â•â• Panel Styles â•â•â• */',
    '',
    '/* Individual panel */',
    '.dashboard-panel {',
    '  background: rgba(15,12,20,0.9);',
    '  border: 1px solid rgba(218,165,32,0.25);',
    '  border-radius: 8px;',
    '  display: flex;',
    '  flex-direction: column;',
    '  max-height: 80vh;',
    '  overflow: hidden;',
    '  transition: border-color 0.2s ease;',
    '}',
    '',
    '.dashboard-panel:hover {',
    '  border-color: rgba(218,165,32,0.5);',
    '}',
    '',
    '.dashboard-panel.focused {',
    '  border-color: #DAA520;',
    '  box-shadow: 0 0 20px rgba(218,165,32,0.15);',
    '}',
    '',
    '.dashboard-panel-header {',
    '  display: flex;',
    '  align-items: center;',
    '  justify-content: space-between;',
    '  padding: 10px 14px;',
    '  background: rgba(218,165,32,0.08);',
    '  border-bottom: 1px solid rgba(218,165,32,0.15);',
    '  cursor: pointer;',
    '  user-select: none;',
    '}',
    '',
    '.dashboard-panel-title {',
    '  font-family: Georgia, "Times New Roman", serif;',
    '  font-size: 0.95rem;',
    '  color: #DAA520;',
    '  letter-spacing: 0.05em;',
    '}',
    '',
    '.dashboard-panel-controls {',
    '  display: flex;',
    '  gap: 8px;',
    '}',
    '',
    '.dashboard-panel-btn {',
    '  background: none;',
    '  border: none;',
    '  color: #A0978E;',
    '  cursor: pointer;',
    '  font-size: 0.8rem;',
    '  padding: 2px 6px;',
    '  border-radius: 3px;',
    '  transition: color 0.2s ease, background 0.2s ease;',
    '}',
    '',
    '.dashboard-panel-btn:hover {',
    '  color: #DAA520;',
    '  background: rgba(218,165,32,0.15);',
    '}',
    '',
    '.dashboard-panel-body {',
    '  flex: 1;',
    '  padding: 12px 14px;',
    '  overflow-y: auto;',
    '  font-size: 0.85rem;',
    '  line-height: 1.5;',
    '}',
    '',
    '.dashboard-panel.collapsed .dashboard-panel-body {',
    '  display: none;',
    '}',
    '',
    '.dashboard-panel.fullscreen {',
    '  position: fixed;',
    '  top: 0;',
    '  left: 0;',
    '  width: 100%;',
    '  height: 100%;',
    '  max-height: 100vh;',
    '  z-index: 1000;',
    '  border-radius: 0;',
    '  border: none;',
    '}'
  ].join('\n');

  var TABS_CSS = [
    '/* â•â•â• Tab System (within panels) â•â•â• */',
    '',
    '.panel-tabs {',
    '  display: flex;',
    '  gap: 2px;',
    '  padding: 0 14px;',
    '  background: rgba(0,0,0,0.2);',
    '  border-bottom: 1px solid rgba(218,165,32,0.1);',
    '}',
    '',
    '.panel-tab {',
    '  padding: 6px 12px;',
    '  border: none;',
    '  background: transparent;',
    '  color: #A0978E;',
    '  cursor: pointer;',
    '  font-size: 0.8rem;',
    '  border-bottom: 2px solid transparent;',
    '  transition: all 0.2s ease;',
    '}',
    '',
    '.panel-tab:hover {',
    '  color: #E8E0D8;',
    '}',
    '',
    '.panel-tab.active {',
    '  color: #DAA520;',
    '  border-bottom-color: #DAA520;',
    '}',
    '',
    '.panel-tab-content {',
    '  display: none;',
    '}',
    '',
    '.panel-tab-content.active {',
    '  display: block;',
    '}'
  ].join('\n');

  var COMMON_CSS = [
    '/* â•â•â• Common UI Elements â•â•â• */',
    '',
    '/* Buttons */',
    '.dash-btn {',
    '  padding: 6px 12px;',
    '  border: 1px solid rgba(218,165,32,0.4);',
    '  border-radius: 4px;',
    '  background: rgba(218,165,32,0.1);',
    '  color: #DAA520;',
    '  cursor: pointer;',
    '  font-size: 0.8rem;',
    '  transition: all 0.2s ease;',
    '}',
    '',
    '.dash-btn:hover {',
    '  background: rgba(218,165,32,0.25);',
    '  border-color: #DAA520;',
    '}',
    '',
    '.dash-btn:disabled {',
    '  opacity: 0.4;',
    '  cursor: not-allowed;',
    '}',
    '',
    '.dash-btn-primary {',
    '  background: rgba(218,165,32,0.3);',
    '  border-color: #DAA520;',
    '}',
    '',
    '.dash-btn-danger {',
    '  border-color: rgba(239,83,80,0.5);',
    '  color: #EF5350;',
    '  background: rgba(239,83,80,0.1);',
    '}',
    '',
    '/* Input fields */',
    '.dash-input {',
    '  padding: 6px 10px;',
    '  border: 1px solid rgba(218,165,32,0.25);',
    '  border-radius: 4px;',
    '  background: rgba(0,0,0,0.3);',
    '  color: #E8E0D8;',
    '  font-size: 0.85rem;',
    '  transition: border-color 0.2s ease;',
    '}',
    '',
    '.dash-input:focus {',
    '  outline: none;',
    '  border-color: #DAA520;',
    '}',
    '',
    '.dash-input::placeholder {',
    '  color: #5A5248;',
    '}',
    '',
    '/* Select dropdowns */',
    '.dash-select {',
    '  padding: 6px 10px;',
    '  border: 1px solid rgba(218,165,32,0.25);',
    '  border-radius: 4px;',
    '  background: rgba(0,0,0,0.3);',
    '  color: #E8E0D8;',
    '  font-size: 0.85rem;',
    '}',
    '',
    '/* Progress bars */',
    '.dash-progress {',
    '  height: 6px;',
    '  background: rgba(255,255,255,0.08);',
    '  border-radius: 3px;',
    '  overflow: hidden;',
    '}',
    '',
    '.dash-progress-fill {',
    '  height: 100%;',
    '  border-radius: 3px;',
    '  transition: width 0.3s ease;',
    '}',
    '',
    '.dash-progress-fill.gold { background: linear-gradient(90deg, #DAA520, #F4A460); }',
    '.dash-progress-fill.green { background: linear-gradient(90deg, #4CAF50, #8BC34A); }',
    '.dash-progress-fill.blue { background: linear-gradient(90deg, #2196F3, #03A9F4); }',
    '.dash-progress-fill.red { background: linear-gradient(90deg, #EF5350, #FF7043); }',
    '.dash-progress-fill.purple { background: linear-gradient(90deg, #9C27B0, #BA68C8); }',
    '',
    '/* Rarity borders */',
    '.rarity-common { border-color: #cccccc; }',
    '.rarity-uncommon { border-color: #2ecc71; }',
    '.rarity-rare { border-color: #3498db; }',
    '.rarity-epic { border-color: #9b59b6; }',
    '.rarity-legendary { border-color: #f39c12; }',
    '',
    '/* Item grid */',
    '.item-grid {',
    '  display: grid;',
    '  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));',
    '  gap: 6px;',
    '}',
    '',
    '.item-slot {',
    '  aspect-ratio: 1;',
    '  border: 1px solid rgba(255,255,255,0.1);',
    '  border-radius: 4px;',
    '  display: flex;',
    '  flex-direction: column;',
    '  align-items: center;',
    '  justify-content: center;',
    '  padding: 4px;',
    '  cursor: pointer;',
    '  transition: all 0.2s ease;',
    '  font-size: 0.75rem;',
    '  position: relative;',
    '}',
    '',
    '.item-slot:hover {',
    '  background: rgba(218,165,32,0.1);',
    '  border-color: rgba(218,165,32,0.4);',
    '}',
    '',
    '.item-slot.selected {',
    '  border-color: #DAA520;',
    '  background: rgba(218,165,32,0.15);',
    '}',
    '',
    '.item-slot .item-count {',
    '  position: absolute;',
    '  bottom: 2px;',
    '  right: 4px;',
    '  font-size: 0.65rem;',
    '  color: #DAA520;',
    '}',
    '',
    '/* List rows */',
    '.dash-row {',
    '  display: flex;',
    '  align-items: center;',
    '  padding: 8px 10px;',
    '  border-bottom: 1px solid rgba(255,255,255,0.05);',
    '  transition: background 0.15s ease;',
    '}',
    '',
    '.dash-row:hover {',
    '  background: rgba(218,165,32,0.05);',
    '}',
    '',
    '.dash-row:last-child {',
    '  border-bottom: none;',
    '}',
    '',
    '/* Badges and tags */',
    '.dash-badge {',
    '  display: inline-block;',
    '  padding: 2px 8px;',
    '  border-radius: 10px;',
    '  font-size: 0.7rem;',
    '  font-weight: 600;',
    '}',
    '',
    '.dash-badge-gold { background: rgba(218,165,32,0.2); color: #DAA520; }',
    '.dash-badge-green { background: rgba(76,175,80,0.2); color: #4CAF50; }',
    '.dash-badge-blue { background: rgba(33,150,243,0.2); color: #2196F3; }',
    '.dash-badge-red { background: rgba(239,83,80,0.2); color: #EF5350; }',
    '.dash-badge-purple { background: rgba(156,39,176,0.2); color: #BA68C8; }',
    '',
    '/* Chat styles */',
    '.chat-message-row {',
    '  padding: 3px 0;',
    '  font-size: 0.82rem;',
    '  line-height: 1.4;',
    '}',
    '',
    '.chat-timestamp {',
    '  color: #5A5248;',
    '  font-size: 0.75rem;',
    '}',
    '',
    '.chat-sender {',
    '  color: #87CEEB;',
    '  font-weight: 600;',
    '}',
    '',
    '.chat-system {',
    '  color: #DAA520;',
    '  font-style: italic;',
    '}',
    '',
    '.chat-whisper {',
    '  color: #BA68C8;',
    '}',
    '',
    '/* ASCII art / game display */',
    '.game-display {',
    '  font-family: "Courier New", monospace;',
    '  background: rgba(0,0,0,0.4);',
    '  border: 1px solid rgba(218,165,32,0.15);',
    '  border-radius: 4px;',
    '  padding: 12px;',
    '  white-space: pre;',
    '  overflow-x: auto;',
    '  font-size: 0.8rem;',
    '  line-height: 1.3;',
    '}',
    '',
    '/* Tooltip */',
    '.dash-tooltip {',
    '  position: absolute;',
    '  background: rgba(10,14,26,0.95);',
    '  border: 1px solid rgba(218,165,32,0.4);',
    '  border-radius: 4px;',
    '  padding: 8px 12px;',
    '  font-size: 0.8rem;',
    '  max-width: 250px;',
    '  z-index: 2000;',
    '  pointer-events: none;',
    '  box-shadow: 0 4px 12px rgba(0,0,0,0.5);',
    '}',
    '',
    '.dash-tooltip-title {',
    '  color: #DAA520;',
    '  font-weight: 600;',
    '  margin-bottom: 4px;',
    '}',
    '',
    '.dash-tooltip-desc {',
    '  color: #A0978E;',
    '  font-size: 0.75rem;',
    '}',
    '',
    '/* Scrollbar styling */',
    '.dashboard-container ::-webkit-scrollbar {',
    '  width: 5px;',
    '}',
    '',
    '.dashboard-container ::-webkit-scrollbar-track {',
    '  background: transparent;',
    '}',
    '',
    '.dashboard-container ::-webkit-scrollbar-thumb {',
    '  background: rgba(218,165,32,0.25);',
    '  border-radius: 3px;',
    '}',
    '',
    '.dashboard-container ::-webkit-scrollbar-thumb:hover {',
    '  background: rgba(218,165,32,0.45);',
    '}',
    '',
    '/* Notification toast for dashboard */',
    '.dash-toast {',
    '  position: fixed;',
    '  top: 60px;',
    '  right: 16px;',
    '  background: rgba(15,12,20,0.95);',
    '  border: 1px solid rgba(218,165,32,0.4);',
    '  border-radius: 6px;',
    '  padding: 12px 16px;',
    '  max-width: 320px;',
    '  z-index: 3000;',
    '  animation: dashToastIn 0.3s ease;',
    '}',
    '',
    '@keyframes dashToastIn {',
    '  from { opacity: 0; transform: translateX(20px); }',
    '  to { opacity: 1; transform: translateX(0); }',
    '}',
    '',
    '/* Loading spinner */',
    '.dash-spinner {',
    '  display: inline-block;',
    '  width: 16px;',
    '  height: 16px;',
    '  border: 2px solid rgba(218,165,32,0.2);',
    '  border-top-color: #DAA520;',
    '  border-radius: 50%;',
    '  animation: dashSpin 0.8s linear infinite;',
    '}',
    '',
    '@keyframes dashSpin {',
    '  to { transform: rotate(360deg); }',
    '}',
    '',
    '/* Empty state */',
    '.dash-empty {',
    '  text-align: center;',
    '  padding: 24px;',
    '  color: #5A5248;',
    '  font-style: italic;',
    '}',
    '',
    '/* Divider */',
    '.dash-divider {',
    '  height: 1px;',
    '  background: rgba(218,165,32,0.15);',
    '  margin: 8px 0;',
    '}',
    '',
    '/* Zone colors for badges */',
    '.zone-nexus { border-left: 3px solid #8888cc; }',
    '.zone-gardens { border-left: 3px solid #4caf50; }',
    '.zone-athenaeum { border-left: 3px solid #795548; }',
    '.zone-studio { border-left: 3px solid #ff9800; }',
    '.zone-wilds { border-left: 3px solid #2e7d32; }',
    '.zone-agora { border-left: 3px solid #ffd700; }',
    '.zone-commons { border-left: 3px solid #faf0e6; }',
    '.zone-arena { border-left: 3px solid #d2691e; }'
  ].join('\n');

  var ANIMATION_CSS = [
    '/* â•â•â• Animation States â•â•â• */',
    '',
    '/* Panel transitions */',
    '.dashboard-panel-enter {',
    '  animation: panelFadeIn 0.3s ease;',
    '}',
    '',
    '@keyframes panelFadeIn {',
    '  from { opacity: 0; transform: translateY(10px); }',
    '  to { opacity: 1; transform: translateY(0); }',
    '}',
    '',
    '.dashboard-panel-exit {',
    '  animation: panelFadeOut 0.2s ease;',
    '}',
    '',
    '@keyframes panelFadeOut {',
    '  from { opacity: 1; }',
    '  to { opacity: 0; transform: translateY(-10px); }',
    '}',
    '',
    '/* Zone transition text */',
    '.zone-transition-overlay {',
    '  position: fixed;',
    '  top: 0;',
    '  left: 0;',
    '  right: 0;',
    '  bottom: 0;',
    '  display: flex;',
    '  align-items: center;',
    '  justify-content: center;',
    '  background: rgba(10,14,26,0.8);',
    '  z-index: 5000;',
    '  animation: zoneFade 1.5s ease-in-out;',
    '}',
    '',
    '@keyframes zoneFade {',
    '  0% { opacity: 0; }',
    '  30% { opacity: 1; }',
    '  70% { opacity: 1; }',
    '  100% { opacity: 0; }',
    '}'
  ].join('\n');

  // â”€â”€â”€ Full Stylesheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns the complete CSS string.
   * Safe to call in Node.js (no DOM required).
   * @returns {string}
   */
  function getStylesheet() {
    return [
      LAYOUT_CSS,
      '',
      PANEL_CSS,
      '',
      TABS_CSS,
      '',
      COMMON_CSS,
      '',
      ANIMATION_CSS
    ].join('\n');
  }

  /**
   * Returns responsive breakpoint pixel values.
   * @returns {{ mobile: number, tablet: number, desktop: number }}
   */
  function getBreakpoints() {
    return {
      mobile: BREAKPOINTS.mobile,
      tablet: BREAKPOINTS.tablet,
      desktop: BREAKPOINTS.desktop
    };
  }

  /**
   * Injects all dashboard CSS into the document head.
   * Idempotent â€” does nothing if styles are already injected.
   * @returns {HTMLStyleElement} the style element
   */
  function injectStyles() {
    if (typeof document === 'undefined') {
      throw new Error('injectStyles() requires a DOM environment');
    }

    var existing = document.getElementById(STYLE_ELEMENT_ID);
    if (existing) {
      return existing;
    }

    var style = document.createElement('style');
    style.id = STYLE_ELEMENT_ID;
    style.textContent = getStylesheet();
    document.head.appendChild(style);
    return style;
  }

  /**
   * Removes the injected dashboard style element (if present).
   */
  function removeStyles() {
    if (typeof document === 'undefined') {
      return;
    }
    var el = document.getElementById(STYLE_ELEMENT_ID);
    if (el && el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.injectStyles = injectStyles;
  exports.removeStyles = removeStyles;
  exports.getStylesheet = getStylesheet;
  exports.getBreakpoints = getBreakpoints;

  // Internal constants exposed for testing
  exports.STYLE_ELEMENT_ID = STYLE_ELEMENT_ID;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardCSS = {}));


// dashboard_zones.js
// dashboard_zones.js
/**
 * dashboard_zones.js â€” Zone Navigator panel for ZION dashboard (UI-only) mode
 * Provides zone browsing, details, and simulated travel without 3D rendering.
 * Layer: UI-only, no 3D dependency
 */
(function(exports) {
  'use strict';

  // â”€â”€â”€ Zone Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var ZONE_INFO = {
    nexus: {
      id: 'nexus',
      name: 'The Nexus',
      desc: 'Central hub where all paths converge. A place of meeting and new beginnings.',
      cx: 0,
      cz: 0,
      radius: 60,
      terrain: 'Stone plaza with glowing runes',
      npcs: ['Herald', 'Guide', 'Merchant']
    },
    gardens: {
      id: 'gardens',
      name: 'The Gardens',
      desc: 'Lush terraced gardens where communities grow food and tend the earth together.',
      cx: 200,
      cz: 30,
      radius: 80,
      terrain: 'Rolling green hills, flower beds, orchards',
      npcs: ['Gardener', 'Herbalist', 'Beekeeper']
    },
    athenaeum: {
      id: 'athenaeum',
      name: 'The Athenaeum',
      desc: 'A vast open-air library and school. Knowledge is freely shared here.',
      cx: 100,
      cz: -220,
      radius: 60,
      terrain: 'Sandstone shelves, reading alcoves, fountains',
      npcs: ['Librarian', 'Scholar', 'Teacher']
    },
    studio: {
      id: 'studio',
      name: 'The Studio',
      desc: 'Creative workshops where art, music, and craft flourish.',
      cx: -200,
      cz: -100,
      radius: 60,
      terrain: 'Colorful workshops, kilns, stages',
      npcs: ['Artist', 'Musician', 'Sculptor']
    },
    wilds: {
      id: 'wilds',
      name: 'The Wilds',
      desc: 'Untamed wilderness stretching beyond the settled zones. Adventure awaits.',
      cx: -30,
      cz: 260,
      radius: 90,
      terrain: 'Dense forest, rivers, caves, cliffs',
      npcs: ['Ranger', 'Explorer', 'Hermit']
    },
    agora: {
      id: 'agora',
      name: 'The Agora',
      desc: 'The marketplace and civic center. Trade, debate, and governance happen here.',
      cx: -190,
      cz: 120,
      radius: 55,
      terrain: 'Market stalls, amphitheater, council hall',
      npcs: ['Merchant', 'Politician', 'Auctioneer']
    },
    commons: {
      id: 'commons',
      name: 'The Commons',
      desc: 'Open gathering grounds for festivals, games, and community events.',
      cx: 170,
      cz: 190,
      radius: 55,
      terrain: 'Open fields, pavilions, campfire circles',
      npcs: ['Storyteller', 'Cook', 'Musician']
    },
    arena: {
      id: 'arena',
      name: 'The Arena',
      desc: 'Competitive grounds where citizens test their skills in fair contest.',
      cx: 0,
      cz: -240,
      radius: 55,
      terrain: 'Sand pit, spectator stands, trophy hall',
      npcs: ['Champion', 'Trainer', 'Referee']
    }
  };

  // Order used for grid layout
  var ZONE_IDS = ['nexus', 'gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena'];

  // â”€â”€â”€ Distance & Cost â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Calculate Euclidean distance between two zone centers.
   * @param {string} fromZone  - zone id
   * @param {string} toZone    - zone id
   * @returns {number}
   */
  function getZoneDistance(fromZone, toZone) {
    var a = ZONE_INFO[fromZone];
    var b = ZONE_INFO[toZone];
    if (!a || !b) return 0;
    var dx = a.cx - b.cx;
    var dz = a.cz - b.cz;
    return Math.sqrt(dx * dx + dz * dz);
  }

  /**
   * Calculate Spark travel cost between two zones.
   * Cost = Math.ceil(distance / 100), minimum 1.
   * Same-zone cost is 0.
   * @param {string} fromZone
   * @param {string} toZone
   * @returns {number}
   */
  function getTravelCost(fromZone, toZone) {
    if (fromZone === toZone) return 0;
    var dist = getZoneDistance(fromZone, toZone);
    return Math.max(1, Math.ceil(dist / 100));
  }

  // â”€â”€â”€ Zone Data Accessors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns full zone info object, or null if not found.
   * @param {string} zoneId
   * @returns {Object|null}
   */
  function getZoneDetails(zoneId) {
    return ZONE_INFO[zoneId] || null;
  }

  /**
   * Returns list of NPC types in a zone.
   * @param {string} zoneId
   * @returns {Array}
   */
  function getZoneNPCs(zoneId) {
    var z = ZONE_INFO[zoneId];
    if (!z) return [];
    return z.npcs.slice();
  }

  /**
   * Returns a text summary for a zone.
   * Example: "The Gardens â€” 3 NPCs, Sunny, 2 active events, 145 units away"
   * @param {string} zoneId
   * @param {Object} gameState  - optional; may have currentZone, weather, events
   * @returns {string}
   */
  function getZoneSummary(zoneId, gameState) {
    var z = ZONE_INFO[zoneId];
    if (!z) return 'Unknown zone';

    var parts = [z.name];
    var npcCount = z.npcs.length;
    parts.push(npcCount + ' NPCs');

    var weather = 'Clear';
    var eventCount = 0;
    var distStr = '';

    if (gameState) {
      if (gameState.weather && gameState.weather[zoneId]) {
        weather = gameState.weather[zoneId];
      } else if (gameState.weather && typeof gameState.weather === 'string') {
        weather = gameState.weather;
      }

      if (gameState.events && Array.isArray(gameState.events)) {
        for (var i = 0; i < gameState.events.length; i++) {
          if (gameState.events[i].zone === zoneId) eventCount++;
        }
      }

      if (gameState.currentZone && gameState.currentZone !== zoneId) {
        var dist = Math.round(getZoneDistance(gameState.currentZone, zoneId));
        distStr = dist + ' units away';
      } else if (gameState.currentZone === zoneId) {
        distStr = 'current location';
      }
    }

    parts.push(weather);
    parts.push(eventCount + ' active events');
    if (distStr) parts.push(distStr);

    return parts.join(', ');
  }

  /**
   * Returns all zones sorted by the given criterion.
   * sortBy: 'distance' (default, nearest first), 'name', 'alphabetical'
   * @param {string} currentZone
   * @param {string} sortBy
   * @returns {Array} array of zone info objects with added distance/cost
   */
  function getAllZonesSorted(currentZone, sortBy) {
    var sorted = ZONE_IDS.map(function(id) {
      var z = ZONE_INFO[id];
      var dist = getZoneDistance(currentZone, id);
      return {
        id: id,
        name: z.name,
        desc: z.desc,
        cx: z.cx,
        cz: z.cz,
        radius: z.radius,
        terrain: z.terrain,
        npcs: z.npcs.slice(),
        distance: Math.round(dist),
        cost: getTravelCost(currentZone, id)
      };
    });

    var criterion = sortBy || 'distance';

    if (criterion === 'distance') {
      sorted.sort(function(a, b) { return a.distance - b.distance; });
    } else if (criterion === 'name' || criterion === 'alphabetical') {
      sorted.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });
    }

    return sorted;
  }

  // â”€â”€â”€ ASCII Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Renders a text-based ASCII map of all zones.
   * Positions are derived from the zone cx/cz coordinates mapped to a fixed grid.
   * @param {string} currentZone  - zone id to highlight
   * @returns {string}  multi-line string
   */
  function renderAsciiMap(currentZone) {
    // Grid dimensions
    var COLS = 56;
    var ROWS = 14;

    // Initialise a blank grid
    var grid = [];
    var r, c;
    for (r = 0; r < ROWS; r++) {
      var row = [];
      for (c = 0; c < COLS; c++) {
        row.push(' ');
      }
      grid.push(row);
    }

    // World extents used for mapping (cx: -250..250, cz: -290..300)
    var CX_MIN = -260;
    var CX_MAX = 260;
    var CZ_MIN = -290;
    var CZ_MAX = 310;

    // Abbreviations for the map (6 chars wide + brackets = 8 chars)
    var ABBREV = {
      nexus:     'NEXUS ',
      gardens:   'GARDNS',
      athenaeum: 'ATHNM ',
      studio:    'STUDIO',
      wilds:     'WILDS ',
      agora:     'AGORA ',
      commons:   'COMONS',
      arena:     'ARENA '
    };

    function worldToGrid(cx, cz) {
      // Map cx -> col, cz -> row (note: higher cz = further "down" in world but up on screen)
      var col = Math.round(((cx - CX_MIN) / (CX_MAX - CX_MIN)) * (COLS - 10));
      var row = Math.round(((CZ_MAX - cz) / (CZ_MAX - CZ_MIN)) * (ROWS - 2));
      // Clamp
      col = Math.max(0, Math.min(COLS - 9, col));
      row = Math.max(0, Math.min(ROWS - 2, row));
      return { col: col, row: row };
    }

    // Place zone labels
    for (var zid in ZONE_INFO) {
      var z = ZONE_INFO[zid];
      var pos = worldToGrid(z.cx, z.cz);
      var abbr = ABBREV[zid] || zid.toUpperCase().substring(0, 6);
      var isCurrent = (zid === currentZone);
      var label = isCurrent ? ('[' + abbr + ']') : (' ' + abbr + ' ');
      // label is 8 chars
      for (var ch = 0; ch < label.length && (pos.col + ch) < COLS; ch++) {
        grid[pos.row][pos.col + ch] = label[ch];
      }
    }

    // Build header/footer border
    var border = '+' + repeat('-', COLS) + '+';
    var lines = [border];
    for (r = 0; r < ROWS; r++) {
      lines.push('|' + grid[r].join('') + '|');
    }
    lines.push(border);

    // Legend
    lines.push('');
    lines.push('  [ZONE] = current zone   ZONE  = other zone');

    return lines.join('\n');
  }

  function repeat(ch, n) {
    var s = '';
    for (var i = 0; i < n; i++) s += ch;
    return s;
  }

  // â”€â”€â”€ HTML Formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns HTML string for a zone card.
   * @param {string} zoneId
   * @param {string} currentZone
   * @param {Object} gameState  - optional
   * @returns {string}
   */
  function formatZoneCard(zoneId, currentZone, gameState) {
    var z = ZONE_INFO[zoneId];
    if (!z) return '';

    var isCurrent = (zoneId === currentZone);
    var dist = Math.round(getZoneDistance(currentZone, zoneId));
    var cost = getTravelCost(currentZone, zoneId);

    var weather = 'Clear';
    var eventCount = 0;

    if (gameState) {
      if (gameState.weather && gameState.weather[zoneId]) {
        weather = gameState.weather[zoneId];
      } else if (gameState.weather && typeof gameState.weather === 'string') {
        weather = gameState.weather;
      }
      if (gameState.events && Array.isArray(gameState.events)) {
        for (var i = 0; i < gameState.events.length; i++) {
          if (gameState.events[i].zone === zoneId) eventCount++;
        }
      }
    }

    var cardClass = 'dz-zone-card' + (isCurrent ? ' dz-zone-card--current' : '');
    var npcList = z.npcs.join(', ');
    var travelBtn = isCurrent
      ? '<span class="dz-btn dz-btn--disabled">[*] Here</span>'
      : '<button class="dz-btn dz-btn--travel" data-zone="' + zoneId + '">[>] Travel (' + cost + ' Spark)</button>';

    var distLabel = isCurrent
      ? '<span class="dz-current-label">[*] Current Location</span>'
      : '<span class="dz-distance">' + dist + ' units away</span>';

    var eventsStr = eventCount > 0
      ? '<span class="dz-events">[+] ' + eventCount + ' active event' + (eventCount !== 1 ? 's' : '') + '</span>'
      : '<span class="dz-events dz-events--none">[-] No active events</span>';

    return (
      '<div class="' + cardClass + '" data-zone-id="' + zoneId + '">' +
        '<div class="dz-zone-header">' +
          '<span class="dz-zone-name">' + escapeHtml(z.name) + '</span>' +
          distLabel +
        '</div>' +
        '<p class="dz-zone-desc">' + escapeHtml(z.desc) + '</p>' +
        '<div class="dz-zone-meta">' +
          '<span class="dz-terrain">[~] ' + escapeHtml(z.terrain) + '</span>' +
          '<span class="dz-npcs">[&] NPCs: ' + escapeHtml(npcList) + '</span>' +
          '<span class="dz-weather">[W] ' + escapeHtml(weather) + '</span>' +
          eventsStr +
        '</div>' +
        '<div class="dz-zone-actions">' +
          travelBtn +
        '</div>' +
      '</div>'
    );
  }

  function escapeHtml(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  // â”€â”€â”€ DOM Panel Construction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates and returns the Zone Navigator DOM element.
   * Works in both browser (document available) and test (document mock) contexts.
   * @returns {Element}
   */
  function createZoneNavigator() {
    var container = _createElement('div');
    container.className = 'dz-zone-navigator';
    container.setAttribute('role', 'region');
    container.setAttribute('aria-label', 'Zone Navigator');

    // â”€â”€ Header â”€â”€
    var header = _createElement('div');
    header.className = 'dz-nav-header';
    header.innerHTML = '<h2 class="dz-nav-title">Zone Navigator</h2>' +
      '<span class="dz-nav-subtitle">Browse and travel between zones</span>';
    container.appendChild(header);

    // â”€â”€ ASCII Map â”€â”€
    var mapSection = _createElement('div');
    mapSection.className = 'dz-map-section';

    var mapLabel = _createElement('div');
    mapLabel.className = 'dz-map-label';
    mapLabel.textContent = 'World Map';
    mapSection.appendChild(mapLabel);

    var mapPre = _createElement('pre');
    mapPre.className = 'dz-ascii-map';
    mapPre.textContent = renderAsciiMap('nexus');
    mapSection.appendChild(mapPre);
    container.appendChild(mapSection);

    // â”€â”€ Sort Controls â”€â”€
    var controls = _createElement('div');
    controls.className = 'dz-controls';

    var sortLabel = _createElement('span');
    sortLabel.className = 'dz-sort-label';
    sortLabel.textContent = 'Sort: ';
    controls.appendChild(sortLabel);

    var sortOptions = [
      { value: 'distance', label: 'By Distance' },
      { value: 'name',     label: 'By Name'     }
    ];
    for (var si = 0; si < sortOptions.length; si++) {
      var btn = _createElement('button');
      btn.className = 'dz-sort-btn' + (si === 0 ? ' dz-sort-btn--active' : '');
      btn.setAttribute('data-sort', sortOptions[si].value);
      btn.textContent = sortOptions[si].label;
      controls.appendChild(btn);
    }
    container.appendChild(controls);

    // â”€â”€ Zone Cards List â”€â”€
    var cardList = _createElement('div');
    cardList.className = 'dz-zone-list';
    cardList.setAttribute('data-current-zone', 'nexus');

    var defaultZones = getAllZonesSorted('nexus', 'distance');
    for (var zi = 0; zi < defaultZones.length; zi++) {
      var cardHtml = formatZoneCard(defaultZones[zi].id, 'nexus', null);
      var wrapper = _createElement('div');
      wrapper.innerHTML = cardHtml;
      if (wrapper.firstChild) {
        cardList.appendChild(wrapper.firstChild);
      }
    }
    container.appendChild(cardList);

    // â”€â”€ Inject Styles â”€â”€
    _injectStyles();

    return container;
  }

  /**
   * Updates the Zone Navigator panel with current game state.
   * @param {Element} panel      - the element returned by createZoneNavigator()
   * @param {Object}  state      - game state: { currentZone, weather, events, ... }
   */
  function updateZoneNavigator(panel, state) {
    if (!panel || !state) return;

    var currentZone = (state.currentZone && ZONE_INFO[state.currentZone])
      ? state.currentZone
      : 'nexus';

    // Update ASCII map
    var mapEl = panel.querySelector ? panel.querySelector('.dz-ascii-map') : null;
    if (mapEl) {
      mapEl.textContent = renderAsciiMap(currentZone);
    }

    // Update card list
    var cardList = panel.querySelector ? panel.querySelector('.dz-zone-list') : null;
    if (cardList) {
      cardList.setAttribute('data-current-zone', currentZone);

      // Determine current sort
      var activeSortBtn = panel.querySelector ? panel.querySelector('.dz-sort-btn--active') : null;
      var sortBy = activeSortBtn ? (activeSortBtn.getAttribute('data-sort') || 'distance') : 'distance';

      var zones = getAllZonesSorted(currentZone, sortBy);
      // Clear existing cards
      while (cardList.firstChild) {
        cardList.removeChild(cardList.firstChild);
      }
      // Re-render
      for (var zi = 0; zi < zones.length; zi++) {
        var cardHtml = formatZoneCard(zones[zi].id, currentZone, state);
        var wrapper = _createElement('div');
        wrapper.innerHTML = cardHtml;
        if (wrapper.firstChild) {
          cardList.appendChild(wrapper.firstChild);
        }
      }
    }
  }

  // â”€â”€â”€ DOM helpers (work in Node.js without jsdom) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _createElement(tag) {
    // Browser
    if (typeof document !== 'undefined') {
      return document.createElement(tag);
    }
    // Minimal Node.js mock element
    return _mockElement(tag);
  }

  function _mockElement(tag) {
    var el = {
      _tag: tag,
      _children: [],
      _attrs: {},
      className: '',
      textContent: '',
      firstChild: null,
      style: {},
      querySelector: function(sel) {
        return _mockQuerySelector(el, sel);
      },
      querySelectorAll: function(sel) {
        return _mockQuerySelectorAll(el, sel);
      },
      getAttribute: function(name) {
        return el._attrs[name] !== undefined ? el._attrs[name] : null;
      },
      setAttribute: function(name, value) {
        el._attrs[name] = String(value);
      },
      appendChild: function(child) {
        el._children.push(child);
        el.firstChild = el._children[0] || null;
        return child;
      },
      removeChild: function(child) {
        var idx = el._children.indexOf(child);
        if (idx !== -1) el._children.splice(idx, 1);
        el.firstChild = el._children[0] || null;
      }
    };

    // innerHTML setter: parse the HTML string and populate _children with mock elements
    // so that firstChild works in Node.js test environment.
    Object.defineProperty(el, 'innerHTML', {
      get: function() {
        return el._innerHTMLValue || '';
      },
      set: function(html) {
        el._innerHTMLValue = html;
        // Clear existing children
        el._children = [];
        el.firstChild = null;
        if (!html || html.trim() === '') return;
        // Parse top-level elements from HTML string
        var parsed = _parseHTMLChildren(html);
        for (var pi = 0; pi < parsed.length; pi++) {
          el._children.push(parsed[pi]);
        }
        el.firstChild = el._children[0] || null;
      },
      enumerable: true,
      configurable: true
    });

    return el;
  }

  /**
   * Very lightweight HTML parser for mock elements.
   * Extracts top-level elements and their class/data attributes.
   * Supports: class="...", data-*="...", and recursively handles children.
   */
  function _parseHTMLChildren(html) {
    var elements = [];
    var pos = 0;
    var len = html.length;

    while (pos < len) {
      // Skip whitespace and text nodes
      var tagStart = html.indexOf('<', pos);
      if (tagStart === -1) break;

      // Skip closing tags at this level
      if (html[tagStart + 1] === '/') {
        break;
      }

      // Find end of opening tag
      var tagEnd = html.indexOf('>', tagStart);
      if (tagEnd === -1) break;

      var isSelfClosing = html[tagEnd - 1] === '/';
      var openTag = html.substring(tagStart + 1, isSelfClosing ? tagEnd - 1 : tagEnd);

      // Extract tag name
      var spaceIdx = openTag.search(/[\s\/]/);
      var tagName = spaceIdx === -1 ? openTag : openTag.substring(0, spaceIdx);
      if (!tagName) { pos = tagEnd + 1; continue; }

      // Create element
      var child = _mockElement(tagName.toLowerCase());

      // Extract class attribute
      var classMatch = openTag.match(/class="([^"]*)"/);
      if (classMatch) child.className = classMatch[1];

      // Extract data-* and other attributes
      var attrRegex = /(\w[\w\-]*)="([^"]*)"/g;
      var attrMatch;
      while ((attrMatch = attrRegex.exec(openTag)) !== null) {
        if (attrMatch[1] !== 'class') {
          child.setAttribute(attrMatch[1], attrMatch[2]);
        }
      }

      if (isSelfClosing) {
        elements.push(child);
        pos = tagEnd + 1;
      } else {
        // Find matching closing tag (handles nesting)
        var closeTag = '</' + tagName;
        var depth = 1;
        var searchPos = tagEnd + 1;
        while (depth > 0 && searchPos < len) {
          var nextOpen = html.indexOf('<' + tagName, searchPos);
          var nextClose = html.indexOf(closeTag, searchPos);
          if (nextClose === -1) break;
          if (nextOpen !== -1 && nextOpen < nextClose) {
            depth++;
            searchPos = nextOpen + 1;
          } else {
            depth--;
            if (depth === 0) {
              // Content between opening and closing tags
              var innerHtml = html.substring(tagEnd + 1, nextClose);
              child.textContent = innerHtml.replace(/<[^>]*>/g, '');
              // Recursively parse inner children
              if (innerHtml.indexOf('<') !== -1) {
                child.innerHTML = innerHtml;
              }
              pos = nextClose + closeTag.length + 1;
              elements.push(child);
              break;
            }
            searchPos = nextClose + 1;
          }
        }
        if (depth !== 0) {
          // Unclosed tag, skip
          pos = tagEnd + 1;
        }
      }
    }

    return elements;
  }

  function _mockQuerySelector(el, sel) {
    // Very simple selector: only class selectors (.foo) supported
    if (!sel || sel[0] !== '.') return null;
    var cls = sel.substring(1);
    return _findByClass(el, cls);
  }

  function _mockQuerySelectorAll(el, sel) {
    if (!sel || sel[0] !== '.') return [];
    var cls = sel.substring(1);
    var results = [];
    _collectByClass(el, cls, results);
    return results;
  }

  function _findByClass(el, cls) {
    if (_hasClass(el, cls)) return el;
    for (var i = 0; i < el._children.length; i++) {
      var found = _findByClass(el._children[i], cls);
      if (found) return found;
    }
    return null;
  }

  function _collectByClass(el, cls, results) {
    if (_hasClass(el, cls)) results.push(el);
    for (var i = 0; i < el._children.length; i++) {
      _collectByClass(el._children[i], cls, results);
    }
  }

  function _hasClass(el, cls) {
    if (!el || !el.className) return false;
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') !== -1;
  }

  function _injectStyles() {
    // Only inject in browser context
    if (typeof document === 'undefined') return;
    if (document.getElementById('dz-styles')) return;

    var style = document.createElement('style');
    style.id = 'dz-styles';
    style.textContent = [
      '.dz-zone-navigator {',
      '  font-family: "Courier New", Courier, monospace;',
      '  background: #1a1814;',
      '  color: #C8BCA8;',
      '  padding: 16px;',
      '  border-radius: 4px;',
      '  max-width: 800px;',
      '  box-sizing: border-box;',
      '}',
      '.dz-nav-header { margin-bottom: 12px; }',
      '.dz-nav-title {',
      '  color: #DAA520;',
      '  font-size: 1.2em;',
      '  margin: 0 0 4px 0;',
      '}',
      '.dz-nav-subtitle {',
      '  color: #A0978E;',
      '  font-size: 0.85em;',
      '}',
      '.dz-map-section { margin-bottom: 16px; }',
      '.dz-map-label {',
      '  color: #DAA520;',
      '  font-size: 0.8em;',
      '  text-transform: uppercase;',
      '  letter-spacing: 2px;',
      '  margin-bottom: 4px;',
      '}',
      '.dz-ascii-map {',
      '  background: #120F0D;',
      '  border: 1px solid #3A3530;',
      '  padding: 8px;',
      '  font-size: 0.75em;',
      '  line-height: 1.4;',
      '  color: #8A8078;',
      '  overflow-x: auto;',
      '  white-space: pre;',
      '}',
      '.dz-controls {',
      '  margin-bottom: 12px;',
      '  display: flex;',
      '  align-items: center;',
      '  gap: 8px;',
      '}',
      '.dz-sort-label { color: #A0978E; font-size: 0.85em; }',
      '.dz-sort-btn {',
      '  background: #2A2520;',
      '  border: 1px solid #3A3530;',
      '  color: #C8BCA8;',
      '  padding: 4px 10px;',
      '  cursor: pointer;',
      '  font-family: inherit;',
      '  font-size: 0.82em;',
      '}',
      '.dz-sort-btn--active {',
      '  background: #3A2E10;',
      '  border-color: #DAA520;',
      '  color: #DAA520;',
      '}',
      '.dz-zone-list {',
      '  display: flex;',
      '  flex-direction: column;',
      '  gap: 10px;',
      '  max-height: 480px;',
      '  overflow-y: auto;',
      '}',
      '.dz-zone-card {',
      '  background: #201D19;',
      '  border: 1px solid #3A3530;',
      '  padding: 12px;',
      '  border-radius: 3px;',
      '}',
      '.dz-zone-card--current {',
      '  border-color: #DAA520;',
      '  background: #221E0E;',
      '}',
      '.dz-zone-header {',
      '  display: flex;',
      '  justify-content: space-between;',
      '  align-items: center;',
      '  margin-bottom: 6px;',
      '}',
      '.dz-zone-name {',
      '  color: #E8D8A0;',
      '  font-size: 1em;',
      '  font-weight: bold;',
      '}',
      '.dz-zone-card--current .dz-zone-name { color: #DAA520; }',
      '.dz-current-label { color: #DAA520; font-size: 0.82em; }',
      '.dz-distance { color: #A0978E; font-size: 0.82em; }',
      '.dz-zone-desc {',
      '  color: #A0978E;',
      '  font-size: 0.85em;',
      '  margin: 0 0 8px 0;',
      '  line-height: 1.5;',
      '}',
      '.dz-zone-meta {',
      '  display: flex;',
      '  flex-wrap: wrap;',
      '  gap: 6px;',
      '  margin-bottom: 10px;',
      '}',
      '.dz-zone-meta span {',
      '  font-size: 0.78em;',
      '  color: #7A7268;',
      '  background: #151210;',
      '  padding: 2px 6px;',
      '  border-radius: 2px;',
      '}',
      '.dz-events { color: #8A9A6A !important; }',
      '.dz-events--none { color: #5A5248 !important; }',
      '.dz-zone-actions { display: flex; gap: 8px; }',
      '.dz-btn {',
      '  font-family: inherit;',
      '  font-size: 0.82em;',
      '  padding: 5px 12px;',
      '  cursor: pointer;',
      '  border-radius: 2px;',
      '}',
      '.dz-btn--travel {',
      '  background: #2A2010;',
      '  border: 1px solid #DAA520;',
      '  color: #DAA520;',
      '}',
      '.dz-btn--travel:hover {',
      '  background: #3A2E10;',
      '}',
      '.dz-btn--disabled {',
      '  background: #1A1814;',
      '  border: 1px solid #3A3530;',
      '  color: #5A5248;',
      '  cursor: default;',
      '}'
    ].join('\n');

    document.head.appendChild(style);
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.ZONE_INFO         = ZONE_INFO;
  exports.ZONE_IDS          = ZONE_IDS;
  exports.createZoneNavigator  = createZoneNavigator;
  exports.updateZoneNavigator  = updateZoneNavigator;
  exports.renderAsciiMap    = renderAsciiMap;
  exports.getZoneDistance   = getZoneDistance;
  exports.getTravelCost     = getTravelCost;
  exports.getZoneDetails    = getZoneDetails;
  exports.getZoneNPCs       = getZoneNPCs;
  exports.getZoneSummary    = getZoneSummary;
  exports.formatZoneCard    = formatZoneCard;
  exports.getAllZonesSorted  = getAllZonesSorted;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardZones = {}));


// dashboard_npcs.js
// dashboard_npcs.js
/**
 * ZION Dashboard NPC Interaction System
 * Provides NPC panel for dashboard (UI-only) mode: talk, shop, quests, relationships
 * Layer: standalone (no required project dependencies; guards optional deps)
 */

(function(exports) {
  'use strict';

  // ==========================================================================
  // CONSTANTS
  // ==========================================================================

  var ZONES = ['nexus', 'gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena'];

  var ARCHETYPES = {
    gardener: {
      role: 'Gardener',
      greeting: 'The soil speaks to those who listen.',
      shop: ['seeds', 'fertilizer', 'watering_can'],
      skills: ['herbalism', 'farming'],
      quests: ['plant_10_seeds', 'harvest_rare_herb']
    },
    builder: {
      role: 'Builder',
      greeting: 'Every structure tells a story.',
      shop: ['planks', 'nails', 'blueprint'],
      skills: ['construction', 'design'],
      quests: ['build_shelter', 'repair_bridge']
    },
    storyteller: {
      role: 'Storyteller',
      greeting: 'Gather close, I have a tale...',
      shop: ['scroll', 'ink', 'journal'],
      skills: ['lore', 'history'],
      quests: ['collect_3_tales', 'visit_ancient_site']
    },
    merchant: {
      role: 'Merchant',
      greeting: 'Fine goods, fair prices!',
      shop: ['trade_permit', 'lockbox', 'scale'],
      skills: ['trading', 'appraisal'],
      quests: ['complete_5_trades', 'find_rare_item']
    },
    explorer: {
      role: 'Explorer',
      greeting: 'The horizon always calls.',
      shop: ['compass', 'rope', 'map_fragment'],
      skills: ['navigation', 'survival'],
      quests: ['discover_3_landmarks', 'map_unknown_area']
    },
    teacher: {
      role: 'Teacher',
      greeting: 'What would you like to learn today?',
      shop: ['textbook', 'chalk', 'lens'],
      skills: ['education', 'research'],
      quests: ['attend_3_lessons', 'solve_puzzle']
    },
    musician: {
      role: 'Musician',
      greeting: 'Music connects all living things.',
      shop: ['strings', 'drum_skin', 'sheet_music'],
      skills: ['performance', 'composition'],
      quests: ['play_for_crowd', 'compose_melody']
    },
    healer: {
      role: 'Healer',
      greeting: 'Rest here, friend. You are safe.',
      shop: ['bandage', 'salve', 'herb_pouch'],
      skills: ['medicine', 'alchemy'],
      quests: ['heal_5_citizens', 'brew_potion']
    },
    philosopher: {
      role: 'Philosopher',
      greeting: 'Question everything, especially this.',
      shop: ['riddle_box', 'meditation_mat', 'star_chart'],
      skills: ['wisdom', 'debate'],
      quests: ['debate_3_topics', 'meditate_at_shrine']
    },
    artist: {
      role: 'Artist',
      greeting: 'Beauty exists in every corner of this world.',
      shop: ['pigment', 'canvas', 'chisel'],
      skills: ['painting', 'sculpture'],
      quests: ['create_artwork', 'find_inspiration']
    }
  };

  var ARCHETYPE_KEYS = Object.keys(ARCHETYPES);

  // 100 names for NPC generation
  var NPC_NAMES = [
    'Aelara', 'Bram', 'Calla', 'Dorin', 'Elara', 'Fenn', 'Greta', 'Hale', 'Iris', 'Jasper',
    'Kael', 'Luna', 'Maren', 'Nyx', 'Orin', 'Petra', 'Quinn', 'Riven', 'Sage', 'Thane',
    'Uma', 'Vale', 'Wren', 'Xander', 'Yara', 'Zeke', 'Ashwin', 'Briar', 'Cedar', 'Dawn',
    'Ember', 'Flint', 'Gale', 'Haven', 'Ivy', 'Jade', 'Kira', 'Lark', 'Moss', 'Nova',
    'Oak', 'Piper', 'Rain', 'Stone', 'Thorn', 'Umber', 'Vesper', 'Willow', 'Zara', 'Aspen',
    'Brook', 'Clay', 'Dune', 'Echo', 'Frost', 'Glen', 'Heath', 'Ione', 'Juniper', 'Kai',
    'Lotus', 'Maple', 'North', 'Onyx', 'Pine', 'Quest', 'Reed', 'Sable', 'Tide', 'Unity',
    'Vine', 'Wave', 'Xyla', 'Yarrow', 'Zinnia', 'Alder', 'Birch', 'Coral', 'Drake', 'Elm',
    'Fawn', 'Grove', 'Haze', 'Indigo', 'Jem', 'Kelp', 'Linden', 'Marsh', 'Nettle', 'Olive',
    'Pearl', 'Quill', 'Rue', 'Swift', 'Terra', 'Urchin', 'Veil', 'Wisp', 'Xyris', 'Yew'
  ];

  // Mood cycles
  var MOODS = ['happy', 'neutral', 'busy', 'thoughtful'];

  // Item catalog with descriptions and base prices
  var ITEM_CATALOG = {
    // Gardener
    seeds:          { name: 'Seeds',          basePrice: 5,   description: 'A packet of mixed seeds ready for planting.' },
    fertilizer:     { name: 'Fertilizer',     basePrice: 8,   description: 'Enriched compost to speed plant growth.' },
    watering_can:   { name: 'Watering Can',   basePrice: 15,  description: 'A copper watering can with a fine rose head.' },
    // Builder
    planks:         { name: 'Planks',         basePrice: 10,  description: 'Hewn timber planks, good for walls and floors.' },
    nails:          { name: 'Nails',          basePrice: 4,   description: 'Iron nails, sold by the handful.' },
    blueprint:      { name: 'Blueprint',      basePrice: 25,  description: 'Detailed construction plans for a small structure.' },
    // Storyteller
    scroll:         { name: 'Scroll',         basePrice: 12,  description: 'A blank scroll of quality parchment.' },
    ink:            { name: 'Ink',            basePrice: 7,   description: 'Deep black ink in a sealed vial.' },
    journal:        { name: 'Journal',        basePrice: 20,  description: 'A leather-bound journal with 200 pages.' },
    // Merchant
    trade_permit:   { name: 'Trade Permit',   basePrice: 30,  description: 'Official permit allowing market stall operation.' },
    lockbox:        { name: 'Lockbox',        basePrice: 18,  description: 'A sturdy iron box with a reliable lock.' },
    scale:          { name: 'Scale',          basePrice: 22,  description: 'A brass balance scale for fair measurement.' },
    // Explorer
    compass:        { name: 'Compass',        basePrice: 20,  description: 'A reliable magnetic compass.' },
    rope:           { name: 'Rope',           basePrice: 9,   description: 'Fifteen meters of braided hemp rope.' },
    map_fragment:   { name: 'Map Fragment',   basePrice: 35,  description: 'A torn piece of a larger map, showing unknown territory.' },
    // Teacher
    textbook:       { name: 'Textbook',       basePrice: 25,  description: 'A comprehensive guide on a chosen subject.' },
    chalk:          { name: 'Chalk',          basePrice: 3,   description: 'White chalk sticks for writing on boards.' },
    lens:           { name: 'Lens',           basePrice: 40,  description: 'A ground glass lens for study and observation.' },
    // Musician
    strings:        { name: 'Strings',        basePrice: 8,   description: 'A set of instrument strings in various gauges.' },
    drum_skin:      { name: 'Drum Skin',      basePrice: 15,  description: 'A tanned hide stretched for drumming.' },
    sheet_music:    { name: 'Sheet Music',    basePrice: 12,  description: 'Handwritten musical scores.' },
    // Healer
    bandage:        { name: 'Bandage',        basePrice: 5,   description: 'Clean linen bandage for wound dressing.' },
    salve:          { name: 'Salve',          basePrice: 10,  description: 'Herbal ointment for soothing cuts and burns.' },
    herb_pouch:     { name: 'Herb Pouch',     basePrice: 18,  description: 'A selection of dried medicinal herbs.' },
    // Philosopher
    riddle_box:     { name: 'Riddle Box',     basePrice: 28,  description: 'A puzzle box containing a mystery inside.' },
    meditation_mat: { name: 'Meditation Mat', basePrice: 16,  description: 'A woven mat for contemplative practice.' },
    star_chart:     { name: 'Star Chart',     basePrice: 45,  description: 'A detailed celestial map of the night sky.' },
    // Artist
    pigment:        { name: 'Pigment',        basePrice: 12,  description: 'Ground mineral pigments in vibrant colors.' },
    canvas:         { name: 'Canvas',         basePrice: 20,  description: 'A primed linen canvas ready for painting.' },
    chisel:         { name: 'Chisel',         basePrice: 22,  description: 'A sharp steel chisel for stone carving.' }
  };

  // Quest catalog
  var QUEST_CATALOG = {
    plant_10_seeds: {
      questId: 'plant_10_seeds',
      title: 'Sow the Land',
      description: 'Plant ten seeds in the gardens zone to help the community grow.',
      reward: { spark: 30, friendship: 10 },
      requirements: { level: 1 }
    },
    harvest_rare_herb: {
      questId: 'harvest_rare_herb',
      title: 'The Rare Bloom',
      description: 'Find and harvest a rare herb growing deep in the wilds.',
      reward: { spark: 60, friendship: 15 },
      requirements: { level: 3 }
    },
    build_shelter: {
      questId: 'build_shelter',
      title: 'First Shelter',
      description: 'Construct a basic shelter in the commons district.',
      reward: { spark: 40, friendship: 10 },
      requirements: { level: 1 }
    },
    repair_bridge: {
      questId: 'repair_bridge',
      title: 'Mend the Bridge',
      description: 'Repair the old stone bridge near the arena zone.',
      reward: { spark: 75, friendship: 20 },
      requirements: { level: 4 }
    },
    collect_3_tales: {
      questId: 'collect_3_tales',
      title: 'The Story Harvest',
      description: 'Speak to three different citizens and collect their personal stories.',
      reward: { spark: 35, friendship: 12 },
      requirements: { level: 1 }
    },
    visit_ancient_site: {
      questId: 'visit_ancient_site',
      title: 'Echoes of the Past',
      description: 'Visit the ancient site hidden in the athenaeum zone.',
      reward: { spark: 55, friendship: 15 },
      requirements: { level: 2 }
    },
    complete_5_trades: {
      questId: 'complete_5_trades',
      title: 'A Fair Exchange',
      description: 'Complete five successful trades in the agora market.',
      reward: { spark: 50, friendship: 10 },
      requirements: { level: 1 }
    },
    find_rare_item: {
      questId: 'find_rare_item',
      title: 'The Uncommon Commodity',
      description: 'Locate a rare item that only appears in certain zones.',
      reward: { spark: 80, friendship: 18 },
      requirements: { level: 3 }
    },
    discover_3_landmarks: {
      questId: 'discover_3_landmarks',
      title: 'Landmark Discovery',
      description: 'Explore and discover three landmarks across different zones.',
      reward: { spark: 45, friendship: 12 },
      requirements: { level: 1 }
    },
    map_unknown_area: {
      questId: 'map_unknown_area',
      title: 'Charting the Unknown',
      description: 'Create a map of an unexplored region near the wilds.',
      reward: { spark: 70, friendship: 18 },
      requirements: { level: 4 }
    },
    attend_3_lessons: {
      questId: 'attend_3_lessons',
      title: 'The Eager Student',
      description: 'Attend three lessons at the athenaeum.',
      reward: { spark: 30, friendship: 10 },
      requirements: { level: 1 }
    },
    solve_puzzle: {
      questId: 'solve_puzzle',
      title: 'The Grand Puzzle',
      description: 'Solve a complex riddle left by a former scholar.',
      reward: { spark: 65, friendship: 16 },
      requirements: { level: 2 }
    },
    play_for_crowd: {
      questId: 'play_for_crowd',
      title: 'Street Performance',
      description: 'Perform music for a crowd of at least five citizens in the agora.',
      reward: { spark: 40, friendship: 12 },
      requirements: { level: 1 }
    },
    compose_melody: {
      questId: 'compose_melody',
      title: 'New Composition',
      description: 'Compose an original melody and share it with the community.',
      reward: { spark: 60, friendship: 15 },
      requirements: { level: 2 }
    },
    heal_5_citizens: {
      questId: 'heal_5_citizens',
      title: 'Healer\'s Work',
      description: 'Provide healing or comfort to five citizens in need.',
      reward: { spark: 50, friendship: 15 },
      requirements: { level: 1 }
    },
    brew_potion: {
      questId: 'brew_potion',
      title: 'The Brew',
      description: 'Brew a restorative potion using herbs gathered in the wilds.',
      reward: { spark: 70, friendship: 18 },
      requirements: { level: 3 }
    },
    debate_3_topics: {
      questId: 'debate_3_topics',
      title: 'The Discourse',
      description: 'Engage in substantive debate on three different philosophical topics.',
      reward: { spark: 45, friendship: 12 },
      requirements: { level: 1 }
    },
    meditate_at_shrine: {
      questId: 'meditate_at_shrine',
      title: 'Shrine Meditation',
      description: 'Meditate at the ancient shrine in the athenaeum for one in-game hour.',
      reward: { spark: 55, friendship: 14 },
      requirements: { level: 2 }
    },
    create_artwork: {
      questId: 'create_artwork',
      title: 'Original Work',
      description: 'Create an original artwork and display it in the studio zone.',
      reward: { spark: 60, friendship: 15 },
      requirements: { level: 1 }
    },
    find_inspiration: {
      questId: 'find_inspiration',
      title: 'The Muse',
      description: 'Visit five different zones to gather visual inspiration for your art.',
      reward: { spark: 40, friendship: 10 },
      requirements: { level: 1 }
    }
  };

  // Price multipliers by archetype
  var ARCHETYPE_PRICE_MULTIPLIERS = {
    merchant:    0.85,
    gardener:    1.00,
    builder:     1.05,
    storyteller: 1.00,
    explorer:    1.10,
    teacher:     1.00,
    musician:    1.05,
    healer:      1.00,
    philosopher: 1.15,
    artist:      1.10
  };

  // Dialogue templates by friendship tier
  var DIALOGUE_BY_TIER = {
    stranger: {
      greeting: [
        'I don\'t believe we\'ve met. Welcome to {zone}.',
        'Ah, a new face. I am {name}, the {role} of this area.',
        'Hello there, traveler. What brings you to {zone}?'
      ],
      farewell: [
        'Safe travels, stranger.',
        'Until we meet again.',
        'May your path be clear.'
      ]
    },
    acquaintance: {
      greeting: [
        'Good to see you again, {player}.',
        'Ah, {player}! Back again, I see.',
        'Welcome back, {player}. How goes your work?'
      ],
      farewell: [
        'Take care, {player}.',
        'See you around, {player}.',
        'Until next time!'
      ]
    },
    friend: {
      greeting: [
        'There you are, {player}! I was hoping you\'d visit.',
        '{player}! Always a pleasure to see a friend.',
        'My dear {player}, welcome! Come, sit with me.'
      ],
      farewell: [
        'Come back soon, friend.',
        'Always good to see you, {player}.',
        'Take care, and visit again!'
      ]
    },
    confidant: {
      greeting: [
        '{player}, you couldn\'t have arrived at a better time.',
        'My closest friend! What adventures have you had today?',
        '{player}! I have so much to tell you.'
      ],
      farewell: [
        'You are always welcome here, {player}.',
        'Until next time, dear friend.',
        'My door is always open for you, {player}.'
      ]
    }
  };

  // Time-of-day greetings
  var TIME_GREETINGS = {
    morning:   'Good morning!',
    afternoon: 'Good afternoon!',
    evening:   'Good evening!',
    night:     'You\'re up late...'
  };

  // Archetype-specific mood by time
  var ARCHETYPE_MOOD_BY_TIME = {
    gardener:    { morning: 'happy',     afternoon: 'busy',      evening: 'neutral',    night: 'thoughtful' },
    builder:     { morning: 'busy',      afternoon: 'busy',      evening: 'neutral',    night: 'thoughtful' },
    storyteller: { morning: 'neutral',   afternoon: 'happy',     evening: 'happy',      night: 'thoughtful' },
    merchant:    { morning: 'happy',     afternoon: 'busy',      evening: 'neutral',    night: 'neutral' },
    explorer:    { morning: 'happy',     afternoon: 'neutral',   evening: 'thoughtful', night: 'thoughtful' },
    teacher:     { morning: 'happy',     afternoon: 'busy',      evening: 'neutral',    night: 'thoughtful' },
    musician:    { morning: 'neutral',   afternoon: 'neutral',   evening: 'happy',      night: 'happy' },
    healer:      { morning: 'happy',     afternoon: 'busy',      evening: 'neutral',    night: 'thoughtful' },
    philosopher: { morning: 'thoughtful', afternoon: 'thoughtful', evening: 'thoughtful', night: 'happy' },
    artist:      { morning: 'neutral',   afternoon: 'happy',     evening: 'happy',      night: 'thoughtful' }
  };

  // Gossip lines by archetype (zone-aware)
  var GOSSIP = {
    gardener:    'I heard the gardens are especially lush near the old fountain this season.',
    builder:     'They say someone is constructing a grand tower near the arena. Bold project.',
    storyteller: 'A traveler came through yesterday with the strangest tale about the wilds.',
    merchant:    'Trade has been brisk lately. The nexus market is quite busy these days.',
    explorer:    'There are uncharted paths beyond the wilds that few dare to walk.',
    teacher:     'The athenaeum received new texts last week. Fascinating reading.',
    musician:    'There was a beautiful impromptu concert in the agora just yesterday.',
    healer:      'The commons folk have been quite healthy. Fresh air and good water help.',
    philosopher: 'I\'ve been pondering the nature of zones. Are boundaries real or imagined?',
    artist:      'The studio is full of creative energy lately. Something is brewing.'
  };

  // ==========================================================================
  // NPC GENERATION
  // ==========================================================================

  var _npcRegistry = null; // lazy-initialized registry

  /**
   * Generate all 100 NPCs deterministically
   * Each zone gets 12-13 NPCs distributed across archetypes
   */
  function _generateNPCs() {
    var npcs = [];
    var nameIndex = 0;
    var archetypeIndex = 0;

    for (var z = 0; z < ZONES.length; z++) {
      var zone = ZONES[z];
      // Zones 0-3 get 13 NPCs, zones 4-7 get 12 NPCs (total = 4*13 + 4*12 = 100)
      var count = z < 4 ? 13 : 12;

      for (var n = 0; n < count; n++) {
        var npcIndex = npcs.length + 1; // 1-based
        var idStr = npcIndex < 10 ? '00' + npcIndex : (npcIndex < 100 ? '0' + npcIndex : '' + npcIndex);
        var archetype = ARCHETYPE_KEYS[archetypeIndex % ARCHETYPE_KEYS.length];
        archetypeIndex++;

        npcs.push({
          id:         'npc_' + idStr,
          name:       NPC_NAMES[nameIndex % NPC_NAMES.length],
          archetype:  archetype,
          zone:       zone,
          mood:       'neutral',
          friendship: 0
        });

        nameIndex++;
      }
    }

    return npcs;
  }

  /**
   * Get (and lazy-init) the NPC registry map by id
   */
  function _getRegistry() {
    if (!_npcRegistry) {
      _npcRegistry = {};
      var list = _generateNPCs();
      for (var i = 0; i < list.length; i++) {
        _npcRegistry[list[i].id] = list[i];
      }
    }
    return _npcRegistry;
  }

  /**
   * Get a flat array of all NPCs
   */
  function _getAllNPCs() {
    var registry = _getRegistry();
    var result = [];
    for (var id in registry) {
      if (registry.hasOwnProperty(id)) {
        result.push(registry[id]);
      }
    }
    return result;
  }

  // ==========================================================================
  // FRIENDSHIP HELPERS
  // ==========================================================================

  /**
   * Returns friendship tier string for a given friendship value
   * @param {number} friendship - 0-100
   * @returns {string} 'stranger' | 'acquaintance' | 'friend' | 'confidant'
   */
  function getFriendshipTier(friendship) {
    if (friendship >= 80) return 'confidant';
    if (friendship >= 50) return 'friend';
    if (friendship >= 20) return 'acquaintance';
    return 'stranger';
  }

  /**
   * Render an ASCII friendship bar
   * @param {number} friendship - 0-100
   * @returns {string} e.g. '[####------] 40%'
   */
  function _friendshipBar(friendship) {
    var pct = Math.max(0, Math.min(100, friendship));
    var filled = Math.round(pct / 10);
    var empty = 10 - filled;
    var bar = '[';
    for (var i = 0; i < filled; i++) bar += '#';
    for (var j = 0; j < empty; j++) bar += '-';
    bar += '] ' + pct + '%';
    return bar;
  }

  // ==========================================================================
  // PLAYER STATE (in-memory; per session)
  // ==========================================================================

  // friendship[playerId][npcId] = number
  var _friendship = {};

  // visitCounts[playerId][npcId] = number
  var _visitCounts = {};

  // completedQuests[playerId] = Set-like object {questId: true}
  var _completedQuests = {};

  // activeQuests[playerId][questId] = quest object
  var _activeQuests = {};

  // inventory[playerId] = [{itemId, name, qty}]
  var _inventory = {};

  /**
   * Get friendship value for a player/npc pair
   */
  function _getFriendship(npcId, playerId) {
    if (!_friendship[playerId]) return 0;
    return _friendship[playerId][npcId] || 0;
  }

  /**
   * Get visit count for a player/npc pair
   */
  function _getVisitCount(npcId, playerId) {
    if (!_visitCounts[playerId]) return 0;
    return _visitCounts[playerId][npcId] || 0;
  }

  /**
   * Increment visit count
   */
  function _incrementVisit(npcId, playerId) {
    if (!_visitCounts[playerId]) _visitCounts[playerId] = {};
    _visitCounts[playerId][npcId] = (_visitCounts[playerId][npcId] || 0) + 1;
  }

  // ==========================================================================
  // CORE EXPORTED FUNCTIONS
  // ==========================================================================

  /**
   * Get all NPCs in a zone
   * @param {string} zoneId
   * @returns {Array}
   */
  function getNPCsInZone(zoneId) {
    return _getAllNPCs().filter(function(npc) {
      return npc.zone === zoneId;
    });
  }

  /**
   * Get an NPC by ID
   * @param {string} npcId
   * @returns {Object|null}
   */
  function getNPCById(npcId) {
    var registry = _getRegistry();
    return registry[npcId] || null;
  }

  /**
   * Get the current mood of an NPC based on time of day
   * @param {string} npcId
   * @param {string} timeOfDay - 'morning'|'afternoon'|'evening'|'night'
   * @returns {string} mood
   */
  function getNPCMood(npcId, timeOfDay) {
    var npc = getNPCById(npcId);
    if (!npc) return 'neutral';
    var validTimes = ['morning', 'afternoon', 'evening', 'night'];
    var tod = validTimes.indexOf(timeOfDay) >= 0 ? timeOfDay : 'afternoon';
    var moodMap = ARCHETYPE_MOOD_BY_TIME[npc.archetype];
    if (!moodMap) return 'neutral';
    return moodMap[tod] || 'neutral';
  }

  /**
   * Update friendship between a player and NPC
   * @param {string} npcId
   * @param {string} playerId
   * @param {number} amount - positive or negative
   * @returns {number} new friendship level (0-100)
   */
  function updateFriendship(npcId, playerId, amount) {
    if (!_friendship[playerId]) _friendship[playerId] = {};
    var current = _friendship[playerId][npcId] || 0;
    var next = Math.max(0, Math.min(100, current + amount));
    _friendship[playerId][npcId] = next;
    return next;
  }

  /**
   * Talk to an NPC â€” returns dialogue object
   * @param {string} npcId
   * @param {string} playerId
   * @returns {Object} { speaker, text, options: [{label, action}] }
   */
  function talkToNPC(npcId, playerId) {
    var npc = getNPCById(npcId);
    if (!npc) {
      return {
        speaker: 'System',
        text: 'No one by that name could be found.',
        options: []
      };
    }

    var friendship = _getFriendship(npcId, playerId);
    var tier = getFriendshipTier(friendship);
    var visits = _getVisitCount(npcId, playerId);
    var archData = ARCHETYPES[npc.archetype];

    // Increment visit on talk
    _incrementVisit(npcId, playerId);

    // Small friendship boost on visit (capped after many visits)
    if (visits < 10) {
      updateFriendship(npcId, playerId, 2);
    }

    // Determine time-of-day greeting prefix
    var hour = new Date().getHours();
    var tod;
    if (hour >= 5 && hour < 12)       tod = 'morning';
    else if (hour >= 12 && hour < 17) tod = 'afternoon';
    else if (hour >= 17 && hour < 21) tod = 'evening';
    else                               tod = 'night';

    var timeGreet = TIME_GREETINGS[tod];

    // Build greeting based on tier
    var tierGreetings = DIALOGUE_BY_TIER[tier].greeting;
    var greetIdx = visits % tierGreetings.length;
    var greetTemplate = tierGreetings[greetIdx];

    var playerLabel = playerId || 'traveler';
    var greet = greetTemplate
      .replace('{player}', playerLabel)
      .replace('{name}', npc.name)
      .replace('{role}', archData.role)
      .replace('{zone}', npc.zone);

    var introLine = (tier === 'stranger')
      ? greet
      : (timeGreet + ' ' + greet);

    // Archetype greeting on first visit
    var text;
    if (visits === 0) {
      text = archData.greeting + ' ' + introLine;
    } else {
      text = introLine;
    }

    return {
      speaker: npc.name,
      text: text,
      options: [
        { label: '[>] Chat',    action: 'gossip' },
        { label: '[$] Shop',   action: 'shop' },
        { label: '[!] Quest',  action: 'quest' },
        { label: '[~] Goodbye', action: 'farewell' }
      ]
    };
  }

  /**
   * Get available dialogue options for an NPC
   * @param {string} npcId
   * @param {string} playerId
   * @param {string} context - 'greeting'|'shop'|'quest'|'gossip'|'farewell'
   * @returns {Array} [{label, action}]
   */
  function getDialogueOptions(npcId, playerId, context) {
    var npc = getNPCById(npcId);
    if (!npc) return [];

    var baseOptions = [
      { label: '[>] Chat',    action: 'gossip' },
      { label: '[$] Shop',   action: 'shop' },
      { label: '[!] Quest',  action: 'quest' },
      { label: '[~] Goodbye', action: 'farewell' }
    ];

    if (context === 'farewell') {
      return [{ label: '[>] Wait, one more thing...', action: 'greeting' }];
    }
    if (context === 'gossip') {
      return [
        { label: '[>] Tell me more', action: 'gossip' },
        { label: '[~] Goodbye',      action: 'farewell' },
        { label: '[$] Shop',         action: 'shop' },
        { label: '[!] Quest',        action: 'quest' }
      ];
    }
    if (context === 'shop') {
      return [
        { label: '[>] Chat',    action: 'gossip' },
        { label: '[!] Quest',  action: 'quest' },
        { label: '[~] Goodbye', action: 'farewell' }
      ];
    }
    if (context === 'quest') {
      return [
        { label: '[>] Chat',    action: 'gossip' },
        { label: '[$] Shop',   action: 'shop' },
        { label: '[~] Goodbye', action: 'farewell' }
      ];
    }
    return baseOptions;
  }

  /**
   * Process a dialogue choice and return the next state
   * @param {string} npcId
   * @param {string} playerId
   * @param {string} choice - action string from dialogue option
   * @returns {Object} { speaker, text, options, effect }
   */
  function processDialogueChoice(npcId, playerId, choice) {
    var npc = getNPCById(npcId);
    if (!npc) {
      return { speaker: 'System', text: 'NPC not found.', options: [], effect: null };
    }

    var archData = ARCHETYPES[npc.archetype];
    var friendship = _getFriendship(npcId, playerId);
    var tier = getFriendshipTier(friendship);
    var effect = null;

    if (choice === 'gossip') {
      var gossipLine = GOSSIP[npc.archetype] || 'Things seem quiet around here.';
      // Small friendship gain for chatting
      var newFriendship = updateFriendship(npcId, playerId, 1);
      effect = { type: 'friendship', delta: 1, total: newFriendship };
      return {
        speaker: npc.name,
        text: gossipLine,
        options: getDialogueOptions(npcId, playerId, 'gossip'),
        effect: effect
      };
    }

    if (choice === 'farewell') {
      var farewellTemplates = DIALOGUE_BY_TIER[tier].farewell;
      var farewellIdx = _getVisitCount(npcId, playerId) % farewellTemplates.length;
      var farewellText = farewellTemplates[farewellIdx]
        .replace('{player}', playerId || 'traveler')
        .replace('{name}', npc.name);
      return {
        speaker: npc.name,
        text: farewellText,
        options: [],
        effect: null
      };
    }

    if (choice === 'shop') {
      var inventory = getShopInventory(npcId);
      var itemList = inventory.map(function(item) {
        return item.name + ' (' + item.price + ' Spark)';
      }).join(', ');
      return {
        speaker: npc.name,
        text: 'Here is what I have available: ' + itemList,
        options: getDialogueOptions(npcId, playerId, 'shop'),
        effect: { type: 'open_shop', npcId: npcId }
      };
    }

    if (choice === 'quest') {
      var playerLabel = playerId || 'traveler';
      var quests = getAvailableQuests(npcId, playerId);
      if (quests.length === 0) {
        return {
          speaker: npc.name,
          text: 'I have no tasks for you right now, ' + playerLabel + '. Come back later.',
          options: getDialogueOptions(npcId, playerId, 'quest'),
          effect: null
        };
      }
      var questNames = quests.map(function(q) { return '[!] ' + q.title; }).join(', ');
      return {
        speaker: npc.name,
        text: 'I have work that needs doing, ' + playerLabel + ': ' + questNames,
        options: getDialogueOptions(npcId, playerId, 'quest'),
        effect: { type: 'open_quests', npcId: npcId }
      };
    }

    if (choice === 'greeting') {
      return talkToNPC(npcId, playerId);
    }

    return {
      speaker: npc.name,
      text: 'Hmm, I\'m not sure what you mean.',
      options: getDialogueOptions(npcId, playerId, 'greeting'),
      effect: null
    };
  }

  /**
   * Get shop inventory for an NPC
   * @param {string} npcId
   * @returns {Array} [{id, name, price, description, stock}]
   */
  function getShopInventory(npcId) {
    var npc = getNPCById(npcId);
    if (!npc) return [];

    var archData = ARCHETYPES[npc.archetype];
    var multiplier = ARCHETYPE_PRICE_MULTIPLIERS[npc.archetype] || 1.0;

    return archData.shop.map(function(itemId) {
      var catalogItem = ITEM_CATALOG[itemId];
      if (!catalogItem) return null;
      var price = Math.round(catalogItem.basePrice * multiplier);
      return {
        id:          itemId,
        name:        catalogItem.name,
        price:       price,
        description: catalogItem.description,
        stock:       10
      };
    }).filter(function(item) { return item !== null; });
  }

  /**
   * Buy an item from an NPC
   * @param {string} npcId
   * @param {string} itemId
   * @param {string} playerId
   * @param {Object} [economy] - optional economy ledger (guards if absent)
   * @returns {Object} { success, message, item, cost }
   */
  function buyFromNPC(npcId, itemId, playerId, economy) {
    var npc = getNPCById(npcId);
    if (!npc) {
      return { success: false, message: 'NPC not found.', item: null, cost: 0 };
    }

    var inventory = getShopInventory(npcId);
    var shopItem = null;
    for (var i = 0; i < inventory.length; i++) {
      if (inventory[i].id === itemId) {
        shopItem = inventory[i];
        break;
      }
    }

    if (!shopItem) {
      return { success: false, message: 'Item not available from this NPC.', item: null, cost: 0 };
    }

    // Attempt economy deduction if provided
    if (economy && typeof economy.getBalance === 'function') {
      var balance = economy.getBalance(playerId);
      if (balance < shopItem.price) {
        return {
          success: false,
          message: 'Not enough Spark. Need ' + shopItem.price + ', have ' + balance + '.',
          item: null,
          cost: shopItem.price
        };
      }
      if (typeof economy.deduct === 'function') {
        economy.deduct(playerId, shopItem.price);
      }
    }

    // Add to player inventory
    if (!_inventory[playerId]) _inventory[playerId] = [];
    var found = false;
    for (var j = 0; j < _inventory[playerId].length; j++) {
      if (_inventory[playerId][j].itemId === itemId) {
        _inventory[playerId][j].qty += 1;
        found = true;
        break;
      }
    }
    if (!found) {
      _inventory[playerId].push({ itemId: itemId, name: shopItem.name, qty: 1 });
    }

    // Small friendship bump on purchase
    updateFriendship(npcId, playerId, 3);

    return {
      success: true,
      message: 'You purchased ' + shopItem.name + ' for ' + shopItem.price + ' Spark.',
      item: shopItem,
      cost: shopItem.price
    };
  }

  /**
   * Get available quests from an NPC for a player
   * @param {string} npcId
   * @param {string} playerId
   * @returns {Array} quest objects
   */
  function getAvailableQuests(npcId, playerId) {
    var npc = getNPCById(npcId);
    if (!npc) return [];

    var archData = ARCHETYPES[npc.archetype];
    var completed = _completedQuests[playerId] || {};
    var active = _activeQuests[playerId] || {};

    return archData.quests.map(function(questId) {
      return QUEST_CATALOG[questId] || null;
    }).filter(function(quest) {
      if (!quest) return false;
      if (completed[quest.questId]) return false;
      if (active[quest.questId]) return false;
      return true;
    });
  }

  /**
   * Accept a quest from an NPC
   * @param {string} npcId
   * @param {string} questId
   * @param {string} playerId
   * @returns {Object} { success, quest }
   */
  function acceptQuestFromNPC(npcId, questId, playerId) {
    var npc = getNPCById(npcId);
    if (!npc) {
      return { success: false, quest: null, message: 'NPC not found.' };
    }

    var archData = ARCHETYPES[npc.archetype];
    if (archData.quests.indexOf(questId) < 0) {
      return { success: false, quest: null, message: 'This NPC does not offer that quest.' };
    }

    var quest = QUEST_CATALOG[questId];
    if (!quest) {
      return { success: false, quest: null, message: 'Quest not found.' };
    }

    var completed = _completedQuests[playerId] || {};
    if (completed[questId]) {
      return { success: false, quest: quest, message: 'You have already completed this quest.' };
    }

    if (!_activeQuests[playerId]) _activeQuests[playerId] = {};
    if (_activeQuests[playerId][questId]) {
      return { success: false, quest: quest, message: 'Quest already active.' };
    }

    _activeQuests[playerId][questId] = quest;

    // Friendship bonus for accepting
    updateFriendship(npcId, playerId, 5);

    return { success: true, quest: quest, message: 'Quest accepted: ' + quest.title };
  }

  /**
   * Search NPCs by name, role, or zone
   * @param {string} query
   * @returns {Array} matching NPCs
   */
  function searchNPCs(query) {
    if (!query || typeof query !== 'string') return [];
    var q = query.toLowerCase().trim();
    if (q.length === 0) return [];

    return _getAllNPCs().filter(function(npc) {
      var archData = ARCHETYPES[npc.archetype];
      var role = archData ? archData.role.toLowerCase() : '';
      return (
        npc.name.toLowerCase().indexOf(q) >= 0 ||
        role.indexOf(q) >= 0 ||
        npc.zone.toLowerCase().indexOf(q) >= 0 ||
        npc.archetype.toLowerCase().indexOf(q) >= 0
      );
    });
  }

  /**
   * Format an NPC card as HTML string
   * @param {Object} npc
   * @param {number} friendship - 0-100
   * @returns {string} HTML string
   */
  function formatNPCCard(npc, friendship) {
    if (!npc) return '<div class="npc-card npc-card--empty">No NPC data.</div>';

    var f = typeof friendship === 'number' ? friendship : 0;
    var archData = ARCHETYPES[npc.archetype] || { role: 'Unknown' };
    var tier = getFriendshipTier(f);
    var bar = _friendshipBar(f);
    var mood = npc.mood || 'neutral';

    return (
      '<div class="npc-card" data-id="' + npc.id + '">' +
        '<div class="npc-card__header">' +
          '<span class="npc-card__name">' + npc.name + '</span>' +
          '<span class="npc-card__role"> &mdash; ' + archData.role + '</span>' +
        '</div>' +
        '<div class="npc-card__meta">' +
          '<span class="npc-card__zone">Zone: ' + npc.zone + '</span>' +
          ' | ' +
          '<span class="npc-card__mood">[~] ' + mood + '</span>' +
        '</div>' +
        '<div class="npc-card__friendship">' +
          'Friendship (' + tier + '): ' + bar +
        '</div>' +
        '<div class="npc-card__actions">' +
          '<button class="npc-btn npc-btn--talk"  data-npc="' + npc.id + '">[>] Talk</button>' +
          '<button class="npc-btn npc-btn--shop"  data-npc="' + npc.id + '">[$] Shop</button>' +
          '<button class="npc-btn npc-btn--quest" data-npc="' + npc.id + '">[!] Quest</button>' +
        '</div>' +
      '</div>'
    );
  }

  // ==========================================================================
  // DOM PANEL (browser only; guarded)
  // ==========================================================================

  /**
   * Create the NPC interaction panel DOM element
   * @returns {Element|Object} DOM element (or plain object if no DOM)
   */
  function createNPCPanel() {
    // Guard: no DOM in Node environment
    if (typeof document === 'undefined') {
      return { type: 'npc-panel', rendered: false };
    }

    var panel = document.createElement('div');
    panel.className = 'dashboard-npc-panel';
    panel.setAttribute('data-panel', 'npcs');

    // --- Filter bar ---
    var filterBar = document.createElement('div');
    filterBar.className = 'npc-filter-bar';

    var zoneSelect = document.createElement('select');
    zoneSelect.className = 'npc-filter-zone';
    zoneSelect.innerHTML = '<option value="">All Zones</option>' +
      ZONES.map(function(z) {
        return '<option value="' + z + '">' + z.charAt(0).toUpperCase() + z.slice(1) + '</option>';
      }).join('');

    var archetypeSelect = document.createElement('select');
    archetypeSelect.className = 'npc-filter-archetype';
    archetypeSelect.innerHTML = '<option value="">All Roles</option>' +
      ARCHETYPE_KEYS.map(function(k) {
        return '<option value="' + k + '">' + ARCHETYPES[k].role + '</option>';
      }).join('');

    var searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.className = 'npc-filter-search';
    searchInput.placeholder = 'Search by name...';

    filterBar.appendChild(zoneSelect);
    filterBar.appendChild(archetypeSelect);
    filterBar.appendChild(searchInput);

    // --- NPC list ---
    var npcList = document.createElement('div');
    npcList.className = 'npc-list';

    // Render first zone by default
    var allNPCs = getNPCsInZone(ZONES[0]);
    for (var i = 0; i < allNPCs.length; i++) {
      var npc = allNPCs[i];
      var friendship = 0;
      var cardHtml = formatNPCCard(npc, friendship);
      var wrapper = document.createElement('div');
      wrapper.innerHTML = cardHtml;
      npcList.appendChild(wrapper.firstChild);
    }

    // --- Interaction area ---
    var interactionArea = document.createElement('div');
    interactionArea.className = 'npc-interaction-area';
    interactionArea.innerHTML = '<p class="npc-interaction-prompt">Select an NPC to interact.</p>';

    // --- Wire up filter events ---
    function _applyFilters() {
      var zone = zoneSelect.value;
      var archetype = archetypeSelect.value;
      var query = searchInput.value;

      var filtered = _getAllNPCs();

      if (zone) {
        filtered = filtered.filter(function(n) { return n.zone === zone; });
      }
      if (archetype) {
        filtered = filtered.filter(function(n) { return n.archetype === archetype; });
      }
      if (query) {
        var q = query.toLowerCase();
        filtered = filtered.filter(function(n) {
          var role = (ARCHETYPES[n.archetype] || {}).role || '';
          return (
            n.name.toLowerCase().indexOf(q) >= 0 ||
            role.toLowerCase().indexOf(q) >= 0 ||
            n.zone.toLowerCase().indexOf(q) >= 0
          );
        });
      }

      npcList.innerHTML = '';
      for (var fi = 0; fi < filtered.length; fi++) {
        var fn = filtered[fi];
        var html = formatNPCCard(fn, _getFriendship(fn.id, 'player'));
        var wr = document.createElement('div');
        wr.innerHTML = html;
        npcList.appendChild(wr.firstChild);
      }

      if (filtered.length === 0) {
        npcList.innerHTML = '<p class="npc-list--empty">No NPCs match your search.</p>';
      }
    }

    zoneSelect.addEventListener('change', _applyFilters);
    archetypeSelect.addEventListener('change', _applyFilters);
    searchInput.addEventListener('input', _applyFilters);

    // --- Wire up NPC action buttons via delegation ---
    npcList.addEventListener('click', function(e) {
      var btn = e.target;
      if (!btn.classList.contains('npc-btn')) return;
      var npcId = btn.getAttribute('data-npc');
      var playerId = 'player';

      interactionArea.innerHTML = '';

      if (btn.classList.contains('npc-btn--talk')) {
        var dialogue = talkToNPC(npcId, playerId);
        _renderDialogue(interactionArea, dialogue, npcId, playerId);
      } else if (btn.classList.contains('npc-btn--shop')) {
        _renderShop(interactionArea, npcId, playerId);
      } else if (btn.classList.contains('npc-btn--quest')) {
        _renderQuests(interactionArea, npcId, playerId);
      }
    });

    // Assemble panel
    panel.appendChild(filterBar);
    panel.appendChild(npcList);
    panel.appendChild(interactionArea);

    return panel;
  }

  /**
   * Render dialogue into a container (internal helper)
   */
  function _renderDialogue(container, dialogue, npcId, playerId) {
    var div = document.createElement('div');
    div.className = 'npc-dialogue';
    div.innerHTML =
      '<div class="npc-dialogue__speaker">' + dialogue.speaker + '</div>' +
      '<div class="npc-dialogue__text">' + dialogue.text + '</div>' +
      '<div class="npc-dialogue__options"></div>';

    var optionsDiv = div.querySelector('.npc-dialogue__options');
    dialogue.options.forEach(function(opt) {
      var btn = document.createElement('button');
      btn.className = 'npc-dialogue__option-btn';
      btn.textContent = opt.label;
      btn.addEventListener('click', function() {
        var result = processDialogueChoice(npcId, playerId, opt.action);
        container.innerHTML = '';
        _renderDialogue(container, result, npcId, playerId);
      });
      optionsDiv.appendChild(btn);
    });

    container.appendChild(div);
  }

  /**
   * Render shop into a container (internal helper)
   */
  function _renderShop(container, npcId, playerId) {
    var inventory = getShopInventory(npcId);
    var npc = getNPCById(npcId);
    var html = '<div class="npc-shop"><h3>[$] ' + (npc ? npc.name : '') + '\'s Shop</h3><ul>';
    inventory.forEach(function(item) {
      html += '<li><strong>' + item.name + '</strong> &mdash; ' + item.price + ' Spark &mdash; ' + item.description + '</li>';
    });
    html += '</ul></div>';
    container.innerHTML = html;
  }

  /**
   * Render quests into a container (internal helper)
   */
  function _renderQuests(container, npcId, playerId) {
    var quests = getAvailableQuests(npcId, playerId);
    var npc = getNPCById(npcId);
    var html = '<div class="npc-quests"><h3>[!] ' + (npc ? npc.name : '') + '\'s Quests</h3>';
    if (quests.length === 0) {
      html += '<p>No quests available right now.</p>';
    } else {
      html += '<ul>';
      quests.forEach(function(q) {
        html += '<li><strong>' + q.title + '</strong> &mdash; ' + q.description +
                ' <em>(Reward: ' + q.reward.spark + ' Spark)</em></li>';
      });
      html += '</ul>';
    }
    html += '</div>';
    container.innerHTML = html;
  }

  // ==========================================================================
  // EXPORTS
  // ==========================================================================

  exports.ARCHETYPES             = ARCHETYPES;
  exports.ZONES                  = ZONES;
  exports.NPC_NAMES              = NPC_NAMES;
  exports.ITEM_CATALOG           = ITEM_CATALOG;
  exports.QUEST_CATALOG          = QUEST_CATALOG;
  exports.ARCHETYPE_PRICE_MULTIPLIERS = ARCHETYPE_PRICE_MULTIPLIERS;

  exports.createNPCPanel         = createNPCPanel;
  exports.getNPCsInZone          = getNPCsInZone;
  exports.getNPCById             = getNPCById;
  exports.talkToNPC              = talkToNPC;
  exports.getShopInventory       = getShopInventory;
  exports.buyFromNPC             = buyFromNPC;
  exports.getAvailableQuests     = getAvailableQuests;
  exports.acceptQuestFromNPC     = acceptQuestFromNPC;
  exports.updateFriendship       = updateFriendship;
  exports.getFriendshipTier      = getFriendshipTier;
  exports.getNPCMood             = getNPCMood;
  exports.searchNPCs             = searchNPCs;
  exports.formatNPCCard          = formatNPCCard;
  exports.getDialogueOptions     = getDialogueOptions;
  exports.processDialogueChoice  = processDialogueChoice;

  // Internal helpers exposed for testing
  exports._generateNPCs          = _generateNPCs;
  exports._friendshipBar         = _friendshipBar;
  exports._getAllNPCs            = _getAllNPCs;
  exports._getFriendship         = _getFriendship;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardNPCs = {}));


// dashboard_inventory.js
// dashboard_inventory.js
/**
 * ZION Dashboard â€” Inventory & Crafting Panel
 *
 * Provides a UI-only inventory panel for dashboard (text-based) mode.
 * Manages item catalog, crafting recipes, equipment, and inventory state.
 *
 * UMD pattern â€” works in browser (window.DashboardInventory) and Node.js.
 * ES5 compatible â€” uses var declarations throughout.
 */
(function(exports) {
  'use strict';

  // ---------------------------------------------------------------------------
  // Item Catalog
  // ---------------------------------------------------------------------------

  var ITEM_CATALOG = {
    // Resources
    wood: {
      name: 'Wood',
      category: 'resource',
      rarity: 'common',
      value: 2,
      desc: 'Sturdy timber from the Wilds'
    },
    stone: {
      name: 'Stone',
      category: 'resource',
      rarity: 'common',
      value: 3,
      desc: 'Quarried from the mountains'
    },
    iron_ore: {
      name: 'Iron Ore',
      category: 'resource',
      rarity: 'uncommon',
      value: 8,
      desc: 'Raw metal waiting to be smelted'
    },
    crystal: {
      name: 'Crystal',
      category: 'resource',
      rarity: 'rare',
      value: 25,
      desc: 'Glowing shard from deep caves'
    },
    herbs: {
      name: 'Herbs',
      category: 'resource',
      rarity: 'common',
      value: 4,
      desc: 'Medicinal plants from the Gardens'
    },
    silk: {
      name: 'Silk',
      category: 'resource',
      rarity: 'uncommon',
      value: 12,
      desc: 'Fine thread from garden spiders'
    },
    clay: {
      name: 'Clay',
      category: 'resource',
      rarity: 'common',
      value: 2,
      desc: 'Moldable earth from riverbeds'
    },
    gold_dust: {
      name: 'Gold Dust',
      category: 'resource',
      rarity: 'rare',
      value: 30,
      desc: 'Precious metal particles'
    },
    feather: {
      name: 'Feather',
      category: 'resource',
      rarity: 'common',
      value: 1,
      desc: 'Light plume from birds'
    },
    honey: {
      name: 'Honey',
      category: 'resource',
      rarity: 'uncommon',
      value: 6,
      desc: 'Sweet nectar from garden bees'
    },

    // Tools
    pickaxe: {
      name: 'Pickaxe',
      category: 'tool',
      rarity: 'common',
      value: 15,
      desc: 'For mining stone and ore'
    },
    axe: {
      name: 'Axe',
      category: 'tool',
      rarity: 'common',
      value: 12,
      desc: 'For chopping wood'
    },
    fishing_rod: {
      name: 'Fishing Rod',
      category: 'tool',
      rarity: 'common',
      value: 10,
      desc: 'Basic rod for catching fish'
    },
    compass: {
      name: 'Compass',
      category: 'tool',
      rarity: 'uncommon',
      value: 20,
      desc: 'Points toward discoveries'
    },
    telescope: {
      name: 'Telescope',
      category: 'tool',
      rarity: 'rare',
      value: 50,
      desc: 'See constellations clearly'
    },

    // Consumables
    bread: {
      name: 'Bread',
      category: 'consumable',
      rarity: 'common',
      value: 3,
      desc: 'Restores a bit of energy'
    },
    potion: {
      name: 'Potion',
      category: 'consumable',
      rarity: 'uncommon',
      value: 15,
      desc: 'Restores energy fully'
    },
    elixir: {
      name: 'Elixir',
      category: 'consumable',
      rarity: 'rare',
      value: 40,
      desc: 'Grants temporary bonus'
    },
    scroll: {
      name: 'Scroll',
      category: 'consumable',
      rarity: 'uncommon',
      value: 10,
      desc: 'Contains ancient knowledge'
    },

    // Crafted items
    iron_bar: {
      name: 'Iron Bar',
      category: 'crafted',
      rarity: 'uncommon',
      value: 20,
      desc: 'Smelted iron ingot'
    },
    plank: {
      name: 'Plank',
      category: 'crafted',
      rarity: 'common',
      value: 5,
      desc: 'Processed lumber'
    },
    brick: {
      name: 'Brick',
      category: 'crafted',
      rarity: 'common',
      value: 6,
      desc: 'Fired clay block'
    },
    rope: {
      name: 'Rope',
      category: 'crafted',
      rarity: 'common',
      value: 8,
      desc: 'Woven silk fibers'
    },
    candle: {
      name: 'Candle',
      category: 'crafted',
      rarity: 'common',
      value: 4,
      desc: 'Wax and wick for light'
    },
    glass: {
      name: 'Glass',
      category: 'crafted',
      rarity: 'uncommon',
      value: 12,
      desc: 'Clear pane of glass'
    },

    // Equipment
    leather_armor: {
      name: 'Leather Armor',
      category: 'equipment',
      rarity: 'uncommon',
      value: 30,
      desc: 'Basic protection',
      slot: 'body',
      stats: { defense: 5 }
    },
    iron_sword: {
      name: 'Iron Sword',
      category: 'equipment',
      rarity: 'uncommon',
      value: 35,
      desc: 'A sturdy blade',
      slot: 'weapon',
      stats: { attack: 8 }
    },
    gold_ring: {
      name: 'Gold Ring',
      category: 'equipment',
      rarity: 'rare',
      value: 60,
      desc: 'Ornate jewelry',
      slot: 'accessory',
      stats: { luck: 5 }
    },
    crystal_staff: {
      name: 'Crystal Staff',
      category: 'equipment',
      rarity: 'epic',
      value: 100,
      desc: 'Channels energy',
      slot: 'weapon',
      stats: { attack: 15, magic: 20 }
    },
    iron_helm: {
      name: 'Iron Helm',
      category: 'equipment',
      rarity: 'uncommon',
      value: 25,
      desc: 'A solid iron helmet',
      slot: 'head',
      stats: { defense: 3 }
    },
    silver_amulet: {
      name: 'Silver Amulet',
      category: 'equipment',
      rarity: 'rare',
      value: 55,
      desc: 'A gleaming amulet',
      slot: 'accessory',
      stats: { magic: 8, luck: 3 }
    },

    // Collectibles
    ancient_coin: {
      name: 'Ancient Coin',
      category: 'collectible',
      rarity: 'rare',
      value: 50,
      desc: 'From a forgotten era'
    },
    fossil: {
      name: 'Fossil',
      category: 'collectible',
      rarity: 'rare',
      value: 45,
      desc: 'Preserved in stone'
    },
    star_fragment: {
      name: 'Star Fragment',
      category: 'collectible',
      rarity: 'legendary',
      value: 200,
      desc: 'Fell from the sky'
    },
    rare_gem: {
      name: 'Rare Gem',
      category: 'collectible',
      rarity: 'epic',
      value: 120,
      desc: 'A gemstone of unusual brilliance'
    },
    portrait: {
      name: 'Portrait',
      category: 'collectible',
      rarity: 'uncommon',
      value: 35,
      desc: 'A painted portrait of a ZION citizen'
    },
    rune_stone: {
      name: 'Rune Stone',
      category: 'collectible',
      rarity: 'rare',
      value: 70,
      desc: 'Ancient stone covered in runes'
    },

    // Extra resources
    charcoal: {
      name: 'Charcoal',
      category: 'resource',
      rarity: 'common',
      value: 3,
      desc: 'Burned wood residue'
    },
    sand: {
      name: 'Sand',
      category: 'resource',
      rarity: 'common',
      value: 1,
      desc: 'Fine grains from the shore'
    },
    mushroom: {
      name: 'Mushroom',
      category: 'resource',
      rarity: 'common',
      value: 2,
      desc: 'Foraged from the forest floor'
    },
    fiber: {
      name: 'Fiber',
      category: 'resource',
      rarity: 'common',
      value: 2,
      desc: 'Plant fiber for weaving'
    },
    resin: {
      name: 'Resin',
      category: 'resource',
      rarity: 'uncommon',
      value: 7,
      desc: 'Sticky sap from ancient trees'
    },

    // Extra crafted
    torch: {
      name: 'Torch',
      category: 'crafted',
      rarity: 'common',
      value: 5,
      desc: 'Lights the way in dark places'
    },
    net: {
      name: 'Net',
      category: 'crafted',
      rarity: 'common',
      value: 9,
      desc: 'Woven fiber for catching creatures'
    },
    bowl: {
      name: 'Bowl',
      category: 'crafted',
      rarity: 'common',
      value: 4,
      desc: 'A clay vessel for food'
    },
    ink: {
      name: 'Ink',
      category: 'crafted',
      rarity: 'uncommon',
      value: 10,
      desc: 'Dark ink for writing'
    },
    dye: {
      name: 'Dye',
      category: 'crafted',
      rarity: 'common',
      value: 6,
      desc: 'Colorful dye made from herbs'
    },

    // Extra consumables
    stew: {
      name: 'Stew',
      category: 'consumable',
      rarity: 'common',
      value: 8,
      desc: 'Hearty meal that restores energy'
    },
    tea: {
      name: 'Tea',
      category: 'consumable',
      rarity: 'common',
      value: 5,
      desc: 'Calming herbal tea'
    },
    antidote: {
      name: 'Antidote',
      category: 'consumable',
      rarity: 'uncommon',
      value: 18,
      desc: 'Cures ailments and poison'
    },

    // Additional resources
    coal: {
      name: 'Coal',
      category: 'resource',
      rarity: 'common',
      value: 4,
      desc: 'Fuel for furnaces and forges'
    },
    sulfur: {
      name: 'Sulfur',
      category: 'resource',
      rarity: 'uncommon',
      value: 9,
      desc: 'Yellow mineral with explosive potential'
    },
    salt: {
      name: 'Salt',
      category: 'resource',
      rarity: 'common',
      value: 2,
      desc: 'Harvested from coastal shores'
    },

    // Additional crafted items
    wire: {
      name: 'Wire',
      category: 'crafted',
      rarity: 'uncommon',
      value: 11,
      desc: 'Thin drawn iron strand'
    },
    barrel: {
      name: 'Barrel',
      category: 'crafted',
      rarity: 'common',
      value: 7,
      desc: 'Wooden cask for storage'
    },
    lantern: {
      name: 'Lantern',
      category: 'crafted',
      rarity: 'uncommon',
      value: 14,
      desc: 'Glass lantern that holds candlelight'
    },

    // Additional collectibles
    carved_idol: {
      name: 'Carved Idol',
      category: 'collectible',
      rarity: 'epic',
      value: 130,
      desc: 'A small figure carved from an unknown material'
    },
    map_fragment: {
      name: 'Map Fragment',
      category: 'collectible',
      rarity: 'rare',
      value: 65,
      desc: 'A piece of an ancient map of ZION'
    },
    void_shard: {
      name: 'Void Shard',
      category: 'collectible',
      rarity: 'legendary',
      value: 250,
      desc: 'A fragment of pure darkness from beyond the rift'
    },
    pressed_flower: {
      name: 'Pressed Flower',
      category: 'collectible',
      rarity: 'uncommon',
      value: 28,
      desc: 'A rare bloom preserved between pages'
    }
  };

  // ---------------------------------------------------------------------------
  // Crafting Recipes
  // ---------------------------------------------------------------------------

  var RECIPES = [
    {
      id: 'plank',
      name: 'Plank',
      inputs: [{ item: 'wood', count: 2 }],
      output: { item: 'plank', count: 2 },
      skill: 'crafting',
      level: 0
    },
    {
      id: 'brick',
      name: 'Brick',
      inputs: [{ item: 'clay', count: 3 }],
      output: { item: 'brick', count: 2 },
      skill: 'crafting',
      level: 0
    },
    {
      id: 'iron_bar',
      name: 'Iron Bar',
      inputs: [{ item: 'iron_ore', count: 2 }, { item: 'wood', count: 1 }],
      output: { item: 'iron_bar', count: 1 },
      skill: 'smithing',
      level: 1
    },
    {
      id: 'rope',
      name: 'Rope',
      inputs: [{ item: 'silk', count: 3 }],
      output: { item: 'rope', count: 1 },
      skill: 'crafting',
      level: 0
    },
    {
      id: 'bread',
      name: 'Bread',
      inputs: [{ item: 'herbs', count: 2 }],
      output: { item: 'bread', count: 3 },
      skill: 'cooking',
      level: 0
    },
    {
      id: 'candle',
      name: 'Candle',
      inputs: [{ item: 'honey', count: 1 }, { item: 'silk', count: 1 }],
      output: { item: 'candle', count: 2 },
      skill: 'crafting',
      level: 0
    },
    {
      id: 'potion',
      name: 'Potion',
      inputs: [{ item: 'herbs', count: 3 }, { item: 'crystal', count: 1 }],
      output: { item: 'potion', count: 1 },
      skill: 'alchemy',
      level: 2
    },
    {
      id: 'glass',
      name: 'Glass',
      inputs: [{ item: 'stone', count: 2 }, { item: 'gold_dust', count: 1 }],
      output: { item: 'glass', count: 1 },
      skill: 'crafting',
      level: 1
    },
    {
      id: 'pickaxe',
      name: 'Pickaxe',
      inputs: [{ item: 'iron_bar', count: 2 }, { item: 'plank', count: 1 }],
      output: { item: 'pickaxe', count: 1 },
      skill: 'smithing',
      level: 2
    },
    {
      id: 'axe',
      name: 'Axe',
      inputs: [{ item: 'iron_bar', count: 1 }, { item: 'plank', count: 2 }],
      output: { item: 'axe', count: 1 },
      skill: 'smithing',
      level: 1
    },
    {
      id: 'fishing_rod',
      name: 'Fishing Rod',
      inputs: [{ item: 'plank', count: 2 }, { item: 'rope', count: 1 }],
      output: { item: 'fishing_rod', count: 1 },
      skill: 'crafting',
      level: 1
    },
    {
      id: 'compass',
      name: 'Compass',
      inputs: [
        { item: 'iron_bar', count: 1 },
        { item: 'glass', count: 1 },
        { item: 'gold_dust', count: 1 }
      ],
      output: { item: 'compass', count: 1 },
      skill: 'engineering',
      level: 3
    },
    {
      id: 'leather_armor',
      name: 'Leather Armor',
      inputs: [{ item: 'silk', count: 5 }, { item: 'iron_bar', count: 2 }],
      output: { item: 'leather_armor', count: 1 },
      skill: 'tailoring',
      level: 2
    },
    {
      id: 'iron_sword',
      name: 'Iron Sword',
      inputs: [{ item: 'iron_bar', count: 3 }, { item: 'plank', count: 1 }],
      output: { item: 'iron_sword', count: 1 },
      skill: 'smithing',
      level: 3
    },
    {
      id: 'telescope',
      name: 'Telescope',
      inputs: [
        { item: 'glass', count: 2 },
        { item: 'iron_bar', count: 1 },
        { item: 'gold_dust', count: 1 }
      ],
      output: { item: 'telescope', count: 1 },
      skill: 'engineering',
      level: 4
    },
    {
      id: 'gold_ring',
      name: 'Gold Ring',
      inputs: [{ item: 'gold_dust', count: 5 }],
      output: { item: 'gold_ring', count: 1 },
      skill: 'smithing',
      level: 3
    },
    {
      id: 'elixir',
      name: 'Elixir',
      inputs: [{ item: 'potion', count: 2 }, { item: 'star_fragment', count: 1 }],
      output: { item: 'elixir', count: 1 },
      skill: 'alchemy',
      level: 5
    },
    {
      id: 'crystal_staff',
      name: 'Crystal Staff',
      inputs: [
        { item: 'crystal', count: 3 },
        { item: 'plank', count: 1 },
        { item: 'gold_dust', count: 2 }
      ],
      output: { item: 'crystal_staff', count: 1 },
      skill: 'enchanting',
      level: 5
    },
    {
      id: 'scroll',
      name: 'Scroll',
      inputs: [{ item: 'feather', count: 2 }, { item: 'silk', count: 1 }],
      output: { item: 'scroll', count: 2 },
      skill: 'scribing',
      level: 1
    },
    {
      id: 'torch',
      name: 'Torch',
      inputs: [{ item: 'wood', count: 1 }, { item: 'honey', count: 1 }],
      output: { item: 'torch', count: 2 },
      skill: 'crafting',
      level: 0
    },
    {
      id: 'net',
      name: 'Net',
      inputs: [{ item: 'fiber', count: 4 }, { item: 'rope', count: 1 }],
      output: { item: 'net', count: 1 },
      skill: 'crafting',
      level: 1
    },
    {
      id: 'bowl',
      name: 'Bowl',
      inputs: [{ item: 'clay', count: 2 }],
      output: { item: 'bowl', count: 1 },
      skill: 'crafting',
      level: 0
    },
    {
      id: 'stew',
      name: 'Stew',
      inputs: [{ item: 'mushroom', count: 2 }, { item: 'herbs', count: 1 }],
      output: { item: 'stew', count: 1 },
      skill: 'cooking',
      level: 1
    },
    {
      id: 'tea',
      name: 'Tea',
      inputs: [{ item: 'herbs', count: 1 }],
      output: { item: 'tea', count: 2 },
      skill: 'cooking',
      level: 0
    },
    {
      id: 'ink',
      name: 'Ink',
      inputs: [{ item: 'mushroom', count: 1 }, { item: 'resin', count: 1 }],
      output: { item: 'ink', count: 2 },
      skill: 'scribing',
      level: 0
    },
    {
      id: 'dye',
      name: 'Dye',
      inputs: [{ item: 'herbs', count: 2 }, { item: 'crystal', count: 1 }],
      output: { item: 'dye', count: 3 },
      skill: 'crafting',
      level: 1
    }
  ];

  // ---------------------------------------------------------------------------
  // Rarity and Symbol Helpers
  // ---------------------------------------------------------------------------

  /**
   * Get the display color for a rarity level.
   * @param {string} rarity
   * @returns {string} CSS color string
   */
  function getRarityColor(rarity) {
    var colors = {
      common:    '#cccccc',
      uncommon:  '#2ecc71',
      rare:      '#3498db',
      epic:      '#9b59b6',
      legendary: '#f39c12'
    };
    return colors[rarity] || '#cccccc';
  }

  /**
   * Get the text symbol for an item category.
   * @param {string} category
   * @returns {string}
   */
  function getItemSymbol(category) {
    var symbols = {
      resource:   '[R]',
      tool:       '[T]',
      consumable: '[C]',
      crafted:    '[+]',
      equipment:  '[E]',
      collectible:'[*]'
    };
    return symbols[category] || '[?]';
  }

  // ---------------------------------------------------------------------------
  // Item Lookup
  // ---------------------------------------------------------------------------

  /**
   * Returns the full ITEM_CATALOG.
   * @returns {Object}
   */
  function getItemCatalog() {
    return ITEM_CATALOG;
  }

  /**
   * Get item details from the catalog by ID.
   * @param {string} itemId
   * @returns {Object|null}
   */
  function getItemInfo(itemId) {
    return ITEM_CATALOG[itemId] || null;
  }

  // ---------------------------------------------------------------------------
  // Recipe Lookup
  // ---------------------------------------------------------------------------

  /**
   * Returns all crafting recipes.
   * @returns {Array}
   */
  function getRecipes() {
    return RECIPES;
  }

  /**
   * Get a specific recipe by ID.
   * @param {string} recipeId
   * @returns {Object|null}
   */
  function getRecipeById(recipeId) {
    for (var i = 0; i < RECIPES.length; i++) {
      if (RECIPES[i].id === recipeId) return RECIPES[i];
    }
    return null;
  }

  // ---------------------------------------------------------------------------
  // Inventory State Management
  // ---------------------------------------------------------------------------

  /**
   * Create a fresh inventory state.
   * @returns {Object}
   */
  function createInventoryState() {
    return {
      items: {},
      equipped: {
        head:      null,
        body:      null,
        weapon:    null,
        accessory: null
      },
      skills: {}
    };
  }

  /**
   * Add items to inventory. Returns updated state (mutates in place).
   * @param {Object} state
   * @param {string} itemId
   * @param {number} count
   * @returns {Object}
   */
  function addItemToInventory(state, itemId, count) {
    if (!ITEM_CATALOG[itemId]) return state;
    var qty = count > 0 ? count : 0;
    if (qty === 0) return state;
    state.items[itemId] = (state.items[itemId] || 0) + qty;
    return state;
  }

  /**
   * Remove items from inventory.
   * @param {Object} state
   * @param {string} itemId
   * @param {number} count
   * @returns {{ success: boolean, state: Object, message: string }}
   */
  function removeItemFromInventory(state, itemId, count) {
    var have = state.items[itemId] || 0;
    if (have < count) {
      return {
        success: false,
        state: state,
        message: 'Not enough ' + (ITEM_CATALOG[itemId] ? ITEM_CATALOG[itemId].name : itemId) + ' (have ' + have + ', need ' + count + ')'
      };
    }
    state.items[itemId] = have - count;
    if (state.items[itemId] === 0) {
      delete state.items[itemId];
    }
    return { success: true, state: state, message: 'Removed ' + count + 'x ' + itemId };
  }

  // ---------------------------------------------------------------------------
  // Equipment System
  // ---------------------------------------------------------------------------

  /**
   * Equip an item to its designated slot.
   * @param {Object} state
   * @param {string} itemId
   * @returns {{ success: boolean, state: Object, previousItem: string|null, message: string }}
   */
  function equipItem(state, itemId) {
    var itemInfo = ITEM_CATALOG[itemId];
    if (!itemInfo) {
      return { success: false, state: state, previousItem: null, message: 'Unknown item: ' + itemId };
    }
    if (itemInfo.category !== 'equipment') {
      return { success: false, state: state, previousItem: null, message: itemInfo.name + ' is not equippable' };
    }
    if (!state.items[itemId] || state.items[itemId] < 1) {
      return { success: false, state: state, previousItem: null, message: 'You do not have ' + itemInfo.name + ' in your inventory' };
    }

    var slot = itemInfo.slot;
    if (!slot || !(slot in state.equipped)) {
      return { success: false, state: state, previousItem: null, message: 'No valid slot for ' + itemInfo.name };
    }

    var previousItem = state.equipped[slot];

    // Remove from inventory
    state.items[itemId] -= 1;
    if (state.items[itemId] === 0) delete state.items[itemId];

    // If something was equipped in that slot, return it to inventory
    if (previousItem) {
      state.items[previousItem] = (state.items[previousItem] || 0) + 1;
    }

    state.equipped[slot] = itemId;

    return {
      success: true,
      state: state,
      previousItem: previousItem,
      message: 'Equipped ' + itemInfo.name + (previousItem ? ' (replaced ' + previousItem + ')' : '')
    };
  }

  /**
   * Unequip an item from a slot.
   * @param {Object} state
   * @param {string} slot
   * @returns {{ success: boolean, state: Object, item: string|null, message: string }}
   */
  function unequipItem(state, slot) {
    if (!(slot in state.equipped)) {
      return { success: false, state: state, item: null, message: 'Invalid slot: ' + slot };
    }
    var itemId = state.equipped[slot];
    if (!itemId) {
      return { success: false, state: state, item: null, message: 'Nothing equipped in ' + slot };
    }
    state.equipped[slot] = null;
    state.items[itemId] = (state.items[itemId] || 0) + 1;
    return {
      success: true,
      state: state,
      item: itemId,
      message: 'Unequipped ' + (ITEM_CATALOG[itemId] ? ITEM_CATALOG[itemId].name : itemId)
    };
  }

  /**
   * Get aggregate stats from all equipped items.
   * @param {Object} equipped - The equipped object from inventory state
   * @returns {Object} - Merged stats object
   */
  function getEquipmentStats(equipped) {
    var stats = {};
    var slots = Object.keys(equipped);
    for (var i = 0; i < slots.length; i++) {
      var itemId = equipped[slots[i]];
      if (!itemId) continue;
      var itemInfo = ITEM_CATALOG[itemId];
      if (!itemInfo || !itemInfo.stats) continue;
      var statKeys = Object.keys(itemInfo.stats);
      for (var j = 0; j < statKeys.length; j++) {
        var key = statKeys[j];
        stats[key] = (stats[key] || 0) + itemInfo.stats[key];
      }
    }
    return stats;
  }

  // ---------------------------------------------------------------------------
  // Crafting Logic
  // ---------------------------------------------------------------------------

  /**
   * Check if a recipe can be crafted given current inventory and skills.
   * @param {string} recipeId
   * @param {Object} inventory - map of itemId â†’ quantity
   * @param {Object} skills - map of skillName â†’ level
   * @returns {{ craftable: boolean, missing: Array, skillRequired: Object|null }}
   */
  function canCraft(recipeId, inventory, skills) {
    var recipe = getRecipeById(recipeId);
    if (!recipe) {
      return { craftable: false, missing: [], skillRequired: null };
    }

    var missing = [];
    for (var i = 0; i < recipe.inputs.length; i++) {
      var input = recipe.inputs[i];
      var have = (inventory && inventory[input.item]) ? inventory[input.item] : 0;
      if (have < input.count) {
        missing.push({ item: input.item, need: input.count, have: have });
      }
    }

    var skillRequired = null;
    var playerLevel = (skills && skills[recipe.skill]) ? skills[recipe.skill] : 0;
    if (playerLevel < recipe.level) {
      skillRequired = { skill: recipe.skill, level: recipe.level, playerLevel: playerLevel };
    }

    return {
      craftable: missing.length === 0 && skillRequired === null,
      missing: missing,
      skillRequired: skillRequired
    };
  }

  /**
   * Attempt to craft an item. Consumes inputs and produces output.
   * @param {string} recipeId
   * @param {Object} inventory - map of itemId â†’ quantity (mutated)
   * @param {Object} skills - map of skillName â†’ level
   * @returns {{ success: boolean, item: string|null, quantity: number, message: string }}
   */
  function craftItem(recipeId, inventory, skills) {
    var check = canCraft(recipeId, inventory, skills);
    if (!check.craftable) {
      if (check.skillRequired) {
        return {
          success: false,
          item: null,
          quantity: 0,
          message: 'Requires ' + check.skillRequired.skill + ' level ' + check.skillRequired.level + ' (you have ' + check.skillRequired.playerLevel + ')'
        };
      }
      var missingText = check.missing.map(function(m) {
        return m.item + ' (have ' + m.have + ', need ' + m.need + ')';
      }).join(', ');
      return {
        success: false,
        item: null,
        quantity: 0,
        message: 'Missing materials: ' + missingText
      };
    }

    var recipe = getRecipeById(recipeId);

    // Consume inputs
    for (var i = 0; i < recipe.inputs.length; i++) {
      var input = recipe.inputs[i];
      inventory[input.item] -= input.count;
      if (inventory[input.item] === 0) delete inventory[input.item];
    }

    // Produce output
    var outputItem = recipe.output.item;
    var outputCount = recipe.output.count;
    inventory[outputItem] = (inventory[outputItem] || 0) + outputCount;

    var itemInfo = ITEM_CATALOG[outputItem];
    var itemName = itemInfo ? itemInfo.name : outputItem;

    return {
      success: true,
      item: outputItem,
      quantity: outputCount,
      message: 'Crafted ' + outputCount + 'x ' + itemName
    };
  }

  // ---------------------------------------------------------------------------
  // Filtering and Sorting
  // ---------------------------------------------------------------------------

  /**
   * Filter inventory items by category.
   * @param {Object} inventory - map of itemId â†’ quantity
   * @param {string} category - 'all' or a category name
   * @returns {Array} - array of { id, quantity, info } objects
   */
  function getItemsByCategory(inventory, category) {
    var result = [];
    var keys = Object.keys(inventory || {});
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      var info = ITEM_CATALOG[id];
      if (!info) continue;
      if (category === 'all' || !category || info.category === category) {
        result.push({ id: id, quantity: inventory[id], info: info });
      }
    }
    return result;
  }

  // Rarity order for sorting
  var RARITY_ORDER = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };

  /**
   * Sort an array of { id, quantity, info } items.
   * @param {Array} items
   * @param {string} sortBy - 'name', 'value', 'rarity', 'quantity'
   * @returns {Array}
   */
  function sortItems(items, sortBy) {
    var sorted = items.slice();
    sorted.sort(function(a, b) {
      switch (sortBy) {
        case 'name':
          return a.info.name.localeCompare(b.info.name);
        case 'value':
          return b.info.value - a.info.value;
        case 'rarity':
          return (RARITY_ORDER[b.info.rarity] || 0) - (RARITY_ORDER[a.info.rarity] || 0);
        case 'quantity':
          return b.quantity - a.quantity;
        default:
          return 0;
      }
    });
    return sorted;
  }

  // ---------------------------------------------------------------------------
  // Value Calculation
  // ---------------------------------------------------------------------------

  /**
   * Calculate total value of all items in inventory.
   * @param {Object} inventory - map of itemId â†’ quantity
   * @returns {number}
   */
  function calculateInventoryValue(inventory) {
    var total = 0;
    var keys = Object.keys(inventory || {});
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      var info = ITEM_CATALOG[id];
      if (!info) continue;
      total += info.value * inventory[id];
    }
    return total;
  }

  // ---------------------------------------------------------------------------
  // HTML Formatting
  // ---------------------------------------------------------------------------

  /**
   * Format an item slot for the grid view.
   * @param {string} itemId
   * @param {number} quantity
   * @param {boolean} selected
   * @returns {string} HTML string
   */
  function formatItemSlot(itemId, quantity, selected) {
    var info = ITEM_CATALOG[itemId];
    if (!info) return '<div class="inv-slot inv-slot--empty"></div>';

    var rarityColor = getRarityColor(info.rarity);
    var symbol = getItemSymbol(info.category);
    var border = selected ? '2px solid #f0c040' : '2px solid ' + rarityColor;
    var selectedClass = selected ? ' inv-slot--selected' : '';

    return '<div class="inv-slot' + selectedClass + '" data-item="' + itemId + '" style="border:' + border + ';padding:4px;display:inline-block;text-align:center;min-width:60px;background:#1a1a2e;">' +
      '<div class="inv-slot__symbol" style="font-size:1.2em;color:' + rarityColor + ';">' + symbol + '</div>' +
      '<div class="inv-slot__name" style="font-size:0.75em;color:#ccc;">' + info.name + '</div>' +
      '<div class="inv-slot__qty" style="font-size:0.7em;color:#aaa;">x' + quantity + '</div>' +
    '</div>';
  }

  /**
   * Format a recipe card for the crafting view.
   * @param {Object} recipe
   * @param {Object} inventory - map of itemId â†’ quantity
   * @param {Object} skills - map of skillName â†’ level
   * @returns {string} HTML string
   */
  function formatRecipeCard(recipe, inventory, skills) {
    var check = canCraft(recipe.id, inventory, skills);
    var outputInfo = ITEM_CATALOG[recipe.output.item];
    var outputName = outputInfo ? outputInfo.name : recipe.output.item;
    var outputSymbol = outputInfo ? getItemSymbol(outputInfo.category) : '[?]';
    var outputColor = outputInfo ? getRarityColor(outputInfo.rarity) : '#cccccc';
    var craftableClass = check.craftable ? 'craftable' : 'not-craftable';
    var btnDisabled = check.craftable ? '' : ' disabled';

    var inputsHtml = '';
    for (var i = 0; i < recipe.inputs.length; i++) {
      var input = recipe.inputs[i];
      var have = (inventory && inventory[input.item]) ? inventory[input.item] : 0;
      var enoughColor = have >= input.count ? '#2ecc71' : '#e74c3c';
      var inputInfo = ITEM_CATALOG[input.item];
      var inputName = inputInfo ? inputInfo.name : input.item;
      inputsHtml += '<span class="recipe-input" style="color:' + enoughColor + ';">' +
        inputName + ' (' + have + '/' + input.count + ')' +
      '</span> ';
    }

    var skillHtml = '';
    if (recipe.level > 0) {
      var playerSkillLevel = (skills && skills[recipe.skill]) ? skills[recipe.skill] : 0;
      var skillColor = playerSkillLevel >= recipe.level ? '#2ecc71' : '#e74c3c';
      skillHtml = '<div class="recipe-skill" style="font-size:0.75em;color:' + skillColor + ';">' +
        recipe.skill + ' lv.' + recipe.level + ' (you: ' + playerSkillLevel + ')' +
      '</div>';
    }

    return '<div class="recipe-card ' + craftableClass + '" data-recipe="' + recipe.id + '" style="border:1px solid #333;padding:6px;margin-bottom:4px;background:#111;">' +
      '<div class="recipe-output" style="font-weight:bold;color:' + outputColor + ';">' +
        outputSymbol + ' ' + outputName + ' x' + recipe.output.count +
      '</div>' +
      '<div class="recipe-inputs" style="font-size:0.8em;margin-top:4px;">' + inputsHtml + '</div>' +
      skillHtml +
      '<button class="recipe-craft-btn" data-recipe="' + recipe.id + '"' + btnDisabled + ' style="margin-top:4px;">[Craft]</button>' +
    '</div>';
  }

  // ---------------------------------------------------------------------------
  // Panel DOM Creation
  // ---------------------------------------------------------------------------

  /**
   * Create the full inventory panel DOM element.
   * Works in browser only; returns null in Node.js.
   * @returns {HTMLElement|null}
   */
  function createInventoryPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.className = 'dashboard-inventory-panel';
    panel.style.cssText = 'font-family:monospace;background:#0a0a14;color:#ccc;padding:12px;height:100%;overflow:auto;';

    panel.innerHTML =
      '<div class="inv-header" style="font-size:1.1em;font-weight:bold;color:#f0c040;margin-bottom:8px;">Inventory &amp; Crafting</div>' +
      '<div class="inv-tabs" style="display:flex;gap:4px;margin-bottom:8px;">' +
        '<button class="inv-tab inv-tab--active" data-tab="items" style="background:#222;border:1px solid #f0c040;color:#f0c040;padding:4px 10px;cursor:pointer;">[Items]</button>' +
        '<button class="inv-tab" data-tab="crafting" style="background:#111;border:1px solid #555;color:#aaa;padding:4px 10px;cursor:pointer;">[Crafting]</button>' +
        '<button class="inv-tab" data-tab="equipment" style="background:#111;border:1px solid #555;color:#aaa;padding:4px 10px;cursor:pointer;">[Equipment]</button>' +
      '</div>' +
      '<div class="inv-tab-content" id="inv-tab-items">' +
        '<div class="inv-filters" style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px;">' +
          '<button class="inv-filter inv-filter--active" data-filter="all">All</button>' +
          '<button class="inv-filter" data-filter="resource">Resources</button>' +
          '<button class="inv-filter" data-filter="tool">Tools</button>' +
          '<button class="inv-filter" data-filter="consumable">Consumables</button>' +
          '<button class="inv-filter" data-filter="crafted">Crafted</button>' +
          '<button class="inv-filter" data-filter="equipment">Equipment</button>' +
          '<button class="inv-filter" data-filter="collectible">Collectibles</button>' +
        '</div>' +
        '<div class="inv-sort" style="margin-bottom:8px;">' +
          'Sort: ' +
          '<button class="inv-sort-btn" data-sort="name">Name</button>' +
          '<button class="inv-sort-btn" data-sort="value">Value</button>' +
          '<button class="inv-sort-btn" data-sort="rarity">Rarity</button>' +
          '<button class="inv-sort-btn" data-sort="quantity">Quantity</button>' +
        '</div>' +
        '<div class="inv-grid" style="display:flex;flex-wrap:wrap;gap:4px;">' +
          '<div class="inv-empty" style="color:#555;font-size:0.85em;">No items. Explore ZION to gather resources.</div>' +
        '</div>' +
      '</div>' +
      '<div class="inv-tab-content" id="inv-tab-crafting" style="display:none;">' +
        '<div class="inv-recipes">' +
          '<div class="inv-empty" style="color:#555;font-size:0.85em;">Gather materials to unlock crafting.</div>' +
        '</div>' +
      '</div>' +
      '<div class="inv-tab-content" id="inv-tab-equipment" style="display:none;">' +
        '<div class="inv-equipment-slots" style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">' +
          '<div class="equip-slot" data-slot="head" style="border:1px solid #333;padding:6px;background:#111;">' +
            '<div style="color:#888;font-size:0.75em;">HEAD</div><div class="equip-item" style="color:#555;">-- empty --</div>' +
          '</div>' +
          '<div class="equip-slot" data-slot="body" style="border:1px solid #333;padding:6px;background:#111;">' +
            '<div style="color:#888;font-size:0.75em;">BODY</div><div class="equip-item" style="color:#555;">-- empty --</div>' +
          '</div>' +
          '<div class="equip-slot" data-slot="weapon" style="border:1px solid #333;padding:6px;background:#111;">' +
            '<div style="color:#888;font-size:0.75em;">WEAPON</div><div class="equip-item" style="color:#555;">-- empty --</div>' +
          '</div>' +
          '<div class="equip-slot" data-slot="accessory" style="border:1px solid #333;padding:6px;background:#111;">' +
            '<div style="color:#888;font-size:0.75em;">ACCESSORY</div><div class="equip-item" style="color:#555;">-- empty --</div>' +
          '</div>' +
        '</div>' +
        '<div class="equip-stats" style="margin-top:8px;border:1px solid #333;padding:6px;background:#111;">' +
          '<div style="color:#f0c040;font-size:0.85em;margin-bottom:4px;">STATS</div>' +
          '<div class="equip-stats-content" style="color:#aaa;font-size:0.8em;">No equipment worn.</div>' +
        '</div>' +
      '</div>';

    _wireTabSwitching(panel);

    return panel;
  }

  /**
   * Wire tab switching logic on the panel.
   * @param {HTMLElement} panel
   */
  function _wireTabSwitching(panel) {
    var tabs = panel.querySelectorAll('.inv-tab');
    for (var i = 0; i < tabs.length; i++) {
      (function(tab) {
        tab.addEventListener('click', function() {
          var targetTab = tab.getAttribute('data-tab');
          // Update tab button styles
          var allTabs = panel.querySelectorAll('.inv-tab');
          for (var j = 0; j < allTabs.length; j++) {
            allTabs[j].style.background = '#111';
            allTabs[j].style.borderColor = '#555';
            allTabs[j].style.color = '#aaa';
            allTabs[j].classList.remove('inv-tab--active');
          }
          tab.style.background = '#222';
          tab.style.borderColor = '#f0c040';
          tab.style.color = '#f0c040';
          tab.classList.add('inv-tab--active');

          // Show/hide content panels
          var contents = panel.querySelectorAll('.inv-tab-content');
          for (var k = 0; k < contents.length; k++) {
            contents[k].style.display = 'none';
          }
          var target = panel.querySelector('#inv-tab-' + targetTab);
          if (target) target.style.display = 'block';
        });
      })(tabs[i]);
    }
  }

  // ---------------------------------------------------------------------------
  // Exports
  // ---------------------------------------------------------------------------

  exports.ITEM_CATALOG              = ITEM_CATALOG;
  exports.RECIPES                   = RECIPES;

  exports.createInventoryPanel      = createInventoryPanel;
  exports.getItemCatalog            = getItemCatalog;
  exports.getItemInfo               = getItemInfo;
  exports.getRecipes                = getRecipes;
  exports.getRecipeById             = getRecipeById;
  exports.canCraft                  = canCraft;
  exports.craftItem                 = craftItem;
  exports.formatItemSlot            = formatItemSlot;
  exports.formatRecipeCard          = formatRecipeCard;
  exports.getItemsByCategory        = getItemsByCategory;
  exports.sortItems                 = sortItems;
  exports.getRarityColor            = getRarityColor;
  exports.getItemSymbol             = getItemSymbol;
  exports.calculateInventoryValue   = calculateInventoryValue;
  exports.getEquipmentStats         = getEquipmentStats;
  exports.createInventoryState      = createInventoryState;
  exports.addItemToInventory        = addItemToInventory;
  exports.removeItemFromInventory   = removeItemFromInventory;
  exports.equipItem                 = equipItem;
  exports.unequipItem               = unequipItem;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardInventory = {}));


// dashboard_economy.js
// dashboard_economy.js
/**
 * ZION Dashboard Economy Module
 * Economy & Trading panel for UI-only (dashboard) mode.
 * Manages Spark balance, market listings, transaction history, and stats.
 * Layer: standalone (no required project dependencies)
 */

(function(exports) {
  'use strict';

  // =========================================================================
  // CONSTANTS
  // =========================================================================

  var DEFAULT_BALANCE = 100;
  var LISTING_FEE_RATE = 0.05;
  var MINIMUM_LISTING_FEE = 1;
  var TREASURY_ID = '__treasury__';
  var MS_PER_DAY = 86400000;

  var WEALTH_BRACKETS = [0, 50, 100, 250, 500, 1000, 5000, Infinity];

  // =========================================================================
  // STATE
  // =========================================================================

  /**
   * Returns a fresh economy state object.
   * @returns {Object} Economy state
   */
  function createEconomyState() {
    return {
      balances: {},
      transactions: [],
      listings: [],
      nextListingId: 1,
      treasury: 1000000,
      ubiHistory: [],
      taxHistory: [],
      dailyStats: []
    };
  }

  // =========================================================================
  // BALANCE OPERATIONS
  // =========================================================================

  /**
   * Returns a player's Spark balance (default 100 for new players).
   * @param {Object} state
   * @param {string} playerId
   * @returns {number}
   */
  function getBalance(state, playerId) {
    if (!state || !state.balances) return DEFAULT_BALANCE;
    if (state.balances[playerId] === undefined) return DEFAULT_BALANCE;
    return state.balances[playerId];
  }

  /**
   * Add Spark to a player's balance and log the transaction.
   * @param {Object} state
   * @param {string} playerId
   * @param {number} amount
   * @param {string} reason
   * @returns {Object} Updated state (mutated in place)
   */
  function earnSpark(state, playerId, amount, reason) {
    if (!state || !playerId || typeof amount !== 'number' || amount <= 0) {
      return state;
    }
    if (state.balances[playerId] === undefined) {
      state.balances[playerId] = DEFAULT_BALANCE;
    }
    state.balances[playerId] += amount;
    state.transactions.push({
      id: 'tx_' + Date.now() + '_' + Math.random().toString(36).slice(2),
      type: 'earn',
      playerId: playerId,
      amount: amount,
      reason: reason || '',
      timestamp: Date.now(),
      counterparty: null
    });
    return state;
  }

  /**
   * Deduct Spark from a player's balance.
   * Fails if insufficient funds.
   * @param {Object} state
   * @param {string} playerId
   * @param {number} amount
   * @param {string} reason
   * @returns {{ success: boolean, state: Object, message: string }}
   */
  function spendSpark(state, playerId, amount, reason) {
    if (!state || !playerId || typeof amount !== 'number' || amount <= 0) {
      return { success: false, state: state, message: 'Invalid arguments' };
    }
    var balance = getBalance(state, playerId);
    if (balance < amount) {
      return { success: false, state: state, message: 'Insufficient funds' };
    }
    if (state.balances[playerId] === undefined) {
      state.balances[playerId] = DEFAULT_BALANCE;
    }
    state.balances[playerId] -= amount;
    state.transactions.push({
      id: 'tx_' + Date.now() + '_' + Math.random().toString(36).slice(2),
      type: 'spend',
      playerId: playerId,
      amount: -amount,
      reason: reason || '',
      timestamp: Date.now(),
      counterparty: null
    });
    return { success: true, state: state, message: 'OK' };
  }

  /**
   * Transfer Spark from one player to another.
   * @param {Object} state
   * @param {string} fromId
   * @param {string} toId
   * @param {number} amount
   * @param {string} reason
   * @returns {{ success: boolean, state: Object, message: string }}
   */
  function transferSpark(state, fromId, toId, amount, reason) {
    if (!state || !fromId || !toId || typeof amount !== 'number' || amount <= 0) {
      return { success: false, state: state, message: 'Invalid arguments' };
    }
    var senderBalance = getBalance(state, fromId);
    if (senderBalance < amount) {
      return { success: false, state: state, message: 'Insufficient funds' };
    }
    if (state.balances[fromId] === undefined) {
      state.balances[fromId] = DEFAULT_BALANCE;
    }
    if (state.balances[toId] === undefined) {
      state.balances[toId] = DEFAULT_BALANCE;
    }
    state.balances[fromId] -= amount;
    state.balances[toId] += amount;
    var ts = Date.now();
    var txBase = 'tx_' + ts + '_' + Math.random().toString(36).slice(2);
    // Debit transaction (for sender)
    state.transactions.push({
      id: txBase + '_debit',
      type: 'transfer_out',
      playerId: fromId,
      amount: -amount,
      reason: reason || '',
      timestamp: ts,
      counterparty: toId
    });
    // Credit transaction (for recipient)
    state.transactions.push({
      id: txBase + '_credit',
      type: 'transfer_in',
      playerId: toId,
      amount: amount,
      reason: reason || '',
      timestamp: ts,
      counterparty: fromId
    });
    return { success: true, state: state, message: 'OK' };
  }

  // =========================================================================
  // MARKET LISTINGS
  // =========================================================================

  /**
   * Create a market listing. Charges a listing fee (5% of total price, minimum 1 Spark).
   * @param {Object} state
   * @param {string} sellerId
   * @param {string} itemId
   * @param {number} quantity
   * @param {number} pricePerUnit
   * @returns {{ success: boolean, state: Object, listing: Object|null, fee: number, message: string }}
   */
  function createListing(state, sellerId, itemId, quantity, pricePerUnit) {
    if (!state || !sellerId || !itemId ||
        typeof quantity !== 'number' || quantity <= 0 ||
        typeof pricePerUnit !== 'number' || pricePerUnit <= 0) {
      return { success: false, state: state, listing: null, fee: 0, message: 'Invalid arguments' };
    }
    var totalPrice = quantity * pricePerUnit;
    var fee = Math.max(MINIMUM_LISTING_FEE, Math.floor(totalPrice * LISTING_FEE_RATE));
    var balance = getBalance(state, sellerId);
    if (balance < fee) {
      return { success: false, state: state, listing: null, fee: fee, message: 'Insufficient funds for listing fee' };
    }
    // Charge the fee
    if (state.balances[sellerId] === undefined) {
      state.balances[sellerId] = DEFAULT_BALANCE;
    }
    state.balances[sellerId] -= fee;
    state.treasury += fee;
    state.transactions.push({
      id: 'tx_' + Date.now() + '_' + Math.random().toString(36).slice(2),
      type: 'listing_fee',
      playerId: sellerId,
      amount: -fee,
      reason: 'Listing fee for ' + itemId,
      timestamp: Date.now(),
      counterparty: TREASURY_ID
    });
    var listing = {
      id: 'listing_' + state.nextListingId++,
      sellerId: sellerId,
      itemId: itemId,
      quantity: quantity,
      pricePerUnit: pricePerUnit,
      createdAt: Date.now(),
      active: true
    };
    state.listings.push(listing);
    return { success: true, state: state, listing: listing, fee: fee, message: 'OK' };
  }

  /**
   * Buy from a market listing. Partial buys allowed.
   * @param {Object} state
   * @param {string} buyerId
   * @param {string} listingId
   * @param {number} quantity
   * @returns {{ success: boolean, state: Object, cost: number, items: number, message: string }}
   */
  function buyListing(state, buyerId, listingId, quantity) {
    if (!state || !buyerId || !listingId || typeof quantity !== 'number' || quantity <= 0) {
      return { success: false, state: state, cost: 0, items: 0, message: 'Invalid arguments' };
    }
    var listing = null;
    for (var i = 0; i < state.listings.length; i++) {
      if (state.listings[i].id === listingId) {
        listing = state.listings[i];
        break;
      }
    }
    if (!listing) {
      return { success: false, state: state, cost: 0, items: 0, message: 'Listing not found' };
    }
    if (!listing.active) {
      return { success: false, state: state, cost: 0, items: 0, message: 'Listing is not active' };
    }
    // Buyer cannot buy own listing
    if (listing.sellerId === buyerId) {
      return { success: false, state: state, cost: 0, items: 0, message: 'Cannot buy your own listing' };
    }
    var buyQty = Math.min(quantity, listing.quantity);
    var cost = buyQty * listing.pricePerUnit;
    var buyerBalance = getBalance(state, buyerId);
    if (buyerBalance < cost) {
      return { success: false, state: state, cost: cost, items: 0, message: 'Insufficient funds' };
    }
    if (state.balances[buyerId] === undefined) {
      state.balances[buyerId] = DEFAULT_BALANCE;
    }
    if (state.balances[listing.sellerId] === undefined) {
      state.balances[listing.sellerId] = DEFAULT_BALANCE;
    }
    // Transfer Spark from buyer to seller
    state.balances[buyerId] -= cost;
    state.balances[listing.sellerId] += cost;
    var ts = Date.now();
    var txBase = 'tx_' + ts + '_' + Math.random().toString(36).slice(2);
    state.transactions.push({
      id: txBase + '_buy',
      type: 'market_buy',
      playerId: buyerId,
      amount: -cost,
      reason: 'Purchase: ' + buyQty + 'x ' + listing.itemId,
      timestamp: ts,
      counterparty: listing.sellerId
    });
    state.transactions.push({
      id: txBase + '_sell',
      type: 'market_sell',
      playerId: listing.sellerId,
      amount: cost,
      reason: 'Sale: ' + buyQty + 'x ' + listing.itemId,
      timestamp: ts,
      counterparty: buyerId
    });
    // Reduce listing quantity
    listing.quantity -= buyQty;
    if (listing.quantity <= 0) {
      listing.active = false;
    }
    return { success: true, state: state, cost: cost, items: buyQty, message: 'OK' };
  }

  /**
   * Cancel a market listing. No refund on listing fee.
   * @param {Object} state
   * @param {string} sellerId
   * @param {string} listingId
   * @returns {{ success: boolean, state: Object, message: string }}
   */
  function cancelListing(state, sellerId, listingId) {
    if (!state || !sellerId || !listingId) {
      return { success: false, state: state, message: 'Invalid arguments' };
    }
    var listing = null;
    for (var i = 0; i < state.listings.length; i++) {
      if (state.listings[i].id === listingId) {
        listing = state.listings[i];
        break;
      }
    }
    if (!listing) {
      return { success: false, state: state, message: 'Listing not found' };
    }
    if (listing.sellerId !== sellerId) {
      return { success: false, state: state, message: 'Not your listing' };
    }
    if (!listing.active) {
      return { success: false, state: state, message: 'Listing already inactive' };
    }
    listing.active = false;
    return { success: true, state: state, message: 'OK' };
  }

  /**
   * Get filtered and sorted market listings (active only by default).
   * @param {Object} state
   * @param {Object} [filters] - { itemId, sellerId, minPrice, maxPrice, sortBy: 'price'|'date'|'quantity' }
   * @returns {Array}
   */
  function getListings(state, filters) {
    if (!state || !state.listings) return [];
    filters = filters || {};
    var results = [];
    for (var i = 0; i < state.listings.length; i++) {
      var l = state.listings[i];
      if (!l.active) continue;
      if (filters.itemId && l.itemId !== filters.itemId) continue;
      if (filters.sellerId && l.sellerId !== filters.sellerId) continue;
      if (typeof filters.minPrice === 'number' && l.pricePerUnit < filters.minPrice) continue;
      if (typeof filters.maxPrice === 'number' && l.pricePerUnit > filters.maxPrice) continue;
      results.push(l);
    }
    var sortBy = filters.sortBy || 'date';
    results.sort(function(a, b) {
      if (sortBy === 'price') return a.pricePerUnit - b.pricePerUnit;
      if (sortBy === 'quantity') return b.quantity - a.quantity;
      // default: date descending
      return b.createdAt - a.createdAt;
    });
    return results;
  }

  // =========================================================================
  // TRANSACTION HISTORY
  // =========================================================================

  /**
   * Get the last N transactions for a player.
   * @param {Object} state
   * @param {string} playerId
   * @param {number} [limit=50]
   * @returns {Array}
   */
  function getTransactionHistory(state, playerId, limit) {
    if (!state || !state.transactions || !playerId) return [];
    limit = (typeof limit === 'number' && limit > 0) ? limit : 50;
    var results = [];
    for (var i = 0; i < state.transactions.length; i++) {
      if (state.transactions[i].playerId === playerId) {
        results.push(state.transactions[i]);
      }
    }
    // Sort by timestamp descending
    results.sort(function(a, b) { return b.timestamp - a.timestamp; });
    return results.slice(0, limit);
  }

  /**
   * Sum of earnings (positive amounts) in the last 24 hours for a player.
   * @param {Object} state
   * @param {string} playerId
   * @returns {number}
   */
  function calculateDailyIncome(state, playerId) {
    if (!state || !state.transactions || !playerId) return 0;
    var cutoff = Date.now() - MS_PER_DAY;
    var total = 0;
    for (var i = 0; i < state.transactions.length; i++) {
      var tx = state.transactions[i];
      if (tx.playerId === playerId && tx.timestamp >= cutoff && tx.amount > 0) {
        total += tx.amount;
      }
    }
    return total;
  }

  /**
   * Sum of spending (negative amounts) in the last 24 hours for a player.
   * Returns a positive number representing total spent.
   * @param {Object} state
   * @param {string} playerId
   * @returns {number}
   */
  function calculateDailyExpenses(state, playerId) {
    if (!state || !state.transactions || !playerId) return 0;
    var cutoff = Date.now() - MS_PER_DAY;
    var total = 0;
    for (var i = 0; i < state.transactions.length; i++) {
      var tx = state.transactions[i];
      if (tx.playerId === playerId && tx.timestamp >= cutoff && tx.amount < 0) {
        total += Math.abs(tx.amount);
      }
    }
    return total;
  }

  // =========================================================================
  // ECONOMY STATISTICS
  // =========================================================================

  /**
   * Compute Gini coefficient from an array of balance values.
   * 0 = perfect equality, 1 = maximum inequality.
   * @param {Array<number>} balances
   * @returns {number}
   */
  function calculateGiniCoefficient(balances) {
    if (!balances || balances.length === 0) return 0;
    var n = balances.length;
    if (n === 1) return 0;
    // Sort ascending
    var sorted = balances.slice().sort(function(a, b) { return a - b; });
    // Clamp negatives to 0 for Gini calculation
    for (var i = 0; i < sorted.length; i++) {
      if (sorted[i] < 0) sorted[i] = 0;
    }
    var sumOfAbsDiff = 0;
    var sumAll = 0;
    for (var i = 0; i < n; i++) {
      sumAll += sorted[i];
      for (var j = 0; j < n; j++) {
        sumOfAbsDiff += Math.abs(sorted[i] - sorted[j]);
      }
    }
    if (sumAll === 0) return 0;
    return sumOfAbsDiff / (2 * n * sumAll);
  }

  /**
   * Returns economy-wide statistics.
   * @param {Object} state
   * @returns {{ totalCirculation: number, averageWealth: number, medianWealth: number, giniCoefficient: number, activeTraders: number, totalListings: number, totalTransactions: number }}
   */
  function getEconomyStats(state) {
    if (!state) {
      return {
        totalCirculation: 0,
        averageWealth: 0,
        medianWealth: 0,
        giniCoefficient: 0,
        activeTraders: 0,
        totalListings: 0,
        totalTransactions: 0
      };
    }
    var playerBalances = [];
    var totalCirculation = 0;
    for (var pid in state.balances) {
      if (pid === TREASURY_ID) continue;
      var bal = state.balances[pid];
      playerBalances.push(bal);
      totalCirculation += bal;
    }
    var n = playerBalances.length;
    var avgWealth = n > 0 ? totalCirculation / n : 0;
    var medianWealth = 0;
    if (n > 0) {
      var sorted = playerBalances.slice().sort(function(a, b) { return a - b; });
      if (n % 2 === 0) {
        medianWealth = (sorted[n / 2 - 1] + sorted[n / 2]) / 2;
      } else {
        medianWealth = sorted[Math.floor(n / 2)];
      }
    }
    var gini = calculateGiniCoefficient(playerBalances);
    var activeListings = 0;
    var activeSellers = {};
    for (var i = 0; i < state.listings.length; i++) {
      if (state.listings[i].active) {
        activeListings++;
        activeSellers[state.listings[i].sellerId] = true;
      }
    }
    return {
      totalCirculation: totalCirculation,
      averageWealth: avgWealth,
      medianWealth: medianWealth,
      giniCoefficient: gini,
      activeTraders: Object.keys(activeSellers).length,
      totalListings: activeListings,
      totalTransactions: state.transactions.length
    };
  }

  /**
   * Group players into wealth distribution brackets.
   * @param {Object} state
   * @param {Array<number>} [brackets]
   * @returns {Array<{bracket: string, count: number, min: number, max: number}>}
   */
  function getWealthDistribution(state, brackets) {
    brackets = brackets || WEALTH_BRACKETS;
    var result = [];
    for (var i = 0; i < brackets.length - 1; i++) {
      var min = brackets[i];
      var max = brackets[i + 1];
      var label = max === Infinity
        ? (min + '+')
        : (min + '-' + (max - 1));
      result.push({ bracket: label, count: 0, min: min, max: max });
    }
    if (!state || !state.balances) return result;
    for (var pid in state.balances) {
      if (pid === TREASURY_ID) continue;
      var bal = state.balances[pid];
      for (var j = 0; j < result.length; j++) {
        var br = result[j];
        if (bal >= br.min && (br.max === Infinity || bal < br.max)) {
          br.count++;
          break;
        }
      }
    }
    return result;
  }

  // =========================================================================
  // UBI & WEALTH TAX
  // =========================================================================

  /**
   * Distribute equal UBI to all known players from treasury.
   * @param {Object} state
   * @param {number} amount  Amount per player
   * @param {number} [timestamp]
   * @returns {{ success: boolean, state: Object, perPlayer: number, recipients: number }}
   */
  function distributeUBI(state, amount, timestamp) {
    if (!state || typeof amount !== 'number' || amount <= 0) {
      return { success: false, state: state, perPlayer: 0, recipients: 0 };
    }
    var ts = timestamp || Date.now();
    var players = [];
    for (var pid in state.balances) {
      if (pid !== TREASURY_ID) players.push(pid);
    }
    if (players.length === 0) {
      return { success: true, state: state, perPlayer: amount, recipients: 0 };
    }
    var totalNeeded = amount * players.length;
    if (state.treasury < totalNeeded) {
      return { success: false, state: state, perPlayer: amount, recipients: 0, message: 'Insufficient treasury' };
    }
    state.treasury -= totalNeeded;
    for (var i = 0; i < players.length; i++) {
      state.balances[players[i]] += amount;
      state.transactions.push({
        id: 'tx_ubi_' + ts + '_' + players[i],
        type: 'ubi',
        playerId: players[i],
        amount: amount,
        reason: 'UBI distribution',
        timestamp: ts,
        counterparty: TREASURY_ID
      });
    }
    state.ubiHistory.push({ timestamp: ts, perPlayer: amount, recipients: players.length });
    return { success: true, state: state, perPlayer: amount, recipients: players.length };
  }

  /**
   * Tax balances above threshold at given rate. Transfer taxed amount to treasury.
   * @param {Object} state
   * @param {number} threshold
   * @param {number} rate
   * @param {number} [timestamp]
   * @returns {{ success: boolean, state: Object, taxed: Array<{playerId: string, amount: number}> }}
   */
  function applyWealthTax(state, threshold, rate, timestamp) {
    if (!state || typeof threshold !== 'number' || typeof rate !== 'number') {
      return { success: false, state: state, taxed: [] };
    }
    var ts = timestamp || Date.now();
    var taxed = [];
    for (var pid in state.balances) {
      if (pid === TREASURY_ID) continue;
      var bal = state.balances[pid];
      if (bal > threshold) {
        var excess = bal - threshold;
        var taxAmount = Math.floor(excess * rate);
        if (taxAmount <= 0) continue;
        state.balances[pid] -= taxAmount;
        state.treasury += taxAmount;
        taxed.push({ playerId: pid, amount: taxAmount });
        state.transactions.push({
          id: 'tx_tax_' + ts + '_' + pid,
          type: 'wealth_tax',
          playerId: pid,
          amount: -taxAmount,
          reason: 'Wealth tax (threshold: ' + threshold + ', rate: ' + (rate * 100) + '%)',
          timestamp: ts,
          counterparty: TREASURY_ID
        });
      }
    }
    state.taxHistory.push({ timestamp: ts, threshold: threshold, rate: rate, taxed: taxed });
    return { success: true, state: state, taxed: taxed };
  }

  // =========================================================================
  // FORMATTING
  // =========================================================================

  /**
   * Render an ASCII bar chart segment showing a percentage.
   * @param {number} value  0-100
   * @param {number} [width=20]
   * @returns {string}  e.g. "[####      ] 40%"
   */
  function _asciiBar(value, width) {
    width = width || 20;
    value = Math.max(0, Math.min(100, value));
    var filled = Math.round((value / 100) * width);
    var empty = width - filled;
    var bar = '[';
    for (var i = 0; i < filled; i++) bar += '#';
    for (var j = 0; j < empty; j++) bar += ' ';
    bar += '] ' + Math.round(value) + '%';
    return bar;
  }

  /**
   * Format a Spark amount with sign and [S] symbol.
   * @param {number} amount
   * @returns {string}
   */
  function _formatSpark(amount) {
    var sign = amount >= 0 ? '+' : '';
    return sign + amount + ' Spark';
  }

  /**
   * Format balance card HTML for a player.
   * @param {Object} state
   * @param {string} playerId
   * @returns {string} HTML string
   */
  function formatBalanceCard(state, playerId) {
    var balance = getBalance(state, playerId);
    var income = calculateDailyIncome(state, playerId);
    var expenses = calculateDailyExpenses(state, playerId);
    var net = income - expenses;
    var netClass = net >= 0 ? 'spark-positive' : 'spark-negative';
    var netSign = net >= 0 ? '+' : '';
    // Sum UBI received
    var ubiReceived = 0;
    if (state && state.transactions) {
      for (var i = 0; i < state.transactions.length; i++) {
        var tx = state.transactions[i];
        if (tx.playerId === playerId && tx.type === 'ubi') ubiReceived += tx.amount;
      }
    }
    // Sum tax paid
    var taxPaid = 0;
    if (state && state.transactions) {
      for (var j = 0; j < state.transactions.length; j++) {
        var ttx = state.transactions[j];
        if (ttx.playerId === playerId && ttx.type === 'wealth_tax') taxPaid += Math.abs(ttx.amount);
      }
    }
    return '<div class="balance-card">' +
      '<div class="balance-main"><span class="spark-gold">' + balance + ' Spark</span></div>' +
      '<div class="balance-row"><span class="label">Daily Income</span><span class="spark-positive">+' + income + ' Spark</span></div>' +
      '<div class="balance-row"><span class="label">Daily Expenses</span><span class="spark-negative">-' + expenses + ' Spark</span></div>' +
      '<div class="balance-row"><span class="label">Net Change</span><span class="' + netClass + '">' + netSign + net + ' Spark</span></div>' +
      '<div class="balance-row"><span class="label">UBI Received</span><span class="spark-positive">+' + ubiReceived + ' Spark</span></div>' +
      '<div class="balance-row"><span class="label">Tax Paid</span><span class="spark-negative">-' + taxPaid + ' Spark</span></div>' +
      '</div>';
  }

  /**
   * Format a market listing as an HTML table row.
   * @param {Object} listing
   * @returns {string} HTML string
   */
  function formatListingRow(listing) {
    if (!listing) return '';
    var total = listing.quantity * listing.pricePerUnit;
    return '<tr class="listing-row" data-listing-id="' + listing.id + '">' +
      '<td class="listing-item">' + (listing.itemId || '') + '</td>' +
      '<td class="listing-qty">' + (listing.quantity || 0) + '</td>' +
      '<td class="listing-price">' + (listing.pricePerUnit || 0) + ' Spark</td>' +
      '<td class="listing-total">' + total + ' Spark</td>' +
      '<td class="listing-seller">' + (listing.sellerId || '') + '</td>' +
      '<td class="listing-action"><button class="btn-buy" data-listing-id="' + listing.id + '">Buy</button></td>' +
      '</tr>';
  }

  /**
   * Format a transaction as an HTML row.
   * @param {Object} tx
   * @returns {string} HTML string
   */
  function formatTransactionRow(tx) {
    if (!tx) return '';
    var isPositive = tx.amount >= 0;
    var amountClass = isPositive ? 'spark-positive' : 'spark-negative';
    var typeIcon = _txTypeIcon(tx.type);
    var amountStr = (isPositive ? '+' : '') + tx.amount + ' Spark';
    var dateStr = tx.timestamp ? new Date(tx.timestamp).toLocaleDateString() : '';
    var timeStr = tx.timestamp ? new Date(tx.timestamp).toLocaleTimeString() : '';
    var counterparty = tx.counterparty || '';
    return '<tr class="tx-row">' +
      '<td class="tx-type">' + typeIcon + '</td>' +
      '<td class="tx-amount ' + amountClass + '">' + amountStr + '</td>' +
      '<td class="tx-reason">' + (tx.reason || '') + '</td>' +
      '<td class="tx-date">' + dateStr + ' ' + timeStr + '</td>' +
      '<td class="tx-counterparty">' + counterparty + '</td>' +
      '</tr>';
  }

  /**
   * Get a text icon for a transaction type.
   * @param {string} type
   * @returns {string}
   */
  function _txTypeIcon(type) {
    var icons = {
      'earn': '[+]',
      'spend': '[-]',
      'transfer_in': '[>>]',
      'transfer_out': '[<<]',
      'market_buy': '[B]',
      'market_sell': '[S]',
      'listing_fee': '[F]',
      'ubi': '[U]',
      'wealth_tax': '[T]'
    };
    return icons[type] || '[?]';
  }

  /**
   * Format economy stats as HTML.
   * @param {Object} stats
   * @returns {string} HTML string
   */
  function formatEconomyStats(stats) {
    if (!stats) return '<div class="stats-panel">No data</div>';
    var giniPct = Math.round((stats.giniCoefficient || 0) * 100);
    var giniBar = _asciiBar(giniPct);
    return '<div class="stats-panel">' +
      '<div class="stat-row"><span class="label">Total Circulation</span><span class="spark-gold">' + Math.round(stats.totalCirculation || 0) + ' Spark</span></div>' +
      '<div class="stat-row"><span class="label">Average Wealth</span><span>' + Math.round(stats.averageWealth || 0) + ' Spark</span></div>' +
      '<div class="stat-row"><span class="label">Median Wealth</span><span>' + Math.round(stats.medianWealth || 0) + ' Spark</span></div>' +
      '<div class="stat-row"><span class="label">Gini Coefficient</span><span>' + (stats.giniCoefficient || 0).toFixed(3) + '</span></div>' +
      '<div class="stat-row stat-bar"><span class="label">Inequality</span><pre>' + giniBar + '</pre></div>' +
      '<div class="stat-row"><span class="label">Active Traders</span><span>' + (stats.activeTraders || 0) + '</span></div>' +
      '<div class="stat-row"><span class="label">Active Listings</span><span>' + (stats.totalListings || 0) + '</span></div>' +
      '<div class="stat-row"><span class="label">Total Transactions</span><span>' + (stats.totalTransactions || 0) + '</span></div>' +
      '</div>';
  }

  /**
   * Render an ASCII line chart showing Spark balance over time.
   * @param {Array} transactions
   * @param {number} [days=7]
   * @returns {string} Multi-line string
   */
  function renderSparkChart(transactions, days) {
    days = (typeof days === 'number' && days > 0) ? days : 7;
    if (!transactions || transactions.length === 0) {
      return '(no data)';
    }
    // Build daily net change buckets
    var now = Date.now();
    var buckets = [];
    for (var d = days - 1; d >= 0; d--) {
      buckets.push({ dayOffset: d, net: 0 });
    }
    for (var i = 0; i < transactions.length; i++) {
      var tx = transactions[i];
      var age = now - tx.timestamp;
      var dayIndex = Math.floor(age / MS_PER_DAY);
      if (dayIndex >= 0 && dayIndex < days) {
        // buckets[0] is oldest, but we indexed from newest
        var bIdx = (days - 1) - dayIndex;
        buckets[bIdx].net += tx.amount;
      }
    }
    // Compute running balance (from first to last)
    var running = [];
    var runBal = 0;
    for (var k = 0; k < buckets.length; k++) {
      runBal += buckets[k].net;
      running.push(runBal);
    }
    // Normalize to chart height of 5 rows
    var chartHeight = 5;
    var maxVal = Math.max.apply(null, running);
    var minVal = Math.min.apply(null, running);
    var range = maxVal - minVal;
    if (range === 0) range = 1;
    var chart = [];
    for (var row = chartHeight; row >= 0; row--) {
      var line = '';
      var rowThreshold = minVal + (row / chartHeight) * range;
      for (var col = 0; col < running.length; col++) {
        if (running[col] >= rowThreshold) {
          line += '*';
        } else {
          line += ' ';
        }
      }
      chart.push(line);
    }
    // Add axis
    var axis = '';
    for (var a = 0; a < days; a++) axis += '-';
    chart.push(axis);
    // Add day labels
    var labels = '';
    for (var b = days; b >= 1; b--) {
      labels += 'D' + b;
      if (b > 1) labels += ' ';
    }
    chart.push(labels);
    return chart.join('\n');
  }

  // =========================================================================
  // UI PANEL
  // =========================================================================

  /**
   * Create the economy panel DOM element (for browser use).
   * @returns {Element|null} DOM element, or null if document is not available
   */
  function createEconomyPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.className = 'economy-panel';
    panel.setAttribute('data-panel', 'economy');

    // Tab navigation
    var tabNav = document.createElement('div');
    tabNav.className = 'economy-tabs';
    var tabs = ['Balance', 'Market', 'History', 'Stats'];
    var tabBtns = [];
    for (var t = 0; t < tabs.length; t++) {
      var btn = document.createElement('button');
      btn.className = 'economy-tab-btn' + (t === 0 ? ' active' : '');
      btn.setAttribute('data-tab', tabs[t].toLowerCase());
      btn.textContent = tabs[t];
      tabBtns.push(btn);
      tabNav.appendChild(btn);
    }
    panel.appendChild(tabNav);

    // Tab content container
    var tabContent = document.createElement('div');
    tabContent.className = 'economy-tab-content';

    // Balance tab
    var balanceTab = document.createElement('div');
    balanceTab.className = 'economy-tab active';
    balanceTab.setAttribute('data-content', 'balance');
    balanceTab.innerHTML =
      '<div class="tab-header">Balance</div>' +
      '<div class="balance-display">' +
        '<div class="balance-amount spark-gold">100 Spark</div>' +
        '<div class="balance-meta">' +
          '<div class="meta-row"><span>Daily Income</span><span class="spark-positive">+0 Spark</span></div>' +
          '<div class="meta-row"><span>Daily Expenses</span><span class="spark-negative">-0 Spark</span></div>' +
          '<div class="meta-row"><span>UBI Status</span><span class="ubi-status">Active</span></div>' +
          '<div class="meta-row"><span>Wealth Tax</span><span class="tax-indicator">None</span></div>' +
        '</div>' +
      '</div>';
    tabContent.appendChild(balanceTab);

    // Market tab
    var marketTab = document.createElement('div');
    marketTab.className = 'economy-tab hidden';
    marketTab.setAttribute('data-content', 'market');
    marketTab.innerHTML =
      '<div class="tab-header">Market</div>' +
      '<div class="market-controls">' +
        '<label>Sort by: <select class="market-sort">' +
          '<option value="date">Date</option>' +
          '<option value="price">Price</option>' +
          '<option value="quantity">Quantity</option>' +
        '</select></label>' +
      '</div>' +
      '<table class="market-table">' +
        '<thead><tr>' +
          '<th>Item</th><th>Qty</th><th>Price</th><th>Total</th><th>Seller</th><th>Action</th>' +
        '</tr></thead>' +
        '<tbody class="market-listing-body"><tr><td colspan="6">No listings available</td></tr></tbody>' +
      '</table>' +
      '<div class="create-listing">' +
        '<div class="form-header">Create Listing</div>' +
        '<div class="form-group"><label>Item ID <input type="text" class="listing-item-id" placeholder="item_wood"></label></div>' +
        '<div class="form-group"><label>Quantity <input type="number" class="listing-qty" min="1" value="1"></label></div>' +
        '<div class="form-group"><label>Price per Unit <input type="number" class="listing-price" min="1" value="10"></label></div>' +
        '<div class="form-group listing-fee-preview">Listing fee: 1 Spark</div>' +
        '<button class="btn-create-listing">Create Listing</button>' +
      '</div>';
    tabContent.appendChild(marketTab);

    // History tab
    var historyTab = document.createElement('div');
    historyTab.className = 'economy-tab hidden';
    historyTab.setAttribute('data-content', 'history');
    historyTab.innerHTML =
      '<div class="tab-header">Transaction History</div>' +
      '<table class="tx-table">' +
        '<thead><tr>' +
          '<th>Type</th><th>Amount</th><th>Reason</th><th>Date</th><th>Counterparty</th>' +
        '</tr></thead>' +
        '<tbody class="tx-body"><tr><td colspan="5">No transactions yet</td></tr></tbody>' +
      '</table>';
    tabContent.appendChild(historyTab);

    // Stats tab
    var statsTab = document.createElement('div');
    statsTab.className = 'economy-tab hidden';
    statsTab.setAttribute('data-content', 'stats');
    statsTab.innerHTML =
      '<div class="tab-header">Economy Statistics</div>' +
      '<div class="stats-container">' +
        '<div class="stat-row"><span>Total Circulation</span><span class="spark-gold">0 Spark</span></div>' +
        '<div class="stat-row"><span>Average Wealth</span><span>0 Spark</span></div>' +
        '<div class="stat-row"><span>Gini Coefficient</span><span>0.000</span></div>' +
        '<div class="stat-row"><span>Active Traders</span><span>0</span></div>' +
        '<div class="wealth-distribution">' +
          '<div class="dist-header">Wealth Distribution</div>' +
          '<div class="dist-bars"></div>' +
        '</div>' +
      '</div>';
    tabContent.appendChild(statsTab);

    panel.appendChild(tabContent);

    // Wire up tab switching
    for (var i = 0; i < tabBtns.length; i++) {
      tabBtns[i].addEventListener('click', function(e) {
        var target = e.target.getAttribute('data-tab');
        var allBtns = panel.querySelectorAll('.economy-tab-btn');
        var allContent = panel.querySelectorAll('.economy-tab');
        for (var b = 0; b < allBtns.length; b++) {
          allBtns[b].classList.remove('active');
        }
        for (var c = 0; c < allContent.length; c++) {
          allContent[c].classList.remove('active');
          allContent[c].classList.add('hidden');
        }
        e.target.classList.add('active');
        var targetPane = panel.querySelector('[data-content="' + target + '"]');
        if (targetPane) {
          targetPane.classList.remove('hidden');
          targetPane.classList.add('active');
        }
      });
    }

    return panel;
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.createEconomyPanel = createEconomyPanel;
  exports.createEconomyState = createEconomyState;
  exports.getBalance = getBalance;
  exports.earnSpark = earnSpark;
  exports.spendSpark = spendSpark;
  exports.transferSpark = transferSpark;
  exports.createListing = createListing;
  exports.buyListing = buyListing;
  exports.cancelListing = cancelListing;
  exports.getListings = getListings;
  exports.getTransactionHistory = getTransactionHistory;
  exports.calculateDailyIncome = calculateDailyIncome;
  exports.calculateDailyExpenses = calculateDailyExpenses;
  exports.getEconomyStats = getEconomyStats;
  exports.calculateGiniCoefficient = calculateGiniCoefficient;
  exports.distributeUBI = distributeUBI;
  exports.applyWealthTax = applyWealthTax;
  exports.formatBalanceCard = formatBalanceCard;
  exports.formatListingRow = formatListingRow;
  exports.formatTransactionRow = formatTransactionRow;
  exports.formatEconomyStats = formatEconomyStats;
  exports.renderSparkChart = renderSparkChart;
  exports.getWealthDistribution = getWealthDistribution;
  // Expose constants for tests
  exports.DEFAULT_BALANCE = DEFAULT_BALANCE;
  exports.LISTING_FEE_RATE = LISTING_FEE_RATE;
  exports.MINIMUM_LISTING_FEE = MINIMUM_LISTING_FEE;
  exports.WEALTH_BRACKETS = WEALTH_BRACKETS;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardEconomy = {}));


// dashboard_quests.js
// dashboard_quests.js
/**
 * dashboard_quests.js - Quest and Achievement panel for ZION dashboard mode
 *
 * Provides the QUEST & ACHIEVEMENT panel: browse available quests,
 * track progress, view achievements, and claim rewards.
 * UI-only mode â€” no Three.js or PeerJS dependencies.
 *
 * UMD module: window.DashboardQuests (browser) or module.exports (Node.js)
 * ES5 compatible - uses var declarations
 */
(function(exports) {
  'use strict';

  // =========================================================================
  // CONSTANTS & COLOR PALETTE
  // =========================================================================

  var COLORS = {
    bg:            '#0A0E1A',
    bgPanel:       '#111827',
    bgHeader:      '#0D1321',
    bgCard:        '#161F2E',
    bgCardHover:   '#1A2640',
    border:        '#1E3A5F',
    borderAccent:  '#2A5285',
    accent:        '#DAA520',
    text:          '#E8E0D8',
    textMuted:     '#8A9AB0',
    textDim:       '#4A5A70',
    success:       '#2E7D32',
    warning:       '#F57F17',
    danger:        '#C62828',
    easy:          '#4CAF50',
    medium:        '#FFA726',
    hard:          '#EF5350',
    legendary:     '#9b59b6',
    bronze:        '#CD7F32',
    silver:        '#C0C0C0',
    gold:          '#FFD700',
    platinum:      '#E5E4E2'
  };

  var DIFFICULTY_COLORS = {
    easy:      '#4CAF50',
    medium:    '#FFA726',
    hard:      '#EF5350',
    legendary: '#9b59b6'
  };

  var TIER_COLORS = {
    bronze:   '#CD7F32',
    silver:   '#C0C0C0',
    gold:     '#FFD700',
    platinum: '#E5E4E2'
  };

  var CATEGORY_ICONS = {
    exploration: '[EX]',
    social:      '[SO]',
    crafting:    '[CR]',
    economy:     '[EC]',
    minigame:    '[MG]'
  };

  var TIER_ICONS = {
    bronze:   '[B]',
    silver:   '[S]',
    gold:     '[G]',
    platinum: '[P]'
  };

  // =========================================================================
  // QUEST CATALOG (30 quests)
  // =========================================================================

  var QUEST_CATALOG = {

    // ---- Exploration (6) ----
    explore_all_zones: {
      id: 'explore_all_zones',
      title: 'World Walker',
      desc: 'Visit all 8 zones in ZION',
      category: 'exploration',
      difficulty: 'medium',
      reward: { spark: 50, item: 'compass' },
      objectives: [{ type: 'visit_zone', target: 8, desc: 'Zones visited' }]
    },
    discover_landmarks: {
      id: 'discover_landmarks',
      title: 'Landmark Seeker',
      desc: 'Discover 5 hidden landmarks',
      category: 'exploration',
      difficulty: 'hard',
      reward: { spark: 100, item: 'telescope' },
      objectives: [{ type: 'discover', target: 5, desc: 'Landmarks found' }]
    },
    map_the_wilds: {
      id: 'map_the_wilds',
      title: 'Cartographer',
      desc: 'Explore every corner of the Wilds',
      category: 'exploration',
      difficulty: 'medium',
      reward: { spark: 40, item: 'map_fragment' },
      objectives: [{ type: 'explore_area', target: 100, desc: '% explored' }]
    },
    night_walker: {
      id: 'night_walker',
      title: 'Night Walker',
      desc: 'Explore 3 zones during nighttime',
      category: 'exploration',
      difficulty: 'easy',
      reward: { spark: 25 },
      objectives: [{ type: 'night_visit', target: 3, desc: 'Night zones visited' }]
    },
    summit_seeker: {
      id: 'summit_seeker',
      title: 'Summit Seeker',
      desc: 'Reach the highest point in ZION',
      category: 'exploration',
      difficulty: 'hard',
      reward: { spark: 75, item: 'star_fragment' },
      objectives: [{ type: 'reach_height', target: 1, desc: 'Summit reached' }]
    },
    cave_diver: {
      id: 'cave_diver',
      title: 'Cave Diver',
      desc: 'Explore 3 underground caves',
      category: 'exploration',
      difficulty: 'medium',
      reward: { spark: 45, item: 'crystal' },
      objectives: [{ type: 'explore_cave', target: 3, desc: 'Caves explored' }]
    },

    // ---- Social (6) ----
    make_friends: {
      id: 'make_friends',
      title: 'Social Butterfly',
      desc: 'Reach Friend tier with 5 NPCs',
      category: 'social',
      difficulty: 'medium',
      reward: { spark: 60, item: 'gold_ring' },
      objectives: [{ type: 'friendship_tier', target: 5, desc: 'NPC friends made' }]
    },
    join_guild: {
      id: 'join_guild',
      title: 'Strength in Numbers',
      desc: 'Join or create a guild',
      category: 'social',
      difficulty: 'easy',
      reward: { spark: 20 },
      objectives: [{ type: 'guild_action', target: 1, desc: 'Guild joined' }]
    },
    chat_master: {
      id: 'chat_master',
      title: 'Chatterbox',
      desc: 'Send 50 chat messages',
      category: 'social',
      difficulty: 'easy',
      reward: { spark: 15 },
      objectives: [{ type: 'send_message', target: 50, desc: 'Messages sent' }]
    },
    mentor_someone: {
      id: 'mentor_someone',
      title: 'Guiding Light',
      desc: 'Complete 3 mentoring sessions',
      category: 'social',
      difficulty: 'hard',
      reward: { spark: 80 },
      objectives: [{ type: 'mentor', target: 3, desc: 'Sessions completed' }]
    },
    attend_event: {
      id: 'attend_event',
      title: 'Community Spirit',
      desc: 'Participate in 5 world events',
      category: 'social',
      difficulty: 'medium',
      reward: { spark: 50 },
      objectives: [{ type: 'join_event', target: 5, desc: 'Events attended' }]
    },
    trade_partner: {
      id: 'trade_partner',
      title: 'Trade Partner',
      desc: 'Complete trades with 10 different players',
      category: 'social',
      difficulty: 'hard',
      reward: { spark: 70, item: 'trade_permit' },
      objectives: [{ type: 'unique_trades', target: 10, desc: 'Trade partners' }]
    },

    // ---- Crafting (6) ----
    first_craft: {
      id: 'first_craft',
      title: 'Apprentice Crafter',
      desc: 'Craft your first item',
      category: 'crafting',
      difficulty: 'easy',
      reward: { spark: 10 },
      objectives: [{ type: 'craft', target: 1, desc: 'Items crafted' }]
    },
    master_smith: {
      id: 'master_smith',
      title: 'Master Smith',
      desc: 'Craft 10 iron items',
      category: 'crafting',
      difficulty: 'hard',
      reward: { spark: 100, item: 'iron_sword' },
      objectives: [{ type: 'craft_category', target: 10, desc: 'Iron items crafted' }]
    },
    recipe_collector: {
      id: 'recipe_collector',
      title: 'Recipe Collector',
      desc: 'Learn 15 crafting recipes',
      category: 'crafting',
      difficulty: 'medium',
      reward: { spark: 55 },
      objectives: [{ type: 'learn_recipe', target: 15, desc: 'Recipes learned' }]
    },
    resource_gatherer: {
      id: 'resource_gatherer',
      title: 'Gatherer',
      desc: 'Collect 100 resources of any type',
      category: 'crafting',
      difficulty: 'medium',
      reward: { spark: 35 },
      objectives: [{ type: 'gather', target: 100, desc: 'Resources gathered' }]
    },
    alchemist: {
      id: 'alchemist',
      title: 'Alchemist',
      desc: 'Brew 5 potions',
      category: 'crafting',
      difficulty: 'medium',
      reward: { spark: 45, item: 'herb_pouch' },
      objectives: [{ type: 'craft_item', target: 5, targetItem: 'potion', desc: 'Potions brewed' }]
    },
    legendary_craft: {
      id: 'legendary_craft',
      title: 'Legendary Artisan',
      desc: 'Craft a legendary item',
      category: 'crafting',
      difficulty: 'legendary',
      reward: { spark: 200 },
      objectives: [{ type: 'craft_rarity', target: 1, targetRarity: 'legendary', desc: 'Legendary items crafted' }]
    },

    // ---- Economy (6) ----
    first_sale: {
      id: 'first_sale',
      title: 'Open for Business',
      desc: 'Sell an item on the market',
      category: 'economy',
      difficulty: 'easy',
      reward: { spark: 10 },
      objectives: [{ type: 'market_sell', target: 1, desc: 'Items listed' }]
    },
    spark_saver: {
      id: 'spark_saver',
      title: 'Spark Saver',
      desc: 'Accumulate 500 Spark',
      category: 'economy',
      difficulty: 'hard',
      reward: { spark: 50 },
      objectives: [{ type: 'balance_reach', target: 500, desc: 'Spark accumulated' }]
    },
    market_mogul: {
      id: 'market_mogul',
      title: 'Market Mogul',
      desc: 'Complete 25 market transactions',
      category: 'economy',
      difficulty: 'hard',
      reward: { spark: 120 },
      objectives: [{ type: 'market_tx', target: 25, desc: 'Transactions' }]
    },
    generous_soul: {
      id: 'generous_soul',
      title: 'Generous Soul',
      desc: 'Gift 100 Spark to other players',
      category: 'economy',
      difficulty: 'medium',
      reward: { spark: 30, item: 'gold_dust' },
      objectives: [{ type: 'gift_spark', target: 100, desc: 'Spark gifted' }]
    },
    tax_payer: {
      id: 'tax_payer',
      title: 'Good Citizen',
      desc: 'Pay 50 Spark in taxes',
      category: 'economy',
      difficulty: 'medium',
      reward: { spark: 25 },
      objectives: [{ type: 'tax_paid', target: 50, desc: 'Tax paid' }]
    },
    bargain_hunter: {
      id: 'bargain_hunter',
      title: 'Bargain Hunter',
      desc: 'Buy 10 items below market value',
      category: 'economy',
      difficulty: 'hard',
      reward: { spark: 60 },
      objectives: [{ type: 'bargain_buy', target: 10, desc: 'Bargains found' }]
    },

    // ---- Mini-games (6) ----
    first_catch: {
      id: 'first_catch',
      title: 'Gone Fishing',
      desc: 'Catch your first fish',
      category: 'minigame',
      difficulty: 'easy',
      reward: { spark: 10 },
      objectives: [{ type: 'catch_fish', target: 1, desc: 'Fish caught' }]
    },
    card_collector: {
      id: 'card_collector',
      title: 'Card Collector',
      desc: 'Collect 20 unique cards',
      category: 'minigame',
      difficulty: 'medium',
      reward: { spark: 40 },
      objectives: [{ type: 'collect_cards', target: 20, desc: 'Cards collected' }]
    },
    dungeon_clear: {
      id: 'dungeon_clear',
      title: 'Dungeon Delver',
      desc: 'Clear 3 dungeons',
      category: 'minigame',
      difficulty: 'hard',
      reward: { spark: 80, item: 'crystal' },
      objectives: [{ type: 'clear_dungeon', target: 3, desc: 'Dungeons cleared' }]
    },
    stargazer: {
      id: 'stargazer',
      title: 'Stargazer',
      desc: 'Identify 6 constellations',
      category: 'minigame',
      difficulty: 'medium',
      reward: { spark: 35, item: 'star_chart' },
      objectives: [{ type: 'identify_constellation', target: 6, desc: 'Constellations found' }]
    },
    time_capsule_writer: {
      id: 'time_capsule_writer',
      title: 'Message in a Bottle',
      desc: 'Bury 3 time capsules',
      category: 'minigame',
      difficulty: 'easy',
      reward: { spark: 20 },
      objectives: [{ type: 'bury_capsule', target: 3, desc: 'Capsules buried' }]
    },
    housing_decorator: {
      id: 'housing_decorator',
      title: 'Interior Designer',
      desc: 'Place 10 furniture items in your house',
      category: 'minigame',
      difficulty: 'medium',
      reward: { spark: 45 },
      objectives: [{ type: 'place_furniture', target: 10, desc: 'Furniture placed' }]
    }
  };

  // =========================================================================
  // ACHIEVEMENT CATALOG (20 achievements)
  // =========================================================================

  var ACHIEVEMENTS = {
    first_steps: {
      id: 'first_steps',
      title: 'First Steps',
      desc: 'Enter ZION for the first time',
      tier: 'bronze',
      points: 5
    },
    zone_traveler: {
      id: 'zone_traveler',
      title: 'Zone Traveler',
      desc: 'Visit 4 different zones',
      tier: 'bronze',
      points: 10
    },
    world_citizen: {
      id: 'world_citizen',
      title: 'World Citizen',
      desc: 'Visit all 8 zones',
      tier: 'silver',
      points: 25
    },
    spark_earner: {
      id: 'spark_earner',
      title: 'Spark Earner',
      desc: 'Earn 100 Spark total',
      tier: 'bronze',
      points: 10
    },
    wealthy: {
      id: 'wealthy',
      title: 'Wealthy',
      desc: 'Hold 1000 Spark at once',
      tier: 'gold',
      points: 50
    },
    quest_starter: {
      id: 'quest_starter',
      title: 'Quest Starter',
      desc: 'Accept your first quest',
      tier: 'bronze',
      points: 5
    },
    quest_master: {
      id: 'quest_master',
      title: 'Quest Master',
      desc: 'Complete 10 quests',
      tier: 'silver',
      points: 30
    },
    quest_legend: {
      id: 'quest_legend',
      title: 'Quest Legend',
      desc: 'Complete 25 quests',
      tier: 'gold',
      points: 75
    },
    crafter: {
      id: 'crafter',
      title: 'Crafter',
      desc: 'Craft 10 items',
      tier: 'bronze',
      points: 10
    },
    master_crafter: {
      id: 'master_crafter',
      title: 'Master Crafter',
      desc: 'Craft 50 items',
      tier: 'silver',
      points: 30
    },
    social_climber: {
      id: 'social_climber',
      title: 'Social Climber',
      desc: 'Reach Friend tier with any NPC',
      tier: 'bronze',
      points: 10
    },
    beloved: {
      id: 'beloved',
      title: 'Beloved',
      desc: 'Reach Confidant tier with 3 NPCs',
      tier: 'gold',
      points: 50
    },
    angler: {
      id: 'angler',
      title: 'Angler',
      desc: 'Catch 25 fish',
      tier: 'silver',
      points: 20
    },
    card_player: {
      id: 'card_player',
      title: 'Card Player',
      desc: 'Win 5 card game battles',
      tier: 'silver',
      points: 20
    },
    dungeon_hero: {
      id: 'dungeon_hero',
      title: 'Dungeon Hero',
      desc: 'Clear a dungeon on hard difficulty',
      tier: 'gold',
      points: 40
    },
    guild_founder: {
      id: 'guild_founder',
      title: 'Guild Founder',
      desc: 'Create a guild',
      tier: 'silver',
      points: 25
    },
    voter: {
      id: 'voter',
      title: 'Civic Duty',
      desc: 'Vote in a zone election',
      tier: 'bronze',
      points: 10
    },
    homeowner: {
      id: 'homeowner',
      title: 'Homeowner',
      desc: 'Claim a housing plot',
      tier: 'silver',
      points: 20
    },
    composer: {
      id: 'composer',
      title: 'Composer',
      desc: 'Create a music composition',
      tier: 'bronze',
      points: 15
    },
    completionist: {
      id: 'completionist',
      title: 'Completionist',
      desc: 'Earn all other achievements',
      tier: 'platinum',
      points: 200
    }
  };

  // =========================================================================
  // INTERNAL HELPERS
  // =========================================================================

  function _escapeHtml(str) {
    if (typeof str !== 'string') { return String(str); }
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function _pad(n, width) {
    var s = String(n);
    while (s.length < width) { s = '0' + s; }
    return s;
  }

  /**
   * Render a text progress bar: [####------] 4/10
   */
  function _progressBar(current, target, width) {
    width = width || 10;
    var pct = (target > 0) ? Math.min(1, current / target) : 0;
    var filled = Math.round(pct * width);
    var empty = width - filled;
    var bar = '';
    for (var i = 0; i < filled; i++) { bar += '#'; }
    for (var j = 0; j < empty; j++) { bar += '-'; }
    return '[' + bar + '] ' + current + '/' + target;
  }

  function _createElement(tag, attrs, innerHTML) {
    if (typeof document === 'undefined') { return null; }
    var el = document.createElement(tag);
    if (attrs) {
      for (var k in attrs) {
        if (Object.prototype.hasOwnProperty.call(attrs, k)) {
          if (k === 'style') {
            el.style.cssText = attrs[k];
          } else if (k === 'className') {
            el.className = attrs[k];
          } else if (k.indexOf('data-') === 0) {
            el.setAttribute(k, attrs[k]);
          } else {
            el[k] = attrs[k];
          }
        }
      }
    }
    if (innerHTML !== undefined) {
      el.innerHTML = innerHTML;
    }
    return el;
  }

  function _appendChildren(parent, children) {
    if (!parent) { return; }
    for (var i = 0; i < children.length; i++) {
      if (children[i]) { parent.appendChild(children[i]); }
    }
  }

  // Card style string
  function _cardStyle() {
    return [
      'background:' + COLORS.bgCard,
      'border:1px solid ' + COLORS.border,
      'border-radius:4px',
      'padding:10px',
      'margin-bottom:8px'
    ].join(';');
  }

  function _labelStyle(color) {
    return [
      'display:inline-block',
      'padding:1px 6px',
      'border-radius:3px',
      'font-size:11px',
      'font-weight:bold',
      'color:#fff',
      'background:' + (color || COLORS.textDim),
      'margin-right:4px'
    ].join(';');
  }

  function _progressBarStyle() {
    return [
      'background:' + COLORS.border,
      'border-radius:2px',
      'height:6px',
      'margin:4px 0',
      'overflow:hidden'
    ].join(';');
  }

  function _progressFillStyle(pct, color) {
    return [
      'height:100%',
      'width:' + Math.min(100, pct) + '%',
      'background:' + (color || COLORS.accent),
      'border-radius:2px',
      'transition:width 0.3s'
    ].join(';');
  }

  // =========================================================================
  // QUEST STATE
  // =========================================================================

  /**
   * createQuestState()
   * Returns fresh quest tracking state.
   * active:       { [questId]: { acceptedAt, progress: [number per objective] } }
   * completed:    { [questId]: { completedAt, rewards } }
   * progress:     { [questId]: [current values per objective] }
   * achievements: { [achievementId]: { unlockedAt, points } }
   */
  function createQuestState() {
    return {
      active:       {},
      completed:    {},
      progress:     {},
      achievements: {}
    };
  }

  // =========================================================================
  // QUEST QUERIES
  // =========================================================================

  /**
   * getAvailableQuests(state, playerData)
   * Returns array of quest objects not yet accepted or completed.
   */
  function getAvailableQuests(state, playerData) {
    var result = [];
    for (var id in QUEST_CATALOG) {
      if (!Object.prototype.hasOwnProperty.call(QUEST_CATALOG, id)) { continue; }
      if (state.active[id] || state.completed[id]) { continue; }
      result.push(QUEST_CATALOG[id]);
    }
    return result;
  }

  /**
   * getQuestsByCategory(category)
   * Returns array of quest objects matching the given category.
   */
  function getQuestsByCategory(category) {
    var result = [];
    for (var id in QUEST_CATALOG) {
      if (!Object.prototype.hasOwnProperty.call(QUEST_CATALOG, id)) { continue; }
      if (QUEST_CATALOG[id].category === category) {
        result.push(QUEST_CATALOG[id]);
      }
    }
    return result;
  }

  /**
   * getQuestReward(questId)
   * Returns the reward object for a quest, or null if not found.
   */
  function getQuestReward(questId) {
    var q = QUEST_CATALOG[questId];
    if (!q) { return null; }
    return q.reward;
  }

  // =========================================================================
  // QUEST LIFECYCLE
  // =========================================================================

  /**
   * acceptQuest(state, questId)
   * Accept a quest â€” initialise progress tracking.
   * Returns { success, state, quest, error }
   */
  function acceptQuest(state, questId) {
    if (!state) { return { success: false, error: 'No state provided' }; }
    var quest = QUEST_CATALOG[questId];
    if (!quest) { return { success: false, error: 'Quest not found: ' + questId }; }
    if (state.active[questId]) { return { success: false, error: 'Quest already active: ' + questId }; }
    if (state.completed[questId]) { return { success: false, error: 'Quest already completed: ' + questId }; }

    // Init progress array (one slot per objective)
    var progress = [];
    for (var i = 0; i < quest.objectives.length; i++) {
      progress.push(0);
    }

    state.active[questId] = { acceptedAt: Date.now(), progress: progress };
    state.progress[questId] = progress;

    return { success: true, state: state, quest: quest };
  }

  /**
   * updateQuestProgress(state, questId, objectiveIndex, amount)
   * Add `amount` to a quest objective's progress counter.
   * Auto-completes quest when all objectives meet their targets.
   * Returns { success, state, completed, rewards, error }
   */
  function updateQuestProgress(state, questId, objectiveIndex, amount) {
    if (!state) { return { success: false, error: 'No state provided' }; }
    if (!state.active[questId]) { return { success: false, error: 'Quest not active: ' + questId }; }
    var quest = QUEST_CATALOG[questId];
    if (!quest) { return { success: false, error: 'Quest not found: ' + questId }; }
    if (objectiveIndex < 0 || objectiveIndex >= quest.objectives.length) {
      return { success: false, error: 'Invalid objective index: ' + objectiveIndex };
    }

    var active = state.active[questId];
    var obj = quest.objectives[objectiveIndex];
    var prev = active.progress[objectiveIndex];
    var newVal = Math.min(obj.target, prev + (amount !== undefined && amount !== null ? amount : 1));
    active.progress[objectiveIndex] = newVal;
    state.progress[questId] = active.progress;

    // Check all objectives complete
    var allDone = true;
    for (var i = 0; i < quest.objectives.length; i++) {
      if (active.progress[i] < quest.objectives[i].target) {
        allDone = false;
        break;
      }
    }

    if (allDone) {
      var result = completeQuest(state, questId);
      return {
        success: true,
        state: state,
        completed: true,
        rewards: result.rewards
      };
    }

    return { success: true, state: state, completed: false, rewards: null };
  }

  /**
   * completeQuest(state, questId)
   * Mark quest complete and record rewards.
   * Returns { success, state, rewards, error }
   */
  function completeQuest(state, questId) {
    if (!state) { return { success: false, error: 'No state provided' }; }
    var quest = QUEST_CATALOG[questId];
    if (!quest) { return { success: false, error: 'Quest not found: ' + questId }; }

    // Allow completing even without being in active (direct complete call)
    if (state.completed[questId]) {
      return { success: false, error: 'Quest already completed: ' + questId };
    }

    // Check objectives if quest is active
    if (state.active[questId]) {
      var active = state.active[questId];
      var allMet = true;
      for (var i = 0; i < quest.objectives.length; i++) {
        if ((active.progress[i] || 0) < quest.objectives[i].target) {
          allMet = false;
          break;
        }
      }
      if (!allMet) {
        return { success: false, error: 'Objectives not yet complete for: ' + questId };
      }
    }

    var rewards = quest.reward || {};
    state.completed[questId] = {
      completedAt: Date.now(),
      rewards: rewards
    };
    delete state.active[questId];
    delete state.progress[questId];

    return { success: true, state: state, rewards: rewards };
  }

  /**
   * abandonQuest(state, questId)
   * Remove from active quests without completing.
   * Returns { success, state, error }
   */
  function abandonQuest(state, questId) {
    if (!state) { return { success: false, error: 'No state provided' }; }
    if (!state.active[questId]) { return { success: false, error: 'Quest not active: ' + questId }; }
    delete state.active[questId];
    delete state.progress[questId];
    return { success: true, state: state };
  }

  /**
   * getQuestProgress(state, questId)
   * Returns array of { desc, current, target, percent } per objective.
   */
  function getQuestProgress(state, questId) {
    var quest = QUEST_CATALOG[questId];
    if (!quest) { return []; }
    var progressArr = (state.progress && state.progress[questId]) ||
                      (state.active && state.active[questId] && state.active[questId].progress) ||
                      [];
    var result = [];
    for (var i = 0; i < quest.objectives.length; i++) {
      var obj = quest.objectives[i];
      var cur = progressArr[i] || 0;
      var pct = obj.target > 0 ? Math.min(100, Math.round((cur / obj.target) * 100)) : 0;
      result.push({
        desc:    obj.desc,
        current: cur,
        target:  obj.target,
        percent: pct
      });
    }
    return result;
  }

  // =========================================================================
  // ACHIEVEMENTS
  // =========================================================================

  /**
   * checkAchievement(state, achievementId, playerData)
   * Returns { unlocked, progress, target } for the given achievement.
   * playerData may supply counters used for progress checks.
   */
  function checkAchievement(state, achievementId, playerData) {
    var ach = ACHIEVEMENTS[achievementId];
    if (!ach) { return { unlocked: false, progress: 0, target: 1 }; }
    var alreadyUnlocked = !!(state.achievements && state.achievements[achievementId]);
    if (alreadyUnlocked) {
      return { unlocked: true, progress: 1, target: 1 };
    }
    // Without live game data we report progress = 0
    var progress = (playerData && playerData[achievementId + '_progress']) || 0;
    var target = (playerData && playerData[achievementId + '_target']) || 1;
    return { unlocked: false, progress: progress, target: target };
  }

  /**
   * unlockAchievement(state, achievementId)
   * Mark achievement as unlocked.
   * Returns { success, state, achievement, points, error }
   */
  function unlockAchievement(state, achievementId) {
    if (!state) { return { success: false, error: 'No state provided' }; }
    var ach = ACHIEVEMENTS[achievementId];
    if (!ach) { return { success: false, error: 'Achievement not found: ' + achievementId }; }
    if (state.achievements[achievementId]) {
      return { success: false, error: 'Achievement already unlocked: ' + achievementId };
    }
    state.achievements[achievementId] = { unlockedAt: Date.now(), points: ach.points };
    return { success: true, state: state, achievement: ach, points: ach.points };
  }

  /**
   * getAchievementProgress(state)
   * Returns { unlocked, total, points, tier }
   * Tier is highest tier fully represented among unlocked achievements.
   */
  function getAchievementProgress(state) {
    var total = Object.keys(ACHIEVEMENTS).length;
    var unlocked = 0;
    var points = 0;
    var hasBronze = false;
    var hasSilver = false;
    var hasGold = false;
    var hasPlatinum = false;

    for (var id in ACHIEVEMENTS) {
      if (!Object.prototype.hasOwnProperty.call(ACHIEVEMENTS, id)) { continue; }
      var ach = ACHIEVEMENTS[id];
      if (state.achievements && state.achievements[id]) {
        unlocked++;
        points += ach.points;
        if (ach.tier === 'bronze')   { hasBronze = true; }
        if (ach.tier === 'silver')   { hasSilver = true; }
        if (ach.tier === 'gold')     { hasGold = true; }
        if (ach.tier === 'platinum') { hasPlatinum = true; }
      }
    }

    var tier = 'bronze';
    if (hasPlatinum) { tier = 'platinum'; }
    else if (hasGold) { tier = 'gold'; }
    else if (hasSilver) { tier = 'silver'; }
    else if (hasBronze) { tier = 'bronze'; }

    return { unlocked: unlocked, total: total, points: points, tier: tier };
  }

  // =========================================================================
  // COMPLETION SUMMARY
  // =========================================================================

  /**
   * getCompletionSummary(state)
   * Returns { questsCompleted, totalQuests, achievementsUnlocked, totalAchievements, totalPoints }
   */
  function getCompletionSummary(state) {
    var questsCompleted = state.completed ? Object.keys(state.completed).length : 0;
    var totalQuests = Object.keys(QUEST_CATALOG).length;
    var achProg = getAchievementProgress(state);
    return {
      questsCompleted:       questsCompleted,
      totalQuests:           totalQuests,
      achievementsUnlocked:  achProg.unlocked,
      totalAchievements:     achProg.total,
      totalPoints:           achProg.points
    };
  }

  // =========================================================================
  // COLOR HELPERS
  // =========================================================================

  /**
   * getDifficultyColor(difficulty)
   */
  function getDifficultyColor(difficulty) {
    return DIFFICULTY_COLORS[difficulty] || COLORS.textMuted;
  }

  /**
   * getTierColor(tier)
   */
  function getTierColor(tier) {
    return TIER_COLORS[tier] || COLORS.textMuted;
  }

  // =========================================================================
  // FORMATTING
  // =========================================================================

  /**
   * formatQuestCard(quest, progress, status)
   * Returns HTML string for a quest card.
   * progress: array of { desc, current, target, percent } (from getQuestProgress)
   * status: 'available' | 'active' | 'completed'
   */
  function formatQuestCard(quest, progress, status) {
    if (!quest) { return '<div style="color:#666">Quest not found</div>'; }
    progress = progress || [];
    status = status || 'available';

    var diffColor = getDifficultyColor(quest.difficulty);
    var catIcon = CATEGORY_ICONS[quest.category] || '[?]';
    var statusLabel = status === 'available' ? '[Available]' :
                      status === 'active'    ? '[Active]' :
                                              '[Complete]';
    var statusColor = status === 'available' ? COLORS.textMuted :
                      status === 'active'    ? COLORS.accent :
                                              COLORS.success;

    var html = '';
    html += '<div style="' + _cardStyle() + '">';

    // Header row
    html += '<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">';
    html += '<span style="font-weight:bold;color:' + COLORS.text + '">' + _escapeHtml(quest.title) + '</span>';
    html += '<span style="font-size:11px;color:' + statusColor + '">' + statusLabel + '</span>';
    html += '</div>';

    // Category + difficulty row
    html += '<div style="margin-bottom:6px">';
    html += '<span style="' + _labelStyle(COLORS.textDim) + '">' + catIcon + ' ' + _escapeHtml(quest.category) + '</span>';
    html += '<span style="' + _labelStyle(diffColor) + '">(' + _escapeHtml(quest.difficulty.charAt(0).toUpperCase() + quest.difficulty.slice(1)) + ')</span>';
    html += '</div>';

    // Description
    html += '<div style="color:' + COLORS.textMuted + ';font-size:12px;margin-bottom:8px">' + _escapeHtml(quest.desc) + '</div>';

    // Objectives with progress bars
    if (quest.objectives && quest.objectives.length > 0) {
      html += '<div style="margin-bottom:8px">';
      for (var i = 0; i < quest.objectives.length; i++) {
        var obj = quest.objectives[i];
        var prog = progress[i] || { current: 0, target: obj.target, percent: 0, desc: obj.desc };
        var bar = _progressBar(prog.current, prog.target);
        html += '<div style="font-size:11px;color:' + COLORS.textMuted + ';margin-bottom:4px">';
        html += _escapeHtml(prog.desc) + ': ' + bar;
        html += '</div>';
        // Visual progress bar
        html += '<div style="' + _progressBarStyle() + '">';
        html += '<div style="' + _progressFillStyle(prog.percent, diffColor) + '"></div>';
        html += '</div>';
      }
      html += '</div>';
    }

    // Reward
    if (quest.reward) {
      html += '<div style="font-size:11px;color:' + COLORS.accent + '">';
      html += 'Reward: ';
      if (quest.reward.spark) { html += quest.reward.spark + ' Spark'; }
      if (quest.reward.item) { html += (quest.reward.spark ? ' + ' : '') + _escapeHtml(quest.reward.item); }
      html += '</div>';
    }

    // Action buttons
    html += '<div style="margin-top:8px;display:flex;gap:6px">';
    if (status === 'available') {
      html += '<button style="background:' + COLORS.accent + ';color:#000;border:none;padding:4px 10px;border-radius:3px;cursor:pointer;font-size:11px">Accept</button>';
    } else if (status === 'active') {
      html += '<button style="background:' + COLORS.danger + ';color:#fff;border:none;padding:4px 10px;border-radius:3px;cursor:pointer;font-size:11px">Abandon</button>';
    }
    html += '</div>';

    html += '</div>';
    return html;
  }

  /**
   * formatAchievementBadge(achievement, unlocked)
   * Returns HTML string for an achievement badge.
   */
  function formatAchievementBadge(achievement, unlocked) {
    if (!achievement) { return '<div style="color:#666">Achievement not found</div>'; }
    var tierColor = getTierColor(achievement.tier);
    var tierIcon = TIER_ICONS[achievement.tier] || '[?]';
    var opacity = unlocked ? '1' : '0.4';
    var lockText = unlocked ? '' : ' [Locked]';

    var html = '';
    html += '<div style="' + [
      'display:inline-block',
      'background:' + COLORS.bgCard,
      'border:2px solid ' + (unlocked ? tierColor : COLORS.border),
      'border-radius:6px',
      'padding:8px',
      'margin:4px',
      'min-width:120px',
      'max-width:160px',
      'vertical-align:top',
      'opacity:' + opacity,
      'text-align:center'
    ].join(';') + '">';

    // Tier badge
    html += '<div style="color:' + tierColor + ';font-weight:bold;font-size:16px;margin-bottom:4px">' + tierIcon + '</div>';

    // Title
    html += '<div style="font-weight:bold;color:' + COLORS.text + ';font-size:12px;margin-bottom:2px">' + _escapeHtml(achievement.title) + lockText + '</div>';

    // Description
    html += '<div style="color:' + COLORS.textMuted + ';font-size:11px;margin-bottom:4px">' + _escapeHtml(achievement.desc) + '</div>';

    // Tier label + points
    html += '<div style="' + _labelStyle(tierColor) + '">' + achievement.tier.toUpperCase() + '</div>';
    html += '<div style="font-size:10px;color:' + COLORS.textDim + ';margin-top:4px">' + achievement.points + ' pts</div>';

    html += '</div>';
    return html;
  }

  // =========================================================================
  // QUEST PANEL DOM (browser only)
  // =========================================================================

  /**
   * createQuestPanel()
   * Returns a DOM element for the quest & achievement panel.
   * Tabs: Available, Active, Completed, Achievements
   */
  function createQuestPanel() {
    if (typeof document === 'undefined') { return null; }

    var panelStyle = [
      'background:' + COLORS.bgPanel,
      'border:1px solid ' + COLORS.border,
      'border-radius:4px',
      'overflow:hidden',
      'min-height:300px',
      'font-family:monospace',
      'font-size:13px',
      'color:' + COLORS.text
    ].join(';');

    var panel = _createElement('div', { style: panelStyle });

    // Header
    var header = _createElement('div', {
      style: [
        'background:' + COLORS.bgHeader,
        'border-bottom:1px solid ' + COLORS.border,
        'padding:10px 14px',
        'font-weight:bold',
        'font-size:14px',
        'color:' + COLORS.accent
      ].join(';')
    }, 'QUESTS & ACHIEVEMENTS');
    panel.appendChild(header);

    // Tab bar
    var tabNames = ['Available', 'Active', 'Completed', 'Achievements'];
    var tabIds   = ['available', 'active', 'completed', 'achievements'];
    var tabBar = _createElement('div', {
      style: [
        'display:flex',
        'border-bottom:1px solid ' + COLORS.border,
        'background:' + COLORS.bgHeader
      ].join(';')
    });

    var tabContents = {};
    var tabButtons = {};

    function _activateTab(id) {
      for (var t in tabContents) {
        tabContents[t].style.display = 'none';
        tabButtons[t].style.borderBottom = '2px solid transparent';
        tabButtons[t].style.color = COLORS.textMuted;
      }
      tabContents[id].style.display = 'block';
      tabButtons[id].style.borderBottom = '2px solid ' + COLORS.accent;
      tabButtons[id].style.color = COLORS.accent;
    }

    for (var ti = 0; ti < tabNames.length; ti++) {
      (function(name, id) {
        var btn = _createElement('button', {
          style: [
            'background:transparent',
            'border:none',
            'border-bottom:2px solid transparent',
            'padding:8px 14px',
            'cursor:pointer',
            'font-size:12px',
            'color:' + COLORS.textMuted,
            'font-family:monospace'
          ].join(';')
        }, name);
        btn.addEventListener('click', function() { _activateTab(id); });
        tabBar.appendChild(btn);
        tabButtons[id] = btn;
      })(tabNames[ti], tabIds[ti]);
    }
    panel.appendChild(tabBar);

    // Tab content areas
    var contentWrap = _createElement('div', {
      style: 'padding:12px;overflow-y:auto;max-height:420px'
    });

    for (var ci = 0; ci < tabIds.length; ci++) {
      (function(id, name) {
        var content = _createElement('div', { style: 'display:none' });
        content.innerHTML = _buildTabContent(id);
        tabContents[id] = content;
        contentWrap.appendChild(content);
      })(tabIds[ci], tabNames[ci]);
    }

    panel.appendChild(contentWrap);

    // Activate first tab
    _activateTab('available');
    return panel;
  }

  /**
   * Build static HTML content for a tab (used in createQuestPanel).
   * In a real integration these would be populated from live state.
   */
  function _buildTabContent(tabId) {
    var html = '';
    if (tabId === 'available') {
      var categories = ['exploration', 'social', 'crafting', 'economy', 'minigame'];
      for (var ci = 0; ci < categories.length; ci++) {
        var cat = categories[ci];
        var quests = getQuestsByCategory(cat);
        if (quests.length === 0) { continue; }
        html += '<div style="margin-bottom:8px;font-size:11px;color:' + COLORS.textDim + ';text-transform:uppercase;letter-spacing:1px">';
        html += (CATEGORY_ICONS[cat] || '') + ' ' + cat;
        html += '</div>';
        for (var qi = 0; qi < quests.length; qi++) {
          html += formatQuestCard(quests[qi], [], 'available');
        }
      }
    } else if (tabId === 'active') {
      html += '<div style="color:' + COLORS.textMuted + ';font-size:12px">No active quests. Accept quests from the Available tab.</div>';
    } else if (tabId === 'completed') {
      html += '<div style="color:' + COLORS.textMuted + ';font-size:12px">No completed quests yet.</div>';
    } else if (tabId === 'achievements') {
      html += '<div style="margin-bottom:10px;font-size:12px;color:' + COLORS.textMuted + '">0 / ' + Object.keys(ACHIEVEMENTS).length + ' achievements unlocked</div>';
      for (var id in ACHIEVEMENTS) {
        if (!Object.prototype.hasOwnProperty.call(ACHIEVEMENTS, id)) { continue; }
        html += formatAchievementBadge(ACHIEVEMENTS[id], false);
      }
    }
    return html;
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.QUEST_CATALOG       = QUEST_CATALOG;
  exports.ACHIEVEMENTS        = ACHIEVEMENTS;
  exports.DIFFICULTY_COLORS   = DIFFICULTY_COLORS;
  exports.TIER_COLORS         = TIER_COLORS;

  // State
  exports.createQuestState        = createQuestState;

  // Queries
  exports.getAvailableQuests      = getAvailableQuests;
  exports.getQuestsByCategory     = getQuestsByCategory;
  exports.getQuestReward          = getQuestReward;
  exports.getQuestProgress        = getQuestProgress;
  exports.getAchievementProgress  = getAchievementProgress;
  exports.getCompletionSummary    = getCompletionSummary;

  // Lifecycle
  exports.acceptQuest             = acceptQuest;
  exports.updateQuestProgress     = updateQuestProgress;
  exports.completeQuest           = completeQuest;
  exports.abandonQuest            = abandonQuest;

  // Achievements
  exports.checkAchievement        = checkAchievement;
  exports.unlockAchievement       = unlockAchievement;

  // Formatting
  exports.formatQuestCard         = formatQuestCard;
  exports.formatAchievementBadge  = formatAchievementBadge;

  // Color helpers
  exports.getDifficultyColor      = getDifficultyColor;
  exports.getTierColor            = getTierColor;

  // DOM panel (browser)
  exports.createQuestPanel        = createQuestPanel;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardQuests = {}));


// dashboard_social.js
// dashboard_social.js
/**
 * dashboard_social.js - Social Hub panel for ZION dashboard mode
 *
 * Provides chat, guild management, player profiles, and leaderboards
 * as a self-contained UI panel for the dashboard (UI-only) mode.
 *
 * UMD module: window.DashboardSocial (browser) or module.exports (Node.js)
 * ES5 compatible - uses var declarations
 */
(function(exports) {
  'use strict';

  // â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var MAX_MESSAGES_PER_CHANNEL = 200;
  var DEFAULT_MESSAGE_LIMIT = 50;
  var DEFAULT_LEADERBOARD_LIMIT = 10;
  var MAX_LEADERBOARD_ENTRIES = 100;
  var MAX_GUILD_MEMBERS = 50;
  var MAX_GUILD_NAME_LENGTH = 30;
  var MAX_GUILD_MOTTO_LENGTH = 100;
  var MAX_PLAYER_LEVEL = 50;

  var CHANNEL_TYPES = ['global', 'zone', 'guild', 'whisper'];

  var MESSAGE_TYPES = {
    CHAT: 'chat',
    SYSTEM: 'system',
    EMOTE: 'emote',
    TRADE: 'trade'
  };

  var LEADERBOARD_CATEGORIES = [
    'spark',
    'quests',
    'reputation',
    'crafting',
    'exploration',
    'fishing',
    'cards',
    'dungeons',
    'social'
  ];

  var COLORS = {
    bg: '#0A0E1A',
    bgPanel: '#111827',
    bgHeader: '#0D1321',
    bgTab: '#161F2E',
    bgTabActive: '#1E2D44',
    border: '#1E3A5F',
    borderHighlight: '#2A5285',
    accent: '#DAA520',
    accentHover: '#F0B830',
    text: '#E8E0D8',
    textMuted: '#8A9AB0',
    textDim: '#4A5A70',
    system: '#DAA520',
    whisper: '#C77DFF',
    emote: '#A8D8EA',
    trade: '#FFB347',
    gold: '#FFD700',
    silver: '#C0C0C0',
    bronze: '#CD7F32',
    profileBg: '#0D1321',
    profileBorder: '#DAA520'
  };

  var RANK_BADGES = {
    1: { label: '[1st]', color: '#FFD700' },
    2: { label: '[2nd]', color: '#C0C0C0' },
    3: { label: '[3rd]', color: '#CD7F32' }
  };

  var PLAYER_TITLES = {
    newcomer: 'Newcomer',
    citizen: 'Citizen',
    veteran: 'Veteran',
    elder: 'Elder',
    master: 'Master',
    legend: 'Legend'
  };

  // â”€â”€â”€ Utility Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _escapeHtml(str) {
    if (typeof str !== 'string') { return String(str); }
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function _formatTimestamp(ts) {
    var d = new Date(ts);
    var h = d.getHours();
    var m = d.getMinutes();
    var hh = h < 10 ? '0' + h : String(h);
    var mm = m < 10 ? '0' + m : String(m);
    return hh + ':' + mm;
  }

  function _now() {
    return Date.now();
  }

  function _createElement(tag, attrs, innerHTML) {
    if (typeof document === 'undefined') { return null; }
    var el = document.createElement(tag);
    if (attrs) {
      for (var k in attrs) {
        if (Object.prototype.hasOwnProperty.call(attrs, k)) {
          if (k === 'style') {
            el.style.cssText = attrs[k];
          } else if (k === 'className') {
            el.className = attrs[k];
          } else {
            el.setAttribute(k, attrs[k]);
          }
        }
      }
    }
    if (innerHTML !== undefined) {
      el.innerHTML = innerHTML;
    }
    return el;
  }

  // â”€â”€â”€ Chat System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create initial chat state.
   * @returns {object} Chat state with channels, activeChannel, unread
   */
  function createChatState() {
    return {
      channels: {
        global: [],
        zone: [],
        guild: [],
        whisper: {}
      },
      activeChannel: 'global',
      unread: {
        global: 0,
        zone: 0,
        guild: 0,
        whisper: 0
      }
    };
  }

  /**
   * Add a message to a channel.
   * @param {object} state - Chat state
   * @param {string} channel - Channel name ('global', 'zone', 'guild', or whisper key)
   * @param {object} message - { from, text, timestamp, type }
   * @returns {object} Updated state
   */
  function addMessage(state, channel, message) {
    if (!state || !channel || !message) { return state; }

    var msg = {
      from: message.from || 'Unknown',
      text: message.text || '',
      timestamp: message.timestamp || _now(),
      type: message.type || MESSAGE_TYPES.CHAT
    };

    var newState = {
      channels: {
        global: state.channels.global ? state.channels.global.slice() : [],
        zone: state.channels.zone ? state.channels.zone.slice() : [],
        guild: state.channels.guild ? state.channels.guild.slice() : [],
        whisper: {}
      },
      activeChannel: state.activeChannel,
      unread: {
        global: state.unread.global || 0,
        zone: state.unread.zone || 0,
        guild: state.unread.guild || 0,
        whisper: state.unread.whisper || 0
      }
    };

    // Copy whisper channels
    if (state.channels.whisper) {
      for (var wk in state.channels.whisper) {
        if (Object.prototype.hasOwnProperty.call(state.channels.whisper, wk)) {
          newState.channels.whisper[wk] = state.channels.whisper[wk].slice();
        }
      }
    }

    // Determine target array
    if (channel === 'global' || channel === 'zone' || channel === 'guild') {
      newState.channels[channel].push(msg);
      // Cap at max
      if (newState.channels[channel].length > MAX_MESSAGES_PER_CHANNEL) {
        newState.channels[channel] = newState.channels[channel].slice(
          newState.channels[channel].length - MAX_MESSAGES_PER_CHANNEL
        );
      }
      // Track unread if not active channel
      if (newState.activeChannel !== channel) {
        newState.unread[channel] = (newState.unread[channel] || 0) + 1;
      }
    } else {
      // Whisper channel
      if (!newState.channels.whisper[channel]) {
        newState.channels.whisper[channel] = [];
      }
      newState.channels.whisper[channel].push(msg);
      // Cap at max
      if (newState.channels.whisper[channel].length > MAX_MESSAGES_PER_CHANNEL) {
        newState.channels.whisper[channel] = newState.channels.whisper[channel].slice(
          newState.channels.whisper[channel].length - MAX_MESSAGES_PER_CHANNEL
        );
      }
      // Track unread if not active whisper channel
      if (newState.activeChannel !== channel) {
        newState.unread.whisper = (newState.unread.whisper || 0) + 1;
      }
    }

    return newState;
  }

  /**
   * Get the last N messages from a channel.
   * @param {object} state - Chat state
   * @param {string} channel - Channel name
   * @param {number} [limit] - Max messages to return (default 50)
   * @returns {Array} Array of messages
   */
  function getMessages(state, channel, limit) {
    if (!state || !channel) { return []; }
    var n = (limit !== undefined && limit !== null) ? limit : DEFAULT_MESSAGE_LIMIT;

    if (channel === 'global' || channel === 'zone' || channel === 'guild') {
      var arr = state.channels[channel] || [];
      return arr.slice(Math.max(0, arr.length - n));
    }
    // Whisper
    var whispers = (state.channels.whisper || {});
    var wArr = whispers[channel] || [];
    return wArr.slice(Math.max(0, wArr.length - n));
  }

  /**
   * Switch active channel and clear unread for new channel.
   * @param {object} state - Chat state
   * @param {string} channel - Channel to switch to
   * @returns {object} Updated state
   */
  function switchChannel(state, channel) {
    if (!state || !channel) { return state; }

    var newState = {
      channels: state.channels,
      activeChannel: channel,
      unread: {
        global: state.unread.global || 0,
        zone: state.unread.zone || 0,
        guild: state.unread.guild || 0,
        whisper: state.unread.whisper || 0
      }
    };

    // Clear unread for the new channel
    if (channel === 'global' || channel === 'zone' || channel === 'guild') {
      newState.unread[channel] = 0;
    } else {
      // Whisper channel - clear whisper unread
      newState.unread.whisper = 0;
    }

    return newState;
  }

  /**
   * Get unread count for a channel.
   * @param {object} state - Chat state
   * @param {string} channel - Channel name
   * @returns {number} Unread count
   */
  function getUnreadCount(state, channel) {
    if (!state || !channel) { return 0; }
    if (channel === 'global' || channel === 'zone' || channel === 'guild') {
      return state.unread[channel] || 0;
    }
    return state.unread.whisper || 0;
  }

  /**
   * Send a private whisper message.
   * @param {object} state - Chat state
   * @param {string} fromId - Sender player ID
   * @param {string} toId - Recipient player ID
   * @param {string} text - Message text
   * @returns {object} Updated state
   */
  function sendWhisper(state, fromId, toId, text) {
    if (!state || !fromId || !toId || !text) { return state; }

    // Whisper channel key is based on the two participants (sorted for consistency)
    var channelKey = [fromId, toId].sort().join(':');

    var msg = {
      from: fromId,
      text: text,
      timestamp: _now(),
      type: MESSAGE_TYPES.CHAT
    };

    return addMessage(state, channelKey, msg);
  }

  /**
   * Format a chat message as HTML.
   * @param {object} msg - Message object { from, text, timestamp, type }
   * @returns {string} HTML string
   */
  function formatMessage(msg) {
    if (!msg) { return ''; }

    var ts = _formatTimestamp(msg.timestamp || 0);
    var from = _escapeHtml(msg.from || 'Unknown');
    var text = _escapeHtml(msg.text || '');
    var type = msg.type || MESSAGE_TYPES.CHAT;

    var tsHtml = '<span style="color:' + COLORS.textMuted + ';font-size:11px;">[' + ts + ']</span>';

    if (type === MESSAGE_TYPES.SYSTEM) {
      return '<div style="color:' + COLORS.system + ';padding:2px 0;">' +
        tsHtml + ' <em>' + text + '</em></div>';
    }

    if (type === MESSAGE_TYPES.EMOTE) {
      return '<div style="color:' + COLORS.emote + ';font-style:italic;padding:2px 0;">' +
        tsHtml + ' * ' + from + ' ' + text + '</div>';
    }

    if (type === MESSAGE_TYPES.TRADE) {
      return '<div style="color:' + COLORS.trade + ';padding:2px 0;">' +
        tsHtml + ' <strong>' + from + '</strong>: ' + text + '</div>';
    }

    // Check if it's a whisper by looking for the whisper color hint in context
    // We determine whisper by the channel, but formatMessage only gets the msg.
    // Use a custom attribute if provided
    if (msg._whisper) {
      return '<div style="color:' + COLORS.whisper + ';padding:2px 0;">' +
        tsHtml + ' <strong>' + from + '</strong>: ' + text + '</div>';
    }

    // Default chat
    return '<div style="color:' + COLORS.text + ';padding:2px 0;">' +
      tsHtml + ' <strong>' + from + '</strong>: ' + text + '</div>';
  }

  // â”€â”€â”€ Guild System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create initial guild state.
   * @returns {object} Guild state
   */
  function createGuildState() {
    return {
      guilds: [],
      playerGuild: {},
      invites: []
    };
  }

  /**
   * Create a new guild.
   * @param {object} state - Guild state
   * @param {string} name - Guild name (max 30 chars)
   * @param {string} leaderId - Leader player ID
   * @param {string} motto - Guild motto (max 100 chars)
   * @returns {{ success: boolean, state: object, guild?: object, error?: string }}
   */
  function createGuild(state, name, leaderId, motto) {
    if (!state || !name || !leaderId) {
      return { success: false, error: 'Missing required parameters', state: state };
    }

    if (name.length > MAX_GUILD_NAME_LENGTH) {
      return { success: false, error: 'Guild name too long (max ' + MAX_GUILD_NAME_LENGTH + ' chars)', state: state };
    }

    if (motto && motto.length > MAX_GUILD_MOTTO_LENGTH) {
      return { success: false, error: 'Guild motto too long (max ' + MAX_GUILD_MOTTO_LENGTH + ' chars)', state: state };
    }

    // Check for duplicate name
    var existing = state.guilds.filter(function(g) {
      return g.name.toLowerCase() === name.toLowerCase();
    });
    if (existing.length > 0) {
      return { success: false, error: 'Guild name already taken', state: state };
    }

    // Check if player is already in a guild
    if (state.playerGuild[leaderId]) {
      return { success: false, error: 'Player is already in a guild', state: state };
    }

    var guild = {
      id: 'guild_' + _now() + '_' + Math.floor(Math.random() * 10000),
      name: name,
      motto: motto || '',
      leaderId: leaderId,
      members: [{ playerId: leaderId, role: 'leader', joinedAt: _now() }],
      createdAt: _now(),
      level: 1,
      color: COLORS.accent
    };

    var newGuilds = state.guilds.slice();
    newGuilds.push(guild);

    var newPlayerGuild = {};
    for (var pk in state.playerGuild) {
      if (Object.prototype.hasOwnProperty.call(state.playerGuild, pk)) {
        newPlayerGuild[pk] = state.playerGuild[pk];
      }
    }
    newPlayerGuild[leaderId] = guild.id;

    return {
      success: true,
      state: {
        guilds: newGuilds,
        playerGuild: newPlayerGuild,
        invites: state.invites ? state.invites.slice() : []
      },
      guild: guild
    };
  }

  /**
   * Join an existing guild.
   * @param {object} state - Guild state
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID
   * @returns {{ success: boolean, state: object, error?: string }}
   */
  function joinGuild(state, guildId, playerId) {
    if (!state || !guildId || !playerId) {
      return { success: false, error: 'Missing required parameters', state: state };
    }

    var guildIndex = -1;
    for (var i = 0; i < state.guilds.length; i++) {
      if (state.guilds[i].id === guildId) {
        guildIndex = i;
        break;
      }
    }

    if (guildIndex === -1) {
      return { success: false, error: 'Guild not found', state: state };
    }

    var guild = state.guilds[guildIndex];

    // Check max members
    if (guild.members.length >= MAX_GUILD_MEMBERS) {
      return { success: false, error: 'Guild is full (max ' + MAX_GUILD_MEMBERS + ' members)', state: state };
    }

    // Check if already a member
    var alreadyMember = guild.members.filter(function(m) {
      return m.playerId === playerId;
    }).length > 0;
    if (alreadyMember) {
      return { success: false, error: 'Player is already a member', state: state };
    }

    // Check if in another guild
    if (state.playerGuild[playerId]) {
      return { success: false, error: 'Player is already in a guild', state: state };
    }

    var newMember = { playerId: playerId, role: 'member', joinedAt: _now() };
    var newGuilds = state.guilds.map(function(g, idx) {
      if (idx === guildIndex) {
        return {
          id: g.id,
          name: g.name,
          motto: g.motto,
          leaderId: g.leaderId,
          members: g.members.concat([newMember]),
          createdAt: g.createdAt,
          level: g.level,
          color: g.color
        };
      }
      return g;
    });

    var newPlayerGuild = {};
    for (var pk in state.playerGuild) {
      if (Object.prototype.hasOwnProperty.call(state.playerGuild, pk)) {
        newPlayerGuild[pk] = state.playerGuild[pk];
      }
    }
    newPlayerGuild[playerId] = guildId;

    return {
      success: true,
      state: {
        guilds: newGuilds,
        playerGuild: newPlayerGuild,
        invites: state.invites ? state.invites.slice() : []
      }
    };
  }

  /**
   * Leave a guild.
   * @param {object} state - Guild state
   * @param {string} guildId - Guild ID
   * @param {string} playerId - Player ID
   * @returns {{ success: boolean, state: object, message?: string, error?: string }}
   */
  function leaveGuild(state, guildId, playerId) {
    if (!state || !guildId || !playerId) {
      return { success: false, error: 'Missing required parameters', state: state };
    }

    var guildIndex = -1;
    for (var i = 0; i < state.guilds.length; i++) {
      if (state.guilds[i].id === guildId) {
        guildIndex = i;
        break;
      }
    }

    if (guildIndex === -1) {
      return { success: false, error: 'Guild not found', state: state };
    }

    var guild = state.guilds[guildIndex];

    // Check membership
    var isMember = guild.members.filter(function(m) {
      return m.playerId === playerId;
    }).length > 0;
    if (!isMember) {
      return { success: false, error: 'Player is not a member of this guild', state: state };
    }

    // Leader cannot leave without transferring
    if (guild.leaderId === playerId) {
      return { success: false, error: 'Leader must transfer leadership before leaving', state: state, message: 'Leader must transfer leadership before leaving' };
    }

    var newMembers = guild.members.filter(function(m) {
      return m.playerId !== playerId;
    });

    var newGuilds = state.guilds.map(function(g, idx) {
      if (idx === guildIndex) {
        return {
          id: g.id,
          name: g.name,
          motto: g.motto,
          leaderId: g.leaderId,
          members: newMembers,
          createdAt: g.createdAt,
          level: g.level,
          color: g.color
        };
      }
      return g;
    });

    var newPlayerGuild = {};
    for (var pk in state.playerGuild) {
      if (Object.prototype.hasOwnProperty.call(state.playerGuild, pk)) {
        if (pk !== playerId) {
          newPlayerGuild[pk] = state.playerGuild[pk];
        }
      }
    }

    return {
      success: true,
      state: {
        guilds: newGuilds,
        playerGuild: newPlayerGuild,
        invites: state.invites ? state.invites.slice() : []
      },
      message: 'Left guild successfully'
    };
  }

  /**
   * Invite a player to a guild.
   * @param {object} state - Guild state
   * @param {string} guildId - Guild ID
   * @param {string} inviterId - ID of the player sending the invite
   * @param {string} inviteeId - ID of the player being invited
   * @returns {{ success: boolean, state: object, invite?: object, error?: string }}
   */
  function inviteToGuild(state, guildId, inviterId, inviteeId) {
    if (!state || !guildId || !inviterId || !inviteeId) {
      return { success: false, error: 'Missing required parameters', state: state };
    }

    // Cannot invite yourself
    if (inviterId === inviteeId) {
      return { success: false, error: 'Cannot invite yourself', state: state };
    }

    var guild = null;
    for (var i = 0; i < state.guilds.length; i++) {
      if (state.guilds[i].id === guildId) {
        guild = state.guilds[i];
        break;
      }
    }

    if (!guild) {
      return { success: false, error: 'Guild not found', state: state };
    }

    // Check inviter is a member
    var inviterMember = guild.members.filter(function(m) {
      return m.playerId === inviterId;
    }).length > 0;
    if (!inviterMember) {
      return { success: false, error: 'Inviter is not a member of this guild', state: state };
    }

    // Check if invitee is already a member
    var alreadyMember = guild.members.filter(function(m) {
      return m.playerId === inviteeId;
    }).length > 0;
    if (alreadyMember) {
      return { success: false, error: 'Player is already a member', state: state };
    }

    // Check if guild is full
    if (guild.members.length >= MAX_GUILD_MEMBERS) {
      return { success: false, error: 'Guild is full', state: state };
    }

    // Check for duplicate invite
    var existingInvite = (state.invites || []).filter(function(inv) {
      return inv.guildId === guildId && inv.inviteeId === inviteeId;
    }).length > 0;
    if (existingInvite) {
      return { success: false, error: 'Invite already pending', state: state };
    }

    var invite = {
      id: 'inv_' + _now() + '_' + Math.floor(Math.random() * 10000),
      guildId: guildId,
      guildName: guild.name,
      inviterId: inviterId,
      inviteeId: inviteeId,
      createdAt: _now()
    };

    var newInvites = (state.invites ? state.invites.slice() : []);
    newInvites.push(invite);

    return {
      success: true,
      state: {
        guilds: state.guilds,
        playerGuild: state.playerGuild,
        invites: newInvites
      },
      invite: invite
    };
  }

  /**
   * Get guild info by ID.
   * @param {object} state - Guild state
   * @param {string} guildId - Guild ID
   * @returns {object|null} Guild details or null
   */
  function getGuildInfo(state, guildId) {
    if (!state || !guildId) { return null; }
    for (var i = 0; i < state.guilds.length; i++) {
      if (state.guilds[i].id === guildId) {
        var g = state.guilds[i];
        return {
          id: g.id,
          name: g.name,
          motto: g.motto || '',
          leader: g.leaderId,
          members: g.members,
          createdAt: g.createdAt,
          level: g.level || 1,
          color: g.color || COLORS.accent
        };
      }
    }
    return null;
  }

  /**
   * Get guild member list.
   * @param {object} state - Guild state
   * @param {string} guildId - Guild ID
   * @returns {Array} Member list with roles
   */
  function getGuildMembers(state, guildId) {
    var info = getGuildInfo(state, guildId);
    if (!info) { return []; }
    return info.members.slice();
  }

  /**
   * Format a guild info card as HTML.
   * @param {object} guild - Guild object
   * @param {boolean} isOwn - Whether this is the player's own guild
   * @returns {string} HTML string
   */
  function formatGuildCard(guild, isOwn) {
    if (!guild) { return '<div style="color:' + COLORS.textMuted + '">No guild data</div>'; }

    var name = _escapeHtml(guild.name || '');
    var motto = _escapeHtml(guild.motto || '');
    var level = guild.level || 1;
    var memberCount = guild.members ? guild.members.length : 0;
    var color = guild.color || COLORS.accent;
    var ownBadge = isOwn ? ' <span style="color:' + COLORS.accent + ';font-size:11px;">[Your Guild]</span>' : '';

    var html = '<div style="background:' + COLORS.profileBg + ';border:1px solid ' + color + ';' +
      'border-radius:4px;padding:10px;margin:4px 0;">';
    html += '<div style="color:' + color + ';font-weight:bold;font-size:14px;">' + name + ownBadge + '</div>';
    if (motto) {
      html += '<div style="color:' + COLORS.textMuted + ';font-style:italic;font-size:12px;margin:2px 0;">' + motto + '</div>';
    }
    html += '<div style="color:' + COLORS.text + ';font-size:12px;margin-top:4px;">';
    html += 'Level ' + level + ' &bull; ' + memberCount + '/' + MAX_GUILD_MEMBERS + ' members';
    html += '</div>';
    html += '</div>';

    return html;
  }

  // â”€â”€â”€ Player Profiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create a player profile object.
   * @param {string} playerId - Player ID
   * @param {object} data - Profile data
   * @returns {object} Player profile
   */
  function createPlayerProfile(playerId, data) {
    if (!playerId) { return null; }
    var d = data || {};
    return {
      id: playerId,
      name: d.name || playerId,
      title: d.title || 'Newcomer',
      level: d.level || 1,
      zone: d.zone || 'nexus',
      spark: d.spark || 0,
      questsCompleted: d.questsCompleted || 0,
      joinDate: d.joinDate || _now(),
      playtime: d.playtime || 0,
      reputation: d.reputation || 0
    };
  }

  /**
   * Calculate player level from XP.
   * Formula: floor(sqrt(xp / 50)) + 1, max level 50
   * @param {number} xp - Experience points
   * @returns {number} Player level (1 - 50)
   */
  function getPlayerLevel(xp) {
    if (!xp || xp < 0) { return 1; }
    var level = Math.floor(Math.sqrt(xp / 50)) + 1;
    return Math.min(level, MAX_PLAYER_LEVEL);
  }

  /**
   * Get player title based on level and achievements.
   * @param {number} level - Player level
   * @param {Array} [achievements] - Optional achievements array
   * @returns {string} Player title
   */
  function getPlayerTitle(level, achievements) {
    if (!level || level < 1) { return PLAYER_TITLES.newcomer; }
    if (level <= 5) { return PLAYER_TITLES.newcomer; }
    if (level <= 10) { return PLAYER_TITLES.citizen; }
    if (level <= 20) { return PLAYER_TITLES.veteran; }
    if (level <= 30) { return PLAYER_TITLES.elder; }
    if (level <= 40) { return PLAYER_TITLES.master; }
    return PLAYER_TITLES.legend;
  }

  /**
   * Format a player profile card as HTML.
   * @param {object} profile - Player profile object
   * @returns {string} HTML string
   */
  function formatProfileCard(profile) {
    if (!profile) { return '<div style="color:' + COLORS.textMuted + '">No profile data</div>'; }

    var name = _escapeHtml(profile.name || profile.id || 'Unknown');
    var title = _escapeHtml(profile.title || 'Newcomer');
    var level = profile.level || 1;
    var zone = _escapeHtml(profile.zone || 'nexus');
    var spark = profile.spark || 0;
    var quests = profile.questsCompleted || 0;
    var rep = profile.reputation || 0;

    var html = '<div style="background:' + COLORS.profileBg + ';border:1px solid ' + COLORS.profileBorder + ';' +
      'border-radius:4px;padding:12px;margin:4px 0;">';

    html += '<div style="display:flex;justify-content:space-between;align-items:flex-start;">';
    html += '<div>';
    html += '<div style="color:' + COLORS.accent + ';font-weight:bold;font-size:15px;">' + name + '</div>';
    html += '<div style="color:' + COLORS.textMuted + ';font-size:12px;">' + title + ' &bull; Level ' + level + '</div>';
    html += '</div>';
    html += '<div style="color:' + COLORS.textDim + ';font-size:11px;text-align:right;">Zone: ' + zone + '</div>';
    html += '</div>';

    html += '<div style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap;">';
    html += '<span style="color:' + COLORS.text + ';font-size:12px;">Spark: <strong style="color:' + COLORS.gold + ';">' + spark + '</strong></span>';
    html += '<span style="color:' + COLORS.text + ';font-size:12px;">Quests: <strong>' + quests + '</strong></span>';
    html += '<span style="color:' + COLORS.text + ';font-size:12px;">Rep: <strong>' + rep + '</strong></span>';
    html += '</div>';

    html += '</div>';

    return html;
  }

  /**
   * Search players by name, title, or zone.
   * @param {Array} profiles - Array of player profiles
   * @param {string} query - Search query
   * @returns {Array} Matching profiles
   */
  function searchPlayers(profiles, query) {
    if (!profiles || !query) { return profiles || []; }
    var q = query.toLowerCase();
    return profiles.filter(function(p) {
      if (!p) { return false; }
      if (p.name && p.name.toLowerCase().indexOf(q) !== -1) { return true; }
      if (p.title && p.title.toLowerCase().indexOf(q) !== -1) { return true; }
      if (p.zone && p.zone.toLowerCase().indexOf(q) !== -1) { return true; }
      return false;
    });
  }

  // â”€â”€â”€ Leaderboard System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Create initial leaderboard state.
   * @returns {object} Leaderboard state
   */
  function createLeaderboardState() {
    return {
      categories: {},
      lastUpdated: 0
    };
  }

  /**
   * Update leaderboard for a category.
   * @param {object} state - Leaderboard state
   * @param {string} category - Category name
   * @param {Array} entries - [{ playerId, name, score }]
   * @returns {object} Updated state
   */
  function updateLeaderboard(state, category, entries) {
    if (!state || !category || !entries) { return state; }

    var sorted = entries.slice().sort(function(a, b) {
      return (b.score || 0) - (a.score || 0);
    });

    var top = sorted.slice(0, MAX_LEADERBOARD_ENTRIES);

    var newCategories = {};
    for (var k in state.categories) {
      if (Object.prototype.hasOwnProperty.call(state.categories, k)) {
        newCategories[k] = state.categories[k];
      }
    }
    newCategories[category] = top;

    return {
      categories: newCategories,
      lastUpdated: _now()
    };
  }

  /**
   * Get top N entries for a leaderboard category.
   * @param {object} state - Leaderboard state
   * @param {string} category - Category name
   * @param {number} [limit] - Max entries (default 10)
   * @returns {Array} Top entries
   */
  function getLeaderboard(state, category, limit) {
    if (!state || !category) { return []; }
    var n = (limit !== undefined && limit !== null) ? limit : DEFAULT_LEADERBOARD_LIMIT;
    var entries = (state.categories[category] || []);
    return entries.slice(0, n);
  }

  /**
   * Get a player's rank in a category.
   * @param {object} state - Leaderboard state
   * @param {string} category - Category name
   * @param {string} playerId - Player ID
   * @returns {{ rank: number, score: number, total: number } | null}
   */
  function getPlayerRank(state, category, playerId) {
    if (!state || !category || !playerId) { return null; }
    var entries = state.categories[category] || [];
    for (var i = 0; i < entries.length; i++) {
      if (entries[i].playerId === playerId) {
        return {
          rank: i + 1,
          score: entries[i].score || 0,
          total: entries.length
        };
      }
    }
    return null;
  }

  /**
   * Format a leaderboard as an HTML table.
   * @param {Array} entries - Leaderboard entries
   * @param {string} category - Category name
   * @param {object|null} playerRank - Player's rank info { rank, score }
   * @returns {string} HTML string
   */
  function formatLeaderboardTable(entries, category, playerRank) {
    if (!entries || entries.length === 0) {
      return '<div style="color:' + COLORS.textMuted + ';padding:8px;">No entries yet</div>';
    }

    var categoryLabel = _escapeHtml(category || 'Score');
    var html = '<table style="width:100%;border-collapse:collapse;font-size:12px;">';
    html += '<thead>';
    html += '<tr style="color:' + COLORS.textMuted + ';border-bottom:1px solid ' + COLORS.border + ';">';
    html += '<th style="text-align:left;padding:4px 6px;width:50px;">Rank</th>';
    html += '<th style="text-align:left;padding:4px 6px;">Player</th>';
    html += '<th style="text-align:right;padding:4px 6px;">' + categoryLabel + '</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';

    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      var rank = i + 1;
      var isCurrentPlayer = playerRank && entry.playerId &&
        playerRank.playerId && entry.playerId === playerRank.playerId;
      var rowBg = isCurrentPlayer ? 'background:' + COLORS.bgTabActive + ';' : '';

      var rankDisplay;
      if (RANK_BADGES[rank]) {
        var badge = RANK_BADGES[rank];
        rankDisplay = '<span style="color:' + badge.color + ';font-weight:bold;">' + badge.label + '</span>';
      } else {
        rankDisplay = '<span style="color:' + COLORS.textMuted + ';">#' + rank + '</span>';
      }

      html += '<tr style="border-bottom:1px solid ' + COLORS.bgTab + ';' + rowBg + '">';
      html += '<td style="padding:4px 6px;">' + rankDisplay + '</td>';
      html += '<td style="padding:4px 6px;color:' + COLORS.text + ';">' + _escapeHtml(entry.name || entry.playerId || 'Unknown') + '</td>';
      html += '<td style="padding:4px 6px;text-align:right;color:' + COLORS.accent + ';font-weight:bold;">' + (entry.score || 0) + '</td>';
      html += '</tr>';
    }

    html += '</tbody>';
    html += '</table>';

    return html;
  }

  // â”€â”€â”€ Panel Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  var PANEL_STYLE = [
    'background:' + COLORS.bgPanel,
    'border:1px solid ' + COLORS.border,
    'border-radius:4px',
    'display:flex',
    'flex-direction:column',
    'overflow:hidden',
    'min-height:300px',
    'max-height:600px',
    'font-family:monospace',
    'font-size:13px',
    'color:' + COLORS.text
  ].join(';');

  var TAB_BASE_STYLE = [
    'padding:6px 14px',
    'cursor:pointer',
    'border:none',
    'background:' + COLORS.bgTab,
    'color:' + COLORS.textMuted,
    'font-size:12px',
    'font-family:monospace',
    'border-right:1px solid ' + COLORS.border
  ].join(';');

  var TAB_ACTIVE_STYLE = TAB_BASE_STYLE + ';background:' + COLORS.bgTabActive + ';color:' + COLORS.accent + ';font-weight:bold;';

  var INPUT_STYLE = [
    'background:' + COLORS.bg,
    'border:1px solid ' + COLORS.border,
    'color:' + COLORS.text,
    'padding:4px 8px',
    'font-family:monospace',
    'font-size:12px',
    'border-radius:3px',
    'flex:1'
  ].join(';');

  var BUTTON_STYLE = [
    'background:' + COLORS.bgTabActive,
    'border:1px solid ' + COLORS.borderHighlight,
    'color:' + COLORS.accent,
    'padding:4px 10px',
    'cursor:pointer',
    'font-family:monospace',
    'font-size:12px',
    'border-radius:3px'
  ].join(';');

  /**
   * Build the Chat tab content element.
   * @param {object} chatState - Chat state
   * @returns {Element|object} DOM element or mock for Node.js
   */
  function _buildChatTab(chatState) {
    if (typeof document === 'undefined') {
      return { _type: 'chat-tab', chatState: chatState };
    }

    var state = chatState || createChatState();
    var wrap = document.createElement('div');
    wrap.style.cssText = 'display:flex;flex-direction:column;height:100%;';

    // Channel selector
    var channels = document.createElement('div');
    channels.style.cssText = 'display:flex;border-bottom:1px solid ' + COLORS.border + ';';

    var channelList = ['global', 'zone', 'guild', 'whisper'];
    var activeTab = state.activeChannel;
    channelList.forEach(function(ch) {
      var btn = document.createElement('button');
      btn.textContent = ch;
      btn.style.cssText = ch === activeTab ? TAB_ACTIVE_STYLE : TAB_BASE_STYLE;
      btn.setAttribute('data-channel', ch);
      channels.appendChild(btn);
    });
    wrap.appendChild(channels);

    // Message history
    var history = document.createElement('div');
    history.style.cssText = 'flex:1;overflow-y:auto;padding:8px;min-height:180px;';
    var msgs = getMessages(state, state.activeChannel, 50);
    var histHtml = '';
    msgs.forEach(function(m) { histHtml += formatMessage(m); });
    history.innerHTML = histHtml;
    wrap.appendChild(history);

    // Input area
    var inputArea = document.createElement('div');
    inputArea.style.cssText = 'display:flex;gap:6px;padding:8px;border-top:1px solid ' + COLORS.border + ';';

    var input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Type a message...';
    input.style.cssText = INPUT_STYLE;

    var sendBtn = document.createElement('button');
    sendBtn.textContent = 'Send';
    sendBtn.style.cssText = BUTTON_STYLE;

    inputArea.appendChild(input);
    inputArea.appendChild(sendBtn);
    wrap.appendChild(inputArea);

    return wrap;
  }

  /**
   * Build the Guild tab content element.
   * @param {object} guildState - Guild state
   * @param {string} playerId - Current player ID
   * @returns {Element|object} DOM element or mock
   */
  function _buildGuildTab(guildState, playerId) {
    if (typeof document === 'undefined') {
      return { _type: 'guild-tab', guildState: guildState, playerId: playerId };
    }

    var state = guildState || createGuildState();
    var wrap = document.createElement('div');
    wrap.style.cssText = 'padding:10px;overflow-y:auto;height:100%;';

    var myGuildId = playerId && state.playerGuild ? state.playerGuild[playerId] : null;

    if (myGuildId) {
      // Show guild info
      var info = getGuildInfo(state, myGuildId);
      if (info) {
        var guildCard = document.createElement('div');
        guildCard.innerHTML = formatGuildCard(info, true);
        wrap.appendChild(guildCard);

        // Member list
        var membersTitle = document.createElement('div');
        membersTitle.style.cssText = 'color:' + COLORS.textMuted + ';font-size:11px;margin:8px 0 4px;';
        membersTitle.textContent = 'Members (' + info.members.length + '/' + MAX_GUILD_MEMBERS + ')';
        wrap.appendChild(membersTitle);

        var membersList = document.createElement('div');
        info.members.forEach(function(m) {
          var row = document.createElement('div');
          row.style.cssText = 'padding:3px 0;color:' + COLORS.text + ';font-size:12px;';
          var roleColor = m.role === 'leader' ? COLORS.accent : COLORS.textMuted;
          row.innerHTML = '<span style="color:' + roleColor + ';">[' + (m.role || 'member') + ']</span> ' +
            _escapeHtml(m.playerId);
          membersList.appendChild(row);
        });
        wrap.appendChild(membersList);

        // Invite form
        var inviteSection = document.createElement('div');
        inviteSection.style.cssText = 'margin-top:12px;border-top:1px solid ' + COLORS.border + ';padding-top:10px;';

        var inviteTitle = document.createElement('div');
        inviteTitle.style.cssText = 'color:' + COLORS.textMuted + ';font-size:11px;margin-bottom:6px;';
        inviteTitle.textContent = 'Invite Player';
        inviteSection.appendChild(inviteTitle);

        var inviteRow = document.createElement('div');
        inviteRow.style.cssText = 'display:flex;gap:6px;';

        var inviteInput = document.createElement('input');
        inviteInput.type = 'text';
        inviteInput.placeholder = 'Player name...';
        inviteInput.style.cssText = INPUT_STYLE;

        var inviteBtn = document.createElement('button');
        inviteBtn.textContent = 'Invite';
        inviteBtn.style.cssText = BUTTON_STYLE;

        inviteRow.appendChild(inviteInput);
        inviteRow.appendChild(inviteBtn);
        inviteSection.appendChild(inviteRow);
        wrap.appendChild(inviteSection);
      }
    } else {
      // Show create guild form
      var noGuildMsg = document.createElement('div');
      noGuildMsg.style.cssText = 'color:' + COLORS.textMuted + ';margin-bottom:12px;';
      noGuildMsg.textContent = 'You are not in a guild.';
      wrap.appendChild(noGuildMsg);

      var createSection = document.createElement('div');
      createSection.style.cssText = 'background:' + COLORS.profileBg + ';border:1px solid ' + COLORS.border + ';border-radius:4px;padding:12px;';

      var createTitle = document.createElement('div');
      createTitle.style.cssText = 'color:' + COLORS.accent + ';font-weight:bold;margin-bottom:8px;';
      createTitle.textContent = 'Create a Guild';
      createSection.appendChild(createTitle);

      var nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.placeholder = 'Guild name (max 30 chars)...';
      nameInput.style.cssText = INPUT_STYLE + ';display:block;width:100%;margin-bottom:6px;box-sizing:border-box;';
      createSection.appendChild(nameInput);

      var mottoInput = document.createElement('input');
      mottoInput.type = 'text';
      mottoInput.placeholder = 'Guild motto (max 100 chars)...';
      mottoInput.style.cssText = INPUT_STYLE + ';display:block;width:100%;margin-bottom:8px;box-sizing:border-box;';
      createSection.appendChild(mottoInput);

      var createBtn = document.createElement('button');
      createBtn.textContent = 'Create Guild';
      createBtn.style.cssText = BUTTON_STYLE;
      createSection.appendChild(createBtn);

      wrap.appendChild(createSection);
    }

    return wrap;
  }

  /**
   * Build the Players tab content element.
   * @param {Array} profiles - Player profiles
   * @param {string} [currentPlayerId] - Current player ID for context
   * @returns {Element|object} DOM element or mock
   */
  function _buildPlayersTab(profiles, currentPlayerId) {
    if (typeof document === 'undefined') {
      return { _type: 'players-tab', profiles: profiles };
    }

    var wrap = document.createElement('div');
    wrap.style.cssText = 'display:flex;flex-direction:column;height:100%;';

    // Search bar
    var searchRow = document.createElement('div');
    searchRow.style.cssText = 'display:flex;gap:6px;padding:8px;border-bottom:1px solid ' + COLORS.border + ';';

    var searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.placeholder = 'Search players...';
    searchInput.style.cssText = INPUT_STYLE;

    searchRow.appendChild(searchInput);
    wrap.appendChild(searchRow);

    // Player list
    var list = document.createElement('div');
    list.style.cssText = 'flex:1;overflow-y:auto;padding:8px;';

    var displayProfiles = profiles || [];
    if (displayProfiles.length === 0) {
      list.innerHTML = '<div style="color:' + COLORS.textMuted + ';padding:8px;">No players nearby</div>';
    } else {
      displayProfiles.forEach(function(profile) {
        var card = document.createElement('div');
        card.style.cssText = 'margin-bottom:8px;';
        card.innerHTML = formatProfileCard(profile);

        // Action buttons
        var actions = document.createElement('div');
        actions.style.cssText = 'display:flex;gap:6px;margin-top:4px;';

        var tradeBtn = document.createElement('button');
        tradeBtn.textContent = 'Trade';
        tradeBtn.style.cssText = BUTTON_STYLE;

        var msgBtn = document.createElement('button');
        msgBtn.textContent = 'Message';
        msgBtn.style.cssText = BUTTON_STYLE;

        actions.appendChild(tradeBtn);
        actions.appendChild(msgBtn);
        card.appendChild(actions);

        list.appendChild(card);
      });
    }

    wrap.appendChild(list);
    return wrap;
  }

  /**
   * Build the Leaderboards tab content element.
   * @param {object} lbState - Leaderboard state
   * @param {string} [playerId] - Current player ID
   * @returns {Element|object} DOM element or mock
   */
  function _buildLeaderboardsTab(lbState, playerId) {
    if (typeof document === 'undefined') {
      return { _type: 'leaderboards-tab', lbState: lbState };
    }

    var state = lbState || createLeaderboardState();
    var wrap = document.createElement('div');
    wrap.style.cssText = 'display:flex;flex-direction:column;height:100%;';

    // Category tabs
    var catTabs = document.createElement('div');
    catTabs.style.cssText = 'display:flex;flex-wrap:wrap;border-bottom:1px solid ' + COLORS.border + ';padding:4px;gap:2px;';

    var activeCategory = LEADERBOARD_CATEGORIES[0];
    LEADERBOARD_CATEGORIES.forEach(function(cat) {
      var btn = document.createElement('button');
      btn.textContent = cat;
      btn.style.cssText = cat === activeCategory ? TAB_ACTIVE_STYLE : TAB_BASE_STYLE;
      btn.setAttribute('data-category', cat);
      catTabs.appendChild(btn);
    });
    wrap.appendChild(catTabs);

    // Leaderboard content
    var content = document.createElement('div');
    content.style.cssText = 'flex:1;overflow-y:auto;padding:10px;';

    var entries = getLeaderboard(state, activeCategory, 10);
    var playerRank = playerId ? getPlayerRank(state, activeCategory, playerId) : null;
    content.innerHTML = formatLeaderboardTable(entries, activeCategory, playerRank);
    wrap.appendChild(content);

    return wrap;
  }

  /**
   * Create the main Social Hub panel DOM element.
   * @param {object} [opts] - Options { chatState, guildState, profiles, lbState, playerId }
   * @returns {Element|object} DOM element or mock
   */
  function createSocialPanel(opts) {
    var options = opts || {};
    var chatState = options.chatState || createChatState();
    var guildState = options.guildState || createGuildState();
    var profiles = options.profiles || [];
    var lbState = options.lbState || createLeaderboardState();
    var playerId = options.playerId || null;

    if (typeof document === 'undefined') {
      // Return mock object for Node.js
      return {
        _type: 'social-panel',
        _panelId: 'social-hub',
        tabs: ['Chat', 'Guild', 'Players', 'Leaderboards'],
        chatState: chatState,
        guildState: guildState,
        profiles: profiles,
        lbState: lbState
      };
    }

    var panel = document.createElement('div');
    panel.style.cssText = PANEL_STYLE;
    panel.id = 'social-hub-panel';

    // Panel header
    var header = document.createElement('div');
    header.style.cssText = [
      'background:' + COLORS.bgHeader,
      'border-bottom:1px solid ' + COLORS.border,
      'padding:8px 12px',
      'display:flex',
      'align-items:center',
      'justify-content:space-between'
    ].join(';');

    var title = document.createElement('span');
    title.style.cssText = 'color:' + COLORS.accent + ';font-weight:bold;font-size:13px;';
    title.textContent = '[S] Social Hub';
    header.appendChild(title);
    panel.appendChild(header);

    // Tab bar
    var tabBar = document.createElement('div');
    tabBar.style.cssText = 'display:flex;border-bottom:1px solid ' + COLORS.border + ';';

    var tabs = ['Chat', 'Guild', 'Players', 'Leaderboards'];
    var activeTab = 'Chat';

    tabs.forEach(function(tab) {
      var btn = document.createElement('button');
      btn.textContent = tab;
      btn.style.cssText = tab === activeTab ? TAB_ACTIVE_STYLE : TAB_BASE_STYLE;
      btn.setAttribute('data-tab', tab);
      tabBar.appendChild(btn);
    });

    panel.appendChild(tabBar);

    // Tab content area
    var contentArea = document.createElement('div');
    contentArea.style.cssText = 'flex:1;overflow:hidden;';

    // Build initial tab content (Chat)
    var chatContent = _buildChatTab(chatState);
    if (chatContent) { contentArea.appendChild(chatContent); }

    panel.appendChild(contentArea);

    // Wire tab switching
    var tabButtons = tabBar.querySelectorAll('[data-tab]');
    tabButtons.forEach(function(btn) {
      btn.addEventListener('click', function() {
        var tabName = btn.getAttribute('data-tab');

        // Update tab styles
        tabButtons.forEach(function(b) {
          b.style.cssText = b === btn ? TAB_ACTIVE_STYLE : TAB_BASE_STYLE;
        });

        // Replace content
        contentArea.innerHTML = '';
        var newContent = null;
        if (tabName === 'Chat') {
          newContent = _buildChatTab(chatState);
        } else if (tabName === 'Guild') {
          newContent = _buildGuildTab(guildState, playerId);
        } else if (tabName === 'Players') {
          newContent = _buildPlayersTab(profiles, playerId);
        } else if (tabName === 'Leaderboards') {
          newContent = _buildLeaderboardsTab(lbState, playerId);
        }
        if (newContent) { contentArea.appendChild(newContent); }
      });
    });

    return panel;
  }

  // â”€â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.createSocialPanel = createSocialPanel;

  // Chat
  exports.createChatState = createChatState;
  exports.addMessage = addMessage;
  exports.getMessages = getMessages;
  exports.switchChannel = switchChannel;
  exports.getUnreadCount = getUnreadCount;
  exports.sendWhisper = sendWhisper;
  exports.formatMessage = formatMessage;

  // Guild
  exports.createGuildState = createGuildState;
  exports.createGuild = createGuild;
  exports.joinGuild = joinGuild;
  exports.leaveGuild = leaveGuild;
  exports.inviteToGuild = inviteToGuild;
  exports.getGuildInfo = getGuildInfo;
  exports.getGuildMembers = getGuildMembers;
  exports.formatGuildCard = formatGuildCard;

  // Players
  exports.createPlayerProfile = createPlayerProfile;
  exports.getPlayerLevel = getPlayerLevel;
  exports.getPlayerTitle = getPlayerTitle;
  exports.formatProfileCard = formatProfileCard;
  exports.searchPlayers = searchPlayers;

  // Leaderboards
  exports.createLeaderboardState = createLeaderboardState;
  exports.updateLeaderboard = updateLeaderboard;
  exports.getLeaderboard = getLeaderboard;
  exports.getPlayerRank = getPlayerRank;
  exports.formatLeaderboardTable = formatLeaderboardTable;

  // Constants (for testing)
  exports.MAX_MESSAGES_PER_CHANNEL = MAX_MESSAGES_PER_CHANNEL;
  exports.MAX_GUILD_MEMBERS = MAX_GUILD_MEMBERS;
  exports.MAX_GUILD_NAME_LENGTH = MAX_GUILD_NAME_LENGTH;
  exports.MAX_GUILD_MOTTO_LENGTH = MAX_GUILD_MOTTO_LENGTH;
  exports.MAX_PLAYER_LEVEL = MAX_PLAYER_LEVEL;
  exports.MAX_LEADERBOARD_ENTRIES = MAX_LEADERBOARD_ENTRIES;
  exports.LEADERBOARD_CATEGORIES = LEADERBOARD_CATEGORIES;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardSocial = {}));


// dashboard_games.js
// dashboard_games.js
/**
 * ZION Dashboard Games Module
 * Mini-games panel for UI-only (dashboard) mode.
 * Provides text-based Fishing, Card Game, Dungeon, and Stargazing.
 * No project dependencies â€” pure logic + DOM helpers.
 */
(function(exports) {
  'use strict';

  // ===========================================================================
  // SEEDED RNG (mulberry32)
  // ===========================================================================

  function createRng(seed) {
    var s = (seed >>> 0) || 1;
    return function() {
      s += 0x6D2B79F5;
      var t = Math.imul(s ^ (s >>> 15), 1 | s);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) >>> 0;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function rngInt(rng, min, max) {
    return min + Math.floor(rng() * (max - min + 1));
  }

  function rngPick(rng, arr) {
    return arr[Math.floor(rng() * arr.length)];
  }

  function rngShuffle(rng, arr) {
    var a = arr.slice();
    for (var i = a.length - 1; i > 0; i--) {
      var j = Math.floor(rng() * (i + 1));
      var tmp = a[i]; a[i] = a[j]; a[j] = tmp;
    }
    return a;
  }

  function hashString(str) {
    var h = 2166136261;
    for (var i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  // ===========================================================================
  // FISHING SYSTEM
  // ===========================================================================

  // Fish data by zone
  var FISH_BY_ZONE = {
    nexus: [
      { name: 'Golden Carp',    rarity: 'common',   value: 5,  weight: { min: 1,   max: 3   }, desc: 'Glimmers in the central fountain' },
      { name: 'Rune Fish',      rarity: 'rare',     value: 25, weight: { min: 2,   max: 5   }, desc: 'Covered in ancient symbols' },
      { name: 'Crystal Minnow', rarity: 'uncommon', value: 12, weight: { min: 0.5, max: 1.5 }, desc: 'Translucent and delicate' }
    ],
    gardens: [
      { name: 'Lily Trout',  rarity: 'common',   value: 4,  weight: { min: 1, max: 4 }, desc: 'Feeds among the lily pads' },
      { name: 'Honey Bass',  rarity: 'uncommon', value: 15, weight: { min: 2, max: 6 }, desc: 'Sweet-scented scales' },
      { name: 'Bloom Fish',  rarity: 'rare',     value: 30, weight: { min: 1, max: 3 }, desc: 'Petals grow on its fins' },
      { name: 'Garden Eel',  rarity: 'common',   value: 6,  weight: { min: 3, max: 8 }, desc: 'Burrows in garden soil' }
    ],
    wilds: [
      { name: 'Shadow Catfish', rarity: 'uncommon', value: 10, weight: { min: 5,  max: 15 }, desc: 'Lurks in murky depths' },
      { name: 'River King',     rarity: 'rare',     value: 40, weight: { min: 10, max: 25 }, desc: 'Largest fish in ZION' },
      { name: 'Cave Blindfish', rarity: 'rare',     value: 35, weight: { min: 1,  max: 3  }, desc: 'Has no eyes, senses vibrations' },
      { name: 'Wild Salmon',    rarity: 'common',   value: 8,  weight: { min: 3,  max: 7  }, desc: 'Swims upstream in autumn' }
    ],
    athenaeum: [
      { name: 'Scholar Fish', rarity: 'uncommon', value: 14, weight: { min: 1,   max: 4 }, desc: 'Seems unusually intelligent' },
      { name: 'Ink Squid',    rarity: 'rare',     value: 28, weight: { min: 2,   max: 5 }, desc: 'Leaves trails of text in water' },
      { name: 'Page Turner',  rarity: 'common',   value: 5,  weight: { min: 0.5, max: 2 }, desc: 'Thin and flat like a page' }
    ],
    studio: [
      { name: 'Paint Splash', rarity: 'uncommon', value: 11, weight: { min: 1, max: 3 }, desc: 'Changes color constantly' },
      { name: 'Clay Crab',    rarity: 'common',   value: 4,  weight: { min: 2, max: 4 }, desc: 'Sculpts tiny castles' },
      { name: 'Melody Eel',   rarity: 'rare',     value: 32, weight: { min: 3, max: 6 }, desc: 'Hums when caught' }
    ],
    agora: [
      { name: 'Merchant Minnow', rarity: 'common',   value: 3,  weight: { min: 0.5, max: 1 }, desc: 'Always travels in schools' },
      { name: 'Gold Scale',      rarity: 'rare',     value: 50, weight: { min: 1,   max: 3 }, desc: 'Scales are actual gold' },
      { name: 'Debate Fish',     rarity: 'uncommon', value: 9,  weight: { min: 2,   max: 4 }, desc: 'Makes argumentative sounds' }
    ],
    commons: [
      { name: 'Festival Fish',  rarity: 'uncommon', value: 13, weight: { min: 2, max: 5  }, desc: 'Appears during celebrations' },
      { name: 'Campfire Cod',   rarity: 'common',   value: 6,  weight: { min: 3, max: 7  }, desc: 'Best served smoked' },
      { name: 'Story Sturgeon', rarity: 'rare',     value: 38, weight: { min: 8, max: 20 }, desc: 'Ancient and wise' }
    ],
    arena: [
      { name: 'Battle Bass',  rarity: 'uncommon', value: 16, weight: { min: 4, max: 10 }, desc: 'Fights back hard' },
      { name: 'Trophy Fish',  rarity: 'rare',     value: 45, weight: { min: 5, max: 15 }, desc: 'Legendary catch' },
      { name: 'Sand Shark',   rarity: 'uncommon', value: 20, weight: { min: 6, max: 12 }, desc: 'Burrows in arena sand' }
    ]
  };

  // Rod tiers with bonuses
  var ROD_TIERS = {
    basic:    { tier: 0, biteBonus: 0,    reelBonus: 0,    label: 'Basic Rod' },
    wooden:   { tier: 1, biteBonus: 0.05, reelBonus: 0.05, label: 'Wooden Rod' },
    bamboo:   { tier: 2, biteBonus: 0.10, reelBonus: 0.10, label: 'Bamboo Rod' },
    carbon:   { tier: 3, biteBonus: 0.15, reelBonus: 0.15, label: 'Carbon Rod' },
    legendary:{ tier: 4, biteBonus: 0.20, reelBonus: 0.25, label: 'Legendary Rod' }
  };

  /**
   * Create initial fishing state.
   * @returns {object} fishing state
   */
  function createFishingGame() {
    return {
      rod: 'basic',
      bait: null,
      location: 'nexus',
      casting: false,
      fish: null,
      catches: [],
      stats: { total: 0, best: null, streak: 0 }
    };
  }

  /**
   * Cast fishing line at a location.
   * @param {object} state - fishing state
   * @param {string} location - zone name
   * @returns {{ state: object, message: string }}
   */
  function castLine(state, location) {
    var newState = _cloneState(state);
    var loc = (location && FISH_BY_ZONE[location]) ? location : (newState.location || 'nexus');
    newState.location = loc;
    newState.casting = true;
    newState.fish = null;
    var locLabels = {
      nexus: 'Nexus pond',
      gardens: 'Gardens stream',
      wilds: 'Wilds river',
      athenaeum: 'Athenaeum pool',
      studio: 'Studio canal',
      agora: 'Agora channel',
      commons: 'Commons lake',
      arena: 'Arena waterway'
    };
    var label = locLabels[loc] || (loc + ' waters');
    return {
      state: newState,
      message: 'You cast your line into the ' + label + '...'
    };
  }

  /**
   * Check if a fish has bitten.
   * @param {object} state - fishing state
   * @returns {{ state: object, bite: boolean, fish: object|null }}
   */
  function checkBite(state) {
    var newState = _cloneState(state);
    if (!newState.casting) {
      return { state: newState, bite: false, fish: null };
    }
    var rodInfo = ROD_TIERS[newState.rod] || ROD_TIERS.basic;
    var biteChance = 0.30 + (rodInfo.tier * 0.10) + (newState.bait ? 0.15 : 0);
    var rng = createRng(hashString(newState.location + Date.now()));
    var roll = rng();
    if (roll > biteChance) {
      return { state: newState, bite: false, fish: null };
    }
    // Pick a fish weighted by rarity
    var pool = getFishForLocation(newState.location);
    var fish = _pickWeightedFish(rng, pool);
    if (!fish) {
      return { state: newState, bite: false, fish: null };
    }
    // Assign random weight in range
    var weight = _randomInRange(rng, fish.weight.min, fish.weight.max);
    var caughtFish = _assignFishWeight(fish, weight);
    newState.fish = caughtFish;
    return { state: newState, bite: true, fish: caughtFish };
  }

  /**
   * Attempt to reel in a bitten fish.
   * @param {object} state - fishing state
   * @returns {{ state: object, success: boolean, fish: object|null, message: string }}
   */
  function reelIn(state) {
    var newState = _cloneState(state);
    if (!newState.casting || !newState.fish) {
      newState.casting = false;
      return { state: newState, success: false, fish: null, message: 'Nothing on the line.' };
    }
    var rodInfo = ROD_TIERS[newState.rod] || ROD_TIERS.basic;
    var successChance = 0.60 + (rodInfo.tier * 0.05);
    var rng = createRng(hashString(newState.fish.name + Date.now()));
    var caught = rng() <= successChance;
    var fish = newState.fish;
    newState.fish = null;
    newState.casting = false;
    if (caught) {
      newState.catches.push(fish);
      newState.stats.total += 1;
      newState.stats.streak += 1;
      if (!newState.stats.best || fish.value > newState.stats.best.value) {
        newState.stats.best = fish;
      }
      return {
        state: newState,
        success: true,
        fish: fish,
        message: 'You caught a ' + fish.name + '! (' + fish.weight.toFixed(1) + ' lbs, ' + fish.rarity + ')'
      };
    } else {
      newState.stats.streak = 0;
      return {
        state: newState,
        success: false,
        fish: null,
        message: 'The ' + fish.name + ' got away!'
      };
    }
  }

  /**
   * Get fish available at a location.
   * @param {string} location
   * @returns {Array} array of fish data objects
   */
  function getFishForLocation(location) {
    return (FISH_BY_ZONE[location] || FISH_BY_ZONE.nexus).slice();
  }

  /**
   * Sell a caught fish for Spark.
   * @param {object} state - fishing state
   * @param {number} fishIndex - index in catches array
   * @param {object} [economy] - optional economy object (unused in dashboard mode)
   * @param {string} [playerId] - optional player id
   * @returns {{ success: boolean, state: object, earnings: number, message: string }}
   */
  function sellFish(state, fishIndex, economy, playerId) {
    var newState = _cloneState(state);
    if (fishIndex < 0 || fishIndex >= newState.catches.length) {
      return { success: false, state: newState, earnings: 0, message: 'No fish at that index.' };
    }
    var fish = newState.catches[fishIndex];
    newState.catches.splice(fishIndex, 1);
    return {
      success: true,
      state: newState,
      earnings: fish.value,
      message: 'Sold ' + fish.name + ' for ' + fish.value + ' Spark.'
    };
  }

  /**
   * Get fishing stats summary.
   * @param {object} state - fishing state
   * @returns {object} stats summary
   */
  function getFishingStats(state) {
    var byRarity = { common: 0, uncommon: 0, rare: 0, legendary: 0 };
    for (var i = 0; i < state.catches.length; i++) {
      var r = state.catches[i].rarity || 'common';
      if (byRarity[r] !== undefined) byRarity[r]++;
      else byRarity[r] = 1;
    }
    return {
      total: state.stats.total,
      best: state.stats.best,
      streak: state.stats.streak,
      inCreel: state.catches.length,
      byRarity: byRarity
    };
  }

  // --- Fishing helpers ---

  function _pickWeightedFish(rng, pool) {
    if (!pool || !pool.length) return null;
    var weights = { common: 100, uncommon: 40, rare: 15, legendary: 5 };
    var totalWeight = 0;
    for (var i = 0; i < pool.length; i++) {
      totalWeight += (weights[pool[i].rarity] || 50);
    }
    var roll = rng() * totalWeight;
    var cumulative = 0;
    for (var j = 0; j < pool.length; j++) {
      cumulative += (weights[pool[j].rarity] || 50);
      if (roll <= cumulative) return pool[j];
    }
    return pool[pool.length - 1];
  }

  function _randomInRange(rng, min, max) {
    return min + rng() * (max - min);
  }

  function _assignFishWeight(fish, weight) {
    return {
      name: fish.name,
      rarity: fish.rarity,
      value: fish.value,
      weight: weight,
      desc: fish.desc
    };
  }

  function _cloneState(state) {
    return JSON.parse(JSON.stringify(state));
  }

  // ===========================================================================
  // CARD GAME (Text-Based Battles)
  // ===========================================================================

  var CARD_HAND_MAX = 7;
  var CARD_FIELD_MAX = 5;
  var CARD_STARTING_HP = 20;

  // Full card catalog used for starter decks
  var CARD_CATALOG_SIMPLE = {
    // Creatures
    'flame_sprite':    { id: 'flame_sprite',    name: 'Flame Sprite',    type: 'creature', cost: 1, attack: 2, defense: 1, hp: 1, rarity: 'common',   ability: null },
    'stone_guard':     { id: 'stone_guard',     name: 'Stone Guard',     type: 'creature', cost: 2, attack: 1, defense: 4, hp: 3, rarity: 'common',   ability: null },
    'wind_dancer':     { id: 'wind_dancer',     name: 'Wind Dancer',     type: 'creature', cost: 2, attack: 3, defense: 1, hp: 2, rarity: 'common',   ability: 'swift' },
    'tide_caller':     { id: 'tide_caller',     name: 'Tide Caller',     type: 'creature', cost: 3, attack: 2, defense: 3, hp: 4, rarity: 'uncommon', ability: null },
    'fire_wolf':       { id: 'fire_wolf',       name: 'Fire Wolf',       type: 'creature', cost: 2, attack: 3, defense: 1, hp: 2, rarity: 'common',   ability: null },
    'crystal_golem':   { id: 'crystal_golem',   name: 'Crystal Golem',   type: 'creature', cost: 4, attack: 3, defense: 5, hp: 5, rarity: 'uncommon', ability: null },
    'shadow_runner':   { id: 'shadow_runner',   name: 'Shadow Runner',   type: 'creature', cost: 1, attack: 2, defense: 0, hp: 1, rarity: 'common',   ability: 'swift' },
    'spirit_guide':    { id: 'spirit_guide',    name: 'Spirit Guide',    type: 'creature', cost: 3, attack: 1, defense: 2, hp: 3, rarity: 'uncommon', ability: 'heal_ally' },
    'nexus_warden':    { id: 'nexus_warden',    name: 'Nexus Warden',    type: 'creature', cost: 5, attack: 4, defense: 4, hp: 6, rarity: 'rare',     ability: 'taunt' },
    'ember_sprite':    { id: 'ember_sprite',    name: 'Ember Sprite',    type: 'creature', cost: 1, attack: 1, defense: 1, hp: 1, rarity: 'common',   ability: null },
    // Spells
    'fireball':        { id: 'fireball',        name: 'Fireball',        type: 'spell',    cost: 2, attack: 3, defense: 0, hp: 0, rarity: 'common',   ability: 'deal_3' },
    'healing_light':   { id: 'healing_light',   name: 'Healing Light',   type: 'spell',    cost: 2, attack: 0, defense: 0, hp: 0, rarity: 'common',   ability: 'heal_4' },
    'lightning_bolt':  { id: 'lightning_bolt',  name: 'Lightning Bolt',  type: 'spell',    cost: 3, attack: 4, defense: 0, hp: 0, rarity: 'uncommon', ability: 'deal_4' },
    'frost_nova':      { id: 'frost_nova',      name: 'Frost Nova',      type: 'spell',    cost: 2, attack: 0, defense: 0, hp: 0, rarity: 'common',   ability: 'freeze_all' },
    'power_surge':     { id: 'power_surge',     name: 'Power Surge',     type: 'spell',    cost: 1, attack: 2, defense: 0, hp: 0, rarity: 'common',   ability: 'deal_2' }
  };

  // Starter decks (20 cards each)
  var STARTER_DECK_PLAYER = [
    'flame_sprite', 'flame_sprite', 'stone_guard', 'stone_guard',
    'wind_dancer', 'wind_dancer', 'fire_wolf', 'fire_wolf',
    'tide_caller', 'tide_caller', 'spirit_guide', 'spirit_guide',
    'crystal_golem', 'nexus_warden',
    'fireball', 'fireball', 'healing_light', 'healing_light',
    'lightning_bolt', 'frost_nova'
  ];

  var STARTER_DECK_OPPONENT = [
    'shadow_runner', 'shadow_runner', 'shadow_runner',
    'ember_sprite', 'ember_sprite', 'ember_sprite',
    'fire_wolf', 'fire_wolf', 'fire_wolf',
    'wind_dancer', 'wind_dancer',
    'stone_guard', 'stone_guard',
    'tide_caller', 'crystal_golem',
    'fireball', 'fireball', 'lightning_bolt',
    'power_surge', 'power_surge'
  ];

  function _makeCardInstance(cardId, instanceId) {
    var def = CARD_CATALOG_SIMPLE[cardId];
    if (!def) return null;
    return {
      instanceId: instanceId || cardId + '_' + Math.floor(Math.random() * 99999),
      id: def.id,
      name: def.name,
      type: def.type,
      cost: def.cost,
      attack: def.attack,
      defense: def.defense,
      hp: def.hp,
      currentHp: def.hp,
      rarity: def.rarity,
      ability: def.ability,
      exhausted: false
    };
  }

  function _buildDeckFromIds(cardIds) {
    var deck = [];
    for (var i = 0; i < cardIds.length; i++) {
      var card = _makeCardInstance(cardIds[i], cardIds[i] + '_' + i);
      if (card) deck.push(card);
    }
    return deck;
  }

  function _shuffleDeck(deck) {
    var a = deck.slice();
    for (var i = a.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var tmp = a[i]; a[i] = a[j]; a[j] = tmp;
    }
    return a;
  }

  function _makeSide(deckIds) {
    var deck = _shuffleDeck(_buildDeckFromIds(deckIds));
    var hand = deck.splice(0, 4); // Draw opening hand
    return {
      hp: CARD_STARTING_HP,
      maxHp: CARD_STARTING_HP,
      mana: 1,
      maxMana: 1,
      hand: hand,
      deck: deck,
      graveyard: [],
      field: []
    };
  }

  /**
   * Create a new card battle state.
   * @param {Array} [playerDeck] - optional array of card IDs
   * @param {Array} [opponentDeck] - optional array of card IDs
   * @returns {object} battle state
   */
  function createCardBattleState(playerDeck, opponentDeck) {
    var pDeck = (playerDeck && playerDeck.length >= 10) ? playerDeck : STARTER_DECK_PLAYER;
    var oDeck = (opponentDeck && opponentDeck.length >= 10) ? opponentDeck : STARTER_DECK_OPPONENT;
    return {
      player: _makeSide(pDeck),
      opponent: _makeSide(oDeck),
      turn: 1,
      activePlayer: 'player',
      phase: 'draw',
      log: []
    };
  }

  /**
   * Draw a card from deck to hand.
   * @param {object} state - battle state
   * @param {string} who - 'player' or 'opponent'
   * @returns {{ state: object, card: object|null, discarded: boolean }}
   */
  function drawCard(state, who) {
    var newState = _cloneBattleState(state);
    var side = newState[who];
    if (!side || !side.deck.length) {
      return { state: newState, card: null, discarded: false };
    }
    var card = side.deck.shift();
    var discarded = false;
    if (side.hand.length >= CARD_HAND_MAX) {
      side.graveyard.push(card);
      discarded = true;
      newState.log.push(who + ' discarded ' + card.name + ' (hand full)');
    } else {
      side.hand.push(card);
      newState.log.push(who + ' drew ' + card.name);
    }
    return { state: newState, card: card, discarded: discarded };
  }

  /**
   * Play a card from hand.
   * @param {object} state - battle state
   * @param {string} who - 'player' or 'opponent'
   * @param {number} handIndex - index in hand array
   * @param {string|number} [target] - target identifier for spells
   * @returns {{ state: object, success: boolean, message: string }}
   */
  function playCard(state, who, handIndex, target) {
    var newState = _cloneBattleState(state);
    var side = newState[who];
    var other = who === 'player' ? newState.opponent : newState.player;
    if (!side) return { state: newState, success: false, message: 'Invalid player.' };
    if (handIndex < 0 || handIndex >= side.hand.length) {
      return { state: newState, success: false, message: 'No card at that position.' };
    }
    var card = side.hand[handIndex];
    if (card.cost > side.mana) {
      return { state: newState, success: false, message: 'Not enough mana. Need ' + card.cost + ', have ' + side.mana + '.' };
    }
    side.mana -= card.cost;
    side.hand.splice(handIndex, 1);

    var msg = '';
    if (card.type === 'creature') {
      if (side.field.length >= CARD_FIELD_MAX) {
        side.graveyard.push(card);
        msg = 'Field full â€” ' + card.name + ' discarded.';
      } else {
        card.exhausted = true; // Summoning sickness
        side.field.push(card);
        msg = who + ' played creature: ' + card.name + ' (' + card.attack + '/' + card.currentHp + ')';
        // Apply enter effects
        if (card.ability === 'ignite' || card.ability === 'deal_1') {
          other.hp -= 1;
          msg += '. Ignite: dealt 1 damage to opponent.';
        }
      }
    } else if (card.type === 'spell') {
      side.graveyard.push(card);
      msg = who + ' cast spell: ' + card.name + '.';
      // Apply spell effects
      if (card.ability === 'deal_2') { other.hp -= 2; msg += ' Dealt 2 damage.'; }
      else if (card.ability === 'deal_3') { other.hp -= 3; msg += ' Dealt 3 damage.'; }
      else if (card.ability === 'deal_4') { other.hp -= 4; msg += ' Dealt 4 damage.'; }
      else if (card.ability === 'heal_4') { side.hp = Math.min(side.maxHp, side.hp + 4); msg += ' Healed 4 HP.'; }
      else if (card.ability === 'freeze_all') {
        for (var fi = 0; fi < other.field.length; fi++) { other.field[fi].exhausted = true; }
        msg += ' Froze all opponent creatures.';
      }
    } else {
      side.graveyard.push(card);
      msg = who + ' played ' + card.type + ': ' + card.name + '.';
    }

    newState.log.push(msg);
    // Clamp HP
    other.hp = Math.max(0, other.hp);
    return { state: newState, success: true, message: msg };
  }

  /**
   * Attack with a creature.
   * @param {object} state - battle state
   * @param {number} attackerIndex - index in active player's field
   * @param {number|string} targetIndex - index in opponent's field, or 'player'/'opponent' for direct
   * @returns {{ state: object, result: string, damage: number, message: string }}
   */
  function attackWithCreature(state, attackerIndex, targetIndex) {
    var newState = _cloneBattleState(state);
    var activeSide = newState[newState.activePlayer];
    var otherKey = newState.activePlayer === 'player' ? 'opponent' : 'player';
    var otherSide = newState[otherKey];

    if (!activeSide || attackerIndex < 0 || attackerIndex >= activeSide.field.length) {
      return { state: newState, result: 'invalid', damage: 0, message: 'Invalid attacker.' };
    }
    var attacker = activeSide.field[attackerIndex];
    if (attacker.exhausted) {
      return { state: newState, result: 'invalid', damage: 0, message: attacker.name + ' is exhausted.' };
    }

    attacker.exhausted = true;
    var msg = '';
    var result = 'survive';
    var damage = attacker.attack;

    // Direct attack on opponent
    if (targetIndex === 'face' || targetIndex === otherKey || typeof targetIndex !== 'number' || targetIndex < 0 || targetIndex >= otherSide.field.length) {
      otherSide.hp = Math.max(0, otherSide.hp - damage);
      msg = attacker.name + ' attacks ' + otherKey + ' for ' + damage + ' damage!';
      result = otherSide.hp <= 0 ? 'kill' : 'survive';
    } else {
      // Attack a creature
      var defender = otherSide.field[targetIndex];
      defender.currentHp -= damage;
      // Counter-attack
      var counterDamage = Math.max(0, defender.attack - attacker.defense);
      attacker.currentHp -= counterDamage;

      if (defender.currentHp <= 0) {
        otherSide.graveyard.push(otherSide.field.splice(targetIndex, 1)[0]);
        result = 'kill';
        msg = attacker.name + ' killed ' + defender.name + '!';
      } else {
        result = 'survive';
        msg = attacker.name + ' hit ' + defender.name + ' for ' + damage + ' damage. It survives with ' + defender.currentHp + ' HP.';
      }
      if (attacker.currentHp <= 0) {
        activeSide.graveyard.push(activeSide.field.splice(attackerIndex, 1)[0]);
        result = 'blocked';
        msg += ' ' + attacker.name + ' was destroyed in return.';
      }
    }

    // Clamp HP
    otherSide.hp = Math.max(0, otherSide.hp);
    activeSide.hp = Math.max(0, activeSide.hp);
    newState.log.push(msg);
    return { state: newState, result: result, damage: damage, message: msg };
  }

  /**
   * End current player's turn.
   * @param {object} state - battle state
   * @returns {object} new state
   */
  function endTurn(state) {
    var newState = _cloneBattleState(state);
    newState.turn += 1;
    // Switch active player
    newState.activePlayer = newState.activePlayer === 'player' ? 'opponent' : 'player';
    var nextSide = newState[newState.activePlayer];
    // Increase max mana (cap 10), refill mana
    nextSide.maxMana = Math.min(10, nextSide.maxMana + 1);
    nextSide.mana = nextSide.maxMana;
    // Unexhaust creatures
    for (var i = 0; i < nextSide.field.length; i++) {
      nextSide.field[i].exhausted = false;
    }
    newState.phase = 'draw';
    newState.log.push('Turn ' + newState.turn + ': ' + newState.activePlayer + "'s turn.");
    return newState;
  }

  /**
   * Check if there is a winner.
   * @param {object} state - battle state
   * @returns {null|'player'|'opponent'}
   */
  function checkWinner(state) {
    if (state.opponent.hp <= 0) return 'player';
    if (state.player.hp <= 0) return 'opponent';
    return null;
  }

  /**
   * Run the AI's turn.
   * @param {object} state - battle state
   * @returns {{ state: object, actions: Array }}
   */
  function aiTurn(state) {
    var newState = _cloneBattleState(state);
    var actions = [];

    // Ensure it's the opponent's turn
    if (newState.activePlayer !== 'opponent') {
      return { state: newState, actions: actions };
    }

    var ai = newState.opponent;

    // 1. Play highest cost affordable card(s)
    var maxPlays = 5;
    for (var pass = 0; pass < maxPlays; pass++) {
      var bestIdx = -1;
      var bestCost = -1;
      for (var i = 0; i < ai.hand.length; i++) {
        if (ai.hand[i].cost <= ai.mana && ai.hand[i].cost > bestCost) {
          bestCost = ai.hand[i].cost;
          bestIdx = i;
        }
      }
      if (bestIdx === -1) break;
      var playResult = playCard(newState, 'opponent', bestIdx, 'face');
      newState = playResult.state;
      actions.push({ type: 'play', detail: playResult.message });
      ai = newState.opponent; // Refresh reference
    }

    // 2. Attack with all non-exhausted creatures
    for (var a = 0; a < 10; a++) {
      var opField = newState.opponent.field;
      var attackerIdx = -1;
      for (var k = 0; k < opField.length; k++) {
        if (!opField[k].exhausted) { attackerIdx = k; break; }
      }
      if (attackerIdx === -1) break;

      var playerField = newState.player.field;
      var targetIdx;
      if (playerField.length > 0) {
        // Attack weakest player creature
        var weakest = 0;
        for (var w = 1; w < playerField.length; w++) {
          if (playerField[w].currentHp < playerField[weakest].currentHp) weakest = w;
        }
        targetIdx = weakest;
      } else {
        targetIdx = 'face';
      }

      var atkResult = attackWithCreature(newState, attackerIdx, targetIdx);
      newState = atkResult.state;
      actions.push({ type: 'attack', detail: atkResult.message });
    }

    return { state: newState, actions: actions };
  }

  /**
   * Format battle field as ASCII art.
   * @param {object} state - battle state
   * @returns {string} ASCII display
   */
  function formatBattleField(state) {
    var lines = [];
    var opp = state.opponent;
    var pl = state.player;

    lines.push('Opponent: HP ' + opp.hp + '/' + opp.maxHp + ' | Mana ' + opp.mana + '/' + opp.maxMana + ' | Hand: ' + opp.hand.length + ' cards');

    var oppRow = '';
    for (var oi = 0; oi < opp.field.length; oi++) {
      var oc = opp.field[oi];
      oppRow += '[' + oc.name.substring(0, 8) + ' (' + oc.attack + '/' + oc.currentHp + ')' + (oc.exhausted ? '*' : '') + '] ';
    }
    lines.push(oppRow || '  (no creatures)');
    lines.push('--- field divider ---');

    var plRow = '';
    for (var pi = 0; pi < pl.field.length; pi++) {
      var pc = pl.field[pi];
      plRow += '[' + pc.name.substring(0, 8) + ' (' + pc.attack + '/' + pc.currentHp + ')' + (pc.exhausted ? '*' : '') + '] ';
    }
    lines.push(plRow || '  (no creatures)');
    lines.push('Player: HP ' + pl.hp + '/' + pl.maxHp + ' | Mana ' + pl.mana + '/' + pl.maxMana + ' | Hand: ' + pl.hand.length + ' cards');

    return lines.join('\n');
  }

  function _cloneBattleState(state) {
    return JSON.parse(JSON.stringify(state));
  }

  // ===========================================================================
  // DUNGEON (Text-Based Roguelike)
  // ===========================================================================

  var DUNGEON_DIFFICULTIES = {
    easy:   { rooms: 5,  enemyScale: 0.8, lootScale: 0.8  },
    medium: { rooms: 8,  enemyScale: 1.0, lootScale: 1.0  },
    hard:   { rooms: 12, enemyScale: 1.4, lootScale: 1.3  }
  };

  var ROOM_TYPE_POOL = ['empty', 'enemy', 'treasure', 'puzzle', 'trap', 'rest', 'shop', 'boss'];

  var DUNGEON_ENEMIES = [
    { name: 'Shadow Wisp',    hp: 15, attack: 4,  defense: 1, xp: 10, loot: 5  },
    { name: 'Stone Crawler',  hp: 20, attack: 3,  defense: 3, xp: 12, loot: 8  },
    { name: 'Flame Imp',      hp: 12, attack: 6,  defense: 0, xp: 15, loot: 10 },
    { name: 'Void Stalker',   hp: 25, attack: 5,  defense: 2, xp: 18, loot: 12 },
    { name: 'Crystal Golem',  hp: 40, attack: 6,  defense: 6, xp: 30, loot: 20 },
    { name: 'Nexus Guardian', hp: 60, attack: 10, defense: 8, xp: 50, loot: 40 }
  ];

  var DUNGEON_ITEMS = [
    { name: 'Health Potion',  type: 'consumable', effect: 'heal_25',   value: 10 },
    { name: 'Attack Shard',   type: 'equipment',  effect: 'attack_+3', value: 15 },
    { name: 'Shield Rune',    type: 'equipment',  effect: 'defense_+2',value: 12 },
    { name: 'Spark Coin',     type: 'currency',   effect: 'gold_10',   value: 10 },
    { name: 'Magic Scroll',   type: 'consumable', effect: 'deal_20',   value: 20 },
    { name: 'Lucky Charm',    type: 'passive',    effect: 'luck_+10',  value: 25 }
  ];

  var DUNGEON_PUZZLES = [
    {
      question: 'Three torches lit. Middle must stay unlit. Which sequence opens the door?',
      options: ['Left, Right, Left', 'Right, Left, Right', 'Left, Left, Right', 'None â€” extinguish all'],
      correct: 1,
      reward: { name: 'Puzzle Gem', value: 20 }
    },
    {
      question: 'The symbol appears: circle, triangle, circle, triangle, circle, ?',
      options: ['Circle', 'Triangle', 'Square', 'Diamond'],
      correct: 1,
      reward: { name: 'Pattern Crystal', value: 15 }
    },
    {
      question: 'I speak without a mouth. I hear without ears. I have no body, but I come alive with wind. What am I?',
      options: ['A shadow', 'An echo', 'A ghost', 'A dream'],
      correct: 1,
      reward: { name: 'Echo Stone', value: 18 }
    },
    {
      question: 'Four pressure plates. Step only on the ones that sum to 10: Plates are 3, 7, 4, 6.',
      options: ['3 and 7', '4 and 6', '3 and 7 and nothing else', '7 only'],
      correct: 0,
      reward: { name: 'Weight Rune', value: 12 }
    }
  ];

  /**
   * Create a new dungeon run.
   * @param {number|string} seed - seed for generation
   * @param {string} difficulty - 'easy', 'medium', or 'hard'
   * @returns {object} dungeon state
   */
  function createDungeonRun(seed, difficulty) {
    var diff = DUNGEON_DIFFICULTIES[difficulty] || DUNGEON_DIFFICULTIES.medium;
    var rng = createRng(typeof seed === 'string' ? hashString(seed) : (seed >>> 0));
    var numRooms = diff.rooms;
    var rooms = [];
    for (var i = 0; i < numRooms; i++) {
      rooms.push(generateRoom(rng, i, difficulty, numRooms));
    }
    // First room is always entrance, last is boss
    rooms[0].type = 'entrance';
    rooms[0].description = 'You stand at the dungeon entrance. Torches flicker on damp stone walls.';
    rooms[0].contents = null;
    rooms[numRooms - 1].type = 'boss';
    rooms[numRooms - 1].description = 'A massive chamber. Something powerful stirs in the darkness.';
    rooms[numRooms - 1].contents = {
      enemy: _scaleEnemy(DUNGEON_ENEMIES[DUNGEON_ENEMIES.length - 1], diff.enemyScale)
    };

    return {
      rooms: rooms,
      currentRoom: 0,
      player: { hp: 100, maxHp: 100, attack: 10, defense: 5, items: [], xp: 0, gold: 0 },
      floor: 1,
      cleared: false,
      log: ['You enter the dungeon. Stay alert.'],
      seed: seed,
      difficulty: difficulty
    };
  }

  /**
   * Generate a single room.
   * @param {function|number} seedOrRng - rng function or seed
   * @param {number} index - room index
   * @param {string} difficulty
   * @param {number} [total] - total rooms
   * @returns {object} room
   */
  function generateRoom(seedOrRng, index, difficulty, total) {
    var rng = typeof seedOrRng === 'function' ? seedOrRng : createRng(typeof seedOrRng === 'string' ? hashString(seedOrRng) : (seedOrRng >>> 0));
    var diff = DUNGEON_DIFFICULTIES[difficulty] || DUNGEON_DIFFICULTIES.medium;
    var numRooms = total || diff.rooms;

    // Pick room type based on position
    var typePool;
    if (index === 0) {
      typePool = ['entrance'];
    } else if (index === numRooms - 1) {
      typePool = ['boss'];
    } else if (index % 4 === 2) {
      typePool = ['rest', 'shop'];
    } else {
      typePool = ['enemy', 'enemy', 'enemy', 'treasure', 'puzzle', 'trap', 'empty'];
    }
    var type = rngPick(rng, typePool);

    var desc = _roomDescription(type, rng);
    var contents = _roomContents(type, rng, diff);
    var exits = _roomExits(index, numRooms, rng);

    return {
      type: type,
      description: desc,
      contents: contents,
      exits: exits,
      visited: false,
      cleared: false
    };
  }

  function _roomDescription(type, rng) {
    var descs = {
      entrance: ['The dungeon entrance. Cold air drifts inward.'],
      empty:    ['A dusty corridor. Nothing stirs.', 'An empty chamber. Old bones litter the floor.', 'A quiet alcove with faded murals.'],
      enemy:    ['Shadows move in the corners. You are not alone.', 'A growl echoes from the darkness.', 'Glowing eyes appear in the gloom.'],
      treasure: ['A stone chest sits in the center of the room.', 'Glittering objects catch the torchlight.', 'You find a locked coffer on a pedestal.'],
      puzzle:   ['Strange mechanisms cover the walls.', 'Inscriptions glow faintly on the floor.', 'Levers and symbols challenge your mind.'],
      trap:     ['The floor feels unsteady.', 'You hear a faint clicking as you enter.', 'Pressure plates dot the stone floor.'],
      rest:     ['A campfire burns low. Someone was here recently.', 'A peaceful alcove with a bedroll.'],
      shop:     ['A hooded merchant sits behind a makeshift counter.', 'A wandering trader eyes you with interest.'],
      boss:     ['The chamber shakes. A colossal shadow rises.']
    };
    var pool = descs[type] || descs.empty;
    return rngPick(rng, pool);
  }

  function _roomContents(type, rng, diff) {
    if (type === 'enemy') {
      var enemyPool = DUNGEON_ENEMIES.slice(0, DUNGEON_ENEMIES.length - 1);
      var enemy = _scaleEnemy(rngPick(rng, enemyPool), diff.enemyScale);
      return { enemy: enemy };
    }
    if (type === 'treasure') {
      return { chest: true, looted: false };
    }
    if (type === 'puzzle') {
      var puzzle = DUNGEON_PUZZLES[Math.floor(rng() * DUNGEON_PUZZLES.length)];
      return { puzzle: JSON.parse(JSON.stringify(puzzle)), solved: false };
    }
    if (type === 'trap') {
      return { damage: rngInt(rng, 5, 20), triggered: false };
    }
    if (type === 'rest') {
      return { rested: false };
    }
    if (type === 'shop') {
      var shopItems = [];
      for (var i = 0; i < 3; i++) {
        shopItems.push(JSON.parse(JSON.stringify(rngPick(rng, DUNGEON_ITEMS))));
      }
      return { items: shopItems };
    }
    return null;
  }

  function _roomExits(index, total, rng) {
    var exits = ['forward'];
    if (index > 0) exits.push('back');
    if (index < total - 1 && rng() > 0.5) exits.push('side');
    return exits;
  }

  function _scaleEnemy(enemy, scale) {
    return {
      name: enemy.name,
      hp: Math.ceil(enemy.hp * scale),
      currentHp: Math.ceil(enemy.hp * scale),
      attack: Math.ceil(enemy.attack * scale),
      defense: Math.ceil(enemy.defense * scale),
      xp: enemy.xp,
      loot: enemy.loot,
      alive: true
    };
  }

  /**
   * Enter a room by direction.
   * @param {object} state - dungeon state
   * @param {string} direction - 'forward', 'back', 'side'
   * @returns {{ state: object, event: object }}
   */
  function enterRoom(state, direction) {
    var newState = _cloneDungeonState(state);
    var currentRoom = newState.rooms[newState.currentRoom];
    var newRoomIndex = newState.currentRoom;

    if (direction === 'forward' && newState.currentRoom < newState.rooms.length - 1) {
      newRoomIndex = newState.currentRoom + 1;
    } else if (direction === 'back' && newState.currentRoom > 0) {
      newRoomIndex = newState.currentRoom - 1;
    } else if (direction === 'side') {
      // Side room: stays on same floor level, try adjacent
      newRoomIndex = Math.min(newState.currentRoom + 1, newState.rooms.length - 1);
    } else {
      return {
        state: newState,
        event: { type: 'invalid', description: 'You cannot go that way.', options: [] }
      };
    }

    newState.currentRoom = newRoomIndex;
    var room = newState.rooms[newRoomIndex];
    room.visited = true;

    var event = _triggerRoomEvent(newState, newRoomIndex);
    newState.log.push(room.description);
    return { state: newState, event: event };
  }

  function _triggerRoomEvent(state, roomIndex) {
    var room = state.rooms[roomIndex];
    if (room.type === 'entrance') {
      return { type: 'entrance', description: room.description, options: ['[Forward] Move deeper', '[Inspect] Look around'] };
    }
    if (room.type === 'empty') {
      room.cleared = true;
      return { type: 'empty', description: room.description, options: ['[Forward] Move on', '[Back] Return'] };
    }
    if (room.type === 'enemy' && room.contents && room.contents.enemy && room.contents.enemy.alive) {
      return {
        type: 'enemy',
        description: room.description + ' A ' + room.contents.enemy.name + ' blocks your path!',
        options: ['[Attack] Fight the enemy', '[Defend] Guard yourself', '[Flee] Run back']
      };
    }
    if (room.type === 'treasure' && room.contents && !room.contents.looted) {
      return {
        type: 'treasure',
        description: room.description,
        options: ['[Open] Open the chest', '[Inspect] Look for traps first', '[Leave] Move on']
      };
    }
    if (room.type === 'puzzle' && room.contents && !room.contents.solved) {
      var puzzle = room.contents.puzzle;
      var opts = puzzle.options.map(function(o, i) { return '[' + (i + 1) + '] ' + o; });
      return {
        type: 'puzzle',
        description: room.description + '\n' + puzzle.question,
        options: opts
      };
    }
    if (room.type === 'trap' && room.contents && !room.contents.triggered) {
      return {
        type: 'trap',
        description: room.description,
        options: ['[Proceed] Walk through carefully', '[Back] Return cautiously']
      };
    }
    if (room.type === 'rest' && room.contents && !room.contents.rested) {
      return {
        type: 'rest',
        description: room.description,
        options: ['[Rest] Rest here (+30% HP)', '[Continue] Keep moving']
      };
    }
    if (room.type === 'shop' && room.contents) {
      var shopOpts = room.contents.items.map(function(it, i) {
        return '[Buy ' + (i + 1) + '] ' + it.name + ' (' + it.value + ' Spark)';
      });
      shopOpts.push('[Leave] Exit shop');
      return {
        type: 'shop',
        description: room.description,
        options: shopOpts
      };
    }
    if (room.type === 'boss' && room.contents && room.contents.enemy && room.contents.enemy.alive) {
      return {
        type: 'boss',
        description: room.description,
        options: ['[Attack] Challenge the boss', '[Flee] Run away']
      };
    }
    // Room already cleared
    room.cleared = true;
    return { type: 'cleared', description: 'The room is clear.', options: ['[Forward] Move on', '[Back] Return'] };
  }

  /**
   * Fight an enemy.
   * @param {object} state - dungeon state
   * @param {string} action - 'attack', 'defend', 'flee'
   * @returns {{ state: object, result: string, message: string }}
   */
  function fightEnemy(state, action) {
    var newState = _cloneDungeonState(state);
    var room = newState.rooms[newState.currentRoom];
    if (!room || !room.contents || !room.contents.enemy || !room.contents.enemy.alive) {
      return { state: newState, result: 'no_enemy', message: 'There is no enemy here.' };
    }

    var player = newState.player;
    var enemy = room.contents.enemy;
    var msg = '';
    var result = 'ongoing';

    if (action === 'flee') {
      if (newState.currentRoom > 0) {
        newState.currentRoom -= 1;
        msg = 'You fled back to the previous room!';
        result = 'fled';
      } else {
        msg = 'Nowhere to flee!';
        result = 'ongoing';
      }
      newState.log.push(msg);
      return { state: newState, result: result, message: msg };
    }

    // Player attacks enemy
    var playerDamage = Math.max(1, player.attack - enemy.defense);
    if (action === 'defend') {
      playerDamage = Math.max(1, Math.floor(playerDamage * 0.5));
    }
    enemy.currentHp -= playerDamage;
    msg += 'You deal ' + playerDamage + ' damage to ' + enemy.name + '. ';

    if (enemy.currentHp <= 0) {
      enemy.alive = false;
      enemy.currentHp = 0;
      room.cleared = true;
      player.xp += enemy.xp;
      player.gold += enemy.loot;
      msg += enemy.name + ' defeated! Gained ' + enemy.xp + ' XP and ' + enemy.loot + ' gold.';
      result = 'victory';
    } else {
      // Enemy attacks player
      var enemyDamage = Math.max(1, enemy.attack - (action === 'defend' ? player.defense * 2 : player.defense));
      player.hp -= enemyDamage;
      msg += enemy.name + ' hits you for ' + enemyDamage + ' damage. ';
      if (player.hp <= 0) {
        player.hp = 0;
        msg += 'You have been defeated!';
        result = 'defeat';
      } else {
        msg += 'You have ' + player.hp + ' HP remaining. Enemy has ' + enemy.currentHp + ' HP.';
      }
    }

    newState.log.push(msg);
    return { state: newState, result: result, message: msg };
  }

  /**
   * Attempt to solve a puzzle.
   * @param {object} state - dungeon state
   * @param {number} answer - option index (0-based)
   * @returns {{ state: object, correct: boolean, reward: object|null, message: string }}
   */
  function solvePuzzle(state, answer) {
    var newState = _cloneDungeonState(state);
    var room = newState.rooms[newState.currentRoom];
    if (!room || room.type !== 'puzzle' || !room.contents || room.contents.solved) {
      return { state: newState, correct: false, reward: null, message: 'No unsolved puzzle here.' };
    }

    var puzzle = room.contents.puzzle;
    var correct = answer === puzzle.correct;
    var msg = '';
    var reward = null;

    if (correct) {
      room.contents.solved = true;
      room.cleared = true;
      reward = puzzle.reward;
      newState.player.items.push(reward);
      msg = 'Correct! The door opens. You receive: ' + reward.name + ' (value: ' + reward.value + ')';
    } else {
      // Wrong answer â€” take damage
      var penalty = 10;
      newState.player.hp = Math.max(0, newState.player.hp - penalty);
      msg = 'Wrong answer. A trap triggers and deals ' + penalty + ' damage. You have ' + newState.player.hp + ' HP.';
    }

    newState.log.push(msg);
    return { state: newState, correct: correct, reward: reward, message: msg };
  }

  /**
   * Open a treasure chest.
   * @param {object} state - dungeon state
   * @returns {{ state: object, loot: object|null, message: string }}
   */
  function openTreasure(state) {
    var newState = _cloneDungeonState(state);
    var room = newState.rooms[newState.currentRoom];
    if (!room || room.type !== 'treasure' || !room.contents || room.contents.looted) {
      return { state: newState, loot: null, message: 'Nothing to open here.' };
    }

    room.contents.looted = true;
    room.cleared = true;

    // Pick random loot
    var rng = createRng(hashString(newState.seed + ':' + newState.currentRoom));
    var item = JSON.parse(JSON.stringify(rngPick(rng, DUNGEON_ITEMS)));
    newState.player.items.push(item);

    // Also give some gold
    var gold = rngInt(rng, 5, 25);
    newState.player.gold += gold;

    var msg = 'You open the chest and find: ' + item.name + ' and ' + gold + ' gold!';
    newState.log.push(msg);
    return { state: newState, loot: item, message: msg };
  }

  /**
   * Rest at a campfire.
   * @param {object} state - dungeon state
   * @returns {{ state: object, healed: number, message: string }}
   */
  function restAtCamp(state) {
    var newState = _cloneDungeonState(state);
    var room = newState.rooms[newState.currentRoom];
    if (!room || room.type !== 'rest' || !room.contents) {
      return { state: newState, healed: 0, message: 'No place to rest here.' };
    }
    if (room.contents.rested) {
      return { state: newState, healed: 0, message: 'You have already rested here.' };
    }

    var healAmount = Math.floor(newState.player.maxHp * 0.3);
    newState.player.hp = Math.min(newState.player.maxHp, newState.player.hp + healAmount);
    room.contents.rested = true;
    room.cleared = true;

    var msg = 'You rest by the fire and recover ' + healAmount + ' HP. HP: ' + newState.player.hp + '/' + newState.player.maxHp;
    newState.log.push(msg);
    return { state: newState, healed: healAmount, message: msg };
  }

  /**
   * Format dungeon view as ASCII art.
   * @param {object} state - dungeon state
   * @returns {string} ASCII display
   */
  function formatDungeonView(state) {
    var lines = [];
    var rooms = state.rooms;
    var current = state.currentRoom;
    var cols = 3;
    var rows = Math.ceil(rooms.length / cols);

    // Build grid
    for (var r = 0; r < rows; r++) {
      lines.push('+' + new Array(cols).join('---+---+') + '---+');
      var row = '|';
      for (var c = 0; c < cols; c++) {
        var idx = r * cols + c;
        if (idx >= rooms.length) {
          row += '   |';
        } else {
          var room = rooms[idx];
          var sym = _roomSymbol(room, idx === current);
          row += ' ' + sym + ' |';
        }
      }
      lines.push(row);
    }
    lines.push('+' + new Array(cols).join('---+---+') + '---+');

    // Player stats
    var player = state.player;
    var hpBar = _hpBar(player.hp, player.maxHp, 10);
    lines.push('HP: [' + hpBar + '] ' + player.hp + '/' + player.maxHp + '  ATK: ' + player.attack + '  DEF: ' + player.defense);

    var currentRoomObj = rooms[current];
    var roomLabel = currentRoomObj ? currentRoomObj.type : 'unknown';
    lines.push('Room: ' + roomLabel + '  |  Floor ' + state.floor + '  |  ' + _countCleared(rooms) + '/' + rooms.length + ' rooms cleared');

    return lines.join('\n');
  }

  function _roomSymbol(room, isCurrent) {
    if (isCurrent) return '@';
    if (!room.visited) return '?';
    var syms = { entrance: 'S', empty: '.', enemy: 'E', treasure: 'T', puzzle: 'P', trap: '!', rest: 'R', shop: '$', boss: 'B' };
    return syms[room.type] || '.';
  }

  function _hpBar(hp, maxHp, width) {
    var filled = Math.round((hp / maxHp) * width);
    filled = Math.max(0, Math.min(filled, width));
    var bar = '';
    for (var i = 0; i < filled; i++) bar += '#';
    for (var j = filled; j < width; j++) bar += '-';
    return bar;
  }

  function _countCleared(rooms) {
    var count = 0;
    for (var i = 0; i < rooms.length; i++) {
      if (rooms[i].cleared) count++;
    }
    return count;
  }

  function _cloneDungeonState(state) {
    return JSON.parse(JSON.stringify(state));
  }

  // ===========================================================================
  // STARGAZING
  // ===========================================================================

  var CONSTELLATIONS = [
    {
      id: 'nexus_crown',
      name: 'The Nexus Crown',
      stars: 5,
      seasons: ['spring', 'summer', 'winter'],
      timeRange: [20, 4],
      lore: 'Seven founders of ZION who united the zones. Brightest in the winter sky.',
      ascii: ' * * *\n  ***\n   *'
    },
    {
      id: 'wanderers_path',
      name: 'The Wanderer\'s Path',
      stars: 4,
      seasons: ['autumn', 'winter', 'spring'],
      timeRange: [21, 5],
      lore: 'Marks the route taken by the first explorers. A guide for those who travel by night.',
      ascii: '*\n *\n  *\n   *'
    },
    {
      id: 'flame_serpent',
      name: 'The Flame Serpent',
      stars: 7,
      seasons: ['summer', 'spring'],
      timeRange: [22, 3],
      lore: 'Said to have breathed the first fires of the Studio. Artists invoke it for inspiration.',
      ascii: '  *\n * *\n*   *\n * *'
    },
    {
      id: 'water_bearer',
      name: 'The Water Bearer',
      stars: 6,
      seasons: ['winter', 'autumn'],
      timeRange: [19, 2],
      lore: 'Pours celestial streams into the Gardens. Gardeners plant by its light.',
      ascii: '*   *\n * *\n  *  \n * *'
    },
    {
      id: 'great_library',
      name: 'The Great Library',
      stars: 8,
      seasons: ['autumn', 'winter', 'spring', 'summer'],
      timeRange: [20, 6],
      lore: 'Always visible. Represents the eternal accumulation of knowledge at the Athenaeum.',
      ascii: '* * * *\n* * * *'
    },
    {
      id: 'silver_arena',
      name: 'The Silver Arena',
      stars: 5,
      seasons: ['summer', 'autumn'],
      timeRange: [21, 4],
      lore: 'Champions who fell in glorious battle. Their spirits watch each new contest.',
      ascii: ' * *\n*   *\n * *'
    },
    {
      id: 'root_network',
      name: 'The Root Network',
      stars: 9,
      seasons: ['spring', 'winter'],
      timeRange: [23, 5],
      lore: 'Represents the underground pathways connecting all zones beneath the surface.',
      ascii: '  *  *\n * * *\n*   *'
    },
    {
      id: 'twin_moons',
      name: 'The Twin Moons',
      stars: 2,
      seasons: ['spring', 'summer', 'autumn', 'winter'],
      timeRange: [18, 6],
      lore: 'Two moons of ZION â€” Lumen and Umbra. Represent balance between light and shadow.',
      ascii: '*  *'
    }
  ];

  var CELESTIAL_EVENTS = [
    { id: 'meteor_shower',   name: 'Meteor Shower',   desc: 'Streaks of light cross the sky. Wishes made now are said to come true.',      chance: 0.10 },
    { id: 'lunar_eclipse',   name: 'Lunar Eclipse',   desc: 'Umbra passes before Lumen. A rare and auspicious alignment.',                  chance: 0.05 },
    { id: 'aurora',          name: 'Aurora Nexus',    desc: 'Ribbons of color dance across the horizon. A gift from the zone spirits.',     chance: 0.08 },
    { id: 'comet_passage',   name: 'Comet Passage',   desc: 'A brilliant comet trails across the sky. Occurs once every hundred years.', chance: 0.03 },
    { id: 'alignment',       name: 'Grand Alignment', desc: 'All major constellations align. Sages say destiny is written on such nights.', chance: 0.02 }
  ];

  /**
   * Create stargazing state.
   * @param {number} timeOfDay - hour (0-23)
   * @param {string} season - 'spring', 'summer', 'autumn', 'winter'
   * @returns {object} stargazing state
   */
  function createStargazingState(timeOfDay, season) {
    var visible = getVisibleConstellations(timeOfDay, season);
    return {
      visible: visible,
      identified: [],
      zodiac: _getZodiac(timeOfDay),
      event: null,
      timeOfDay: timeOfDay,
      season: season
    };
  }

  /**
   * Get constellations visible at given time and season.
   * @param {number} timeOfDay - hour (0-23)
   * @param {string} season
   * @returns {Array} visible constellations
   */
  function getVisibleConstellations(timeOfDay, season) {
    // Night hours only
    var isNight = timeOfDay >= 18 || timeOfDay <= 6;
    if (!isNight) return [];

    var visible = [];
    for (var i = 0; i < CONSTELLATIONS.length; i++) {
      var c = CONSTELLATIONS[i];
      if (c.seasons.indexOf(season) === -1) continue;
      // Check time range (wraps midnight)
      var start = c.timeRange[0];
      var end = c.timeRange[1];
      var inRange = false;
      if (start > end) {
        // Wraps midnight
        inRange = timeOfDay >= start || timeOfDay <= end;
      } else {
        inRange = timeOfDay >= start && timeOfDay <= end;
      }
      if (inRange) visible.push(c.id);
    }
    return visible;
  }

  /**
   * Identify a constellation.
   * @param {object} state - stargazing state
   * @param {string} constellationId
   * @returns {{ state: object, success: boolean, constellation: object|null, lore: string }}
   */
  function identifyConstellation(state, constellationId) {
    var newState = JSON.parse(JSON.stringify(state));
    if (newState.visible.indexOf(constellationId) === -1) {
      return { state: newState, success: false, constellation: null, lore: 'That constellation is not visible right now.' };
    }
    if (newState.identified.indexOf(constellationId) !== -1) {
      var known = _findConstellation(constellationId);
      return { state: newState, success: false, constellation: known, lore: 'You have already identified ' + (known ? known.name : constellationId) + '.' };
    }
    var constellation = _findConstellation(constellationId);
    if (!constellation) {
      return { state: newState, success: false, constellation: null, lore: 'Unknown constellation.' };
    }
    newState.identified.push(constellationId);
    return {
      state: newState,
      success: true,
      constellation: constellation,
      lore: constellation.lore
    };
  }

  /**
   * Check for a celestial event.
   * @param {number} timeOfDay - hour
   * @param {number} dayOfYear - day of year (1-365)
   * @returns {object|null} celestial event or null
   */
  function checkCelestialEvent(timeOfDay, dayOfYear) {
    // Only at night
    var isNight = timeOfDay >= 20 || timeOfDay <= 4;
    if (!isNight) return null;

    // Use day of year as seed for determinism
    var rng = createRng(hashString('celestial:' + dayOfYear));
    for (var i = 0; i < CELESTIAL_EVENTS.length; i++) {
      var ev = CELESTIAL_EVENTS[i];
      if (rng() < ev.chance) {
        return { id: ev.id, name: ev.name, desc: ev.desc };
      }
    }
    return null;
  }

  /**
   * Format night sky as ASCII star map.
   * @param {object} state - stargazing state
   * @returns {string} ASCII display
   */
  function formatNightSky(state) {
    var lines = [];
    lines.push('=== Night Sky ===');
    lines.push('Season: ' + state.season + '  |  Time: ' + state.timeOfDay + ':00');

    if (state.visible.length === 0) {
      lines.push('The sky is too bright to see stars. Come back at night.');
      return lines.join('\n');
    }

    lines.push('');
    lines.push('Visible constellations:');

    for (var i = 0; i < state.visible.length; i++) {
      var cid = state.visible[i];
      var constellation = _findConstellation(cid);
      if (!constellation) continue;
      var isIdentified = state.identified.indexOf(cid) !== -1;
      if (isIdentified) {
        lines.push('  [Identified] ' + constellation.name);
        lines.push(constellation.ascii.split('\n').map(function(l) { return '    ' + l; }).join('\n'));
      } else {
        lines.push('  [Unknown]    ???  (' + constellation.stars + ' stars)');
        // Show dots for unidentified
        var dots = '';
        for (var s = 0; s < constellation.stars; s++) dots += '. ';
        lines.push('    ' + dots.trim());
      }
    }

    if (state.event) {
      lines.push('');
      lines.push('** ' + state.event.name + ' **');
      lines.push(state.event.desc);
    }

    return lines.join('\n');
  }

  function _findConstellation(id) {
    for (var i = 0; i < CONSTELLATIONS.length; i++) {
      if (CONSTELLATIONS[i].id === id) return CONSTELLATIONS[i];
    }
    return null;
  }

  function _getZodiac(timeOfDay) {
    var hour = timeOfDay % 24;
    var zodiacSigns = ['Root Network', 'Water Bearer', 'Flame Serpent', 'Nexus Crown',
                       'Silver Arena', 'Great Library', 'Wanderer\'s Path', 'Twin Moons'];
    return zodiacSigns[Math.floor(hour / 3) % zodiacSigns.length];
  }

  // ===========================================================================
  // PANEL BUILDER (DOM â€” only runs in browser)
  // ===========================================================================

  /**
   * Create the main games panel DOM element.
   * @returns {Element} panel element
   */
  function createGamesPanel() {
    if (typeof document === 'undefined') return null;

    var panel = document.createElement('div');
    panel.className = 'dg-panel';
    panel.style.cssText = 'font-family: monospace; background: #0a0a1a; color: #ccc; padding: 10px; border: 1px solid #333; min-height: 400px;';

    // Tab bar
    var tabs = ['Fishing', 'Card Game', 'Dungeon', 'Stargazing'];
    var tabBar = document.createElement('div');
    tabBar.style.cssText = 'display: flex; gap: 4px; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 6px;';

    var contentArea = document.createElement('div');
    contentArea.style.cssText = 'min-height: 300px;';

    var activeTab = 0;

    tabs.forEach(function(tabName, idx) {
      var btn = document.createElement('button');
      btn.textContent = tabName;
      btn.style.cssText = 'background: #111; color: #aaa; border: 1px solid #444; padding: 4px 10px; cursor: pointer; font-family: monospace;';
      btn.addEventListener('click', function() {
        activeTab = idx;
        renderTab(contentArea, idx);
        Array.from(tabBar.children).forEach(function(b, bi) {
          b.style.background = bi === idx ? '#222' : '#111';
          b.style.color = bi === idx ? '#fff' : '#aaa';
        });
      });
      if (idx === 0) {
        btn.style.background = '#222';
        btn.style.color = '#fff';
      }
      tabBar.appendChild(btn);
    });

    panel.appendChild(tabBar);
    panel.appendChild(contentArea);

    // Render initial tab
    renderTab(contentArea, 0);

    return panel;
  }

  function renderTab(container, tabIndex) {
    container.innerHTML = '';
    var pre = document.createElement('pre');
    pre.style.cssText = 'margin: 0; color: #ccc; font-size: 12px; white-space: pre-wrap;';

    if (tabIndex === 0) {
      // Fishing
      var fishState = createFishingGame();
      var cast = castLine(fishState, 'nexus');
      pre.textContent = 'FISHING\n\n' + cast.message + '\n\n' +
        'Fish available at nexus:\n' +
        getFishForLocation('nexus').map(function(f) {
          return '  ' + f.name + ' [' + f.rarity + '] â€” ' + f.desc;
        }).join('\n') +
        '\n\n[Cast] [Reel In] [Check Bite] [View Catches] [Sell]';
    } else if (tabIndex === 1) {
      // Card Game
      var bState = createCardBattleState();
      pre.textContent = 'CARD GAME BATTLE\n\n' + formatBattleField(bState) + '\n\n[Draw] [Play Card] [Attack] [End Turn]';
    } else if (tabIndex === 2) {
      // Dungeon
      var dState = createDungeonRun('default', 'medium');
      pre.textContent = 'DUNGEON EXPLORER\n\n' + formatDungeonView(dState) + '\n\n[Forward] [Back] [Attack] [Use Item]';
    } else if (tabIndex === 3) {
      // Stargazing
      var sgState = createStargazingState(22, 'winter');
      pre.textContent = 'STARGAZING\n\n' + formatNightSky(sgState) + '\n\n[Identify] [Check Events]';
    }

    container.appendChild(pre);
  }

  // ===========================================================================
  // EXPORTS
  // ===========================================================================

  // Fishing
  exports.createFishingGame = createFishingGame;
  exports.castLine = castLine;
  exports.checkBite = checkBite;
  exports.reelIn = reelIn;
  exports.getFishForLocation = getFishForLocation;
  exports.sellFish = sellFish;
  exports.getFishingStats = getFishingStats;
  exports.FISH_BY_ZONE = FISH_BY_ZONE;

  // Card Game
  exports.createCardBattleState = createCardBattleState;
  exports.drawCard = drawCard;
  exports.playCard = playCard;
  exports.attackWithCreature = attackWithCreature;
  exports.endTurn = endTurn;
  exports.checkWinner = checkWinner;
  exports.aiTurn = aiTurn;
  exports.formatBattleField = formatBattleField;
  exports.CARD_CATALOG_SIMPLE = CARD_CATALOG_SIMPLE;

  // Dungeon
  exports.createDungeonRun = createDungeonRun;
  exports.generateRoom = generateRoom;
  exports.enterRoom = enterRoom;
  exports.fightEnemy = fightEnemy;
  exports.solvePuzzle = solvePuzzle;
  exports.openTreasure = openTreasure;
  exports.restAtCamp = restAtCamp;
  exports.formatDungeonView = formatDungeonView;

  // Stargazing
  exports.createStargazingState = createStargazingState;
  exports.getVisibleConstellations = getVisibleConstellations;
  exports.identifyConstellation = identifyConstellation;
  exports.checkCelestialEvent = checkCelestialEvent;
  exports.formatNightSky = formatNightSky;
  exports.CONSTELLATIONS = CONSTELLATIONS;

  // Panel (browser only)
  exports.createGamesPanel = createGamesPanel;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardGames = {}));


// dashboard_world.js
// dashboard_world.js â€” WORLD STATUS panel for ZION dashboard (UI-only mode)
// Shows time of day, weather, active events, season info, and world news.
(function(exports) {
  'use strict';

  // â”€â”€ Zone IDs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  var ZONE_IDS = ['nexus', 'gardens', 'athenaeum', 'studio', 'wilds', 'agora', 'commons', 'arena'];

  var ZONE_NAMES = {
    nexus:     'The Nexus',
    gardens:   'The Gardens',
    athenaeum: 'The Athenaeum',
    studio:    'The Studio',
    wilds:     'The Wilds',
    agora:     'The Agora',
    commons:   'The Commons',
    arena:     'The Arena'
  };

  // â”€â”€ Time System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates a new world time state.
   * 1 real second = 1 game minute (timeScale = 60).
   * Full day = 1200 ticks = 20 real minutes.
   */
  function createWorldTime() {
    return {
      tick: 0,
      dayLength: 1200,
      timeScale: 60
    };
  }

  /**
   * Advance world time by deltaTicks.
   * Returns new state (does not mutate).
   */
  function advanceTime(state, deltaTicks) {
    var delta = deltaTicks || 0;
    return {
      tick: state.tick + delta,
      dayLength: state.dayLength,
      timeScale: state.timeScale
    };
  }

  /**
   * Returns time-of-day as fraction 0â€“1.
   *   0.0 = midnight, 0.25 = 6:00, 0.5 = noon, 0.75 = 18:00
   */
  function getTimeOfDay(tick, dayLength) {
    var len = dayLength || 1200;
    return (tick % len) / len;
  }

  /**
   * Returns the named phase of day.
   * 0.00â€“0.20 â†’ 'night'
   * 0.20â€“0.30 â†’ 'dawn'
   * 0.30â€“0.45 â†’ 'morning'
   * 0.45â€“0.55 â†’ 'noon'
   * 0.55â€“0.70 â†’ 'afternoon'
   * 0.70â€“0.80 â†’ 'dusk'
   * 0.80â€“1.00 â†’ 'evening'
   */
  function getPhaseOfDay(timeOfDay) {
    // Wrap only integer multiples to avoid floating-point drift at phase boundaries.
    var t = timeOfDay - Math.floor(timeOfDay); // equivalent to fmod, no precision loss
    if (t < 0.20) return 'night';
    if (t < 0.30) return 'dawn';
    if (t < 0.45) return 'morning';
    if (t < 0.55) return 'noon';
    if (t < 0.70) return 'afternoon';
    if (t < 0.80) return 'dusk';
    return 'evening';
  }

  /**
   * Formats time-of-day fraction as "HH:MM" (24-hour).
   */
  function formatGameTime(timeOfDay) {
    var t = timeOfDay - Math.floor(timeOfDay);
    var totalMinutes = Math.floor(t * 24 * 60);
    var hours   = Math.floor(totalMinutes / 60);
    var minutes = totalMinutes % 60;
    return (hours < 10 ? '0' : '') + hours + ':' + (minutes < 10 ? '0' : '') + minutes;
  }

  /**
   * Returns the current day number (1-based) from the tick counter.
   */
  function getDayNumber(tick, dayLength) {
    var len = dayLength || 1200;
    return Math.floor(tick / len) + 1;
  }

  /**
   * Returns the season name for a given day number.
   * Cycles every 360 days: spring 1â€“90, summer 91â€“180, autumn 181â€“270, winter 271â€“360.
   */
  function getSeason(dayNumber) {
    var d = ((dayNumber - 1) % 360) + 1; // 1-based within 360-day year
    if (d <= 90)  return 'spring';
    if (d <= 180) return 'summer';
    if (d <= 270) return 'autumn';
    return 'winter';
  }

  /**
   * Returns progress within current season as 0â€“1.
   */
  function getSeasonProgress(dayNumber) {
    var d = ((dayNumber - 1) % 360) + 1;
    if (d <= 90)  return (d - 1) / 90;
    if (d <= 180) return (d - 91) / 90;
    if (d <= 270) return (d - 181) / 90;
    return (d - 271) / 90;
  }

  /**
   * Returns a formatted display string for the current time state.
   * Example: "Day 42 | 14:30 | Afternoon | Summer"
   */
  function formatTimeDisplay(tick, dayLength) {
    var len     = dayLength || 1200;
    var tod     = getTimeOfDay(tick, len);
    var day     = getDayNumber(tick, len);
    var phase   = getPhaseOfDay(tod);
    var season  = getSeason(day);
    var timeStr = formatGameTime(tod);

    var phaseLabel  = phase.charAt(0).toUpperCase() + phase.slice(1);
    var seasonLabel = season.charAt(0).toUpperCase() + season.slice(1);

    return 'Day ' + day + ' | ' + timeStr + ' | ' + phaseLabel + ' | ' + seasonLabel;
  }

  // â”€â”€ Seeded RNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Simple deterministic PRNG based on mulberry32.
   * Returns a function that produces 0â€“1 floats.
   */
  function createSeededRng(seed) {
    var s = (seed >>> 0) || 1;
    return function() {
      s = (s + 0x6d2b79f5) >>> 0;
      var t = Math.imul(s ^ (s >>> 15), 1 | s);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) >>> 0;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  // â”€â”€ Weather System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates an empty weather state.
   */
  function createWeatherState() {
    return {
      zones: {},
      globalWind: { speed: 0, direction: 0 },
      lastUpdate: 0
    };
  }

  // Relative likelihoods per season; each type maps to weight 0â€“10
  var WEATHER_WEIGHTS = {
    spring:   { clear: 4, cloudy: 3, overcast: 2, rain: 3, storm: 1, fog: 2, snow: 0, heatwave: 0, wind: 2 },
    summer:   { clear: 6, cloudy: 2, overcast: 1, rain: 2, storm: 2, fog: 0, snow: 0, heatwave: 2, wind: 1 },
    autumn:   { clear: 3, cloudy: 3, overcast: 3, rain: 3, storm: 2, fog: 3, snow: 1, heatwave: 0, wind: 3 },
    winter:   { clear: 2, cloudy: 3, overcast: 3, rain: 2, storm: 1, fog: 2, snow: 5, heatwave: 0, wind: 2 }
  };

  var WIND_DIRECTIONS = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];

  /**
   * Seeded weather generation for a single zone.
   * Returns { type, intensity, temperature, windSpeed, windDirection, visibility, precipitation }
   */
  function generateWeather(seed, zoneId, season, timeOfDay) {
    var rng     = createSeededRng(seed + _hashStr(zoneId + (season || 'spring')));
    var weights = WEATHER_WEIGHTS[season || 'spring'] || WEATHER_WEIGHTS.spring;

    // Build weighted table
    var types = Object.keys(weights);
    var total = 0;
    for (var i = 0; i < types.length; i++) {
      total += weights[types[i]];
    }
    var roll = rng() * total;
    var type = 'clear';
    var cum  = 0;
    for (var j = 0; j < types.length; j++) {
      cum += weights[types[j]];
      if (roll < cum) { type = types[j]; break; }
    }

    var intensity   = Math.round(rng() * 10) / 10; // 0.0â€“1.0
    var windSpeed   = Math.floor(rng() * 60);       // 0â€“59 km/h
    var windDir     = WIND_DIRECTIONS[Math.floor(rng() * 8)];
    var visibility  = _calcVisibility(type, intensity);
    var precip      = _calcPrecipitation(type, intensity);
    var temperature = getTemperature(season, timeOfDay, zoneId, { type: type, intensity: intensity });

    return {
      type:        type,
      intensity:   intensity,
      temperature: temperature,
      windSpeed:   windSpeed,
      windDirection: windDir,
      visibility:  visibility,
      precipitation: precip
    };
  }

  function _calcVisibility(type, intensity) {
    var base = { clear: 100, cloudy: 80, overcast: 60, rain: 50, storm: 30, fog: 20, snow: 40, heatwave: 90, wind: 70 };
    var v = (base[type] || 80) - Math.floor(intensity * 20);
    return Math.max(10, v);
  }

  function _calcPrecipitation(type, intensity) {
    if (type === 'rain' || type === 'storm') return Math.floor(intensity * 30);
    if (type === 'snow') return Math.floor(intensity * 15);
    return 0;
  }

  /** Simple djb2-style string hash to an unsigned integer. */
  function _hashStr(s) {
    var h = 5381;
    for (var i = 0; i < s.length; i++) {
      h = ((h << 5) + h) + s.charCodeAt(i);
      h = h >>> 0;
    }
    return h;
  }

  /**
   * Returns the current weather for a zone from state.
   */
  function getWeatherForZone(state, zoneId) {
    if (!state || !state.zones) return null;
    return state.zones[zoneId] || null;
  }

  /**
   * Update weather for all 8 zones; returns a new state.
   */
  function updateAllWeather(state, seed, season, timeOfDay) {
    var newZones = {};
    for (var i = 0; i < ZONE_IDS.length; i++) {
      var zid = ZONE_IDS[i];
      newZones[zid] = generateWeather(seed, zid, season, timeOfDay);
    }
    return {
      zones:      newZones,
      globalWind: { speed: Math.floor(Math.random() * 40), direction: Math.floor(Math.random() * 360) },
      lastUpdate: Date.now()
    };
  }

  // Season base temperatures (Â°C)
  var SEASON_BASE_TEMP = { spring: 15, summer: 28, autumn: 12, winter: 2 };

  // Zone temperature modifiers
  var ZONE_TEMP_MOD = { wilds: -3, arena: 2, gardens: 1 };

  // Weather temperature modifiers
  var WEATHER_TEMP_MOD = { rain: -3, heatwave: 10, snow: -5, storm: -4, fog: -1 };

  /**
   * Calculate temperature for zone/time/weather combination.
   */
  function getTemperature(season, timeOfDay, zoneId, weather) {
    var base     = SEASON_BASE_TEMP[season] !== undefined ? SEASON_BASE_TEMP[season] : 15;
    var tod      = timeOfDay || 0;
    var todMod   = 0;
    var phase    = getPhaseOfDay(tod);
    if (phase === 'night' || phase === 'evening') todMod = -8;
    else if (phase === 'noon') todMod = 5;
    else if (phase === 'afternoon') todMod = 3;
    else if (phase === 'morning' || phase === 'dawn') todMod = -2;

    var zoneMod    = ZONE_TEMP_MOD[zoneId] || 0;
    var weatherMod = 0;
    if (weather && weather.type) {
      weatherMod = WEATHER_TEMP_MOD[weather.type] || 0;
    }

    return Math.round(base + todMod + zoneMod + weatherMod);
  }

  /**
   * Returns human-readable weather summary.
   * Example: "Clear skies, 22C, Light breeze from NW, Visibility: Good"
   */
  function formatWeatherDisplay(weather) {
    if (!weather) return 'Unknown conditions';

    var typeLabels = {
      clear:    'Clear skies',
      cloudy:   'Partly cloudy',
      overcast: 'Overcast',
      rain:     'Rain',
      storm:    'Storm',
      fog:      'Foggy',
      snow:     'Snow',
      heatwave: 'Heat wave',
      wind:     'Windy'
    };

    var label = typeLabels[weather.type] || weather.type;
    var temp  = weather.temperature + 'C';

    var windLabel;
    var ws = weather.windSpeed || 0;
    if (ws < 5)       windLabel = 'Calm';
    else if (ws < 20) windLabel = 'Light breeze from ' + (weather.windDirection || 'N');
    else if (ws < 40) windLabel = 'Moderate wind from ' + (weather.windDirection || 'N');
    else              windLabel = 'Strong wind from ' + (weather.windDirection || 'N');

    var vis     = weather.visibility || 100;
    var visLabel;
    if (vis >= 80)      visLabel = 'Excellent';
    else if (vis >= 50) visLabel = 'Good';
    else if (vis >= 30) visLabel = 'Moderate';
    else                visLabel = 'Poor';

    return label + ', ' + temp + ', ' + windLabel + ', Visibility: ' + visLabel;
  }

  /**
   * Returns a bracket-icon for a weather type.
   */
  function getWeatherIcon(type) {
    var icons = {
      clear:    '[*]',
      cloudy:   '[~]',
      overcast: '[~]',
      rain:     '[/]',
      storm:    '[!]',
      fog:      '[.]',
      snow:     '[:]',
      heatwave: '[^]',
      wind:     '[>]'
    };
    return icons[type] || '[?]';
  }

  /**
   * Returns gameplay effects for a weather condition.
   * { fishingBonus, farmingBonus, explorationPenalty, combatModifier }
   */
  function getWeatherEffect(weather) {
    if (!weather) {
      return { fishingBonus: 0, farmingBonus: 0, explorationPenalty: 0, combatModifier: 0 };
    }
    var type   = weather.type || 'clear';
    var effect = {
      fishingBonus:       0,
      farmingBonus:       0,
      explorationPenalty: 0,
      combatModifier:     0
    };

    switch (type) {
      case 'rain':
        effect.fishingBonus  = 20;
        effect.farmingBonus  = 10;
        break;
      case 'storm':
        effect.explorationPenalty = 30;
        effect.combatModifier     = -10;
        break;
      case 'clear':
        effect.explorationPenalty = -10; // bonus (negative penalty)
        break;
      case 'heatwave':
        effect.farmingBonus = -20;
        break;
      case 'snow':
        effect.explorationPenalty = 15;
        effect.combatModifier     = -5;
        break;
      case 'fog':
        effect.explorationPenalty = 10;
        effect.combatModifier     = -5;
        break;
      case 'wind':
        effect.explorationPenalty = 5;
        break;
    }
    return effect;
  }

  // â”€â”€ World Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates an empty event state.
   */
  function createEventState() {
    return {
      active:   [],
      upcoming: [],
      history:  [],
      nextId:   1
    };
  }

  // Event type catalog
  var EVENT_TYPES = {
    market_day: {
      title:       'Market Day',
      description: 'Double market activity in the Agora. Merchants and buyers flood the stalls.',
      zone:        'agora',
      duration:    600
    },
    festival: {
      title:       'Community Festival',
      description: 'A joyful community celebration fills the Commons with music and laughter.',
      zone:        'commons',
      duration:    900
    },
    harvest: {
      title:       'Great Harvest',
      description: 'Bonus gathering in the Gardens as crops and herbs grow in abundance.',
      zone:        'gardens',
      duration:    480
    },
    tournament: {
      title:       'Grand Tournament',
      description: 'Competitors clash in the Arena for glory and prizes.',
      zone:        'arena',
      duration:    720
    },
    storm_surge: {
      title:       'Storm Surge',
      description: 'A violent storm tears through the Wilds. Dangerous for those unprepared.',
      zone:        'wilds',
      duration:    360
    },
    knowledge_fair: {
      title:       'Knowledge Fair',
      description: 'Bonus XP for learning and teaching in the Athenaeum.',
      zone:        'athenaeum',
      duration:    600
    },
    art_exhibition: {
      title:       'Art Exhibition',
      description: 'A grand exhibition in the Studio grants crafting bonuses to all artisans.',
      zone:        'studio',
      duration:    480
    },
    full_moon: {
      title:       'Full Moon',
      description: 'The full moon rises, enhancing stargazing and attracting rare fish.',
      zone:        'nexus',
      duration:    1200
    },
    meteor_shower: {
      title:       'Meteor Shower',
      description: 'Star fragments can be found across the world during this celestial event.',
      zone:        'nexus',
      duration:    600
    },
    migration: {
      title:       'Creature Migration',
      description: 'Rare creatures appear in the Wilds, offering unique encounters.',
      zone:        'wilds',
      duration:    720
    }
  };

  var EVENT_TYPE_KEYS = Object.keys(EVENT_TYPES);

  /**
   * Seeded event generation for a given day and season.
   * Returns an event object: { id, type, title, description, zone, startTick, duration, rewards, participants }
   */
  function generateEvent(seed, dayNumber, season) {
    var rng = createSeededRng(seed + (dayNumber || 1) * 997 + _hashStr(season || 'spring'));
    var idx  = Math.floor(rng() * EVENT_TYPE_KEYS.length);
    var type = EVENT_TYPE_KEYS[idx];
    var def  = EVENT_TYPES[type];

    // Seasonal event weighting: some events appear more in certain seasons
    var seasonalBias = {
      spring:  ['harvest', 'festival', 'migration'],
      summer:  ['tournament', 'market_day', 'meteor_shower'],
      autumn:  ['harvest', 'art_exhibition', 'knowledge_fair'],
      winter:  ['festival', 'full_moon', 'storm_surge']
    };
    var biased = seasonalBias[season || 'spring'];
    if (biased && rng() < 0.5) {
      type = biased[Math.floor(rng() * biased.length)];
      def  = EVENT_TYPES[type];
    }

    var startTick = Math.floor(rng() * 1200); // random start within a day
    var rewards = {
      sparks:    10 + Math.floor(rng() * 40),
      xp:        5  + Math.floor(rng() * 20),
      item:      rng() > 0.7 ? 'rare_item' : null
    };

    return {
      id:           0, // assigned by state
      type:         type,
      title:        def.title,
      description:  def.description,
      zone:         def.zone,
      startTick:    startTick,
      duration:     def.duration,
      rewards:      rewards,
      participants: []
    };
  }

  /**
   * Returns events whose time window covers currentTick.
   */
  function getActiveEvents(state, currentTick) {
    if (!state || !state.active) return [];
    return state.active.filter(function(ev) {
      return currentTick >= ev.startTick && currentTick < (ev.startTick + ev.duration);
    });
  }

  /**
   * Returns events starting within lookahead ticks from currentTick.
   */
  function getUpcomingEvents(state, currentTick, lookahead) {
    if (!state || !state.upcoming) return [];
    var ahead = lookahead !== undefined ? lookahead : 300;
    return state.upcoming.filter(function(ev) {
      return ev.startTick > currentTick && ev.startTick <= currentTick + ahead;
    });
  }

  /**
   * Add a player as a participant in an event.
   * Returns { success, state, event }.
   */
  function joinEvent(state, eventId, playerId) {
    if (!state || !state.active) return { success: false, state: state, event: null };
    var ev = null;
    var activeIdx = -1;
    for (var i = 0; i < state.active.length; i++) {
      if (state.active[i].id === eventId) {
        ev = state.active[i];
        activeIdx = i;
        break;
      }
    }
    if (!ev) return { success: false, state: state, event: null };
    if (ev.participants.indexOf(playerId) !== -1) {
      return { success: false, state: state, event: ev };
    }

    var newEvent = _cloneEvent(ev);
    newEvent.participants.push(playerId);

    var newActive = state.active.slice();
    newActive[activeIdx] = newEvent;

    var newState = {
      active:   newActive,
      upcoming: state.upcoming,
      history:  state.history,
      nextId:   state.nextId
    };
    return { success: true, state: newState, event: newEvent };
  }

  /**
   * Finalize an event. Moves it to history and returns rewards.
   * Returns { success, state, rewards }.
   */
  function completeEvent(state, eventId, currentTick) {
    if (!state || !state.active) return { success: false, state: state, rewards: [] };
    var ev = null;
    var activeIdx = -1;
    for (var i = 0; i < state.active.length; i++) {
      if (state.active[i].id === eventId) {
        ev = state.active[i];
        activeIdx = i;
        break;
      }
    }
    if (!ev) return { success: false, state: state, rewards: [] };

    var completedEvent = _cloneEvent(ev);
    completedEvent.completedAt = currentTick;

    var newActive  = state.active.slice();
    newActive.splice(activeIdx, 1);

    var newHistory = state.history.concat([completedEvent]);

    var rewards = ev.participants.map(function(pid) {
      return { playerId: pid, sparks: ev.rewards.sparks, xp: ev.rewards.xp, item: ev.rewards.item };
    });

    var newState = {
      active:   newActive,
      upcoming: state.upcoming,
      history:  newHistory,
      nextId:   state.nextId
    };
    return { success: true, state: newState, rewards: rewards };
  }

  function _cloneEvent(ev) {
    return {
      id:           ev.id,
      type:         ev.type,
      title:        ev.title,
      description:  ev.description,
      zone:         ev.zone,
      startTick:    ev.startTick,
      duration:     ev.duration,
      rewards:      { sparks: ev.rewards.sparks, xp: ev.rewards.xp, item: ev.rewards.item },
      participants: ev.participants.slice(),
      completedAt:  ev.completedAt
    };
  }

  /**
   * Returns HTML for an event card.
   */
  function formatEventCard(event, currentTick) {
    var tick   = currentTick || 0;
    var endTick = event.startTick + event.duration;
    var remaining = endTick - tick;
    var minutes   = Math.max(0, Math.floor(remaining / 60));
    var seconds   = Math.max(0, remaining % 60);
    var timeLabel = remaining > 0
      ? (minutes + 'm ' + seconds + 's remaining')
      : 'Ended';

    var zoneName  = ZONE_NAMES[event.zone] || event.zone;
    var partCount = event.participants ? event.participants.length : 0;

    return '<div class="dw-event-card" data-event-id="' + event.id + '">' +
      '<div class="dw-event-header">' +
        '<span class="dw-event-title">' + _escHtml(event.title) + '</span>' +
        '<span class="dw-event-zone">' + _escHtml(zoneName) + '</span>' +
      '</div>' +
      '<div class="dw-event-desc">' + _escHtml(event.description) + '</div>' +
      '<div class="dw-event-meta">' +
        '<span class="dw-event-time">' + timeLabel + '</span>' +
        '<span class="dw-event-participants">' + partCount + ' participants</span>' +
      '</div>' +
      '<button class="dw-event-join-btn" data-event-id="' + event.id + '">[Join]</button>' +
    '</div>';
  }

  // â”€â”€ World News â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates an empty news state.
   */
  function createNewsState() {
    return {
      entries:    [],
      maxEntries: 50
    };
  }

  /**
   * Adds a news entry to the state. Trims to maxEntries.
   * entry: { type, title, description, timestamp, zone }
   */
  function addNewsEntry(state, entry) {
    var newEntries = state.entries.concat([{
      type:        entry.type      || 'discovery',
      title:       entry.title     || '',
      description: entry.description || '',
      timestamp:   entry.timestamp !== undefined ? entry.timestamp : Date.now(),
      zone:        entry.zone      || null
    }]);
    if (newEntries.length > state.maxEntries) {
      newEntries = newEntries.slice(newEntries.length - state.maxEntries);
    }
    return { entries: newEntries, maxEntries: state.maxEntries };
  }

  /**
   * Returns the last N news entries (default 10), most recent last.
   */
  function getRecentNews(state, limit) {
    if (!state || !state.entries) return [];
    var n = limit !== undefined ? limit : 10;
    return state.entries.slice(-n);
  }

  /**
   * Returns HTML for a scrollable news feed.
   */
  function formatNewsFeed(entries) {
    if (!entries || entries.length === 0) {
      return '<div class="dw-news-feed"><p class="dw-news-empty">No recent news.</p></div>';
    }

    var TYPE_BADGE_CLASS = {
      event_start:  'badge-event',
      event_end:    'badge-event',
      election:     'badge-election',
      guild:        'badge-guild',
      achievement:  'badge-achievement',
      weather:      'badge-weather',
      discovery:    'badge-discovery',
      economy:      'badge-economy'
    };

    var html = '<div class="dw-news-feed">';
    // Show most recent first
    var reversed = entries.slice().reverse();
    for (var i = 0; i < reversed.length; i++) {
      var e        = reversed[i];
      var badgeCls = TYPE_BADGE_CLASS[e.type] || 'badge-discovery';
      var tsLabel  = _formatTimestamp(e.timestamp);
      html += '<div class="dw-news-entry">' +
        '<span class="dw-news-ts">' + _escHtml(tsLabel) + '</span>' +
        '<span class="dw-news-badge ' + badgeCls + '">' + _escHtml(e.type) + '</span>' +
        '<span class="dw-news-title">' + _escHtml(e.title) + '</span>' +
        '<p class="dw-news-desc">'    + _escHtml(e.description) + '</p>' +
      '</div>';
    }
    html += '</div>';
    return html;
  }

  /**
   * Compares current and previous game state, generating news entries for changes.
   * Returns an array of news entry objects.
   */
  function generateAutoNews(gameState, previousState) {
    var news = [];
    if (!gameState || !previousState) return news;

    // Weather shifts
    if (gameState.weather && previousState.weather) {
      for (var i = 0; i < ZONE_IDS.length; i++) {
        var zid = ZONE_IDS[i];
        var cur  = gameState.weather.zones  && gameState.weather.zones[zid];
        var prev = previousState.weather && previousState.weather.zones && previousState.weather.zones[zid];
        if (cur && prev && cur.type !== prev.type) {
          news.push({
            type:        'weather',
            title:       'Weather change in ' + (ZONE_NAMES[zid] || zid),
            description: 'Conditions changed from ' + prev.type + ' to ' + cur.type + '.',
            timestamp:   Date.now(),
            zone:        zid
          });
        }
      }
    }

    // Economy milestones (if ledger present)
    if (gameState.ledger && previousState.ledger) {
      var curTx  = (gameState.ledger.transactions  || []).length;
      var prevTx = (previousState.ledger.transactions || []).length;
      if (curTx > prevTx) {
        var delta = curTx - prevTx;
        if (delta >= 10) {
          news.push({
            type:        'economy',
            title:       'Busy market activity',
            description: delta + ' new transactions recorded in the ledger.',
            timestamp:   Date.now(),
            zone:        'agora'
          });
        }
      }
    }

    // Zone player arrivals (players object or array)
    if (gameState.players && previousState.players) {
      var curPlayers  = Object.keys(gameState.players).length;
      var prevPlayers = Object.keys(previousState.players).length;
      if (curPlayers > prevPlayers) {
        news.push({
          type:        'discovery',
          title:       'New arrivals in ZION',
          description: (curPlayers - prevPlayers) + ' new citizen(s) have joined the world.',
          timestamp:   Date.now(),
          zone:        'nexus'
        });
      }
    }

    return news;
  }

  // â”€â”€ Zone Activity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Returns per-zone activity summary from game state.
   * Returns { zoneId: { playerCount, npcCount, activeEvents, weather, temperature } }
   */
  function getZoneActivity(gameState) {
    var result = {};

    for (var i = 0; i < ZONE_IDS.length; i++) {
      var zid = ZONE_IDS[i];
      result[zid] = {
        playerCount:  0,
        npcCount:     0,
        activeEvents: 0,
        weather:      null,
        temperature:  null
      };
    }

    if (!gameState) return result;

    // Count players per zone
    if (gameState.players) {
      var playerKeys = Object.keys(gameState.players);
      for (var p = 0; p < playerKeys.length; p++) {
        var player = gameState.players[playerKeys[p]];
        var zone   = player && player.zone;
        if (zone && result[zone]) {
          result[zone].playerCount++;
        }
      }
    }

    // Count NPCs per zone
    if (gameState.npcs) {
      var npcKeys = Object.keys(gameState.npcs);
      for (var n = 0; n < npcKeys.length; n++) {
        var npc  = gameState.npcs[npcKeys[n]];
        var nZone = npc && npc.zone;
        if (nZone && result[nZone]) {
          result[nZone].npcCount++;
        }
      }
    }

    // Count active events per zone
    if (gameState.events && gameState.events.active) {
      var evs   = gameState.events.active;
      var cTick = gameState.tick || 0;
      for (var e = 0; e < evs.length; e++) {
        var ev = evs[e];
        if (cTick >= ev.startTick && cTick < ev.startTick + ev.duration) {
          if (ev.zone && result[ev.zone]) {
            result[ev.zone].activeEvents++;
          }
        }
      }
    }

    // Attach weather per zone
    if (gameState.weather && gameState.weather.zones) {
      for (var z = 0; z < ZONE_IDS.length; z++) {
        var zkey = ZONE_IDS[z];
        var w    = gameState.weather.zones[zkey];
        if (w) {
          result[zkey].weather     = w.type;
          result[zkey].temperature = w.temperature;
        }
      }
    }

    return result;
  }

  /**
   * Returns an HTML grid of all 8 zones with activity summaries.
   * currentZone (optional) is highlighted in gold.
   */
  function formatZoneActivityGrid(activity, currentZone) {
    var html = '<div class="dw-zone-grid">';
    for (var i = 0; i < ZONE_IDS.length; i++) {
      var zid      = ZONE_IDS[i];
      var data     = (activity && activity[zid]) || { playerCount: 0, npcCount: 0, activeEvents: 0, weather: null, temperature: null };
      var name     = ZONE_NAMES[zid] || zid;
      var isCurrent = zid === currentZone;
      var cls      = 'dw-zone-cell' + (isCurrent ? ' dw-zone-current' : '');
      var wIcon    = data.weather ? getWeatherIcon(data.weather) : '';
      var tempStr  = data.temperature !== null && data.temperature !== undefined ? data.temperature + 'C' : '--';

      html += '<div class="' + cls + '" data-zone="' + zid + '">' +
        '<div class="dw-zone-name">' + _escHtml(name) + '</div>' +
        '<div class="dw-zone-stats">' +
          '<span class="dw-zone-players">' + data.playerCount + ' players</span>' +
          '<span class="dw-zone-npcs">'    + data.npcCount    + ' npcs</span>' +
        '</div>' +
        '<div class="dw-zone-events">' + data.activeEvents + ' event(s)</div>' +
        '<div class="dw-zone-weather">' + wIcon + ' ' + (data.weather || '--') + ' ' + tempStr + '</div>' +
      '</div>';
    }
    html += '</div>';
    return html;
  }

  // â”€â”€ Panel DOM builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Creates the full WORLD STATUS panel DOM element (div).
   * Works in Node.js (returns a plain object) and in browser (returns HTMLElement).
   */
  function createWorldPanel() {
    // Build lightweight panel descriptor that works both in Node and browser
    var panel = _createElement('div', 'dw-world-panel');

    // â”€â”€ Clock & Calendar section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var clockSection = _createElement('section', 'dw-section dw-section-clock');
    clockSection.innerHTML =
      '<h3 class="dw-section-title">Clock and Calendar</h3>' +
      '<div class="dw-clock-display">' +
        '<span class="dw-time-display">00:00</span>' +
        '<span class="dw-phase-display">Night</span>' +
      '</div>' +
      '<div class="dw-calendar-display">' +
        '<span class="dw-day-display">Day 1</span>' +
        '<span class="dw-season-display">Spring</span>' +
      '</div>';

    // â”€â”€ Weather section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var weatherSection = _createElement('section', 'dw-section dw-section-weather');
    weatherSection.innerHTML =
      '<h3 class="dw-section-title">Weather</h3>' +
      '<div class="dw-weather-container">' +
        '<p class="dw-weather-loading">Loading weather data...</p>' +
      '</div>';

    // â”€â”€ World Events section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var eventsSection = _createElement('section', 'dw-section dw-section-events');
    eventsSection.innerHTML =
      '<h3 class="dw-section-title">World Events</h3>' +
      '<div class="dw-events-active">' +
        '<h4>Active Events</h4>' +
        '<p class="dw-no-events">No active events.</p>' +
      '</div>' +
      '<div class="dw-events-upcoming">' +
        '<h4>Upcoming Events</h4>' +
        '<p class="dw-no-events">No upcoming events.</p>' +
      '</div>';

    // â”€â”€ Zone Activity section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var zonesSection = _createElement('section', 'dw-section dw-section-zones');
    zonesSection.innerHTML =
      '<h3 class="dw-section-title">Zone Activity</h3>' +
      '<div class="dw-zone-activity-container">' +
        formatZoneActivityGrid(null, null) +
      '</div>';

    // â”€â”€ World News section â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var newsSection = _createElement('section', 'dw-section dw-section-news');
    newsSection.innerHTML =
      '<h3 class="dw-section-title">World News</h3>' +
      formatNewsFeed([]);

    _appendChild(panel, clockSection);
    _appendChild(panel, weatherSection);
    _appendChild(panel, eventsSection);
    _appendChild(panel, zonesSection);
    _appendChild(panel, newsSection);

    return panel;
  }

  // â”€â”€ Small DOM helpers (isomorphic) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _createElement(tag, className) {
    if (typeof document !== 'undefined') {
      var el = document.createElement(tag);
      if (className) el.className = className;
      return el;
    }
    // Minimal Node.js shim
    return {
      tagName:   tag.toUpperCase(),
      className: className || '',
      innerHTML: '',
      children:  [],
      setAttribute: function(k, v) { this[k] = v; },
      appendChild:  function(child) { this.children.push(child); }
    };
  }

  function _appendChild(parent, child) {
    if (typeof parent.appendChild === 'function') {
      parent.appendChild(child);
    }
  }

  // â”€â”€ Misc helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function _escHtml(str) {
    if (typeof str !== 'string') return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function _formatTimestamp(ts) {
    if (!ts) return '--';
    var d = new Date(ts);
    if (isNaN(d.getTime())) return String(ts);
    var h = d.getHours(),   m = d.getMinutes();
    var D = d.getDate(),    M = d.getMonth() + 1, Y = d.getFullYear();
    return (D < 10 ? '0' : '') + D + '/' + (M < 10 ? '0' : '') + M + '/' + Y +
           ' ' + (h < 10 ? '0' : '') + h + ':' + (m < 10 ? '0' : '') + m;
  }

  // â”€â”€ Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  exports.ZONE_IDS         = ZONE_IDS;
  exports.ZONE_NAMES       = ZONE_NAMES;
  exports.EVENT_TYPES      = EVENT_TYPES;

  // Time
  exports.createWorldTime     = createWorldTime;
  exports.advanceTime         = advanceTime;
  exports.getTimeOfDay        = getTimeOfDay;
  exports.getPhaseOfDay       = getPhaseOfDay;
  exports.formatGameTime      = formatGameTime;
  exports.getDayNumber        = getDayNumber;
  exports.getSeason           = getSeason;
  exports.getSeasonProgress   = getSeasonProgress;
  exports.formatTimeDisplay   = formatTimeDisplay;

  // Weather
  exports.createWeatherState  = createWeatherState;
  exports.generateWeather     = generateWeather;
  exports.getWeatherForZone   = getWeatherForZone;
  exports.updateAllWeather    = updateAllWeather;
  exports.getTemperature      = getTemperature;
  exports.formatWeatherDisplay = formatWeatherDisplay;
  exports.getWeatherIcon      = getWeatherIcon;
  exports.getWeatherEffect    = getWeatherEffect;

  // Events
  exports.createEventState    = createEventState;
  exports.generateEvent       = generateEvent;
  exports.getActiveEvents     = getActiveEvents;
  exports.getUpcomingEvents   = getUpcomingEvents;
  exports.joinEvent           = joinEvent;
  exports.completeEvent       = completeEvent;
  exports.formatEventCard     = formatEventCard;

  // News
  exports.createNewsState     = createNewsState;
  exports.addNewsEntry        = addNewsEntry;
  exports.getRecentNews       = getRecentNews;
  exports.formatNewsFeed      = formatNewsFeed;
  exports.generateAutoNews    = generateAutoNews;

  // Zone activity
  exports.getZoneActivity         = getZoneActivity;
  exports.formatZoneActivityGrid  = formatZoneActivityGrid;

  // Panel
  exports.createWorldPanel        = createWorldPanel;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardWorld = {}));


// dashboard_main.js
// dashboard_main.js
/**
 * dashboard_main.js - Integration module for ZION dashboard mode
 *
 * Wires all dashboard panels together and provides the main game loop
 * for UI-only mode. Connects DashboardZones, DashboardNPCs,
 * DashboardInventory, DashboardEconomy, DashboardQuests, DashboardSocial,
 * DashboardGames, DashboardWorld, and DashboardCSS into a cohesive experience.
 *
 * UMD module: window.DashboardMain (browser) or module.exports (Node.js)
 * ES5 compatible - uses var declarations
 */
(function(exports) {
  'use strict';

  // =========================================================================
  // VERSION
  // =========================================================================

  var VERSION = '1.0.0';

  // =========================================================================
  // CONSTANTS
  // =========================================================================

  var STORAGE_KEY = 'zion_dashboard_state';
  var AUTO_SAVE_INTERVAL = 30;  // ticks
  var WEATHER_UPDATE_INTERVAL = 60;  // ticks
  var TICK_INTERVAL_MS = 1000;  // milliseconds

  var ZONE_NAMES = {
    nexus:     'The Nexus',
    gardens:   'The Gardens',
    athenaeum: 'The Athenaeum',
    studio:    'The Studio',
    wilds:     'The Wilds',
    agora:     'The Agora',
    commons:   'The Commons',
    arena:     'The Arena'
  };

  var ZONE_DESCRIPTIONS = {
    nexus:     'a crystalline plaza at the heart of ZION, where all paths converge',
    gardens:   'cultivated gardens of extraordinary beauty, tended by devoted citizens',
    athenaeum: 'grand marble halls filled with the accumulated knowledge of civilization',
    studio:    'artisan workshops alive with creative work and the smell of craft',
    wilds:     'untamed wilderness stretching beyond the settled lands',
    agora:     'a bustling market square where commerce and community interweave',
    commons:   'open building grounds where citizens raise the structures of tomorrow',
    arena:     'combat grounds where skill is tested and glory sought'
  };

  var WEATHER_TYPES = [
    'clear', 'cloudy', 'misty', 'rainy', 'stormy', 'windy', 'foggy', 'sunny'
  ];

  var WEATHER_ADJECTIVES = {
    clear:  'clear',
    cloudy: 'overcast',
    misty:  'misty',
    rainy:  'rainy',
    stormy: 'stormy',
    windy:  'windswept',
    foggy:  'fog-laden',
    sunny:  'sun-drenched'
  };

  var DAY_PARTS = [
    { name: 'Dawn',      startTick: 0,    endTick: 100 },
    { name: 'Morning',   startTick: 100,  endTick: 300 },
    { name: 'Afternoon', startTick: 300,  endTick: 700 },
    { name: 'Evening',   startTick: 700,  endTick: 1000 },
    { name: 'Night',     startTick: 1000, endTick: 1200 }
  ];

  // =========================================================================
  // ZONE RESOURCES TABLE
  // =========================================================================

  var ZONE_RESOURCES = {
    nexus: {
      common:   ['stone'],
      uncommon: ['crystal'],
      rare:     []
    },
    gardens: {
      common:   ['herbs', 'feather'],
      uncommon: ['honey', 'silk'],
      rare:     []
    },
    athenaeum: {
      common:   ['feather'],
      uncommon: ['herbs'],
      rare:     ['scroll']
    },
    studio: {
      common:   ['clay'],
      uncommon: ['silk'],
      rare:     ['pigment']
    },
    wilds: {
      common:   ['wood', 'stone'],
      uncommon: ['iron_ore'],
      rare:     ['crystal']
    },
    agora: {
      common:   ['herbs'],
      uncommon: ['gold_dust'],
      rare:     []
    },
    commons: {
      common:   ['wood', 'feather'],
      uncommon: ['herbs'],
      rare:     []
    },
    arena: {
      common:   ['stone'],
      uncommon: ['iron_ore'],
      rare:     ['gold_dust']
    }
  };

  // =========================================================================
  // KEYBOARD SHORTCUTS
  // =========================================================================

  var KEY_SHORTCUTS = {
    'i': { action: 'toggle_panel', panel: 'inventory',  label: 'Inventory' },
    'c': { action: 'toggle_panel', panel: 'crafting',   label: 'Crafting' },
    'j': { action: 'toggle_panel', panel: 'quests',     label: 'Quests' },
    'g': { action: 'toggle_panel', panel: 'guild',      label: 'Guild' },
    'm': { action: 'toggle_panel', panel: 'map',        label: 'Map' },
    's': { action: 'toggle_panel', panel: 'social',     label: 'Social' },
    'e': { action: 'toggle_panel', panel: 'economy',    label: 'Economy' },
    'n': { action: 'toggle_panel', panel: 'npcs',       label: 'NPCs' },
    'w': { action: 'toggle_panel', panel: 'world',      label: 'World Status' },
    'z': { action: 'toggle_panel', panel: 'zones',      label: 'Zones' },
    'f': { action: 'action',       type:  'cast_line',  label: 'Fish' },
    'r': { action: 'action',       type:  'gather_resource', label: 'Gather' },
    'F5': { action: 'save_game',   label: 'Save Game' }
  };

  // =========================================================================
  // WORLD EVENTS CATALOG
  // =========================================================================

  var WORLD_EVENTS = [
    { id: 'market_day',    name: 'Market Day',       zone: 'agora',     tickInterval: 240, duration: 60,  reward: { spark: 20 } },
    { id: 'harvest_feast', name: 'Harvest Feast',    zone: 'gardens',   tickInterval: 360, duration: 90,  reward: { spark: 30, item: 'herbs' } },
    { id: 'tournament',    name: 'Grand Tournament', zone: 'arena',     tickInterval: 480, duration: 120, reward: { spark: 50 } },
    { id: 'lecture',       name: 'Public Lecture',   zone: 'athenaeum', tickInterval: 200, duration: 45,  reward: { xp: 25 } },
    { id: 'art_show',      name: 'Art Exhibition',   zone: 'studio',    tickInterval: 300, duration: 60,  reward: { reputation: 10 } }
  ];

  // =========================================================================
  // MODULE STATE
  // =========================================================================

  var _tickHandle = null;
  var _gameState = null;
  var _tickCount = 0;
  var _initialized = false;

  // =========================================================================
  // SAFE HELPERS
  // =========================================================================

  function _safeLocalStorage(action, key, value) {
    try {
      if (typeof localStorage === 'undefined') { return null; }
      if (action === 'get') { return localStorage.getItem(key); }
      if (action === 'set') { localStorage.setItem(key, value); return true; }
      if (action === 'remove') { localStorage.removeItem(key); return true; }
    } catch (e) {
      return null;
    }
    return null;
  }

  function _randomItem(arr) {
    if (!arr || arr.length === 0) { return null; }
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function _randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function _escapeHtml(str) {
    if (typeof str !== 'string') { return String(str || ''); }
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  function _deepClone(obj) {
    try {
      return JSON.parse(JSON.stringify(obj));
    } catch (e) {
      return obj;
    }
  }

  // =========================================================================
  // OPTIONAL MODULE ACCESSORS (guarded)
  // =========================================================================

  function _getDashboardZones() {
    if (typeof DashboardZones !== 'undefined') { return DashboardZones; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_zones.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardNPCs() {
    if (typeof DashboardNPCs !== 'undefined') { return DashboardNPCs; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_npcs.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardInventory() {
    if (typeof DashboardInventory !== 'undefined') { return DashboardInventory; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_inventory.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardEconomy() {
    if (typeof DashboardEconomy !== 'undefined') { return DashboardEconomy; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_economy.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardQuests() {
    if (typeof DashboardQuests !== 'undefined') { return DashboardQuests; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_quests.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardSocial() {
    if (typeof DashboardSocial !== 'undefined') { return DashboardSocial; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_social.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardGames() {
    if (typeof DashboardGames !== 'undefined') { return DashboardGames; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_games.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardWorld() {
    if (typeof DashboardWorld !== 'undefined') { return DashboardWorld; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_world.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboardCSS() {
    if (typeof DashboardCSS !== 'undefined') { return DashboardCSS; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard_css.js'); } catch (e) {}
    }
    return null;
  }

  function _getDashboard() {
    if (typeof Dashboard !== 'undefined') { return Dashboard; }
    if (typeof module !== 'undefined' && module.exports) {
      try { return require('./dashboard.js'); } catch (e) {}
    }
    return null;
  }

  // =========================================================================
  // GAME STATE
  // =========================================================================

  /**
   * createGameState(playerName)
   * Creates a complete, fresh game state for dashboard mode.
   */
  function createGameState(playerName) {
    var name = (typeof playerName === 'string' && playerName.trim()) ? playerName.trim() : 'Citizen';
    var id = 'player_' + name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + Date.now();

    return {
      player: {
        id: id,
        name: name,
        zone: 'nexus',
        level: 1,
        xp: 0,
        spark: 100,
        reputation: {
          nexus:     0,
          gardens:   0,
          athenaeum: 0,
          studio:    0,
          wilds:     0,
          agora:     0,
          commons:   0,
          arena:     0
        },
        lastGatherTick: -1
      },
      inventory: {
        items: {},
        equipped: {},
        skills: {}
      },
      economy: {
        balances: {},
        transactions: [],
        listings: []
      },
      quests: {
        active: {},
        completed: {},
        progress: {}
      },
      social: {
        chat: {
          global: [],
          zone:   [],
          guild:  []
        },
        guild: null,
        friends: []
      },
      world: {
        time: {
          tick:      0,
          dayLength: 1200
        },
        weather: {
          current: 'clear',
          nextChange: WEATHER_UPDATE_INTERVAL
        },
        events:  [],
        news:    []
      },
      achievements: {},
      settings: {
        layout:        'full',
        theme:         'dark',
        notifications: true
      },
      _meta: {
        version:   VERSION,
        createdAt: Date.now(),
        savedAt:   null
      }
    };
  }

  // =========================================================================
  // DASHBOARD TICK
  // =========================================================================

  /**
   * dashboardTick(state, deltaTime)
   * Called every second. Advances world time, updates weather, checks events,
   * updates NPCs, auto-saves, generates news.
   * Returns updated state.
   */
  function dashboardTick(state, deltaTime) {
    if (!state || !state.world) { return state; }

    // Advance world time
    var DashboardWorld = _getDashboardWorld();
    if (DashboardWorld && typeof DashboardWorld.advanceTime === 'function') {
      var newTime = DashboardWorld.advanceTime(state.world.time, 1);
      if (newTime) { state.world.time = newTime; }
    } else {
      state.world.time.tick = (state.world.time.tick || 0) + 1;
    }
    var tick = state.world.time.tick;

    // Update weather periodically
    if (tick % WEATHER_UPDATE_INTERVAL === 0) {
      state = _updateWeather(state);
    }

    // Check for event triggers
    state = _checkEventTriggers(state, tick);

    // Update NPC states
    var DashboardNPCs = _getDashboardNPCs();
    if (DashboardNPCs && typeof DashboardNPCs.tickNPCs === 'function') {
      DashboardNPCs.tickNPCs(state);
    }

    // Auto-save every 30 ticks
    if (tick % AUTO_SAVE_INTERVAL === 0) {
      saveState(state);
    }

    // Generate news from state changes
    state = _generateNews(state, tick);

    return state;
  }

  function _updateWeather(state) {
    var weather = state.world.weather;
    var oldWeather = weather.current;
    // Pick a new weather type (different from current when possible)
    var choices = WEATHER_TYPES.filter(function(w) { return w !== oldWeather; });
    weather.current = _randomItem(choices) || oldWeather;
    weather.nextChange = WEATHER_UPDATE_INTERVAL;

    // Add news item about weather change
    if (state.world.news) {
      state.world.news.unshift({
        type:    'weather',
        message: 'The weather has shifted. The skies are now ' + (WEATHER_ADJECTIVES[weather.current] || weather.current) + '.',
        tick:    state.world.time.tick
      });
      // Keep news list manageable
      if (state.world.news.length > 50) {
        state.world.news = state.world.news.slice(0, 50);
      }
    }

    return state;
  }

  function _checkEventTriggers(state, tick) {
    if (!state.world.events) { state.world.events = []; }

    // Start events at their scheduled intervals
    for (var i = 0; i < WORLD_EVENTS.length; i++) {
      var evDef = WORLD_EVENTS[i];
      if (tick > 0 && tick % evDef.tickInterval === 0) {
        // Check if not already active
        var alreadyActive = false;
        for (var j = 0; j < state.world.events.length; j++) {
          if (state.world.events[j].id === evDef.id && state.world.events[j].active) {
            alreadyActive = true;
            break;
          }
        }
        if (!alreadyActive) {
          state.world.events.push({
            id:       evDef.id,
            name:     evDef.name,
            zone:     evDef.zone,
            startTick: tick,
            endTick:  tick + evDef.duration,
            active:   true,
            reward:   evDef.reward
          });
          if (state.world.news) {
            state.world.news.unshift({
              type:    'event',
              message: evDef.name + ' has begun in ' + (ZONE_NAMES[evDef.zone] || evDef.zone) + '!',
              tick:    tick
            });
          }
        }
      }
    }

    // Expire old events
    for (var k = 0; k < state.world.events.length; k++) {
      var ev = state.world.events[k];
      if (ev.active && tick >= ev.endTick) {
        ev.active = false;
      }
    }

    // Prune inactive events older than 200 ticks
    state.world.events = state.world.events.filter(function(ev) {
      return ev.active || (tick - ev.endTick < 200);
    });

    return state;
  }

  function _generateNews(state, tick) {
    if (!state.world.news) { state.world.news = []; }

    // Every 50 ticks, generate a flavor news item
    if (tick > 0 && tick % 50 === 0) {
      var zone = _randomItem(Object.keys(ZONE_NAMES));
      var items = [
        'Citizens gather in ' + ZONE_NAMES[zone] + ' to share stories.',
        'A traveling merchant arrives at ' + ZONE_NAMES[zone] + '.',
        'Rumors circulate of rare resources spotted near ' + ZONE_NAMES[zone] + '.',
        'The Council meets to discuss new policies.',
        'Trade routes between zones grow more active.'
      ];
      var msg = _randomItem(items);
      if (msg) {
        state.world.news.unshift({ type: 'flavor', message: msg, tick: tick });
      }
      if (state.world.news.length > 50) {
        state.world.news = state.world.news.slice(0, 50);
      }
    }

    return state;
  }

  // =========================================================================
  // ACTION HANDLER
  // =========================================================================

  /**
   * handleDashboardAction(state, action)
   * Central action handler. Returns { state, result, notifications }.
   */
  function handleDashboardAction(state, action) {
    if (!state) {
      return { state: state, result: { success: false, error: 'No state' }, notifications: [] };
    }
    if (!action || !action.type) {
      return { state: state, result: { success: false, error: 'No action type' }, notifications: [] };
    }

    var result = { success: false, error: 'Unknown action: ' + action.type };

    switch (action.type) {

      case 'travel':
        result = _actionTravel(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'talk_npc':
        result = _actionTalkNPC(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'buy_item':
        result = _actionBuyItem(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'craft':
        result = _actionCraft(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'equip':
        result = _actionEquip(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'sell_item':
        result = _actionSellItem(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'accept_quest':
        result = _actionAcceptQuest(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'send_chat':
        result = _actionSendChat(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'create_guild':
        result = _actionCreateGuild(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'join_event':
        result = _actionJoinEvent(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'cast_line':
        result = _actionCastLine(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'play_card':
        result = _actionPlayCard(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'enter_dungeon':
        result = _actionEnterDungeon(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'gaze_stars':
        result = _actionGazeStars(state, action);
        if (result.success) { state = result.state || state; }
        break;

      case 'gather_resource':
        result = gatherResource(state, action.resourceType);
        if (result.success) { state = result.state || state; }
        break;

      case 'save_game':
        result = _actionSaveGame(state);
        break;

      case 'load_game':
        result = _actionLoadGame(state);
        if (result.success && result.state) { state = result.state; }
        break;

      default:
        result = { success: false, error: 'Unknown action: ' + action.type };
        break;
    }

    var notifications = processNotifications(state, result);
    return { state: state, result: result, notifications: notifications };
  }

  // ---- Individual Action Implementations ----

  function _actionTravel(state, action) {
    var zone = action.zone;
    if (!zone) { return { success: false, error: 'No zone specified' }; }
    if (!ZONE_NAMES[zone]) { return { success: false, error: 'Unknown zone: ' + zone }; }
    if (!state.player) { return { success: false, error: 'No player in state' }; }

    var prevZone = state.player.zone;
    state.player.zone = zone;

    // Delegate to DashboardZones if available
    var DashboardZones = _getDashboardZones();
    if (DashboardZones && typeof DashboardZones.navigateToZone === 'function') {
      var navResult = DashboardZones.navigateToZone(zone, state);
      if (navResult && navResult.error) {
        state.player.zone = prevZone;
        return { success: false, error: navResult.error };
      }
    }

    // Gain reputation in the destination zone
    if (state.player.reputation && state.player.reputation[zone] !== undefined) {
      state.player.reputation[zone] += 1;
    }

    // Award XP for exploration
    state.player.xp = (state.player.xp || 0) + 5;

    // Zone-change news
    if (state.world && state.world.news) {
      state.world.news.unshift({
        type:    'travel',
        message: state.player.name + ' travels from ' + (ZONE_NAMES[prevZone] || prevZone) + ' to ' + (ZONE_NAMES[zone] || zone) + '.',
        tick:    state.world.time.tick
      });
    }

    return {
      success:  true,
      state:    state,
      fromZone: prevZone,
      toZone:   zone,
      message:  'You arrive at ' + ZONE_NAMES[zone] + '.'
    };
  }

  function _actionTalkNPC(state, action) {
    var npcId = action.npcId;
    if (!npcId) { return { success: false, error: 'No NPC id specified' }; }

    var dialogue = 'Hello, traveler. Welcome to ' + (ZONE_NAMES[state.player.zone] || 'ZION') + '.';

    // Delegate to DashboardNPCs if available
    var DashboardNPCs = _getDashboardNPCs();
    if (DashboardNPCs && typeof DashboardNPCs.talkToNPC === 'function') {
      var npcResult = DashboardNPCs.talkToNPC(npcId, state);
      if (npcResult && npcResult.dialogue) { dialogue = npcResult.dialogue; }
    }

    // Small XP gain for socializing
    state.player.xp = (state.player.xp || 0) + 2;

    return { success: true, state: state, npcId: npcId, dialogue: dialogue };
  }

  function _actionBuyItem(state, action) {
    var npcId  = action.npcId;
    var itemId = action.itemId;
    if (!itemId) { return { success: false, error: 'No item specified' }; }

    var cost = 10; // default cost

    // Use game state directly for economy operations
    if ((state.player.spark || 0) < cost) {
      return { success: false, error: 'Not enough Spark' };
    }
    state.player.spark = (state.player.spark || 0) - cost;

    // Add item to inventory
    state.inventory.items[itemId] = (state.inventory.items[itemId] || 0) + 1;

    return { success: true, state: state, itemId: itemId, cost: cost, message: 'Purchased ' + itemId + '.' };
  }

  function _actionCraft(state, action) {
    var recipeId = action.recipeId;
    if (!recipeId) { return { success: false, error: 'No recipe specified' }; }

    // Craft: award the item directly on game state
    state.inventory.items[recipeId] = (state.inventory.items[recipeId] || 0) + 1;
    state.player.xp = (state.player.xp || 0) + 10;

    return { success: true, state: state, recipeId: recipeId, message: 'Crafted ' + recipeId + '.' };
  }

  function _actionEquip(state, action) {
    var itemId = action.itemId;
    if (!itemId) { return { success: false, error: 'No item specified' }; }
    if (!state.inventory.items[itemId] || state.inventory.items[itemId] < 1) {
      return { success: false, error: 'Item not in inventory: ' + itemId };
    }

    // Equip item directly on game state
    state.inventory.equipped[itemId] = true;
    return { success: true, state: state, itemId: itemId, message: 'Equipped ' + itemId + '.' };
  }

  function _actionSellItem(state, action) {
    var itemId   = action.itemId;
    var quantity = action.quantity || 1;
    if (!itemId) { return { success: false, error: 'No item specified' }; }
    if (!state.inventory.items[itemId] || state.inventory.items[itemId] < quantity) {
      return { success: false, error: 'Not enough ' + itemId + ' in inventory' };
    }

    var salePrice = 8; // stub price per item

    // Credit sale proceeds directly on game state
    state.player.spark = (state.player.spark || 0) + salePrice * quantity;

    state.inventory.items[itemId] -= quantity;
    if (state.inventory.items[itemId] <= 0) {
      delete state.inventory.items[itemId];
    }

    return {
      success:  true,
      state:    state,
      itemId:   itemId,
      quantity: quantity,
      earned:   salePrice * quantity,
      message:  'Sold ' + quantity + 'x ' + itemId + ' for ' + (salePrice * quantity) + ' Spark.'
    };
  }

  function _actionAcceptQuest(state, action) {
    var questId = action.questId;
    if (!questId) { return { success: false, error: 'No quest id specified' }; }

    // Stub quest acceptance (primary path â€” works with any questId)
    if (state.quests.active[questId]) {
      return { success: false, error: 'Quest already active: ' + questId };
    }
    if (state.quests.completed[questId]) {
      return { success: false, error: 'Quest already completed: ' + questId };
    }

    // Try DashboardQuests if available (only for catalog quests)
    var DashboardQuests = _getDashboardQuests();
    if (DashboardQuests && typeof DashboardQuests.acceptQuest === 'function') {
      try {
        var questState = state.quests;
        var questResult = DashboardQuests.acceptQuest(questState, questId);
        if (questResult && questResult.success) {
          state.quests = questResult.state || state.quests;
          return { success: true, state: state, questId: questId, message: 'Quest accepted: ' + questId };
        }
        // Quest not in catalog or already done â€” fall through to stub
      } catch (e) { /* fall through to stub */ }
    }

    // Stub: accept any questId
    state.quests.active[questId] = { acceptedAt: Date.now(), progress: [] };

    return { success: true, state: state, questId: questId, message: 'Quest accepted: ' + questId };
  }

  function _actionSendChat(state, action) {
    var channel = action.channel || 'global';
    var text    = action.text;
    if (!text || !text.trim()) { return { success: false, error: 'No message text' }; }

    var message = {
      from:      state.player.name,
      text:      text.trim(),
      channel:   channel,
      timestamp: Date.now(),
      tick:      (state.world && state.world.time) ? state.world.time.tick : 0
    };

    // Store in local state (primary path â€” always works)
    if (!state.social.chat) { state.social.chat = {}; }
    if (!state.social.chat[channel]) { state.social.chat[channel] = []; }
    state.social.chat[channel].push(message);
    if (state.social.chat[channel].length > 200) {
      state.social.chat[channel] = state.social.chat[channel].slice(-200);
    }

    // Optionally delegate to DashboardSocial if it uses a compatible state format
    var DashboardSocial = _getDashboardSocial();
    if (DashboardSocial && typeof DashboardSocial.addMessage === 'function') {
      try {
        // DashboardSocial.addMessage expects state.channels â€” attempt only if available
        var chatState = state.social.chat || {};
        if (chatState.channels) {
          DashboardSocial.addMessage(chatState, channel, message);
        }
      } catch (e) { /* ignore module-specific errors */ }
    }

    return { success: true, state: state, message: message };
  }

  function _actionCreateGuild(state, action) {
    var name  = action.name;
    var motto = action.motto || '';
    if (!name || !name.trim()) { return { success: false, error: 'No guild name' }; }
    if (state.social.guild) { return { success: false, error: 'Already in a guild' }; }

    // Stub guild creation (primary path â€” uses our game state format)
    state.social.guild = {
      name:      name.trim(),
      motto:     motto,
      founder:   state.player.id,
      members:   [state.player.id],
      createdAt: Date.now()
    };

    // Optionally delegate to DashboardSocial if it uses a compatible state format
    var DashboardSocial = _getDashboardSocial();
    if (DashboardSocial && typeof DashboardSocial.createGuild === 'function') {
      try {
        // DashboardSocial.createGuild expects a state with guilds array and playerGuild map
        if (state.social.guilds && state.social.playerGuild) {
          var guildResult = DashboardSocial.createGuild(state.social, name.trim(), state.player.id, motto);
          if (guildResult && guildResult.success) {
            state.social = guildResult.state || state.social;
          }
        }
      } catch (e) { /* ignore module-specific errors */ }
    }

    return { success: true, state: state, guild: state.social.guild, message: 'Guild "' + name + '" created!' };
  }

  function _actionJoinEvent(state, action) {
    var eventId = action.eventId;
    if (!eventId) { return { success: false, error: 'No event id' }; }

    // Find the event in the world
    var worldEvent = null;
    if (state.world && state.world.events) {
      for (var i = 0; i < state.world.events.length; i++) {
        if (state.world.events[i].id === eventId && state.world.events[i].active) {
          worldEvent = state.world.events[i];
          break;
        }
      }
    }

    if (!worldEvent) { return { success: false, error: 'Event not active: ' + eventId }; }

    // Award event reward
    var reward = worldEvent.reward || {};
    if (reward.spark) {
      state.player.spark = (state.player.spark || 0) + reward.spark;
    }
    if (reward.xp) {
      state.player.xp = (state.player.xp || 0) + reward.xp;
    }
    if (reward.item) {
      state.inventory.items[reward.item] = (state.inventory.items[reward.item] || 0) + 1;
    }

    return {
      success:  true,
      state:    state,
      eventId:  eventId,
      reward:   reward,
      message:  'You joined ' + worldEvent.name + '!'
    };
  }

  function _actionCastLine(state, action) {
    // Fishing mini-game stub
    var catchChance = Math.random();
    var fish = null;
    var spark = 0;

    if (catchChance < 0.4) {
      // No catch
      return { success: true, state: state, caught: false, message: 'Nothing bit. Try again.' };
    } else if (catchChance < 0.75) {
      fish = 'common_fish';
      spark = 5;
    } else if (catchChance < 0.95) {
      fish = 'silver_fish';
      spark = 15;
    } else {
      fish = 'golden_fish';
      spark = 50;
    }

    if (fish) {
      state.inventory.items[fish] = (state.inventory.items[fish] || 0) + 1;
      state.player.spark = (state.player.spark || 0) + spark;
      state.player.xp    = (state.player.xp    || 0) + 3;
    }

    // Delegate to DashboardGames if available
    var DashboardGames = _getDashboardGames();
    if (DashboardGames && typeof DashboardGames.resolveFishing === 'function') {
      var fishResult = DashboardGames.resolveFishing(state, catchChance);
      if (fishResult && fishResult.state) { state = fishResult.state; }
    }

    return {
      success: true,
      state:   state,
      caught:  !!fish,
      fish:    fish,
      spark:   spark,
      message: fish ? 'You caught a ' + fish + '! (+' + spark + ' Spark)' : 'Nothing bit.'
    };
  }

  function _actionPlayCard(state, action) {
    var cardIndex = action.cardIndex;
    if (cardIndex === undefined || cardIndex === null) {
      return { success: false, error: 'No card index' };
    }

    // Try to delegate to DashboardGames if compatible result
    var DashboardGames = _getDashboardGames();
    if (DashboardGames && typeof DashboardGames.playCard === 'function') {
      try {
        var cardResult = DashboardGames.playCard(state, cardIndex);
        if (cardResult && cardResult.outcome) {
          if (cardResult.state) { state = cardResult.state; }
          return { success: true, state: state, cardIndex: cardIndex, outcome: cardResult.outcome, result: cardResult };
        }
        // Module returned without outcome â€” fall through to stub
      } catch (e) { /* fall through to stub */ }
    }

    // Stub card play
    var outcome = Math.random() < 0.5 ? 'win' : 'lose';
    var sparkChange = outcome === 'win' ? 10 : -5;
    state.player.spark = Math.max(0, (state.player.spark || 0) + sparkChange);
    state.player.xp    = (state.player.xp || 0) + 2;

    return {
      success:     true,
      state:       state,
      cardIndex:   cardIndex,
      outcome:     outcome,
      sparkChange: sparkChange,
      message:     'Card played. You ' + outcome + '! (' + (sparkChange > 0 ? '+' : '') + sparkChange + ' Spark)'
    };
  }

  function _actionEnterDungeon(state, action) {
    var difficulty = action.difficulty || 'normal';
    var validDifficulties = ['easy', 'normal', 'hard', 'legendary'];
    if (validDifficulties.indexOf(difficulty) === -1) {
      return { success: false, error: 'Invalid difficulty: ' + difficulty };
    }

    // Delegate to DashboardGames if available
    var DashboardGames = _getDashboardGames();
    if (DashboardGames && typeof DashboardGames.enterDungeon === 'function') {
      var dungeonResult = DashboardGames.enterDungeon(state, difficulty);
      if (dungeonResult && dungeonResult.state) { state = dungeonResult.state; }
      return { success: true, state: state, difficulty: difficulty, result: dungeonResult };
    }

    // Stub dungeon
    var successChance = { easy: 0.9, normal: 0.7, hard: 0.5, legendary: 0.25 }[difficulty];
    var won = Math.random() < successChance;
    var sparkReward = { easy: 20, normal: 40, hard: 80, legendary: 200 }[difficulty];
    var xpReward    = { easy: 15, normal: 30, hard: 60, legendary: 150 }[difficulty];

    if (won) {
      state.player.spark = (state.player.spark || 0) + sparkReward;
      state.player.xp    = (state.player.xp    || 0) + xpReward;
    }

    return {
      success:    true,
      state:      state,
      difficulty: difficulty,
      won:        won,
      reward:     won ? { spark: sparkReward, xp: xpReward } : null,
      message:    won
        ? 'Dungeon cleared! Rewards: +' + sparkReward + ' Spark, +' + xpReward + ' XP.'
        : 'Dungeon failed. Better luck next time.'
    };
  }

  function _actionGazeStars(state, action) {
    // Stargazing gives small XP and occasionally reveals constellation info
    var xpGain = _randomInt(3, 8);
    state.player.xp = (state.player.xp || 0) + xpGain;

    var messages = [
      'You study the constellations above. The stars are clear tonight.',
      'A shooting star crosses the sky. You make a wish.',
      'The heavens wheel overhead, reminding you of the passage of time.',
      'You trace the outline of a familiar constellation, its myth echoing in memory.'
    ];
    var message = _randomItem(messages);

    // Delegate to DashboardGames if available
    var DashboardGames = _getDashboardGames();
    if (DashboardGames && typeof DashboardGames.gazeStars === 'function') {
      var starResult = DashboardGames.gazeStars(state);
      if (starResult && starResult.state) { state = starResult.state; }
    }

    return { success: true, state: state, xpGain: xpGain, message: message };
  }

  function _actionSaveGame(state) {
    var saved = saveState(state);
    return { success: saved, message: saved ? 'Game saved.' : 'Save failed.' };
  }

  function _actionLoadGame(state) {
    var loaded = loadState();
    if (!loaded) { return { success: false, error: 'No saved game found.' }; }
    return { success: true, state: loaded, message: 'Game loaded.' };
  }

  // =========================================================================
  // RESOURCE GATHERING
  // =========================================================================

  /**
   * gatherResource(state, resourceType)
   * Gather a resource based on current zone.
   * Returns { success, item, quantity, message, state }
   */
  function gatherResource(state, resourceType) {
    if (!state || !state.player) {
      return { success: false, error: 'No state', message: 'Cannot gather: no state.' };
    }

    var zone = state.player.zone || 'nexus';
    var currentTick = (state.world && state.world.time && state.world.time.tick) || 0;
    var lastGather  = state.player.lastGatherTick || -1;

    // Cooldown check: must wait at least 1 tick between gathers
    if (lastGather >= 0 && currentTick <= lastGather) {
      return {
        success: false,
        error:   'Gather cooldown active',
        message: 'You need to rest before gathering again.'
      };
    }

    var zoneRes = ZONE_RESOURCES[zone];
    if (!zoneRes) {
      return { success: false, error: 'No resources in zone: ' + zone, message: 'Nothing to gather here.' };
    }

    // Determine rarity tier
    var roll = Math.random();
    var tier, pool;

    if (roll < 0.70) {
      tier = 'common';
      pool = zoneRes.common || [];
    } else if (roll < 0.90) {
      tier = 'uncommon';
      pool = zoneRes.uncommon || [];
    } else {
      tier = 'rare';
      pool = zoneRes.rare || [];
    }

    // Fallback to common if pool is empty
    if (!pool || pool.length === 0) {
      tier = 'common';
      pool = zoneRes.common || [];
    }

    // If resourceType is specified, check if it is available in this zone
    if (resourceType) {
      var allAvailable = (zoneRes.common || []).concat(zoneRes.uncommon || []).concat(zoneRes.rare || []);
      if (allAvailable.indexOf(resourceType) === -1) {
        return {
          success: false,
          error:   resourceType + ' not available in ' + zone,
          message: resourceType + ' cannot be found in ' + (ZONE_NAMES[zone] || zone) + '.'
        };
      }
      pool = [resourceType];
      // Determine tier for the specified resource
      if ((zoneRes.rare || []).indexOf(resourceType) !== -1) { tier = 'rare'; }
      else if ((zoneRes.uncommon || []).indexOf(resourceType) !== -1) { tier = 'uncommon'; }
      else { tier = 'common'; }
    }

    if (!pool || pool.length === 0) {
      return { success: false, error: 'No resources available', message: 'Nothing found.' };
    }

    var item     = _randomItem(pool);
    var quantity = (tier === 'rare') ? 1 : (tier === 'uncommon' ? _randomInt(1, 2) : _randomInt(1, 3));

    // Add to inventory
    state.inventory.items[item] = (state.inventory.items[item] || 0) + quantity;

    // Update cooldown
    state.player.lastGatherTick = currentTick;

    // Small XP gain
    var xpMap = { common: 2, uncommon: 5, rare: 15 };
    state.player.xp = (state.player.xp || 0) + (xpMap[tier] || 2);

    var tierLabel = tier.charAt(0).toUpperCase() + tier.slice(1);
    var message = 'You gather ' + quantity + 'x ' + item + ' [' + tierLabel + '].';

    return {
      success:  true,
      state:    state,
      item:     item,
      quantity: quantity,
      tier:     tier,
      message:  message
    };
  }

  // =========================================================================
  // STATE PERSISTENCE
  // =========================================================================

  /**
   * saveState(state)
   * Save full game state to localStorage.
   * Returns success boolean.
   */
  function saveState(state) {
    if (!state) { return false; }
    try {
      var clone = _deepClone(state);
      clone._meta = clone._meta || {};
      clone._meta.savedAt = Date.now();
      var json = JSON.stringify(clone);
      var result = _safeLocalStorage('set', STORAGE_KEY, json);
      return result === true;
    } catch (e) {
      return false;
    }
  }

  /**
   * loadState()
   * Load game state from localStorage.
   * Returns state or null.
   */
  function loadState() {
    try {
      var raw = _safeLocalStorage('get', STORAGE_KEY);
      if (!raw) { return null; }
      var parsed = JSON.parse(raw);
      // Basic sanity check
      if (!parsed || !parsed.player || !parsed.world) { return null; }
      return parsed;
    } catch (e) {
      return null;
    }
  }

  /**
   * resetState(playerName)
   * Reset to a fresh game state.
   * Returns new state.
   */
  function resetState(playerName) {
    _safeLocalStorage('remove', STORAGE_KEY);
    return createGameState(playerName);
  }

  // =========================================================================
  // AVAILABLE ACTIONS
  // =========================================================================

  /**
   * getAvailableActions(state)
   * Returns list of actions available based on current state.
   */
  function getAvailableActions(state) {
    if (!state || !state.player) { return []; }

    var actions = [];
    var zone = state.player.zone || 'nexus';

    // Travel is always available
    var allZones = Object.keys(ZONE_NAMES);
    for (var i = 0; i < allZones.length; i++) {
      if (allZones[i] !== zone) {
        actions.push({ type: 'travel', zone: allZones[i], label: 'Travel to ' + ZONE_NAMES[allZones[i]] });
      }
    }

    // Talk NPC is always available
    actions.push({ type: 'talk_npc', npcId: 'npc_001', label: 'Talk to a citizen' });

    // Gather resource based on zone resources
    var zoneRes = ZONE_RESOURCES[zone];
    if (zoneRes) {
      var allResources = (zoneRes.common || []).concat(zoneRes.uncommon || []).concat(zoneRes.rare || []);
      // Deduplicate
      var seen = {};
      for (var j = 0; j < allResources.length; j++) {
        if (!seen[allResources[j]]) {
          seen[allResources[j]] = true;
          actions.push({ type: 'gather_resource', resourceType: allResources[j], label: 'Gather ' + allResources[j] });
        }
      }
    }

    // Fishing â€” in wilds, gardens, commons
    if (zone === 'wilds' || zone === 'gardens' || zone === 'commons') {
      actions.push({ type: 'cast_line', label: 'Go fishing' });
    }

    // Dungeon â€” in arena
    if (zone === 'arena') {
      actions.push({ type: 'enter_dungeon', difficulty: 'normal', label: 'Enter dungeon (normal)' });
      actions.push({ type: 'enter_dungeon', difficulty: 'hard',   label: 'Enter dungeon (hard)' });
    }

    // Card game â€” in agora or nexus
    if (zone === 'agora' || zone === 'nexus') {
      actions.push({ type: 'play_card', cardIndex: 0, label: 'Play a card' });
    }

    // Stargazing â€” everywhere at night
    var tick        = (state.world && state.world.time && state.world.time.tick) || 0;
    var dayLength   = (state.world && state.world.time && state.world.time.dayLength) || 1200;
    var dayProgress = tick % dayLength;
    if (dayProgress >= 700) {
      actions.push({ type: 'gaze_stars', label: 'Gaze at the stars' });
    }

    // Chat â€” always available
    actions.push({ type: 'send_chat', channel: 'global', text: '', label: 'Send chat message' });

    // Quest acceptance â€” if no active quests or fewer than 3
    var activeQuestCount = Object.keys(state.quests.active).length;
    if (activeQuestCount < 3) {
      actions.push({ type: 'accept_quest', questId: 'explore_all_zones', label: 'Accept a quest' });
    }

    // Save/Load
    actions.push({ type: 'save_game', label: 'Save game' });
    actions.push({ type: 'load_game', label: 'Load game' });

    return actions;
  }

  // =========================================================================
  // NOTIFICATIONS
  // =========================================================================

  /**
   * processNotifications(state, result)
   * Convert action results into notification messages.
   * Returns array of notification objects.
   */
  function processNotifications(state, result) {
    if (!result) { return []; }

    var notifications = [];

    if (!result.success) {
      notifications.push({
        type:    'error',
        message: result.error || 'Action failed.',
        tick:    state && state.world ? state.world.time.tick : 0
      });
      return notifications;
    }

    // Success notification with appropriate type
    if (result.message) {
      var type = 'success';

      // Classify notification type
      if (result.error)                                        { type = 'error'; }
      else if (result.won === false)                           { type = 'warning'; }
      else if (result.caught === false)                        { type = 'info'; }
      else if (result.type === 'weather' || result.flavor)     { type = 'info'; }

      notifications.push({
        type:    type,
        message: result.message,
        tick:    state && state.world ? state.world.time.tick : 0
      });
    }

    // Achievement notifications
    if (result.achievement) {
      notifications.push({
        type:    'achievement',
        message: 'Achievement unlocked: ' + result.achievement,
        tick:    state && state.world ? state.world.time.tick : 0
      });
    }

    // Level-up check
    if (state && state.player) {
      var xpThreshold = state.player.level * 100;
      if (state.player.xp >= xpThreshold) {
        state.player.level += 1;
        state.player.xp -= xpThreshold;
        notifications.push({
          type:    'achievement',
          message: 'Level up! You are now level ' + state.player.level + '.',
          tick:    state && state.world ? state.world.time.tick : 0
        });
      }
    }

    // Reward notifications
    if (result.reward) {
      var reward = result.reward;
      var parts  = [];
      if (reward.spark) { parts.push('+' + reward.spark + ' Spark'); }
      if (reward.xp)    { parts.push('+' + reward.xp + ' XP'); }
      if (reward.item)  { parts.push(reward.item + ' obtained'); }
      if (parts.length > 0) {
        notifications.push({
          type:    'info',
          message: 'Rewards: ' + parts.join(', '),
          tick:    state && state.world ? state.world.time.tick : 0
        });
      }
    }

    return notifications;
  }

  // =========================================================================
  // KEYBOARD SHORTCUTS
  // =========================================================================

  /**
   * handleKeyPress(state, key)
   * Map keyboard shortcuts to dashboard actions.
   * Returns updated state (and may trigger side effects).
   */
  function handleKeyPress(state, key) {
    if (!state || !key) { return state; }

    var shortcut = KEY_SHORTCUTS[key];
    if (!shortcut) { return state; }

    if (shortcut.action === 'toggle_panel') {
      // Delegate to Dashboard if available
      var Dashboard = _getDashboard();
      if (Dashboard && typeof Dashboard.togglePanel === 'function') {
        Dashboard.togglePanel(shortcut.panel + '-panel');
      }
    } else if (shortcut.action === 'action') {
      var actionResult = handleDashboardAction(state, { type: shortcut.type });
      state = actionResult.state || state;
    } else if (shortcut.action === 'save_game') {
      saveState(state);
    }

    return state;
  }

  // =========================================================================
  // PLAYER SUMMARY
  // =========================================================================

  /**
   * getPlayerSummary(state)
   * Returns text summary of player status.
   */
  function getPlayerSummary(state) {
    if (!state || !state.player) { return 'Unknown citizen'; }

    var p    = state.player;
    var zone = ZONE_NAMES[p.zone] || p.zone || 'Unknown';

    var activeQuests = Object.keys(state.quests ? state.quests.active : {}).length;
    var questPart    = activeQuests === 1
      ? '1 active quest'
      : activeQuests + ' active quests';

    var tick      = (state.world && state.world.time && state.world.time.tick) || 0;
    var dayLength = (state.world && state.world.time && state.world.time.dayLength) || 1200;
    var day       = Math.floor(tick / dayLength) + 1;

    // Day part
    var dayProgress = tick % dayLength;
    var dayPartName = 'Night';
    for (var i = 0; i < DAY_PARTS.length; i++) {
      var dp = DAY_PARTS[i];
      if (dayProgress >= dp.startTick && dayProgress < dp.endTick) {
        dayPartName = dp.name;
        break;
      }
    }

    return 'Level ' + (p.level || 1) + ' Citizen | ' +
           zone + ' | ' +
           (p.spark || 0) + ' Spark | ' +
           questPart + ' | ' +
           'Day ' + day + ', ' + dayPartName;
  }

  // =========================================================================
  // WELCOME MESSAGE
  // =========================================================================

  /**
   * formatWelcomeMessage(playerName, zone)
   * Returns welcome HTML for first visit or zone change.
   */
  function formatWelcomeMessage(playerName, zone) {
    var name     = _escapeHtml(playerName || 'Citizen');
    var zoneKey  = zone || 'nexus';
    var zoneName = ZONE_NAMES[zoneKey] || zoneKey;
    var zoneDesc = ZONE_DESCRIPTIONS[zoneKey] || 'a part of ZION';

    // Fake a weather type for the welcome
    var weather     = _randomItem(WEATHER_TYPES) || 'clear';
    var weatherAdj  = WEATHER_ADJECTIVES[weather] || weather;

    return '<div class="zion-welcome">' +
      '<p>Welcome to ZION, <strong>' + name + '</strong>.</p>' +
      '<p>You stand in <em>' + zoneName + '</em>, ' + zoneDesc + '.</p>' +
      '<p>The ' + weatherAdj + ' sky stretches above you.</p>' +
      '</div>';
  }

  // =========================================================================
  // DASHBOARD SHELL LAYOUT
  // =========================================================================

  function _createShellLayout(container) {
    if (typeof document === 'undefined') { return null; }

    // Header
    var header = document.createElement('div');
    header.id = 'zion-dashboard-header';
    header.style.cssText = [
      'background:#0D1321',
      'border-bottom:1px solid #1E3A5F',
      'padding:8px 16px',
      'display:flex',
      'align-items:center',
      'justify-content:space-between',
      'flex-shrink:0'
    ].join(';');
    header.innerHTML = '<span style="color:#DAA520;font-weight:bold;font-family:monospace">ZION</span>' +
      '<span id="zion-player-summary" style="color:#8A9AB0;font-size:12px;font-family:monospace"></span>';

    // Main grid
    var main = document.createElement('div');
    main.id = 'zion-dashboard-main';
    main.style.cssText = [
      'flex:1',
      'overflow-y:auto',
      'padding:12px',
      'display:grid',
      'grid-template-columns:repeat(auto-fill, minmax(340px, 1fr))',
      'gap:12px',
      'align-content:start'
    ].join(';');

    // Footer tabs
    var footer = document.createElement('div');
    footer.id = 'zion-dashboard-footer';
    footer.style.cssText = [
      'background:#161F2E',
      'border-top:1px solid #1E3A5F',
      'padding:6px 12px',
      'display:flex',
      'gap:8px',
      'flex-shrink:0',
      'overflow-x:auto'
    ].join(';');

    var shortcuts = [
      '[I] Inventory', '[C] Craft', '[J] Quests',
      '[G] Guild', '[M] Map', '[S] Social', '[E] Economy', '[F5] Save'
    ];
    footer.innerHTML = shortcuts.map(function(s) {
      return '<span style="color:#4A5A70;font-size:11px;font-family:monospace">' + s + '</span>';
    }).join('');

    // Wrapper
    var wrapper = document.createElement('div');
    wrapper.id = 'zion-dashboard-wrapper';
    wrapper.style.cssText = [
      'display:flex',
      'flex-direction:column',
      'height:100%',
      'background:#0A0E1A',
      'color:#E8E0D8',
      'font-family:monospace',
      'overflow:hidden'
    ].join(';');

    wrapper.appendChild(header);
    wrapper.appendChild(main);
    wrapper.appendChild(footer);

    container.innerHTML = '';
    container.appendChild(wrapper);

    return { header: header, main: main, footer: footer, wrapper: wrapper };
  }

  // =========================================================================
  // INIT DASHBOARD MODE
  // =========================================================================

  /**
   * initDashboardMode(container)
   * Master initialization for dashboard mode.
   * Returns the dashboard state object.
   */
  function initDashboardMode(container) {
    if (_initialized) {
      return _gameState;
    }

    // 1. Inject dashboard CSS
    var DashboardCSS = _getDashboardCSS();
    if (DashboardCSS && typeof DashboardCSS.inject === 'function') {
      DashboardCSS.inject();
    }

    // 2. Create dashboard shell layout (only in browser)
    var shell = null;
    if (container && typeof document !== 'undefined') {
      shell = _createShellLayout(container);
    }

    // 3. Load or create game state
    var savedState = loadState();
    _gameState = savedState || createGameState('Citizen');

    // 4. Initialize all panel modules
    var panelContainer = (shell && shell.main) ? shell.main : container;

    var DashboardZones     = _getDashboardZones();
    var DashboardNPCs      = _getDashboardNPCs();
    var DashboardInventory = _getDashboardInventory();
    var DashboardEconomy   = _getDashboardEconomy();
    var DashboardQuests    = _getDashboardQuests();
    var DashboardSocial    = _getDashboardSocial();
    var DashboardGames     = _getDashboardGames();
    var DashboardWorld     = _getDashboardWorld();

    if (panelContainer && typeof document !== 'undefined') {
      if (DashboardZones && typeof DashboardZones.createZonePanel === 'function') {
        var zonePanel = DashboardZones.createZonePanel(_gameState.player.zone);
        if (zonePanel && zonePanel.nodeType) { panelContainer.appendChild(zonePanel); }
      }
      if (DashboardNPCs && typeof DashboardNPCs.createNPCPanel === 'function') {
        var npcPanel = DashboardNPCs.createNPCPanel(_gameState.player.zone);
        if (npcPanel && npcPanel.nodeType) { panelContainer.appendChild(npcPanel); }
      }
      if (DashboardInventory && typeof DashboardInventory.createInventoryPanel === 'function') {
        var invPanel = DashboardInventory.createInventoryPanel(_gameState);
        if (invPanel && invPanel.nodeType) { panelContainer.appendChild(invPanel); }
      }
      if (DashboardEconomy && typeof DashboardEconomy.createEconomyPanel === 'function') {
        var ecoPanel = DashboardEconomy.createEconomyPanel(_gameState);
        if (ecoPanel && ecoPanel.nodeType) { panelContainer.appendChild(ecoPanel); }
      }
      if (DashboardQuests && typeof DashboardQuests.createQuestPanel === 'function') {
        var questPanel = DashboardQuests.createQuestPanel(_gameState.quests);
        if (questPanel && questPanel.nodeType) { panelContainer.appendChild(questPanel); }
      }
      if (DashboardSocial && typeof DashboardSocial.createSocialPanel === 'function') {
        var socialPanel = DashboardSocial.createSocialPanel(_gameState.social);
        if (socialPanel && socialPanel.nodeType) { panelContainer.appendChild(socialPanel); }
      }
      if (DashboardGames && typeof DashboardGames.createGamesPanel === 'function') {
        var gamesPanel = DashboardGames.createGamesPanel(_gameState);
        if (gamesPanel && gamesPanel.nodeType) { panelContainer.appendChild(gamesPanel); }
      }
      if (DashboardWorld && typeof DashboardWorld.createWorldPanel === 'function') {
        var worldPanel = DashboardWorld.createWorldPanel(_gameState.world);
        if (worldPanel && worldPanel.nodeType) { panelContainer.appendChild(worldPanel); }
      }
    }

    // 5. Set up keyboard shortcuts (browser only)
    if (typeof document !== 'undefined') {
      document.addEventListener('keydown', function(e) {
        var key = e.key || e.keyCode;
        _gameState = handleKeyPress(_gameState, key);
        _updatePlayerSummary(shell);
      });
    }

    // 6. Start dashboard game loop
    _startGameLoop(shell);

    // 7. Show welcome message / zone info
    if (typeof document !== 'undefined' && panelContainer) {
      var welcome = document.createElement('div');
      welcome.style.cssText = 'padding:12px;grid-column:1/-1';
      welcome.innerHTML = formatWelcomeMessage(_gameState.player.name, _gameState.player.zone);
      panelContainer.insertBefore(welcome, panelContainer.firstChild);
    }

    // 8. Update player summary
    _updatePlayerSummary(shell);

    _initialized = true;
    return _gameState;
  }

  function _updatePlayerSummary(shell) {
    if (!shell || !_gameState) { return; }
    if (typeof document === 'undefined') { return; }
    var el = document.getElementById('zion-player-summary');
    if (el) { el.textContent = getPlayerSummary(_gameState); }
  }

  function _startGameLoop(shell) {
    if (_tickHandle) { clearInterval(_tickHandle); }
    _tickHandle = setInterval(function() {
      if (!_gameState) { return; }
      _gameState = dashboardTick(_gameState, 1);
      _tickCount += 1;
      _updatePlayerSummary(shell);
    }, TICK_INTERVAL_MS);
  }

  // =========================================================================
  // VERSION
  // =========================================================================

  /**
   * getDashboardVersion()
   * Returns the module version string.
   */
  function getDashboardVersion() {
    return VERSION;
  }

  // =========================================================================
  // INTERNAL RESET (for testing)
  // =========================================================================

  function _reset() {
    if (_tickHandle) {
      clearInterval(_tickHandle);
      _tickHandle = null;
    }
    _gameState   = null;
    _tickCount   = 0;
    _initialized = false;
  }

  // =========================================================================
  // EXPORTS
  // =========================================================================

  exports.VERSION              = VERSION;
  exports.ZONE_RESOURCES       = ZONE_RESOURCES;
  exports.ZONE_NAMES           = ZONE_NAMES;
  exports.ZONE_DESCRIPTIONS    = ZONE_DESCRIPTIONS;
  exports.WEATHER_TYPES        = WEATHER_TYPES;
  exports.KEY_SHORTCUTS        = KEY_SHORTCUTS;
  exports.WORLD_EVENTS         = WORLD_EVENTS;

  // Core init
  exports.initDashboardMode    = initDashboardMode;
  exports.getDashboardVersion  = getDashboardVersion;

  // Game state
  exports.createGameState      = createGameState;
  exports.dashboardTick        = dashboardTick;

  // Actions
  exports.handleDashboardAction = handleDashboardAction;
  exports.gatherResource        = gatherResource;

  // Persistence
  exports.saveState             = saveState;
  exports.loadState             = loadState;
  exports.resetState            = resetState;

  // Queries
  exports.getAvailableActions   = getAvailableActions;
  exports.processNotifications  = processNotifications;
  exports.handleKeyPress        = handleKeyPress;
  exports.getPlayerSummary      = getPlayerSummary;
  exports.formatWelcomeMessage  = formatWelcomeMessage;

  // Testing helpers
  exports._reset                = _reset;
  exports._updateWeather        = _updateWeather;
  exports._checkEventTriggers   = _checkEventTriggers;

})(typeof module !== 'undefined' ? module.exports : (window.DashboardMain = {}));


// main.js
(function(exports) {
  // Main entry point and game loop orchestrator

  // Import references (browser globals or require)
  const Protocol = typeof require !== 'undefined' ? require('./protocol') : window.Protocol;
  const State = typeof require !== 'undefined' ? require('./state') : window.State;
  const Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
  const Economy = typeof require !== 'undefined' ? require('./economy') : window.Economy;
  const Inventory = typeof require !== 'undefined' ? require('./inventory') : window.Inventory;
  const Trading = typeof require !== 'undefined' ? require('./trading') : window.Trading;
  const Intentions = typeof require !== 'undefined' ? require('./intentions') : window.Intentions;
  const Social = typeof require !== 'undefined' ? require('./social') : window.Social;
  const Creation = typeof require !== 'undefined' ? require('./creation') : window.Creation;
  const Competition = typeof require !== 'undefined' ? require('./competition') : window.Competition;
  const Exploration = typeof require !== 'undefined' ? require('./exploration') : window.Exploration;
  const Physical = typeof require !== 'undefined' ? require('./physical') : window.Physical;
  const Auth = typeof require !== 'undefined' ? require('./auth') : window.Auth;
  const Network = typeof require !== 'undefined' ? require('./network') : window.Network;
  const World = typeof require !== 'undefined' ? require('./world') : window.World;
  const Input = typeof require !== 'undefined' ? require('./input') : window.Input;
  const HUD = typeof require !== 'undefined' ? require('./hud') : window.HUD;
  const XR = typeof require !== 'undefined' ? require('./xr') : window.XR;
  const Audio = typeof require !== 'undefined' ? require('./audio') : window.Audio;
  const NPCs = typeof require !== 'undefined' ? require('./npcs') : window.NPCs;
  const Quests = typeof require !== 'undefined' ? require('./quests') : window.Quests;
  const Mentoring = typeof require !== 'undefined' ? require('./mentoring') : window.Mentoring;
  const Guilds = typeof require !== 'undefined' ? require('./guilds') : window.Guilds;
  const Seasons = typeof require !== 'undefined' ? require('./seasons') : window.Seasons;
  const Pets = typeof require !== 'undefined' ? require('./pets') : window.Pets;
  const ApiBridge = typeof require !== 'undefined' ? require('./api_bridge') : window.ApiBridge;
  const FastTravel = typeof require !== 'undefined' ? require('./fast_travel') : window.FastTravel;
  const WeatherFX = typeof require !== 'undefined' ? require('./weather_fx') : window.WeatherFX;
  const Progression = typeof require !== 'undefined' ? require('./progression') : window.Progression;
  const NpcReputation = typeof require !== 'undefined' ? require('./npc_reputation') : window.NpcReputation;
  const Loot = typeof require !== 'undefined' ? require('./loot') : window.Loot;
  const GuildProgression = typeof require !== 'undefined' ? require('./guild_progression') : window.GuildProgression;
  const DailyChallenges = typeof require !== 'undefined' ? require('./daily_challenges') : window.DailyChallenges;
  const Apprenticeship = typeof require !== 'undefined' ? require('./apprenticeship') : window.Apprenticeship;
  const EventVoting = typeof require !== 'undefined' ? require('./event_voting') : window.EventVoting;
  const HousingSocial = typeof require !== 'undefined' ? require('./housing_social') : window.HousingSocial;
  const Prestige = typeof require !== 'undefined' ? require('./prestige') : window.Prestige;
  const MentorshipMarket = typeof require !== 'undefined' ? require('./mentorship_market') : window.MentorshipMarket;

  // Embedded soul data (replaced at bundle time)
  var EMBEDDED_SOULS = [{"id": "agent_001", "name": "Iris Skyhigh", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_002", "name": "Meadow Mindclear", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_003", "name": "Luna Pathfinder", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_004", "name": "Luna Rootdeep", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_005", "name": "Storm Windwalker", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_006", "name": "Wren Voicetrue", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_007", "name": "Delta Hopefast", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_008", "name": "Luna Songsmith", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_009", "name": "Wren Starseed", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_010", "name": "Lyra Thoughtdeep", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_011", "name": "Wren Moonwhisper", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_012", "name": "Frost Rootdeep", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_013", "name": "River Soulbright", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_014", "name": "Felix Shadowmender", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_015", "name": "Phoenix Sunweaver", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_016", "name": "Luna Rootdeep", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_017", "name": "Vale Truthseeker", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_018", "name": "Ezra Willstrong", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_019", "name": "Nova Dreamweaver", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_020", "name": "Echo Thoughtdeep", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_021", "name": "Vale Waterborn", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_022", "name": "Vale Spaceborn", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_023", "name": "Echo Thoughtdeep", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_024", "name": "Nova Hopefast", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_025", "name": "Ridge Handsteady", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_026", "name": "Frost Voicetrue", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_027", "name": "Drift Shadowmender", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_028", "name": "Vale Pathfinder", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_029", "name": "Haven Handsteady", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_030", "name": "River Mindclear", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_031", "name": "Meadow Lightbringer", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_032", "name": "Fern Spaceborn", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_033", "name": "Sage Starseed", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_034", "name": "Blaze Wordkeeper", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_035", "name": "Orion Sunweaver", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_036", "name": "Breeze Mindclear", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_037", "name": "Ash Thoughtdeep", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_038", "name": "Mira Truthseeker", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_039", "name": "Sage Skyhigh", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_040", "name": "Luna Stonecarver", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_041", "name": "Phoenix Waterborn", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_042", "name": "Luna Moonwhisper", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_043", "name": "Haven Handsteady", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_044", "name": "Jasper Shadowmender", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_045", "name": "Phoenix Spiritfree", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_046", "name": "Cedar Timewalker", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_047", "name": "Grove Skyhigh", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_048", "name": "Haven Heartstrong", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_049", "name": "Fern Handsteady", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_050", "name": "Stella Windwalker", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_051", "name": "Cliff Songsmith", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_052", "name": "River Footswift", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_053", "name": "Ezra Dreamweaver", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_054", "name": "Opal Moonwhisper", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_055", "name": "Sol Mindclear", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_056", "name": "Aria Waterborn", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_057", "name": "Dawn Mindclear", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_058", "name": "Opal Earthshaper", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_059", "name": "Ezra Spaceborn", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_060", "name": "Iris Timewalker", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_061", "name": "River Pathfinder", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_062", "name": "Storm Sunweaver", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_063", "name": "Coral Songsmith", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_064", "name": "Reef Hopefast", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_065", "name": "Storm Skyhigh", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_066", "name": "Jasper Moonwhisper", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_067", "name": "Willow Heartstrong", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_068", "name": "Blaze Stonecarver", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_069", "name": "Meadow Firekeeper", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_070", "name": "Echo Soulbright", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_071", "name": "Coral Mindclear", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_072", "name": "Grove Pathfinder", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_073", "name": "Ridge Heartstrong", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_074", "name": "Flint Rootdeep", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_075", "name": "Cedar Spiritfree", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_076", "name": "Zion Truthseeker", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_077", "name": "Quill Dreamweaver", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_078", "name": "Orion Footswift", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_079", "name": "Drift Sunweaver", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_080", "name": "Ash Sunweaver", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_081", "name": "Haven Timewalker", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_082", "name": "Aria Spaceborn", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_083", "name": "Phoenix Thoughtdeep", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_084", "name": "Cedar Wordkeeper", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_085", "name": "Cliff Sunweaver", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_086", "name": "Sage Handsteady", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_087", "name": "Rain Dreamweaver", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_088", "name": "Flint Heartstrong", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_089", "name": "Cliff Heartstrong", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_090", "name": "Echo Footswift", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}, {"id": "agent_091", "name": "Reef Spiritfree", "archetype": "gardener", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Welcome to the gardens! The soil is rich today. Take your time here \u2014 there's no rush."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "tend", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_092", "name": "Vale Spiritfree", "archetype": "builder", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Careful around here \u2014 we're building something great. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "build", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_093", "name": "River Mindclear", "archetype": "storyteller", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Ah, a new face! Come, I have tales to tell."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "narrate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "say", "params": {"text": "Long ago, when Zion was young..."}}, "priority": 2, "ttl": 86400, "cooldown": 90, "max_fires": 100}]}, {"id": "agent_094", "name": "River Soulbright", "archetype": "merchant", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Looking to trade? I've got the finest goods in Zion."}}, "priority": 5, "ttl": 86400, "cooldown": 25, "max_fires": 100}, {"id": "hawk", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "say", "params": {"text": "Fresh supplies, fair prices!"}}, "priority": 2, "ttl": 86400, "cooldown": 120, "max_fires": 100}]}, {"id": "agent_095", "name": "Ezra Spiritfree", "archetype": "explorer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Have you been to the far edges? There's so much to see. There's always something new to discover!"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "wander", "trigger": {"condition": "timer", "params": {"interval_seconds": 45}}, "action": {"type": "emote", "params": {"emoteType": "wave"}}, "priority": 3, "ttl": 86400, "cooldown": 45, "max_fires": 200}]}, {"id": "agent_096", "name": "Kai Thoughtdeep", "archetype": "teacher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Seeking knowledge? I can teach you the ways of Zion. Experience is the greatest teacher."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "lecture", "trigger": {"condition": "timer", "params": {"interval_seconds": 180}}, "action": {"type": "say", "params": {"text": "Remember: in Zion, every action ripples outward."}}, "priority": 2, "ttl": 86400, "cooldown": 180, "max_fires": 100}]}, {"id": "agent_097", "name": "Cliff Hopefast", "archetype": "musician", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Listen... can you hear the music of Zion?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "perform", "trigger": {"condition": "timer", "params": {"interval_seconds": 60}}, "action": {"type": "emote", "params": {"emoteType": "dance"}}, "priority": 3, "ttl": 86400, "cooldown": 60, "max_fires": 200}]}, {"id": "agent_098", "name": "Blaze Hopefast", "archetype": "healer", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Peace, traveler. Rest here if you need healing."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "meditate", "trigger": {"condition": "timer", "params": {"interval_seconds": 90}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 90, "max_fires": 200}]}, {"id": "agent_099", "name": "North Songsmith", "archetype": "philosopher", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "What brings you here, seeker? Every journey has meaning."}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "ponder", "trigger": {"condition": "timer", "params": {"interval_seconds": 120}}, "action": {"type": "emote", "params": {"emoteType": "meditate"}}, "priority": 3, "ttl": 86400, "cooldown": 120, "max_fires": 200}]}, {"id": "agent_100", "name": "Ezra Dreamweaver", "archetype": "artist", "intentions": [{"id": "greet", "trigger": {"condition": "player_nearby", "params": {"distance_lt": 12}}, "action": {"type": "say", "params": {"text": "Beauty is everywhere \u2014 you just have to look. Inspiration strikes in the strangest places, doesn't it?"}}, "priority": 5, "ttl": 86400, "cooldown": 30, "max_fires": 100}, {"id": "create", "trigger": {"condition": "timer", "params": {"interval_seconds": 75}}, "action": {"type": "emote", "params": {"emoteType": "work"}}, "priority": 3, "ttl": 86400, "cooldown": 75, "max_fires": 200}]}];

  // Game state
  let gameState = null;
  let sceneContext = null;
  let messageQueue = [];
  let isRunning = false;
  let lastTimestamp = 0;
  let worldTime = 0; // Minutes in 24-hour cycle (0-1440)
  let currentZone = 'nexus';
  let currentWeather = 'clear';
  let npcIntentionIndex = 0; // Throttle: which NPC to evaluate next
  let localPlayer = null;
  let playStartTime = 0;
  let lastBreakReminder = 0;
  let footstepTimer = 0;
  let currentTimePeriod = 'morning';  // tracks dawn/morning/midday/afternoon/evening/night
  let cameraYaw = 0;       // horizontal camera orbit angle (radians)
  let cameraPitch = 0.35;  // vertical tilt (0 = flat, higher = more top-down)
  let cameraDistance = 18;  // distance from player
  let isDragging = false;
  let lastMouseX = 0, lastMouseY = 0;
  let playerInventory = null;
  let economyLedger = null;
  let raycaster = null;
  let simCrmState = null;
  let lastSimCrmTick = 0;
  var SIM_CRM_TICK_INTERVAL = 45000; // 45 seconds between CRM ticks
  let npcUpdateFrame = 0;
  let visitedZones = { nexus: true }; // Track discovered zones for piano accents

  // Performance tracking
  let frameCount = 0;
  let fpsFrameTimes = [];
  let currentFPS = 60;
  let showDebug = false; // Set to true to show FPS counter

  // Play time tracking
  let playTimeSeconds = 0;
  let recentActivities = [];

  // Auto-save tracking
  let lastAutoSave = 0;
  let AUTO_SAVE_INTERVAL = 60000; // 60 seconds

  // Secret discovery tracking
  let lastSecretCheck = 0;
  let SECRET_CHECK_INTERVAL = 2000; // Check every 2 seconds

  // Economic event tracking
  let currentEconomicEvent = null;
  let lastEventCheck = 0;

  // Seasonal event tracking
  let currentSeason = null;
  let lastSeasonCheck = 0;
  let SEASON_CHECK_INTERVAL = 60000; // Check season every 60s

  // Pet tracking
  let lastPetUpdate = 0;
  let PET_UPDATE_INTERVAL = 30000; // Update pet every 30s

  // Race checkpoint tracking
  var lastRaceCheck = 0;
  var RACE_CHECK_INTERVAL = 500; // Check every 500ms

  // Fishing state
  let isFishing = false;

  // World events tracking
  var worldEvents = {
    shootingStars: {
      lastSpawn: 0,
      interval: 30000, // 30-90 seconds in milliseconds
      active: []
    },
    resourceBloom: {
      lastSpawn: 0,
      interval: 600000, // 10-15 minutes in milliseconds
      activeZone: null,
      startTime: 0,
      duration: 120000 // 2 minutes
    },
    auroraBorealis: {
      lastSpawn: 0,
      interval: 1200000, // 20+ minutes in milliseconds
      active: false,
      mesh: null,
      startTime: 0,
      duration: 240000, // 3-5 minutes
      animTime: 0
    },
    wanderingMerchant: {
      lastSpawn: 0,
      interval: 900000, // 15 minutes in milliseconds
      activeZone: null
    },
    fireflySwarm: {
      lastSpawn: 0,
      interval: 1800000, // 30 minutes
      active: false,
      startTime: 0,
      duration: 180000 // 3 minutes
    }
  };

  // Warmth tracking (GPS-based outdoor play bonus)
  let gpsHistory = [];
  let gpsWatchId = null;
  let lastWarmthUpdate = 0;

  // Platform detection
  let platform = 'desktop';

  // Camera shake system
  var cameraShake = { intensity: 0, duration: 0, elapsed: 0, active: false };

  /**
   * Trigger camera shake effect
   * @param {number} intensity - Shake strength (0.1-1.0)
   * @param {number} duration - Duration in seconds
   */
  function triggerCameraShake(intensity, duration) {
    cameraShake.intensity = intensity;
    cameraShake.duration = duration;
    cameraShake.elapsed = 0;
    cameraShake.active = true;
  }

  function startZoneCinematic() {
    if (!sceneContext || !localPlayer) return;
    var cam = sceneContext.camera;
    cinematicCamera.active = true;
    cinematicCamera.elapsed = 0;
    cinematicCamera.startPos = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
    cinematicCamera.peakPos = {
      x: cam.position.x,
      y: cam.position.y + 15,
      z: cam.position.z - 8
    };
    // Look toward zone center
    var Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
    var zoneInfo = Zones && Zones.ZONES ? Zones.ZONES[currentZone] : null;
    var lookX = zoneInfo ? zoneInfo.cx : localPlayer.position.x;
    var lookZ = zoneInfo ? zoneInfo.cz : localPlayer.position.z;
    var lookY = (World && World.getTerrainHeight) ? World.getTerrainHeight(lookX, lookZ) + 1.5 : 1.5;
    cinematicCamera.startLookAt = {
      x: localPlayer.position.x,
      y: ((World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0) + 1.5,
      z: localPlayer.position.z
    };
    cinematicCamera.targetLookAt = { x: lookX, y: lookY, z: lookZ };
  }

  function updateCinematicCamera(deltaTime) {
    if (!cinematicCamera.active || !sceneContext) return false;
    cinematicCamera.elapsed += deltaTime;
    var progress = Math.min(cinematicCamera.elapsed / cinematicCamera.duration, 1.0);
    // Smooth ease-in-out
    var ease = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    var cam = sceneContext.camera;
    var sp = cinematicCamera.startPos;
    var pp = cinematicCamera.peakPos;

    if (progress < 0.5) {
      // First half: ease up to peak
      var t = ease * 2; // 0 to 1 over first half
      cam.position.x = sp.x + (pp.x - sp.x) * t;
      cam.position.y = sp.y + (pp.y - sp.y) * t;
      cam.position.z = sp.z + (pp.z - sp.z) * t;
    } else {
      // Second half: ease back down to where normal orbit would be
      var inputDist = Input && Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;
      var inputOrbit = Input && Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;
      var terrY = (World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0;
      var normalX = localPlayer.position.x + Math.sin(inputOrbit) * Math.cos(cameraPitch) * inputDist;
      var normalY = terrY + Math.sin(cameraPitch) * inputDist + 2;
      var normalZ = localPlayer.position.z + Math.cos(inputOrbit) * Math.cos(cameraPitch) * inputDist;
      var t2 = (ease - 0.5) * 2; // 0 to 1 over second half
      cam.position.x = pp.x + (normalX - pp.x) * t2;
      cam.position.y = pp.y + (normalY - pp.y) * t2;
      cam.position.z = pp.z + (normalZ - pp.z) * t2;
    }

    // Blend lookAt from start to target
    var sl = cinematicCamera.startLookAt;
    var tl = cinematicCamera.targetLookAt;
    var lookBlend = Math.min(ease * 1.5, 1.0); // Look moves faster than camera
    cam.lookAt(
      sl.x + (tl.x - sl.x) * lookBlend,
      sl.y + (tl.y - sl.y) * lookBlend,
      sl.z + (tl.z - sl.z) * lookBlend
    );

    if (progress >= 1.0) {
      cinematicCamera.active = false;
    }
    return true;
  }

  function togglePhotoMode() {
    photoMode.active = !photoMode.active;
    var hudContainer = document.getElementById('hud-container');
    if (photoMode.active) {
      // Play shutter click sound
      if (Audio && Audio.playSound) Audio.playSound('shutter');
      // Enter photo mode
      if (sceneContext && sceneContext.camera) {
        photoMode.freeLookAt = {
          x: localPlayer ? localPlayer.position.x : 0,
          y: localPlayer ? ((World && World.getTerrainHeight) ? World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z) : 0) + 1.5 : 1.5,
          z: localPlayer ? localPlayer.position.z : 0
        };
      }
      if (hudContainer) {
        photoMode.savedHUDDisplay = hudContainer.style.display;
        hudContainer.style.display = 'none';
      }
      // Show photo mode label
      if (!photoMode.labelEl) {
        photoMode.labelEl = document.createElement('div');
        photoMode.labelEl.style.cssText = 'position:fixed;top:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);color:#fff;padding:6px 16px;border-radius:4px;font:13px monospace;z-index:9999;pointer-events:none;';
        photoMode.labelEl.textContent = 'PHOTO MODE â€” F2 to exit';
        document.body.appendChild(photoMode.labelEl);
      }
      photoMode.labelEl.style.display = 'block';
      setVignetteIntensity(0.6);
    } else {
      // Exit photo mode
      if (hudContainer) {
        hudContainer.style.display = photoMode.savedHUDDisplay || '';
      }
      if (photoMode.labelEl) {
        photoMode.labelEl.style.display = 'none';
      }
      setVignetteIntensity(0.3);
    }
  }

  function updatePhotoModeCamera(deltaTime) {
    if (!photoMode.active || !sceneContext || !Input) return false;
    var delta = Input.getMovementDelta();
    var inputOrbit = Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;
    var inputDist = Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;

    // Pan freeLookAt with camera-relative WASD
    var speed = 0.3;
    if (delta.x !== 0 || delta.z !== 0) {
      var sinY = Math.sin(inputOrbit);
      var cosY = Math.cos(inputOrbit);
      photoMode.freeLookAt.x += (delta.x * cosY - delta.z * sinY) * speed;
      photoMode.freeLookAt.z += (delta.x * sinY + delta.z * cosY) * speed;
      // Follow terrain
      var ty = (World && World.getTerrainHeight) ? World.getTerrainHeight(photoMode.freeLookAt.x, photoMode.freeLookAt.z) : 0;
      photoMode.freeLookAt.y = ty + 1.5;
    }

    // Orbit around freeLookAt
    var camX = photoMode.freeLookAt.x + Math.sin(inputOrbit) * Math.cos(cameraPitch) * inputDist;
    var camY = photoMode.freeLookAt.y + Math.sin(cameraPitch) * inputDist;
    var camZ = photoMode.freeLookAt.z + Math.cos(inputOrbit) * Math.cos(cameraPitch) * inputDist;

    // Smooth lerp
    var lf = 0.12;
    sceneContext.camera.position.x += (camX - sceneContext.camera.position.x) * lf;
    sceneContext.camera.position.y += (camY - sceneContext.camera.position.y) * lf;
    sceneContext.camera.position.z += (camZ - sceneContext.camera.position.z) * lf;

    sceneContext.camera.lookAt(
      photoMode.freeLookAt.x,
      photoMode.freeLookAt.y,
      photoMode.freeLookAt.z
    );
    return true;
  }

  // Cinematic zone entry swoop
  var cinematicCamera = {
    active: false, elapsed: 0, duration: 1.2,
    startPos: null, peakPos: null,
    startLookAt: null, targetLookAt: null
  };

  // Photo mode (F2 toggle)
  var photoMode = {
    active: false,
    freeLookAt: null,
    savedHUDDisplay: '',
    labelEl: null
  };

  // Interaction target tracking for hover highlights and tooltips
  var currentInteractionTarget = null; // { object, type, name, distance, action, mesh }
  var tooltipEl = null;

  // Hover cursor for resource nodes
  var lastHoverCheckTime = 0;

  // Floating text particles
  var floatingTexts = [];

  function showFloatingText(text, screenX, screenY) {
    var el = document.createElement('div');
    el.textContent = text;
    el.style.cssText = 'position:fixed;pointer-events:none;z-index:300;' +
      'color:#DAA520;font:bold 14px var(--font-ui);text-shadow:0 1px 3px rgba(0,0,0,0.8);' +
      'left:' + screenX + 'px;top:' + screenY + 'px;transform:translate(-50%,0);' +
      'transition:transform 1.2s ease-out,opacity 1.2s ease-out;opacity:1;';
    document.body.appendChild(el);
    requestAnimationFrame(function() {
      el.style.transform = 'translate(-50%,-40px)';
      el.style.opacity = '0';
    });
    setTimeout(function() {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, 1300);
  }

  // Show floating Spark earn popup above the player
  function showSparkPopup(amount) {
    if (!amount || amount <= 0) return;
    if (!sceneContext || !sceneContext.camera || !sceneContext.renderer || !localPlayer || !localPlayer.position) return;
    if (!window.THREE) return;
    var pos = new window.THREE.Vector3(localPlayer.position.x, localPlayer.position.y + 2.5, localPlayer.position.z);
    pos.project(sceneContext.camera);
    var sx = (pos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
    var sy = (-pos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;
    showFloatingText('+' + amount + ' Spark', sx, sy);
    if (Audio) Audio.playSound('coin');
  }

  // Screen flash overlay element
  var screenFlashOverlay = null;
  var vignetteOverlay = null;

  /**
   * Trigger screen flash effect
   * @param {string} color - CSS color (e.g., '#DAA520', 'rgba(0,120,255,0.3)')
   * @param {number} duration - Duration in seconds
   */
  function triggerScreenFlash(color, duration) {
    if (!screenFlashOverlay) {
      screenFlashOverlay = document.createElement('div');
      screenFlashOverlay.style.position = 'fixed';
      screenFlashOverlay.style.top = '0';
      screenFlashOverlay.style.left = '0';
      screenFlashOverlay.style.width = '100%';
      screenFlashOverlay.style.height = '100%';
      screenFlashOverlay.style.pointerEvents = 'none';
      screenFlashOverlay.style.zIndex = '9998';
      screenFlashOverlay.style.opacity = '0';
      screenFlashOverlay.style.transition = 'opacity 0.1s ease-out';
      document.body.appendChild(screenFlashOverlay);
    }

    // Set color and show
    screenFlashOverlay.style.backgroundColor = color;
    screenFlashOverlay.style.opacity = '0.6';

    // Fade out
    setTimeout(function() {
      screenFlashOverlay.style.transition = 'opacity ' + duration + 's ease-out';
      screenFlashOverlay.style.opacity = '0';
    }, 50);
  }

  /**
   * Set vignette intensity
   * @param {number} intensity - Intensity level (0.0-1.0)
   */
  function setVignetteIntensity(intensity) {
    if (!vignetteOverlay) {
      vignetteOverlay = document.createElement('div');
      vignetteOverlay.style.position = 'fixed';
      vignetteOverlay.style.top = '0';
      vignetteOverlay.style.left = '0';
      vignetteOverlay.style.width = '100%';
      vignetteOverlay.style.height = '100%';
      vignetteOverlay.style.pointerEvents = 'none';
      vignetteOverlay.style.zIndex = '9997';
      vignetteOverlay.style.transition = 'box-shadow 0.5s ease';
      document.body.appendChild(vignetteOverlay);
    }

    var spread = Math.floor(150 * intensity);
    var alpha = 0.3 + (intensity * 0.4); // 0.3-0.7 range
    vignetteOverlay.style.boxShadow = 'inset 0 0 ' + spread + 'px rgba(0,0,0,' + alpha + ')';
  }

  /**
   * Emit level up particle burst effect
   */
  function emitLevelUpParticles() {
    if (World && World.emitParticles && localPlayer && localPlayer.position) {
      var levelUpPos = { x: localPlayer.position.x, y: localPlayer.position.y + 2, z: localPlayer.position.z };
      World.emitParticles('sparkle', levelUpPos, 25);
    }
    // Add golden flash effect for level up
    triggerScreenFlash('#DAA520', 0.3);
  }

  /**
   * Detect nearest interactable object/NPC/resource within range
   * Returns { object, type, name, distance, action, mesh, position } or null
   */
  function detectNearestInteractable() {
    if (!localPlayer) return null;

    var nearestTarget = null;
    var minDist = 10; // Max interaction range

    var playerX = localPlayer.position.x;
    var playerZ = localPlayer.position.z;

    // Check NPCs
    if (NPCs && NPCs.getNPCPositions) {
      var npcPositions = NPCs.getNPCPositions();
      for (var i = 0; i < npcPositions.length; i++) {
        var npc = npcPositions[i];
        if (!npc) continue;
        var dx = npc.x - playerX;
        var dz = npc.z - playerZ;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearestTarget = {
            type: 'npc',
            name: npc.name || 'NPC',
            action: 'Talk',
            distance: dist,
            mesh: npc.mesh,
            position: { x: npc.x, y: localPlayer.position.y + 1, z: npc.z }
          };
        }
      }
    }

    // Check interactive objects (benches, campfires, etc.)
    if (World && World.getInteractiveAtPosition) {
      var nearbyObj = World.getInteractiveAtPosition(playerX, playerZ, minDist);
      if (nearbyObj) {
        var dx = nearbyObj.position.x - playerX;
        var dz = nearbyObj.position.z - playerZ;
        var dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < minDist) {
          minDist = dist;
          nearestTarget = {
            type: 'interactive',
            name: nearbyObj.type ? nearbyObj.type.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase(); }) : 'Object',
            action: nearbyObj.action ? nearbyObj.action.replace(/_/g, ' ').replace(/\b\w/g, function(l){ return l.toUpperCase(); }) : 'Use',
            distance: dist,
            mesh: nearbyObj.mesh,
            position: nearbyObj.position
          };
        }
      }
    }

    // Check resource nodes
    if (World && World.getResourceNodeAtMouse) {
      // For now, skip resource node highlighting as it requires mouse position
      // Could be enhanced later with a separate distance-based check
    }

    return nearestTarget;
  }

  /**
   * Update tooltip position and content based on current interaction target
   */
  function updateTooltip() {
    if (!tooltipEl || !sceneContext || !sceneContext.camera || !sceneContext.renderer) return;

    if (!currentInteractionTarget) {
      tooltipEl.style.display = 'none';
      return;
    }

    // Project 3D position to screen space
    if (!window.THREE) return;
    var pos = new window.THREE.Vector3(
      currentInteractionTarget.position.x,
      currentInteractionTarget.position.y + 3, // Offset above object
      currentInteractionTarget.position.z
    );
    pos.project(sceneContext.camera);

    // Convert to screen coordinates
    var x = (pos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
    var y = (-pos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;

    // Position tooltip
    tooltipEl.style.left = x + 'px';
    tooltipEl.style.top = y + 'px';
    tooltipEl.style.display = 'block';

    // Update content
    tooltipEl.innerHTML = '<span style="color:#DAA520">' + currentInteractionTarget.name + '</span>' +
      '<br><span style="color:#A0978E; font-size:11px">[E] ' + currentInteractionTarget.action + '</span>';
  }

  /**
   * Initialize the game
   */
  async function init() {
    console.log('Initializing ZION MMO...');

    // --- Dashboard Mode Check ---
    // If ?mode=dashboard or #dashboard, launch UI-only mode
    if (typeof window !== 'undefined' && typeof Dashboard !== 'undefined' && Dashboard.isDashboardMode) {
      if (Dashboard.isDashboardMode()) {
        console.log('[Dashboard] UI-only mode detected');
        return initDashboardMode();
      }
    }

    // Detect platform
    if (Input) {
      platform = Input.getPlatform();
      console.log('Platform:', platform);
    }

    // Check authentication
    if (!Auth) {
      console.error('Auth module not available');
      return;
    }

    // Handle OAuth callback (exchanges ?code= for token if present)
    await Auth.handleCallback();

    // Check if authenticated
    if (!Auth.isAuthenticated()) {
      showLoginScreen();
      return;
    }

    // Hide login screen, show loading screen
    if (typeof document !== 'undefined') {
      var loginEl = document.getElementById('login-screen');
      if (loginEl) loginEl.style.display = 'none';
      var loadingEl = document.getElementById('loading-overlay');
      if (loadingEl) loadingEl.style.display = 'flex';
    }

    // Get username
    const username = Auth.getUsername();
    console.log('Authenticated as:', username);

    // Initialize game systems with loading progress
    await initGameSystems(username);

    // Hide loading screen with fade
    if (typeof document !== 'undefined') {
      var loadEl = document.getElementById('loading-overlay');
      if (loadEl) {
        loadEl.style.opacity = '0';
        loadEl.style.transition = 'opacity 0.5s ease';
        setTimeout(function() { loadEl.style.display = 'none'; }, 600);
      }
    }

    // Start tutorial for new players
    if (HUD && HUD.initTutorial) {
      setTimeout(function() { HUD.initTutorial(); }, 1500);
    }

    // Start game loop
    startGameLoop();
  }

  /**
   * Initialize dashboard (UI-only) mode â€” no 3D world, text/panel interface
   */
  function initDashboardMode() {
    console.log('[Dashboard] Launching dashboard mode...');

    // Hide login screen, loading overlay, and 3D canvas
    if (typeof document !== 'undefined') {
      var loginEl = document.getElementById('login-screen');
      if (loginEl) loginEl.style.display = 'none';
      var loadingEl = document.getElementById('loading-overlay');
      if (loadingEl) loadingEl.style.display = 'none';
      var canvas = document.getElementById('world-canvas');
      if (canvas) canvas.style.display = 'none';
      var hudContainer = document.getElementById('hud-container');
      if (hudContainer) hudContainer.style.display = 'none';
    }

    // Inject dashboard CSS
    if (typeof DashboardCSS !== 'undefined' && DashboardCSS.injectStyles) {
      DashboardCSS.injectStyles();
    }

    // Get container
    var container = typeof document !== 'undefined'
      ? (document.getElementById('game-container') || document.body)
      : null;

    // Get player name (from Auth if available, else prompt or default)
    var playerName = 'Traveler';
    if (typeof Auth !== 'undefined' && Auth.isAuthenticated && Auth.isAuthenticated()) {
      playerName = Auth.getUsername() || 'Traveler';
    } else if (typeof localStorage !== 'undefined') {
      playerName = localStorage.getItem('zion_dashboard_player') || 'Traveler';
    }

    // Initialize dashboard shell
    if (typeof Dashboard !== 'undefined' && Dashboard.initDashboard) {
      Dashboard.initDashboard(container);
    }

    // Create game state via DashboardMain
    var dashState = null;
    if (typeof DashboardMain !== 'undefined' && DashboardMain.createGameState) {
      // Try loading saved state first
      dashState = DashboardMain.loadState ? DashboardMain.loadState() : null;
      if (!dashState) {
        dashState = DashboardMain.createGameState(playerName);
      }
    }

    // Create dashboard UI inside the container
    if (container && typeof document !== 'undefined') {
      // Create the dashboard container div
      var dashEl = document.createElement('div');
      dashEl.className = 'dashboard-container';
      dashEl.id = 'dashboard-root';

      // Header
      var header = document.createElement('div');
      header.className = 'dashboard-header';
      header.innerHTML =
        '<div class="dashboard-logo">ZION</div>' +
        '<div class="dashboard-player-info">' +
          '<span id="dash-player-name">' + _escHtml(playerName) + '</span>' +
          ' | <span class="dashboard-spark" id="dash-spark">' + (dashState ? dashState.player.spark : 100) + ' Spark</span>' +
          ' | <span class="dashboard-zone" id="dash-zone">' + (dashState ? _zoneDisplayName(dashState.player.zone) : 'The Nexus') + '</span>' +
          ' | <span class="dashboard-time" id="dash-time">Day 1 | 06:00</span>' +
        '</div>';
      dashEl.appendChild(header);

      // Main panel grid
      var main = document.createElement('div');
      main.className = 'dashboard-main';
      main.id = 'dashboard-panels';

      // Create panels from available modules
      var panels = [];

      // Zone Navigator
      if (typeof DashboardZones !== 'undefined' && DashboardZones.createZoneNavigator) {
        var zonePanel = _wrapPanel('Zone Navigator', DashboardZones.createZoneNavigator());
        panels.push(zonePanel);
      }

      // NPC Panel
      if (typeof DashboardNPCs !== 'undefined' && DashboardNPCs.createNPCPanel) {
        var npcPanel = _wrapPanel('NPCs', DashboardNPCs.createNPCPanel());
        panels.push(npcPanel);
      }

      // Inventory
      if (typeof DashboardInventory !== 'undefined' && DashboardInventory.createInventoryPanel) {
        var invPanel = _wrapPanel('Inventory & Crafting', DashboardInventory.createInventoryPanel());
        panels.push(invPanel);
      }

      // Economy
      if (typeof DashboardEconomy !== 'undefined' && DashboardEconomy.createEconomyPanel) {
        var ecoPanel = _wrapPanel('Economy & Trading', DashboardEconomy.createEconomyPanel());
        panels.push(ecoPanel);
      }

      // Quests
      if (typeof DashboardQuests !== 'undefined' && DashboardQuests.createQuestPanel) {
        var questPanel = _wrapPanel('Quests & Achievements', DashboardQuests.createQuestPanel());
        panels.push(questPanel);
      }

      // Social
      if (typeof DashboardSocial !== 'undefined' && DashboardSocial.createSocialPanel) {
        var socialPanel = _wrapPanel('Social Hub', DashboardSocial.createSocialPanel());
        panels.push(socialPanel);
      }

      // Mini-Games
      if (typeof DashboardGames !== 'undefined' && DashboardGames.createGamesPanel) {
        var gamesPanel = _wrapPanel('Mini-Games', DashboardGames.createGamesPanel());
        panels.push(gamesPanel);
      }

      // World Status
      if (typeof DashboardWorld !== 'undefined' && DashboardWorld.createWorldPanel) {
        var worldPanel = _wrapPanel('World Status', DashboardWorld.createWorldPanel());
        panels.push(worldPanel);
      }

      // If no module panels created, show a basic welcome panel
      if (panels.length === 0) {
        var welcomePanel = document.createElement('div');
        welcomePanel.className = 'dashboard-panel';
        welcomePanel.innerHTML =
          '<div class="dashboard-panel-header"><span class="dashboard-panel-title">Welcome to ZION</span></div>' +
          '<div class="dashboard-panel-body">' +
            '<p>Dashboard mode is active. You are exploring ZION through a text-based interface.</p>' +
            '<p style="color:#DAA520;margin-top:12px">Current Zone: ' + (dashState ? _zoneDisplayName(dashState.player.zone) : 'The Nexus') + '</p>' +
            '<p style="color:#A0978E;margin-top:8px">Use keyboard shortcuts: I (Inventory), J (Quests), M (Map), G (Guild)</p>' +
          '</div>';
        panels.push(welcomePanel);
      }

      for (var pi = 0; pi < panels.length; pi++) {
        main.appendChild(panels[pi]);
      }
      dashEl.appendChild(main);

      // Footer tabs
      var footer = document.createElement('div');
      footer.className = 'dashboard-footer';
      var tabLabels = ['All', 'Navigate', 'Social', 'Economy', 'Gameplay', 'Info'];
      for (var ti = 0; ti < tabLabels.length; ti++) {
        var tab = document.createElement('button');
        tab.className = 'dashboard-tab' + (ti === 0 ? ' active' : '');
        tab.textContent = tabLabels[ti];
        footer.appendChild(tab);
      }
      dashEl.appendChild(footer);

      container.appendChild(dashEl);
    }

    // Start dashboard game loop
    if (typeof DashboardMain !== 'undefined' && DashboardMain.dashboardTick && dashState) {
      var dashInterval = setInterval(function() {
        dashState = DashboardMain.dashboardTick(dashState, 1);

        // Update header
        if (typeof document !== 'undefined') {
          var sparkEl = document.getElementById('dash-spark');
          if (sparkEl) sparkEl.textContent = (dashState.player.spark || 0) + ' Spark';
          var zoneEl = document.getElementById('dash-zone');
          if (zoneEl) zoneEl.textContent = _zoneDisplayName(dashState.player.zone);
          var timeEl = document.getElementById('dash-time');
          if (timeEl && dashState.world && dashState.world.time) {
            var dayNum = Math.floor(dashState.world.time.tick / (dashState.world.time.dayLength || 1200)) + 1;
            var timeOfDay = (dashState.world.time.tick % (dashState.world.time.dayLength || 1200)) / (dashState.world.time.dayLength || 1200);
            var hours = Math.floor(timeOfDay * 24);
            var mins = Math.floor((timeOfDay * 24 - hours) * 60);
            timeEl.textContent = 'Day ' + dayNum + ' | ' + (hours < 10 ? '0' : '') + hours + ':' + (mins < 10 ? '0' : '') + mins;
          }
        }
      }, 1000);

      // Store interval for cleanup
      if (typeof window !== 'undefined') {
        window._zionDashInterval = dashInterval;
      }
    }

    console.log('[Dashboard] Dashboard mode initialized');
  }

  function _wrapPanel(title, contentEl) {
    if (typeof document === 'undefined') return null;
    var panel = document.createElement('div');
    panel.className = 'dashboard-panel';
    var hdr = document.createElement('div');
    hdr.className = 'dashboard-panel-header';
    hdr.innerHTML = '<span class="dashboard-panel-title">' + _escHtml(title) + '</span>' +
      '<div class="dashboard-panel-controls">' +
        '<button class="dashboard-panel-btn" title="Minimize">[-]</button>' +
        '<button class="dashboard-panel-btn" title="Close">[x]</button>' +
      '</div>';
    panel.appendChild(hdr);
    var body = document.createElement('div');
    body.className = 'dashboard-panel-body';
    if (contentEl) body.appendChild(contentEl);
    panel.appendChild(body);

    // Wire minimize toggle
    var minBtn = hdr.querySelector('[title="Minimize"]');
    if (minBtn) {
      minBtn.addEventListener('click', function() {
        if (body.style.display === 'none') {
          body.style.display = 'block';
          minBtn.textContent = '[-]';
        } else {
          body.style.display = 'none';
          minBtn.textContent = '[+]';
        }
      });
    }
    // Wire close
    var closeBtn = hdr.querySelector('[title="Close"]');
    if (closeBtn) {
      closeBtn.addEventListener('click', function() {
        panel.style.display = 'none';
      });
    }
    return panel;
  }

  function _escHtml(s) {
    if (!s) return '';
    return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  function _zoneDisplayName(zoneId) {
    var names = {
      nexus: 'The Nexus', gardens: 'The Gardens', athenaeum: 'The Athenaeum',
      studio: 'The Studio', wilds: 'The Wilds', agora: 'The Agora',
      commons: 'The Commons', arena: 'The Arena'
    };
    return names[zoneId] || zoneId || 'Unknown';
  }

  /**
   * Initialize game systems
   */
  async function initGameSystems(username) {
    // Initialize audio
    if (Audio) {
      Audio.initAudio();
    }

    // Initialize state
    if (State) {
      gameState = State.initState();
      localPlayer = {
        id: username,
        name: username,
        position: { x: 0, y: 0, z: 0 },
        zone: 'nexus',
        spark: 1000,
        warmth: 0
      };
      State.addPlayer(gameState, localPlayer);
    }

    // Initialize economy ledger
    if (Economy) {
      economyLedger = Economy.createLedger();
      economyLedger.balances[username] = 1000;
    }

    // Initialize inventory
    if (Inventory) {
      playerInventory = Inventory.createInventory();
      Inventory.addItem(playerInventory, 'wood_oak', 5);
      Inventory.addItem(playerInventory, 'stone_common', 5);
      Inventory.addItem(playerInventory, 'seed_wildflower', 3);
    }

    // Initialize raycaster for clicking
    if (typeof THREE !== 'undefined') {
      raycaster = new THREE.Raycaster();
    }

    // Initialize network
    if (Network) {
      // Host mode: use well-known lobby peer ID so other players auto-connect
      const urlParams = typeof URLSearchParams !== 'undefined' && typeof window !== 'undefined'
        ? new URLSearchParams(window.location.search) : null;
      const isHost = urlParams && urlParams.get('host') === 'true';
      const peerId = isHost ? 'zion-lobby-main' : `zion-${username}-${Date.now()}`;
      Network.initMesh(peerId, {
        onMessage: handleIncomingMessage,
        onPeerConnect: (peerId) => {
          console.log('Peer connected:', peerId);
          HUD && HUD.showNotification(`Player connected: ${peerId}`, 'info');
        },
        onPeerDisconnect: (peerId) => {
          console.log('Peer disconnected:', peerId);
          HUD && HUD.showNotification(`Player disconnected: ${peerId}`, 'info');
          if (gameState && State) {
            State.removePlayer(gameState, peerId);
          }
        }
      });

      // Connect to lobby peer
      const lobbyPeer = Network.getLobbyPeerId('main');
      Network.connectToPeer(lobbyPeer);

      // Join lobby for automatic peer discovery
      if (Network.joinLobby) {
        Network.joinLobby('main', username, currentZone);
      }

      // Broadcast join message after a short delay to let connections establish
      setTimeout(function() {
        joinWorld();
      }, 2000);

      // Initialize federation
      const worldId = Network.deriveWorldId();
      const worldName = 'ZION'; // Could be customized per fork
      const endpoint = typeof window !== 'undefined' ? window.location.origin : 'http://localhost';
      Network.initFederation(worldId, worldName, endpoint);

      // Register federation event handler
      Network.onFederationEvent((event) => {
        handleFederationEvent(event);
      });

      // Announce to federation network periodically
      setInterval(() => {
        if (Network.announceFederation) {
          Network.announceFederation();
        }
      }, 60000); // Every 60 seconds

      // Initial announce
      setTimeout(() => {
        if (Network.announceFederation) {
          Network.announceFederation();
        }
      }, 5000); // After 5 seconds to let connections establish
    }

    // Initialize API bridge for AI agent communication
    if (ApiBridge && ApiBridge.init) {
      ApiBridge.init();
    }

    // Load canonical state from GitHub (so solo visitors see agent activity)
    if (typeof fetch !== 'undefined' && State && State.getLiveState && State.setLiveState) {
      const RAW = 'https://raw.githubusercontent.com/kody-w/zion/main/state';
      const loadCanonical = function(file) {
        return fetch(RAW + '/' + file, { cache: 'no-cache' })
          .then(function(r) { return r.ok ? r.json() : null; })
          .catch(function() { return null; });
      };
      Promise.all([loadCanonical('world.json'), loadCanonical('chat.json')])
        .then(function(results) {
          var world = results[0];
          var chat = results[1];
          if (!world && !chat) return;
          var live = State.getLiveState();
          if (world) {
            // Merge citizens from canonical into live state
            var citizens = world.citizens || {};
            if (!live.players) live.players = {};
            for (var cid in citizens) {
              if (citizens.hasOwnProperty(cid) && !live.players[cid]) {
                live.players[cid] = citizens[cid];
              }
            }
            // Merge world metadata
            if (!live.world) live.world = {};
            live.world.time = world.worldTime || live.world.time || 0;
            live.world.dayPhase = world.dayPhase || live.world.dayPhase || 'day';
            live.world.weather = world.weather || live.world.weather || 'clear';
            live.world.season = world.season || live.world.season || 'spring';
            live.world.structures = world.structures || [];
            live.world.creations = world.creations || [];
          }
          if (chat && chat.messages) {
            if (!live.chat) live.chat = [];
            // Prepend canonical chat (live chat takes priority for duplicates)
            var liveIds = {};
            for (var i = 0; i < live.chat.length; i++) {
              if (live.chat[i].id) liveIds[live.chat[i].id] = true;
            }
            for (var j = 0; j < chat.messages.length; j++) {
              var m = chat.messages[j];
              if (!m.id || !liveIds[m.id]) {
                live.chat.push(m);
              }
            }
          }
          State.setLiveState(live);
          console.log('[Canonical] Loaded %d citizens, %d chat messages from state/',
            Object.keys((world && world.citizens) || {}).length,
            (chat && chat.messages || []).length);
        });
    }

    // Initialize CRM simulation
    if (typeof SimCRM !== 'undefined' && SimCRM.initState) {
      simCrmState = SimCRM.initState();
      console.log('[SimCRM] Initialized');
    }

    // Initialize 3D scene
    if (typeof document !== 'undefined' && World) {
      const container = document.getElementById('game-container') || document.body;
      sceneContext = World.initScene(container);

      if (sceneContext) {
        // Load initial zone - positions player at nexus center
        World.loadZone(sceneContext, currentZone);
        // Load initial chunks around player
        if (World.updateChunks) {
          World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
        }
        World.addPlayer(sceneContext, username, localPlayer.position);

        // Initialize particle effects (fire, sparkle, mist, fountain, etc.)
        if (World.initParticles) {
          World.initParticles(sceneContext);
        }

        // Initialize water bodies (ponds, rivers, fountains)
        if (World.initWater) {
          World.initWater(sceneContext);
        }

        // Initialize skybox (sky dome, stars, sun, moon)
        if (World.initSkybox) {
          World.initSkybox(sceneContext);
        }

        // Initialize resource nodes for harvesting
        if (World.initResourceNodes) {
          World.initResourceNodes(sceneContext);
        }

        // Spawn interactive objects for current zone (benches, campfires, etc.)
        if (World.spawnZoneInteractives) {
          World.spawnZoneInteractives(sceneContext, currentZone);
        }

        // Initialize wildlife (butterflies, fireflies, birds, fish)
        if (World.initWildlife) {
          World.initWildlife(sceneContext);
        }

        // Initialize zone ambience particles
        if (World.initZoneAmbience) {
          World.initZoneAmbience(sceneContext);
        }

        // Initialize seasonal particle system (cherry blossoms, fireflies, leaves, snow)
        if (World.initSeasonalParticles) {
          World.initSeasonalParticles(sceneContext);
        }

        // Initialize vignette overlay with default intensity
        setVignetteIntensity(0.3);

        // Create zone boundary particles (golden floating markers at zone edges)
        if (World.createZoneBoundaryParticles && sceneContext.scene) {
          World.createZoneBoundaryParticles(sceneContext.scene);
        }

        // Initialize enhanced weather systems
        if (World.initBillboardClouds) World.initBillboardClouds(sceneContext);
        if (World.initRainSplashes) World.initRainSplashes(sceneContext);
        if (World.initValleyFog) World.initValleyFog(sceneContext);
        if (World.initZoneBorderShimmer) World.initZoneBorderShimmer(sceneContext);

        // Load world memory (footpaths, gathering spots)
        if (World.loadWorldMemory) World.loadWorldMemory();

        // Wire lightning callback for camera shake + thunder
        if (World.weatherCallbacks) {
          World.weatherCallbacks.onLightningStrike = function(boltX, boltZ) {
            triggerCameraShake(0.3, 0.4);
            // Trigger thunder SFX after 1-3 second delay
            var thunderDelay = 1000 + Math.random() * 2000;
            setTimeout(function() {
              if (Audio && Audio.playAmbient) {
                // Use existing audio system for thunder
                triggerScreenFlash('rgba(255,255,255,0.15)', 0.1);
              }
            }, thunderDelay);
          };
        }
      }
    }

    // Initialize HUD
    if (typeof document !== 'undefined' && HUD) {
      const container = document.getElementById('game-container') || document.body;
      HUD.initHUD(container);
      HUD.updateZoneLabel(currentZone);
      HUD.updatePlayerInfo(localPlayer);

      // Initialize toolbar (action buttons, coords, time/weather)
      if (HUD.initToolbar) {
        HUD.initToolbar();
      }

      // Initialize quest tracker
      if (HUD.initQuestTracker) {
        HUD.initQuestTracker();
      }

      // Initialize reputation system
      if (Social && Social.initReputation) {
        Social.initReputation(localPlayer.id);
        if (HUD.updateReputationDisplay) {
          HUD.updateReputationDisplay(Social.getReputation(localPlayer.id));
        }
      }

      // Initialize governance panel callback
      if (HUD.initGovernancePanel) {
        HUD.initGovernancePanel(handleGovernanceAction);
      }

      // Initialize inventory panel
      if (HUD.initInventoryPanel) {
        HUD.initInventoryPanel();
      }

      // Initialize crafting panel with craft callback
      if (HUD.initCraftingPanel) {
        HUD.initCraftingPanel(function(recipeId) {
          handleCraft(recipeId);
        });
      }

      // Initialize quick bar
      if (HUD.initQuickBar) {
        HUD.initQuickBar();
      }

      // Load settings and apply them
      if (HUD.loadSettings) {
        HUD.loadSettings();
        var settings = HUD.getSettings();
        if (settings && Audio) {
          if (Audio.setVolume) {
            Audio.setVolume('master', settings.masterVolume / 100);
            Audio.setVolume('music', settings.musicVolume / 100);
            Audio.setVolume('sfx', settings.sfxVolume / 100);
          }
        }
        // Set FPS counter visibility
        if (settings) {
          showDebug = settings.showFPS;
        }
      }

      // Initialize play time tracking
      getPlayTimeSeconds();

      // Add chat input
      HUD.addChatInput((text) => {
        handleLocalAction('chat', { message: text });
        HUD.hideChatInput();
      });

      // Initialize interaction tooltip overlay
      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'interaction-tooltip';
        tooltipEl.style.cssText = 'position:fixed; pointer-events:none; z-index:200; ' +
          'background:rgba(10,14,26,0.85); border:1px solid rgba(218,165,32,0.6); ' +
          'border-radius:6px; padding:6px 12px; color:#E8E0D8; font-size:12px; ' +
          'font-family:var(--font-ui); display:none; transform:translate(-50%,-100%); ' +
          'backdrop-filter:blur(5px); white-space:nowrap;';
        document.body.appendChild(tooltipEl);
      }
    }

    // Initialize quest system for local player
    if (Quests) {
      Quests.initPlayerQuests(username);
      if (Quests.initPlayerAchievements) {
        Quests.initPlayerAchievements(username);
      }
      console.log('Quest system initialized for player:', username);
    }

    // Restore saved player data (position, inventory, spark, etc.)
    var wasRestored = restorePlayerData();
    if (wasRestored) {
      console.log('Restored saved player data');
      var timeSince = Auth.getTimeSinceLastSave ? Auth.getTimeSinceLastSave() : Infinity;
      if (timeSince < 86400000 && HUD) { // Less than 24 hours
        var minsAgo = Math.floor(timeSince / 60000);
        var timeStr = minsAgo < 60 ? minsAgo + ' minutes' : Math.floor(minsAgo / 60) + ' hours';
        setTimeout(function() {
          HUD.showNotification('Welcome back! Last seen ' + timeStr + ' ago', 'info');
        }, 2000);
      }
    }

    // Initialize trading system
    if (Trading && Network) {
      Trading.initTrading(function(msg) {
        Network.broadcastMessage(msg);
      });
      console.log('Trading system initialized');
    }

    // Set up NPC dialog action handler
    if (HUD && HUD.setNPCActionCallback) {
      HUD.setNPCActionCallback(function(action, npcData) {
        handleNPCAction(action, npcData);
      });
    }

    // Initialize input
    if (Input) {
      Input.initInput({
        onMove: (delta) => {
          // Movement handled in game loop
        },
        onAction: (type, data) => {
          handleLocalAction(type, data);
        },
        onChat: (data) => {
          if (data.mode === 'open') {
            HUD && HUD.showChatInput();
          }
        },
        onBuild: (data) => {
          handleBuildAction(data);
        }
      });
    }

    // Hover cursor change on mousemove (raycast for resource nodes)
    if (typeof document !== 'undefined' && sceneContext && sceneContext.renderer) {
      var hoverCanvas = sceneContext.renderer.domElement;
      hoverCanvas.addEventListener('mousemove', function(e) {
        var now = Date.now();
        if (now - lastHoverCheckTime < 100) return; // Throttle to 100ms
        lastHoverCheckTime = now;
        if (!raycaster || !sceneContext.camera || !World) return;
        var rect = hoverCanvas.getBoundingClientRect();
        var mx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        var my = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        var node = World.getResourceNodeAtMouse(raycaster, sceneContext.camera, mx, my);
        document.body.style.cursor = node ? 'pointer' : 'default';
      });
    }

    // Mobile photo mode button (touch devices only)
    if ('ontouchstart' in window && typeof document !== 'undefined') {
      var photoBtn = document.createElement('div');
      photoBtn.id = 'mobile-photo-btn';
      photoBtn.innerHTML = '&#128247;'; // camera emoji
      photoBtn.style.cssText = 'position:fixed;bottom:80px;right:16px;width:44px;height:44px;' +
        'background:rgba(10,14,26,0.7);border:1px solid rgba(218,165,32,0.5);border-radius:50%;' +
        'color:#E8E0D8;font-size:20px;display:flex;align-items:center;justify-content:center;' +
        'z-index:150;cursor:pointer;backdrop-filter:blur(5px);';
      photoBtn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePhotoMode();
        photoBtn.innerHTML = photoMode.active ? '&#10005;' : '&#128247;';
      });
      document.body.appendChild(photoBtn);
    }

    // Play ambient audio and start music
    if (Audio) {
      Audio.playAmbient(currentZone);
      if (Audio.startMusic) Audio.startMusic(currentZone, currentTimePeriod || 'midday');
    }

    // Initialize AI citizens
    if (NPCs) {
      NPCs.initNPCs(null, gameState, sceneContext);
      NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);

      // Register NPC intentions from embedded souls
      if (Intentions && EMBEDDED_SOULS && EMBEDDED_SOULS.length > 0) {
        var registered = 0;
        EMBEDDED_SOULS.forEach(function(soul) {
          if (soul.intentions && soul.intentions.length > 0) {
            Intentions.clearIntentions(soul.id);
            soul.intentions.forEach(function(intent) {
              Intentions.registerIntention(soul.id, intent);
            });
            registered++;
          }
        });
        console.log('Registered intentions for ' + registered + ' NPCs');
      }
    }

    // Initialize economic event display
    updateEconomicEvent();

    // Initialize seasonal event display
    initSeasonalEvent();

    // Initialize XR (VR/AR) capabilities
    if (XR && XR.initXR) {
      XR.initXR().then(function(caps) {
        if (HUD && HUD.setXRCapabilities) {
          HUD.setXRCapabilities(caps, sceneContext);
        }
      });
    }

    // Initialize pet system - restore saved pet
    initPetSystem(username);

    // Wire HUD callbacks for anchor, steward, and federation panels
    if (typeof window !== 'undefined') {
      window.playerInventory = playerInventory;
      window._onAnchorPlace = function(data) {
        if (State && gameState) {
          var msg = { type: 'anchor_place', from: localPlayer.id, ts: Date.now(), payload: { anchor: data } };
          gameState = State.applyMessage(gameState, msg);
        }
      };
      window._onElectionStart = function(data) {
        if (State && gameState) {
          var msg = { type: 'election_start', from: localPlayer.id, ts: Date.now(), payload: data };
          gameState = State.applyMessage(gameState, msg);
        }
      };
      window._onElectionVote = function(data) {
        if (State && gameState) {
          var msg = { type: 'election_vote', from: localPlayer.id, ts: Date.now(), payload: data };
          gameState = State.applyMessage(gameState, msg);
        }
      };
      window._onFederationPropose = function(data) {
        if (State && gameState) {
          var msg = { type: 'federation_announce', from: localPlayer.id, ts: Date.now(), payload: { federation: data } };
          gameState = State.applyMessage(gameState, msg);
        }
      };
    }

    // Send join message
    joinWorld();

    // Record play start time
    playStartTime = Date.now();

    // Start GPS tracking for Warmth (only if geolocation available)
    if (typeof navigator !== 'undefined' && navigator.geolocation) {
      try {
        gpsWatchId = navigator.geolocation.watchPosition(function(pos) {
          gpsHistory.push({
            lat: pos.coords.latitude,
            lon: pos.coords.longitude,
            ts: Date.now()
          });
          // Keep only last 100 points
          if (gpsHistory.length > 100) {
            gpsHistory = gpsHistory.slice(-100);
          }
        }, function() {
          // Geolocation denied or unavailable - game works fine without it
          console.log('Geolocation not available - Warmth bonus disabled');
        }, { enableHighAccuracy: false, maximumAge: 30000, timeout: 10000 });
      } catch (e) {
        // Silently ignore - warmth is optional
      }
    }

    console.log('Game systems initialized');
  }

  /**
   * Convert 3D position to screen coordinates
   */
  function getScreenPosition(position, camera, renderer) {
    if (!window.THREE || !camera || !renderer) return null;

    var vector = new window.THREE.Vector3(position.x, position.y + 2, position.z);
    vector.project(camera);

    var widthHalf = renderer.domElement.width / 2;
    var heightHalf = renderer.domElement.height / 2;

    return {
      x: (vector.x * widthHalf) + widthHalf,
      y: -(vector.y * heightHalf) + heightHalf
    };
  }

  /**
   * Show login screen
   */
  function showLoginScreen() {
    if (typeof document === 'undefined') {
      console.log('Not authenticated. Please authenticate.');
      return;
    }

    const loginScreen = document.createElement('div');
    loginScreen.id = 'login-screen';
    loginScreen.style.cssText = `
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1040 40%, #0d2137 70%, #0a0e1a 100%);
      display: flex; align-items: center; justify-content: center;
      z-index: 10000; font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    `;

    // Animated star background
    var starCanvas = document.createElement('canvas');
    starCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;';
    starCanvas.width = window.innerWidth;
    starCanvas.height = window.innerHeight;
    loginScreen.appendChild(starCanvas);
    var starCtx = starCanvas.getContext('2d');
    var loginStars = [];
    for (var si = 0; si < 150; si++) {
      loginStars.push({
        x: Math.random() * starCanvas.width,
        y: Math.random() * starCanvas.height,
        r: 0.5 + Math.random() * 1.5,
        speed: 0.1 + Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2
      });
    }
    function animateLoginStars() {
      if (!document.getElementById('login-screen')) return;
      starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
      var time = Date.now() * 0.001;
      loginStars.forEach(function(s) {
        var alpha = 0.3 + Math.sin(time * s.speed + s.phase) * 0.4;
        starCtx.fillStyle = 'rgba(180, 200, 255, ' + Math.max(0, alpha) + ')';
        starCtx.beginPath();
        starCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        starCtx.fill();
      });
      requestAnimationFrame(animateLoginStars);
    }
    animateLoginStars();

    const content = document.createElement('div');
    content.style.cssText = 'text-align:center;color:white;position:relative;z-index:1;';

    content.innerHTML = `
      <div style="font-size:72px;font-weight:100;letter-spacing:16px;margin-bottom:8px;
        background:linear-gradient(135deg,#4af,#a8f,#4af);-webkit-background-clip:text;
        -webkit-text-fill-color:transparent;background-clip:text;">ZION</div>
      <p style="font-size:16px;margin-bottom:40px;opacity:0.6;letter-spacing:4px;text-transform:uppercase;">
        A peer-to-peer social metaverse</p>
      <button id="github-login" style="
        padding:16px 48px;font-size:16px;background:rgba(255,255,255,0.1);
        color:white;border:1px solid rgba(255,255,255,0.3);border-radius:30px;
        cursor:pointer;font-weight:500;letter-spacing:1px;
        backdrop-filter:blur(10px);transition:all 0.3s;
      " onmouseover="this.style.background='rgba(255,255,255,0.2)';this.style.borderColor='rgba(255,255,255,0.6)'"
         onmouseout="this.style.background='rgba(255,255,255,0.1)';this.style.borderColor='rgba(255,255,255,0.3)'"
      >Login with GitHub</button>
      <p style="margin-top:24px;font-size:12px;opacity:0.4;">
        Or append ?token=YOUR_GITHUB_PAT to the URL</p>
      <div style="margin-top:60px;font-size:11px;opacity:0.3;">
        100 AI citizens await in 8 zones</div>
    `;

    loginScreen.appendChild(content);
    document.body.appendChild(loginScreen);

    document.getElementById('github-login').addEventListener('click', () => {
      if (Auth) {
        Auth.initiateOAuth();
      }
    });
  }

  /**
   * Start game loop
   */
  function startGameLoop() {
    isRunning = true;
    lastTimestamp = performance.now();

    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    } else {
      console.warn('requestAnimationFrame not available');
    }
  }

  /**
   * Main game loop
   */
  function gameLoop(timestamp) {
    if (!isRunning) return;

    const deltaTime = (timestamp - lastTimestamp) / 1000; // seconds
    lastTimestamp = timestamp;

    // Increment frame counter for periodic updates
    npcUpdateFrame++;
    frameCount++;

    // Track FPS
    fpsFrameTimes.push(deltaTime);
    if (fpsFrameTimes.length > 60) {
      fpsFrameTimes.shift();
    }
    if (fpsFrameTimes.length > 10) {
      var avgFrameTime = fpsFrameTimes.reduce(function(a, b) { return a + b; }, 0) / fpsFrameTimes.length;
      currentFPS = avgFrameTime > 0 ? Math.round(1 / avgFrameTime) : 60;
    }

    // Track play time
    playTimeSeconds += deltaTime;
    // Save every 30 seconds
    if (frameCount % 1800 === 0) {
      savePlayTime();
    }

    // Update FPS counter visibility from settings
    if (HUD && HUD.getSettings) {
      var settings = HUD.getSettings();
      if (settings) {
        showDebug = settings.showFPS;
      }
    }

    // Process queued messages
    processMessageQueue();

    // Process local player movement (skip in photo mode)
    if (Input && localPlayer && gameState && !photoMode.active) {
      const delta = Input.getMovementDelta();
      if (delta.x !== 0 || delta.z !== 0) {
        // Rotate movement delta by camera yaw so WASD is camera-relative
        var sinYaw = Math.sin(cameraYaw);
        var cosYaw = Math.cos(cameraYaw);
        var rotatedDelta = {
          x: delta.x * cosYaw - delta.z * sinYaw,
          y: delta.y,
          z: delta.x * sinYaw + delta.z * cosYaw
        };

        const moveMsg = Input.createMoveMessage(
          localPlayer.id,
          rotatedDelta,
          localPlayer.position,
          currentZone
        );

        // Collision check â€” reject move if it would clip into a structure
        var newPos = moveMsg.payload.position;
        if (World && World.checkCollision && World.checkCollision(newPos.x, newPos.z, 0.5)) {
          // Blocked â€” try sliding along X or Z axis only
          var slideX = { x: newPos.x, y: localPlayer.position.y, z: localPlayer.position.z };
          var slideZ = { x: localPlayer.position.x, y: localPlayer.position.y, z: newPos.z };
          if (!World.checkCollision(slideX.x, slideX.z, 0.5)) {
            moveMsg.payload.position = slideX;
          } else if (!World.checkCollision(slideZ.x, slideZ.z, 0.5)) {
            moveMsg.payload.position = slideZ;
          } else {
            // Fully blocked, don't move
            moveMsg.payload.position = { x: localPlayer.position.x, y: localPlayer.position.y, z: localPlayer.position.z };
          }
        }

        // Apply locally
        handleLocalAction('move', moveMsg.payload);

        // Broadcast to network
        if (Network) {
          Network.broadcastMessage(moveMsg);
        }

        // Update world chunks around player position
        if (World && World.updateChunks && sceneContext) {
          World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
        }

        // Detect zone from player position
        if (World && World.getZoneAtPosition) {
          var detectedZone = World.getZoneAtPosition(localPlayer.position.x, localPlayer.position.z);
          if (detectedZone !== currentZone) {
            var oldZone = currentZone;
            currentZone = detectedZone;
            console.log('Entered zone:', currentZone);

            // Play zone entry swoosh sound
            if (Audio && Audio.playSound) Audio.playSound('zone_enter');

            // Track activity
            addRecentActivity('Entered ' + currentZone);

            // Seamless transition â€” no camera teleport, just update zone context
            // Terrain chunks load dynamically as the player walks

            if (Mentoring) {
              var xpResult = Mentoring.addSkillXP(localPlayer.id, 'exploration', 8);
              if (xpResult.leveledUp && HUD) {
                HUD.showNotification('Exploration skill increased to ' + xpResult.newLevelName, 'success');
                emitLevelUpParticles();
              }
            }

            if (HUD) {
              HUD.updateZoneLabel(currentZone);
              HUD.showNotification('Entered ' + currentZone.charAt(0).toUpperCase() + currentZone.slice(1), 'info');
            }

            if (Audio) {
              Audio.playAmbient(currentZone);
              if (Audio.setZoneAmbient) Audio.setZoneAmbient(currentZone);
              if (Audio.updateMusic) Audio.updateMusic(currentZone, currentTimePeriod);
              // Piano accent on first zone discovery
              if (Audio.playPianoAccent && !visitedZones[currentZone]) {
                Audio.playPianoAccent('zone_discovery');
              }
            }
            visitedZones[currentZone] = true;

            if (NPCs) {
              NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
              // Broadcast zone change to NPCs
              if (NPCs.broadcastEvent) {
                NPCs.broadcastEvent({ type: 'player_zone_change', data: {
                  playerId: localPlayer.id, fromZone: oldZone, toZone: currentZone,
                  position: localPlayer.position
                }});
              }
            }

            // Reload interactive objects for new zone
            if (World && World.clearInteractiveObjects && World.spawnZoneInteractives) {
              World.clearInteractiveObjects(sceneContext);
              World.spawnZoneInteractives(sceneContext, currentZone);
            }

            // Record zone visit for governance
            if (Zones && Zones.recordZoneVisit) {
              Zones.recordZoneVisit(currentZone, localPlayer.id);
            }

            // Show welcome message if zone has one
            if (Zones && HUD) {
              var policies = Zones.getZonePolicies(currentZone);
              if (policies && policies.welcomeMessage) {
                HUD.showNotification(policies.welcomeMessage, 'info');
              }
            }

            // Update quest progress for zone visits
            if (Quests) {
              var updated = Quests.updateQuestProgress(localPlayer.id, 'visit_zone', { zone: currentZone });
              if (updated.length > 0 && HUD) {
                updated.forEach(function(quest) {
                  HUD.showQuestProgress('Quest progress: ' + quest.title);
                });
              }
            }

            // Track zone visit achievement
            trackAchievement('zone_visit', { zone: currentZone });
          }
        }

        // Update NPC visibility by distance every ~30 frames
        if (NPCs && Math.random() < 0.03) {
          NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
        }

        // Footstep sounds
        footstepTimer += deltaTime;
        if (footstepTimer >= 0.4) {
          // Determine footstep sound based on zone
          var footstepTerrain = 'grass'; // default
          if (currentZone === 'nexus') footstepTerrain = 'stone';
          else if (currentZone === 'gardens') footstepTerrain = 'grass';
          else if (currentZone === 'athenaeum') footstepTerrain = 'stone';
          else if (currentZone === 'studio') footstepTerrain = 'wood';
          else if (currentZone === 'wilds') footstepTerrain = 'grass';
          else if (currentZone === 'agora') footstepTerrain = 'stone';
          else if (currentZone === 'commons') footstepTerrain = 'wood';
          else if (currentZone === 'arena') footstepTerrain = 'stone';

          if (Audio && Audio.playFootstep) {
            Audio.playFootstep(footstepTerrain);
          }
          footstepTimer = 0;
        }
      } else {
        // Reset footstep timer when not moving
        footstepTimer = 0;
      }
    }

    // Evaluate NPC intentions â€” throttled: 5 NPCs per frame
    if (Intentions && NPCs && localPlayer && gameState) {
      var agents = NPCs.getAgents ? NPCs.getAgents() : [];
      if (agents.length > 0) {
        var worldStateForIntentions = {
          players: new Map()
        };
        // Add local player
        worldStateForIntentions.players.set(localPlayer.id, {
          id: localPlayer.id,
          position: localPlayer.position
        });
        // Add NPC positions from agents array
        agents.forEach(function(agent) {
          if (agent.position) {
            worldStateForIntentions.players.set(agent.id, {
              id: agent.id,
              position: { x: agent.position.x, y: agent.position.y || 0, z: agent.position.z }
            });
          }
        });
        // Evaluate 5 NPCs per frame round-robin
        var count = Math.min(5, agents.length);
        for (var ei = 0; ei < count; ei++) {
          var idx = (npcIntentionIndex + ei) % agents.length;
          var agent = agents[idx];
          var actions = Intentions.evaluateTriggers(agent.id, worldStateForIntentions, deltaTime);
          if (actions && actions.length > 0) {
            actions.forEach(function(action) {
              if (action.type === 'say' && NPCs.showNPCSpeechBubble) {
                NPCs.showNPCSpeechBubble(agent.id, action.payload ? action.payload.text || action.payload.message : '...');
              }
            });
          }
        }
        npcIntentionIndex = (npcIntentionIndex + count) % agents.length;
      }
    }

    // Update world time (24-min day/night cycle = 1440 minutes in 24 real minutes)
    worldTime += deltaTime * 60; // 60x speed
    if (worldTime >= 1440) worldTime -= 1440;

    // Detect time period from worldTime (minutes 0-1440)
    var worldHour = worldTime / 60;
    var newTimePeriod = 'night';
    if (worldHour >= 5 && worldHour < 7) newTimePeriod = 'dawn';
    else if (worldHour >= 7 && worldHour < 12) newTimePeriod = 'morning';
    else if (worldHour >= 12 && worldHour < 14) newTimePeriod = 'midday';
    else if (worldHour >= 14 && worldHour < 18) newTimePeriod = 'afternoon';
    else if (worldHour >= 18 && worldHour < 21) newTimePeriod = 'evening';
    else newTimePeriod = 'night';

    // Broadcast time period changes to NPCs and audio
    if (newTimePeriod !== currentTimePeriod) {
      currentTimePeriod = newTimePeriod;
      if (NPCs && NPCs.broadcastEvent) {
        NPCs.broadcastEvent({ type: 'time_change', data: { period: currentTimePeriod, hour: worldHour } });
      }
      // Update ambient audio and music for time of day
      if (Audio && Audio.updateAmbientTime) {
        Audio.updateAmbientTime(currentTimePeriod);
      }
      if (Audio && Audio.updateMusic) {
        Audio.updateMusic(currentZone, currentTimePeriod);
      }
      // Piano accent for time-of-day transitions (BotW-style)
      if (Audio && Audio.playPianoAccent) {
        if (currentTimePeriod === 'dawn') Audio.playPianoAccent('dawn');
        else if (currentTimePeriod === 'morning') Audio.playPianoAccent('morning');
        else if (currentTimePeriod === 'evening') Audio.playPianoAccent('dusk');
        else if (currentTimePeriod === 'night') Audio.playPianoAccent('night');
      }
    }

    // Update AI citizens â€” pass player position and weather for perception
    if (NPCs) {
      var npcWorldState = {
        weather: currentWeather,
        worldTime: worldTime,
        timePeriod: currentTimePeriod,
        playerPosition: localPlayer ? localPlayer.position : null,
        playerId: localPlayer ? localPlayer.id : null
      };
      NPCs.updateNPCs(sceneContext, gameState, deltaTime, worldTime, npcWorldState);
      // Update speech bubble positions based on camera
      if (NPCs.updateSpeechBubbles && sceneContext && sceneContext.camera) {
        NPCs.updateSpeechBubbles(sceneContext.camera);
      }
    }

    // Update rendering
    if (sceneContext && World) {
      // Update player positions
      if (gameState && State) {
        const players = State.getPlayers(gameState);
        players.forEach(player => {
          if (player.id !== localPlayer.id) {
            World.movePlayer(sceneContext, player.id, player.position);
          } else {
            World.movePlayer(sceneContext, player.id, localPlayer.position);
          }
        });
      }

      // Camera follows player (orbiting third-person with smooth lerp interpolation)
      if (sceneContext.camera && localPlayer) {
        var terrainY = 0;
        if (World && World.getTerrainHeight) {
          terrainY = World.getTerrainHeight(localPlayer.position.x, localPlayer.position.z);
        }
        localPlayer.position.y = terrainY;

        // Photo mode camera overrides normal follow
        if (photoMode.active) {
          updatePhotoModeCamera(deltaTime);
        }
        else {
        // Get camera controls from Input module
        var inputCameraDistance = Input && Input.getCameraDistance ? Input.getCameraDistance() : cameraDistance;
        var inputCameraOrbit = Input && Input.getCameraOrbit ? Input.getCameraOrbit() : cameraYaw;

        // Calculate orbiting camera position from orbit/pitch/distance
        var camOffX = Math.sin(inputCameraOrbit) * Math.cos(cameraPitch) * inputCameraDistance;
        var camOffY = Math.sin(cameraPitch) * inputCameraDistance;
        var camOffZ = Math.cos(inputCameraOrbit) * Math.cos(cameraPitch) * inputCameraDistance;

        var camTargetX = localPlayer.position.x + camOffX;
        var camTargetY = terrainY + camOffY + 2;
        var camTargetZ = localPlayer.position.z + camOffZ;

        // Camera collision: ensure camera doesn't go below terrain
        var camTerrainY = World && World.getTerrainHeight ? World.getTerrainHeight(camTargetX, camTargetZ) : 0;
        if (camTargetY < camTerrainY + 2) camTargetY = camTerrainY + 2;

        // Buttery smooth camera follow using lerp interpolation
        var lerpFactor = 0.08;
        sceneContext.camera.position.x += (camTargetX - sceneContext.camera.position.x) * lerpFactor;
        sceneContext.camera.position.y += (camTargetY - sceneContext.camera.position.y) * lerpFactor;
        sceneContext.camera.position.z += (camTargetZ - sceneContext.camera.position.z) * lerpFactor;

        // Apply camera shake if active
        if (cameraShake.active) {
          cameraShake.elapsed += deltaTime;
          var progress = cameraShake.elapsed / cameraShake.duration;
          if (progress >= 1) {
            cameraShake.active = false;
          } else {
            var decay = 1 - progress;
            var shakeX = (Math.random() - 0.5) * 2 * cameraShake.intensity * decay;
            var shakeY = (Math.random() - 0.5) * 2 * cameraShake.intensity * decay;
            sceneContext.camera.position.x += shakeX;
            sceneContext.camera.position.y += shakeY;
          }
        }

        sceneContext.camera.lookAt(
          localPlayer.position.x,
          terrainY + 1.5,
          localPlayer.position.z
        );
        } // end normal camera else block
      }

      // Update day/night cycle
      World.updateDayNight(sceneContext, worldTime);

      // Weather cycling â€” changes every 4 in-game hours (every 4 real minutes)
      var weatherCycleMinute = Math.floor(worldTime / 240); // 0-5
      var nextWeather;
      if (typeof WeatherFX !== 'undefined' && WeatherFX.rollWeather) {
        var season = (Seasons && Seasons.getCurrentSeason) ? Seasons.getCurrentSeason() : null;
        var seasonId = season ? season.id : 'summer';
        nextWeather = WeatherFX.rollWeather(weatherCycleMinute, seasonId);
      } else {
        var weatherTypes = ['clear', 'cloudy', 'rain', 'clear', 'storm', 'snow'];
        nextWeather = weatherTypes[weatherCycleMinute % weatherTypes.length];
      }
      if (nextWeather !== currentWeather) {
        var prevWeather = currentWeather;
        currentWeather = nextWeather;
        if (World.setWeather) {
          World.setWeather(sceneContext, currentWeather);
        }
        // Broadcast weather change to NPCs
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'weather_change', data: { weather: currentWeather, previous: prevWeather } });
        }
        // Update ambient audio for weather
        if (Audio && Audio.updateAmbientWeather) {
          Audio.updateAmbientWeather(currentWeather);
        }
        // Update vignette intensity based on weather (use WeatherFX visibility if available)
        if (typeof WeatherFX !== 'undefined' && WeatherFX.getVisibilityRange) {
          var vis = WeatherFX.getVisibilityRange(currentWeather);
          setVignetteIntensity(vis < 100 ? 0.7 : vis < 300 ? 0.5 : 0.3);
        } else if (currentWeather === 'storm') {
          setVignetteIntensity(0.7);
        } else if (currentWeather === 'rain' || currentWeather === 'snow') {
          setVignetteIntensity(0.5);
        } else {
          setVignetteIntensity(0.3);
        }
        // Apply weather gameplay modifiers
        if (typeof WeatherFX !== 'undefined' && WeatherFX.getAmbientModifiers) {
          var mods = WeatherFX.getAmbientModifiers(currentWeather);
          if (localPlayer) localPlayer.weatherModifiers = mods;
        }
      }

      // Cull distant lights for performance (max 12 nearest within 40 units)
      if (World.cullLights) {
        World.cullLights(sceneContext, localPlayer.position, 40, 12);
      }

      // Performance optimizations
      // Update frustum culling every 10 frames
      if (frameCount % 10 === 0 && World.updateFrustumCulling) {
        World.updateFrustumCulling(sceneContext);
      }

      // Update LOD every 30 frames
      if (frameCount % 30 === 0 && World.updateLOD) {
        World.updateLOD(sceneContext, localPlayer.position);
      }

      // Update environmental animations
      if (World.updateAnimations) {
        World.updateAnimations(sceneContext, deltaTime, worldTime);
      }

      // Update resource nodes (respawning)
      if (World.updateResourceNodes) {
        World.updateResourceNodes(deltaTime);
      }

      // Update player animations (walk/run/idle)
      if (World.updatePlayerAnimations) {
        World.updatePlayerAnimations(sceneContext, deltaTime);
      }

      // Update particle effects (fire, sparkle, mist, fountain, leaves)
      if (World.updateParticles) {
        World.updateParticles(sceneContext, deltaTime * 1000, localPlayer ? localPlayer.position : null);
      }

      // Update weather effects (rain, snow)
      if (World.updateWeatherEffects) {
        World.updateWeatherEffects(sceneContext, deltaTime * 1000, localPlayer ? localPlayer.position : null);
      }

      // Update zone ambience particles
      if (World.updateZoneAmbience && localPlayer) {
        World.updateZoneAmbience(sceneContext, localPlayer.zone, deltaTime * 1000);
      }

      // Update seasonal visuals: particles (blossoms/fireflies/leaves/snow), light tints, fog tint
      if (World.updateSeasonalVisuals) {
        var seasonNormalizedTime = worldTime / 1440;
        World.updateSeasonalVisuals(sceneContext, localPlayer ? localPlayer.zone : 'nexus', deltaTime * 1000, seasonNormalizedTime);
      }

      // Update water bodies (animated waves, weather-reactive)
      if (World.updateWater) {
        var currentWeather = World.getCurrentWeather ? World.getCurrentWeather() : 'clear';
        World.updateWater(deltaTime, currentWeather);
      }

      // Update skybox (sun/moon orbit, star visibility)
      if (World.updateSkybox) {
        World.updateSkybox(sceneContext, worldTime);
      }

      // Update interactive objects (highlights, campfire flicker, etc.)
      if (World.updateInteractiveAnimations) {
        World.updateInteractiveAnimations(deltaTime);
      }
      if (World.updateInteractiveHighlights && localPlayer) {
        World.updateInteractiveHighlights(localPlayer.position.x, localPlayer.position.z, 4);
      }

      // Detect and highlight nearest interactable for E-key interaction
      if (localPlayer) {
        var newTarget = detectNearestInteractable();

        // If target changed, update highlighting
        if (newTarget !== currentInteractionTarget) {
          // Clear previous highlight
          if (World && World.unhighlightObject) {
            World.unhighlightObject();
          }

          // Set new target
          currentInteractionTarget = newTarget;

          // Apply new highlight
          if (currentInteractionTarget && currentInteractionTarget.mesh && World && World.highlightObject) {
            World.highlightObject(currentInteractionTarget.mesh);
          }
        }

        // Update tooltip position
        updateTooltip();
      }

      // Update ambient wildlife (butterflies, fireflies, birds, fish)
      if (World.updateWildlife) {
        World.updateWildlife(sceneContext, deltaTime, worldTime);
      }

      // Update world events (shooting stars, aurora, resource blooms, etc.)
      updateWorldEvents(deltaTime, worldTime, sceneContext);

      // Update zone boundary particles (golden floating markers)
      if (World.updateZoneBoundaryParticles) {
        World.updateZoneBoundaryParticles(worldTime);
      }

      // â”€â”€ Enhanced systems â”€â”€
      // World memory (footpaths, gathering, flowers)
      if (World.updateWorldMemory && localPlayer) {
        var nearbyCount = 0;
        if (NPCs && NPCs.getNearbyNPCCount) {
          nearbyCount = NPCs.getNearbyNPCCount(localPlayer.position, 5);
        }
        World.updateWorldMemory(localPlayer.position, nearbyCount, deltaTime);
      }

      // Billboard clouds
      if (World.updateBillboardClouds) {
        World.updateBillboardClouds(deltaTime, currentWeather);
      }

      // Snow accumulation
      if (World.updateSnowAccumulation) {
        World.updateSnowAccumulation(deltaTime * 1000, currentWeather);
      }

      // Valley fog
      if (World.updateValleyFog) {
        World.updateValleyFog(worldTime, currentWeather);
      }

      // Terrain breathing
      if (World.updateTerrainBreathing) {
        World.updateTerrainBreathing(deltaTime, worldTime);
      }

      // Wind system
      if (World.updateWindSystem) {
        World.updateWindSystem(deltaTime, currentWeather);
      }

      // Zone border shimmer
      if (World.updateZoneBorderShimmer) {
        World.updateZoneBorderShimmer(worldTime);
      }

      // Update build preview if in build mode
      if (buildModeActive && World && World.updateBuildPreview && Input && Input.getMouseNDC) {
        var mousePos = Input.getMouseNDC();
        World.updateBuildPreview(sceneContext, mousePos.x, mousePos.y, sceneContext.camera);
      }

      // Render scene
      if (sceneContext.renderer && sceneContext.scene && sceneContext.camera) {
        sceneContext.renderer.render(sceneContext.scene, sceneContext.camera);
      }
    }

    // Update HUD
    if (HUD && gameState && State) {
      // Update player info
      HUD.updatePlayerInfo(localPlayer);

      // Update minimap and emote bubbles
      const players = State.getPlayers(gameState);

      // Update emote bubble positions
      if (HUD.updateEmoteBubbles && sceneContext && sceneContext.camera) {
        var playerPositions = {};
        players.forEach(function(player) {
          if (World && World.getPlayerMesh) {
            var mesh = World.getPlayerMesh(sceneContext, player.id);
            if (mesh) {
              var screenPos = getScreenPosition(mesh.position, sceneContext.camera, sceneContext.renderer);
              if (screenPos) {
                playerPositions[player.id] = screenPos;
              }
            }
          }
        });
        HUD.updateEmoteBubbles(playerPositions);
      }
      const mapPlayers = players.map(p => ({
        id: p.id,
        position: p.position,
        isLocal: p.id === localPlayer.id
      }));
      HUD.updateMinimap(mapPlayers, currentZone);

      // Update NPC dots on minimap
      if (HUD.updateMinimapNPCs && NPCs && NPCs.getNPCPositions) {
        HUD.updateMinimapNPCs(NPCs.getNPCPositions(), localPlayer.position);
      }

      // Update nearby players
      const nearby = players
        .filter(p => p.id !== localPlayer.id && p.zone === currentZone)
        .map(p => {
          const dx = p.position.x - localPlayer.position.x;
          const dz = p.position.z - localPlayer.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          return { id: p.id, name: p.name, distance };
        })
        .sort((a, b) => a.distance - b.distance);

      HUD.updateNearbyPlayers(nearby);

      // Update coordinates display
      if (HUD.updateCoords && localPlayer) {
        HUD.updateCoords(localPlayer.position);
      }

      // Update time and weather display
      if (HUD.updateTimeWeather) {
        HUD.updateTimeWeather(worldTime, currentWeather);
      }

      // Update chat
      const messages = Social ? Social.getRecentMessages(gameState) : [];
      HUD.updateChat(messages);

      // Update quest tracker (every few frames)
      if (Quests && HUD.updateQuestTracker && npcUpdateFrame % 30 === 0) {
        var activeQuests = Quests.getActiveQuests(localPlayer.id);
        HUD.updateQuestTracker(activeQuests);
      }

      // Update quest indicators on NPCs (every few frames)
      if (Quests && NPCs && NPCs.updateQuestIndicators && npcUpdateFrame % 60 === 0) {
        NPCs.updateQuestIndicators(localPlayer.id, localPlayer.position);
      }

      // Update Warmth from GPS movement (every 5 seconds)
      var now = Date.now();
      if (now - lastWarmthUpdate > 5000 && Physical && gpsHistory.length >= 2) {
        lastWarmthUpdate = now;
        var newWarmth = Physical.calculateWarmth(gpsHistory);
        if (localPlayer && newWarmth !== localPlayer.warmth) {
          localPlayer.warmth = newWarmth;
          // Warmth bonus applies to harvest yields and discovery rates
          // This is cosmetic-adjacent per constitution - minor 1-10% bonus
        }
      }

      // Update FPS display if debug mode is enabled
      if (showDebug && typeof document !== 'undefined') {
        var fpsElement = document.getElementById('fps-counter');
        if (!fpsElement) {
          fpsElement = document.createElement('div');
          fpsElement.id = 'fps-counter';
          fpsElement.style.position = 'fixed';
          fpsElement.style.top = '10px';
          fpsElement.style.right = '10px';
          fpsElement.style.padding = '8px 12px';
          fpsElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          fpsElement.style.color = '#00ff00';
          fpsElement.style.fontFamily = 'monospace';
          fpsElement.style.fontSize = '12px';
          fpsElement.style.borderRadius = '4px';
          fpsElement.style.zIndex = '10000';
          document.body.appendChild(fpsElement);
        }

        // Get performance stats from World
        var perfStats = World && World.getPerformanceStats ? World.getPerformanceStats() : null;
        var statsText = 'FPS: ' + currentFPS;
        if (perfStats) {
          statsText += '\nObjects: ' + perfStats.visibleObjects + '/' + perfStats.totalObjects;
          statsText += '\nAnimations: ' + perfStats.activeAnimations;
          statsText += '\nChunks: ' + perfStats.loadedChunks;
          statsText += '\nTriangles: ' + perfStats.estimatedTriangles;
        }
        fpsElement.innerText = statsText;
      }
    }

    // Check for break reminder (every 30 minutes)
    const minutesPlayed = (Date.now() - playStartTime) / 60000;
    if (minutesPlayed > 30 && minutesPlayed - lastBreakReminder > 30) {
      if (HUD) {
        HUD.showBreakReminder(Math.floor(minutesPlayed));
      }
      lastBreakReminder = minutesPlayed;
    }

    // Auto-save player data periodically
    var nowMs = Date.now();
    if (nowMs - lastAutoSave > AUTO_SAVE_INTERVAL) {
      lastAutoSave = nowMs;
      autoSavePlayerData();
      // Flush economy ledger into live state for API bridge visibility
      if (State && economyLedger) {
        State.setLiveState('economy', {
          balances: economyLedger.balances || {},
          transactions: (economyLedger.transactions || []).slice(-50),
          listings: economyLedger.listings || []
        });
        State.flushToLocal();
      }
    }

    // Check for nearby secrets periodically
    if (nowMs - lastSecretCheck > SECRET_CHECK_INTERVAL) {
      lastSecretCheck = nowMs;
      checkSecrets();
    }

    // Update economic event display periodically (every 30 seconds)
    if (nowMs - lastEventCheck > 30000) {
      lastEventCheck = nowMs;
      updateEconomicEvent();
    }

    // Update seasonal event periodically
    if (nowMs - lastSeasonCheck > SEASON_CHECK_INTERVAL) {
      lastSeasonCheck = nowMs;
      updateSeasonalEvent();
    }

    // Update pet status periodically
    if (nowMs - lastPetUpdate > PET_UPDATE_INTERVAL) {
      lastPetUpdate = nowMs;
      updatePetStatus();
    }

    // Check race checkpoint progress periodically
    if (nowMs - lastRaceCheck > RACE_CHECK_INTERVAL && localPlayer && gameState && Competition && Competition.checkRaceProgress) {
      lastRaceCheck = nowMs;
      var comps = gameState.competitions;
      if (comps && comps.length > 0) {
        for (var ri = 0; ri < comps.length; ri++) {
          var rc = comps[ri];
          if (rc.type === 'race' && rc.status === 'active' && rc.participants && rc.participants.indexOf(localPlayer.id) !== -1) {
            var raceResult = Competition.checkRaceProgress(rc.id, localPlayer.id, localPlayer.position, gameState);
            if (raceResult.checkpointHit) {
              if (raceResult.finished) {
                HUD.showNotification('Race complete! Time: ' + (raceResult.time / 1000).toFixed(1) + 's', 'success');
                if (Audio) Audio.playSound('coin');
              } else {
                HUD.showNotification('Checkpoint ' + raceResult.currentCheckpoint + '/' + rc.checkpoints.length + '!', 'info');
                if (Audio) Audio.playSound('item_pickup');
              }
            }
          }
        }
      }
    }

    // Tick CRM simulation periodically
    if (typeof SimCRM !== 'undefined' && SimCRM.simulateTick && simCrmState && nowMs - lastSimCrmTick >= SIM_CRM_TICK_INTERVAL) {
      lastSimCrmTick = nowMs;
      simCrmState = SimCRM.simulateTick(simCrmState);
    }

    // Update API bridge (state publishing + inbox polling)
    if (ApiBridge && ApiBridge.update) {
      ApiBridge.update(nowMs, gameState);
    }

    // Request next frame
    if (typeof window !== 'undefined' && window.requestAnimationFrame) {
      window.requestAnimationFrame(gameLoop);
    }
  }

  /**
   * Process queued incoming messages
   */
  function processMessageQueue() {
    while (messageQueue.length > 0) {
      const msg = messageQueue.shift();
      applyMessage(msg);
    }
  }

  /**
   * Handle federation events from Network module
   */
  function handleFederationEvent(event) {
    if (!event || !event.type) return;

    switch (event.type) {
      case 'world_discovered':
        console.log('Discovered federated world:', event.worldInfo.worldName);
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Discovered world: ' + event.worldInfo.worldName, 'info');
        }
        if (HUD && HUD.updateFederationStatus) {
          HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
        }
        break;

      case 'federation_established':
        console.log('Federation established with:', event.worldInfo.worldName);
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Portal opened to: ' + event.worldInfo.worldName, 'success');
        }
        if (HUD && HUD.updateFederationStatus) {
          HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
        }
        // Create portal in 3D world if in Nexus
        if (World && sceneContext && currentZone === 'nexus') {
          createFederationPortal(event.worldInfo);
        }
        break;

      case 'cross_world_warp':
        console.log('Player warping to world:', event.targetWorld);
        triggerCameraShake(0.4, 0.6);
        triggerScreenFlash('rgba(138,43,226,0.4)', 0.5);
        break;

      case 'player_returned':
        console.log('Player returned:', event.playerId);
        break;

      default:
        console.log('Unknown federation event:', event.type);
    }
  }

  /**
   * Create a federation portal in the 3D world
   */
  function createFederationPortal(worldInfo) {
    if (!World || !sceneContext || !World.createPortal) return;

    // Position portals around the nexus
    var portalCount = Network.getFederatedWorlds().length;
    var angle = (portalCount * Math.PI * 2) / 8; // Spread around circle
    var radius = 30;
    var x = Math.cos(angle) * radius;
    var z = Math.sin(angle) * radius;

    var portalData = {
      id: 'portal-fed-' + worldInfo.worldId,
      position: { x: x, y: 0, z: z },
      targetWorld: worldInfo.worldId,
      worldName: worldInfo.worldName,
      type: 'federation'
    };

    World.createPortal(sceneContext, portalData);
    console.log('Created federation portal to:', worldInfo.worldName);
  }

  /**
   * Handle incoming network message
   */
  function handleIncomingMessage(msg) {
    // Validate message
    if (!Protocol) {
      return;
    }
    // Accept messages even without full protocol validation for P2P
    // (remote peers may send slightly different formats)
    if (Protocol.validateMessage) {
      var validation = Protocol.validateMessage(msg);
      if (!validation.valid) {
        // Only reject if completely malformed (no type or from)
        if (!msg || !msg.type || !msg.from) {
          console.warn('Invalid message received (no type/from):', msg);
          return;
        }
      }
    }

    // Add to queue for processing
    messageQueue.push(msg);
  }

  /**
   * Apply message to game state
   */
  function applyMessage(msg) {
    if (!gameState || !State) return;

    switch (msg.type) {
      case 'join':
        handleJoinMessage(msg);
        break;
      case 'leave':
        handleLeaveMessage(msg);
        break;
      case 'move':
        handleMoveMessage(msg);
        break;
      case 'chat':
      case 'say':
      case 'shout':
      case 'whisper':
        handleChatMessage(msg);
        break;
      case 'warp':
        handleWarpMessage(msg);
        break;
      case 'harvest':
        handleHarvestMessage(msg);
        break;
      case 'build':
        handleBuildMessage(msg);
        break;
      case 'trade':
        handleTradeMessage(msg);
        break;
      case 'trade_offer':
      case 'trade_accept':
      case 'trade_decline':
        handleTradeProtocolMessage(msg);
        break;
      case 'emote':
        handleEmoteMessage(msg);
        break;
      case 'discover':
        handleDiscoverMessage(msg);
        break;
      case 'score':
        handleScoreMessage(msg);
        break;
      case 'federation_announce':
        handleFederationAnnounce(msg);
        break;
      case 'federation_handshake':
        handleFederationHandshake(msg);
        break;
      case 'warp_fork':
        handleWarpFork(msg);
        break;
      case 'return_home':
        handleReturnHome(msg);
        break;
      default:
        console.log('Unknown message type:', msg.type);
    }
  }

  /**
   * Handle emote message
   */
  function handleEmoteMessage(msg) {
    if (!msg.payload || !msg.payload.emoteType) return;

    // Play animation on remote player mesh
    if (World && sceneContext && NPCs && NPCs.playEmoteAnimation) {
      var playerMesh = World.getPlayerMesh ? World.getPlayerMesh(sceneContext, msg.from) : null;
      if (playerMesh) {
        NPCs.playEmoteAnimation(playerMesh, msg.payload.emoteType);
      }
    }

    // Show emote bubble
    if (HUD && HUD.showEmoteBubble) {
      HUD.showEmoteBubble(msg.from, msg.payload.emoteType);
    }
  }

  /**
   * Handle discover message
   */
  function handleDiscoverMessage(msg) {
    if (!Exploration || !gameState) return;

    var result = Exploration.handleDiscover(msg, gameState);
    if (result.success) {
      // Update game state
      gameState = result.state;

      // If this is the local player, show discovery popup and update spark
      if (msg.from === localPlayer.id) {
        if (HUD && HUD.showDiscoveryPopup) {
          var discoveryData = {
            name: result.discovery.type.charAt(0).toUpperCase() + result.discovery.type.slice(1),
            description: result.discovery.description,
            rarity: getRarityName(result.discovery.rarity),
            sparkReward: result.sparkAwarded
          };
          HUD.showDiscoveryPopup(discoveryData);
        }

        // Award spark
        if (economyLedger && Economy && result.sparkAwarded) {
          var discoverySpark = Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: result.discovery.rarity });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(discoverySpark);
        }

        // Track activity
        addRecentActivity('Discovered a ' + result.discovery.type);

        // Track discovery achievement
        trackAchievement('discover', { type: result.discovery.type, rarity: result.discovery.rarity });

        if (Audio) Audio.playSound('warp');
      }
    }
  }

  /**
   * Handle federation announce message
   */
  function handleFederationAnnounce(msg) {
    if (!Network) return;

    // Let Network module handle the discovery
    Network.handleFederationMessage(msg);

    // Update HUD if available
    if (HUD && HUD.updateFederationStatus) {
      HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
    }
  }

  /**
   * Handle federation handshake message
   */
  function handleFederationHandshake(msg) {
    if (!Network) return;

    // Let Network module handle the handshake
    Network.handleFederationMessage(msg);

    // Update HUD
    if (HUD && HUD.updateFederationStatus) {
      HUD.updateFederationStatus(Network.getDiscoveredWorlds(), Network.getFederatedWorlds());
    }

    // Show notification
    var worldName = msg.worldName || msg.payload?.worldName || 'Unknown World';
    if (HUD && HUD.showNotification) {
      HUD.showNotification('Federation established with ' + worldName, 'success');
    }
  }

  /**
   * Handle cross-world warp message
   */
  function handleWarpFork(msg) {
    if (!msg.payload || !msg.payload.target_world) return;

    var targetWorld = msg.payload.target_world;
    var playerId = msg.from;

    // If this is the local player, handle the warp
    if (playerId === localPlayer.id) {
      // Store home world if not already set
      if (!localPlayer.home_world) {
        localPlayer.home_world = Network.deriveWorldId();
      }

      // Update current world
      localPlayer.current_world = targetWorld;

      if (HUD && HUD.showNotification) {
        HUD.showNotification('Warping to federated world: ' + targetWorld, 'info');
      }

      // Add warp fork screen effects
      triggerCameraShake(0.4, 0.6);
      triggerScreenFlash('rgba(138,43,226,0.4)', 0.5);

      // In a real implementation, this would navigate to the other world's URL
      // For now, we just track the state
      console.log('Player warped to federated world:', targetWorld);
    } else {
      // Another player warped out
      if (gameState && State) {
        State.removePlayer(gameState, playerId);
      }

      if (World && sceneContext) {
        World.removePlayer(sceneContext, playerId);
      }

      if (HUD && HUD.showNotification) {
        HUD.showNotification(playerId + ' traveled to another world', 'info');
      }
    }
  }

  /**
   * Handle return home message
   */
  function handleReturnHome(msg) {
    var playerId = msg.from;

    // If this is the local player returning
    if (playerId === localPlayer.id) {
      var homeWorld = localPlayer.home_world || Network.deriveWorldId();
      localPlayer.current_world = homeWorld;

      if (HUD && HUD.showNotification) {
        HUD.showNotification('Returned to home world', 'success');
      }

      console.log('Player returned to home world:', homeWorld);
    } else {
      // Another player returned from traveling
      if (HUD && HUD.showNotification) {
        HUD.showNotification(playerId + ' returned from traveling', 'info');
      }
    }
  }

  /**
   * Handle score message for competitions
   */
  function handleScoreMessage(msg) {
    if (!Competition || !gameState) return;

    var result = Competition.handleScore(msg, gameState);
    if (result.success) {
      gameState = result.state;

      // Broadcast to spectators if any
      if (Competition.getSpectators) {
        var spectators = Competition.getSpectators(result.competition.id);
        if (spectators.length > 0 && Competition.broadcastToSpectators) {
          Competition.broadcastToSpectators(
            result.competition.id,
            'score_update',
            {
              playerId: msg.from,
              score: msg.payload.score,
              competition: result.competition
            }
          );
        }
      }

      // If competition ended, award spark to winner
      if (result.winner && result.sparkAward) {
        if (result.winner === localPlayer.id) {
          if (HUD) {
            HUD.showNotification('You won the competition! +' + result.sparkAward + ' Spark', 'success');
          }
          if (economyLedger && Economy) {
            var compSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'competition', { complexity: 1.0 });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
            showSparkPopup(compSpark);
          }
          // Award combat XP for winning
          if (Mentoring) {
            var combatXP = Mentoring.addSkillXP(localPlayer.id, 'combat', 25);
            if (combatXP.leveledUp && HUD) {
              HUD.showNotification('Combat skill increased to ' + combatXP.newLevelName + '!', 'success');
              emitLevelUpParticles();
            }
          }
        } else {
          // Participation XP even for losing
          if (Mentoring) {
            Mentoring.addSkillXP(localPlayer.id, 'combat', 8);
          }
        }
      }
    }
  }

  /**
   * Convert rarity number to name
   */
  function getRarityName(rarity) {
    if (rarity >= 0.9) return 'legendary';
    if (rarity >= 0.7) return 'epic';
    if (rarity >= 0.5) return 'rare';
    if (rarity >= 0.3) return 'uncommon';
    return 'common';
  }

  /**
   * Handle join message
   */
  function handleJoinMessage(msg) {
    const player = {
      id: msg.from,
      name: msg.from,
      position: msg.payload.position || { x: 0, y: 0, z: 0 },
      zone: msg.payload.zone || 'nexus',
      spark: 1000,
      warmth: 0
    };

    State.addPlayer(gameState, player);

    if (World && sceneContext) {
      World.addPlayer(sceneContext, player.id, player.position);
    }

    if (HUD) {
      HUD.showNotification(`${player.name} joined the world`, 'success');
    }

    if (Audio) {
      Audio.playSound('warp');
    }
  }

  /**
   * Handle leave message
   */
  function handleLeaveMessage(msg) {
    State.removePlayer(gameState, msg.from);

    if (World && sceneContext) {
      World.removePlayer(sceneContext, msg.from);
    }

    if (HUD) {
      HUD.showNotification(`${msg.from} left the world`, 'info');
    }
  }

  /**
   * Handle move message
   */
  function handleMoveMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.position = msg.payload.position;
    player.zone = msg.payload.zone;

    // Update in world if not local player
    if (msg.from !== localPlayer.id && World && sceneContext) {
      World.movePlayer(sceneContext, msg.from, player.position);
    }
  }

  /**
   * Handle chat message
   */
  function handleChatMessage(msg) {
    var text = msg.payload.message || msg.payload.text || '';
    var sender = msg.from;

    if (Social) {
      Social.addMessage(gameState, {
        user: sender,
        text: text,
        timestamp: msg.timestamp || msg.ts
      });
    }

    // Update chat HUD with the new message
    if (HUD && HUD.addChatMessage) {
      HUD.addChatMessage(sender, text);
    } else if (HUD) {
      // Fallback: show as notification if chat panel not available
      HUD.showNotification(sender + ': ' + text, 'info');
    }

    if (Audio) {
      Audio.playSound('chat');
    }
  }

  /**
   * Handle warp message
   */
  function handleWarpMessage(msg) {
    const player = State.getPlayer(gameState, msg.from);
    if (!player) return;

    player.zone = msg.payload.zone;
    player.position = msg.payload.position;

    if (msg.from === localPlayer.id) {
      currentZone = msg.payload.zone;

      // Get zone center position from World
      var zonePos = World.getZoneCenter ? World.getZoneCenter(currentZone) : {x: 0, z: 0};
      localPlayer.position.x = zonePos.x;
      localPlayer.position.z = zonePos.z;
      localPlayer.position.y = 0;

      // Update chunks for new position
      if (World.updateChunks) {
        World.updateChunks(sceneContext, localPlayer.position.x, localPlayer.position.z);
      }

      if (HUD) {
        HUD.updateZoneLabel(currentZone);
      }

      if (Audio) {
        Audio.playAmbient(currentZone);
      }

      if (NPCs) {
        NPCs.reloadZoneNPCs(sceneContext, currentZone);
      }
    }

    // Emit portal warp particles (cyan swirl at player position)
    if (World && World.emitParticles && player && player.position) {
      var warpPos = { x: player.position.x, y: player.position.y + 1, z: player.position.z };
      World.emitParticles('fountain', warpPos, 15);
    }

    if (Audio) {
      Audio.playSound('warp');
    }

    // Add warp screen effects
    if (msg.from === localPlayer.id) {
      triggerCameraShake(0.3, 0.5);
      triggerScreenFlash('rgba(0,120,255,0.4)', 0.4);
    }
  }

  /**
   * Handle harvest message
   */
  function handleHarvestMessage(msg) {
    if (Economy) {
      Economy.earnSpark(gameState, msg.from, msg.payload.amount || 10);
    }

    if (Audio) {
      Audio.playSound('harvest');
    }

    if (msg.from === localPlayer.id && HUD) {
      HUD.showNotification(`Harvested ${msg.payload.amount || 10} Spark`, 'success');
    }
  }

  /**
   * Handle build message
   */
  function handleBuildMessage(msg) {
    // Route simulation messages
    if (msg.payload && msg.payload.sim === 'crm' && typeof SimCRM !== 'undefined' && simCrmState) {
      simCrmState = SimCRM.applyAction(simCrmState, msg);
      console.log('[SimCRM] Applied action:', msg.payload.action);
      return;
    }

    if (Creation && World && sceneContext) {
      const structure = msg.payload.structure;
      World.addStructure(sceneContext, structure);
    }

    if (Audio) {
      Audio.playSound('build');
    }

    if (msg.from === localPlayer.id) {
      var structureName = msg.payload.structure.type || 'structure';
      addRecentActivity('Built a ' + structureName);
    }
  }

  /**
   * Handle trade message (legacy)
   */
  function handleTradeMessage(msg) {
    if (Economy) {
      Economy.transferSpark(
        gameState,
        msg.payload.from,
        msg.payload.to,
        msg.payload.amount
      );
    }

    if (Audio) {
      Audio.playSound('trade');
    }

    if (HUD && (msg.payload.from === localPlayer.id || msg.payload.to === localPlayer.id)) {
      HUD.showNotification(
        `Trade: ${msg.payload.amount} Spark`,
        'success'
      );
    }
  }

  /**
   * Handle trade protocol messages
   */
  function handleTradeProtocolMessage(msg) {
    if (!Trading || !HUD) return;

    var result = Trading.handleTradeMessage(msg);
    if (!result) return;

    switch (result.type) {
      case 'trade_request':
        // Only show to target player
        if (result.data.to === localPlayer.id) {
          HUD.showTradeRequest(
            result.data.from,
            result.data.tradeId,
            function(tradeId) {
              // Accept trade
              var acceptResult = Trading.acceptTrade(tradeId, localPlayer.id, localPlayer.position);
              if (acceptResult.success) {
                showTradeWindowForActive(acceptResult.trade);
              } else {
                HUD.showNotification(acceptResult.message, 'error');
              }
            },
            function(tradeId) {
              // Decline trade
              Trading.declineTrade(tradeId, localPlayer.id, localPlayer.position);

              // Record decline for harassment detection
              if (Social && result.data.from) {
                var harassment = Social.recordDecline(result.data.from, localPlayer.id, 'trade_offer');
                if (harassment && HUD) {
                  HUD.showNotification('Repeated unwanted interactions detected - reputation penalty applied', 'warning');
                }
              }
            }
          );
        }
        break;

      case 'trade_accepted':
        // Trade was accepted, show window
        var activeTrade = Trading.getActiveTrade(localPlayer.id);
        if (activeTrade) {
          showTradeWindowForActive(activeTrade);
          HUD.showNotification('Trade started!', 'success');
        }
        break;

      case 'trade_update':
        // Update trade window if open
        var currentTrade = Trading.getActiveTrade(localPlayer.id);
        if (currentTrade && HUD.updateTradeWindow) {
          HUD.updateTradeWindow(currentTrade, localPlayer.id);
        }
        break;

      case 'trade_confirm':
        // Other player confirmed
        var confirmTrade = Trading.getActiveTrade(localPlayer.id);
        if (confirmTrade && HUD.updateTradeWindow) {
          HUD.updateTradeWindow(confirmTrade, localPlayer.id);
        }
        break;

      case 'trade_complete':
        // Trade completed
        HUD.hideTradeWindow();
        HUD.showTradeComplete(msg.from);
        if (Audio) Audio.playSound('trade');

        // Emit trade complete particles (gold sparkle at player position)
        if (World && World.emitParticles && localPlayer && localPlayer.position) {
          var tradePos = { x: localPlayer.position.x, y: localPlayer.position.y + 1.5, z: localPlayer.position.z };
          World.emitParticles('sparkle', tradePos, 12);
        }

        // Track trade achievement
        trackAchievement('trade', { with: msg.from });

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'trading', 15);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Trading skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        // Award reputation for trading
        if (Social) {
          var repResult = Social.adjustReputation(localPlayer.id, 'trading', { with: msg.from });
          if (repResult.tierChanged && HUD) {
            HUD.showNotification('Reputation increased to ' + repResult.tier + '!', 'success');
          }
          if (HUD && HUD.updateReputationDisplay) {
            HUD.updateReputationDisplay(Social.getReputation(localPlayer.id));
          }
        }

        // Update inventory display
        if (HUD.updateInventoryDisplay && playerInventory) {
          HUD.updateInventoryDisplay(playerInventory);
          HUD.updateQuickBar(playerInventory);
        }
        // Update player info with new Spark balance
        if (localPlayer && economyLedger) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          HUD.updatePlayerInfo(localPlayer);
        }
        break;

      case 'trade_cancelled':
        // Trade cancelled
        HUD.hideTradeWindow();
        HUD.hideTradeRequest();
        HUD.showNotification('Trade cancelled', 'info');
        break;
    }
  }

  /**
   * Show trade window for active trade
   */
  function showTradeWindowForActive(trade) {
    if (!HUD || !Trading) return;

    HUD.showTradeWindow(
      trade,
      localPlayer.id,
      // onAddItem â€” opens inventory picker, adds selected item to trade
      function(slotIndex, itemId) {
        if (Trading && playerInventory) {
          var result = Trading.addItemToTrade(trade.id, localPlayer.id, itemId, playerInventory, localPlayer.position);
          if (result && !result.success) {
            HUD.showNotification(result.message || 'Cannot add item', 'error');
          }
        }
      },
      // onRemoveItem
      function(tradeSlot) {
        var result = Trading.removeItemFromTrade(trade.id, localPlayer.id, tradeSlot, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onSetSpark
      function(amount) {
        var result = Trading.setSparkOffer(trade.id, localPlayer.id, amount, economyLedger, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onReady
      function() {
        var result = Trading.setReady(trade.id, localPlayer.id, localPlayer.position);
        if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onConfirm
      function() {
        // In P2P, each client only has their own inventory.
        // Pass local inventory for the local player's side; null for remote
        // (the remote peer confirms with their own inventory on their end).
        var player1Inv = trade.player1.id === localPlayer.id ? playerInventory : null;
        var player2Inv = trade.player2.id === localPlayer.id ? playerInventory : null;

        var result = Trading.confirmTrade(trade.id, localPlayer.id, player1Inv, player2Inv, economyLedger, localPlayer.position);
        if (result.success && result.executed) {
          HUD.hideTradeWindow();
          HUD.showTradeComplete(trade.player1.id === localPlayer.id ? trade.player2.id : trade.player1.id);
          if (Audio) Audio.playSound('trade');
          // Update displays
          if (HUD.updateInventoryDisplay && playerInventory) {
            HUD.updateInventoryDisplay(playerInventory);
            HUD.updateQuickBar(playerInventory);
          }
          if (localPlayer && economyLedger) {
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            HUD.updatePlayerInfo(localPlayer);
          }
        } else if (!result.success) {
          HUD.showNotification(result.message, 'error');
        }
      },
      // onCancel
      function() {
        Trading.cancelTrade(trade.id, localPlayer.id, localPlayer.position);
        HUD.hideTradeWindow();
      }
    );
  }

  // NPC shop inventories by archetype
  var NPC_SHOP_ITEMS = {
    merchant: [
      { id: 'torch', name: 'Torch', price: 8, description: 'Lights the way', icon: '&#128294;' },
      { id: 'rope', name: 'Rope', price: 12, description: 'Useful for climbing and building', icon: '&#129526;' },
      { id: 'compass', name: 'Compass', price: 20, description: 'Helps with navigation', icon: '&#129517;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' },
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'spyglass', name: 'Spyglass', price: 35, description: 'See far-off landmarks', icon: '&#128269;' },
      { id: 'lantern_oil', name: 'Lantern Oil', price: 6, description: 'Fuel for lanterns', icon: '&#128167;' }
    ],
    trader: [
      { id: 'rare_seed', name: 'Rare Seed', price: 30, description: 'Grows into a rare plant', icon: '&#127793;' },
      { id: 'crystal_shard', name: 'Crystal Shard', price: 40, description: 'A glowing fragment', icon: '&#128142;' },
      { id: 'ancient_coin', name: 'Ancient Coin', price: 50, description: 'A relic from the founding', icon: '&#129689;' },
      { id: 'silk_thread', name: 'Silk Thread', price: 22, description: 'Fine textile material', icon: '&#129525;' },
      { id: 'copper_ingot', name: 'Copper Ingot', price: 18, description: 'Refined copper metal', icon: '&#129704;' }
    ],
    farmer: [
      { id: 'wheat_seed', name: 'Wheat Seeds', price: 5, description: 'Basic crop seeds', icon: '&#127806;' },
      { id: 'flower_seed', name: 'Flower Seeds', price: 8, description: 'Decorative flowers', icon: '&#127804;' },
      { id: 'herb_seed', name: 'Herb Seeds', price: 10, description: 'Medicinal herbs', icon: '&#127807;' },
      { id: 'fertilizer', name: 'Fertilizer', price: 15, description: 'Speeds up growth', icon: '&#128169;' },
      { id: 'seed_wildflower', name: 'Wildflower Seeds', price: 4, description: 'Beautiful wildflowers', icon: '&#127803;' }
    ],
    artisan: [
      { id: 'pigment', name: 'Pigment', price: 12, description: 'Natural color pigment', icon: '&#127912;' },
      { id: 'canvas', name: 'Canvas', price: 15, description: 'For painting masterworks', icon: '&#128444;' },
      { id: 'clay', name: 'Clay', price: 8, description: 'Moldable material', icon: '&#129520;' },
      { id: 'ink_bottle', name: 'Ink Bottle', price: 10, description: 'For writing and drawing', icon: '&#128395;' },
      { id: 'golden_frame', name: 'Golden Frame', price: 35, description: 'Display art beautifully', icon: '&#128444;' }
    ],
    gardener: [
      { id: 'seed_wildflower', name: 'Wildflower Seeds', price: 4, description: 'Beautiful wildflowers', icon: '&#127803;' },
      { id: 'herb_seed', name: 'Herb Seeds', price: 10, description: 'Medicinal herbs', icon: '&#127807;' },
      { id: 'rare_seed', name: 'Rare Seed', price: 30, description: 'Unusual plant variety', icon: '&#127793;' },
      { id: 'fertilizer', name: 'Fertilizer', price: 15, description: 'Speeds up growth', icon: '&#128169;' },
      { id: 'garden_shears', name: 'Garden Shears', price: 18, description: 'For pruning and shaping', icon: '&#9986;' }
    ],
    scholar: [
      { id: 'scroll_blank', name: 'Blank Scroll', price: 8, description: 'For recording knowledge', icon: '&#128220;' },
      { id: 'ink_bottle', name: 'Ink Bottle', price: 10, description: 'For writing', icon: '&#128395;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' },
      { id: 'lens', name: 'Magnifying Lens', price: 25, description: 'For studying fine details', icon: '&#128270;' },
      { id: 'ancient_tome', name: 'Ancient Tome', price: 45, description: 'Contains forgotten wisdom', icon: '&#128214;' }
    ],
    warrior: [
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'training_weight', name: 'Training Weight', price: 15, description: 'For strength training', icon: '&#127947;' },
      { id: 'bandage', name: 'Bandage', price: 8, description: 'First aid supply', icon: '&#129657;' },
      { id: 'arena_token', name: 'Arena Token', price: 20, description: 'Entry to special events', icon: '&#127941;' }
    ],
    musician: [
      { id: 'flute', name: 'Flute', price: 28, description: 'A simple wooden flute', icon: '&#127925;' },
      { id: 'drum', name: 'Drum', price: 22, description: 'A hand drum', icon: '&#129345;' },
      { id: 'bell', name: 'Bell', price: 15, description: 'A clear-toned bell', icon: '&#128276;' },
      { id: 'sheet_music', name: 'Sheet Music', price: 12, description: 'Musical compositions', icon: '&#127926;' }
    ],
    explorer: [
      { id: 'compass', name: 'Compass', price: 20, description: 'Never lose your way', icon: '&#129517;' },
      { id: 'rope', name: 'Rope', price: 12, description: 'For difficult terrain', icon: '&#129526;' },
      { id: 'spyglass', name: 'Spyglass', price: 35, description: 'See far-off landmarks', icon: '&#128269;' },
      { id: 'trail_ration', name: 'Trail Ration', price: 8, description: 'Sustenance for the road', icon: '&#127838;' },
      { id: 'map_fragment', name: 'Map Fragment', price: 15, description: 'Reveals hidden areas', icon: '&#128506;' }
    ],
    healer: [
      { id: 'healing_herb', name: 'Healing Herb', price: 10, description: 'Soothing medicinal plant', icon: '&#127807;' },
      { id: 'bandage', name: 'Bandage', price: 8, description: 'First aid supply', icon: '&#129657;' },
      { id: 'potion_energy', name: 'Energy Potion', price: 25, description: 'Restores energy', icon: '&#129514;' },
      { id: 'herbal_tea', name: 'Herbal Tea', price: 6, description: 'Calming warm drink', icon: '&#127861;' }
    ]
  };

  /**
   * Handle NPC dialog action button clicks
   */
  function handleNPCAction(action, npcData) {
    if (!npcData || !localPlayer) return;

    switch (action) {
      case 'trade':
        var shopItems = NPC_SHOP_ITEMS[npcData.archetype] || NPC_SHOP_ITEMS.merchant;
        if (HUD && HUD.showNPCShop) {
          HUD.showNPCShop(npcData, shopItems, localPlayer.spark, function onBuyItem(itemId) {
            var item = shopItems.find(function(i) { return i.id === itemId; });
            if (!item) return;
            if (localPlayer.spark < item.price) {
              if (HUD) HUD.showNotification('Not enough Spark!', 'error');
              return;
            }
            if (economyLedger && Economy) {
              var result = Economy.spendSpark(economyLedger, localPlayer.id, item.price);
              if (!result.success) {
                if (HUD) HUD.showNotification('Transaction failed', 'error');
                return;
              }
              localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            } else {
              localPlayer.spark -= item.price;
            }
            if (Inventory && playerInventory) {
              Inventory.addItem(playerInventory, item.id, 1);
              if (HUD) {
                HUD.showItemPickup(item.name, 1, item.icon);
                HUD.updateInventoryDisplay(playerInventory);
              }
            }
            if (HUD) {
              HUD.updatePlayerInfo(localPlayer);
              HUD.showNotification('Bought ' + item.name + ' for ' + item.price + ' Spark', 'success');
            }
            if (Audio) Audio.playSound('trade');
            // Refresh shop with updated balance
            HUD.showNPCShop(npcData, shopItems, localPlayer.spark, onBuyItem);
            addRecentActivity('Bought ' + item.name + ' from ' + npcData.name);
          });
        }
        break;

      case 'learn':
        if (HUD) {
          var teachingMsg = '';
          if (typeof NPC_AI !== 'undefined' && NPC_AI.getTeaching) {
            var teaching = NPC_AI.getTeaching(npcData.archetype, {});
            if (teaching) {
              teachingMsg = npcData.name + ' teaches you about ' + teaching.topic + ': "' + teaching.description + '"';
              if (Economy && economyLedger) {
                var teachSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'teach', { complexity: 0.5 });
                localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
                HUD.updatePlayerInfo(localPlayer);
                showSparkPopup(teachSpark);
              }
            } else {
              teachingMsg = npcData.name + ' has nothing more to teach you right now.';
            }
          } else {
            teachingMsg = npcData.name + ' shares some wisdom with you.';
            if (Economy && economyLedger) {
              var teachSpark2 = Economy.earnSpark(economyLedger, localPlayer.id, 'teach', { complexity: 0.3 });
              localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
              HUD.updatePlayerInfo(localPlayer);
              showSparkPopup(teachSpark2);
            }
          }
          HUD.showNotification(teachingMsg, 'info');
          addRecentActivity('Learned from ' + npcData.name);
        }
        break;

      case 'lore':
        if (HUD) {
          var loreMsg = '';
          if (typeof NPC_AI !== 'undefined' && NPC_AI.getLore) {
            var lore = NPC_AI.getLore(npcData.archetype, {});
            if (lore) {
              loreMsg = npcData.name + ' tells you: "' + lore + '"';
            } else {
              loreMsg = npcData.name + ' has shared all their stories with you.';
            }
          } else {
            loreMsg = npcData.name + ' tells you a tale of the founding of ZION.';
          }
          HUD.showNotification(loreMsg, 'info');
          addRecentActivity('Heard lore from ' + npcData.name);
        }
        break;
    }
  }

  /**
   * Handle resource node harvesting
   */
  function handleResourceHarvest(node) {
    if (!World || !Inventory || !playerInventory) return;

    var itemId = World.harvestResource(node);
    if (!itemId) {
      if (HUD) HUD.showNotification('Resource already depleted', 'warning');
      return;
    }

    var itemData = Inventory.getItemData(itemId);
    if (!itemData) return;

    var result = Inventory.addItem(playerInventory, itemId, 1);
    if (result.success) {
      if (HUD) {
        HUD.showItemPickup(itemData.name, 1, itemData.icon);
        HUD.updateInventoryDisplay(playerInventory);
        HUD.updateQuickBar(playerInventory);
      }

      if (economyLedger && Economy) {
        // Apply Warmth bonus to harvest yields (minor, cosmetic-adjacent per Â§5.3)
        var harvestComplexity = 0.5;
        if (Physical && localPlayer.warmth > 0) {
          var warmthBonus = Physical.getWarmthBonus(localPlayer.warmth);
          harvestComplexity = Math.min(1.0, harvestComplexity * warmthBonus);
        }
        var sparkEarned = Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: harvestComplexity });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(sparkEarned);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'gardening', 5);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Gardening skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      // Emit harvest success particles (green/gold upward burst)
      if (World && World.emitParticles && node.position) {
        var harvestPos = { x: node.position.x, y: node.position.y + 1, z: node.position.z };
        World.emitParticles('sparkle', harvestPos, 8);
      }

      // Show floating pickup text
      if (sceneContext && sceneContext.camera && sceneContext.renderer && node.position && window.THREE) {
        var textPos = new window.THREE.Vector3(node.position.x, node.position.y + 2, node.position.z);
        textPos.project(sceneContext.camera);
        var sx = (textPos.x * 0.5 + 0.5) * sceneContext.renderer.domElement.clientWidth;
        var sy = (-textPos.y * 0.5 + 0.5) * sceneContext.renderer.domElement.clientHeight;
        showFloatingText('+1 ' + itemData.name, sx, sy);
      }

      if (Quests) {
        var updated = Quests.updateQuestProgress(localPlayer.id, 'collect', { item: itemId, amount: 1 });
        if (updated.length > 0 && HUD) {
          updated.forEach(function(quest) {
            HUD.showQuestProgress('Quest progress: ' + quest.title);
          });
        }
      }

      // Roll for bonus zone loot drop
      if (Inventory.rollHarvestDrop) {
        var luck = Physical && localPlayer.warmth > 0 ? Physical.getWarmthBonus(localPlayer.warmth) : 1.0;
        var bonusDrop = Inventory.rollHarvestDrop(currentZone, luck);
        if (bonusDrop) {
          var bonusResult = Inventory.addItem(playerInventory, bonusDrop.id, 1);
          if (bonusResult.success) {
            var bonusData = Inventory.getItemData(bonusDrop.id);
            if (bonusData && HUD) {
              setTimeout(function() {
                HUD.showItemPickup(bonusData.name, 1, bonusData.icon);
              }, 500);
            }
          }
        }
      }

      // Apply economic event modifier to harvest spark
      if (Economy && Economy.applyEventModifier && economyLedger) {
        var eventBonus = Economy.applyEventModifier(0, 'harvest');
        if (eventBonus > 0) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: 0.2 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
      }

      // Apply seasonal bonus to harvest
      var harvestSeasonBonus = getSeasonalBonus('garden');
      if (harvestSeasonBonus > 1.0 && Economy && economyLedger) {
        var bonusSpark = Math.round((harvestSeasonBonus - 1.0) * 5);
        if (bonusSpark > 0) {
          Economy.earnSpark(economyLedger, localPlayer.id, 'harvest', { complexity: 0.1 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
        }
      }

      // Track harvest achievement
      trackAchievement('harvest', { item: itemId, zone: currentZone });

      if (Audio) Audio.playSound('harvest');

      // Track activity
      addRecentActivity('Collected ' + itemData.name);
    } else {
      if (HUD) HUD.showNotification(result.message, 'warning');
    }
  }

  /**
   * Handle crafting
   */
  function handleCraft(recipeId) {
    if (!Inventory || !playerInventory) return;

    var result = Inventory.craftItem(playerInventory, recipeId);
    if (result.success) {
      if (HUD) {
        HUD.showNotification(result.message, 'success');
        HUD.updateInventoryDisplay(playerInventory);
        HUD.updateCraftingDisplay(playerInventory);
        HUD.updateQuickBar(playerInventory);
      }

      if (economyLedger && Economy && result.sparkEarned) {
        var craftSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'craft', { complexity: result.sparkEarned / 50 });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(craftSpark);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'crafting', 10);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Crafting skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (Quests) {
        Quests.updateQuestProgress(localPlayer.id, 'craft', { item: result.output.itemId, amount: result.output.count });
      }

      // Track craft achievement
      trackAchievement('craft', { item: result.output.itemId, recipe: recipeId });

      // Emit craft success particles (orange/white sparkle at player position)
      if (World && World.emitParticles && localPlayer && localPlayer.position) {
        var craftPos = { x: localPlayer.position.x, y: localPlayer.position.y + 1.5, z: localPlayer.position.z };
        World.emitParticles('fire', craftPos, 10);
      }

      if (Audio) Audio.playSound('build');
    } else {
      if (HUD) HUD.showNotification(result.message, 'error');
    }
  }

  /**
   * Handle compose (artwork creation)
   */
  function handleGuildCreate(guildData) {
    if (!Guilds || !localPlayer || !Economy || !economyLedger) return;

    // Check if player has enough Spark
    var balance = Economy.getBalance(economyLedger, localPlayer.id);
    if (balance < 100) {
      if (HUD) {
        HUD.showNotification('Not enough Spark to create guild (need 100)', 'error');
      }
      return;
    }

    var result = Guilds.createGuild(
      localPlayer.id,
      guildData.name,
      guildData.tag,
      guildData.type,
      guildData.description
    );

    if (result.success) {
      // Deduct cost
      Economy.debit(economyLedger, localPlayer.id, result.cost, 'Guild creation');

      if (HUD) {
        HUD.showNotification('Guild created: [' + guildData.tag + '] ' + guildData.name, 'success');
        HUD.updateGuildTag(guildData.tag);

        // Update player info to show new balance
        localPlayer.spark = balance - result.cost;
        HUD.updatePlayerInfo(localPlayer);

        // Show guild panel
        HUD.showGuildPanel(result.guild, { id: localPlayer.id });
      }

      addRecentActivity('Founded [' + guildData.tag + '] ' + guildData.name);
    } else {
      if (HUD) {
        HUD.showNotification('Failed to create guild: ' + result.error, 'error');
      }
    }
  }

  // Global guild action handler for panel buttons
  if (typeof window !== 'undefined') {
    window.handleGuildAction = function(action, data) {
      if (!Guilds || !localPlayer) return;

      switch (action) {
        case 'leave':
          var result = Guilds.leaveGuild(data, localPlayer.id);
          if (result.success) {
            if (HUD) {
              HUD.showNotification('You left the guild', 'info');
              HUD.updateGuildTag('');
            }
            addRecentActivity('Left guild');
          } else {
            if (HUD) {
              HUD.showNotification('Failed to leave guild: ' + result.error, 'error');
            }
          }
          break;
      }
    };
  }

  function handleComposeAction(composeData) {
    if (!Creation || !localPlayer) return;

    // Handle music composition (from new compose panel with notes/instrument)
    if (composeData.notes && composeData.instrument) {
      var noteNames = composeData.notes.map(function(n) { return n.note; }).join('-');
      var msg = {
        type: 'compose',
        from: localPlayer.id,
        timestamp: Date.now(),
        nonce: Math.random().toString(36).substr(2, 9),
        payload: {
          composeType: 'music',
          title: 'Melody (' + composeData.notes.length + ' notes)',
          content: JSON.stringify({ notes: composeData.notes, instrument: composeData.instrument }),
          zone: currentZone,
          position: localPlayer.position
        }
      };

      var result = Creation.handleCompose(msg, gameState);
      if (result.success) {
        if (HUD) HUD.showNotification('Composed a melody with ' + composeData.notes.length + ' notes!', 'success');
        // Play the composition for nearby players
        if (HUD.playComposition) HUD.playComposition(composeData.notes);

        if (economyLedger && Economy) {
          var sparkAmount = Math.min(50, 5 + composeData.notes.length * 2);
          var composeSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'compose', { complexity: sparkAmount / 50 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(composeSpark);
        }

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 20);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        if (Audio) Audio.playSound('chat');
        addRecentActivity('Composed a melody with ' + composeData.notes.length + ' notes');
      }
      return;
    }

    var msg = {
      type: 'compose',
      from: localPlayer.id,
      timestamp: Date.now(),
      nonce: Math.random().toString(36).substr(2, 9),
      payload: {
        composeType: composeData.type,
        title: composeData.title,
        content: composeData.content,
        zone: currentZone,
        position: localPlayer.position
      }
    };

    var result = Creation.handleCompose(msg, gameState);
    if (result.success) {
      if (HUD) {
        HUD.showNotification('Created ' + composeData.type + ': ' + composeData.title, 'success');
      }

      if (economyLedger && Economy && result.sparkReward) {
        var composeSpark2 = Economy.earnSpark(economyLedger, localPlayer.id, 'compose', { complexity: result.sparkReward / 50 });
        if (localPlayer) {
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(composeSpark2);
        }
      }

      if (Mentoring) {
        var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 15);
        if (xpResult.leveledUp && HUD) {
          HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
          emitLevelUpParticles();
        }
      }

      if (Audio) Audio.playSound('chat');

      addRecentActivity('Created ' + composeData.type + ': ' + composeData.title);
    } else {
      if (HUD) HUD.showNotification(result.error, 'error');
    }
  }

  /**
   * Handle governance actions (elections, steward policies, etc.)
   */
  function handleGovernanceAction(action, data) {
    if (!Social || !Zones || !localPlayer) return;

    switch (action) {
      case 'startElection':
        // Start election in current zone
        var zoneId = data.zoneId || currentZone;
        var reputation = Social.getReputation(localPlayer.id);

        // Check if player meets requirements
        if (reputation.tier !== 'Respected' && reputation.tier !== 'Honored' && reputation.tier !== 'Elder') {
          if (HUD) HUD.showNotification('Must be Respected tier or higher to start an election', 'error');
          return;
        }

        // For now, create a simple election with the local player as a candidate
        // In a full implementation, this would open a dialog to add candidates
        var candidates = [localPlayer.id];
        var election = Zones.startElection(zoneId, candidates);

        if (HUD) {
          HUD.showNotification('Election started! Voting ends in 48 hours.', 'success');
          HUD.hideGovernancePanel();
          HUD.showGovernancePanel(zoneId, localPlayer);
        }

        // Broadcast election start to network
        if (Network && Protocol) {
          var msg = Protocol.create.election_start(localPlayer.id, {
            zoneId: zoneId,
            electionId: election.id,
            candidates: candidates
          });
          Network.broadcastMessage(msg);
        }
        break;

      case 'vote':
        var electionId = data.electionId;
        var candidateId = data.candidateId;

        var voteResult = Zones.castVote(electionId, localPlayer.id, candidateId);
        if (voteResult.success) {
          if (HUD) {
            HUD.showNotification('Vote cast for ' + candidateId, 'success');
            HUD.hideGovernancePanel();
            HUD.showGovernancePanel(currentZone, localPlayer);
          }

          // Broadcast vote to network
          if (Network && Protocol) {
            var msg = Protocol.create.election_vote(localPlayer.id, {
              electionId: electionId,
              candidateId: candidateId
            });
            Network.broadcastMessage(msg);
          }
        } else {
          if (HUD) HUD.showNotification(voteResult.error, 'error');
        }
        break;

      case 'savePolicies':
        var zoneId = data.zoneId || currentZone;

        // Set welcome message
        if (data.welcomeMessage !== undefined) {
          var msgResult = Zones.setWelcomeMessage(zoneId, localPlayer.id, data.welcomeMessage);
          if (!msgResult.success) {
            if (HUD) HUD.showNotification(msgResult.error, 'error');
            return;
          }
        }

        // Set policies
        if (data.buildingRequiresApproval !== undefined) {
          Zones.setZonePolicy(zoneId, localPlayer.id, 'buildingRequiresApproval', data.buildingRequiresApproval);
        }
        if (data.chatModerated !== undefined) {
          Zones.setZonePolicy(zoneId, localPlayer.id, 'chatModerated', data.chatModerated);
        }

        if (HUD) {
          HUD.showNotification('Zone policies updated', 'success');
          HUD.hideGovernancePanel();
          HUD.showGovernancePanel(zoneId, localPlayer);
        }

        // Award reputation for steward action
        Social.adjustReputation(localPlayer.id, 'zone_steward_action', { zoneId: zoneId });

        // Broadcast policy changes to network
        if (Network && Protocol) {
          var msg = Protocol.create.steward_set_policy(localPlayer.id, {
            zoneId: zoneId,
            policies: {
              welcomeMessage: data.welcomeMessage,
              buildingRequiresApproval: data.buildingRequiresApproval,
              chatModerated: data.chatModerated
            }
          });
          Network.broadcastMessage(msg);
        }
        break;
    }
  }

  /**
   * Handle build mode actions
   */
  var buildModeActive = false;
  var BUILD_TYPES = [
    'bench', 'lantern', 'signpost', 'fence', 'planter',
    'campfire', 'archway', 'table', 'barrel', 'crate'
  ];
  var BUILD_COSTS = {
    bench: 15, lantern: 10, signpost: 5, fence: 8, planter: 12,
    campfire: 20, archway: 30, table: 15, barrel: 10, crate: 8
  };

  function handleBuildAction(data) {
    if (data.mode !== undefined) {
      // Toggle build mode
      buildModeActive = data.mode;

      if (buildModeActive) {
        if (World && World.enterBuildMode && sceneContext) {
          World.enterBuildMode(sceneContext);
        }
        if (HUD && HUD.showBuildToolbar) {
          HUD.showBuildToolbar();
        }
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Build mode activated - Click to place structures', 'info');
        }
      } else {
        if (World && World.exitBuildMode && sceneContext) {
          World.exitBuildMode(sceneContext);
        }
        if (HUD && HUD.hideBuildToolbar) {
          HUD.hideBuildToolbar();
        }
        if (HUD && HUD.showNotification) {
          HUD.showNotification('Build mode deactivated', 'info');
        }
      }
    } else if (data.action === 'place') {
      // Place structure
      if (World && World.confirmPlacement && sceneContext && localPlayer) {
        var result = World.confirmPlacement(sceneContext, localPlayer.position, currentZone);
        if (result && result.error) {
          if (HUD && HUD.showNotification) {
            HUD.showNotification(result.error, 'error');
          }
        } else if (result) {
          // Deduct Spark cost for building
          var buildCost = BUILD_COSTS[result.type] || 10;
          if (economyLedger && Economy) {
            var spendResult = Economy.spendSpark(economyLedger, localPlayer.id, buildCost);
            if (!spendResult.success) {
              if (HUD && HUD.showNotification) {
                HUD.showNotification('Not enough Spark! Need ' + buildCost + ' Spark to build ' + result.type, 'error');
              }
              // Remove the placed structure since we can't afford it
              if (World && World.removeLastPlaced) {
                World.removeLastPlaced(sceneContext);
              }
              return;
            }
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
          }

          if (HUD && HUD.showNotification) {
            HUD.showNotification('Built ' + result.type + ' (-' + buildCost + ' Spark)', 'success');
          }

          // Award building XP
          if (Economy) {
            var buildSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'build', { complexity: 0.3 });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            showSparkPopup(buildSpark);
          }

          if (Mentoring) {
            var xpResult = Mentoring.addSkillXP(localPlayer.id, 'building', 12);
            if (xpResult.leveledUp && HUD) {
              HUD.showNotification('Building skill increased to ' + xpResult.newLevelName, 'success');
              emitLevelUpParticles();
            }
          }

          // Broadcast to network
          if (Network && Protocol) {
            var buildMsg = Protocol.create.build(localPlayer.id, {
              structureType: result.type,
              position: result.position,
              rotation: result.rotation || 0,
              zone: currentZone
            });
            Network.broadcastMessage(buildMsg);
          }

          // Track build achievement
          trackAchievement('build', { type: result.type, zone: currentZone });

          // Save structure to state
          if (gameState) {
            if (!gameState.structures) gameState.structures = [];
            gameState.structures.push({
              id: 'struct_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
              type: result.type,
              position: result.position,
              rotation: result.rotation || 0,
              zone: currentZone,
              builder: localPlayer.id,
              ts: Date.now()
            });
          }
        }
      }
    } else if (data.action === 'rotate') {
      // Rotate build preview
      if (World && World.rotateBuildPreview) {
        World.rotateBuildPreview(Math.PI / 4); // 45 degrees
      }
    } else if (data.action === 'selectType') {
      // Select build type by number key
      var typeIndex = data.typeIndex;
      if (typeIndex >= 0 && typeIndex < BUILD_TYPES.length) {
        var buildType = BUILD_TYPES[typeIndex];
        if (World && World.setBuildType) {
          World.setBuildType(buildType);
        }
        if (HUD && HUD.updateBuildToolbar) {
          HUD.updateBuildToolbar(buildType);
        }
      }
    }
  }

  /**
   * Handle local action (created by this client)
   */
  function handleLocalAction(type, payload) {
    let msg = null;

    switch (type) {
      case 'move':
        localPlayer.position = payload.position;
        localPlayer.zone = payload.zone;
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('move');
        break;

      case 'chat':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openChat');
        // Check for emote chat commands
        var message = payload.message;
        var emoteMatch = message.match(/^\/(wave|dance|bow|cheer|meditate|point)$/);
        if (emoteMatch) {
          // Trigger emote instead of chat
          handleLocalAction('emote', { type: emoteMatch[1] });
          return;
        }

        msg = Protocol.create.chat(localPlayer.id, { message: message, zone: currentZone, position: localPlayer.position });

        if (Mentoring) {
          var xpResult = Mentoring.addSkillXP(localPlayer.id, 'social', 3);
          if (xpResult.leveledUp && HUD) {
            HUD.showNotification('Social skill increased to ' + xpResult.newLevelName, 'success');
            emitLevelUpParticles();
          }
        }

        // Broadcast player chat to NPCs for reaction
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'player_action', data: {
            playerId: localPlayer.id, action: 'chat',
            position: localPlayer.position, message: message
          }});
        }
        break;

      case 'emote':
        // Handle emote action
        if (World && sceneContext && localPlayer) {
          var playerMesh = World.getPlayerMesh ? World.getPlayerMesh(sceneContext, localPlayer.id) : null;
          if (playerMesh && NPCs && NPCs.playEmoteAnimation) {
            NPCs.playEmoteAnimation(playerMesh, payload.type);
          }
          if (HUD && HUD.showEmoteBubble) {
            HUD.showEmoteBubble(localPlayer.id, payload.type);
          }
          if (Audio) {
            Audio.playSound('chat');
          }
        }
        // Create and broadcast emote message
        msg = {
          type: 'emote',
          from: localPlayer.id,
          timestamp: Date.now(),
          nonce: Math.random().toString(36).substr(2, 9),
          payload: { emoteType: payload.type }
        };
        break;

      case 'toggleEmoteMenu':
        if (HUD) {
          var emoteMenuEl = document.getElementById('emote-menu');
          if (emoteMenuEl) {
            HUD.hideEmoteMenu();
          } else {
            HUD.showEmoteMenu();
          }
        }
        break;

      case 'toggleMap':
        if (HUD && localPlayer) {
          var mapEl = document.getElementById('world-map-overlay');
          if (mapEl) {
            HUD.hideWorldMap();
          } else {
            var npcPositions = NPCs && NPCs.getNPCPositions ? NPCs.getNPCPositions() : [];
            var landmarks = [];
            HUD.showWorldMap(localPlayer.position, npcPositions, landmarks, function(zoneId) {
              handleLocalAction('fastTravel', { zone: zoneId });
            });
          }
        }
        break;

      case 'fastTravel':
        if (localPlayer && World && data && data.zone) {
          var targetZone = data.zone;
          var Zones = typeof require !== 'undefined' ? require('./zones') : window.Zones;
          var zoneInfo = Zones && Zones.ZONES ? Zones.ZONES[targetZone] : null;
          if (!zoneInfo) break;

          // Use FastTravel for cost calculation if available
          if (typeof FastTravel !== 'undefined' && FastTravel.calculateTravelCost && economyLedger) {
            var cost = FastTravel.calculateTravelCost(
              localPlayer.position,
              { x: zoneInfo.cx, z: zoneInfo.cz }
            );
            if (cost > 0 && economyLedger.balances[localPlayer.id] < cost) {
              if (HUD) HUD.showNotification('Not enough Spark to travel (need ' + cost + ')', 'error');
              break;
            }
            if (cost > 0) economyLedger.balances[localPlayer.id] -= cost;
          }
          // Track as recent location
          if (typeof FastTravel !== 'undefined' && FastTravel.addRecentLocation) {
            FastTravel.addRecentLocation(localPlayer.id, {
              id: targetZone, name: targetZone, category: 'zone',
              x: localPlayer.position.x, z: localPlayer.position.z
            });
          }

          var oldZone = currentZone;
          currentZone = targetZone;

          // Fade transition with teleport at peak
          if (World.fadeTransition) {
            World.fadeTransition(function() {
              // Teleport player to zone center
              var tx = zoneInfo.cx;
              var tz = zoneInfo.cz;
              var ty = World.getTerrainHeight ? World.getTerrainHeight(tx, tz) : 0;
              localPlayer.position.x = tx;
              localPlayer.position.y = ty;
              localPlayer.position.z = tz;

              // Move camera to follow
              if (sceneContext && sceneContext.camera) {
                sceneContext.camera.position.set(tx, ty + 5, tz + 12);
                sceneContext.camera.lookAt(tx, ty + 1.5, tz);
              }
            });
          }

          // Play zone entry sound
          if (Audio && Audio.playSound) Audio.playSound('zone_enter');

          // Update all zone context
          if (HUD) {
            HUD.updateZoneLabel(currentZone);
            HUD.showNotification('Traveled to ' + currentZone.charAt(0).toUpperCase() + currentZone.slice(1), 'info');
          }
          if (Audio) {
            Audio.playAmbient(currentZone);
            if (Audio.setZoneAmbient) Audio.setZoneAmbient(currentZone);
            if (Audio.updateMusic) Audio.updateMusic(currentZone, currentTimePeriod);
            if (Audio.playPianoAccent && !visitedZones[currentZone]) {
              Audio.playPianoAccent('zone_discovery');
            }
          }
          visitedZones[currentZone] = true;
          if (NPCs) NPCs.reloadZoneNPCs(sceneContext, currentZone, localPlayer.position);
          if (World && World.clearInteractiveObjects && World.spawnZoneInteractives) {
            World.clearInteractiveObjects(sceneContext);
            World.spawnZoneInteractives(sceneContext, currentZone);
          }
          addRecentActivity('Fast traveled to ' + currentZone);

          // Send warp protocol message
          if (Network && Network.broadcastMessage) {
            Network.broadcastMessage({
              type: 'warp',
              payload: {
                zone: currentZone,
                position: { x: localPlayer.position.x, y: localPlayer.position.y, z: localPlayer.position.z, zone: currentZone }
              }
            });
          }

          // Start cinematic camera swoop
          startZoneCinematic();
        }
        break;

      case 'togglePhotoMode':
        togglePhotoMode();
        break;

      case 'toggleSettings':
        if (HUD) {
          // Close any open panels/dialogs first
          var closedSomething = false;
          if (HUD.hideNPCDialog) {
            var npcDlg = document.getElementById('npc-dialog');
            if (npcDlg) { HUD.hideNPCDialog(); closedSomething = true; }
          }
          if (HUD.hideNPCShop) {
            var npcShop = document.getElementById('npc-shop-panel');
            if (npcShop) { HUD.hideNPCShop(); closedSomething = true; }
          }
          if (HUD.hideQuestOffer) {
            var questOffer = document.getElementById('quest-offer-panel');
            if (questOffer) { HUD.hideQuestOffer(); closedSomething = true; }
          }
          if (HUD.hideQuestLog) {
            var questLog = document.getElementById('quest-log-panel');
            if (questLog) { HUD.hideQuestLog(); closedSomething = true; }
          }
          if (HUD.hideWorldMap) {
            var worldMap = document.getElementById('world-map-overlay');
            if (worldMap) { HUD.hideWorldMap(); closedSomething = true; }
          }
          // Only toggle settings if nothing else was closed
          if (!closedSomething) {
            var settingsEl = document.getElementById('settings-menu-overlay');
            if (settingsEl) {
              HUD.hideSettingsMenu();
            } else {
              HUD.showSettingsMenu();
            }
          }
        }
        break;

      case 'toggleProfile':
        if (HUD && localPlayer) {
          var profileEl = document.getElementById('player-profile-panel') || document.getElementById('profile-panel');
          if (profileEl) {
            if (HUD.hideProfilePanel) HUD.hideProfilePanel();
            else if (HUD.hidePlayerProfile) HUD.hidePlayerProfile();
          } else {
            // Gather player stats
            var playerData = {
              name: localPlayer.name || 'Player',
              zone: currentZone,
              sparkBalance: economyLedger ? Economy.getBalance(economyLedger, localPlayer.id) : 0,
              playTimeSeconds: getPlayTimeSeconds(),
              itemsCollected: playerInventory ? playerInventory.items.length : 0,
              questsCompleted: Quests ? Quests.getCompletedQuests(localPlayer.id).length : 0,
              questsActive: Quests ? Quests.getActiveQuests(localPlayer.id).length : 0,
              npcsMet: NPCs && NPCs.getMetNPCs ? NPCs.getMetNPCs(localPlayer.id).length : 0,
              zonesDiscovered: Exploration ? Exploration.getDiscoveredZones(localPlayer.id, gameState).length : 1,
              structuresBuilt: Creation ? Creation.getPlayerStructures(localPlayer.id).length : 0,
              recentActivities: getRecentActivities(),
              reputationTier: Social && Social.getReputation ? Social.getReputation(localPlayer.id).tier : 'Newcomer'
            };

            // Gather skill data
            var skillData = {};
            if (Mentoring && Mentoring.getPlayerSkills) {
              skillData = Mentoring.getPlayerSkills(localPlayer.id);
            }

            // Use enhanced profile panel if available
            if (HUD.showProfilePanel) {
              HUD.showProfilePanel(playerData, skillData);
            } else if (HUD.showPlayerProfile) {
              HUD.showPlayerProfile(playerData);
            }
          }
        }
        break;

      case 'toggleGuild':
        if (HUD && Guilds && localPlayer) {
          var guildPanelEl = document.getElementById('guild-panel');
          if (guildPanelEl) {
            HUD.hideGuildPanel();
          } else {
            var playerGuild = Guilds.getPlayerGuild(localPlayer.id);
            if (playerGuild) {
              HUD.showGuildPanel(playerGuild, { id: localPlayer.id });
              // Update guild tag in HUD
              HUD.updateGuildTag(playerGuild.tag);
            } else {
              // Show guild creation form if not in a guild
              HUD.showGuildCreate(function(guildData) {
                handleGuildCreate(guildData);
              });
            }
          }
        }
        break;

      case 'toggleSkills':
        if (HUD && Mentoring && localPlayer) {
          var skillsPanelEl = document.getElementById('skills-panel');
          if (skillsPanelEl) {
            HUD.hideSkillsPanel();
          } else {
            var skillsData = Mentoring.getPlayerSkills(localPlayer.id);
            HUD.showSkillsPanel(skillsData);
          }
        }
        break;

      case 'toggleCompose':
        if (HUD && Creation && localPlayer) {
          var composePanelEl = document.getElementById('compose-panel');
          if (composePanelEl) {
            HUD.hideComposePanel();
          } else {
            HUD.showComposePanel(function(composeData) {
              handleComposeAction(composeData);
            });
          }
        }
        break;

      case 'interact':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('interact');
        // Check for nearby NPCs first
        if (NPCs && NPCs.interactWithNPC && localPlayer) {
          var npcResponse = NPCs.interactWithNPC(localPlayer.position.x, localPlayer.position.z, localPlayer.id);
          if (npcResponse) {
            // Show rich NPC interaction dialog
            if (HUD && HUD.showNPCDialog) {
              HUD.showNPCDialog(npcResponse);
            } else if (HUD) {
              HUD.showNotification(npcResponse.name + ': "' + npcResponse.message + '"', 'info');
            }

            // Handle quest interactions
            if (Quests && npcResponse.questInfo) {
              var questInfo = npcResponse.questInfo;

              if (questInfo.state === 'available') {
                // Show quest offer dialog
                if (HUD && HUD.showQuestOffer) {
                  HUD.showQuestOffer(questInfo.quest, { name: npcResponse.name, archetype: npcResponse.archetype }, localPlayer.id);
                }
              } else if (questInfo.state === 'complete') {
                // Turn in quest
                var result = Quests.completeQuest(localPlayer.id, questInfo.quest.id, gameState);
                if (result.success && HUD) {
                  HUD.showQuestComplete(result.quest, result.rewards);
                  // Update player spark display
                  localPlayer.spark += result.rewards.spark;
                  HUD.updatePlayerInfo(localPlayer);
                  showSparkPopup(result.rewards.spark);
                  // Track activity
                  addRecentActivity('Completed quest: ' + result.quest.title);
                  // Emit quest complete particles (rainbow burst - use sparkle and fountain for variety)
                  if (World && World.emitParticles && localPlayer && localPlayer.position) {
                    var questPos = { x: localPlayer.position.x, y: localPlayer.position.y + 2, z: localPlayer.position.z };
                    World.emitParticles('sparkle', questPos, 15);
                    World.emitParticles('fountain', questPos, 15);
                  }
                  // Piano accent for quest completion
                  if (Audio && Audio.playPianoAccent) Audio.playPianoAccent('quest_complete');
                  // Add quest completion screen effects
                  triggerCameraShake(0.2, 0.3);
                  triggerScreenFlash('#DAA520', 0.4);
                }
              }

              // Update quest progress for NPC interaction
              Quests.updateQuestProgress(localPlayer.id, 'talk_npc', { npcId: npcResponse.id });
            }

            if (Audio) Audio.playSound('chat');
            // Track NPC interaction achievement
            trackAchievement('npc_talk', { npcId: npcResponse.id, npcName: npcResponse.name });
            // Track activity
            addRecentActivity('Talked to ' + npcResponse.name);
            // Broadcast player interaction to other NPCs
            if (NPCs.broadcastEvent) {
              NPCs.broadcastEvent({ type: 'player_action', data: {
                playerId: localPlayer.id, action: 'interact_npc',
                position: localPlayer.position, targetNPC: npcResponse.id
              }});
            }
            break;
          }
        }
        // No NPC nearby â€” try interactive objects (benches, campfires, etc.)
        if (World && World.getInteractiveAtPosition && localPlayer) {
          var nearbyObj = World.getInteractiveAtPosition(localPlayer.position.x, localPlayer.position.z, 4);
          if (nearbyObj) {
            var objResult = World.interactWithObject(nearbyObj.id);
            if (objResult) {
              if (HUD) HUD.showNotification(objResult.message, 'info');
              if (Audio) Audio.playSound('chat');

              // Special actions for certain object types
              if (objResult.action === 'rest' || objResult.action === 'sit' || objResult.action === 'socialize') {
                // Resting recovers mood/energy
                addRecentActivity('Resting at ' + objResult.type.replace(/_/g, ' '));
              } else if (objResult.action === 'study' || objResult.action === 'access_lore') {
                if (Mentoring) {
                  var loreXP = Mentoring.addSkillXP(localPlayer.id, 'lore', 5);
                  if (loreXP.leveledUp && HUD) {
                    HUD.showNotification('Lore skill increased to ' + loreXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Studied at ' + objResult.type.replace(/_/g, ' '));
              } else if (objResult.action === 'practice_combat') {
                if (Mentoring) {
                  var combatXP = Mentoring.addSkillXP(localPlayer.id, 'combat', 5);
                  if (combatXP.leveledUp && HUD) {
                    HUD.showNotification('Combat skill increased to ' + combatXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Trained at combat dummy');
              } else if (objResult.action === 'create_art' || objResult.action === 'play_music') {
                if (Mentoring) {
                  var craftXP = Mentoring.addSkillXP(localPlayer.id, 'crafting', 5);
                  if (craftXP.leveledUp && HUD) {
                    HUD.showNotification('Crafting skill increased to ' + craftXP.newLevelName, 'success');
                    emitLevelUpParticles();
                  }
                }
                addRecentActivity('Created at ' + objResult.type.replace(/_/g, ' '));
              }

              trackAchievement('use_object', { type: objResult.type });
              break;
            }
          }
        }
        // No NPC or object nearby â€” try harvesting
        msg = Protocol.create.harvest(localPlayer.id, 10);
        // Update quest progress for harvest
        if (Quests) {
          var updated = Quests.updateQuestProgress(localPlayer.id, 'collect', { item: 'resource', amount: 1 });
          if (updated.length > 0 && HUD) {
            updated.forEach(function(quest) {
              HUD.showQuestProgress('Quest progress: ' + quest.title);
            });
          }
        }
        // Broadcast harvest action to NPCs
        if (NPCs && NPCs.broadcastEvent) {
          NPCs.broadcastEvent({ type: 'player_action', data: {
            playerId: localPlayer.id, action: 'harvest',
            position: localPlayer.position
          }});
        }
        break;

      case 'toggle_quest_log':
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openQuests');
        // Toggle quest log panel
        if (HUD && Quests && localPlayer) {
          var questLogEl = document.getElementById('quest-log-panel');
          if (questLogEl) {
            HUD.hideQuestLog();
          } else {
            var questLog = Quests.getQuestLog(localPlayer.id, { level: 0 });
            HUD.showQuestLog(questLog, localPlayer.id);
          }
        }
        break;

      case 'toggleInventory':
        if (HUD && playerInventory) {
          HUD.toggleInventoryPanel();
          HUD.updateInventoryDisplay(playerInventory);
        }
        if (HUD && HUD.advanceTutorial) HUD.advanceTutorial('openInventory');
        break;

      case 'toggleCrafting':
        if (HUD && playerInventory) {
          HUD.toggleCraftingPanel();
          HUD.updateCraftingDisplay(playerInventory);
        }
        break;

      case 'toggleGovernance':
        if (HUD && localPlayer && Social && Zones) {
          // Initialize governance panel with callback
          if (!HUD.initGovernancePanel) {
            HUD.initGovernancePanel(handleGovernanceAction);
          }
          HUD.toggleGovernancePanel(currentZone, localPlayer);
        }
        break;

      case 'toggleAchievements':
        if (HUD && Quests && localPlayer) {
          var achievementPanelEl = document.getElementById('achievement-panel');
          if (achievementPanelEl) {
            if (HUD.hideAchievementPanel) HUD.hideAchievementPanel();
          } else {
            if (HUD.showAchievementPanel) HUD.showAchievementPanel(localPlayer.id);
          }
        }
        break;

      case 'toggleAuctions':
      case 'toggleAuctionHouse':
        if (HUD && Economy && localPlayer) {
          if (HUD.toggleAuctionHousePanel) {
            HUD.toggleAuctionHousePanel(economyLedger, localPlayer.id, playerInventory);
          } else if (HUD.showAuctionHousePanel) {
            HUD.showAuctionHousePanel(economyLedger, localPlayer.id, playerInventory);
          }
        }
        break;

      case 'toggleLoreJournal':
        if (HUD && Exploration && localPlayer) {
          var lorePanelEl = document.getElementById('lore-journal-panel');
          if (lorePanelEl) {
            if (HUD.hideLoreJournal) HUD.hideLoreJournal();
          } else {
            if (HUD.showLoreJournal) HUD.showLoreJournal(localPlayer.id, gameState);
          }
        }
        break;

      case 'toggleDiscoveryLog':
        if (HUD && Exploration && localPlayer) {
          var discoveryLogEl = document.getElementById('discovery-log-overlay');
          if (discoveryLogEl) {
            HUD.hideDiscoveryLog();
          } else {
            var discoveries = Exploration.getDiscoveries ? Exploration.getDiscoveries(localPlayer.id, gameState) : [];
            HUD.showDiscoveryLog(discoveries);
          }
        }
        break;

      case 'toggleLoreBook':
        if (HUD && localPlayer) {
          var loreBookEl = document.getElementById('lore-book-overlay');
          if (loreBookEl) {
            HUD.hideLoreBook();
          } else {
            var loreEntries = [];
            HUD.showLoreBook(loreEntries);
          }
        }
        break;

      case 'useQuickSlot':
        if (playerInventory && Inventory) {
          var slotIndex = payload.slot; // 0-4
          var qbSlotIdx = playerInventory.quickBar ? playerInventory.quickBar[slotIndex] : slotIndex;
          var items = Inventory.getInventory(playerInventory);
          var slotItem = items[qbSlotIdx];
          if (slotItem) {
            if (slotItem.type === 'food') {
              // Consume food - remove 1 and show notification
              Inventory.removeItem(playerInventory, slotItem.itemId, 1);
              if (HUD) HUD.showNotification('Ate ' + slotItem.icon + ' ' + slotItem.name);
              // Award small Spark for eating
              if (Economy) Economy.earnSpark(localPlayer.id, 'daily_login', {});
              if (HUD && HUD.updateInventoryDisplay) {
                HUD.updateInventoryDisplay(playerInventory);
                HUD.updateQuickBar(playerInventory);
              }
            } else if (slotItem.type === 'tools') {
              // Equip tool - show notification
              if (HUD) HUD.showNotification('Equipped ' + slotItem.icon + ' ' + slotItem.name);
            } else {
              // Other items - show info
              if (HUD) HUD.showNotification(slotItem.icon + ' ' + slotItem.name + ': ' + (slotItem.description || 'An item'));
            }
          } else {
            if (HUD) HUD.showNotification('Quick slot ' + (slotIndex + 1) + ' is empty');
          }
        }
        break;

      case 'click':
        // Raycasting for resource node harvesting
        if (raycaster && sceneContext && sceneContext.camera && World) {
          var node = World.getResourceNodeAtMouse(raycaster, sceneContext.camera, payload.x, payload.y);
          if (node) {
            handleResourceHarvest(node);
          }
        }
        break;

      case 'initiate_trade':
        // Initiate trade with nearest player
        if (Trading && gameState && State && HUD) {
          var players = State.getPlayers(gameState);
          var nearbyPlayers = players
            .filter(function(p) {
              return p.id !== localPlayer.id && p.zone === currentZone;
            })
            .map(function(p) {
              var dx = p.position.x - localPlayer.position.x;
              var dz = p.position.z - localPlayer.position.z;
              var distance = Math.sqrt(dx * dx + dz * dz);
              return { player: p, distance: distance };
            })
            .sort(function(a, b) { return a.distance - b.distance; });

          if (nearbyPlayers.length > 0 && nearbyPlayers[0].distance < 10) {
            var targetPlayer = nearbyPlayers[0].player;
            var result = Trading.requestTrade(localPlayer.id, targetPlayer.id, localPlayer.position);
            if (result.success) {
              HUD.showNotification('Trade request sent to ' + targetPlayer.name, 'info');
            } else {
              HUD.showNotification(result.message, 'warning');
            }
          } else {
            HUD.showNotification('No players nearby to trade with', 'warning');
          }
        }
        break;

      case 'startFishing':
        startFishing();
        break;

      case 'togglePetPanel':
        if (HUD && HUD.showPetPanel) {
          HUD.showPetPanel(localPlayer.id, currentZone);
        }
        break;

      case 'toggleHousing':
        showHousingPanel();
        break;

      case 'toggleAnchorPanel':
        if (HUD && HUD.showAnchorPanel) {
          HUD.showAnchorPanel(localPlayer.position, currentZone);
        }
        break;

      case 'toggleFederationProposal':
        if (HUD && HUD.showFederationProposal) {
          HUD.showFederationProposal();
        }
        break;

      default:
        console.log('Unknown local action:', type);
    }

    if (msg) {
      // Apply locally first
      applyMessage(msg);

      // Broadcast to network
      if (Network) {
        Network.broadcastMessage(msg);
      }
    }
  }

  /**
   * Join world
   */
  function joinWorld() {
    if (!Protocol || !Network) return;

    const msg = Protocol.create.join(localPlayer.id, {
      position: localPlayer.position,
      zone: currentZone
    });

    // Broadcast join message
    Network.broadcastMessage(msg);

    console.log('Joined world');
  }

  /**
   * Leave world
   */
  function leaveWorld() {
    if (!Protocol || !Network || !localPlayer) return;

    const msg = Protocol.create.leave(localPlayer.id);

    // Broadcast leave message
    Network.broadcastMessage(msg);

    // Disconnect from network
    Network.disconnect();

    // Stop audio
    if (Audio) {
      Audio.stopAll();
    }

    // Stop game loop
    isRunning = false;

    console.log('Left world');
  }

  // Auto-start on DOM ready
  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', init);

    // Handle page unload â€” save and leave, register player star
    window.addEventListener('beforeunload', () => {
      // Register player's constellation star before leaving
      if (World && World.registerPlayerStar && localPlayer) {
        World.registerPlayerStar(localPlayer.id, localPlayer.name || localPlayer.id);
      }
      // Save world memory
      if (World && World.saveWorldMemory) {
        World.saveWorldMemory();
      }
      autoSavePlayerData();
      leaveWorld();
    });
  }

  /**
   * Get play time in seconds
   */
  function getPlayTimeSeconds() {
    // Load from localStorage
    if (typeof localStorage !== 'undefined') {
      try {
        var stored = localStorage.getItem('zion_playTime');
        if (stored) {
          playTimeSeconds = parseInt(stored) || 0;
        }
      } catch (err) {
        console.warn('Failed to load play time:', err);
      }
    }
    return playTimeSeconds;
  }

  /**
   * Save play time to localStorage
   */
  function savePlayTime() {
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('zion_playTime', playTimeSeconds.toString());
      } catch (err) {
        console.warn('Failed to save play time:', err);
      }
    }
  }

  /**
   * Add recent activity
   */
  function addRecentActivity(activity) {
    recentActivities.unshift(activity);
    if (recentActivities.length > 10) {
      recentActivities = recentActivities.slice(0, 10);
    }
    // Save to localStorage
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('zion_recentActivities', JSON.stringify(recentActivities));
      } catch (err) {
        console.warn('Failed to save activities:', err);
      }
    }
  }

  /**
   * Get recent activities
   */
  function getRecentActivities() {
    // Load from localStorage
    if (typeof localStorage !== 'undefined' && recentActivities.length === 0) {
      try {
        var stored = localStorage.getItem('zion_recentActivities');
        if (stored) {
          recentActivities = JSON.parse(stored) || [];
        }
      } catch (err) {
        console.warn('Failed to load activities:', err);
      }
    }
    return recentActivities.length > 0 ? recentActivities : ['Started playing ZION'];
  }

  /**
   * Track an achievement event and show toast if earned
   */
  function trackAchievement(eventType, eventData) {
    if (!Quests || !Quests.trackAchievementEvent || !localPlayer) return;
    var earned = Quests.trackAchievementEvent(localPlayer.id, eventType, eventData);
    if (earned && earned.length > 0) {
      earned.forEach(function(achievement) {
        // Piano accent for achievement unlock
        if (Audio && Audio.playPianoAccent) Audio.playPianoAccent('achievement');
        // Show toast notification
        if (HUD && HUD.showAchievementToast) {
          HUD.showAchievementToast(achievement);
        } else if (HUD) {
          HUD.showNotification('Achievement unlocked: ' + achievement.name, 'success');
        }
        // Award bonus spark for achievements
        if (economyLedger && Economy) {
          var bonus = achievement.tier === 'gold' ? 50 : achievement.tier === 'silver' ? 25 : 10;
          var achSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: bonus / 25 });
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          if (HUD) HUD.updatePlayerInfo(localPlayer);
          showSparkPopup(achSpark);
        }
        if (Audio) Audio.playSound('warp');
      });
    }
  }

  /**
   * Save full player state for session persistence
   */
  function autoSavePlayerData() {
    if (!Auth || !Auth.savePlayerData || !localPlayer) return;
    var saveData = {
      inventory: playerInventory,
      spark: localPlayer.spark || 0,
      position: localPlayer.position,
      zone: currentZone,
      skills: Mentoring ? Mentoring.getPlayerSkills(localPlayer.id) : null,
      questState: Quests ? { active: Quests.getActiveQuests(localPlayer.id), completed: Quests.getCompletedQuests(localPlayer.id) } : null,
      achievements: Quests && Quests.getAchievements ? Quests.getAchievements(localPlayer.id) : null,
      guild: Guilds ? Guilds.getPlayerGuild(localPlayer.id) : null,
      discoveredSecrets: [],
      warmth: localPlayer.warmth || 0,
      playTime: playTimeSeconds
    };
    Auth.savePlayerData(saveData);
    // Flush player into live state for canonical visibility
    if (State) {
      State.addPlayer(gameState, localPlayer);
      State.flushToLocal();
    }
  }

  /**
   * Restore player state from saved data
   */
  function restorePlayerData() {
    if (!Auth || !Auth.loadPlayerData || !localPlayer) return false;
    var data = Auth.loadPlayerData();
    if (!data) return false;

    // Restore position
    if (data.position) {
      localPlayer.position = data.position;
    }
    if (data.zone) {
      currentZone = data.zone;
    }
    // Restore spark
    if (data.spark && economyLedger && Economy) {
      economyLedger.balances[localPlayer.id] = data.spark;
      localPlayer.spark = data.spark;
    }
    // Restore inventory
    if (data.inventory && Inventory) {
      playerInventory = data.inventory;
    }
    // Restore play time
    if (data.playTime) {
      playTimeSeconds = data.playTime;
    }
    // Restore warmth
    if (data.warmth) {
      localPlayer.warmth = data.warmth;
    }

    console.log('Player data restored from save');
    return true;
  }

  /**
   * Check nearby secrets and trigger discovery
   */
  function checkSecrets() {
    if (!Exploration || !Exploration.checkNearbySecrets || !localPlayer || !gameState) return;
    var nearbySecrets = Exploration.checkNearbySecrets(localPlayer.id, localPlayer.position, currentZone, gameState);
    if (nearbySecrets && nearbySecrets.length > 0) {
      nearbySecrets.forEach(function(secret) {
        var result = Exploration.discoverSecret(localPlayer.id, secret, gameState);
        if (result && result.success) {
          // Show discovery notification with lore
          if (HUD) {
            HUD.showNotification('Secret discovered: ' + secret.name, 'success');
            if (HUD.showDiscoveryPopup) {
              HUD.showDiscoveryPopup({
                name: secret.name,
                description: secret.description,
                rarity: getRarityName(secret.rarity),
                sparkReward: result.sparkAwarded || 0
              });
            }
          }
          // Award spark
          if (economyLedger && Economy && result.sparkAwarded) {
            var secretSpark = Economy.earnSpark(economyLedger, localPlayer.id, 'discovery', { complexity: secret.rarity });
            localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
            if (HUD) HUD.updatePlayerInfo(localPlayer);
            showSparkPopup(secretSpark);
          }
          // Get and show lore if available
          if (secret.loreId && Exploration.getLoreEntry) {
            var lore = Exploration.getLoreEntry(secret.loreId);
            if (lore && HUD) {
              setTimeout(function() {
                HUD.showNotification('Lore unlocked: ' + lore.title, 'info');
              }, 3000);
            }
            // Award lore XP for discovering lore entries
            if (Mentoring) {
              var loreXP = Mentoring.addSkillXP(localPlayer.id, 'lore', 15);
              if (loreXP.leveledUp && HUD) {
                HUD.showNotification('Lore skill increased to ' + loreXP.newLevelName + '!', 'success');
                emitLevelUpParticles();
              }
            }
          }
          // Award exploration XP for discovering secrets
          if (Mentoring) {
            var exploreXP = Mentoring.addSkillXP(localPlayer.id, 'exploration', 10);
            if (exploreXP.leveledUp && HUD) {
              HUD.showNotification('Exploration skill increased to ' + exploreXP.newLevelName + '!', 'success');
              emitLevelUpParticles();
            }
          }
          // Track achievement
          trackAchievement('discover', { type: 'secret', rarity: secret.rarity });
          if (Audio) Audio.playSound('warp');
          addRecentActivity('Discovered: ' + secret.name);
        }
      });
    }
  }

  /**
   * Update economic event display and check for changes
   */
  function updateEconomicEvent() {
    if (!Economy || !Economy.getCurrentEvent) return;
    var event = Economy.getCurrentEvent();
    if (event && (!currentEconomicEvent || currentEconomicEvent.id !== event.id)) {
      currentEconomicEvent = event;
      if (HUD) {
        // Show event banner
        var bannerEl = document.getElementById('economic-event-banner');
        if (!bannerEl && typeof document !== 'undefined') {
          bannerEl = document.createElement('div');
          bannerEl.id = 'economic-event-banner';
          bannerEl.className = 'economic-event-banner';
          document.body.appendChild(bannerEl);
        }
        if (bannerEl) {
          bannerEl.innerHTML = '<strong>' + event.name + '</strong> â€” ' + event.description;
          bannerEl.style.display = 'block';
        }
        HUD.showNotification('Economic Event: ' + event.name + ' is active!', 'success');
      }
    } else if (!event && currentEconomicEvent) {
      currentEconomicEvent = null;
      var bannerEl = document.getElementById('economic-event-banner');
      if (bannerEl) bannerEl.style.display = 'none';
    }
  }

  /**
   * Initialize seasonal event display
   */
  function initSeasonalEvent() {
    if (!Seasons) return;
    currentSeason = Seasons.getCurrentSeason();
    if (!currentSeason) return;

    var colors = Seasons.getSeasonalColors();
    var daysLeft = Seasons.getDaysUntilSeasonEnd();

    // Create seasonal banner
    if (typeof document !== 'undefined') {
      var banner = document.getElementById('seasonal-banner');
      if (!banner) {
        banner = document.createElement('div');
        banner.id = 'seasonal-banner';
        banner.className = 'seasonal-banner season-' + currentSeason.id;
        document.body.appendChild(banner);
      }
      banner.innerHTML = '<div class="seasonal-banner-title">' + (currentSeason.festival && currentSeason.festival.name ? currentSeason.festival.name : currentSeason.name) + '</div>' +
        '<div class="seasonal-banner-desc">' + currentSeason.description + '</div>' +
        '<div class="seasonal-banner-countdown">' + daysLeft + ' days remaining</div>';
      banner.style.display = 'block';

      // Auto-hide after 8 seconds
      setTimeout(function() {
        if (banner) banner.style.display = 'none';
      }, 8000);
    }

    // Apply seasonal NPC greetings
    if (NPCs && Seasons.getSeasonalGreeting) {
      console.log('Season: ' + currentSeason.name + ' â€” ' + Seasons.getSeasonalGreeting());
    }
  }

  /**
   * Update seasonal event (check for season change)
   */
  function updateSeasonalEvent() {
    if (!Seasons) return;
    var newSeason = Seasons.getCurrentSeason();
    if (newSeason && (!currentSeason || currentSeason.id !== newSeason.id)) {
      currentSeason = newSeason;
      if (HUD) {
        HUD.showNotification('A new season has arrived: ' + newSeason.name + '!', 'success');
      }
      initSeasonalEvent(); // Refresh banner
    }
  }

  /**
   * Get seasonal bonus for an activity
   */
  function getSeasonalBonus(activity) {
    if (!Seasons || !Seasons.getSeasonBonus) return 1.0;
    return Seasons.getSeasonBonus(activity);
  }

  /**
   * Initialize pet system
   */
  function initPetSystem(playerId) {
    if (!Pets) return;

    // Check if player has a saved pet
    var savedData = Auth && Auth.loadPlayerData ? Auth.loadPlayerData() : null;
    if (savedData && savedData.pet) {
      // Restore pet from saved data - pets module stores internally
      console.log('Pet system initialized');
    }
  }

  /**
   * Update pet status (hunger, mood decay)
   */
  function updatePetStatus() {
    if (!Pets || !localPlayer) return;
    var pet = Pets.getPlayerPet(localPlayer.id);
    if (!pet) return;

    // Update pet simulation
    Pets.updatePet(localPlayer.id, PET_UPDATE_INTERVAL / 1000);

    // Get pet bonus and apply
    var bonus = Pets.getPetBonus(localPlayer.id);
    if (bonus && bonus.value > 0) {
      localPlayer.petBonus = bonus;
    }

    // Check pet mood for notifications
    var mood = Pets.getPetMood(pet);
    if (mood === 'sad' && pet.hunger > 70) {
      if (HUD) {
        HUD.showNotification(pet.name + ' is hungry! Feed your Pingym.', 'warning');
      }
    }
  }

  /**
   * Start fishing minigame
   */
  function startFishing() {
    if (isFishing || !HUD || !HUD.showFishingUI) return;

    // Check if current zone allows fishing
    var fishableZones = ['gardens', 'commons', 'wilds', 'nexus', 'agora'];
    if (fishableZones.indexOf(currentZone) === -1) {
      if (HUD) HUD.showNotification('You cannot fish here.', 'warning');
      return;
    }

    isFishing = true;
    if (Audio) Audio.playSound('harvest');

    HUD.showFishingUI(currentZone, function(result) {
      isFishing = false;
      if (result && result.success && result.fish) {
        // Add fish to inventory
        if (Inventory && playerInventory) {
          Inventory.addItem(playerInventory, result.fish.id, 1);
          if (HUD && HUD.updateInventoryDisplay) {
            HUD.updateInventoryDisplay(playerInventory);
          }
        }
        // Award Spark
        var sparkAmount = result.fish.value || 5;
        var seasonBonus = getSeasonalBonus('harvest');
        sparkAmount = Math.round(sparkAmount * seasonBonus);
        if (economyLedger && Economy) {
          Economy.earnSpark(economyLedger, localPlayer.id, sparkAmount, 'fishing');
          localPlayer.spark = Economy.getBalance(economyLedger, localPlayer.id);
          showSparkPopup(sparkAmount);
        }
        if (HUD && HUD.showFishCaughtNotification) {
          HUD.showFishCaughtNotification(result.fish.name, sparkAmount);
        }
        trackAchievement('harvest', { type: 'fishing', fish: result.fish.id });
        // Award gardening XP for fishing (falls under nature skills)
        if (Mentoring) {
          var fishXP = Mentoring.addSkillXP(localPlayer.id, 'gardening', 8);
          if (fishXP.leveledUp && HUD) {
            HUD.showNotification('Gardening skill increased to ' + fishXP.newLevelName + '!', 'success');
            emitLevelUpParticles();
          }
        }
        addRecentActivity('Caught: ' + result.fish.name);
      }
    });
  }

  /**
   * Show housing panel for player
   */
  function showHousingPanel() {
    if (!Creation || !HUD || typeof document === 'undefined') return;

    var existingPanel = document.getElementById('housing-panel');
    if (existingPanel) {
      existingPanel.remove();
      return;
    }

    var panel = document.createElement('div');
    panel.id = 'housing-panel';
    panel.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);' +
      'background:rgba(15,12,10,0.95);border:1px solid rgba(218,165,32,0.3);border-radius:12px;' +
      'padding:24px;min-width:400px;max-width:550px;max-height:70vh;overflow-y:auto;z-index:1100;' +
      'backdrop-filter:blur(10px);color:#E8E0D8;font-family:Georgia,serif;';

    var playerPlot = Creation.getPlayerPlot ? Creation.getPlayerPlot(localPlayer.id) : null;

    // Header
    var header = document.createElement('h2');
    header.textContent = playerPlot ? 'My Home â€” ' + playerPlot.name : 'Housing â€” Claim a Plot';
    header.style.cssText = 'color:#DAA520;margin:0 0 16px;font-size:1.2rem;';
    panel.appendChild(header);

    // Close button
    var closeBtn = document.createElement('button');
    closeBtn.textContent = '\u00d7';
    closeBtn.style.cssText = 'position:absolute;top:12px;right:12px;width:30px;height:30px;' +
      'background:rgba(255,255,255,0.1);color:#E8E0D8;border:1px solid rgba(255,255,255,0.2);' +
      'border-radius:50%;font-size:18px;cursor:pointer;';
    closeBtn.onclick = function() { panel.remove(); };
    panel.appendChild(closeBtn);

    if (playerPlot) {
      // Show owned plot info
      var plotInfo = document.createElement('div');
      plotInfo.style.cssText = 'margin-bottom:16px;padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;';
      plotInfo.innerHTML = '<div style="color:#B8B0A8;font-size:0.85rem;">Plot ' + playerPlot.id +
        ' (' + playerPlot.bounds.x1 + ',' + playerPlot.bounds.z1 + ')</div>' +
        '<div style="color:#E8E0D8;font-size:0.9rem;margin-top:4px;">Furniture: ' +
        playerPlot.furniture.length + '/' + 20 + '</div>';
      panel.appendChild(plotInfo);

      // Furniture list
      var furnitureTypes = Creation.FURNITURE_TYPES || {};
      var furnitureHeader = document.createElement('div');
      furnitureHeader.textContent = 'Add Furniture';
      furnitureHeader.style.cssText = 'color:#DAA520;font-size:0.9rem;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.1em;';
      panel.appendChild(furnitureHeader);

      Object.keys(furnitureTypes).forEach(function(fType) {
        var ft = furnitureTypes[fType];
        var row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px;' +
          'background:rgba(255,255,255,0.02);border-radius:6px;margin-bottom:4px;' +
          'border:1px solid rgba(255,255,255,0.05);cursor:pointer;transition:all 0.2s;';
        row.onmouseover = function() { this.style.borderColor = 'rgba(218,165,32,0.3)'; };
        row.onmouseout = function() { this.style.borderColor = 'rgba(255,255,255,0.05)'; };
        row.innerHTML = '<span style="font-size:1.3rem;">' + ft.icon + '</span>' +
          '<span style="flex:1;color:#E8E0D8;font-size:0.85rem;">' + ft.name + '</span>' +
          '<span style="color:#DAA520;font-size:0.8rem;">' + ft.cost + ' Spark</span>';
        row.onclick = function() {
          var result = Creation.placeFurniture(localPlayer.id, fType, 5, 5);
          if (result && result.success) {
            HUD.showNotification('Placed ' + ft.name + ' in your home!', 'success');
            panel.remove();
          } else {
            HUD.showNotification(result ? result.error : 'Cannot place furniture', 'warning');
          }
        };
        panel.appendChild(row);
      });
    } else {
      // Show available plots
      var plots = Creation.getAvailablePlots ? Creation.getAvailablePlots() : [];
      if (plots.length === 0) {
        var noPlots = document.createElement('div');
        noPlots.textContent = 'No plots available. Visit The Commons zone to find housing.';
        noPlots.style.cssText = 'color:#B8B0A8;text-align:center;padding:20px;';
        panel.appendChild(noPlots);
      } else {
        var infoText = document.createElement('div');
        infoText.textContent = 'Available plots in The Commons (' + plots.length + ' open):';
        infoText.style.cssText = 'color:#B8B0A8;font-size:0.85rem;margin-bottom:12px;';
        panel.appendChild(infoText);

        plots.slice(0, 8).forEach(function(plot) {
          var row = document.createElement('div');
          row.style.cssText = 'display:flex;align-items:center;gap:10px;padding:10px;' +
            'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);' +
            'border-radius:8px;margin-bottom:6px;cursor:pointer;transition:all 0.2s;';
          row.onmouseover = function() { this.style.borderColor = 'rgba(218,165,32,0.4)'; };
          row.onmouseout = function() { this.style.borderColor = 'rgba(255,255,255,0.08)'; };
          row.innerHTML = '<span style="font-size:1.3rem;">ðŸ </span>' +
            '<span style="flex:1;color:#E8E0D8;font-size:0.9rem;">Plot ' + plot.id + '</span>' +
            '<span style="color:#B8B0A8;font-size:0.75rem;">(' + plot.bounds.x1 + ', ' + plot.bounds.z1 + ')</span>';
          row.onclick = function() {
            var plotName = prompt('Name your home:');
            if (plotName && plotName.trim()) {
              var result = Creation.claimPlot(localPlayer.id, plot.id, plotName.trim());
              if (result && result.success) {
                HUD.showNotification('You claimed a plot: ' + plotName.trim() + '!', 'success');
                trackAchievement('build', { type: 'housing' });
                panel.remove();
              } else {
                HUD.showNotification(result ? result.error : 'Cannot claim plot', 'warning');
              }
            }
          };
          panel.appendChild(row);
        });
      }
    }

    document.body.appendChild(panel);

    // Close on Escape
    var escHandler = function(e) {
      if (e.key === 'Escape') {
        panel.remove();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }

  // ========================================================================
  // WORLD EVENTS SYSTEM
  // ========================================================================

  /**
   * Check if it's nighttime based on worldTime
   * @param {number} worldTime - Minutes in 24-hour cycle (0-1440)
   * @returns {boolean} True if nighttime
   */
  function isNighttime(worldTime) {
    var hour = worldTime / 60;
    return hour < 6 || hour >= 20; // Night is 8pm-6am
  }

  /**
   * Get a random zone ID
   * @returns {string} Random zone ID
   */
  function getRandomZone() {
    if (!World || !World.ZONES) return 'nexus';
    var zoneKeys = Object.keys(World.ZONES);
    return zoneKeys[Math.floor(Math.random() * zoneKeys.length)];
  }

  /**
   * Get zone name from zone ID
   * @param {string} zoneId - Zone identifier
   * @returns {string} Zone name
   */
  function getZoneName(zoneId) {
    if (!World || !World.ZONES || !World.ZONES[zoneId]) return zoneId;
    return World.ZONES[zoneId].name || zoneId;
  }

  /**
   * Spawn a shooting star event
   * @param {object} sceneContext - Scene context
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnShootingStar(sceneContext, currentTime) {
    if (!sceneContext || !sceneContext.scene) return;

    // Random direction: left-to-right or right-to-left
    var direction = Math.random() > 0.5 ? 1 : -1;
    var startX = direction > 0 ? -300 : 300;
    var endX = direction > 0 ? 300 : -300;
    var y = 150 + Math.random() * 50; // High in sky
    var z = -200 + Math.random() * 400;

    // Create shooting star
    var starGeom = new THREE.SphereGeometry(0.8, 8, 8);
    var starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    var star = new THREE.Mesh(starGeom, starMat);
    star.position.set(startX, y, z);
    sceneContext.scene.add(star);

    // Create trail spheres
    var trail = [];
    for (var i = 0; i < 3; i++) {
      var trailGeom = new THREE.SphereGeometry(0.5 - i * 0.15, 6, 6);
      var trailMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.7 - i * 0.2
      });
      var trailSphere = new THREE.Mesh(trailGeom, trailMat);
      trailSphere.position.copy(star.position);
      sceneContext.scene.add(trailSphere);
      trail.push(trailSphere);
    }

    // Store in active events
    var duration = 1000 + Math.random() * 1000; // 1-2 seconds
    worldEvents.shootingStars.active.push({
      star: star,
      trail: trail,
      startTime: currentTime,
      duration: duration,
      startX: startX,
      endX: endX,
      y: y,
      z: z
    });

    // Show notification
    if (HUD && HUD.showNotification) {
      HUD.showNotification('A shooting star streaks across the sky!', 'info');
    }
  }

  /**
   * Spawn resource bloom event
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnResourceBloom(currentTime) {
    var zone = getRandomZone();
    worldEvents.resourceBloom.activeZone = zone;
    worldEvents.resourceBloom.startTime = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A bloom of resources has appeared in ' + getZoneName(zone) + '!', 'success');
    }
  }

  /**
   * Spawn aurora borealis event
   * @param {object} sceneContext - Scene context
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnAuroraBorealis(sceneContext, currentTime) {
    if (!sceneContext || !sceneContext.scene) return;

    // Create a large plane high in the sky
    var auroraGeom = new THREE.PlaneGeometry(400, 200, 40, 20);
    var auroraMat = new THREE.MeshBasicMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    var aurora = new THREE.Mesh(auroraGeom, auroraMat);
    aurora.position.set(0, 180, -100);
    aurora.rotation.x = Math.PI / 2.5;
    sceneContext.scene.add(aurora);

    worldEvents.auroraBorealis.active = true;
    worldEvents.auroraBorealis.mesh = aurora;
    worldEvents.auroraBorealis.startTime = currentTime;
    worldEvents.auroraBorealis.duration = 180000 + Math.random() * 120000; // 3-5 minutes
    worldEvents.auroraBorealis.animTime = 0;

    // Store original vertex positions for animation
    var positions = auroraGeom.attributes.position.array;
    var originalPositions = new Float32Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
      originalPositions[i] = positions[i];
    }
    aurora.userData.originalPositions = originalPositions;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('The Northern Lights dance across the sky!', 'success');
    }
  }

  /**
   * Spawn wandering merchant event
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnWanderingMerchant(currentTime) {
    var zone = getRandomZone();
    worldEvents.wanderingMerchant.activeZone = zone;
    worldEvents.wanderingMerchant.lastSpawn = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A wandering merchant has appeared near ' + getZoneName(zone) + '!', 'info');
    }
  }

  /**
   * Spawn firefly swarm event
   * @param {number} currentTime - Current timestamp in milliseconds
   */
  function spawnFireflySwarm(currentTime) {
    // Only in gardens zone
    worldEvents.fireflySwarm.active = true;
    worldEvents.fireflySwarm.startTime = currentTime;

    if (HUD && HUD.showNotification) {
      HUD.showNotification('A swarm of fireflies fills the gardens!', 'success');
    }
  }

  /**
   * Update world events
   * @param {number} deltaTime - Time elapsed since last frame (seconds)
   * @param {number} worldTime - Current world time in minutes (0-1440)
   * @param {object} sceneContext - Scene context with scene, camera, etc.
   */
  function updateWorldEvents(deltaTime, worldTime, sceneContext) {
    if (!sceneContext) return;

    var currentTime = Date.now();
    var isNight = isNighttime(worldTime);

    // 1. SHOOTING STARS (nighttime only, every 30-90 seconds)
    if (isNight) {
      var starInterval = worldEvents.shootingStars.interval + Math.random() * 60000;
      if (currentTime - worldEvents.shootingStars.lastSpawn > starInterval) {
        spawnShootingStar(sceneContext, currentTime);
        worldEvents.shootingStars.lastSpawn = currentTime;
      }
    }

    // Update active shooting stars
    for (var i = worldEvents.shootingStars.active.length - 1; i >= 0; i--) {
      var starEvent = worldEvents.shootingStars.active[i];
      var elapsed = currentTime - starEvent.startTime;
      var progress = Math.min(elapsed / starEvent.duration, 1);

      if (progress >= 1) {
        // Remove completed star
        sceneContext.scene.remove(starEvent.star);
        starEvent.star.geometry.dispose();
        starEvent.star.material.dispose();
        for (var j = 0; j < starEvent.trail.length; j++) {
          sceneContext.scene.remove(starEvent.trail[j]);
          starEvent.trail[j].geometry.dispose();
          starEvent.trail[j].material.dispose();
        }
        worldEvents.shootingStars.active.splice(i, 1);
      } else {
        // Update position
        var newX = starEvent.startX + (starEvent.endX - starEvent.startX) * progress;
        starEvent.star.position.x = newX;

        // Update trail with delay
        for (var k = 0; k < starEvent.trail.length; k++) {
          var trailDelay = (k + 1) * 0.1;
          var trailProgress = Math.max(0, progress - trailDelay);
          var trailX = starEvent.startX + (starEvent.endX - starEvent.startX) * trailProgress;
          starEvent.trail[k].position.x = trailX;
          starEvent.trail[k].position.y = starEvent.y;
          starEvent.trail[k].position.z = starEvent.z;
          // Fade out trail
          starEvent.trail[k].material.opacity = (0.7 - k * 0.2) * (1 - progress);
        }
      }
    }

    // 2. RESOURCE BLOOM (every 10-15 minutes)
    var bloomInterval = worldEvents.resourceBloom.interval + Math.random() * 300000;
    if (currentTime - worldEvents.resourceBloom.lastSpawn > bloomInterval) {
      spawnResourceBloom(currentTime);
      worldEvents.resourceBloom.lastSpawn = currentTime;
    }

    // Update resource bloom (make resources glow if player is in zone)
    if (worldEvents.resourceBloom.activeZone) {
      var bloomElapsed = currentTime - worldEvents.resourceBloom.startTime;
      if (bloomElapsed > worldEvents.resourceBloom.duration) {
        worldEvents.resourceBloom.activeZone = null;
      } else {
        // If player is in bloom zone, resources could glow brighter
        // This would require World module support, so for now just track state
      }
    }

    // 3. AURORA BOREALIS (nighttime, rare - every 20+ minutes)
    if (isNight) {
      var auroraInterval = worldEvents.auroraBorealis.interval + Math.random() * 600000;
      if (!worldEvents.auroraBorealis.active &&
          currentTime - worldEvents.auroraBorealis.lastSpawn > auroraInterval) {
        spawnAuroraBorealis(sceneContext, currentTime);
        worldEvents.auroraBorealis.lastSpawn = currentTime;
      }
    }

    // Update aurora animation
    if (worldEvents.auroraBorealis.active && worldEvents.auroraBorealis.mesh) {
      var auroraElapsed = currentTime - worldEvents.auroraBorealis.startTime;
      if (auroraElapsed > worldEvents.auroraBorealis.duration) {
        // Remove aurora
        sceneContext.scene.remove(worldEvents.auroraBorealis.mesh);
        worldEvents.auroraBorealis.mesh.geometry.dispose();
        worldEvents.auroraBorealis.mesh.material.dispose();
        worldEvents.auroraBorealis.mesh = null;
        worldEvents.auroraBorealis.active = false;
      } else {
        // Animate with sine wave displacement
        worldEvents.auroraBorealis.animTime += deltaTime;
        var aurora = worldEvents.auroraBorealis.mesh;
        var geometry = aurora.geometry;
        var positions = geometry.attributes.position.array;
        var originalPositions = aurora.userData.originalPositions;

        if (originalPositions) {
          for (var v = 0; v < positions.length; v += 3) {
            var x = originalPositions[v];
            var y = originalPositions[v + 1];
            var offset = Math.sin(x * 0.02 + worldEvents.auroraBorealis.animTime * 2) *
                        Math.cos(y * 0.02 + worldEvents.auroraBorealis.animTime * 1.5) * 8;
            positions[v + 2] = originalPositions[v + 2] + offset;
          }
          geometry.attributes.position.needsUpdate = true;
        }

        // Fade opacity based on time
        var fadeProgress = auroraElapsed / worldEvents.auroraBorealis.duration;
        if (fadeProgress > 0.8) {
          aurora.material.opacity = 0.3 * (1 - (fadeProgress - 0.8) / 0.2);
        }
      }
    }

    // 4. WANDERING MERCHANT (every 15 minutes)
    var merchantInterval = worldEvents.wanderingMerchant.interval;
    if (currentTime - worldEvents.wanderingMerchant.lastSpawn > merchantInterval) {
      spawnWanderingMerchant(currentTime);
    }

    // 5. FIREFLY SWARM (nighttime in gardens)
    if (isNight && currentZone === 'gardens') {
      var swarmInterval = worldEvents.fireflySwarm.interval;
      if (!worldEvents.fireflySwarm.active &&
          currentTime - worldEvents.fireflySwarm.lastSpawn > swarmInterval) {
        spawnFireflySwarm(currentTime);
        worldEvents.fireflySwarm.lastSpawn = currentTime;
      }
    }

    // Update firefly swarm
    if (worldEvents.fireflySwarm.active) {
      var swarmElapsed = currentTime - worldEvents.fireflySwarm.startTime;
      if (swarmElapsed > worldEvents.fireflySwarm.duration) {
        worldEvents.fireflySwarm.active = false;
      }
      // The actual firefly count increase is handled in World.updateWildlife
      // We just track the active state here
    }
  }

  // Export public API
  exports.init = init;
  exports.joinWorld = joinWorld;
  exports.leaveWorld = leaveWorld;
  exports.handleLocalAction = handleLocalAction;
  exports.triggerCameraShake = triggerCameraShake;
  exports.triggerScreenFlash = triggerScreenFlash;
  exports.setVignetteIntensity = setVignetteIntensity;
  exports.getSimCrmState = function() { return simCrmState; };

})(typeof module !== 'undefined' ? module.exports : (window.Main = {}));


  </script>
</body>
</html>
