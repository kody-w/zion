#!/usr/bin/env python3
"""world_news.py — World Diff narrative news feed for ZION.

Generates an RSS 2.0 feed by diffing consecutive state snapshots.
The world writes its own newspaper.

Usage:
    python3 scripts/world_news.py before.json after.json docs/feeds/news.xml
"""

import json
import os
import sys
import xml.etree.ElementTree as ET
from datetime import datetime, timezone

# Add scripts directory to sys.path so we can import world_diff
_SCRIPTS_DIR = os.path.dirname(os.path.abspath(__file__))
if _SCRIPTS_DIR not in sys.path:
    sys.path.insert(0, _SCRIPTS_DIR)

from world_diff import diff_states, narrate_diff

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

FEED_TITLE = 'ZION World News'
FEED_DESCRIPTION = (
    'The world writes its own newspaper. '
    'Narrative updates generated by diffing consecutive ZION state snapshots.'
)
FEED_LINK = 'https://kody-w.github.io/zion/'
FEED_SELF_URL = 'https://kody-w.github.io/zion/feeds/news.xml'
MAX_NARRATIVE_LEN = 4096  # Truncate very large narratives in descriptions

RSS_NAMESPACE = 'http://www.w3.org/2005/Atom'
CONTENT_NAMESPACE = 'http://purl.org/rss/1.0/modules/content/'


# ---------------------------------------------------------------------------
# generate_news_item
# ---------------------------------------------------------------------------

def generate_news_item(before_state, after_state, timestamp=None):
    """Diff two state dicts and produce a news item dict.

    Parameters
    ----------
    before_state : dict
        State snapshot before the period.
    after_state : dict
        State snapshot after the period.
    timestamp : str or None
        ISO-format timestamp string for the item. Defaults to now (UTC).

    Returns
    -------
    dict or None
        News item dict with keys: title, description, pubDate, guid.
        Returns None if no changes were detected.
    """
    if timestamp is None:
        timestamp = datetime.now(timezone.utc).isoformat()

    diff = diff_states(before_state, after_state)
    narrative = narrate_diff(diff)

    # No changes produces the quiet "No notable changes" message
    if narrative.strip().lower().startswith('no notable changes'):
        return None

    # Title: first sentence of narrative, capped at 120 chars
    first_sentence = narrative.split('.')[0].strip()
    if not first_sentence:
        first_sentence = 'World Update'
    if len(first_sentence) > 120:
        first_sentence = first_sentence[:117] + '...'
    title = '{} — {}'.format(first_sentence, _format_ts_for_title(timestamp))

    # Description: full narrative, truncated if extremely large
    description = narrative
    if len(description) > MAX_NARRATIVE_LEN:
        description = description[:MAX_NARRATIVE_LEN - 3] + '...'

    # GUID: stable, unique identifier based on timestamp
    guid = 'zion-news-{}'.format(_ts_to_guid(timestamp))

    return {
        'title': title,
        'description': description,
        'pubDate': timestamp,
        'guid': guid,
    }


# ---------------------------------------------------------------------------
# generate_rss_feed
# ---------------------------------------------------------------------------

def generate_rss_feed(news_items, max_items=50):
    """Build an RSS 2.0 XML string from a list of news item dicts.

    Parameters
    ----------
    news_items : list of dict
        Each item must have: title, description, pubDate, guid.
        Items are sorted newest first.
    max_items : int
        Maximum number of items to include in the feed.

    Returns
    -------
    str
        RSS 2.0 XML string.
    """
    # Sort newest first by pubDate
    sorted_items = sorted(
        news_items,
        key=lambda x: x.get('pubDate', ''),
        reverse=True
    )[:max_items]

    now_str = datetime.now(timezone.utc).isoformat()

    lines = [
        '<?xml version="1.0" encoding="UTF-8"?>',
        '<rss version="2.0"',
        '  xmlns:atom="http://www.w3.org/2005/Atom"',
        '  xmlns:content="http://purl.org/rss/1.0/modules/content/">',
        '  <channel>',
        '    <title>{}</title>'.format(_xml_escape(FEED_TITLE)),
        '    <link>{}</link>'.format(_xml_escape(FEED_LINK)),
        '    <description>{}</description>'.format(_xml_escape(FEED_DESCRIPTION)),
        '    <language>en-us</language>',
        '    <lastBuildDate>{}</lastBuildDate>'.format(_xml_escape(now_str)),
        '    <atom:link href="{}" rel="self" type="application/rss+xml" />'.format(
            _xml_escape(FEED_SELF_URL)
        ),
    ]

    for item in sorted_items:
        title = _xml_escape(item.get('title', 'World Update'))
        description = _xml_escape(item.get('description', ''))
        pub_date = _xml_escape(item.get('pubDate', now_str))
        guid = _xml_escape(item.get('guid', ''))

        lines.append('    <item>')
        lines.append('      <title>{}</title>'.format(title))
        lines.append('      <description>{}</description>'.format(description))
        lines.append('      <content:encoded><![CDATA[{}]]></content:encoded>'.format(
            item.get('description', '')
        ))
        lines.append('      <pubDate>{}</pubDate>'.format(pub_date))
        lines.append('      <guid isPermaLink="false">{}</guid>'.format(guid))
        lines.append('    </item>')

    lines.append('  </channel>')
    lines.append('</rss>')

    return '\n'.join(lines)


# ---------------------------------------------------------------------------
# update_feed
# ---------------------------------------------------------------------------

def update_feed(state_before_path, state_after_path, feed_path, max_items=50):
    """Load state snapshots, diff them, and update the RSS feed file.

    Parameters
    ----------
    state_before_path : str
        Path to the before state JSON file (or directory).
    state_after_path : str
        Path to the after state JSON file (or directory).
    feed_path : str
        Path to the RSS feed XML file to read/write.
    max_items : int
        Maximum items to keep in the feed.

    Returns
    -------
    bool
        True if a new item was added, False if no changes detected.
    """
    before_state = _load_state(state_before_path)
    after_state = _load_state(state_after_path)

    # Use the mtime of the after file as timestamp, or now
    try:
        ts = datetime.fromtimestamp(
            os.path.getmtime(state_after_path), tz=timezone.utc
        ).isoformat()
    except (OSError, ValueError):
        ts = datetime.now(timezone.utc).isoformat()

    new_item = generate_news_item(before_state, after_state, timestamp=ts)
    if new_item is None:
        return False

    # Load existing feed items
    existing_items = _load_existing_items(feed_path)

    # Check for duplicate guid
    existing_guids = set(i.get('guid', '') for i in existing_items)
    if new_item['guid'] in existing_guids:
        return False

    # Prepend new item
    all_items = [new_item] + existing_items

    # Write updated feed
    feed_xml = generate_rss_feed(all_items, max_items=max_items)
    _ensure_dir(feed_path)
    with open(feed_path, 'w', encoding='utf-8') as f:
        f.write(feed_xml)
        f.write('\n')

    return True


# ---------------------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------------------

def _load_state(path):
    """Load state from a JSON file or directory of JSON files."""
    if os.path.isdir(path):
        known_files = {
            'economy': 'economy.json',
            'gardens': 'gardens.json',
            'structures': 'structures.json',
            'chat': 'chat.json',
            'federation': 'federation.json',
            'players': 'players.json',
            'world': 'world.json',
            'actions': 'actions.json',
        }
        state = {}
        for key, filename in known_files.items():
            filepath = os.path.join(path, filename)
            if os.path.isfile(filepath):
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        state[key] = json.load(f)
                except (json.JSONDecodeError, IOError):
                    pass
        return state
    else:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)


def _load_existing_items(feed_path):
    """Parse an existing RSS feed file and return a list of item dicts."""
    if not os.path.isfile(feed_path):
        return []

    try:
        tree = ET.parse(feed_path)
        root = tree.getroot()
        channel = root.find('channel')
        if channel is None:
            return []

        items = []
        for item_el in channel.findall('item'):
            title = _text(item_el, 'title')
            description = _text(item_el, 'description')
            pub_date = _text(item_el, 'pubDate')
            guid = _text(item_el, 'guid')
            items.append({
                'title': title or '',
                'description': description or '',
                'pubDate': pub_date or '',
                'guid': guid or '',
            })
        return items
    except ET.ParseError:
        return []


def _text(element, tag):
    """Get text content of a child element, or None."""
    child = element.find(tag)
    if child is not None and child.text:
        return child.text.strip()
    return None


def _xml_escape(s):
    """Escape a string for safe embedding in XML text nodes/attributes."""
    if not isinstance(s, str):
        s = str(s)
    s = s.replace('&', '&amp;')
    s = s.replace('<', '&lt;')
    s = s.replace('>', '&gt;')
    s = s.replace('"', '&quot;')
    return s


def _ts_to_guid(ts):
    """Convert an ISO timestamp to a URL-safe GUID fragment."""
    # Replace characters that might look odd in GUIDs
    return ts.replace(':', '-').replace('+', 'p').replace('.', 'd')


def _format_ts_for_title(ts):
    """Format timestamp for human-readable title suffix."""
    # Take just the date+hour portion
    try:
        # Handle both naive and aware timestamps
        if 'T' in ts:
            date_part = ts[:16]  # YYYY-MM-DDTHH:MM
            return date_part.replace('T', ' ')
        return ts[:16]
    except (IndexError, TypeError):
        return ts


def _ensure_dir(file_path):
    """Ensure the directory containing file_path exists."""
    parent = os.path.dirname(file_path)
    if parent and not os.path.isdir(parent):
        os.makedirs(parent, exist_ok=True)


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------

def main():
    if len(sys.argv) < 4:
        print(
            'Usage: python3 scripts/world_news.py '
            '<before.json> <after.json> <feed.xml>',
            file=sys.stderr
        )
        print(
            '  <before> and <after> can be JSON files or state directories.',
            file=sys.stderr
        )
        sys.exit(1)

    before_path = sys.argv[1]
    after_path = sys.argv[2]
    feed_path = sys.argv[3]

    added = update_feed(before_path, after_path, feed_path)

    if added:
        print('News item added to {}'.format(feed_path))
    else:
        print('No changes detected — feed unchanged.')


if __name__ == '__main__':
    main()
