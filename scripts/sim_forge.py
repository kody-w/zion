#!/usr/bin/env python3
"""
sim_forge.py — Simulation Forge meta-tool for ZION
Generates UMD JS simulation modules, initial state JSON, and tests from a spec.

Article XI: Simulations run locally, store state as JSON, use pure functions.

Usage:
  python3 scripts/sim_forge.py specs/pm.json
  python3 scripts/sim_forge.py specs/pm.json --output-dir ./generated/
  echo '{...}' | python3 scripts/sim_forge.py
  echo '{...}' | python3 scripts/sim_forge.py --output-dir ./generated/
"""

import sys
import os
import json
import re
import datetime
import argparse

# ---------------------------------------------------------------------------
# Spec parsing and validation
# ---------------------------------------------------------------------------

def parse_spec(spec_input):
    """Parse and validate a simulation spec.

    Args:
        spec_input: dict or JSON string

    Returns:
        Validated spec dict with defaults applied.

    Raises:
        ValueError: if spec is invalid.
    """
    if isinstance(spec_input, str):
        try:
            spec = json.loads(spec_input)
        except json.JSONDecodeError as e:
            raise ValueError('Invalid JSON in spec: ' + str(e))
    elif isinstance(spec_input, dict):
        # Deep copy to avoid mutating the input
        spec = json.loads(json.dumps(spec_input))
    else:
        raise ValueError('spec_input must be a dict or JSON string')

    # --- Validate name ---
    if 'name' not in spec or not spec['name']:
        raise ValueError('Spec must have a non-empty "name" field')
    name = spec['name']
    if not isinstance(name, str):
        raise ValueError('"name" must be a string')
    if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
        raise ValueError(
            '"name" must start with a letter or underscore and contain only '
            'alphanumeric characters and underscores, got: ' + repr(name)
        )

    # --- Validate collections ---
    if 'collections' not in spec:
        raise ValueError('Spec must have a "collections" field')
    collections = spec['collections']
    if not isinstance(collections, dict):
        raise ValueError('"collections" must be an object/dict')
    if len(collections) == 0:
        raise ValueError('"collections" must have at least one collection')

    # Normalise each collection entry
    for coll_name, coll_def in list(collections.items()):
        if not isinstance(coll_def, dict):
            collections[coll_name] = {'fields': []}
            coll_def = collections[coll_name]
        if 'fields' not in coll_def or coll_def['fields'] is None:
            coll_def['fields'] = []
        if not isinstance(coll_def['fields'], list):
            raise ValueError(
                'fields for collection "' + coll_name + '" must be a list'
            )

    # --- Default actions ---
    if 'actions' not in spec or not spec['actions']:
        spec['actions'] = ['create', 'update', 'delete']

    # --- Default description ---
    if 'description' not in spec:
        spec['description'] = 'A ' + name.replace('_', ' ') + ' simulation'

    return spec


# ---------------------------------------------------------------------------
# JS code generation helpers
# ---------------------------------------------------------------------------

def _js_str(s):
    """Escape a Python string as a JS single-quoted string."""
    return "'" + str(s).replace('\\', '\\\\').replace("'", "\\'") + "'"


def _coll_prefix(coll_name):
    """Derive a 3-char prefix for IDs from a collection name."""
    return coll_name[:3].lower()


def _pascal(s):
    """Convert snake_case to PascalCase."""
    return ''.join(part.capitalize() for part in s.split('_'))


def _window_name(sim_name):
    """Window export name: Sim_{Name}."""
    return 'Sim' + _pascal(sim_name)


def _module_name(sim_name):
    """JS require name."""
    return 'sim_' + sim_name


# ---------------------------------------------------------------------------
# generate_module
# ---------------------------------------------------------------------------

def generate_module(spec):
    """Generate a UMD JS simulation module from a validated spec.

    Returns:
        JS source string.
    """
    name = spec['name']
    collections = spec['collections']
    description = spec.get('description', '')
    window_name = _window_name(name)

    lines = []
    w = lines.append  # write line

    # Header
    w('// sim_' + name + '.js — ' + description)
    w('// Auto-generated by sim_forge.py — Article XI: Simulations')
    w('// initState(snapshot), applyAction(state, message), getState(), getSchema()')
    w('(function(exports) {')
    w("  'use strict';")
    w('')

    # Schema definition
    w('  // --- Schema ---')
    w('')
    w('  var _schema = {')
    w('    collections: {')
    coll_names = list(collections.keys())
    for i, coll_name in enumerate(coll_names):
        coll_def = collections[coll_name]
        fields = coll_def.get('fields', [])
        prefix = _coll_prefix(coll_name)
        fields_js = '[' + ', '.join(_js_str(f) for f in fields) + ']'
        comma = ',' if i < len(coll_names) - 1 else ''
        w('      ' + _js_str(coll_name) + ': { prefix: ' + _js_str(prefix) + ', fields: ' + fields_js + ' }' + comma)
    w('    }')
    w('  };')
    w('')

    # State holder
    w('  var _state = null;')
    w('  var _idCounter = 0;')
    w('')

    # Utility functions
    w('  // --- Utilities ---')
    w('')
    w('  function clone(obj) {')
    w('    return JSON.parse(JSON.stringify(obj));')
    w('  }')
    w('')
    w('  function generateId(prefix) {')
    w('    _idCounter++;')
    w("    return prefix + '_' + Date.now().toString(36) + '_' + _idCounter;")
    w('  }')
    w('')
    w('  function objectKeys(obj) {')
    w('    var keys = [];')
    w('    for (var k in obj) {')
    w('      if (obj.hasOwnProperty(k)) { keys.push(k); }')
    w('    }')
    w('    return keys;')
    w('  }')
    w('')
    w('  function mergeOwner(data, from) {')
    w('    var out = {};')
    w('    for (var k in data) {')
    w('      if (data.hasOwnProperty(k)) { out[k] = data[k]; }')
    w('    }')
    w("    if (!out.owner) { out.owner = from || 'system'; }")
    w('    return out;')
    w('  }')
    w('')

    # initState
    w('  // --- State Management ---')
    w('')
    w('  function initState(snapshot) {')
    w('    var freshSchema = JSON.parse(JSON.stringify(_schema));')
    w('    if (snapshot && typeof snapshot === \'object\') {')
    w('      // Restore id counter from existing records')
    w('      var maxNum = 0;')
    w('      var collNames = objectKeys((snapshot._schema || {}).collections || {});')
    # Also scan the spec collections
    extra_colls = '[' + ', '.join(_js_str(c) for c in coll_names) + ']'
    w('      var specColls = ' + extra_colls + ';')
    w('      for (var si = 0; si < specColls.length; si++) {')
    w('        if (collNames.indexOf(specColls[si]) === -1) { collNames.push(specColls[si]); }')
    w('      }')
    w('      for (var ci = 0; ci < collNames.length; ci++) {')
    w('        var coll = snapshot[collNames[ci]];')
    w('        if (coll && typeof coll === \'object\' && !Array.isArray(coll)) {')
    w('          var ids = objectKeys(coll);')
    w('          for (var ii = 0; ii < ids.length; ii++) {')
    w('            var parts = ids[ii].split(\'_\');')
    w('            var num = parseInt(parts[parts.length - 1], 10);')
    w('            if (!isNaN(num) && num > maxNum) { maxNum = num; }')
    w('          }')
    w('        }')
    w('      }')
    w('      _idCounter = maxNum;')
    w('      var loaded = clone(snapshot);')
    w('      if (!loaded._schema) { loaded._schema = freshSchema; }')
    w('      // Ensure all spec collections exist')
    w('      for (var sci = 0; sci < specColls.length; sci++) {')
    w('        if (!loaded[specColls[sci]]) { loaded[specColls[sci]] = {}; }')
    w('      }')
    w('      _state = loaded;')
    w('      return _state;')
    w('    }')
    w('    // Fresh state')
    w('    _idCounter = 0;')
    w('    _state = {')
    w('      _schema: freshSchema,')
    w("      _sim: " + _js_str(name) + ",")
    w('      _created_at: new Date().toISOString()')
    w('    };')
    for coll_name in coll_names:
        w('    _state[' + _js_str(coll_name) + '] = {};')
    w('    return _state;')
    w('  }')
    w('')

    # CRUD helpers per collection
    w('  // --- CRUD Helpers ---')
    w('')
    for coll_name in coll_names:
        coll_def = collections[coll_name]
        fields = coll_def.get('fields', [])
        prefix = _coll_prefix(coll_name)

        # createItem
        w('  function create_' + coll_name + '(state, data) {')
        w('    var s = clone(state);')
        w('    var id = generateId(' + _js_str(prefix) + ');')
        w('    var record = {')
        w('      id: id,')
        w("      owner: data.owner || 'system',")
        w('      createdAt: new Date().toISOString()')
        w('    };')
        w('    for (var k in data) {')
        w('      if (data.hasOwnProperty(k)) { record[k] = data[k]; }')
        w('    }')
        w('    if (!record.name && !record.title) {')
        w('      record.name = \'Unnamed ' + coll_name.rstrip('s') + '\';')
        w('    }')
        w('    s[' + _js_str(coll_name) + '][id] = record;')
        w('    return { state: s, record: record };')
        w('  }')
        w('')

        # updateItem
        w('  function update_' + coll_name + '(state, id, data) {')
        w('    if (!state[' + _js_str(coll_name) + '] || !state[' + _js_str(coll_name) + '][id]) { return state; }')
        w('    var s = clone(state);')
        w('    var target = s[' + _js_str(coll_name) + '][id];')
        w('    for (var k in data) {')
        w("      if (data.hasOwnProperty(k) && k !== 'id') { target[k] = data[k]; }")
        w('    }')
        w('    target.updatedAt = new Date().toISOString();')
        w('    return s;')
        w('  }')
        w('')

        # deleteItem
        w('  function delete_' + coll_name + '(state, id) {')
        w('    if (!state[' + _js_str(coll_name) + '] || !state[' + _js_str(coll_name) + '][id]) { return state; }')
        w('    var s = clone(state);')
        w('    delete s[' + _js_str(coll_name) + '][id];')
        w('    return s;')
        w('  }')
        w('')

    # applyAction dispatch
    w('  // --- Action Dispatch ---')
    w('')
    w('  function applyAction(state, msg) {')
    w("    var payload = (msg && msg.payload) ? msg.payload : (msg || {});")
    w("    var action = payload.action || '';")
    w('    var data = payload.data || {};')
    w("    var from = (msg && msg.from) || payload.from || 'system';")
    w('    var result;')
    w('')
    w('    if (!state || !state._schema) {')
    w('      state = initState(state);')
    w('    }')
    w('')
    w('    switch (action) {')

    for coll_name in coll_names:
        # create_<coll>
        w('      case ' + _js_str('create_' + coll_name) + ':')
        w('        result = create_' + coll_name + '(state, mergeOwner(data, from));')
        w('        return result.state;')
        w('')
        # update_<coll>
        w('      case ' + _js_str('update_' + coll_name) + ':')
        w('        return update_' + coll_name + '(state, data.id, data);')
        w('')
        # delete_<coll>
        w('      case ' + _js_str('delete_' + coll_name) + ':')
        w('        return delete_' + coll_name + '(state, data.id);')
        w('')

    # Handle custom actions from spec
    actions = spec.get('actions', [])
    custom_actions = [a for a in actions if a not in ('create', 'update', 'delete')]
    for action in custom_actions:
        # complete action: mark done/status=completed
        if action == 'complete':
            for coll_name in coll_names:
                case_name = 'complete_' + coll_name
                w('      case ' + _js_str(case_name) + ':')
                w('        var sc = clone(state);')
                w('        if (sc[' + _js_str(coll_name) + '] && sc[' + _js_str(coll_name) + '][data.id]) {')
                coll_fields = collections[coll_name].get('fields', [])
                if 'done' in coll_fields:
                    w('          sc[' + _js_str(coll_name) + '][data.id].done = true;')
                if 'status' in coll_fields:
                    w("          sc[" + _js_str(coll_name) + "][data.id].status = 'completed';")
                w('          sc[' + _js_str(coll_name) + '][data.id].completedAt = new Date().toISOString();')
                w('        }')
                w('        return sc;')
                w('')
        elif action == 'assign':
            for coll_name in coll_names:
                coll_fields = collections[coll_name].get('fields', [])
                if 'assignee' in coll_fields:
                    case_name = 'assign_' + coll_name
                    w('      case ' + _js_str(case_name) + ':')
                    w('        var sa = clone(state);')
                    w('        if (sa[' + _js_str(coll_name) + '] && sa[' + _js_str(coll_name) + '][data.id]) {')
                    w('          sa[' + _js_str(coll_name) + '][data.id].assignee = data.assignee || from;')
                    w('          sa[' + _js_str(coll_name) + '][data.id].updatedAt = new Date().toISOString();')
                    w('        }')
                    w('        return sa;')
                    w('')
        elif action == 'move':
            for coll_name in coll_names:
                coll_fields = collections[coll_name].get('fields', [])
                if 'board_id' in coll_fields or 'parent_id' in coll_fields:
                    target_field = 'board_id' if 'board_id' in coll_fields else 'parent_id'
                    case_name = 'move_' + coll_name
                    w('      case ' + _js_str(case_name) + ':')
                    w('        var sm = clone(state);')
                    w('        if (sm[' + _js_str(coll_name) + '] && sm[' + _js_str(coll_name) + '][data.id]) {')
                    w('          sm[' + _js_str(coll_name) + '][data.id][' + _js_str(target_field) + '] = data.' + target_field + ';')
                    w('          sm[' + _js_str(coll_name) + '][data.id].updatedAt = new Date().toISOString();')
                    w('        }')
                    w('        return sm;')
                    w('')

    # default: unknown action returns same state
    w('      default:')
    w('        return state;')
    w('    }')
    w('  }')
    w('')

    # query helper
    w('  // --- Query ---')
    w('')
    w('  function query(state, collName, filter) {')
    w('    var coll = state[collName];')
    w('    if (!coll || typeof coll !== \'object\' || Array.isArray(coll)) { return []; }')
    w('    var results = [];')
    w('    var ids = objectKeys(coll);')
    w('    for (var i = 0; i < ids.length; i++) {')
    w('      var item = coll[ids[i]];')
    w('      if (!filter || matchesFilter(item, filter)) {')
    w('        results.push(item);')
    w('      }')
    w('    }')
    w('    return results;')
    w('  }')
    w('')
    w('  function matchesFilter(item, filter) {')
    w('    for (var k in filter) {')
    w('      if (filter.hasOwnProperty(k)) {')
    w('        if (item[k] !== filter[k]) { return false; }')
    w('      }')
    w('    }')
    w('    return true;')
    w('  }')
    w('')

    # Public exports
    w('  // --- Public API ---')
    w('')
    w('  exports.initState = function(snapshot) {')
    w('    return initState(snapshot);')
    w('  };')
    w('')
    w('  exports.applyAction = function(state, msg) {')
    w('    return applyAction(state, msg);')
    w('  };')
    w('')
    w('  exports.getState = function() {')
    w('    return JSON.parse(JSON.stringify(_state));')
    w('  };')
    w('')
    w('  exports.getSchema = function() {')
    w('    return JSON.parse(JSON.stringify(_schema));')
    w('  };')
    w('')
    w('  exports.query = function(state, collName, filter) {')
    w('    return query(state, collName, filter);')
    w('  };')
    w('')

    # Also export individual CRUD functions for direct use in tests
    for coll_name in coll_names:
        w('  exports.create_' + coll_name + ' = function(state, data) {')
        w('    return create_' + coll_name + '(state, data);')
        w('  };')
        w('  exports.update_' + coll_name + ' = function(state, id, data) {')
        w('    return update_' + coll_name + '(state, id, data);')
        w('  };')
        w('  exports.delete_' + coll_name + ' = function(state, id) {')
        w('    return delete_' + coll_name + '(state, id);')
        w('  };')
        w('')

    # UMD footer
    w('})(typeof module !== \'undefined\' ? module.exports : (window.' + window_name + ' = {}));')

    return '\n'.join(lines) + '\n'


# ---------------------------------------------------------------------------
# generate_state
# ---------------------------------------------------------------------------

def generate_state(spec):
    """Generate initial state JSON for a simulation.

    Returns:
        JSON string.
    """
    name = spec['name']
    collections = spec['collections']

    schema_collections = {}
    for coll_name, coll_def in collections.items():
        fields = coll_def.get('fields', [])
        schema_collections[coll_name] = {
            'prefix': _coll_prefix(coll_name),
            'fields': list(fields)
        }

    state = {
        '_sim': name,
        '_schema': {
            'collections': schema_collections
        },
        '_created_at': datetime.datetime.utcnow().isoformat() + 'Z'
    }

    # Empty collections
    for coll_name in collections:
        state[coll_name] = {}

    return json.dumps(state, indent=2)


# ---------------------------------------------------------------------------
# generate_tests
# ---------------------------------------------------------------------------

def generate_tests(spec):
    """Generate a JS test file for a simulation module.

    Returns:
        JS test source string.
    """
    name = spec['name']
    collections = spec['collections']
    coll_names = list(collections.keys())
    module_name = _module_name(name)
    module_var = 'Sim'

    lines = []
    w = lines.append

    w('#!/usr/bin/env node')
    w('// test_sim_' + name + '.js — Auto-generated tests for ' + module_name)
    w("// Generated by sim_forge.py")
    w("'use strict';")
    w('')
    w("var " + module_var + " = require('../src/js/" + module_name + ".js');")
    w('')
    w('var passed = 0;')
    w('var failed = 0;')
    w('')
    w('function assert(condition, message) {')
    w('  if (condition) {')
    w('    passed++;')
    w('  } else {')
    w('    failed++;')
    w("    console.error('FAIL: ' + message);")
    w('  }')
    w('}')
    w('')
    w('function assertEqual(actual, expected, message) {')
    w('  if (actual === expected) {')
    w('    passed++;')
    w('  } else {')
    w('    failed++;')
    w("    console.error('FAIL: ' + message + ' — expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));")
    w('  }')
    w('}')
    w('')

    # --- initState tests ---
    w('// --- initState ---')
    w('')
    w('(function testInitStateEmpty() {')
    w('  var state = ' + module_var + '.initState();')
    w("  assert(state && typeof state === 'object', 'initState returns object');")
    w("  assert(state._schema && state._schema.collections, 'initState returns state with schema');")
    for coll_name in coll_names:
        w("  assert(state[" + _js_str(coll_name) + "] && typeof state[" + _js_str(coll_name) + "] === 'object', 'initState returns " + coll_name + " object');")
    w('})();')
    w('')

    w('(function testInitStateFromSnapshot() {')
    first_coll = coll_names[0]
    prefix = _coll_prefix(first_coll)
    test_id = prefix + '_snap_1'
    w('  var snap = {')
    w('    _schema: { collections: {} },')
    for i, coll_name in enumerate(coll_names):
        comma = ',' if i < len(coll_names) - 1 else ''
        if i == 0:
            w('    ' + _js_str(coll_name) + ': { ' + _js_str(test_id) + ': { id: ' + _js_str(test_id) + ', name: \'Test\' } }' + comma)
        else:
            w('    ' + _js_str(coll_name) + ': {}' + comma)
    w('  };')
    w('  var state = ' + module_var + '.initState(snap);')
    w("  assert(state[" + _js_str(first_coll) + "][" + _js_str(test_id) + "] !== undefined, 'initState restores snapshot data');")
    w("  assertEqual(state[" + _js_str(first_coll) + "][" + _js_str(test_id) + "].name, 'Test', 'initState restores record name');")
    w('  // Deep clone check')
    w("  snap[" + _js_str(first_coll) + "][" + _js_str(test_id) + "].name = 'Modified';")
    w("  assertEqual(state[" + _js_str(first_coll) + "][" + _js_str(test_id) + "].name, 'Test', 'initState deep clones snapshot');")
    w('})();')
    w('')

    # --- CRUD tests per collection ---
    for coll_name in coll_names:
        coll_def = collections[coll_name]
        fields = coll_def.get('fields', [])
        prefix = _coll_prefix(coll_name)

        w('// --- ' + coll_name + ' CRUD ---')
        w('')

        # Create
        w('(function testCreate_' + coll_name + '() {')
        w('  var state = ' + module_var + '.initState();')
        # Build a data object from fields
        test_data_parts = []
        for f in fields[:3]:  # take first 3 fields as test data
            if f in ('done',):
                test_data_parts.append(_js_str(f) + ': false')
            elif f in ('status',):
                test_data_parts.append(_js_str(f) + ": 'active'")
            elif f in ('priority',):
                test_data_parts.append(_js_str(f) + ": 'high'")
            else:
                test_data_parts.append(_js_str(f) + ': ' + _js_str('test_' + f))
        test_data = '{ ' + ', '.join(test_data_parts) + ' }' if test_data_parts else '{ name: \'Test Item\' }'
        w('  var result = ' + module_var + '.create_' + coll_name + '(state, ' + test_data + ');')
        w('  var record = result.record;')
        w('  var newState = result.state;')
        w("  assert(record && record.id && record.id.indexOf(" + _js_str(prefix) + ") === 0, 'create_" + coll_name + " id has " + prefix + "_ prefix');")
        w("  assert(newState[" + _js_str(coll_name) + "][record.id] !== undefined, 'create_" + coll_name + " stores record');")
        w("  assertEqual(Object.keys(state[" + _js_str(coll_name) + "]).length, 0, 'create_" + coll_name + " does not mutate original state');")
        w('})();')
        w('')

        # Update
        w('(function testUpdate_' + coll_name + '() {')
        w('  var state = ' + module_var + '.initState();')
        w('  var r = ' + module_var + '.create_' + coll_name + "(state, { name: 'Original' });")
        w('  state = r.state;')
        w('  var id = r.record.id;')
        w('  var updated = ' + module_var + '.update_' + coll_name + "(state, id, { name: 'Updated Name' });")
        w("  assertEqual(updated[" + _js_str(coll_name) + "][id].name, 'Updated Name', 'update_" + coll_name + " changes name');")
        w("  assertEqual(state[" + _js_str(coll_name) + "][id].name, 'Original', 'update_" + coll_name + " does not mutate original state');")
        w('})();')
        w('')

        # Update missing (edge case)
        w('(function testUpdate_' + coll_name + '_missing() {')
        w('  var state = ' + module_var + '.initState();')
        w("  var result = " + module_var + ".update_" + coll_name + "(state, 'nonexistent_id', { name: 'X' });")
        w("  assert(result === state, 'update_" + coll_name + " nonexistent id returns same state');")
        w('})();')
        w('')

        # Delete
        w('(function testDelete_' + coll_name + '() {')
        w('  var state = ' + module_var + '.initState();')
        w('  var r = ' + module_var + '.create_' + coll_name + "(state, { name: 'Delete me' });")
        w('  state = r.state;')
        w('  var id = r.record.id;')
        w('  var deleted = ' + module_var + '.delete_' + coll_name + '(state, id);')
        w("  assert(deleted[" + _js_str(coll_name) + "][id] === undefined, 'delete_" + coll_name + " removes record');")
        w("  assertEqual(Object.keys(state[" + _js_str(coll_name) + "]).length, 1, 'delete_" + coll_name + " does not mutate original state');")
        w('})();')
        w('')

        # Delete missing (edge case)
        w('(function testDelete_' + coll_name + '_missing() {')
        w('  var state = ' + module_var + '.initState();')
        w("  var result = " + module_var + ".delete_" + coll_name + "(state, 'nonexistent_id');")
        w("  assert(result === state, 'delete_" + coll_name + " nonexistent id returns same state');")
        w('})();')
        w('')

    # --- Schema validation ---
    w('// --- Schema ---')
    w('')
    w('(function testGetSchema() {')
    w('  ' + module_var + '.initState();')
    w('  var schema = ' + module_var + '.getSchema();')
    w("  assert(schema && schema.collections, 'getSchema returns collections');")
    for coll_name in coll_names:
        w("  assert(schema.collections[" + _js_str(coll_name) + "], 'schema has " + coll_name + " collection');")
        coll_fields = collections[coll_name].get('fields', [])
        for f in coll_fields[:2]:
            w("  assert(schema.collections[" + _js_str(coll_name) + "].fields.indexOf(" + _js_str(f) + ") !== -1, 'schema " + coll_name + " has " + f + " field');")
    w('})();')
    w('')

    # --- applyAction tests ---
    w('// --- applyAction ---')
    w('')
    w('(function testApplyAction_create() {')
    first_coll = coll_names[0]
    w('  var state = ' + module_var + '.initState();')
    w('  var msg = {')
    w("    from: 'user1',")
    w('    payload: {')
    w('      action: ' + _js_str('create_' + first_coll) + ',')
    w("      data: { name: 'Action Created' }")
    w('    }')
    w('  };')
    w('  var s2 = ' + module_var + '.applyAction(state, msg);')
    w('  var items = ' + module_var + '.query(s2, ' + _js_str(first_coll) + ', null);')
    w("  assertEqual(items.length, 1, 'applyAction create adds record');")
    w("  assertEqual(items[0].name, 'Action Created', 'applyAction create passes name');")
    w("  assertEqual(items[0].owner, 'user1', 'applyAction sets owner from msg.from');")
    w('})();')
    w('')

    w('(function testApplyAction_update() {')
    w('  var state = ' + module_var + '.initState();')
    w('  var r = ' + module_var + '.create_' + first_coll + "(state, { name: 'Before' });")
    w('  state = r.state;')
    w('  var id = r.record.id;')
    w('  var msg = {')
    w("    from: 'user1',")
    w('    payload: {')
    w('      action: ' + _js_str('update_' + first_coll) + ',')
    w("      data: { id: id, name: 'After' }")
    w('    }')
    w('  };')
    w('  var s2 = ' + module_var + '.applyAction(state, msg);')
    w("  assertEqual(s2[" + _js_str(first_coll) + "][id].name, 'After', 'applyAction update changes name');")
    w('})();')
    w('')

    w('(function testApplyAction_delete() {')
    w('  var state = ' + module_var + '.initState();')
    w('  var r = ' + module_var + '.create_' + first_coll + "(state, { name: 'Gone' });")
    w('  state = r.state;')
    w('  var id = r.record.id;')
    w('  var msg = {')
    w("    from: 'user1',")
    w('    payload: {')
    w('      action: ' + _js_str('delete_' + first_coll) + ',')
    w('      data: { id: id }')
    w('    }')
    w('  };')
    w('  var s2 = ' + module_var + '.applyAction(state, msg);')
    w("  assert(s2[" + _js_str(first_coll) + "][id] === undefined, 'applyAction delete removes record');")
    w('})();')
    w('')

    w('(function testApplyAction_unknown() {')
    w('  var state = ' + module_var + '.initState();')
    w("  var msg = { from: 'x', payload: { action: 'nonexistent_action_xyz', data: {} } };")
    w('  var s2 = ' + module_var + '.applyAction(state, msg);')
    w("  assert(s2 === state, 'applyAction unknown action returns same state');")
    w('})();')
    w('')

    # --- Edge cases ---
    w('// --- Edge cases ---')
    w('')

    w('(function testCreate_missing_fields() {')
    first_coll = coll_names[0]
    w('  // Create with no data — should not throw, uses defaults')
    w('  var state = ' + module_var + '.initState();')
    w('  var result = ' + module_var + '.create_' + first_coll + '(state, {});')
    w("  assert(result && result.record && result.record.id, 'create with empty data sets an id');")
    w('})();')
    w('')

    w('(function testUpdate_nonexistent_id() {')
    w('  var state = ' + module_var + '.initState();')
    w("  var result = " + module_var + ".update_" + first_coll + "(state, 'nonexistent', { name: 'X' });")
    w("  assert(result === state, 'update nonexistent id returns same state unchanged');")
    w('})();')
    w('')

    w('(function testDelete_nonexistent_id() {')
    w('  var state = ' + module_var + '.initState();')
    w("  var result = " + module_var + ".delete_" + first_coll + "(state, 'nonexistent');")
    w("  assert(result === state, 'delete nonexistent id returns same state');")
    w('})();')
    w('')

    # --- Snapshot roundtrip ---
    w('// --- Snapshot roundtrip ---')
    w('')
    w('(function testSnapshotRoundtrip() {')
    w('  var state = ' + module_var + '.initState();')
    for coll_name in coll_names:
        varname = 'r_' + coll_name
        w('  var ' + varname + ' = ' + module_var + '.create_' + coll_name + "(state, { name: 'Persist " + coll_name + "' });")
        w('  state = ' + varname + '.state;')
    w('  var json = JSON.stringify(state);')
    w('  var restored = ' + module_var + '.initState(JSON.parse(json));')
    for coll_name in coll_names:
        w("  assertEqual(Object.keys(restored[" + _js_str(coll_name) + "]).length, 1, 'snapshot restores " + coll_name + "');")
    w('})();')
    w('')

    # --- getState ---
    w('(function testGetState() {')
    w('  var state = ' + module_var + '.initState();')
    w('  var got = ' + module_var + '.getState();')
    w("  assert(got && typeof got === 'object', 'getState returns object');")
    w("  assert(got._schema !== undefined, 'getState includes schema');")
    w('})();')
    w('')

    # --- query ---
    w('(function testQuery() {')
    first_coll = coll_names[0]
    w('  var state = ' + module_var + '.initState();')
    w('  var r1 = ' + module_var + '.create_' + first_coll + "(state, { name: 'A', status: 'active' });")
    w('  state = r1.state;')
    w('  var r2 = ' + module_var + '.create_' + first_coll + "(state, { name: 'B', status: 'done' });")
    w('  state = r2.state;')
    w('  var all = ' + module_var + '.query(state, ' + _js_str(first_coll) + ', null);')
    w("  assertEqual(all.length, 2, 'query all returns 2');")
    w('  var active = ' + module_var + ".query(state, " + _js_str(first_coll) + ", { status: 'active' });")
    w("  assertEqual(active.length, 1, 'query filtered returns 1');")
    w("  var none = " + module_var + ".query(state, 'nonexistent_collection', {});")
    w("  assertEqual(none.length, 0, 'query nonexistent collection returns empty');")
    w('})();')
    w('')

    # Results
    w("// --- Results ---")
    w('')
    w("console.log('\\n" + _module_name(name) + " Tests: ' + passed + ' passed, ' + failed + ' failed');")
    w('if (failed > 0) {')
    w('  process.exit(1);')
    w('} else {')
    w("  console.log('All " + name + " simulation tests passed!');")
    w('}')

    return '\n'.join(lines) + '\n'


# ---------------------------------------------------------------------------
# forge — write all 3 files
# ---------------------------------------------------------------------------

def forge(spec, output_dir):
    """Generate and write all 3 simulation files.

    Args:
        spec: validated spec dict
        output_dir: root directory for output (project root)

    Returns:
        List of 3 absolute paths created.
    """
    name = spec['name']
    output_dir = os.path.abspath(output_dir)

    # Generate content
    js_content = generate_module(spec)
    state_content = generate_state(spec)
    tests_content = generate_tests(spec)

    # Determine paths
    js_path = os.path.join(output_dir, 'src', 'js', 'sim_' + name + '.js')
    state_dir = os.path.join(output_dir, 'state', 'simulations', name)
    state_path = os.path.join(state_dir, 'state.json')
    tests_path = os.path.join(output_dir, 'tests', 'test_sim_' + name + '.js')

    # Write files
    os.makedirs(os.path.dirname(js_path), exist_ok=True)
    with open(js_path, 'w') as f:
        f.write(js_content)

    os.makedirs(state_dir, exist_ok=True)
    with open(state_path, 'w') as f:
        f.write(state_content)

    os.makedirs(os.path.dirname(tests_path), exist_ok=True)
    with open(tests_path, 'w') as f:
        f.write(tests_content)

    return [js_path, state_path, tests_path]


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description='sim_forge.py — ZION Simulation Forge: generate simulation modules from a spec',
        usage=(
            '\n  python3 sim_forge.py spec.json\n'
            '  python3 sim_forge.py spec.json --output-dir ./generated/\n'
            '  echo \'{"name":"todo",...}\' | python3 sim_forge.py\n'
            '  echo \'{"name":"todo",...}\' | python3 sim_forge.py --output-dir ./generated/'
        )
    )
    parser.add_argument(
        'spec_file',
        nargs='?',
        help='Path to JSON spec file (reads stdin if omitted)'
    )
    parser.add_argument(
        '--output-dir',
        default=None,
        help='Root output directory (default: directory containing this script\'s parent)'
    )

    args = parser.parse_args()

    # Determine output directory
    if args.output_dir:
        output_dir = os.path.abspath(args.output_dir)
    else:
        # Default: project root (parent of scripts/)
        output_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

    # Read spec
    if args.spec_file:
        try:
            with open(args.spec_file) as f:
                raw = f.read()
        except FileNotFoundError:
            print('ERROR: spec file not found: ' + args.spec_file, file=sys.stderr)
            sys.exit(1)
    else:
        raw = sys.stdin.read()

    if not raw.strip():
        print('ERROR: empty spec input', file=sys.stderr)
        sys.exit(1)

    # Parse and validate
    try:
        spec = parse_spec(raw)
    except ValueError as e:
        print('ERROR: invalid spec: ' + str(e), file=sys.stderr)
        sys.exit(1)

    # Forge
    try:
        paths = forge(spec, output_dir)
    except Exception as e:
        print('ERROR: forge failed: ' + str(e), file=sys.stderr)
        sys.exit(1)

    # Report
    print('Simulation Forge: generated sim_' + spec['name'])
    for p in paths:
        print('  ' + p)

    return 0


if __name__ == '__main__':
    sys.exit(main())
